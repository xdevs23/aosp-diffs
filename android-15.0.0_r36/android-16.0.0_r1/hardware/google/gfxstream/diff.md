```diff
diff --git a/.gitignore b/.gitignore
index d01643a43..712259b55 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
+/bazel-*
 /build*/
 /.vscode/*
 /objs/*
diff --git a/Android.bp b/Android.bp
index 212e9e090..385351ffb 100644
--- a/Android.bp
+++ b/Android.bp
@@ -45,7 +45,6 @@ cc_library_headers {
         "include",
         "host",
         "host/gl",
-        "host/gl/glestranslator/include",
         "host/vulkan",
         "utils/include",
     ],
@@ -149,8 +148,8 @@ cc_defaults {
             cflags: [
                 "-DGFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT=1",
             ],
-        }
-    }
+        },
+    },
 }
 
 cc_defaults {
@@ -163,17 +162,16 @@ cc_defaults {
         "-D_FILE_OFFSET_BITS=64",
         "-DVK_GFXSTREAM_STRUCTURE_TYPE_EXT",
         "-DGFXSTREAM_ENABLE_HOST_GLES=1",
-        "-Wno-unreachable-code-loop-increment",
-        "-Wno-unused-parameter",
+        "-Wall",
+        "-Werror",
+        "-Wextra",
+        "-Wformat",
+        "-Wshadow",
+        "-Wthread-safety",
         "-Wno-unused-function",
-        "-Wno-unused-variable",
-        "-Wno-ignored-qualifiers",
-        "-Wno-reorder-ctor",
-        "-Wno-mismatched-tags",
-        "-Wno-missing-field-initializers",
-        "-Wno-implicit-fallthrough",
+        "-Wno-unused-parameter",
         "-Wno-unused-private-field",
-        "-Wno-macro-redefined",
+        "-Wno-unused-variable",
     ],
     header_libs: [
         "gfxstream_headers",
diff --git a/BUILD.bazel b/BUILD.bazel
index 82a1d6adc..698fded39 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -1,3 +1,4 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
 load("@rules_license//rules:license.bzl", "license")
 load("@rules_license//rules:license_kind.bzl", "license_kind")
 
@@ -68,12 +69,11 @@ cc_library(
     name = "gfxstream-gl-host-common-headers",
     hdrs = glob([
         "include/**/*.h",
-        "include/**/*.hpp",
     ]),
     includes = ["include"],
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/aemu/base:aemu-base-headers",
-        "//hardware/google/aemu/host-common:aemu-host-common-headers",
+        "@aemu//base:aemu-base-headers",
+        "@aemu//host-common:aemu-host-common-headers",
     ],
 )
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 47c21f862..766589f52 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -44,6 +44,12 @@ add_definitions(-DGFXSTREAM_ENABLE_HOST_GLES=1)
 
 option(ASTC_CPU_DECODING "Enable decoding ASTC textures on the CPU" OFF)
 
+option(GFXSTREAM_ENABLE_HOST_TRACING "Enable Perfetto trace events on the host" OFF)
+if(GFXSTREAM_ENABLE_HOST_TRACING)
+    add_compile_definitions(GFXSTREAM_BUILD_WITH_TRACING)
+    add_compile_definitions(GFXSTREAM_BUILD_WITH_PERFETTO_SDK)
+endif()
+
 # For now the caller of the cmake script is responsible to create the angle_shader_translator
 # target.
 option(USE_ANGLE_SHADER_PARSER "Build with ANGLE shader parser." OFF)
diff --git a/MODULE.bazel b/MODULE.bazel
new file mode 100644
index 000000000..44a81d182
--- /dev/null
+++ b/MODULE.bazel
@@ -0,0 +1,10 @@
+module(
+    name = "gfxstream",
+    version = "0.0.1",
+)
+
+bazel_dep(name = "aemu", version = "0.0.1")
+bazel_dep(name = "googletest", version = "1.15.2", repo_name = "com_google_googletest")
+bazel_dep(name = "platforms", version = "0.0.11")
+bazel_dep(name = "rules_cc", version = "0.0.14")
+bazel_dep(name = "rules_license", version = "1.0.0")
diff --git a/README.md b/README.md
index e3e4eb162..9a39397bc 100644
--- a/README.md
+++ b/README.md
@@ -161,3 +161,18 @@ of the current design include:
     Mesa object contains a key to the hash table to get a gfxstream internal
     object (for example, `gfxstream_vk_device::internal_object`). Eventually,
     gfxstream objects will be phased out and Mesa objects used exclusively.
+
+# Project Ideas
+gfxstream is a first class open source project, and welcomes new contributors.
+There are many interesting projects available, for new and experienced software
+enthusiasts.  Some ideas include:
+
+1) New OS support (Windows, Haiku, MacOS) support for gfxstream guest
+2) Rewriting the gfxstream protocol using python templates and working
+   with other FOSS projects to de-duplicate
+3) Guided performance optimizations
+4) KVM or hypervisor integration to close gap between HW GPU virtualization
+5) Improving rutabaga integrations
+6) Improving display virtualization
+
+Please reach out to your local gfxstreamist today if you are interested!
diff --git a/cmake/SetWin32TestEnvironment.cmake.in b/cmake/SetWin32TestEnvironment.cmake.in
index 4d89050cf..bbd2939cc 100644
--- a/cmake/SetWin32TestEnvironment.cmake.in
+++ b/cmake/SetWin32TestEnvironment.cmake.in
@@ -5,6 +5,7 @@ set(envs
     "PATH=path_list_prepend:${BUILD_DIR}/lib64/gles_swiftshader"
     "PATH=path_list_prepend:${BUILD_DIR}/lib64/vulkan"
     "VK_ICD_FILENAMES=set:${BUILD_DIR}/lib64/vulkan/vk_swiftshader_icd.json"
+    "VK_DRIVER_FILES=set:${BUILD_DIR}/lib64/vulkan/vk_swiftshader_icd.json"
 )
 
 foreach(test_target ${ALL_TESTS})
diff --git a/common/end2end/GfxstreamEnd2EndVkTests.cpp b/common/end2end/GfxstreamEnd2EndVkTests.cpp
index 4624e4121..831d1b4b1 100644
--- a/common/end2end/GfxstreamEnd2EndVkTests.cpp
+++ b/common/end2end/GfxstreamEnd2EndVkTests.cpp
@@ -2164,6 +2164,7 @@ TEST_P(GfxstreamEnd2EndVkTest, MultiThreadedResetCommandBuffer) {
                 }
                 auto waitResult = device->waitForFences(*transferFence, VK_TRUE, AsVkTimeout(3s));
                 ASSERT_THAT(waitResult, IsVkSuccess());
+                device->resetFences(*transferFence);
             }
         });
     }
@@ -2211,6 +2212,36 @@ std::vector<TestParams> GenerateTestCases() {
     return cases;
 }
 
+TEST_P(GfxstreamEnd2EndVkTest, GetFenceStatusDefault) {
+    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
+        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
+    vkhpp::UniqueFence fence = device->createFenceUnique(vkhpp::FenceCreateInfo()).value;
+    auto status = device->getFenceStatus(*fence);
+    ASSERT_THAT(status, Eq(vkhpp::Result::eNotReady));
+}
+
+TEST_P(GfxstreamEnd2EndVkTest, GetFenceStatusCreateSignaled) {
+    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
+        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
+    vkhpp::FenceCreateInfo fenceCreateInfo = {
+        .flags = vkhpp::FenceCreateFlagBits::eSignaled,
+    };
+    vkhpp::UniqueFence fence = device->createFenceUnique(fenceCreateInfo).value;
+    auto status = device->getFenceStatus(*fence);
+    ASSERT_THAT(status, Eq(vkhpp::Result::eSuccess));
+}
+
+TEST_P(GfxstreamEnd2EndVkTest, WaitForFenceCreateSignaled) {
+    auto [instance, physicalDevice, device, queue, queueFamilyIndex] =
+        GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
+    vkhpp::FenceCreateInfo fenceCreateInfo = {
+        .flags = vkhpp::FenceCreateFlagBits::eSignaled,
+    };
+    vkhpp::UniqueFence fence = device->createFenceUnique(fenceCreateInfo).value;
+    auto status = device->waitForFences(*fence, VK_TRUE, AsVkTimeout(3s));
+    ASSERT_THAT(status, Eq(vkhpp::Result::eSuccess));
+}
+
 TEST_P(GfxstreamEnd2EndVkTest, UseDoubleQueuesAndSynchronizeCorrectly) {
     auto vk = GFXSTREAM_ASSERT(SetUpTypicalVkTestEnvironment());
     auto& [instance, physicalDevice, device, queue_dont_use, graphicsQueueFamilyIndex] = vk;
diff --git a/common/etc/BUILD.bazel b/common/etc/BUILD.bazel
index 3d723bed8..3b1f82c35 100644
--- a/common/etc/BUILD.bazel
+++ b/common/etc/BUILD.bazel
@@ -1,9 +1,10 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
+
 # Header Library
 cc_library(
     name = "gfxstream_etc_headers",
     hdrs = glob([
         "include/**/*.h",
-        "include/**/*.hpp",
     ]),
     includes = ["include"],
     visibility = ["//visibility:public"],
diff --git a/guest/Android.bp b/guest/Android.bp
index 2a3daaa06..780b5f237 100644
--- a/guest/Android.bp
+++ b/guest/Android.bp
@@ -26,6 +26,7 @@ cc_defaults {
     cflags: [
         "-DVK_GFXSTREAM_STRUCTURE_TYPE_EXT",
         "-DGFXSTREAM_ENABLE_GUEST_GOLDFISH=1",
+        "-Wno-cast-function-type-mismatch",
         "-Wno-missing-field-initializers",
         "-Wno-unused-parameter",
     ],
diff --git a/guest/BUILD.gn b/guest/BUILD.gn
deleted file mode 100644
index 01f586517..000000000
--- a/guest/BUILD.gn
+++ /dev/null
@@ -1,301 +0,0 @@
-# Copyright (C) 2023 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import("//build/python/python_action.gni")
-import("//build/python/python_binary.gni")
-import("mesa-gn/mesa.gni")
-
-config("common_config") {
-  defines = [
-    "LOG_TAG=\"gfxstream_vulkan\"",
-    "GOLDFISH_NO_GL",
-    "VK_GFXSTREAM_STRUCTURE_TYPE_EXT",
-    "VK_USE_PLATFORM_FUCHSIA",
-    "PAGE_SIZE=4096",
-  ]
-
-  if (is_debug) {
-    defines += [ "DEBUG=1" ]
-  }
-
-  include_dirs = [
-    "../common/opengl/include",
-    "../common/vulkan/include",
-    "android-emu",
-    "GoldfishAddressSpace/include",
-    "iostream/include",
-    "gralloc_cb/include",
-    "qemupipe/include",
-    "qemupipe/include-types",
-    "OpenglCodecCommon",
-    "OpenglCodecCommon/include",
-    "OpenglSystemCommon",
-    "renderControl_enc",
-    "vulkan_enc",
-    "$mesa_source_root/include",
-    "platform/include",
-  ]
-
-  if (target_os == "fuchsia") {
-    include_dirs += [ "fuchsia/include" ]
-  }
-
-  cflags_cc = [
-    "-Wno-conversion",
-    "-Wno-newline-eof",
-    "-Wno-pessimizing-move",
-    "-Wno-sign-compare",
-    "-Wno-unused-function",
-    "-Wno-unused-value",
-    "-Wno-unused-variable",
-    "-Wno-unused-but-set-parameter",
-    "-Wno-unused-but-set-variable",
-  ]
-}
-
-python_binary("vk_entrypoints_gen_bin") {
-  main_source = "$mesa_source_root/src/vulkan/util/vk_entrypoints_gen.py"
-
-  sources = [
-    "$mesa_source_root/src/vulkan/util/vk_entrypoints.py",
-    "$mesa_source_root/src/vulkan/util/vk_extensions.py",
-  ]
-  deps = [ "//third_party/mako" ]
-}
-
-config("gfxstream_vk_entrypoints_config") {
-  include_dirs = [ "$target_gen_dir" ]
-}
-
-python_action("gfxstream_vk_entrypoints") {
-  public_configs = [ ":gfxstream_vk_entrypoints_config" ]
-
-  binary_label = ":vk_entrypoints_gen_bin"
-
-  sources = [ mesa_vk_xml ]
-
-  h_file = "$target_gen_dir/gfxstream_vk_entrypoints.h"
-  c_file = "$target_gen_dir/gfxstream_vk_entrypoints.c"
-
-  outputs = [
-    h_file,
-    c_file,
-  ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml, root_build_dir),
-    "--proto",
-    "--weak",
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-    "--prefix",
-    "gfxstream_vk",
-    "--beta",
-    "false",
-  ]
-}
-
-# These sources require access to the Fuchsia goldfish protocols.
-source_set("goldfish_srcs") {
-  configs += [ ":common_config" ]
-
-  sources = [
-    "vulkan/gfxstream_vk_fuchsia.cpp",
-    "vulkan_enc/ResourceTracker.cpp",
-    "vulkan_enc/ResourceTracker.h",
-  ]
-
-  public_deps = [
-    "$mesa_build_root/src/vulkan/runtime",
-    "$mesa_build_root/src/vulkan/util",
-    "//sdk/fidl/fuchsia.hardware.goldfish:fuchsia.hardware.goldfish_cpp",
-    "//sdk/fidl/fuchsia.logger:fuchsia.logger_cpp",
-    "//sdk/fidl/fuchsia.sysmem:fuchsia.sysmem_cpp",
-    "//sdk/lib/syslog/structured_backend",
-    "//third_party/Vulkan-Headers:vulkan_headers",
-    "//zircon/system/ulib/async:async-cpp",
-    "//zircon/system/ulib/async-loop:async-loop-cpp",
-    "//zircon/system/ulib/trace:trace-with-static-engine",
-    "//zircon/system/ulib/trace-provider:trace-provider-with-static-engine",
-    "//zircon/system/ulib/zx",
-    "//zircon/system/ulib/zxio",
-  ]
-
-  deps = [ ":gfxstream_vk_entrypoints" ]
-
-  defines = [
-    "QEMU_PIPE_PATH=\"/loader-gpu-devices/class/goldfish-pipe/000\"",
-    "GOLDFISH_ADDRESS_SPACE_DEVICE_NAME=\"/loader-gpu-devices/class/goldfish-address-space/000\"",
-  ]
-}
-
-loadable_module("libvulkan_gfxstream") {
-  configs += [ ":common_config" ]
-
-  deps = [
-    ":gfxstream_vk_entrypoints",
-    "$mesa_build_root/src/vulkan/runtime",
-  ]
-
-  sources = [
-    "$target_gen_dir/gfxstream_vk_entrypoints.c",
-    "GoldfishAddressSpace/AddressSpaceStream.cpp",
-    "GoldfishAddressSpace/VirtioGpuAddressSpaceStream.cpp",
-    "OpenglCodecCommon/ChecksumCalculator.cpp",
-    "OpenglCodecCommon/ChecksumCalculator.h",
-    "OpenglCodecCommon/glUtils.cpp",
-    "OpenglCodecCommon/glUtils.h",
-    "OpenglSystemCommon/HostConnection.cpp",
-    "OpenglSystemCommon/HostConnection.h",
-    "OpenglSystemCommon/ProcessPipe.cpp",
-    "OpenglSystemCommon/ProcessPipe.h",
-    "OpenglSystemCommon/QemuPipeStream.cpp",
-    "OpenglSystemCommon/QemuPipeStream.h",
-    "OpenglSystemCommon/ThreadInfo.cpp",
-    "OpenglSystemCommon/ThreadInfo.h",
-    "OpenglSystemCommon/VirtioGpuPipeStream.cpp",
-    "android-emu/aemu/base/AlignedBuf.cpp",
-    "android-emu/aemu/base/AlignedBuf.h",
-    "android-emu/aemu/base/Allocator.h",
-    "android-emu/aemu/base/AndroidHealthMonitor.cpp",
-    "android-emu/aemu/base/AndroidHealthMonitor.h",
-    "android-emu/aemu/base/AndroidHealthMonitorConsumer.h",
-    "android-emu/aemu/base/AndroidHealthMonitorConsumerBasic.cpp",
-    "android-emu/aemu/base/AndroidHealthMonitorConsumerBasic.h",
-    "android-emu/aemu/base/Process.cpp",
-    "android-emu/aemu/base/Process.h",
-    "android-emu/aemu/base/Tracing.cpp",
-    "android-emu/aemu/base/Tracing.h",
-    "android-emu/aemu/base/files/MemStream.cpp",
-    "android-emu/aemu/base/files/MemStream.h",
-    "android-emu/aemu/base/files/Stream.cpp",
-    "android-emu/aemu/base/files/Stream.h",
-    "android-emu/aemu/base/files/StreamSerializing.cpp",
-    "android-emu/aemu/base/files/StreamSerializing.h",
-    "android-emu/aemu/base/fit/Defer.h",
-    "android-emu/aemu/base/fit/Function.h",
-    "android-emu/aemu/base/fit/FunctionInternal.h",
-    "android-emu/aemu/base/fit/Nullable.h",
-    "android-emu/aemu/base/fit/ThreadChecker.h",
-    "android-emu/aemu/base/fit/ThreadSafety.h",
-    "android-emu/aemu/base/fit/UtilityInternal.h",
-    "android-emu/aemu/base/ring_buffer.c",
-    "android-emu/aemu/base/synchronization/AndroidConditionVariable.h",
-    "android-emu/aemu/base/synchronization/AndroidLock.h",
-    "android-emu/aemu/base/synchronization/AndroidMessageChannel.cpp",
-    "android-emu/aemu/base/synchronization/AndroidMessageChannel.h",
-    "android-emu/aemu/base/testing/TestClock.h",
-    "android-emu/aemu/base/threads/AndroidFunctorThread.cpp",
-    "android-emu/aemu/base/threads/AndroidFunctorThread.h",
-    "android-emu/aemu/base/threads/AndroidThread.h",
-    "android-emu/aemu/base/threads/AndroidThreadStore.h",
-    "android-emu/aemu/base/threads/AndroidThreadTypes.h",
-    "android-emu/aemu/base/threads/AndroidThread_pthread.cpp",
-    "android-emu/aemu/base/threads/AndroidWorkPool.cpp",
-    "android-emu/aemu/base/threads/AndroidWorkPool.h",
-    "gralloc_cb/include/gralloc_cb_bp.h",
-    "platform/VirtGpu.cpp",
-    "platform/include/VirtGpu.h",
-    "qemupipe/include-types/qemu_pipe_types_bp.h",
-    "qemupipe/include/qemu_pipe_bp.h",
-    "qemupipe/qemu_pipe_common.cpp",
-    "qemupipe/qemu_pipe_guest.cpp",
-    "renderControl_enc/renderControl_enc.cpp",
-    "renderControl_enc/renderControl_enc.h",
-    "vulkan/gfxstream_vk_device.cpp",
-    "vulkan/gfxstream_vk_wsi_stub.cpp",
-    "vulkan_enc/CommandBufferStagingStream.cpp",
-    "vulkan_enc/CommandBufferStagingStream.h",
-    "vulkan_enc/DescriptorSetVirtualization.cpp",
-    "vulkan_enc/DescriptorSetVirtualization.h",
-    "vulkan_enc/HostVisibleMemoryVirtualization.cpp",
-    "vulkan_enc/HostVisibleMemoryVirtualization.h",
-    "vulkan_enc/Resources.cpp",
-    "vulkan_enc/Resources.h",
-    "vulkan_enc/Validation.cpp",
-    "vulkan_enc/Validation.h",
-    "vulkan_enc/VkEncoder.cpp",
-    "vulkan_enc/VkEncoder.h",
-    "vulkan_enc/VulkanHandleMapping.cpp",
-    "vulkan_enc/VulkanHandleMapping.h",
-    "vulkan_enc/VulkanStreamGuest.cpp",
-    "vulkan_enc/VulkanStreamGuest.h",
-    "vulkan_enc/func_table.cpp",
-    "vulkan_enc/gfxstream_vk_private.cpp",
-    "vulkan_enc/gfxstream_vk_private.h",
-    "vulkan_enc/goldfish_vk_counting_guest.cpp",
-    "vulkan_enc/goldfish_vk_counting_guest.h",
-    "vulkan_enc/goldfish_vk_deepcopy_guest.cpp",
-    "vulkan_enc/goldfish_vk_deepcopy_guest.h",
-    "vulkan_enc/goldfish_vk_extension_structs_guest.cpp",
-    "vulkan_enc/goldfish_vk_extension_structs_guest.h",
-    "vulkan_enc/goldfish_vk_marshaling_guest.cpp",
-    "vulkan_enc/goldfish_vk_marshaling_guest.h",
-    "vulkan_enc/goldfish_vk_reserved_marshaling_guest.cpp",
-    "vulkan_enc/goldfish_vk_reserved_marshaling_guest.h",
-    "vulkan_enc/goldfish_vk_transform_guest.cpp",
-    "vulkan_enc/goldfish_vk_transform_guest.h",
-    "vulkan_enc/vulkan_gfxstream.h",
-    "vulkan_enc/vulkan_gfxstream_structure_type.h",
-  ]
-
-  if (target_os == "fuchsia") {
-    sources -= [
-      "OpenglSystemCommon/QemuPipeStream.cpp",
-      "qemupipe/qemu_pipe_common.cpp",
-      "qemupipe/qemu_pipe_guest.cpp",
-    ]
-    sources += [
-      "OpenglSystemCommon/TraceProviderFuchsia.cpp",
-      "OpenglSystemCommon/TraceProviderFuchsia.h",
-      "fuchsia/fuchsia_stdio.cc",
-      "fuchsia/port.cc",
-      "fuchsia/service_connector.cc",
-      "platform/kumquat/VirtGpuKumquatStub.cpp",
-      "platform/fuchsia/FuchsiaVirtGpuBlob.cpp",
-      "platform/fuchsia/FuchsiaVirtGpuBlobMapping.cpp",
-      "platform/fuchsia/FuchsiaVirtGpuDevice.cpp",
-      "platform/fuchsia/os_dirent_fuchsia.cpp",
-    ]
-
-    include_dirs = [
-      "fuchsia/include",
-      "platform/include",
-      "//third_party/Vulkan-Headers/include",
-    ]
-
-    deps += [
-      ":goldfish_srcs",
-      "//sdk/fidl/fuchsia.logger:fuchsia.logger_cpp",
-      "//sdk/fidl/fuchsia.sysmem:fuchsia.sysmem_cpp",
-      "//src/graphics/lib/magma/src/libmagma",
-      "//src/zircon/lib/zircon",
-      "//zircon/system/ulib/trace:trace-with-static-engine",
-      "//zircon/system/ulib/zx",
-      "//zircon/system/ulib/zxio",
-    ]
-
-    public_deps = [ "//third_party/Vulkan-Headers:vulkan_headers" ]
-
-    # Vulkan ICDs on Fuchsia are only allowed to depend on (parts of) libc
-    # and libzircon, and no other shared libraries.
-    assert_no_deps = [
-      "//sdk/lib/fdio",
-      "//zircon/system/ulib/async-default",
-    ]
-  }
-}
diff --git a/guest/egl/Android.bp b/guest/egl/Android.bp
index 5e9669772..ccc8c5190 100644
--- a/guest/egl/Android.bp
+++ b/guest/egl/Android.bp
@@ -59,6 +59,7 @@ cc_library_shared {
         "-DEGL_EGLEXT_PROTOTYPES",
         "-DLOG_TAG=\"EGL_emulation\"",
         "-DWITH_GLES2",
+        "-Wno-cast-function-type-mismatch",
         "-Wno-gnu-designator",
     ],
     srcs: [
diff --git a/guest/magma/Android.bp b/guest/magma/Android.bp
deleted file mode 100644
index d9a7bbba6..000000000
--- a/guest/magma/Android.bp
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package {
-    // See: http://go/android-license-faq
-    default_applicable_licenses: ["hardware_google_gfxstream_license"],
-}
-
-cc_library_static {
-    name: "libmagma_android",
-    defaults: [
-        "libgfxstream_guest_cc_defaults",
-        "mesa_platform_virtgpu_defaults",
-    ],
-    header_libs: [
-        "libmagma_enc_headers",
-        "libmagma_headers",
-        "mesa_gfxstream_guest_iostream",
-        "mesa_gfxstream_aemu_headers",
-    ],
-    shared_libs: [
-        "libdrm",
-        "liblog",
-        "libOpenglCodecCommon",
-    ],
-    static_libs: [
-        "mesa_gfxstream_guest_android",
-        "mesa_goldfish_address_space",
-        "mesa_gfxstream_aemu",
-    ],
-    srcs: [
-        "magma.cpp",
-        "magma_enc_util.cpp",
-        "magma_enc/magma_enc.cpp",
-        "magma_enc/magma_entry.cpp",
-        "magma_enc/magma_stubs.cpp",
-        "magma_enc/magma_client_context.cpp",
-    ],
-    cflags: [
-        "-Wno-misleading-indentation",
-        "-Wno-unused-function",
-        "-Wno-unused-parameter",
-    ],
-}
diff --git a/guest/magma/magma_enc/Android.bp b/guest/magma/magma_enc/Android.bp
deleted file mode 100644
index f4b9e38e8..000000000
--- a/guest/magma/magma_enc/Android.bp
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package {
-    // See: http://go/android-license-faq
-    default_applicable_licenses: ["hardware_google_gfxstream_license"],
-}
-
-cc_library_headers {
-    name: "libmagma_enc_headers",
-    defaults: [
-        "libgfxstream_guest_cc_defaults",
-    ],
-    export_include_dirs: [
-        ".",
-    ],
-}
diff --git a/guest/mesa-gn/include/BUILD.gn b/guest/mesa-gn/include/BUILD.gn
deleted file mode 100644
index fbc4deafb..000000000
--- a/guest/mesa-gn/include/BUILD.gn
+++ /dev/null
@@ -1,49 +0,0 @@
-# Copyright 2024 Google, LLC
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-import("../mesa.gni")
-
-config("include_config") {
-  include_dirs = [ "$mesa_source_root/include" ]
-}
-
-config("vulkan_public_config") {
-  defines = [ "VK_USE_PLATFORM_FUCHSIA=1" ]
-}
-
-mesa_source_set("vulkan") {
-  public_configs = [
-    ":include_config",
-    ":vulkan_public_config",
-  ]
-
-  # Don't bother listing all the Vulkan headers
-  sources = [ "vulkan/vulkan.h" ]
-}
-
-mesa_source_set("c_compat") {
-  public_configs = [ ":include_config" ]
-  sources = [
-    "c99_alloca.h",
-    "c99_compat.h",
-    "no_extern_c.h",
-  ]
-}
diff --git a/guest/mesa-gn/mesa.gni b/guest/mesa-gn/mesa.gni
deleted file mode 100644
index 0a8322406..000000000
--- a/guest/mesa-gn/mesa.gni
+++ /dev/null
@@ -1,39 +0,0 @@
-# Copyright 2024 Google, LLC
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-mesa_build_root = "//third_party/gfxstream/src/guest/mesa-gn"
-mesa_source_root = "//third_party/gfxstream/src/guest/mesa"
-mesa_vk_xml = "$mesa_source_root/src/vulkan/registry/vk.xml"
-
-template("mesa_source_set") {
-  source_set(target_name) {
-    # Can't forward configs because doing so overwrites the default
-    # configs specified by the build system.
-    forward_variables_from(invoker, "*", [ "configs" ])
-    if (!defined(public_configs)) {
-      public_configs = []
-    }
-    public_configs += [ "$mesa_build_root/src:common_config" ]
-    if (defined(invoker.configs)) {
-      configs += invoker.configs
-    }
-  }
-}
diff --git a/guest/mesa-gn/src/BUILD.gn b/guest/mesa-gn/src/BUILD.gn
deleted file mode 100644
index 2b7312e1c..000000000
--- a/guest/mesa-gn/src/BUILD.gn
+++ /dev/null
@@ -1,83 +0,0 @@
-# Copyright 2024 Google, LLC
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-import("../mesa.gni")
-
-config("common_config") {
-  # Version file not present
-  mesa_version = "unknown"
-
-  defines = [
-    # Pretend to be Linux for now so we avoid the need to
-    # introduce DETECT_OS_FUCHSIA into mesa.
-    "DETECT_OS_LINUX=1",
-    "DETECT_OS_UNIX=1",
-    "HAVE_PROGRAM_INVOCATION_NAME=1",
-    "HAVE_ENDIAN_H=1",
-    "HAVE_PTHREAD=1",
-    "HAVE_STRUCT_TIMESPEC=1",
-    "HAVE_TIMESPEC_GET=1",
-    "HAVE_UNISTD_H=1",
-    "HAVE_DLFCN_H=1",
-    "HAVE___BUILTIN_BSWAP32=1",
-    "HAVE___BUILTIN_BSWAP64=1",
-    "HAVE___BUILTIN_CLZ=1",
-    "HAVE___BUILTIN_CLZLL=1",
-    "HAVE___BUILTIN_CTZ=1",
-    "HAVE___BUILTIN_EXPECT=1",
-    "HAVE___BUILTIN_FFS=1",
-    "HAVE___BUILTIN_FFSLL=1",
-    "HAVE___BUILTIN_POPCOUNT=1",
-    "HAVE___BUILTIN_POPCOUNTLL=1",
-    "HAVE___BUILTIN_UNREACHABLE=1",
-    "HAVE_FUNC_ATTRIBUTE_CONST=1",
-    "HAVE_FUNC_ATTRIBUTE_FLATTEN=1",
-    "HAVE_FUNC_ATTRIBUTE_FORMAT=1",
-    "HAVE_FUNC_ATTRIBUTE_MALLOC=1",
-    "HAVE_FUNC_ATTRIBUTE_PACKED=1",
-    "HAVE_FUNC_ATTRIBUTE_PURE=1",
-    "HAVE_FUNC_ATTRIBUTE_UNUSED=1",
-    "HAVE_FUNC_ATTRIBUTE_WARN_UNUSED_RESULT=1",
-    "HAVE_FUNC_ATTRIBUTE_NORETURN=1",
-    "HAVE_DLADDR=1",
-    "HAVE_DL_ITERATE_PHDR=1",
-    "PACKAGE_VERSION=\"$mesa_version\" ",
-    "_DEFAULT_SOURCE",
-    "_GNU_SOURCE=1",
-  ]
-
-  if (is_debug) {
-    defines += [ "DEBUG=1" ]
-  }
-
-  cflags = [
-    "-Wno-sign-compare",
-    "-Wno-unused-function",
-    "-Wno-extra-semi",
-    "-Wno-newline-eof",
-    "-Wno-tautological-constant-out-of-range-compare",
-    "-Wno-unknown-pragmas",
-    "-Wno-int-in-bool-context",
-    "-Wno-conversion",
-    "-Wno-deprecated-anon-enum-enum-conversion",
-    "-Wno-strict-prototypes",
-  ]
-}
diff --git a/guest/mesa-gn/src/c11/BUILD.gn b/guest/mesa-gn/src/c11/BUILD.gn
deleted file mode 100644
index d893c492e..000000000
--- a/guest/mesa-gn/src/c11/BUILD.gn
+++ /dev/null
@@ -1,33 +0,0 @@
-# Copyright 2024 Google, LLC
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-import("../../mesa.gni")
-
-c11 = "$mesa_source_root/src/c11"
-
-config("c11_config") {
-  include_dirs = [ "$mesa_source_root/src" ]
-}
-
-mesa_source_set("c11") {
-  configs = [ ":c11_config" ]
-  sources = [ "$c11/impl/time.c" ]
-}
diff --git a/guest/mesa-gn/src/util/BUILD.gn b/guest/mesa-gn/src/util/BUILD.gn
deleted file mode 100644
index 9c99c6e68..000000000
--- a/guest/mesa-gn/src/util/BUILD.gn
+++ /dev/null
@@ -1,66 +0,0 @@
-# Copyright 2024 Google, LLC
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-import("../../mesa.gni")
-
-util = "$mesa_source_root/src/util"
-
-config("util_public_config") {
-  include_dirs = [
-    "$mesa_source_root/src",
-    "$mesa_source_root/src/util",
-  ]
-}
-
-mesa_source_set("util") {
-  public_configs = [ ":util_public_config" ]
-  public_deps = [
-    "$mesa_build_root/include:c_compat",
-    "format",
-  ]
-  deps = [ "$mesa_build_root/src/c11" ]
-  sources = [
-    "$util/hash_table.c",
-    "$util/hash_table.h",
-    "$util/log.c",
-    "$util/log.h",
-    "$util/os_misc.c",
-    "$util/os_misc.h",
-    "$util/os_time.c",
-    "$util/os_time.h",
-    "$util/ralloc.c",
-    "$util/ralloc.h",
-    "$util/simple_mtx.c",
-    "$util/simple_mtx.h",
-    "$util/sparse_array.c",
-    "$util/sparse_array.h",
-    "$util/u_call_once.c",
-    "$util/u_call_once.h",
-    "$util/u_debug.c",
-    "$util/u_debug.h",
-    "$util/u_dynarray.c",
-    "$util/u_dynarray.h",
-    "$util/u_printf.c",
-    "$util/u_printf.h",
-    "$util/u_process.c",
-    "$util/u_process.h",
-  ]
-}
diff --git a/guest/mesa-gn/src/util/format/BUILD.gn b/guest/mesa-gn/src/util/format/BUILD.gn
deleted file mode 100644
index 7d38599e3..000000000
--- a/guest/mesa-gn/src/util/format/BUILD.gn
+++ /dev/null
@@ -1,183 +0,0 @@
-# Copyright 2024 Google, LLC
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-import("//build/python/python_binary.gni")
-import("../../../mesa.gni")
-
-format = "$mesa_source_root/src/util/format"
-
-config("format_config") {
-  include_dirs = [
-    "$format",
-    "$target_gen_dir",
-  ]
-}
-
-mesa_source_set("format") {
-  public_configs = [ "..:util_public_config" ]
-  configs = [ ":format_config" ]
-  public_deps = [ "$mesa_build_root/include:c_compat" ]
-  sources = [
-    "$format/u_format.c",
-    "$format/u_format.h",
-    "$format/u_format_bptc.c",
-    "$format/u_format_etc.c",
-    "$format/u_format_fxt1.c",
-    "$format/u_format_latc.c",
-    "$format/u_format_other.c",
-    "$format/u_format_rgtc.c",
-    "$format/u_format_s3tc.c",
-    "$format/u_format_tests.c",
-    "$format/u_format_yuv.c",
-    "$format/u_format_zs.c",
-    "$target_gen_dir/u_format_table.c",
-  ]
-  deps = [
-    ":u_format_pack_h",
-    ":u_format_table_c",
-  ]
-}
-
-# Executes a python script and writes its output to a file.
-#
-# Example
-#
-#   mesa_python_stdout_to_file_action("opcodes.c") {
-#     output = "opcodes.c"
-#     script = "opcodes_c.py"
-#     sources = [ "opcodes_lib.py" ]
-#     libraries = [ "//third_party/mako" ]
-#   }
-#
-# Parameters
-#
-#   script (required)
-#     The .py file that will be interpreted.
-#     Type: path
-#
-#   output (required)
-#     Path to the output file. Assumed to be relative to ${target_gen_dir}.
-#     Type: path
-#
-#   sources (optional)
-#     Extra .py source files script imports.
-#     Type: list(path)
-#     Default: empty list
-#
-#   libraries (optional)
-#     Paths to python_libraries script imports.
-#     Type: list(string)
-#     Default: empty list
-#
-#   args (optional)
-#     Arguments to pass to the script.
-#     Type: list(str)
-#     Default: empty list
-#
-#   deps
-#   inputs
-#   testonly
-#   visibility
-template("mesa_python_stdout_to_file_action") {
-  assert(defined(invoker.script), "script is required")
-  assert(defined(invoker.output), "output is required")
-
-  py_binary_target = "${target_name}_py_binary"
-  python_binary(py_binary_target) {
-    forward_variables_from(invoker,
-                           [
-                             "sources",
-                             "testonly",
-                           ])
-    main_source = invoker.script
-    if (defined(invoker.libraries)) {
-      deps = invoker.libraries
-    }
-    visibility = [ ":*" ]
-  }
-
-  action(target_name) {
-    forward_variables_from(invoker,
-                           [
-                             "testonly",
-                             "visibility",
-                             "inputs",
-                           ])
-
-    script = "gn_script_wrapper.sh"
-    outputs = [ "${target_gen_dir}/${invoker.output}" ]
-
-    py_binary = get_target_outputs(":${py_binary_target}")
-    assert(py_binary == [ py_binary[0] ],
-           "${py_binary_target} should only have one output")
-    py_binary = py_binary[0]
-    sources = [ py_binary ]
-
-    # Ensure scripts can import other scripts in the same directory
-    # Note - I'm not sure why the ../ is necessary.
-    python_path =
-        rebase_path(get_label_info(target_name, "dir") + "/..", root_build_dir)
-
-    args = [
-      rebase_path(python_exe_src, root_build_dir),
-
-      # TODO(jayzhuang): remove this arg after migrating mesa_python_action.
-      python_path,
-      rebase_path(outputs[0], root_build_dir),
-      rebase_path(py_binary, root_build_dir),
-    ]
-    if (defined(invoker.args)) {
-      args += invoker.args
-    }
-
-    deps = [ ":${py_binary_target}" ]
-    if (defined(invoker.deps)) {
-      deps += invoker.deps
-    }
-  }
-}
-
-u_format_csv = "$format/u_format.csv"
-
-mesa_python_stdout_to_file_action("u_format_pack_h") {
-  output = "u_format_pack.h"
-  script = "$format/u_format_table.py"
-  sources = [
-    "$format/u_format_pack.py",
-    "$format/u_format_parse.py",
-  ]
-  inputs = [ u_format_csv ]
-  args = [
-    rebase_path(u_format_csv, root_build_dir),
-    "--header",
-  ]
-}
-
-mesa_python_stdout_to_file_action("u_format_table_c") {
-  output = "u_format_table.c"
-  script = "$format/u_format_table.py"
-  sources = [
-    "$format/u_format_pack.py",
-    "$format/u_format_parse.py",
-  ]
-  inputs = [ u_format_csv ]
-  args = [ rebase_path(u_format_csv, root_build_dir) ]
-}
diff --git a/guest/mesa-gn/src/util/format/gn_script_wrapper.sh b/guest/mesa-gn/src/util/format/gn_script_wrapper.sh
deleted file mode 100755
index 0e4a98dff..000000000
--- a/guest/mesa-gn/src/util/format/gn_script_wrapper.sh
+++ /dev/null
@@ -1,29 +0,0 @@
-#!/usr/bin/env bash
-
-# Copyright 2020 The Fuchsia Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-# Executes the given python executable with PYTHONPATH set and captures
-# its output in a file. The first PYTHON_ARG should probably be the path
-# to a python script that writes something to stdout.
-# This is to let GN use the mesa python scripts that write headers to stdout,
-# and to support a custom PYTHONPATH.
-
-USAGE="Usage: $0 PYTHON_EXE PYTHONPATH OUT_FILE [PYTHON_ARGS...]"
-
-if [[ "$#" -lt "3" ]]; then
-    echo "${USAGE}" 1>&2;
-    exit 1
-fi
-
-PYTHON_EXE=${1}
-shift
-PYTHONPATH=${1}
-shift
-OUT=${1}
-shift
-
-# -S to decrease start-up time by not looking for site packages.
-env PYTHONPATH="${PYTHONPATH}" "${PYTHON_EXE}" -S "$@" > ${OUT}
-exit $?
diff --git a/guest/mesa-gn/src/vulkan/runtime/BUILD.gn b/guest/mesa-gn/src/vulkan/runtime/BUILD.gn
deleted file mode 100644
index b646e38ec..000000000
--- a/guest/mesa-gn/src/vulkan/runtime/BUILD.gn
+++ /dev/null
@@ -1,397 +0,0 @@
-# Copyright 2024 Google, LLC
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-import("//build/python/python_action.gni")
-import("//build/python/python_binary.gni")
-import("../../../mesa.gni")
-
-runtime = "$mesa_source_root/src/vulkan/runtime"
-
-config("config") {
-  include_dirs = [
-    "$target_gen_dir",
-    "$runtime",
-  ]
-
-  defines = [ "VK_NO_NIR=1" ]
-}
-
-mesa_source_set("runtime") {
-  public_configs = [ ":config" ]
-
-  public_deps = [
-    "$mesa_build_root/include:c_compat",
-    "$mesa_build_root/include:vulkan",
-  ]
-
-  deps = [
-    ":vk_cmd_enqueue_entrypoints",
-    ":vk_cmd_queue",
-    ":vk_common_entrypoints",
-    ":vk_dispatch_trampolines",
-    ":vk_format_info",
-    ":vk_physical_device_features",
-    ":vk_physical_device_properties",
-    "$mesa_build_root/src/util",
-    "$mesa_build_root/src/vulkan/util",
-  ]
-
-  sources = [
-    "$runtime/rmv/vk_rmv_common.c",
-    "$runtime/rmv/vk_rmv_common.h",
-    "$runtime/vk_buffer.c",
-    "$runtime/vk_buffer.h",
-    "$runtime/vk_buffer_view.c",
-    "$runtime/vk_buffer_view.h",
-    "$runtime/vk_cmd_copy.c",
-    "$runtime/vk_cmd_enqueue.c",
-    "$runtime/vk_command_buffer.c",
-    "$runtime/vk_command_buffer.h",
-    "$runtime/vk_command_pool.c",
-    "$runtime/vk_command_pool.h",
-    "$runtime/vk_debug_report.c",
-    "$runtime/vk_debug_report.h",
-    "$runtime/vk_debug_utils.c",
-    "$runtime/vk_debug_utils.h",
-    "$runtime/vk_deferred_operation.c",
-    "$runtime/vk_deferred_operation.h",
-    "$runtime/vk_descriptor_set_layout.c",
-    "$runtime/vk_descriptor_set_layout.h",
-    "$runtime/vk_descriptor_update_template.c",
-    "$runtime/vk_descriptor_update_template.h",
-    "$runtime/vk_descriptors.c",
-    "$runtime/vk_descriptors.h",
-    "$runtime/vk_device.c",
-    "$runtime/vk_device.h",
-    "$runtime/vk_device_memory.c",
-    "$runtime/vk_device_memory.h",
-    "$runtime/vk_fence.c",
-    "$runtime/vk_fence.h",
-    "$runtime/vk_framebuffer.c",
-    "$runtime/vk_framebuffer.h",
-    "$runtime/vk_graphics_state.c",
-    "$runtime/vk_graphics_state.h",
-    "$runtime/vk_image.c",
-    "$runtime/vk_image.h",
-    "$runtime/vk_instance.c",
-    "$runtime/vk_instance.h",
-    "$runtime/vk_log.c",
-    "$runtime/vk_log.h",
-    "$runtime/vk_object.c",
-    "$runtime/vk_object.h",
-    "$runtime/vk_physical_device.c",
-    "$runtime/vk_physical_device.h",
-    "$runtime/vk_query_pool.c",
-    "$runtime/vk_query_pool.h",
-    "$runtime/vk_queue.c",
-    "$runtime/vk_queue.h",
-    "$runtime/vk_render_pass.c",
-    "$runtime/vk_sampler.c",
-    "$runtime/vk_sampler.h",
-    "$runtime/vk_semaphore.c",
-    "$runtime/vk_semaphore.h",
-    "$runtime/vk_standard_sample_locations.c",
-    "$runtime/vk_standard_sample_locations.h",
-    "$runtime/vk_sync.c",
-    "$runtime/vk_sync.h",
-    "$runtime/vk_sync_binary.c",
-    "$runtime/vk_sync_binary.h",
-    "$runtime/vk_sync_dummy.c",
-    "$runtime/vk_sync_dummy.h",
-    "$runtime/vk_sync_timeline.c",
-    "$runtime/vk_sync_timeline.h",
-    "$runtime/vk_synchronization2.c",
-    "$target_gen_dir/vk_cmd_enqueue_entrypoints.c",
-    "$target_gen_dir/vk_cmd_enqueue_entrypoints.h",
-    "$target_gen_dir/vk_cmd_queue.c",
-    "$target_gen_dir/vk_cmd_queue.h",
-    "$target_gen_dir/vk_common_entrypoints.c",
-    "$target_gen_dir/vk_common_entrypoints.h",
-    "$target_gen_dir/vk_dispatch_trampolines.c",
-    "$target_gen_dir/vk_dispatch_trampolines.h",
-    "$target_gen_dir/vk_physical_device_features.c",
-  ]
-
-  configs = [ "//build/config:Wno-strict-prototypes" ]
-}
-
-python_binary("vk_cmd_queue_gen_bin") {
-  main_source = "$mesa_source_root/src/vulkan/util/vk_cmd_queue_gen.py"
-
-  sources = [
-    "$mesa_source_root/src/vulkan/util/vk_entrypoints.py",
-    "$mesa_source_root/src/vulkan/util/vk_extensions.py",
-  ]
-
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("vk_cmd_queue") {
-  binary_label = ":vk_cmd_queue_gen_bin"
-
-  h_file = "$target_gen_dir/vk_cmd_queue.h"
-  c_file = "$target_gen_dir/vk_cmd_queue.c"
-
-  outputs = [
-    h_file,
-    c_file,
-  ]
-
-  inputs = [
-    "$mesa_source_root/src/vulkan/util/vk_dispatch_table_gen.py",
-    "$mesa_source_root/src/vulkan/util/vk_extensions.py",
-    "$mesa_source_root/src/vulkan/util/vk_entrypoints.py",
-    mesa_vk_xml,
-  ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml),
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-    "--beta",
-    "false",
-  ]
-}
-
-python_binary("vk_entrypoints_gen_bin") {
-  main_source = "$mesa_source_root/src/vulkan/util/vk_entrypoints_gen.py"
-
-  sources = [
-    "$mesa_source_root/src/vulkan/util/vk_entrypoints.py",
-    "$mesa_source_root/src/vulkan/util/vk_extensions.py",
-  ]
-
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("vk_common_entrypoints") {
-  binary_label = ":vk_entrypoints_gen_bin"
-
-  h_file = "$target_gen_dir/vk_common_entrypoints.h"
-  c_file = "$target_gen_dir/vk_common_entrypoints.c"
-
-  outputs = [
-    h_file,
-    c_file,
-  ]
-
-  inputs = [
-    "$mesa_source_root/src/vulkan/util/vk_dispatch_table_gen.py",
-    "$mesa_source_root/src/vulkan/util/vk_extensions.py",
-    "$mesa_source_root/src/vulkan/util/vk_entrypoints.py",
-    mesa_vk_xml,
-  ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml),
-    "--proto",
-    "--weak",
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-    "--prefix",
-    "vk_common",
-    "--beta",
-    "false",
-  ]
-}
-
-python_action("vk_cmd_enqueue_entrypoints") {
-  binary_label = ":vk_entrypoints_gen_bin"
-
-  h_file = "$target_gen_dir/vk_cmd_enqueue_entrypoints.h"
-  c_file = "$target_gen_dir/vk_cmd_enqueue_entrypoints.c"
-
-  outputs = [
-    h_file,
-    c_file,
-  ]
-
-  inputs = [
-    "$mesa_source_root/src/vulkan/util/vk_dispatch_table_gen.py",
-    "$mesa_source_root/src/vulkan/util/vk_extensions.py",
-    "$mesa_source_root/src/vulkan/util/vk_entrypoints.py",
-    mesa_vk_xml,
-  ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml),
-    "--proto",
-    "--weak",
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-    "--prefix",
-    "vk_cmd_enqueue",
-    "--prefix",
-    "vk_cmd_enqueue_unless_primary",
-    "--beta",
-    "false",
-  ]
-}
-
-python_binary("vk_dispatch_trampolines_gen_bin") {
-  main_source =
-      "$mesa_source_root/src/vulkan/util/vk_dispatch_trampolines_gen.py"
-
-  sources = [
-    "$mesa_source_root/src/vulkan/util/vk_entrypoints.py",
-    "$mesa_source_root/src/vulkan/util/vk_extensions.py",
-  ]
-
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("vk_dispatch_trampolines") {
-  binary_label = ":vk_dispatch_trampolines_gen_bin"
-
-  h_file = "$target_gen_dir/vk_dispatch_trampolines.h"
-  c_file = "$target_gen_dir/vk_dispatch_trampolines.c"
-
-  outputs = [
-    h_file,
-    c_file,
-  ]
-
-  inputs = [
-    "$mesa_source_root/src/vulkan/util/vk_dispatch_table_gen.py",
-    "$mesa_source_root/src/vulkan/util/vk_extensions.py",
-    "$mesa_source_root/src/vulkan/util/vk_entrypoints.py",
-    mesa_vk_xml,
-  ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml),
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-    "--beta",
-    "false",
-  ]
-}
-
-python_binary("vk_physical_device_features_gen_bin") {
-  main_source =
-      "$mesa_source_root/src/vulkan/util/vk_physical_device_features_gen.py"
-
-  sources = [ "$mesa_source_root/src/vulkan/util/vk_extensions.py" ]
-
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("vk_physical_device_features") {
-  binary_label = ":vk_physical_device_features_gen_bin"
-
-  c_file = "$target_gen_dir/vk_physical_device_features.c"
-  h_file = "$target_gen_dir/vk_physical_device_features.h"
-
-  outputs = [
-    c_file,
-    h_file,
-  ]
-
-  inputs = [ mesa_vk_xml ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml),
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-    "--beta",
-    "false",
-  ]
-}
-
-python_binary("vk_physical_device_properties_gen_bin") {
-  main_source =
-      "$mesa_source_root/src/vulkan/util/vk_physical_device_properties_gen.py"
-
-  sources = [ "$mesa_source_root/src/vulkan/util/vk_extensions.py" ]
-
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("vk_physical_device_properties") {
-  binary_label = ":vk_physical_device_properties_gen_bin"
-
-  c_file = "$target_gen_dir/vk_physical_device_properties.c"
-  h_file = "$target_gen_dir/vk_physical_device_properties.h"
-
-  outputs = [
-    c_file,
-    h_file,
-  ]
-
-  inputs = [ mesa_vk_xml ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml),
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-    "--beta",
-    "false",
-  ]
-}
-
-python_binary("vk_format_info_gen_bin") {
-  main_source = "$mesa_source_root/src/vulkan/runtime/vk_format_info_gen.py"
-
-  sources = [ "$mesa_source_root/src/vulkan/util/vk_extensions.py" ]
-
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("vk_format_info") {
-  binary_label = ":vk_format_info_gen_bin"
-
-  c_file = "$target_gen_dir/vk_format_info.c"
-  h_file = "$target_gen_dir/vk_format_info.h"
-
-  outputs = [
-    c_file,
-    h_file,
-  ]
-
-  inputs = [ mesa_vk_xml ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml),
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-  ]
-}
diff --git a/guest/mesa-gn/src/vulkan/util/BUILD.gn b/guest/mesa-gn/src/vulkan/util/BUILD.gn
deleted file mode 100644
index 24b1a2eb7..000000000
--- a/guest/mesa-gn/src/vulkan/util/BUILD.gn
+++ /dev/null
@@ -1,201 +0,0 @@
-# Copyright 2024 Google, LLC
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-import("//build/python/python_action.gni")
-import("//build/python/python_binary.gni")
-import("../../../mesa.gni")
-
-util = "$mesa_source_root/src/vulkan/util"
-
-config("config_util") {
-  include_dirs = [
-    target_gen_dir,
-    util,
-  ]
-
-  defines = [ "VK_NO_NIR=1" ]
-}
-
-mesa_source_set("util") {
-  public_configs = [ ":config_util" ]
-
-  public_deps = [
-    "$mesa_build_root/include:c_compat",
-    "$mesa_build_root/include:vulkan",
-    "$mesa_build_root/src/util",
-  ]
-
-  sources = [
-    "$target_gen_dir/vk_dispatch_table.c",
-    "$target_gen_dir/vk_dispatch_table.h",
-    "$target_gen_dir/vk_enum_to_str.c",
-    "$target_gen_dir/vk_extensions.c",
-    "$target_gen_dir/vk_extensions.h",
-    "$util/vk_alloc.c",
-    "$util/vk_alloc.h",
-    "$util/vk_enum_to_str.h",
-    "$util/vk_format.c",
-    "$util/vk_format.h",
-    "$util/vk_util.c",
-    "$util/vk_util.h",
-  ]
-
-  deps = [
-    ":gen_enum_to_str",
-    ":vk_dispatch_table",
-    ":vk_extensions",
-    ":vk_struct_type_cast_header",
-  ]
-}
-
-python_binary("gen_enum_to_str_gen_bin") {
-  main_source = "$util/gen_enum_to_str.py"
-
-  sources = [ "$util/vk_extensions.py" ]
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("gen_enum_to_str") {
-  binary_label = ":gen_enum_to_str_gen_bin"
-
-  outputs = [
-    "$target_gen_dir/vk_enum_to_str.h",
-    "$target_gen_dir/vk_enum_to_str.c",
-    "$target_gen_dir/vk_enum_defines.h",
-  ]
-
-  inputs = [ mesa_vk_xml ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml, root_build_dir),
-    "--outdir",
-    rebase_path(target_gen_dir, root_build_dir),
-    "--beta",
-    "false",
-  ]
-}
-
-python_binary("vk_dispatch_table_gen_bin") {
-  main_source = "$util/vk_dispatch_table_gen.py"
-
-  sources = [
-    "$util/vk_entrypoints.py",
-    "$util/vk_extensions.py",
-  ]
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("vk_dispatch_table") {
-  binary_label = ":vk_dispatch_table_gen_bin"
-
-  h_file = "$target_gen_dir/vk_dispatch_table.h"
-  c_file = "$target_gen_dir/vk_dispatch_table.c"
-
-  outputs = [
-    h_file,
-    c_file,
-  ]
-
-  script = "$util/vk_dispatch_table_gen.py"
-
-  inputs = [
-    "$util/vk_extensions.py",
-    mesa_vk_xml,
-  ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml, root_build_dir),
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-    "--beta",
-    "false",
-  ]
-}
-
-python_binary("vk_extensions_gen_bin") {
-  main_source = "$util/vk_extensions_gen.py"
-
-  sources = [
-    "$util/vk_entrypoints.py",
-    "$util/vk_extensions.py",
-  ]
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("vk_extensions") {
-  binary_label = ":vk_extensions_gen_bin"
-
-  h_file = "$target_gen_dir/vk_extensions.h"
-  c_file = "$target_gen_dir/vk_extensions.c"
-
-  outputs = [
-    h_file,
-    c_file,
-  ]
-
-  inputs = [
-    "$util/vk_extensions.py",
-    mesa_vk_xml,
-  ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml, root_build_dir),
-    "--out-h",
-    rebase_path(h_file, root_build_dir),
-    "--out-c",
-    rebase_path(c_file, root_build_dir),
-  ]
-}
-
-python_binary("vk_struct_type_cast_gen_bin") {
-  main_source = "$util/vk_struct_type_cast_gen.py"
-
-  sources = [
-    "$util/vk_entrypoints.py",
-    "$util/vk_extensions.py",
-  ]
-  deps = [ "//third_party/mako" ]
-}
-
-python_action("vk_struct_type_cast_header") {
-  binary_label = ":vk_struct_type_cast_gen_bin"
-
-  outputs = [ "$target_gen_dir/vk_struct_type_cast.h" ]
-
-  inputs = [
-    "$util/vk_extensions.py",
-    mesa_vk_xml,
-  ]
-
-  args = [
-    "--xml",
-    rebase_path(mesa_vk_xml, root_build_dir),
-    "--outdir",
-    rebase_path("$target_gen_dir", root_build_dir),
-    "--beta",
-    "false",
-  ]
-}
diff --git a/guest/renderControl_enc/GfxStreamRenderControl.cpp b/guest/renderControl_enc/GfxStreamRenderControl.cpp
index bf7ca1e82..1d4ec0fe3 100644
--- a/guest/renderControl_enc/GfxStreamRenderControl.cpp
+++ b/guest/renderControl_enc/GfxStreamRenderControl.cpp
@@ -10,8 +10,10 @@
 #include "GfxStreamRenderControlConnection.h"
 
 #if defined(__ANDROID__)
+#include "android-base/file.h"
 #include "android-base/properties.h"
 #endif
+#include "aemu/base/Process.h"
 
 constexpr const auto kEglProp = "ro.hardware.egl";
 
@@ -119,6 +121,12 @@ int32_t renderControlInit(GfxStreamConnectionManager* mgr, void* vkInfo) {
 
         rcEnc->rcSetPuid(rcEnc, puid);
 
+        static constexpr const char kRcMetadataKeyProcessName[] = "process_name";
+        const std::string process_name = gfxstream::guest::getProcessName();
+        rcEnc->rcSetProcessMetadata(rcEnc, const_cast<char*>(kRcMetadataKeyProcessName),
+                                    const_cast<RenderControlByte*>(process_name.c_str()),
+                                    process_name.length() + 1);
+
         if (vkInfo) {
             rcEnc->setVulkanFeatureInfo(vkInfo);
         }
diff --git a/host/Android.bp b/host/Android.bp
index 0c9dab2c0..cabfe2351 100644
--- a/host/Android.bp
+++ b/host/Android.bp
@@ -34,6 +34,7 @@ cc_library_host_static {
         "VirtioGpuFrontendSnapshot.proto",
         "VirtioGpuRingBlobSnapshot.proto",
         "VirtioGpuResourceSnapshot.proto",
+        "VirtioGpuTimelinesSnapshot.proto",
     ],
 }
 
@@ -86,7 +87,6 @@ cc_defaults {
         "-Wno-unused-parameter",
         "-Wno-unused-variable",
         "-Wno-unused-function",
-        "-Wno-unreachable-code-loop-increment",
     ],
     header_libs: [
         "gfxstream_opengl_headers",
@@ -140,6 +140,7 @@ cc_defaults {
         "RendererImpl.cpp",
         "FrameBuffer.cpp",
         "GfxStreamAgents.cpp",
+        "GraphicsDriverLock.cpp",
         "virtio-gpu-gfxstream-renderer.cpp",
         "virtio-gpu-gfxstream-renderer-goldfish.cpp",
         "VirtioGpuContext.cpp",
@@ -324,3 +325,25 @@ cc_test_host {
         "general-tests",
     ],
 }
+
+// Run with `atest GfxstreamVirtioGpuTimelineTests`
+cc_test_host {
+    name: "GfxstreamVirtioGpuTimelineTests",
+    defaults: ["gfxstream_defaults"],
+    srcs: [
+        "VirtioGpuTimelinesTests.cpp",
+    ],
+    shared_libs: [
+        "libbase",
+        "libgfxstream_backend",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+    test_options: {
+        unit_test: true,
+    },
+    test_suites: [
+        "general-tests",
+    ],
+}
diff --git a/host/BUILD.bazel b/host/BUILD.bazel
index 34d41ecb4..dd8e636b6 100644
--- a/host/BUILD.bazel
+++ b/host/BUILD.bazel
@@ -1,3 +1,5 @@
+load("@rules_cc//cc:defs.bzl", "cc_binary", "cc_library", "cc_test", "objc_library")
+
 cc_library(
     name = "gfxstream_backend_headers",
     hdrs = glob(["include/**/*.h"]),
@@ -12,7 +14,6 @@ cc_library(
         "compressedTextureFormats/AstcCpuDecompressor.h",
     ] + glob([
         "*.h",
-        "gl/*.h",
     ]),
     copts = ["-fno-exceptions"],
     includes = ["."],
@@ -29,7 +30,7 @@ cc_library(
     includes = ["."],
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/gfxstream/common/etc:gfxstream_etc",
+        "//common/etc:gfxstream_etc",
     ],
 )
 
@@ -39,8 +40,8 @@ cc_test(
     copts = ["-fno-exceptions"],
     deps = [
         ":gfxstream-compressedTextures",
-        "//hardware/google/aemu/base:aemu-base",
-        "//hardware/google/aemu/host-common:logging",
+        "@aemu//base:aemu-base",
+        "@aemu//host-common:logging",
         "@com_google_googletest//:gtest_main",
     ],
 )
@@ -65,10 +66,13 @@ objc_library(
         "QuartzCore",
         "IOSurface",
     ],
+    target_compatible_with = [
+        "@platforms//os:macos",
+    ],
     deps = [
         ":gfxstream_backend_headers",
-        "//external/angle:angle-headers",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
+        "//:gfxstream-gl-host-common-headers",
+        "//common/opengl:gfxstream_opengl_headers",
     ],
 )
 
@@ -83,6 +87,7 @@ cc_library(
         "ExternalObjectManager.cpp",
         "FrameBuffer.cpp",
         "GfxStreamAgents.cpp",
+        "GraphicsDriverLock.cpp",
         "Hwc2.cpp",
         "PostWorker.cpp",
         "PostWorkerGl.cpp",
@@ -118,6 +123,7 @@ cc_library(
         "-fno-exceptions",
     ],
     defines = [
+        "QEMU_NEXT",
         "EMUGL_BUILD",
         "GFXSTREAM_ENABLE_HOST_GLES=1",
     ] + select({
@@ -134,29 +140,29 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         ":gfxstream_backend_headers",
-        "//hardware/google/aemu/base:aemu-base",
-        "//hardware/google/aemu/base:aemu-base-metrics",
-        "//hardware/google/aemu/host-common:aemu-host-common",
-        "//hardware/google/aemu/host-common:logging",
-        "//hardware/google/aemu/snapshot:aemu-snapshot",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
-        "//hardware/google/gfxstream/host/backend:gfxstream_backend",
-        "//hardware/google/gfxstream/host/features:gfxstream_features",
-        "//hardware/google/gfxstream/host/gl:EGL_translator_static",
-        "//hardware/google/gfxstream/host/gl:OpenGLESDispatch",
-        "//hardware/google/gfxstream/host/gl:gfxstream-gl-host-common",
-        "//hardware/google/gfxstream/host/gl:gfxstream-gl-server",
-        "//hardware/google/gfxstream/host/gl:gl-common-headers",
-        "//hardware/google/gfxstream/host/gl:gl_headers",
-        "//hardware/google/gfxstream/host/gl:gles1_dec",
-        "//hardware/google/gfxstream/host/gl:gles2_dec",
-        "//hardware/google/gfxstream/host/gl/glestranslator/GLES_CM:GLES_CM_translator_static",
-        "//hardware/google/gfxstream/host/magma:gfxstream-magma-server",
-        "//hardware/google/gfxstream/host/magma:magma-headers",
-        "//hardware/google/gfxstream/host/renderControl_dec",
-        "//hardware/google/gfxstream/host/tracing:gfxstream_host_tracing",
-        "//hardware/google/gfxstream/host/vulkan:gfxstream-vulkan-server",
+        "//:gfxstream-gl-host-common-headers",
+        "//host/apigen-codec-common",
+        "//host/backend:gfxstream_backend",
+        "//host/features:gfxstream_features",
+        "//host/gl:EGL_translator_static",
+        "//host/gl:OpenGLESDispatch",
+        "//host/gl:gfxstream-gl-host-common",
+        "//host/gl:gfxstream-gl-server",
+        "//host/gl:gl-common-headers",
+        "//host/gl:gl_headers",
+        "//host/gl:gles1_dec",
+        "//host/gl:gles2_dec",
+        "//host/gl/glestranslator/GLES_CM:GLES_CM_translator_static",
+        "//host/magma:gfxstream-magma-server",
+        "//host/magma:magma-headers",
+        "//host/renderControl_dec",
+        "//host/tracing:gfxstream_host_tracing",
+        "//host/vulkan:gfxstream-vulkan-server",
+        "@aemu//base:aemu-base",
+        "@aemu//base:aemu-base-metrics",
+        "@aemu//host-common:aemu-host-common",
+        "@aemu//host-common:logging",
+        "@aemu//snapshot:aemu-snapshot",
     ] + select({
         "@platforms//os:macos": [
             ":gfxstream_backend_static-darwin",
@@ -185,12 +191,12 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         ":gfxstream_backend_static",
-        "//hardware/google/aemu/base:aemu-base",
-        "//hardware/google/aemu/base:aemu-base-metrics",
-        "//hardware/google/aemu/host-common:aemu-host-common-product-feature-override",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/common/utils:gfxstream_common_utils",
-        "//hardware/google/gfxstream/host/gl:gfxstream-gl-host-common",
+        "//:gfxstream-gl-host-common-headers",
+        "//common/utils:gfxstream_common_utils",
+        "//host/gl:gfxstream-gl-host-common",
+        "@aemu//base:aemu-base",
+        "@aemu//base:aemu-base-metrics",
+        "@aemu//host-common:aemu-host-common-product-feature-override",
     ],
 )
 
@@ -205,12 +211,12 @@ cc_binary(
     visibility = ["//visibility:public"],
     deps = [
         ":gfxstream_backend_static",
-        "//hardware/google/aemu/base:aemu-base",
-        "//hardware/google/aemu/base:aemu-base-metrics",
-        "//hardware/google/aemu/host-common:aemu-host-common-product-feature-override",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/common/utils:gfxstream_common_utils",
-        "//hardware/google/gfxstream/host/gl:gfxstream-gl-host-common",
+        "//:gfxstream-gl-host-common-headers",
+        "//common/utils:gfxstream_common_utils",
+        "//host/gl:gfxstream-gl-host-common",
+        "@aemu//base:aemu-base",
+        "@aemu//base:aemu-base-metrics",
+        "@aemu//host-common:aemu-host-common-product-feature-override",
     ],
 )
 
diff --git a/host/Buffer.cpp b/host/Buffer.cpp
index b37c72906..909739718 100644
--- a/host/Buffer.cpp
+++ b/host/Buffer.cpp
@@ -23,7 +23,6 @@
 
 namespace gfxstream {
 
-using android::base::ManagedDescriptor;
 using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 
@@ -44,10 +43,10 @@ std::shared_ptr<Buffer> Buffer::create(gl::EmulationGl* emulationGl, vk::VkEmula
     }
 #endif
 
-    if (emulationVk && emulationVk->live) {
+    if (emulationVk) {
         const bool vulkanOnly = emulationGl == nullptr;
 
-        buffer->mBufferVk = vk::BufferVk::create(handle, size, vulkanOnly);
+        buffer->mBufferVk = vk::BufferVk::create(*emulationVk, handle, size, vulkanOnly);
         if (!buffer->mBufferVk) {
             ERR("Failed to initialize BufferVk.");
             return nullptr;
diff --git a/host/Buffer.h b/host/Buffer.h
index 8944768ab..91ffde9df 100644
--- a/host/Buffer.h
+++ b/host/Buffer.h
@@ -34,7 +34,7 @@ class EmulationGl;
 namespace gfxstream {
 namespace vk {
 class BufferVk;
-struct VkEmulation;
+class VkEmulation;
 }  // namespace vk
 }  // namespace gfxstream
 
@@ -63,8 +63,8 @@ class Buffer : public android::snapshot::LazySnapshotObj<Buffer> {
    private:
     Buffer(HandleType handle, uint64_t size);
 
-    const uint64_t mSize;
     const HandleType mHandle;
+    const uint64_t mSize;
 
 #if GFXSTREAM_ENABLE_HOST_GLES
     // If GL emulation is enabled.
diff --git a/host/CMakeLists.txt b/host/CMakeLists.txt
index 3d2f7f8c9..31a6358cf 100644
--- a/host/CMakeLists.txt
+++ b/host/CMakeLists.txt
@@ -53,7 +53,8 @@ set(stream-server-core-sources
     RenderWindow.cpp
     RenderLibImpl.cpp
     RendererImpl.cpp
-    FrameBuffer.cpp)
+    FrameBuffer.cpp
+    GraphicsDriverLock.cpp)
 if (APPLE)
     set(stream-server-core-platform-sources NativeSubWindow_cocoa.mm)
 elseif (WIN32)
@@ -125,9 +126,14 @@ endif()
 target_compile_options(
     gfxstream_backend_static
     PRIVATE
-    -Wno-invalid-offsetof
-    -Wno-free-nonheap-object
-    -Wno-attributes
+    -Wall
+    -Wextra
+    -Werror
+    -Wno-missing-field-initializers
+    -Wno-unused-parameter
+    -Wno-unused-private-field
+    -Wno-return-type-c-linkage
+    -Wno-extern-c-compat
     -DGFXSTREAM_ENABLE_HOST_GLES=1
     )
 
@@ -161,8 +167,14 @@ if (APPLE)
         LINK_FLAGS  "-undefined dynamic_lookup -flat_namespace")
 endif()
 
+if (LINUX)
+    # Make sure we embed an build-id that can be used by crashpad.
+    target_link_options(gfxstream_backend PRIVATE "LINKER:--build-id=sha1")
+endif()
+
+
 if(CONFIG_AEMU)
-    android_install_shared(gfxstream_backend)
+    android_install_shared_library(TARGET gfxstream_backend)
 else()
     install(
       TARGETS gfxstream_backend RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX} LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX})
@@ -308,7 +320,7 @@ endfunction()
         tests/CompositorVk_unittest.cpp
         tests/SwapChainStateVk_unittest.cpp
         tests/DisplayVk_unittest.cpp
-        tests/VirtioGpuTimelines_unittest.cpp
+        VirtioGpuTimelinesTests.cpp
         vulkan/vk_util_unittest.cpp
         vulkan/VkFormatUtils_unittest.cpp
         vulkan/VkQsriTimeline_unittest.cpp
diff --git a/host/ColorBuffer.cpp b/host/ColorBuffer.cpp
index f0d783412..345b74b3c 100644
--- a/host/ColorBuffer.cpp
+++ b/host/ColorBuffer.cpp
@@ -24,7 +24,6 @@
 #include "vulkan/VkCommonOperations.h"
 #include "FrameBuffer.h"
 
-using android::base::ManagedDescriptor;
 using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 
@@ -81,14 +80,15 @@ std::shared_ptr<ColorBuffer> ColorBuffer::create(gl::EmulationGl* emulationGl,
     }
 #endif
 
-    if (emulationVk && emulationVk->live) {
+    if (emulationVk) {
         const bool vulkanOnly = colorBuffer->mColorBufferGl == nullptr;
         uint32_t memoryProperty = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
         if (vulkanOnly && linear) {
             memoryProperty |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
         }
-        colorBuffer->mColorBufferVk = vk::ColorBufferVk::create(
-            handle, width, height, format, frameworkFormat, vulkanOnly, memoryProperty, stream);
+        colorBuffer->mColorBufferVk =
+            vk::ColorBufferVk::create(*emulationVk, handle, width, height, format, frameworkFormat,
+                                      vulkanOnly, memoryProperty, stream);
         if (!colorBuffer->mColorBufferVk) {
             if (emulationGl) {
                 // Historically, ColorBufferVk setup was deferred until the first actual Vulkan
@@ -101,17 +101,22 @@ std::shared_ptr<ColorBuffer> ColorBuffer::create(gl::EmulationGl* emulationGl,
     }
 
 #if GFXSTREAM_ENABLE_HOST_GLES
-    bool b271028352Workaround = emulationGl && strstr(emulationGl->getGlesRenderer().c_str(), "Intel");
-    bool vkSnapshotEnabled = emulationVk && emulationVk->features.VulkanSnapshots.enabled;
+    bool vkSnapshotEnabled = emulationVk && emulationVk->getFeatures().VulkanSnapshots.enabled;
 
     if ((!stream || vkSnapshotEnabled) && colorBuffer->mColorBufferGl && colorBuffer->mColorBufferVk &&
-        !b271028352Workaround && shouldAttemptExternalMemorySharing(frameworkFormat)) {
+        shouldAttemptExternalMemorySharing(frameworkFormat)) {
         colorBuffer->touch();
-        auto memoryExport = vk::exportColorBufferMemory(handle);
+        auto memoryExport = emulationVk->exportColorBufferMemory(handle);
         if (memoryExport) {
             if (colorBuffer->mColorBufferGl->importMemory(
-                    std::move(memoryExport->descriptor), memoryExport->size,
-                    memoryExport->dedicatedAllocation, memoryExport->linearTiling)) {
+#ifdef _WIN32
+                    ManagedDescriptor(static_cast<DescriptorType>(
+                        reinterpret_cast<void*>(memoryExport->handleInfo.handle))),
+#else
+                    ManagedDescriptor(static_cast<DescriptorType>(memoryExport->handleInfo.handle)),
+#endif
+                    memoryExport->size, memoryExport->dedicatedAllocation,
+                    memoryExport->linearTiling)) {
                 colorBuffer->mGlAndVkAreSharingExternalMemory = true;
             } else {
                 ERR("Failed to import memory to ColorBufferGl:%d", handle);
@@ -291,7 +296,7 @@ std::unique_ptr<BorrowedImageInfo> ColorBuffer::borrowForComposition(UsedApi api
             if (!mColorBufferVk) {
                 GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "ColorBufferGl not available.";
             }
-            return vk::borrowColorBufferForComposition(getHndl(), isTarget);
+            return mColorBufferVk->borrowForComposition(isTarget);
         }
     }
     GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Unimplemented";
@@ -312,7 +317,7 @@ std::unique_ptr<BorrowedImageInfo> ColorBuffer::borrowForDisplay(UsedApi api) {
             if (!mColorBufferVk) {
                 GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "ColorBufferGl not available.";
             }
-            return vk::borrowColorBufferForDisplay(getHndl());
+            return mColorBufferVk->borrowForDisplay();
         }
     }
     GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Unimplemented";
@@ -343,7 +348,7 @@ bool ColorBuffer::flushFromVk() {
         return true;
     }
     std::vector<uint8_t> contents;
-    if (!vk::readColorBufferToBytes(mHandle, &contents)) {
+    if (!mColorBufferVk->readToBytes(&contents)) {
         ERR("Failed to get VK contents for ColorBuffer:%d", mHandle);
         return false;
     }
@@ -433,42 +438,6 @@ bool ColorBuffer::invalidateForVk() {
     return true;
 }
 
-bool ColorBuffer::importNativeResource(void* nativeResource, uint32_t type, bool preserveContent) {
-    switch (type) {
-        case RESOURCE_TYPE_VK_EXT_MEMORY_HANDLE: {
-            if (mColorBufferGl) {
-                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-                    << "Native resource import type %s is invalid when GL emulation is active. "
-                    << "Use RESOURCE_TYPE_EGL_NATIVE_PIXMAP of RESOURCE_TYPE_EGL_IMAGE imports "
-                       "instead.";
-                return false;
-            } else if (!mColorBufferVk) {
-                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-                    << "Vulkan emulation must be available for RESOURCE_TYPE_VK_EXT_MEMORY_HANDLE "
-                       "import.";
-                return false;
-            }
-            return mColorBufferVk->importExtMemoryHandle(nativeResource, type, preserveContent);
-        }
-        default:
-            GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-                << "Unrecognized type for ColorBuffer::importNativeResource.";
-            return false;
-    }
-}
-
-int ColorBuffer::waitSync() {
-    if (mColorBufferGl) {
-        return -1;
-    }
-
-    if (!mColorBufferVk) {
-        return -1;
-    }
-
-    return mColorBufferVk->waitSync();
-}
-
 std::optional<BlobDescriptorInfo> ColorBuffer::exportBlob() {
     if (!mColorBufferVk) {
         return std::nullopt;
@@ -546,14 +515,6 @@ void ColorBuffer::glOpReadbackAsync(GLuint buffer, bool readbackBgra) {
     mColorBufferGl->readbackAsync(buffer, readbackBgra);
 }
 
-bool ColorBuffer::glOpImportEglImage(void* image, bool preserveContent) {
-    if (!mColorBufferGl) {
-        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "ColorBufferGl not available.";
-    }
-
-    return mColorBufferGl->importEglImage(image, preserveContent);
-}
-
 bool ColorBuffer::glOpImportEglNativePixmap(void* pixmap, bool preserveContent) {
     if (!mColorBufferGl) {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "ColorBufferGl not available.";
diff --git a/host/ColorBuffer.h b/host/ColorBuffer.h
index c5cc53a42..ea6a0257e 100644
--- a/host/ColorBuffer.h
+++ b/host/ColorBuffer.h
@@ -40,7 +40,7 @@ class EmulationGl;
 namespace gfxstream {
 namespace vk {
 class ColorBufferVk;
-struct VkEmulation;
+class VkEmulation;
 }  // namespace vk
 }  // namespace gfxstream
 
@@ -92,9 +92,7 @@ class ColorBuffer : public android::snapshot::LazySnapshotObj<ColorBuffer> {
     bool flushFromVkBytes(const void* bytes, size_t bytesSize);
     bool invalidateForGl();
     bool invalidateForVk();
-    bool importNativeResource(void* nativeResource, uint32_t type, bool preserveContent);
 
-    int waitSync();
     std::optional<BlobDescriptorInfo> exportBlob();
 
 #if GFXSTREAM_ENABLE_HOST_GLES
@@ -105,7 +103,6 @@ class ColorBuffer : public android::snapshot::LazySnapshotObj<ColorBuffer> {
     bool glOpBindToRenderbuffer();
     void glOpReadback(unsigned char* img, bool readbackBgra);
     void glOpReadbackAsync(GLuint buffer, bool readbackBgra);
-    bool glOpImportEglImage(void* image, bool preserveContent);
     bool glOpImportEglNativePixmap(void* pixmap, bool preserveContent);
     void glOpSwapYuvTexturesAndUpdate(GLenum format, GLenum type, FrameworkFormat frameworkFormat,
                                       GLuint* textures);
diff --git a/host/ExternalObjectManager.cpp b/host/ExternalObjectManager.cpp
index 94f858f57..734276bb1 100644
--- a/host/ExternalObjectManager.cpp
+++ b/host/ExternalObjectManager.cpp
@@ -15,8 +15,6 @@
 
 #include <utility>
 
-using android::base::ManagedDescriptor;
-
 namespace gfxstream {
 
 static ExternalObjectManager* sMapping() {
@@ -35,13 +33,13 @@ void ExternalObjectManager::addMapping(uint32_t ctxId, uint64_t blobId, void* ad
     };
 
     auto key = std::make_pair(ctxId, blobId);
-    std::lock_guard<std::mutex> lock(mLock);
+    std::lock_guard<std::mutex> lock(mMutex);
     mHostMemInfos.insert(std::make_pair(key, info));
 }
 
 std::optional<HostMemInfo> ExternalObjectManager::removeMapping(uint32_t ctxId, uint64_t blobId) {
     auto key = std::make_pair(ctxId, blobId);
-    std::lock_guard<std::mutex> lock(mLock);
+    std::lock_guard<std::mutex> lock(mMutex);
     auto found = mHostMemInfos.find(key);
     if (found != mHostMemInfos.end()) {
         std::optional<HostMemInfo> ret = found->second;
@@ -53,25 +51,28 @@ std::optional<HostMemInfo> ExternalObjectManager::removeMapping(uint32_t ctxId,
 }
 
 void ExternalObjectManager::addBlobDescriptorInfo(uint32_t ctxId, uint64_t blobId,
-                                                  ManagedDescriptor descriptor, uint32_t handleType,
-                                                  uint32_t caching,
+                                                  ManagedDescriptor descriptor,
+                                                  uint32_t streamHandleType, uint32_t caching,
                                                   std::optional<VulkanInfo> vulkanInfoOpt) {
     struct BlobDescriptorInfo info = {
-        .descriptor = std::move(descriptor),
-        .handleType = handleType,
+        .descriptorInfo =
+            {
+                .descriptor = std::move(descriptor),
+                .streamHandleType = streamHandleType,
+            },
         .caching = caching,
         .vulkanInfoOpt = vulkanInfoOpt,
     };
 
     auto key = std::make_pair(ctxId, blobId);
-    std::lock_guard<std::mutex> lock(mLock);
+    std::lock_guard<std::mutex> lock(mMutex);
     mBlobDescriptorInfos.insert(std::make_pair(key, std::move(info)));
 }
 
 std::optional<BlobDescriptorInfo> ExternalObjectManager::removeBlobDescriptorInfo(uint32_t ctxId,
                                                                                   uint64_t blobId) {
     auto key = std::make_pair(ctxId, blobId);
-    std::lock_guard<std::mutex> lock(mLock);
+    std::lock_guard<std::mutex> lock(mMutex);
     auto found = mBlobDescriptorInfos.find(key);
     if (found != mBlobDescriptorInfos.end()) {
         std::optional<BlobDescriptorInfo> ret = std::move(found->second);
@@ -84,21 +85,21 @@ std::optional<BlobDescriptorInfo> ExternalObjectManager::removeBlobDescriptorInf
 
 void ExternalObjectManager::addSyncDescriptorInfo(uint32_t ctxId, uint64_t syncId,
                                                   ManagedDescriptor descriptor,
-                                                  uint32_t handleType) {
-    struct SyncDescriptorInfo info = {
+                                                  uint32_t streamHandleType) {
+    SyncDescriptorInfo info = {
         .descriptor = std::move(descriptor),
-        .handleType = handleType,
+        .streamHandleType = streamHandleType,
     };
 
     auto key = std::make_pair(ctxId, syncId);
-    std::lock_guard<std::mutex> lock(mLock);
+    std::lock_guard<std::mutex> lock(mMutex);
     mSyncDescriptorInfos.insert(std::make_pair(key, std::move(info)));
 }
 
 std::optional<SyncDescriptorInfo> ExternalObjectManager::removeSyncDescriptorInfo(uint32_t ctxId,
                                                                                   uint64_t syncId) {
     auto key = std::make_pair(ctxId, syncId);
-    std::lock_guard<std::mutex> lock(mLock);
+    std::lock_guard<std::mutex> lock(mMutex);
     auto found = mSyncDescriptorInfos.find(key);
     if (found != mSyncDescriptorInfos.end()) {
         std::optional<SyncDescriptorInfo> ret = std::move(found->second);
@@ -109,4 +110,23 @@ std::optional<SyncDescriptorInfo> ExternalObjectManager::removeSyncDescriptorInf
     return std::nullopt;
 }
 
+void ExternalObjectManager::addResourceExternalHandleInfo(
+    uint32_t resHandle, const ExternalHandleInfo& externalHandleInfo) {
+    std::lock_guard<std::mutex> lock(mMutex);
+    mResourceExternalHandleInfos.insert(std::make_pair(resHandle, externalHandleInfo));
+}
+
+std::optional<ExternalHandleInfo> ExternalObjectManager::removeResourceExternalHandleInfo(
+    uint32_t resHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
+    auto found = mResourceExternalHandleInfos.find(resHandle);
+    if (found != mResourceExternalHandleInfos.end()) {
+        std::optional<ExternalHandleInfo> ret = found->second;
+        mResourceExternalHandleInfos.erase(found);
+        return ret;
+    }
+
+    return std::nullopt;
+}
+
 }  // namespace gfxstream
diff --git a/host/ExternalObjectManager.h b/host/ExternalObjectManager.h
index 4c901ade4..ff02ff544 100644
--- a/host/ExternalObjectManager.h
+++ b/host/ExternalObjectManager.h
@@ -23,6 +23,7 @@
 
 #include "aemu/base/Compiler.h"
 #include "aemu/base/ManagedDescriptor.hpp"
+#include "aemu/base/ThreadAnnotations.h"
 
 // A global mapping from opaque host memory IDs to host virtual
 // addresses/sizes.  This is so that the guest doesn't have to know the host
@@ -34,6 +35,7 @@
 // address space device, though there are possible other consumers of this, so
 // it becomes a global object. It exports methods into VmOperations.
 
+using android::base::DescriptorType;
 using android::base::ManagedDescriptor;
 
 namespace gfxstream {
@@ -45,15 +47,27 @@ namespace gfxstream {
 #define MAP_CACHE_UNCACHED 0x02
 #define MAP_CACHE_WC 0x03
 
-#define STREAM_MEM_HANDLE_TYPE_OPAQUE_FD 0x1
-#define STREAM_MEM_HANDLE_TYPE_DMABUF 0x2
-#define STREAM_MEM_HANDLE_TYPE_OPAQUE_WIN32 0x3
-#define STREAM_MEM_HANDLE_TYPE_SHM 0x4
-#define STREAM_MEM_HANDLE_TYPE_ZIRCON 0x5
-#define STREAM_FENCE_HANDLE_TYPE_OPAQUE_FD 0x6
-#define STREAM_FENCE_HANDLE_TYPE_SYNC_FD 0x7
-#define STREAM_FENCE_HANDLE_TYPE_OPAQUE_WIN32 0x8
-#define STREAM_FENCE_HANDLE_TYPE_ZIRCON 0x9
+#define STREAM_HANDLE_TYPE_MEM_OPAQUE_FD 0x1
+#define STREAM_HANDLE_TYPE_MEM_DMABUF 0x2
+#define STREAM_HANDLE_TYPE_MEM_OPAQUE_WIN32 0x3
+#define STREAM_HANDLE_TYPE_MEM_SHM 0x4
+#define STREAM_HANDLE_TYPE_MEM_ZIRCON 0x5
+
+#define STREAM_HANDLE_TYPE_SIGNAL_OPAQUE_FD 0x10
+#define STREAM_HANDLE_TYPE_SIGNAL_SYNC_FD 0x20
+#define STREAM_HANDLE_TYPE_SIGNAL_OPAQUE_WIN32 0x30
+#define STREAM_HANDLE_TYPE_SIGNAL_ZIRCON 0x40
+#define STREAM_HANDLE_TYPE_SIGNAL_EVENT_FD 0x50
+
+#define STREAM_HANDLE_TYPE_PLATFORM_SCREEN_BUFFER_QNX 0x01000000
+#define STREAM_HANDLE_TYPE_PLATFORM_EGL_NATIVE_PIXMAP 0x02000000
+
+typedef int64_t ExternalHandleType;
+
+struct ExternalHandleInfo {
+    ExternalHandleType handle;
+    uint32_t streamHandleType;
+};
 
 // A struct describing the information about host memory associated
 // with a host memory id. Used with virtio-gpu-next.
@@ -62,6 +76,11 @@ struct HostMemInfo {
     uint32_t caching;
 };
 
+struct GenericDescriptorInfo {
+    ManagedDescriptor descriptor;
+    uint32_t streamHandleType;
+};
+
 struct VulkanInfo {
     uint32_t memoryIndex;
     uint8_t deviceUUID[16];
@@ -69,16 +88,12 @@ struct VulkanInfo {
 };
 
 struct BlobDescriptorInfo {
-    ManagedDescriptor descriptor;
-    uint32_t handleType;
+    GenericDescriptorInfo descriptorInfo;
     uint32_t caching;
     std::optional<VulkanInfo> vulkanInfoOpt;
 };
 
-struct SyncDescriptorInfo {
-    ManagedDescriptor descriptor;
-    uint32_t handleType;
-};
+using SyncDescriptorInfo = GenericDescriptorInfo;
 
 class ExternalObjectManager {
    public:
@@ -90,14 +105,18 @@ class ExternalObjectManager {
     std::optional<HostMemInfo> removeMapping(uint32_t ctx_id, uint64_t blobId);
 
     void addBlobDescriptorInfo(uint32_t ctx_id, uint64_t blobId, ManagedDescriptor descriptor,
-                               uint32_t handleType, uint32_t caching,
+                               uint32_t streamHandleType, uint32_t caching,
                                std::optional<VulkanInfo> vulkanInfoOpt);
     std::optional<BlobDescriptorInfo> removeBlobDescriptorInfo(uint32_t ctx_id, uint64_t blobId);
 
     void addSyncDescriptorInfo(uint32_t ctx_id, uint64_t syncId, ManagedDescriptor descriptor,
-                               uint32_t handleType);
+                               uint32_t streamHandleType);
     std::optional<SyncDescriptorInfo> removeSyncDescriptorInfo(uint32_t ctx_id, uint64_t syncId);
 
+    void addResourceExternalHandleInfo(uint32_t resHandle,
+                                       const ExternalHandleInfo& externalHandleInfo);
+    std::optional<ExternalHandleInfo> removeResourceExternalHandleInfo(uint32_t resHandle);
+
    private:
     // Only for pairs of std::hash-able types for simplicity.
     // You can of course template this struct to allow other hash functions
@@ -113,12 +132,16 @@ class ExternalObjectManager {
         }
     };
 
-    std::mutex mLock;
-    std::unordered_map<std::pair<uint32_t, uint64_t>, HostMemInfo, pair_hash> mHostMemInfos;
+    std::mutex mMutex;
+    std::unordered_map<std::pair<uint32_t, uint64_t>, HostMemInfo, pair_hash> mHostMemInfos
+        GUARDED_BY(mMutex);
     std::unordered_map<std::pair<uint32_t, uint64_t>, BlobDescriptorInfo, pair_hash>
-        mBlobDescriptorInfos;
+        mBlobDescriptorInfos GUARDED_BY(mMutex);
     std::unordered_map<std::pair<uint32_t, uint64_t>, SyncDescriptorInfo, pair_hash>
-        mSyncDescriptorInfos;
+        mSyncDescriptorInfos GUARDED_BY(mMutex);
+    std::unordered_map<uint32_t, ExternalHandleInfo> mResourceExternalHandleInfos
+        GUARDED_BY(mMutex);
+
     DISALLOW_COPY_ASSIGN_AND_MOVE(ExternalObjectManager);
 };
 
diff --git a/host/FrameBuffer.cpp b/host/FrameBuffer.cpp
index c320cef21..789c8b7f5 100644
--- a/host/FrameBuffer.cpp
+++ b/host/FrameBuffer.cpp
@@ -59,6 +59,7 @@
 #include "host-common/logging.h"
 #include "host-common/misc.h"
 #include "host-common/opengl/misc.h"
+#include "host-common/emugl_vm_operations.h"
 #include "host-common/vm_operations.h"
 #include "render-utils/MediaNative.h"
 #include "vulkan/DisplayVk.h"
@@ -69,7 +70,6 @@
 namespace gfxstream {
 
 using android::base::AutoLock;
-using android::base::ManagedDescriptor;
 using android::base::MetricEventVulkanOutOfMemory;
 using android::base::Stream;
 using android::base::WorkerProcessingResult;
@@ -104,8 +104,8 @@ using gl::YUVConverter;
 using gl::YUVPlane;
 #endif
 
-using gfxstream::vk::AstcEmulationMode;
-using gfxstream::vk::VkEmulationFeatures;
+using vk::AstcEmulationMode;
+using vk::VkEmulation;
 
 // static std::string getTimeStampString() {
 //     const time_t timestamp = android::base::getUnixTimeUs();
@@ -171,18 +171,13 @@ struct InitializedGlobals {
 };
 
 bool postOnlyOnMainThread() {
-#ifdef __APPLE__
+#if defined(__APPLE__) && !defined(QEMU_NEXT)
     return true;
 #else
     return false;
 #endif
 }
 
-AstcEmulationMode getAstcEmulationMode() {
-    return AstcEmulationMode::Gpu;
-//    return AstcEmulationMode::Cpu;
-}
-
 }  // namespace
 
 // |sInitialized| caches the initialized framebuffer state - this way
@@ -315,7 +310,6 @@ bool FrameBuffer::initialize(int width, int height, gfxstream::host::FeatureSet
     // used by underlying EGL driver might become invalid,
     // preventing new contexts from being created that share
     // against those contexts.
-    vk::VkEmulation* vkEmu = nullptr;
     vk::VulkanDispatch* vkDispatch = nullptr;
     if (fb->m_features.Vulkan.enabled) {
         vkDispatch = vk::vkDispatch(false /* not for testing */);
@@ -351,21 +345,31 @@ bool FrameBuffer::initialize(int width, int height, gfxstream::host::FeatureSet
                         description);
                     return future;
                 },
+#ifdef CONFIG_AEMU
+            .registerVulkanInstance =
+                [fb = fb.get()](uint64_t id, const char* appName) {
+                    fb->registerVulkanInstance(id, appName);
+                },
+            .unregisterVulkanInstance =
+                [fb = fb.get()](uint64_t id) { fb->unregisterVulkanInstance(id); },
+#endif
         };
-        vkEmu = vk::createGlobalVkEmulation(vkDispatch, callbacks, fb->m_features);
-        if (!vkEmu) {
+        fb->m_emulationVk = vk::VkEmulation::create(vkDispatch, callbacks, fb->m_features);
+        if (fb->m_emulationVk) {
+            vk::VkDecoderGlobalState::initialize(fb->m_emulationVk.get());
+        } else {
             ERR("Failed to initialize global Vulkan emulation. Disable the Vulkan support.");
         }
-        fb->m_emulationVk = vkEmu;
     }
-    if (vkEmu) {
+    if (fb->m_emulationVk) {
         fb->m_vulkanEnabled = true;
         if (fb->m_features.VulkanNativeSwapchain.enabled) {
-            fb->m_vkInstance = vkEmu->instance;
+            fb->m_vkInstance = fb->m_emulationVk->getInstance();
         }
-        if (vkEmu->instanceSupportsPhysicalDeviceIDProperties) {
-            INFO("Supports id properties, got a vulkan device UUID");
-            memcpy(fb->m_vulkanUUID.data(), vkEmu->deviceInfo.idProps.deviceUUID, VK_UUID_SIZE);
+
+        auto vulkanUuidOpt = fb->m_emulationVk->getDeviceUuid();
+        if (vulkanUuidOpt) {
+            fb->m_vulkanUUID = *vulkanUuidOpt;
         } else {
             WARN("Doesn't support id properties, no vulkan device UUID");
         }
@@ -385,66 +389,39 @@ bool FrameBuffer::initialize(int width, int height, gfxstream::host::FeatureSet
     fb->m_useVulkanComposition = fb->m_features.GuestVulkanOnly.enabled ||
                                  fb->m_features.VulkanNativeSwapchain.enabled;
 
-    std::unique_ptr<VkEmulationFeatures> vkEmulationFeatures =
-        std::make_unique<VkEmulationFeatures>(VkEmulationFeatures{
-            .glInteropSupported = false,  // Set later.
-            .deferredCommands =
-                android::base::getEnvironmentVariable("ANDROID_EMU_VK_DISABLE_DEFERRED_COMMANDS")
-                    .empty(),
-            .createResourceWithRequirements =
-                android::base::getEnvironmentVariable(
-                    "ANDROID_EMU_VK_DISABLE_USE_CREATE_RESOURCES_WITH_REQUIREMENTS")
-                    .empty(),
-            .useVulkanComposition = fb->m_useVulkanComposition,
-            .useVulkanNativeSwapchain = fb->m_features.VulkanNativeSwapchain.enabled,
-            .guestRenderDoc = std::move(renderDocMultipleVkInstances),
-            .astcLdrEmulationMode = AstcEmulationMode::Gpu,
-            .enableEtc2Emulation = true,
-            .enableYcbcrEmulation = false,
-            .guestVulkanOnly = fb->m_features.GuestVulkanOnly.enabled,
-            .useDedicatedAllocations = false,  // Set later.
-        });
+    vk::VkEmulation::Features vkEmulationFeatures = {
+        .glInteropSupported = false,  // Set later.
+        .deferredCommands =
+            android::base::getEnvironmentVariable("ANDROID_EMU_VK_DISABLE_DEFERRED_COMMANDS")
+                .empty(),
+        .createResourceWithRequirements =
+            android::base::getEnvironmentVariable(
+                "ANDROID_EMU_VK_DISABLE_USE_CREATE_RESOURCES_WITH_REQUIREMENTS")
+                .empty(),
+        .useVulkanComposition = fb->m_useVulkanComposition,
+        .useVulkanNativeSwapchain = fb->m_features.VulkanNativeSwapchain.enabled,
+        .guestRenderDoc = std::move(renderDocMultipleVkInstances),
+        .astcLdrEmulationMode = AstcEmulationMode::Gpu,
+        .enableEtc2Emulation = true,
+        .enableYcbcrEmulation = false,
+        .guestVulkanOnly = fb->m_features.GuestVulkanOnly.enabled,
+        .useDedicatedAllocations = false,  // Set later.
+    };
 
     //
     // Cache the GL strings so we don't have to think about threading or
     // current-context when asked for them.
     //
-    bool useVulkanGraphicsDiagInfo =
-        vkEmu && fb->m_features.VulkanNativeSwapchain.enabled && fb->m_features.GuestVulkanOnly.enabled;
+    bool useVulkanGraphicsDiagInfo = fb->m_emulationVk &&
+                                     fb->m_features.VulkanNativeSwapchain.enabled &&
+                                     fb->m_features.GuestVulkanOnly.enabled;
 
     if (useVulkanGraphicsDiagInfo) {
-        fb->m_graphicsAdapterVendor = vkEmu->deviceInfo.driverVendor;
-        fb->m_graphicsAdapterName = vkEmu->deviceInfo.physdevProps.deviceName;
-
-        uint32_t vkVersion = vkEmu->vulkanInstanceVersion;
-
-        std::stringstream versionStringBuilder;
-        versionStringBuilder << "Vulkan " << VK_API_VERSION_MAJOR(vkVersion) << "."
-                             << VK_API_VERSION_MINOR(vkVersion) << "."
-                             << VK_API_VERSION_PATCH(vkVersion) << " "
-                             << vkEmu->deviceInfo.driverVendor << " "
-                             << vkEmu->deviceInfo.driverVersion;
-        fb->m_graphicsApiVersion = versionStringBuilder.str();
-
-        std::stringstream instanceExtensionsStringBuilder;
-        for (auto& ext : vkEmu->instanceExtensions) {
-            if (instanceExtensionsStringBuilder.tellp() != 0) {
-                instanceExtensionsStringBuilder << " ";
-            }
-            instanceExtensionsStringBuilder << ext.extensionName;
-        }
-
-        fb->m_graphicsApiExtensions = instanceExtensionsStringBuilder.str();
-
-        std::stringstream deviceExtensionsStringBuilder;
-        for (auto& ext : vkEmu->deviceInfo.extensions) {
-            if (deviceExtensionsStringBuilder.tellp() != 0) {
-                deviceExtensionsStringBuilder << " ";
-            }
-            deviceExtensionsStringBuilder << ext.extensionName;
-        }
-
-        fb->m_graphicsDeviceExtensions = deviceExtensionsStringBuilder.str();
+        fb->m_graphicsAdapterVendor = fb->m_emulationVk->getGpuVendor();
+        fb->m_graphicsAdapterName = fb->m_emulationVk->getGpuName();
+        fb->m_graphicsApiVersion = fb->m_emulationVk->getGpuVersionString();
+        fb->m_graphicsApiExtensions = fb->m_emulationVk->getInstanceExtensionsString();
+        fb->m_graphicsDeviceExtensions = fb->m_emulationVk->getDeviceExtensionsString();
     } else if (fb->m_emulationGl) {
 #if GFXSTREAM_ENABLE_HOST_GLES
         fb->m_graphicsAdapterVendor = fb->m_emulationGl->getGlesVendor();
@@ -470,7 +447,7 @@ bool FrameBuffer::initialize(int width, int height, gfxstream::host::FeatureSet
     bool vulkanInteropSupported = true;
     // First, if the VkEmulation instance doesn't support ext memory capabilities,
     // it won't support uuids.
-    if (!vkEmu || !vkEmu->instanceSupportsPhysicalDeviceIDProperties) {
+    if (!fb->m_emulationVk || !fb->m_emulationVk->supportsPhysicalDeviceIDProperties()) {
         vulkanInteropSupported = false;
     }
     if (!fb->m_emulationGl) {
@@ -487,9 +464,10 @@ bool FrameBuffer::initialize(int width, int height, gfxstream::host::FeatureSet
 #endif
     }
     // TODO: 0-copy gl interop on swiftshader vk
-    if (android::base::getEnvironmentVariable("ANDROID_EMU_VK_ICD") == "swiftshader") {
+    if (android::base::getEnvironmentVariable("ANDROID_EMU_VK_ICD") == "lavapipe"
+            || android::base::getEnvironmentVariable("ANDROID_EMU_VK_ICD") == "swiftshader") {
         vulkanInteropSupported = false;
-        GL_LOG("vk icd swiftshader, disable interop");
+        GL_LOG("vk icd software rendering, disable interop");
     }
 
     fb->m_vulkanInteropSupported = vulkanInteropSupported;
@@ -499,27 +477,29 @@ bool FrameBuffer::initialize(int width, int height, gfxstream::host::FeatureSet
     if (vulkanInteropSupported && fb->m_emulationGl && fb->m_emulationGl->isMesa()) {
         // Mesa currently expects dedicated allocations for external memory sharing
         // between GL and VK. See b/265186355.
-        vkEmulationFeatures->useDedicatedAllocations = true;
+        vkEmulationFeatures.useDedicatedAllocations = true;
     }
 #endif
 
     GL_LOG("glvk interop final: %d", fb->m_vulkanInteropSupported);
-    vkEmulationFeatures->glInteropSupported = fb->m_vulkanInteropSupported;
-    if (fb->m_features.Vulkan.enabled) {
-        vk::initVkEmulationFeatures(std::move(vkEmulationFeatures));
-        if (vkEmu && vkEmu->displayVk) {
-            fb->m_displayVk = vkEmu->displayVk.get();
+    vkEmulationFeatures.glInteropSupported = fb->m_vulkanInteropSupported;
+    if (fb->m_emulationVk && fb->m_features.Vulkan.enabled) {
+        fb->m_emulationVk->initFeatures(std::move(vkEmulationFeatures));
+
+        auto* display = fb->m_emulationVk->getDisplay();
+        if (display) {
+            fb->m_displayVk = display;
             fb->m_displaySurfaceUsers.push_back(fb->m_displayVk);
         }
     }
 
-    if (fb->m_useVulkanComposition) {
-        if (!vkEmu->compositorVk) {
+    if (fb->m_emulationVk && fb->m_useVulkanComposition) {
+        fb->m_compositor = fb->m_emulationVk->getCompositor();
+        if (!fb->m_compositor) {
             ERR("Failed to get CompositorVk from VkEmulation.");
             return false;
         }
         GL_LOG("Performing composition using CompositorVk.");
-        fb->m_compositor = vkEmu->compositorVk.get();
     } else {
         GL_LOG("Performing composition using CompositorGl.");
 #if GFXSTREAM_ENABLE_HOST_GLES
@@ -677,7 +657,12 @@ FrameBuffer::~FrameBuffer() {
     }
 #endif
 
-    vk::teardownGlobalVkEmulation();
+    if (m_emulationGl) {
+        m_emulationGl.reset();
+    }
+    if (m_emulationVk) {
+        m_emulationVk.reset();
+    }
 
     sInitialized.store(false, std::memory_order_relaxed);
 }
@@ -986,11 +971,9 @@ bool FrameBuffer::setupSubWindow(FBNativeWindowType p_window,
         if (m_subWin) {
             m_nativeWindow = p_window;
 
-
-
             if (m_displayVk) {
-                m_displaySurface =
-                    vk::createDisplaySurface(m_subWin, m_windowWidth * dpr, m_windowHeight * dpr);
+                m_displaySurface = m_emulationVk->createDisplaySurface(
+                    m_subWin, m_windowWidth * dpr, m_windowHeight * dpr);
             } else if (m_emulationGl) {
 #if GFXSTREAM_ENABLE_HOST_GLES
                 m_displaySurface = m_emulationGl->createWindowSurface(m_windowWidth * dpr,
@@ -1055,7 +1038,8 @@ bool FrameBuffer::setupSubWindow(FBNativeWindowType p_window,
             m_windowHeight = wh;
 
             {
-                auto watchdog = WATCHDOG_BUILDER(m_healthMonitor.get(), "Moving subwindow").build();
+                auto moveWatchdog =
+                    WATCHDOG_BUILDER(m_healthMonitor.get(), "Moving subwindow").build();
                 success = moveSubWindow(m_nativeWindow, m_subWin, m_x, m_y, m_windowWidth,
                                         m_windowHeight, dpr);
             }
@@ -1085,9 +1069,9 @@ bool FrameBuffer::setupSubWindow(FBNativeWindowType p_window,
                     postImpl(m_lastPostedColorBuffer,
                         [](std::shared_future<void> waitForGpu) {}, false);
                 } else {
-                    Post postCmd;
-                    postCmd.cmd = PostCmd::Clear;
-                    sendPostWorkerCmd(std::move(postCmd));
+                    Post clearCmd;
+                    clearCmd.cmd = PostCmd::Clear;
+                    sendPostWorkerCmd(std::move(clearCmd));
                 }
             }
             m_windowContentFullWidth = fbw;
@@ -1167,7 +1151,7 @@ bool FrameBuffer::isFormatSupported(GLenum format) {
         supported &= m_emulationGl->isFormatSupported(format);
     }
     if (m_emulationVk) {
-        supported &= vk::isFormatSupported(format);
+        supported &= m_emulationVk->isFormatSupported(format);
     }
     return supported;
 }
@@ -1181,13 +1165,14 @@ HandleType FrameBuffer::createColorBuffer(int p_width,
     sweepColorBuffersLocked();
     AutoLock colorBufferMapLock(m_colorBufferMapLock);
 
-    return createColorBufferWithHandleLocked(p_width, p_height, p_internalFormat, p_frameworkFormat,
-                                             genHandle_locked());
+    return createColorBufferWithResourceHandleLocked(p_width, p_height, p_internalFormat,
+                                                     p_frameworkFormat, genHandle_locked());
 }
 
-void FrameBuffer::createColorBufferWithHandle(int p_width, int p_height, GLenum p_internalFormat,
-                                              FrameworkFormat p_frameworkFormat, HandleType handle,
-                                              bool p_linear) {
+void FrameBuffer::createColorBufferWithResourceHandle(int p_width, int p_height,
+                                                      GLenum p_internalFormat,
+                                                      FrameworkFormat p_frameworkFormat,
+                                                      HandleType handle, bool p_linear) {
     {
         AutoLock mutex(m_lock);
         sweepColorBuffersLocked();
@@ -1202,18 +1187,19 @@ void FrameBuffer::createColorBufferWithHandle(int p_width, int p_height, GLenum
             GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER));
         }
 
-        createColorBufferWithHandleLocked(p_width, p_height, p_internalFormat, p_frameworkFormat,
-                                          handle, p_linear);
+        createColorBufferWithResourceHandleLocked(p_width, p_height, p_internalFormat,
+                                                  p_frameworkFormat, handle, p_linear);
     }
 }
 
-HandleType FrameBuffer::createColorBufferWithHandleLocked(int p_width, int p_height,
-                                                          GLenum p_internalFormat,
-                                                          FrameworkFormat p_frameworkFormat,
-                                                          HandleType handle, bool p_linear) {
-    ColorBufferPtr cb =
-        ColorBuffer::create(m_emulationGl.get(), m_emulationVk, p_width, p_height, p_internalFormat,
-                            p_frameworkFormat, handle, nullptr /*stream*/, p_linear);
+HandleType FrameBuffer::createColorBufferWithResourceHandleLocked(int p_width, int p_height,
+                                                                  GLenum p_internalFormat,
+                                                                  FrameworkFormat p_frameworkFormat,
+                                                                  HandleType handle,
+                                                                  bool p_linear) {
+    ColorBufferPtr cb = ColorBuffer::create(m_emulationGl.get(), m_emulationVk.get(), p_width,
+                                            p_height, p_internalFormat, p_frameworkFormat, handle,
+                                            nullptr /*stream*/, p_linear);
     if (cb.get() == nullptr) {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
             << "Failed to create ColorBuffer:" << handle << " format:" << p_internalFormat
@@ -1254,10 +1240,10 @@ HandleType FrameBuffer::createColorBufferWithHandleLocked(int p_width, int p_hei
 HandleType FrameBuffer::createBuffer(uint64_t p_size, uint32_t memoryProperty) {
     AutoLock mutex(m_lock);
     AutoLock colorBufferMapLock(m_colorBufferMapLock);
-    return createBufferWithHandleLocked(p_size, genHandle_locked(), memoryProperty);
+    return createBufferWithResourceHandleLocked(p_size, genHandle_locked(), memoryProperty);
 }
 
-void FrameBuffer::createBufferWithHandle(uint64_t size, HandleType handle) {
+void FrameBuffer::createBufferWithResourceHandle(uint64_t size, HandleType handle) {
     AutoLock mutex(m_lock);
     AutoLock colorBufferMapLock(m_colorBufferMapLock);
 
@@ -1266,17 +1252,17 @@ void FrameBuffer::createBufferWithHandle(uint64_t size, HandleType handle) {
             << "Buffer already exists with handle " << handle;
     }
 
-    createBufferWithHandleLocked(size, handle, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
+    createBufferWithResourceHandleLocked(size, handle, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
 }
 
-HandleType FrameBuffer::createBufferWithHandleLocked(int p_size, HandleType handle,
-                                                     uint32_t memoryProperty) {
+HandleType FrameBuffer::createBufferWithResourceHandleLocked(int p_size, HandleType handle,
+                                                             uint32_t memoryProperty) {
     if (m_buffers.count(handle) != 0) {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
             << "Buffer already exists with handle " << handle;
     }
 
-    BufferPtr buffer(Buffer::create(m_emulationGl.get(), m_emulationVk, p_size, handle));
+    BufferPtr buffer(Buffer::create(m_emulationGl.get(), m_emulationVk.get(), p_size, handle));
     if (!buffer) {
         ERR("Create buffer failed.\n");
         return 0;
@@ -1302,7 +1288,7 @@ int FrameBuffer::openColorBuffer(HandleType p_colorbuffer) {
         c = m_colorbuffers.find(p_colorbuffer);
         if (c == m_colorbuffers.end()) {
             // bad colorbuffer handle
-            ERR("FB: openColorBuffer cb handle %#x not found", p_colorbuffer);
+            ERR("FB: openColorBuffer cb handle %d not found", p_colorbuffer);
             return -1;
         }
         c->second.refcount++;
@@ -1808,17 +1794,6 @@ bool FrameBuffer::postImplSync(HandleType p_colorbuffer, bool needLockAndBind, b
 
 AsyncResult FrameBuffer::postImpl(HandleType p_colorbuffer, Post::CompletionCallback callback,
                                   bool needLockAndBind, bool repaint) {
-    std::unique_ptr<RecursiveScopedContextBind> bind;
-    if (needLockAndBind) {
-        m_lock.lock();
-#if GFXSTREAM_ENABLE_HOST_GLES
-        if (m_emulationGl) {
-            bind = std::make_unique<RecursiveScopedContextBind>(getPbufferSurfaceContextHelper());
-        }
-#endif
-    }
-    AsyncResult ret = AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
-
     ColorBufferPtr colorBuffer = nullptr;
     {
         AutoLock colorBufferMapLock(m_colorBufferMapLock);
@@ -1830,8 +1805,22 @@ AsyncResult FrameBuffer::postImpl(HandleType p_colorbuffer, Post::CompletionCall
         }
     }
     if (!colorBuffer) {
-        goto EXIT;
+        return AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
+    }
+
+    std::optional<AutoLock> lock;
+#if GFXSTREAM_ENABLE_HOST_GLES
+    std::optional<RecursiveScopedContextBind> bind;
+#endif
+    if (needLockAndBind) {
+        lock.emplace(m_lock);
+#if GFXSTREAM_ENABLE_HOST_GLES
+        if (m_emulationGl) {
+            bind.emplace(getPbufferSurfaceContextHelper());
+        }
+#endif
     }
+    AsyncResult ret = AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
 
     m_lastPostedColorBuffer = p_colorbuffer;
 
@@ -1869,51 +1858,45 @@ AsyncResult FrameBuffer::postImpl(HandleType p_colorbuffer, Post::CompletionCall
     //
     // Send framebuffer (without FPS overlay) to callback
     //
-    if (m_onPost.size() == 0) {
-        goto DEC_REFCOUNT_AND_EXIT;
-    }
-    for (auto& iter : m_onPost) {
-        ColorBufferPtr cb;
-        if (iter.first == 0) {
-            cb = colorBuffer;
-        } else {
-            uint32_t colorBuffer;
-            if (getDisplayColorBuffer(iter.first, &colorBuffer) < 0) {
-                ERR("Failed to get color buffer for display %d, skip onPost", iter.first);
-                continue;
-            }
+    if (!m_onPost.empty()) {
+        for (auto& iter : m_onPost) {
+            ColorBufferPtr cb;
+            if (iter.first == 0) {
+                cb = colorBuffer;
+            } else {
+                uint32_t displayColorBufferHandle = 0;
+                if (getDisplayColorBuffer(iter.first, &displayColorBufferHandle) < 0) {
+                    ERR("Failed to get color buffer for display %d, skip onPost", iter.first);
+                    continue;
+                }
 
-            cb = findColorBuffer(colorBuffer);
-            if (!cb) {
-                ERR("Failed to find colorbuffer %d, skip onPost", colorBuffer);
-                continue;
+                cb = findColorBuffer(displayColorBufferHandle);
+                if (!cb) {
+                    ERR("Failed to find ColorBuffer %d, skip onPost", displayColorBufferHandle);
+                    continue;
+                }
             }
-        }
 
-        if (asyncReadbackSupported()) {
-            ensureReadbackWorker();
-            const auto status = m_readbackWorker->doNextReadback(
-                iter.first, cb.get(), iter.second.img, repaint, iter.second.readBgra);
-            if (status == ReadbackWorker::DoNextReadbackResult::OK_READY_FOR_READ) {
+            if (asyncReadbackSupported()) {
+                ensureReadbackWorker();
+                const auto status = m_readbackWorker->doNextReadback(
+                    iter.first, cb.get(), iter.second.img, repaint, iter.second.readBgra);
+                if (status == ReadbackWorker::DoNextReadbackResult::OK_READY_FOR_READ) {
+                    doPostCallback(iter.second.img, iter.first);
+                }
+            } else {
+    #if GFXSTREAM_ENABLE_HOST_GLES
+                cb->glOpReadback(iter.second.img, iter.second.readBgra);
+    #endif
                 doPostCallback(iter.second.img, iter.first);
             }
-        } else {
-#if GFXSTREAM_ENABLE_HOST_GLES
-            cb->glOpReadback(iter.second.img, iter.second.readBgra);
-#endif
-            doPostCallback(iter.second.img, iter.first);
         }
     }
-DEC_REFCOUNT_AND_EXIT:
+
     if (!m_subWin) {  // m_subWin is supposed to be false
         decColorBufferRefCountLocked(p_colorbuffer);
     }
 
-EXIT:
-    if (needLockAndBind) {
-        bind.reset();
-        m_lock.unlock();
-    }
     return ret;
 }
 
@@ -2107,7 +2090,7 @@ int FrameBuffer::getScreenshot(unsigned int nChannels, unsigned int* width, unsi
     int needed =
         useSnipping ? (nChannels * rect.size.w * rect.size.h) : (nChannels * (*width) * (*height));
 
-    if (*cPixels < needed) {
+    if (*cPixels < (size_t)needed) {
         *cPixels = needed;
         return -2;
     }
@@ -2120,7 +2103,7 @@ int FrameBuffer::getScreenshot(unsigned int nChannels, unsigned int* width, unsi
     // Transform the x, y coordinates given the rotation.
     // Assume (0, 0) represents the top left corner of the screen.
     if (useSnipping) {
-        int x, y;
+        int x = 0, y = 0;
         switch (desiredRotation) {
             case SKIN_ROTATION_0:
                 x = rect.pos.x;
@@ -2368,7 +2351,7 @@ void FrameBuffer::onSave(Stream* stream, const android::snapshot::ITextureSaverP
 
     // TODO(b/309858017): remove if when ready to bump snapshot version
     if (m_features.VulkanSnapshots.enabled) {
-        AutoLock mutex(m_procOwnedResourcesLock);
+        AutoLock procResourceLock(m_procOwnedResourcesLock);
         stream->putBe64(m_procOwnedResources.size());
         for (const auto& element : m_procOwnedResources) {
             stream->putBe64(element.first);
@@ -2572,7 +2555,8 @@ bool FrameBuffer::onLoad(Stream* stream,
         m_guestManagedColorBufferLifetime = stream->getByte();
         loadCollection(
             stream, &m_colorbuffers, [this, now](Stream* stream) -> ColorBufferMap::value_type {
-                ColorBufferPtr cb = ColorBuffer::onLoad(m_emulationGl.get(), m_emulationVk, stream);
+                ColorBufferPtr cb =
+                    ColorBuffer::onLoad(m_emulationGl.get(), m_emulationVk.get(), stream);
                 const HandleType handle = cb->getHndl();
                 const unsigned refCount = stream->getBe32();
                 const bool opened = stream->getByte();
@@ -2709,7 +2693,9 @@ void FrameBuffer::registerProcessCleanupCallback(void* key, std::function<void()
     if (!tInfo) return;
 
     auto& callbackMap = m_procOwnedCleanupCallbacks[tInfo->m_puid];
-    callbackMap[key] = cb;
+    if (!callbackMap.insert({key, std::move(cb)}).second) {
+        ERR("%s: tried to override existing key %p ", __func__, key);
+    }
 }
 
 void FrameBuffer::unregisterProcessCleanupCallback(void* key) {
@@ -2718,12 +2704,12 @@ void FrameBuffer::unregisterProcessCleanupCallback(void* key) {
     if (!tInfo) return;
 
     auto& callbackMap = m_procOwnedCleanupCallbacks[tInfo->m_puid];
-    if (callbackMap.find(key) == callbackMap.end()) {
-        ERR("warning: tried to erase nonexistent key %p "
+    auto erasedCount = callbackMap.erase(key);
+    if (erasedCount == 0) {
+        ERR("%s: tried to erase nonexistent key %p "
             "associated with process %llu",
-            key, (unsigned long long)(tInfo->m_puid));
+            __func__, key, (unsigned long long)(tInfo->m_puid));
     }
-    callbackMap.erase(key);
 }
 
 const ProcessResources* FrameBuffer::getProcessResources(uint64_t puid) {
@@ -2776,7 +2762,7 @@ int FrameBuffer::setDisplayPose(uint32_t displayId, int32_t x, int32_t y, uint32
 }
 
 void FrameBuffer::sweepColorBuffersLocked() {
-    HandleType handleToDestroy;
+    HandleType handleToDestroy = 0;
     while (mOutstandingColorBufferDestroys.tryReceive(&handleToDestroy)) {
         decColorBufferRefCountLocked(handleToDestroy);
     }
@@ -2810,41 +2796,6 @@ void FrameBuffer::setGuestManagedColorBufferLifetime(bool guestManaged) {
     m_guestManagedColorBufferLifetime = guestManaged;
 }
 
-bool FrameBuffer::platformImportResource(uint32_t handle, uint32_t info, void* resource) {
-    if (!resource) {
-        ERR("Error: resource was null");
-    }
-
-    AutoLock mutex(m_lock);
-
-    ColorBufferPtr colorBuffer = findColorBuffer(handle);
-    if (!colorBuffer) {
-        ERR("Error: resource %u not found as a ColorBuffer", handle);
-        return false;
-    }
-
-    uint32_t type = (info & RESOURCE_TYPE_MASK);
-    bool preserveContent = (info & RESOURCE_USE_PRESERVE);
-
-    switch (type) {
-#if GFXSTREAM_ENABLE_HOST_GLES
-        case RESOURCE_TYPE_EGL_NATIVE_PIXMAP:
-            return colorBuffer->glOpImportEglNativePixmap(resource, preserveContent);
-        case RESOURCE_TYPE_EGL_IMAGE:
-            return colorBuffer->glOpImportEglImage(resource, preserveContent);
-#endif
-        // Note: Additional non-EGL resource-types can be added here, and will
-        // be propagated through color-buffer import functionality
-        case RESOURCE_TYPE_VK_EXT_MEMORY_HANDLE:
-            return colorBuffer->importNativeResource(resource, type, preserveContent);
-        default:
-            ERR("Error: unsupported resource type: %u", type);
-            return false;
-    }
-
-    return true;
-}
-
 std::unique_ptr<BorrowedImageInfo> FrameBuffer::borrowColorBufferForComposition(
     uint32_t colorBufferHandle, bool colorBufferIsTarget) {
     ColorBufferPtr colorBufferPtr = findColorBuffer(colorBufferHandle);
@@ -2891,7 +2842,7 @@ void FrameBuffer::logVulkanDeviceLost() {
     if (!m_emulationVk) {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Device lost without VkEmulation?";
     }
-    vk::onVkDeviceLost();
+    m_emulationVk->onVkDeviceLost();
 }
 
 void FrameBuffer::logVulkanOutOfMemory(VkResult result, const char* function, int line,
@@ -2942,12 +2893,12 @@ void FrameBuffer::setDisplayActiveConfig(int configId) {
     INFO("setDisplayActiveConfig %d", configId);
 }
 
-const int FrameBuffer::getDisplayConfigsCount() {
+int FrameBuffer::getDisplayConfigsCount() {
     AutoLock mutex(m_lock);
     return mDisplayConfigs.size();
 }
 
-const int FrameBuffer::getDisplayConfigsParam(int configId, EGLint param) {
+int FrameBuffer::getDisplayConfigsParam(int configId, EGLint param) {
     AutoLock mutex(m_lock);
     if (mDisplayConfigs.find(configId) == mDisplayConfigs.end()) {
         return -1;
@@ -2972,7 +2923,7 @@ const int FrameBuffer::getDisplayConfigsParam(int configId, EGLint param) {
     }
 }
 
-const int FrameBuffer::getDisplayActiveConfig() {
+int FrameBuffer::getDisplayActiveConfig() {
     AutoLock mutex(m_lock);
     return mDisplayActiveConfigId >= 0 ? mDisplayActiveConfigId : -1;
 }
@@ -2981,7 +2932,7 @@ bool FrameBuffer::flushColorBufferFromVk(HandleType colorBufferHandle) {
     AutoLock mutex(m_lock);
     auto colorBuffer = findColorBuffer(colorBufferHandle);
     if (!colorBuffer) {
-        ERR("Failed to find ColorBuffer:%d", colorBufferHandle);
+        ERR("%s: Failed to find ColorBuffer:%d", __func__, colorBufferHandle);
         return false;
     }
     return colorBuffer->flushFromVk();
@@ -2993,7 +2944,7 @@ bool FrameBuffer::flushColorBufferFromVkBytes(HandleType colorBufferHandle, cons
 
     auto colorBuffer = findColorBuffer(colorBufferHandle);
     if (!colorBuffer) {
-        ERR("Failed to find ColorBuffer:%d", colorBufferHandle);
+        ERR("%s: Failed to find ColorBuffer:%d", __func__, colorBufferHandle);
         return false;
     }
     return colorBuffer->flushFromVkBytes(bytes, bytesSize);
@@ -3008,23 +2959,12 @@ bool FrameBuffer::invalidateColorBufferForVk(HandleType colorBufferHandle) {
     AutoLock mutex(m_lock);
     auto colorBuffer = findColorBuffer(colorBufferHandle);
     if (!colorBuffer) {
-        ERR("Failed to find ColorBuffer:%d", colorBufferHandle);
+        VERBOSE("%s: Failed to find ColorBuffer:%d", __func__, colorBufferHandle);
         return false;
     }
     return colorBuffer->invalidateForVk();
 }
 
-int FrameBuffer::waitSyncColorBuffer(HandleType colorBufferHandle) {
-    AutoLock mutex(m_lock);
-
-    ColorBufferPtr colorBuffer = findColorBuffer(colorBufferHandle);
-    if (!colorBuffer) {
-        return -1;
-    }
-
-    return colorBuffer->waitSync();
-}
-
 std::optional<BlobDescriptorInfo> FrameBuffer::exportColorBuffer(HandleType colorBufferHandle) {
     AutoLock mutex(m_lock);
 
@@ -3059,6 +2999,29 @@ HandleType FrameBuffer::getEmulatedEglWindowSurfaceColorBufferHandle(HandleType
     return it->second;
 }
 
+#ifdef CONFIG_AEMU
+void FrameBuffer::unregisterVulkanInstance(uint64_t id) const {
+    get_emugl_vm_operations().vulkanInstanceUnregister(id);
+}
+
+void FrameBuffer::registerVulkanInstance(uint64_t id, const char* appName) const {
+    auto* tInfo = RenderThreadInfo::get();
+    std::string process_name;
+    if (tInfo && tInfo->m_processName.has_value()) {
+        process_name = tInfo->m_processName.value();
+        // for deqp: com.drawelements.deqp:testercore
+        // remove the ":testercore" for deqp
+        auto position = process_name.find(":");
+        if (position != std::string::npos) {
+            process_name = process_name.substr(0, position);
+        }
+    } else if(appName) {
+        process_name = std::string(appName);
+    }
+    get_emugl_vm_operations().vulkanInstanceRegister(id, process_name.c_str());
+}
+#endif
+
 void FrameBuffer::createTrivialContext(HandleType shared, HandleType* contextOut,
                                        HandleType* surfOut) {
     assert(contextOut);
@@ -3121,7 +3084,7 @@ bool FrameBuffer::setEmulatedEglWindowSurfaceColorBuffer(HandleType p_surface,
         AutoLock colorBufferMapLock(m_colorBufferMapLock);
         ColorBufferMap::iterator c(m_colorbuffers.find(p_colorbuffer));
         if (c == m_colorbuffers.end()) {
-            ERR("bad color buffer handle %#x", p_colorbuffer);
+            ERR("bad color buffer handle %d", p_colorbuffer);
             // bad colorbuffer handle
             return false;
         }
@@ -3311,7 +3274,6 @@ void FrameBuffer::createEmulatedEglFenceSync(EGLenum type, int destroyWhenSignal
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "RenderThreadInfoGl not available.";
     }
     if (!info->currContext) {
-        auto fb = FrameBuffer::getFB();
         uint32_t syncContext;
         uint32_t syncSurface;
         createTrivialContext(0,  // There is no context to share.
@@ -3420,6 +3382,13 @@ EmulationGl& FrameBuffer::getEmulationGl() {
     return *m_emulationGl;
 }
 
+VkEmulation& FrameBuffer::getEmulationVk() {
+    if (!m_emulationVk) {
+        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "GL/EGL emulation not enabled.";
+    }
+    return *m_emulationVk;
+}
+
 EGLDisplay FrameBuffer::getDisplay() const {
     if (!m_emulationGl) {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "EGL emulation not enabled.";
@@ -3651,7 +3620,7 @@ bool FrameBuffer::platformDestroySharedEglContext(void* underlyingContext) {
 bool FrameBuffer::flushColorBufferFromGl(HandleType colorBufferHandle) {
     auto colorBuffer = findColorBuffer(colorBufferHandle);
     if (!colorBuffer) {
-        ERR("Failed to find ColorBuffer:%d", colorBufferHandle);
+        ERR("%s: Failed to find ColorBuffer:%d", __func__, colorBufferHandle);
         return false;
     }
     return colorBuffer->flushFromGl();
@@ -3660,7 +3629,7 @@ bool FrameBuffer::flushColorBufferFromGl(HandleType colorBufferHandle) {
 bool FrameBuffer::invalidateColorBufferForGl(HandleType colorBufferHandle) {
     auto colorBuffer = findColorBuffer(colorBufferHandle);
     if (!colorBuffer) {
-        ERR("Failed to find ColorBuffer:%d", colorBufferHandle);
+        VERBOSE("%s: Failed to find ColorBuffer:%d", __func__, colorBufferHandle);
         return false;
     }
     return colorBuffer->invalidateForGl();
@@ -3738,20 +3707,20 @@ bool FrameBuffer::bindContext(HandleType p_context, HandleType p_drawSurface,
     if (p_context || p_drawSurface || p_readSurface) {
         ctx = getContext_locked(p_context);
         if (!ctx) return false;
-        EmulatedEglWindowSurfaceMap::iterator w(m_windows.find(p_drawSurface));
-        if (w == m_windows.end()) {
+        auto drawWindowIt = m_windows.find(p_drawSurface);
+        if (drawWindowIt == m_windows.end()) {
             // bad surface handle
             return false;
         }
-        draw = (*w).second.first;
+        draw = (*drawWindowIt).second.first;
 
         if (p_readSurface != p_drawSurface) {
-            EmulatedEglWindowSurfaceMap::iterator w(m_windows.find(p_readSurface));
-            if (w == m_windows.end()) {
+            auto readWindowIt = m_windows.find(p_readSurface);
+            if (readWindowIt == m_windows.end()) {
                 // bad surface handle
                 return false;
             }
-            read = (*w).second.first;
+            read = (*readWindowIt).second.first;
         } else {
             read = draw;
         }
diff --git a/host/FrameBuffer.h b/host/FrameBuffer.h
index 536c1e063..65b502af8 100644
--- a/host/FrameBuffer.h
+++ b/host/FrameBuffer.h
@@ -41,8 +41,8 @@
 #include "aemu/base/AsyncResult.h"
 #include "aemu/base/EventNotificationSupport.h"
 #include "aemu/base/HealthMonitor.h"
-#include "aemu/base/ManagedDescriptor.hpp"
 #include "aemu/base/Metrics.h"
+#include "aemu/base/ThreadAnnotations.h"
 #include "aemu/base/files/Stream.h"
 #include "aemu/base/synchronization/Lock.h"
 #include "aemu/base/synchronization/MessageChannel.h"
@@ -87,16 +87,6 @@
 #include "utils/RenderDoc.h"
 #include "vulkan/vk_util.h"
 
-//// Import info types for FrameBuffer::platformImportResource
-// Platform resources and contexts support
-#define RESOURCE_TYPE_MASK 0x0F
-// types
-#define RESOURCE_TYPE_EGL_NATIVE_PIXMAP 0x01
-#define RESOURCE_TYPE_EGL_IMAGE 0x02
-#define RESOURCE_TYPE_VK_EXT_MEMORY_HANDLE 0x03
-// uses
-#define RESOURCE_USE_PRESERVE 0x10
-
 namespace gfxstream {
 namespace vk {
 class DisplayVk;
@@ -217,9 +207,9 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     // Variant of createColorBuffer except with a particular
     // handle already assigned. This is for use with
     // virtio-gpu's RESOURCE_CREATE ioctl.
-    void createColorBufferWithHandle(int p_width, int p_height, GLenum p_internalFormat,
-                                     FrameworkFormat p_frameworkFormat, HandleType handle,
-                                     bool linear = false);
+    void createColorBufferWithResourceHandle(int p_width, int p_height, GLenum p_internalFormat,
+                                             FrameworkFormat p_frameworkFormat, HandleType handle,
+                                             bool linear = false);
 
     // Create a new data Buffer instance from this display instance.
     // The buffer will be backed by a VkBuffer and VkDeviceMemory (if Vulkan
@@ -232,7 +222,7 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     // Variant of createBuffer except with a particular handle already
     // assigned and using device local memory. This is for use with
     // virtio-gpu's RESOURCE_CREATE ioctl for BLOB resources.
-    void createBufferWithHandle(uint64_t size, HandleType handle);
+    void createBufferWithResourceHandle(uint64_t size, HandleType handle);
 
     // Increment the reference count associated with a given ColorBuffer
     // instance. |p_colorbuffer| is its handle value as returned by
@@ -409,8 +399,8 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
                 const android::snapshot::ITextureLoaderPtr& textureLoader);
 
     // lock and unlock handles (EmulatedEglContext, ColorBuffer, EmulatedEglWindowSurface)
-    void lock();
-    void unlock();
+    void lock() ACQUIRE(m_lock);
+    void unlock() RELEASE(m_lock);
 
     float getDpr() const { return m_dpr; }
     int windowWidth() const { return m_windowWidth; }
@@ -419,6 +409,9 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     float getPy() const { return m_py; }
     int getZrot() const { return m_zRot; }
 
+    void registerVulkanInstance(uint64_t id, const char* appName) const;
+    void unregisterVulkanInstance(uint64_t id) const;
+
     bool isVulkanInteropSupported() const { return m_vulkanInteropSupported; }
     bool isVulkanEnabled() const { return m_vulkanEnabled; }
 
@@ -487,8 +480,6 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     void asyncWaitForGpuVulkanWithCb(uint64_t deviceHandle, uint64_t fenceHandle, FenceCompletionCallback cb);
     void asyncWaitForGpuVulkanQsriWithCb(uint64_t image, FenceCompletionCallback cb);
 
-    bool platformImportResource(uint32_t handle, uint32_t info, void* resource);
-
     void setGuestManagedColorBufferLifetime(bool guestManaged);
 
     std::unique_ptr<BorrowedImageInfo> borrowColorBufferForComposition(uint32_t colorBufferHandle,
@@ -509,16 +500,15 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     void scheduleVsyncTask(VsyncThread::VsyncTask task);
     void setDisplayConfigs(int configId, int w, int h, int dpiX, int dpiY);
     void setDisplayActiveConfig(int configId);
-    const int getDisplayConfigsCount();
-    const int getDisplayConfigsParam(int configId, EGLint param);
-    const int getDisplayActiveConfig();
+    int getDisplayConfigsCount();
+    int getDisplayConfigsParam(int configId, EGLint param);
+    int getDisplayActiveConfig();
 
     bool flushColorBufferFromVk(HandleType colorBufferHandle);
     bool flushColorBufferFromVkBytes(HandleType colorBufferHandle, const void* bytes,
                                      size_t bytesSize);
     bool invalidateColorBufferForVk(HandleType colorBufferHandle);
 
-    int waitSyncColorBuffer(HandleType colorBufferHandle);
     std::optional<BlobDescriptorInfo> exportColorBuffer(HandleType colorBufferHandle);
     std::optional<BlobDescriptorInfo> exportBuffer(HandleType bufferHandle);
 
@@ -597,6 +587,9 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     gl::EmulationGl& getEmulationGl();
     bool hasEmulationGl() const { return m_emulationGl != nullptr; }
 
+    vk::VkEmulation& getEmulationVk();
+    bool hasEmulationVk() const { return m_emulationVk != nullptr; }
+
     // Return the host EGLDisplay used by this instance.
     EGLDisplay getDisplay() const;
     EGLSurface getWindowSurface() const;
@@ -726,10 +719,12 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
         m_guestPostedAFrame = true;
         fireEvent({FrameBufferChange::FrameReady, mFrameNumber++});
     }
-    HandleType createColorBufferWithHandleLocked(int p_width, int p_height, GLenum p_internalFormat,
-                                                 FrameworkFormat p_frameworkFormat,
-                                                 HandleType handle, bool linear = false);
-    HandleType createBufferWithHandleLocked(int p_size, HandleType handle, uint32_t memoryProperty);
+    HandleType createColorBufferWithResourceHandleLocked(int p_width, int p_height,
+                                                         GLenum p_internalFormat,
+                                                         FrameworkFormat p_frameworkFormat,
+                                                         HandleType handle, bool linear = false);
+    HandleType createBufferWithResourceHandleLocked(int p_size, HandleType handle,
+                                                    uint32_t memoryProperty);
 
     void recomputeLayout();
     void setDisplayPoseInSkinUI(int totalHeight);
@@ -878,7 +873,8 @@ class FrameBuffer : public android::base::EventNotificationSupport<FrameBufferCh
     Compositor* m_compositor = nullptr;
     bool m_useVulkanComposition = false;
 
-    vk::VkEmulation* m_emulationVk = nullptr;
+    std::unique_ptr<vk::VkEmulation> m_emulationVk;
+
     // The implementation for Vulkan native swapchain. Only initialized when useVulkan is set when
     // calling FrameBuffer::initialize(). DisplayVk is actually owned by VkEmulation.
     vk::DisplayVk* m_displayVk = nullptr;
diff --git a/host/GfxStreamAgents.cpp b/host/GfxStreamAgents.cpp
index df2a10b63..2aaadc37f 100644
--- a/host/GfxStreamAgents.cpp
+++ b/host/GfxStreamAgents.cpp
@@ -160,7 +160,7 @@ static const QAndroidMultiDisplayAgent sMultiDisplayAgent = {
             }
             // displays created by internal rcCommands
             if (*displayId == MultiDisplay::s_invalidIdMultiDisplay) {
-                for (int i = MultiDisplay::s_displayIdInternalBegin; i < MultiDisplay::s_maxNumMultiDisplay; i++) {
+                for (uint32_t i = MultiDisplay::s_displayIdInternalBegin; i < MultiDisplay::s_maxNumMultiDisplay; i++) {
                     if (mMultiDisplay.find(i) == mMultiDisplay.end()) {
                         *displayId = i;
                         break;
@@ -434,6 +434,24 @@ static const QAndroidVmOperations sQAndroidVmOperations =
         .hostmemUnregister = android_emulation_hostmem_unregister,
         .hostmemGetInfo = android_emulation_hostmem_get_info,
 #ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
+        .vulkanInstanceRegister =
+            [](uint64_t id, const char* name) {
+                DEBUG_LOG(stderr,
+                          "goldfish-opengl vm ops: register Vulkan instance "
+                          "skipped\n");
+            },
+        .vulkanInstanceUnregister =
+            [](uint64_t id) {
+                DEBUG_LOG(stderr,
+                          "goldfish-opengl vm ops: unregister Vulkan instance "
+                          "skipped\n");
+            },
+        .vulkanInstanceEnumerate =
+            [](uint32_t* pCount, uint64_t* pIds, char** pNames) {
+                DEBUG_LOG(stderr,
+                          "goldfish-opengl vm ops: enumerate Vulkan instance "
+                          "skipped\n");
+            },
         .setSkipSnapshotSaveReason =
             [](SnapshotSkipReason reason) {
                 DEBUG_LOG(stderr,
@@ -466,20 +484,23 @@ static const QAndroidVmOperations sQAndroidVmOperations =
 namespace android {
 namespace emulation {
 
-const QAndroidVmOperations* const
+#ifndef GFXSTREAM_MESON_BUILD
+const QAndroidVmOperations*
 GfxStreamGraphicsAgentFactory::android_get_QAndroidVmOperations() const {
     return &sQAndroidVmOperations;
 }
 
-const QAndroidMultiDisplayAgent* const
+const QAndroidMultiDisplayAgent*
 GfxStreamGraphicsAgentFactory::android_get_QAndroidMultiDisplayAgent() const {
     return &sMultiDisplayAgent;
 }
 
-const QAndroidEmulatorWindowAgent* const
+const QAndroidEmulatorWindowAgent*
 GfxStreamGraphicsAgentFactory::android_get_QAndroidEmulatorWindowAgent()
         const {
     return &sQAndroidEmulatorWindowAgent;
 }
+#endif
+
 }  // namespace emulation
 }  // namespace android
diff --git a/host/GfxStreamAgents.h b/host/GfxStreamAgents.h
index 864d3ddec..ddeca5a83 100644
--- a/host/GfxStreamAgents.h
+++ b/host/GfxStreamAgents.h
@@ -24,17 +24,19 @@ namespace emulation {
 //
 // Most of the agents are not defined, add your agents here if you need
 // access to additional agents.
+#ifndef GFXSTREAM_MESON_BUILD
 class GfxStreamGraphicsAgentFactory : public GraphicsAgentFactory {
 public:
-    const QAndroidVmOperations* const android_get_QAndroidVmOperations()
+    const QAndroidVmOperations* android_get_QAndroidVmOperations()
             const override;
 
-    const QAndroidMultiDisplayAgent* const
+    const QAndroidMultiDisplayAgent*
     android_get_QAndroidMultiDisplayAgent() const override;
 
-    const QAndroidEmulatorWindowAgent* const
+    const QAndroidEmulatorWindowAgent*
     android_get_QAndroidEmulatorWindowAgent() const override;
 };
+#endif
 
 }  // namespace emulation
 }  // namespace android
diff --git a/host/GlesCompat.h b/host/GlesCompat.h
index 3c57028fd..f1f56dc66 100644
--- a/host/GlesCompat.h
+++ b/host/GlesCompat.h
@@ -19,7 +19,6 @@
 
 typedef unsigned int GLenum;
 typedef int32_t EGLint;
-// typedef void *EGLNativeDisplayType;
 typedef unsigned int EGLNativeWindowType;
 
 namespace gfxstream {
diff --git a/host/GraphicsDriverLock.cpp b/host/GraphicsDriverLock.cpp
new file mode 100644
index 000000000..9aeb37561
--- /dev/null
+++ b/host/GraphicsDriverLock.cpp
@@ -0,0 +1,27 @@
+// Copyright 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "GraphicsDriverLock.h"
+
+namespace {
+android::base::Lock* sLock = new android::base::Lock();
+}
+
+namespace gfxstream {
+
+android::base::Lock* graphicsDriverLock() {
+    return sLock;
+}
+
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/GraphicsDriverLock.h b/host/GraphicsDriverLock.h
new file mode 100644
index 000000000..494a39693
--- /dev/null
+++ b/host/GraphicsDriverLock.h
@@ -0,0 +1,25 @@
+// Copyright 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include "aemu/base/synchronization/Lock.h"
+
+namespace gfxstream {
+
+// Used to workaround various driver bugs (e.g. vkDestroyDevice deadlock, eglMakeCurrent +
+// vkDestroyDevice).
+android::base::Lock* graphicsDriverLock();
+
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/PostWorker.cpp b/host/PostWorker.cpp
index 800fb3219..643d2d4ca 100644
--- a/host/PostWorker.cpp
+++ b/host/PostWorker.cpp
@@ -23,7 +23,6 @@
 #include "FrameBuffer.h"
 #include "RenderThreadInfo.h"
 #include "aemu/base/Tracing.h"
-#include "host-common/GfxstreamFatalError.h"
 #include "host-common/logging.h"
 #include "host-common/misc.h"
 #include "vulkan/VkCommonOperations.h"
@@ -35,32 +34,13 @@ static void sDefaultRunOnUiThread(UiUpdateFunc f, void* data, bool wait) {
 }
 
 namespace gfxstream {
-namespace {
-
-using emugl::ABORT_REASON_OTHER;
-using emugl::FatalError;
-
-hwc_transform_t getTransformFromRotation(int rotation) {
-    switch (static_cast<int>(rotation / 90)) {
-        case 1:
-            return HWC_TRANSFORM_ROT_270;
-        case 2:
-            return HWC_TRANSFORM_ROT_180;
-        case 3:
-            return HWC_TRANSFORM_ROT_90;
-        default:
-            return HWC_TRANSFORM_NONE;
-    }
-}
-
-}  // namespace
 
 PostWorker::PostWorker(bool mainThreadPostingOnly, FrameBuffer* fb, Compositor* compositor)
     : mFb(fb),
+      m_compositor(compositor),
       m_mainThreadPostingOnly(mainThreadPostingOnly),
       m_runOnUiThread(m_mainThreadPostingOnly ? emugl::get_emugl_window_operations().runOnUiThread
-                                              : sDefaultRunOnUiThread),
-      m_compositor(compositor) {}
+                                              : sDefaultRunOnUiThread) {}
 
 std::shared_future<void> PostWorker::composeImpl(const FlatComposeRequest& composeRequest) {
     std::shared_future<void> completedFuture =
@@ -161,6 +141,9 @@ void PostWorker::runTask(std::packaged_task<void()> task) {
     using Task = std::packaged_task<void()>;
     auto taskPtr = std::make_unique<Task>(std::move(task));
     if (m_mainThreadPostingOnly) {
+        if (!m_runOnUiThread) {
+            ERR("m_runOnUiThread function ptr is NULL, going to crash");
+        }
         m_runOnUiThread(
             [](void* data) {
                 std::unique_ptr<Task> taskPtr(reinterpret_cast<Task*>(data));
diff --git a/host/PostWorkerGl.cpp b/host/PostWorkerGl.cpp
index f44254ee4..1bb765fea 100644
--- a/host/PostWorkerGl.cpp
+++ b/host/PostWorkerGl.cpp
@@ -221,7 +221,6 @@ DisplayGl::PostLayer PostWorkerGl::postWithOverlay(ColorBuffer* cb) {
     float px = mFb->getPx();
     float py = mFb->getPy();
     int zRot = mFb->getZrot();
-    hwc_transform_t rotation = (hwc_transform_t)0;
 
     // Find the x and y values at the origin when "fully scrolled."
     // Multiply by 2 because the texture goes from -1 to 1, not 0 to 1.
diff --git a/host/ReadBuffer.cpp b/host/ReadBuffer.cpp
index 32382eb94..8fc4728a8 100644
--- a/host/ReadBuffer.cpp
+++ b/host/ReadBuffer.cpp
@@ -86,7 +86,7 @@ int ReadBuffer::getData(IOStream* stream, size_t minSize) {
     }
 
     // get fresh data into the buffer;
-    int readTotal = 0;
+    size_t readTotal = 0;
     do {
         const size_t readNow = stream->read(m_readPtr + m_validData,
                                             maxSizeToRead - readTotal);
diff --git a/host/RenderChannelImpl.cpp b/host/RenderChannelImpl.cpp
index 84144afe4..21699d346 100644
--- a/host/RenderChannelImpl.cpp
+++ b/host/RenderChannelImpl.cpp
@@ -13,6 +13,7 @@
 // limitations under the License.
 #include "RenderChannelImpl.h"
 
+#include "GraphicsDriverLock.h"
 #include "RenderThread.h"
 #include "aemu/base/synchronization/Lock.h"
 
@@ -192,7 +193,12 @@ void RenderChannelImpl::resume() {
 
 RenderChannelImpl::~RenderChannelImpl() {
     // Make sure the render thread is stopped before the channel is gone.
-    mRenderThread->wait();
+    mRenderThread->waitForFinished();
+    {
+        AutoLock lock(*graphicsDriverLock());
+        mRenderThread->sendExitSignal();
+        mRenderThread->wait();
+    }
 }
 
 void RenderChannelImpl::updateStateLocked() {
diff --git a/host/RenderControl.cpp b/host/RenderControl.cpp
index 686b03412..353b275db 100644
--- a/host/RenderControl.cpp
+++ b/host/RenderControl.cpp
@@ -323,7 +323,8 @@ static bool shouldEnableAsyncSwap(const gfxstream::host::FeatureSet& features) {
 
 static bool shouldEnableVulkan(const gfxstream::host::FeatureSet& features) {
     // TODO: Restrict further to devices supporting external memory.
-    return features.Vulkan.enabled && vk::getGlobalVkEmulation() &&
+    FrameBuffer* fb = FrameBuffer::getFB();
+    return features.Vulkan.enabled && fb->hasEmulationVk() &&
            vk::VkDecoderGlobalState::get()->getHostFeatureSupport().supportsVulkan;
 }
 
@@ -874,7 +875,9 @@ static int rcFlushWindowColorBuffer(uint32_t windowSurface)
     }
 
     // Make the GL updates visible to other backings if necessary.
-    fb->flushColorBufferFromGl(colorBufferHandle);
+    if (colorBufferHandle != 0) {
+        fb->flushColorBufferFromGl(colorBufferHandle);
+    }
 
     GRSYNC_DPRINT("unlock gralloc cb lock }");
 
@@ -1088,6 +1091,7 @@ static void rcTriggerWait(uint64_t eglsync_ptr,
         FrameBuffer *fb = FrameBuffer::getFB();
         if (fb && fenceSync && fenceSync->isCompositionFence()) {
             fb->scheduleVsyncTask([eglsync_ptr, fenceSync, timeline](uint64_t) {
+                (void)eglsync_ptr;
                 EGLSYNC_DPRINT(
                     "vsync: eglsync=0x%llx fenceSync=%p thread_ptr=0x%llx "
                     "timeline=0x%llx",
@@ -1377,9 +1381,8 @@ static void rcCreateColorBufferWithHandle(
         return;
     }
 
-    fb->createColorBufferWithHandle(
-        width, height, internalFormat,
-        FRAMEWORK_FORMAT_GL_COMPATIBLE, handle);
+    fb->createColorBufferWithResourceHandle(width, height, internalFormat,
+                                            FRAMEWORK_FORMAT_GL_COMPATIBLE, handle);
 }
 
 static uint32_t rcCreateBuffer2(uint64_t size, uint32_t memoryProperty) {
@@ -1407,12 +1410,13 @@ static int rcSetColorBufferVulkanMode2(uint32_t colorBuffer, uint32_t mode,
                                        uint32_t memoryProperty) {
 #define VULKAN_MODE_VULKAN_ONLY 1
 
-    bool modeIsVulkanOnly = mode == VULKAN_MODE_VULKAN_ONLY;
-
-    if (!vk::setColorBufferVulkanMode(colorBuffer, mode)) {
-        fprintf(stderr,
-                "%s: error: failed to set Vulkan mode for colorBuffer 0x%x\n",
-                __func__, colorBuffer);
+    FrameBuffer* fb = FrameBuffer::getFB();
+    if (!fb->hasEmulationVk()) {
+        ERR("VkEmulation not enabled.");
+        return -1;
+    }
+    if (!fb->getEmulationVk().setColorBufferVulkanMode(colorBuffer, mode)) {
+        ERR("Failed to set ColorBuffer vulkan mode.");
         return -1;
     }
 
@@ -1425,25 +1429,31 @@ static int rcSetColorBufferVulkanMode(uint32_t colorBuffer, uint32_t mode) {
 }
 
 static int32_t rcMapGpaToBufferHandle(uint32_t bufferHandle, uint64_t gpa) {
-    int32_t result = vk::mapGpaToBufferHandle(bufferHandle, gpa);
-    if (result < 0) {
-        fprintf(stderr,
-                "%s: error: failed to map gpa %" PRIx64 " to buffer handle 0x%x: %d\n",
-                __func__, gpa, bufferHandle, result);
+    FrameBuffer* fb = FrameBuffer::getFB();
+    if (!fb->hasEmulationVk()) {
+        ERR("VkEmulation not enabled.");
+        return -1;
     }
-    return result;
+    if (fb->getEmulationVk().mapGpaToBufferHandle(bufferHandle, gpa) < 0) {
+        ERR("Failed to map gpa %" PRIx64 " to buffer handle 0x%x.", gpa, bufferHandle);
+        return -1;
+    }
+    return 0;
 }
 
 static int32_t rcMapGpaToBufferHandle2(uint32_t bufferHandle,
                                        uint64_t gpa,
                                        uint64_t size) {
-    int32_t result = vk::mapGpaToBufferHandle(bufferHandle, gpa, size);
-    if (result < 0) {
-        fprintf(stderr,
-                "%s: error: failed to map gpa %" PRIx64 " to buffer handle 0x%x: %d\n",
-                __func__, gpa, bufferHandle, result);
+    FrameBuffer* fb = FrameBuffer::getFB();
+    if (!fb->hasEmulationVk()) {
+        ERR("VkEmulation not enabled.");
+        return -1;
+    }
+    if (fb->getEmulationVk().mapGpaToBufferHandle(bufferHandle, gpa, size) < 0) {
+        ERR("Failed to map gpa %" PRIx64 " to buffer handle 0x%x.", gpa, bufferHandle);
+        return -1;
     }
-    return result;
+    return 0;
 }
 
 static void rcFlushWindowColorBufferAsyncWithFrameNumber(uint32_t windowSurface, uint32_t frameNumber) {
diff --git a/host/RenderThread.cpp b/host/RenderThread.cpp
index 8a8380396..5207b1ca7 100644
--- a/host/RenderThread.cpp
+++ b/host/RenderThread.cpp
@@ -29,6 +29,7 @@
 #include "aemu/base/synchronization/MessageChannel.h"
 #include "aemu/base/system/System.h"
 #include "apigen-codec-common/ChecksumCalculatorThreadInfo.h"
+#include "host-common/GfxstreamFatalError.h"
 #include "host-common/logging.h"
 #include "vulkan/VkCommonOperations.h"
 
@@ -53,6 +54,8 @@ namespace gfxstream {
 using android::base::AutoLock;
 using android::base::EventHangMetadata;
 using android::base::MessageChannel;
+using emugl::ABORT_REASON_OTHER;
+using emugl::FatalError;
 using emugl::GfxApiLogger;
 using vk::VkDecoderContext;
 
@@ -82,7 +85,8 @@ static android::base::Lock sThreadRunLimiter;
 RenderThread::RenderThread(RenderChannelImpl* channel,
                            android::base::Stream* loadStream,
                            uint32_t virtioGpuContextId)
-    : android::base::Thread(android::base::ThreadFlags::MaskSignals, 2 * 1024 * 1024),
+    : android::base::Thread(android::base::ThreadFlags::MaskSignals, 2 * 1024 * 1024,
+                            "RenderThread"),
       mChannel(channel),
       mRunInLimitedMode(android::base::getCpuCoreCount() < kMinThreadsToRunUnlimited),
       mContextId(virtioGpuContextId)
@@ -134,15 +138,15 @@ void RenderThread::pausePreSnapshot() {
     mState = SnapshotState::StartSaving;
     if (mRingStream) {
         mRingStream->pausePreSnapshot();
-        // mCondVar.broadcastAndUnlock(&lock);
+        // mSnapshotSignal.broadcastAndUnlock(&lock);
     }
     if (mChannel) {
         mChannel->pausePreSnapshot();
-        mCondVar.broadcastAndUnlock(&lock);
+        mSnapshotSignal.broadcastAndUnlock(&lock);
     }
 }
 
-void RenderThread::resume(bool waitForSave) {
+void RenderThread::resume() {
     AutoLock lock(mLock);
     // This function can be called for a thread from pre-snapshot loading
     // state; it doesn't need to do anything.
@@ -150,15 +154,14 @@ void RenderThread::resume(bool waitForSave) {
         return;
     }
     if (mRingStream) mRingStream->resume();
-    if (waitForSave) {
-        waitForSnapshotCompletion(&lock);
-    }
+    waitForSnapshotCompletion(&lock);
+
     mNeedReloadProcessResources = true;
     mStream.clear();
     mState = SnapshotState::Empty;
     if (mChannel) mChannel->resume();
     if (mRingStream) mRingStream->resume();
-    mCondVar.broadcastAndUnlock(&lock);
+    mSnapshotSignal.broadcastAndUnlock(&lock);
 }
 
 void RenderThread::save(android::base::Stream* stream) {
@@ -184,31 +187,39 @@ void RenderThread::save(android::base::Stream* stream) {
 void RenderThread::waitForSnapshotCompletion(AutoLock* lock) {
     while (mState != SnapshotState::Finished &&
            !mFinished.load(std::memory_order_relaxed)) {
-        mCondVar.wait(lock);
+        mSnapshotSignal.wait(lock);
     }
 }
 
-template <class OpImpl>
-void RenderThread::snapshotOperation(AutoLock* lock, OpImpl&& implFunc) {
-    assert(isPausedForSnapshotLocked());
+bool RenderThread::isPausedForSnapshotLocked() const { return mState != SnapshotState::Empty; }
+
+bool RenderThread::doSnapshotOp(const SnapshotObjects& objects, SnapshotState expectedState,
+                                std::function<void()> op) {
+    AutoLock lock(mLock);
+
+    if (mState != expectedState) {
+        return false;
+    }
     mState = SnapshotState::InProgress;
-    mCondVar.broadcastAndUnlock(lock);
+    mSnapshotSignal.broadcastAndUnlock(&lock);
 
-    implFunc();
+    op();
 
-    lock->lock();
+    lock.lock();
 
     mState = SnapshotState::Finished;
-    mCondVar.broadcast();
+    mSnapshotSignal.broadcast();
 
     // Only return after we're allowed to proceed.
     while (isPausedForSnapshotLocked()) {
-        mCondVar.wait(lock);
+        mSnapshotSignal.wait(&lock);
     }
+
+    return true;
 }
 
-void RenderThread::loadImpl(AutoLock* lock, const SnapshotObjects& objects) {
-    snapshotOperation(lock, [this, &objects] {
+bool RenderThread::loadSnapshot(const SnapshotObjects& objects) {
+    return doSnapshotOp(objects, SnapshotState::StartLoading, [this, &objects] {
         objects.readBuffer->onLoad(&*mStream);
         if (objects.channelStream) objects.channelStream->load(&*mStream);
         if (objects.ringStream) objects.ringStream->load(&*mStream);
@@ -217,8 +228,8 @@ void RenderThread::loadImpl(AutoLock* lock, const SnapshotObjects& objects) {
     });
 }
 
-void RenderThread::saveImpl(AutoLock* lock, const SnapshotObjects& objects) {
-    snapshotOperation(lock, [this, &objects] {
+bool RenderThread::saveSnapshot(const SnapshotObjects& objects) {
+    return doSnapshotOp(objects, SnapshotState::StartSaving, [this, &objects] {
         objects.readBuffer->onSave(&*mStream);
         if (objects.channelStream) objects.channelStream->save(&*mStream);
         if (objects.ringStream) objects.ringStream->save(&*mStream);
@@ -227,35 +238,44 @@ void RenderThread::saveImpl(AutoLock* lock, const SnapshotObjects& objects) {
     });
 }
 
-bool RenderThread::isPausedForSnapshotLocked() const {
-    return mState != SnapshotState::Empty;
+void RenderThread::waitForFinished() {
+    AutoLock lock(mLock);
+    while (!mFinished.load(std::memory_order_relaxed)) {
+        mFinishedSignal.wait(&lock);
+    }
 }
 
-bool RenderThread::doSnapshotOperation(const SnapshotObjects& objects,
-                                       SnapshotState state) {
+void RenderThread::sendExitSignal() {
     AutoLock lock(mLock);
-    if (mState == state) {
-        switch (state) {
-            case SnapshotState::StartLoading:
-                loadImpl(&lock, objects);
-                return true;
-            case SnapshotState::StartSaving:
-                saveImpl(&lock, objects);
-                return true;
-            default:
-                return false;
-        }
+    if (!mFinished.load(std::memory_order_relaxed)) {
+        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+            << "RenderThread exit signal sent before finished";
     }
-    return false;
+    mCanExit.store(true, std::memory_order_relaxed);
+    mExitSignal.broadcastAndUnlock(&lock);
 }
 
 void RenderThread::setFinished() {
     // Make sure it never happens that we wait forever for the thread to
     // save to snapshot while it was not even going to.
+    {
+        AutoLock lock(mLock);
+        mFinished.store(true, std::memory_order_relaxed);
+        if (mState != SnapshotState::Empty) {
+            mSnapshotSignal.broadcastAndUnlock(&lock);
+        }
+    }
+    {
+        AutoLock lock(mLock);
+        mFinishedSignal.broadcastAndUnlock(&lock);
+    }
+}
+
+void RenderThread::waitForExitSignal() {
     AutoLock lock(mLock);
-    mFinished.store(true, std::memory_order_relaxed);
-    if (mState != SnapshotState::Empty) {
-        mCondVar.broadcastAndUnlock(&lock);
+    GL_LOG("Waiting for exit signal RenderThread @%p", this);
+    while (!mCanExit.load(std::memory_order_relaxed)) {
+        mExitSignal.wait(&lock);
     }
 }
 
@@ -265,7 +285,7 @@ intptr_t RenderThread::main() {
         return 0;
     }
 
-    RenderThreadInfo tInfo;
+    std::unique_ptr<RenderThreadInfo> tInfo = std::make_unique<RenderThreadInfo>();
     ChecksumCalculatorThreadInfo tChecksumInfo;
     ChecksumCalculator& checksumCalc = tChecksumInfo.get();
     bool needRestoreFromSnapshot = false;
@@ -274,10 +294,10 @@ intptr_t RenderThread::main() {
     // initialize decoders
 #if GFXSTREAM_ENABLE_HOST_GLES
     if (!FrameBuffer::getFB()->getFeatures().GuestVulkanOnly.enabled) {
-        tInfo.initGl();
+        tInfo->initGl();
     }
 
-    initRenderControlContext(&tInfo.m_rcDec);
+    initRenderControlContext(&(tInfo->m_rcDec));
 #endif
 
     if (!mChannel && !mRingStream) {
@@ -296,24 +316,25 @@ intptr_t RenderThread::main() {
     }
 
     const SnapshotObjects snapshotObjects = {
-        &tInfo, &checksumCalc, &stream, mRingStream.get(), &readBuf,
+        tInfo.get(), &checksumCalc, &stream, mRingStream.get(), &readBuf,
     };
 
     // Framebuffer initialization is asynchronous, so we need to make sure
     // it's completely initialized before running any GL commands.
     FrameBuffer::waitUntilInitialized();
-    if (vk::getGlobalVkEmulation()) {
-        tInfo.m_vkInfo.emplace();
+
+    if (FrameBuffer::getFB()->hasEmulationVk()) {
+        tInfo->m_vkInfo.emplace();
     }
 
 #if GFXSTREAM_ENABLE_HOST_MAGMA
-    tInfo.m_magmaInfo.emplace(mContextId);
+    tInfo->m_magmaInfo.emplace(mContextId);
 #endif
 
     // This is the only place where we try loading from snapshot.
     // But the context bind / restoration will be delayed after receiving
     // the first GL command.
-    if (doSnapshotOperation(snapshotObjects, SnapshotState::StartLoading)) {
+    if (loadSnapshot(snapshotObjects)) {
         GL_LOG("Loaded RenderThread @%p from snapshot", this);
         needRestoreFromSnapshot = true;
     } else {
@@ -322,8 +343,10 @@ intptr_t RenderThread::main() {
         uint32_t flags = 0;
         while (ioStream->read(&flags, sizeof(flags)) != sizeof(flags)) {
             // Stream read may fail because of a pending snapshot.
-            if (!doSnapshotOperation(snapshotObjects, SnapshotState::StartSaving)) {
+            if (!saveSnapshot(snapshotObjects)) {
                 setFinished();
+                tInfo.reset();
+                waitForExitSignal();
                 GL_LOG("Exited a RenderThread @%p early", this);
                 return 0;
             }
@@ -386,7 +409,7 @@ intptr_t RenderThread::main() {
         if (packetSize > readBuf.validData()) {
             stat = readBuf.getData(ioStream, packetSize);
             if (stat <= 0) {
-                if (doSnapshotOperation(snapshotObjects, SnapshotState::StartSaving)) {
+                if (saveSnapshot(snapshotObjects)) {
                     continue;
                 } else {
                     D("Warning: render thread could not read data from stream");
@@ -396,7 +419,7 @@ intptr_t RenderThread::main() {
                 // If we're using RingStream that might load before FrameBuffer
                 // restores the contexts from the handles, so check again here.
 
-                tInfo.postLoadRefreshCurrentContextSurfacePtrs();
+                tInfo->postLoadRefreshCurrentContextSurfacePtrs();
                 needRestoreFromSnapshot = false;
             }
             if (mNeedReloadProcessResources) {
@@ -465,12 +488,12 @@ intptr_t RenderThread::main() {
                                 .setAnnotations(std::move(renderThreadData))
                                 .build();
 
-            if (!tInfo.m_puid) {
-                tInfo.m_puid = mContextId;
+            if (!tInfo->m_puid) {
+                tInfo->m_puid = mContextId;
             }
 
-            if (!processResources && tInfo.m_puid && tInfo.m_puid != INVALID_CONTEXT_ID) {
-                processResources = FrameBuffer::getFB()->getProcessResources(tInfo.m_puid);
+            if (!processResources && tInfo->m_puid && tInfo->m_puid != INVALID_CONTEXT_ID) {
+                processResources = FrameBuffer::getFB()->getProcessResources(tInfo->m_puid);
             }
 
             progress = false;
@@ -482,15 +505,15 @@ intptr_t RenderThread::main() {
             //
             // Note: It's risky to limit Vulkan decoding to one thread,
             // so we do it outside the limiter
-            if (tInfo.m_vkInfo) {
-                tInfo.m_vkInfo->ctx_id = mContextId;
+            if (tInfo->m_vkInfo) {
+                tInfo->m_vkInfo->ctx_id = mContextId;
                 VkDecoderContext context = {
                     .processName = contextName,
                     .gfxApiLogger = &gfxLogger,
                     .healthMonitor = FrameBuffer::getFB()->getHealthMonitor(),
                     .metricsLogger = &metricsLogger,
                 };
-                last = tInfo.m_vkInfo->m_vkDec.decode(readBuf.buf(), readBuf.validData(), ioStream,
+                last = tInfo->m_vkInfo->m_vkDec.decode(readBuf.buf(), readBuf.validData(), ioStream,
                                                       processResources, context);
                 if (last > 0) {
                     if (!processResources) {
@@ -502,8 +525,9 @@ intptr_t RenderThread::main() {
                 }
             }
 
+            std::optional<android::base::AutoLock> limitedModeLock;
             if (mRunInLimitedMode) {
-                sThreadRunLimiter.lock();
+                limitedModeLock.emplace(sThreadRunLimiter);
             }
 
             // try to process some of the command buffer using the GLESv1
@@ -525,9 +549,9 @@ intptr_t RenderThread::main() {
             }
 
 #if GFXSTREAM_ENABLE_HOST_GLES
-            if (tInfo.m_glInfo) {
+            if (tInfo->m_glInfo) {
                 {
-                    last = tInfo.m_glInfo->m_glDec.decode(
+                    last = tInfo->m_glInfo->m_glDec.decode(
                             readBuf.buf(), readBuf.validData(), ioStream, &checksumCalc);
                     if (last > 0) {
                         progress = true;
@@ -540,7 +564,7 @@ intptr_t RenderThread::main() {
                 // decoder
                 //
                 {
-                    last = tInfo.m_glInfo->m_gl2Dec.decode(readBuf.buf(), readBuf.validData(),
+                    last = tInfo->m_glInfo->m_gl2Dec.decode(readBuf.buf(), readBuf.validData(),
                                                            ioStream, &checksumCalc);
 
                     if (last > 0) {
@@ -558,7 +582,7 @@ intptr_t RenderThread::main() {
             //
 #if GFXSTREAM_ENABLE_HOST_GLES
             {
-                last = tInfo.m_rcDec.decode(readBuf.buf(), readBuf.validData(),
+                last = tInfo->m_rcDec.decode(readBuf.buf(), readBuf.validData(),
                                             ioStream, &checksumCalc);
                 if (last > 0) {
                     readBuf.consume(last);
@@ -572,9 +596,9 @@ intptr_t RenderThread::main() {
             // decoder
             //
 #if GFXSTREAM_ENABLE_HOST_MAGMA
-            if (tInfo.m_magmaInfo && tInfo.m_magmaInfo->mMagmaDec)
+            if (tInfo->m_magmaInfo && tInfo->m_magmaInfo->mMagmaDec)
             {
-                last = tInfo.m_magmaInfo->mMagmaDec->decode(readBuf.buf(), readBuf.validData(),
+                last = tInfo->m_magmaInfo->mMagmaDec->decode(readBuf.buf(), readBuf.validData(),
                                                             ioStream, &checksumCalc);
                 if (last > 0) {
                     readBuf.consume(last);
@@ -582,11 +606,6 @@ intptr_t RenderThread::main() {
                 }
             }
 #endif
-
-            if (mRunInLimitedMode) {
-                sThreadRunLimiter.unlock();
-            }
-
         } while (progress);
     }
 
@@ -595,12 +614,17 @@ intptr_t RenderThread::main() {
     }
 
 #if GFXSTREAM_ENABLE_HOST_GLES
-    if (tInfo.m_glInfo) {
+    if (tInfo->m_glInfo) {
         FrameBuffer::getFB()->drainGlRenderThreadResources();
     }
 #endif
 
     setFinished();
+    // Since we now control when the thread exits, we must make sure the RenderThreadInfo is
+    // destroyed after the RenderThread is finished, as the RenderThreadInfo cleanup thread is
+    // waiting on the object to be destroyed.
+    tInfo.reset();
+    waitForExitSignal();
 
     GL_LOG("Exited a RenderThread @%p", this);
     return 0;
diff --git a/host/RenderThread.h b/host/RenderThread.h
index b5d5bebe3..b26c224d3 100644
--- a/host/RenderThread.h
+++ b/host/RenderThread.h
@@ -55,14 +55,22 @@ public:
 
     // Returns true iff the thread has finished.
     bool isFinished() const { return mFinished.load(std::memory_order_relaxed); }
+    void waitForFinished();
 
     void pausePreSnapshot();
-    void resume(bool waitForSave);
+    void resume();
     void save(android::base::Stream* stream);
 
+    // RenderThreads are blocked from exiting after finished to workaround driver bugs.
+    // `sendExitSignal` allows us to control when we can allow the thread to exit to synchronize
+    // between exits and other RenderThreads calling vkDestroyDevice, eglMakeCurrent, etc.
+    // This must be called after RenderThread has finished (use `waitForFinished`), as a deadlock
+    // can occur if vulkan commands are still processing.
+    void sendExitSignal();
 private:
     virtual intptr_t main();
     void setFinished();
+    void waitForExitSignal();
 
     // Snapshot support.
     enum class SnapshotState {
@@ -79,13 +87,14 @@ private:
         Ring,
     };
 
-    template <class OpImpl>
-    void snapshotOperation(android::base::AutoLock* lock, OpImpl&& impl);
-
     struct SnapshotObjects;
 
-    bool doSnapshotOperation(const SnapshotObjects& objects,
-                             SnapshotState operation);
+    bool doSnapshotOp(const SnapshotObjects& objects, SnapshotState expectedState,
+                      std::function<void()> op);
+
+    bool loadSnapshot(const SnapshotObjects& objects);
+    bool saveSnapshot(const SnapshotObjects& objects);
+
     void waitForSnapshotCompletion(android::base::AutoLock* lock);
     void loadImpl(android::base::AutoLock* lock, const SnapshotObjects& objects);
     void saveImpl(android::base::AutoLock* lock, const SnapshotObjects& objects);
@@ -98,7 +107,10 @@ private:
     SnapshotState mState = SnapshotState::Empty;
     std::atomic<bool> mFinished { false };
     android::base::Lock mLock;
-    android::base::ConditionVariable mCondVar;
+    android::base::ConditionVariable mSnapshotSignal;
+    android::base::ConditionVariable mFinishedSignal;
+    android::base::ConditionVariable mExitSignal;
+    std::atomic<bool> mCanExit { false };
     android::base::Optional<android::base::MemStream> mStream;
 
     bool mRunInLimitedMode = false;
diff --git a/host/RendererImpl.cpp b/host/RendererImpl.cpp
index 93707b3f0..14bbbff1b 100644
--- a/host/RendererImpl.cpp
+++ b/host/RendererImpl.cpp
@@ -20,6 +20,7 @@
 #include <variant>
 
 #include "FrameBuffer.h"
+#include "GraphicsDriverLock.h"
 #include "RenderChannelImpl.h"
 #include "RenderThread.h"
 #include "aemu/base/system/System.h"
@@ -182,17 +183,23 @@ void RendererImpl::stop(bool wait) {
                             std::make_move_iterator(channels.begin()),
                             std::make_move_iterator(channels.end()));
 
-    if (!wait) {
-        return;
-    }
-
     // Each render channel is referenced in the corresponing pipe object, so
     // even if we clear the |channels| vector they could still be alive
     // for a while. This means we need to make sure to wait for render thread
     // exit explicitly.
     for (const auto& c : mStoppedChannels) {
-        c->renderThread()->wait();
+        c->renderThread()->waitForFinished();
+        {
+            android::base::AutoLock driverLock(*graphicsDriverLock());
+            c->renderThread()->sendExitSignal();
+            c->renderThread()->wait();
+        }
+    }
+
+    if (!wait) {
+        return;
     }
+
     mCleanupThread->waitForCleanup();
     mStoppedChannels.clear();
 }
@@ -222,7 +229,12 @@ void RendererImpl::cleanupRenderThreads() {
         c->stop();
     }
     for (const auto& c : channels) {
-        c->renderThread()->wait();
+        c->renderThread()->waitForFinished();
+        {
+            android::base::AutoLock driverLock(*graphicsDriverLock());
+            c->renderThread()->sendExitSignal();
+            c->renderThread()->wait();
+        }
     }
 }
 
@@ -294,7 +306,13 @@ void RendererImpl::addressSpaceGraphicsConsumerDestroy(void* consumer) {
         android::base::AutoLock lock(mAddressSpaceRenderThreadLock);
         mAddressSpaceRenderThreads.erase(thread);
     }
-    thread->wait();
+
+    thread->waitForFinished();
+    {
+        android::base::AutoLock driverLock(*graphicsDriverLock());
+        thread->sendExitSignal();
+        thread->wait();
+    }
     delete thread;
 }
 
@@ -310,7 +328,7 @@ void RendererImpl::addressSpaceGraphicsConsumerSave(void* consumer, android::bas
 
 void RendererImpl::addressSpaceGraphicsConsumerPostSave(void* consumer) {
     RenderThread* thread = (RenderThread*)consumer;
-    thread->resume(true);
+    thread->resume();
 }
 
 void RendererImpl::addressSpaceGraphicsConsumerRegisterPostLoadRenderThread(void* consumer) {
@@ -337,11 +355,11 @@ void RendererImpl::pauseAllPreSave() {
     waitForProcessCleanup();
 }
 
-void RendererImpl::resumeAll(bool waitForSave) {
+void RendererImpl::resumeAll() {
     {
         android::base::AutoLock lock(mAddressSpaceRenderThreadLock);
         for (const auto t : mAdditionalPostLoadRenderThreads) {
-            t->resume(waitForSave);
+            t->resume();
         }
     }
     {
@@ -350,10 +368,10 @@ void RendererImpl::resumeAll(bool waitForSave) {
             return;
         }
         for (const auto& c : mChannels) {
-            c->renderThread()->resume(waitForSave);
+            c->renderThread()->resume();
         }
         for (const auto& thread : mAddressSpaceRenderThreads) {
-            thread->resume(waitForSave);
+            thread->resume();
         }
         mAdditionalPostLoadRenderThreads.clear();
     }
@@ -551,12 +569,12 @@ void RendererImpl::cleanupProcGLObjects(uint64_t puid) {
 static struct AndroidVirtioGpuOps sVirtioGpuOps = {
     .create_buffer_with_handle =
         [](uint64_t size, uint32_t handle) {
-            FrameBuffer::getFB()->createBufferWithHandle(size, handle);
+            FrameBuffer::getFB()->createBufferWithResourceHandle(size, handle);
         },
     .create_color_buffer_with_handle =
         [](uint32_t width, uint32_t height, uint32_t format, uint32_t fwkFormat, uint32_t handle,
            bool linear) {
-            FrameBuffer::getFB()->createColorBufferWithHandle(
+            FrameBuffer::getFB()->createColorBufferWithResourceHandle(
                 width, height, (GLenum)format, (FrameworkFormat)fwkFormat, handle, linear);
         },
     .open_color_buffer = [](uint32_t handle) { FrameBuffer::getFB()->openColorBuffer(handle); },
diff --git a/host/RendererImpl.h b/host/RendererImpl.h
index b86cd879c..d0cb905be 100644
--- a/host/RendererImpl.h
+++ b/host/RendererImpl.h
@@ -103,7 +103,7 @@ public:
     struct AndroidVirtioGpuOps* getVirtioGpuOps() final;
 
     void pauseAllPreSave() final;
-    void resumeAll(bool waitForSave = true) final;
+    void resumeAll() final;
 
     void save(android::base::Stream* stream,
               const android::snapshot::ITextureSaverPtr& textureSaver) final;
diff --git a/host/RingStream.cpp b/host/RingStream.cpp
index 13dfba640..dc0e478de 100644
--- a/host/RingStream.cpp
+++ b/host/RingStream.cpp
@@ -248,6 +248,10 @@ void RingStream::type1Read(
     ring_buffer_copy_contents(
         mContext.to_host, 0, xferTotal * sizeof(struct asg_type1_xfer), (uint8_t*)xfersPtr);
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunreachable-code-loop-increment"
+#endif // __clang__
     for (uint32_t i = 0; i < xferTotal; ++i) {
         if (*current + xfersPtr[i].size > ptrEnd) {
             // Save in a temp buffer or we'll get stuck
@@ -271,9 +275,12 @@ void RingStream::type1Read(
         *count += xfersPtr[i].size;
 
         // TODO: Figure out why running multiple xfers here can result in data
-        // corruption.
+        // corruption and remove clang diagnostic block.
         return;
     }
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif // __clang__
 }
 
 void RingStream::type2Read(
diff --git a/host/SyncThread.cpp b/host/SyncThread.cpp
index e75936e62..15e531f37 100644
--- a/host/SyncThread.cpp
+++ b/host/SyncThread.cpp
@@ -49,16 +49,16 @@ using gl::EmulatedEglFenceSync;
 
 #if DEBUG
 
-static uint64_t curr_ms() {
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    return tv.tv_usec / 1000 + tv.tv_sec * 1000;
+static uint64_t curr_ns() {
+    auto now = std::chrono::system_clock::now();
+    auto now_ns = std::chrono::time_point_cast<std::chrono::nanoseconds>(now);
+    return now_ns.time_since_epoch().count();
 }
 
-#define DPRINT(fmt, ...) do { \
-    if (!VERBOSE_CHECK(syncthreads)) VERBOSE_ENABLE(syncthreads); \
-    VERBOSE_TID_FUNCTION_DPRINT(syncthreads, "@ time=%llu: " fmt, curr_ms(), ##__VA_ARGS__); \
-} while(0)
+#define DPRINT(fmt, ...)                                                   \
+    do {                                                                   \
+        INFO("@ time=%llu, %s: " fmt, curr_ns(), __func__, ##__VA_ARGS__); \
+    } while (0)
 
 #else
 
@@ -156,10 +156,14 @@ void SyncThread::triggerWaitWithCompletionCallback(EmulatedEglFenceSync* fenceSy
 }
 
 void SyncThread::initSyncEGLContext() {
-    mWorkerThreadPool.broadcast([this] {
+    // b/383543476: force sequential init to work around a deadlock that is
+    // believed to be a driver issue.
+    std::mutex initMutex;
+    mWorkerThreadPool.broadcast([&, this] {
         return Command{
-            .mTask = std::packaged_task<int(WorkerId)>([this](WorkerId workerId) {
+            .mTask = std::packaged_task<int(WorkerId)>([&, this](WorkerId workerId) {
                 DPRINT("for worker id: %d", workerId);
+                std::lock_guard<std::mutex> initLock(initMutex);
                 // We shouldn't initialize EGL context, when SyncThread is initialized
                 // without GL enabled.
                 SYNC_THREAD_CHECK(mHasGl);
@@ -377,6 +381,7 @@ intptr_t SyncThread::main() {
     DPRINT("in sync thread");
     mLock.lock();
     mCv.wait(&mLock, [this] { return mExiting; });
+    mLock.unlock();
 
     mWorkerThreadPool.done();
     mWorkerThreadPool.join();
diff --git a/host/VirtioGpuFrontend.cpp b/host/VirtioGpuFrontend.cpp
index 664c13f69..7dacb4fbf 100644
--- a/host/VirtioGpuFrontend.cpp
+++ b/host/VirtioGpuFrontend.cpp
@@ -28,7 +28,6 @@
 #include "FrameBuffer.h"
 #include "FrameworkFormats.h"
 #include "VkCommonOperations.h"
-#include "aemu/base/ManagedDescriptor.hpp"
 #include "aemu/base/files/StdioStream.h"
 #include "aemu/base/memory/SharedMemory.h"
 #include "aemu/base/threads/WorkerThread.h"
@@ -126,21 +125,7 @@ int VirtioGpuFrontend::init(void* cookie, gfxstream::host::FeatureSet features,
         stream_renderer_error("Could not get address space device control ops!");
         return -EINVAL;
     }
-
-    // Forwards fence completions from VirtioGpuTimelines to the client (VMM).
-    auto fenceCompletionCallback = [this](const VirtioGpuTimelines::Ring& ring,
-                                          VirtioGpuTimelines::FenceId fenceId) {
-        struct stream_renderer_fence fence = {0};
-        fence.fence_id = fenceId;
-        fence.flags = STREAM_RENDERER_FLAG_FENCE;
-        if (const auto* contextSpecificRing = std::get_if<VirtioGpuRingContextSpecific>(&ring)) {
-            fence.flags |= STREAM_RENDERER_FLAG_FENCE_RING_IDX;
-            fence.ctx_id = contextSpecificRing->mCtxId;
-            fence.ring_idx = contextSpecificRing->mRingIdx;
-        }
-        mFenceCallback(mCookie, &fence);
-    };
-    mVirtioGpuTimelines = VirtioGpuTimelines::create(std::move(fenceCompletionCallback));
+    mVirtioGpuTimelines = VirtioGpuTimelines::create(getFenceCompletionCallback());
 
 #if !defined(_WIN32)
     mPageSize = getpagesize();
@@ -198,6 +183,21 @@ int VirtioGpuFrontend::createContext(VirtioGpuCtxId contextId, uint32_t nlen, co
     return 0;
 }
 
+VirtioGpuTimelines::FenceCompletionCallback VirtioGpuFrontend::getFenceCompletionCallback() {
+    // Forwards fence completions from VirtioGpuTimelines to the client (VMM).
+    return [this](const VirtioGpuTimelines::Ring& ring, VirtioGpuTimelines::FenceId fenceId) {
+        struct stream_renderer_fence fence = {0};
+        fence.fence_id = fenceId;
+        fence.flags = STREAM_RENDERER_FLAG_FENCE;
+        if (const auto* contextSpecificRing = std::get_if<VirtioGpuRingContextSpecific>(&ring)) {
+            fence.flags |= STREAM_RENDERER_FLAG_FENCE_RING_IDX;
+            fence.ctx_id = contextSpecificRing->mCtxId;
+            fence.ring_idx = contextSpecificRing->mRingIdx;
+        }
+        mFenceCallback(mCookie, &fence);
+    };
+}
+
 int VirtioGpuFrontend::destroyContext(VirtioGpuCtxId contextId) {
     stream_renderer_debug("ctxid: %u", contextId);
 
@@ -461,6 +461,35 @@ int VirtioGpuFrontend::createResource(struct stream_renderer_resource_create_arg
     return 0;
 }
 
+int VirtioGpuFrontend::importResource(uint32_t res_handle,
+                                      const struct stream_renderer_handle* import_handle,
+                                      const struct stream_renderer_import_data* import_data) {
+    if (!import_handle) {
+        stream_renderer_error(
+            "import_handle was not provided in call to importResource for handle: %d", res_handle);
+        return -EINVAL;
+    } else if (import_data && (import_data->flags & STREAM_RENDERER_IMPORT_FLAG_RESOURCE_EXISTS)) {
+        auto resourceIt = mResources.find(res_handle);
+        if (resourceIt == mResources.end()) {
+            stream_renderer_error(
+                "import_data::flags specified STREAM_RENDERER_IMPORT_FLAG_RESOURCE_EXISTS, but "
+                "internal resource does not already exist",
+                res_handle);
+            return -EINVAL;
+        }
+        return resourceIt->second.ImportHandle(import_handle, import_data);
+    } else {
+        auto resourceOpt = VirtioGpuResource::Create(res_handle, import_handle, import_data);
+        if (!resourceOpt) {
+            stream_renderer_error("Failed to create resource %u, with import_handle/import_data",
+                                  res_handle);
+            return -EINVAL;
+        }
+        mResources[res_handle] = std::move(*resourceOpt);
+        return 0;
+    }
+}
+
 void VirtioGpuFrontend::unrefResource(uint32_t resourceId) {
     stream_renderer_debug("resource: %u", resourceId);
 
@@ -582,10 +611,11 @@ void VirtioGpuFrontend::fillCaps(uint32_t set, void* caps) {
             capset->ringSize = 12288;
             capset->bufferSize = 1048576;
 
-            auto vk_emu = gfxstream::vk::getGlobalVkEmulation();
-            if (vk_emu && vk_emu->live && vk_emu->representativeColorBufferMemoryTypeInfo) {
-                capset->colorBufferMemoryIndex =
-                    vk_emu->representativeColorBufferMemoryTypeInfo->guestMemoryTypeIndex;
+            auto* fb = gfxstream::FrameBuffer::getFB();
+            if (fb->hasEmulationVk()) {
+                const auto info = fb->getEmulationVk().getRepresentativeColorBufferMemoryTypeInfo();
+                capset->colorBufferMemoryIndex = info.guestMemoryTypeIndex;
+                capset->deferredMapping = 1;
             }
 
             if (mFeatures.VulkanBatchedDescriptorSetUpdate.enabled) {
@@ -593,9 +623,6 @@ void VirtioGpuFrontend::fillCaps(uint32_t set, void* caps) {
             }
             capset->noRenderControlEnc = 1;
             capset->blobAlignment = mPageSize;
-            if (vk_emu && vk_emu->live) {
-                capset->deferredMapping = 1;
-            }
 
 #if GFXSTREAM_UNSTABLE_VULKAN_DMABUF_WINSYS
             capset->alwaysBlob = 1;
@@ -779,6 +806,9 @@ int VirtioGpuFrontend::createBlob(uint32_t contextId, uint32_t resourceId,
     auto& context = contextIt->second;
 
     auto createArgs = context.TakePendingBlob(createBlobArgs->blob_id);
+    if (createArgs) {
+        createArgs->handle = resourceId;
+    }
 
     auto resourceOpt =
         VirtioGpuResource::Create(mFeatures, mPageSize, contextId, resourceId,
@@ -826,14 +856,6 @@ int VirtioGpuFrontend::resourceUnmap(uint32_t resourceId) {
     return 0;
 }
 
-int VirtioGpuFrontend::platformImportResource(int res_handle, int res_info, void* resource) {
-    auto it = mResources.find(res_handle);
-    if (it == mResources.end()) return -EINVAL;
-    bool success =
-        gfxstream::FrameBuffer::getFB()->platformImportResource(res_handle, res_info, resource);
-    return success ? 0 : -1;
-}
-
 void* VirtioGpuFrontend::platformCreateSharedEglContext() {
     void* ptr = nullptr;
 #if GFXSTREAM_ENABLE_HOST_GLES
@@ -850,16 +872,6 @@ int VirtioGpuFrontend::platformDestroySharedEglContext(void* context) {
     return success ? 0 : -1;
 }
 
-int VirtioGpuFrontend::waitSyncResource(uint32_t res_handle) {
-    auto resourceIt = mResources.find(res_handle);
-    if (resourceIt == mResources.end()) {
-        stream_renderer_error("waitSyncResource could not find resource: %d", res_handle);
-        return -EINVAL;
-    }
-    auto& resource = resourceIt->second;
-    return resource.WaitSyncResource();
-}
-
 int VirtioGpuFrontend::resourceMapInfo(uint32_t resourceId, uint32_t* map_info) {
     stream_renderer_debug("resource: %u", resourceId);
 
@@ -899,7 +911,7 @@ int VirtioGpuFrontend::exportFence(uint64_t fenceId, struct stream_renderer_hand
     else
         return -EINVAL;
 
-    handle->handle_type = entry->handleType;
+    handle->handle_type = entry->streamHandleType;
 
 #ifdef _WIN32
     handle->os_handle = static_cast<int64_t>(reinterpret_cast<intptr_t>(rawDescriptor));
@@ -1006,6 +1018,15 @@ int VirtioGpuFrontend::snapshotFrontend(const char* directory) {
         (*snapshot.mutable_resources())[resourceId] = std::move(*resourceSnapshotOpt);
     }
 
+    if (mVirtioGpuTimelines) {
+        auto timelinesSnapshotOpt = mVirtioGpuTimelines->Snapshot();
+        if (!timelinesSnapshotOpt) {
+            stream_renderer_error("Failed to snapshot timelines.");
+            return -1;
+        }
+        snapshot.mutable_timelines()->Swap(&*timelinesSnapshotOpt);
+    }
+
     const std::filesystem::path snapshotDirectory = std::string(directory);
     const std::filesystem::path snapshotPath = snapshotDirectory / kSnapshotBasenameFrontend;
     int snapshotFd = open(snapshotPath.c_str(), O_CREAT | O_WRONLY | O_TRUNC, 0660);
@@ -1121,6 +1142,14 @@ int VirtioGpuFrontend::restoreFrontend(const char* directory) {
         }
         mResources.emplace(resourceId, std::move(*resourceOpt));
     }
+
+    mVirtioGpuTimelines =
+        VirtioGpuTimelines::Restore(getFenceCompletionCallback(), snapshot.timelines());
+    if (!mVirtioGpuTimelines) {
+        stream_renderer_error("Failed to restore timelines.");
+        return -1;
+    }
+
     return 0;
 }
 
@@ -1201,9 +1230,7 @@ int VirtioGpuFrontend::restore(const char* directory) {
         return ret;
     }
 
-    // In end2end tests, we don't really do snapshot save for render threads.
-    // We will need to resume all render threads without waiting for snapshot.
-    android_getOpenglesRenderer()->resumeAll(false);
+    android_getOpenglesRenderer()->resumeAll();
 
     stream_renderer_debug("directory:%s - done!", directory);
     return 0;
diff --git a/host/VirtioGpuFrontend.h b/host/VirtioGpuFrontend.h
index 9691d7a8f..510877010 100644
--- a/host/VirtioGpuFrontend.h
+++ b/host/VirtioGpuFrontend.h
@@ -67,6 +67,8 @@ class VirtioGpuFrontend {
 
     int createResource(struct stream_renderer_resource_create_args* args, struct iovec* iov,
                        uint32_t num_iovs);
+    int importResource(uint32_t res_handle, const struct stream_renderer_handle* import_handle,
+                       const struct stream_renderer_import_data* import_data);
     void unrefResource(uint32_t toUnrefId);
 
     int attachIov(int resId, iovec* iov, int num_iovs);
@@ -98,14 +100,10 @@ class VirtioGpuFrontend {
     int resourceMap(uint32_t resourceId, void** hvaOut, uint64_t* sizeOut);
     int resourceUnmap(uint32_t res_handle);
 
-    int platformImportResource(int res_handle, int res_info, void* resource);
-
     void* platformCreateSharedEglContext();
 
     int platformDestroySharedEglContext(void* context);
 
-    int waitSyncResource(uint32_t res_handle);
-
     int resourceMapInfo(uint32_t resourceId, uint32_t* map_info);
 
     int exportBlob(uint32_t resourceId, struct stream_renderer_handle* handle);
@@ -123,6 +121,8 @@ class VirtioGpuFrontend {
 #endif  // CONFIG_AEMU
 
    private:
+    VirtioGpuTimelines::FenceCompletionCallback getFenceCompletionCallback();
+
     int destroyVirtioGpuObjects();
 
 #ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
diff --git a/host/VirtioGpuFrontendSnapshot.proto b/host/VirtioGpuFrontendSnapshot.proto
index 9b5d90267..9b2c6be90 100644
--- a/host/VirtioGpuFrontendSnapshot.proto
+++ b/host/VirtioGpuFrontendSnapshot.proto
@@ -16,6 +16,7 @@ syntax = "proto3";
 
 import "VirtioGpuContextSnapshot.proto";
 import "VirtioGpuResourceSnapshot.proto";
+import "VirtioGpuTimelinesSnapshot.proto";
 
 package gfxstream.host.snapshot;
 
@@ -26,5 +27,6 @@ package gfxstream.host.snapshot;
 message VirtioGpuFrontendSnapshot {
     map<uint32, VirtioGpuContextSnapshot> contexts = 1;
     map<uint32, VirtioGpuResourceSnapshot> resources = 2;
+    optional VirtioGpuTimelinesSnapshot timelines = 3;
 }
 // LINT.ThenChange(VirtioGpuFrontend.h:virtio_gpu_frontend)
\ No newline at end of file
diff --git a/host/VirtioGpuResource.cpp b/host/VirtioGpuResource.cpp
index 70eca6857..557718864 100644
--- a/host/VirtioGpuResource.cpp
+++ b/host/VirtioGpuResource.cpp
@@ -68,8 +68,39 @@ enum pipe_texture_target {
 
 static inline uint32_t AlignUp(uint32_t n, uint32_t a) { return ((n + a - 1) / a) * a; }
 
+struct ResourceFormatInfo {
+    uint32_t drm_fourcc;
+    int bpp;
+};
+
+static std::unordered_map<int, struct ResourceFormatInfo> virglFormatInfoMap = {
+    {VIRGL_FORMAT_B8G8R8A8_UNORM, {DRM_FORMAT_ARGB8888, 4}},
+    {VIRGL_FORMAT_B8G8R8X8_UNORM, {DRM_FORMAT_XRGB8888, 4}},
+    {VIRGL_FORMAT_B5G6R5_UNORM, {DRM_FORMAT_RGB565, 2}},
+    {VIRGL_FORMAT_R8G8B8A8_UNORM, {DRM_FORMAT_ABGR8888, 4}},
+    {VIRGL_FORMAT_R8G8B8X8_UNORM, {DRM_FORMAT_XBGR8888, 4}},
+    {VIRGL_FORMAT_R8_UNORM, {DRM_FORMAT_R8, 1}},
+};
+
+static std::optional<int> DrmFourccToVirglFormat(uint32_t drm_fourcc) {
+    for (auto it : virglFormatInfoMap) {
+        if (it.second.drm_fourcc == drm_fourcc) {
+            return it.first;
+        }
+    }
+    return -1;
+}
+
+static std::optional<struct ResourceFormatInfo> VirglFormatInfo(uint32_t virglFormat) {
+    auto it = virglFormatInfoMap.find(virglFormat);
+    if (virglFormatInfoMap.end() != it) {
+        return it->second;
+    }
+    return std::nullopt;
+}
+
 VirtioGpuResourceType GetResourceType(const struct stream_renderer_resource_create_args& args) {
-    if (args.target == PIPE_BUFFER) {
+    if (args.target == PIPE_BUFFER && args.bind == VIRGL_BIND_CUSTOM) {
         return VirtioGpuResourceType::PIPE;
     }
 
@@ -111,7 +142,8 @@ std::optional<VirtioGpuResource> VirtioGpuResource::Create(
     if (resourceType == VirtioGpuResourceType::PIPE) {
         // Frontend only resource.
     } else if (resourceType == VirtioGpuResourceType::BUFFER) {
-        FrameBuffer::getFB()->createBufferWithHandle(args->width * args->height, args->handle);
+        FrameBuffer::getFB()->createBufferWithResourceHandle(args->width * args->height,
+                                                             args->handle);
     } else if (resourceType == VirtioGpuResourceType::COLOR_BUFFER) {
         const uint32_t glformat = virgl_format_to_gl(args->format);
         const auto fwkformat = (gfxstream::FrameworkFormat)virgl_format_to_fwk_format(args->format);
@@ -121,8 +153,8 @@ std::optional<VirtioGpuResource> VirtioGpuResource::Create(
 #else
             false;
 #endif
-        FrameBuffer::getFB()->createColorBufferWithHandle(args->width, args->height, glformat,
-                                                          fwkformat, args->handle, linear);
+        FrameBuffer::getFB()->createColorBufferWithResourceHandle(
+            args->width, args->height, glformat, fwkformat, args->handle, linear);
         FrameBuffer::getFB()->setGuestManagedColorBufferLifetime(true /* guest manages lifetime */);
         FrameBuffer::getFB()->openColorBuffer(args->handle);
     } else {
@@ -140,6 +172,79 @@ std::optional<VirtioGpuResource> VirtioGpuResource::Create(
     return resource;
 }
 
+/*static*/
+std::optional<VirtioGpuResource> VirtioGpuResource::Create(
+    uint32_t res_handle, const struct stream_renderer_handle* import_handle,
+    const struct stream_renderer_import_data* import_data) {
+    stream_renderer_debug("resource id: %u", res_handle);
+
+    if (!import_handle || !import_data) {
+        stream_renderer_error("Failed to import resource: import_handle/import_data not provided.");
+        return std::nullopt;
+    } else if (!(import_data->flags & STREAM_RENDERER_IMPORT_FLAG_3D_INFO)) {
+        stream_renderer_error(
+            "Failed to import resource: stream_renderer_3d_info not provided in import data.");
+        return std::nullopt;
+    }
+
+    struct stream_renderer_resource_create_args internal_create_args = {0};
+    internal_create_args.handle = res_handle;
+    // TODO(aruby@blackberry.com): Determine VIRGL_BIND_LINEAR from info_3d?
+    internal_create_args.bind = VIRGL_BIND_SAMPLER_VIEW | VIRGL_BIND_SCANOUT | VIRGL_BIND_SHARED;
+    internal_create_args.target = PIPE_TEXTURE_2D;
+    // From info_3d
+    auto virglFormat = DrmFourccToVirglFormat(import_data->info_3d.drm_fourcc);
+    if (!virglFormat) {
+        stream_renderer_error("No virgl format available for drm_fourcc: %d",
+                              import_data->info_3d.drm_fourcc);
+        return std::nullopt;
+    }
+    internal_create_args.format = *virglFormat;
+    internal_create_args.width = import_data->info_3d.width;
+    internal_create_args.height = import_data->info_3d.height;
+    // Default values
+    internal_create_args.depth = 1;
+    internal_create_args.array_size = 1;
+    internal_create_args.last_level = 0;
+    internal_create_args.nr_samples = 0;
+    internal_create_args.flags = 0;
+
+    const auto resourceType = GetResourceType(internal_create_args);
+    if (resourceType != VirtioGpuResourceType::COLOR_BUFFER) {
+        stream_renderer_error(
+            "Failed to create resource with import_handle: arguments resulted in unhandled type. "
+            "Only ColorBuffer resources are supported for import.");
+        return std::nullopt;
+    }
+
+    ExternalObjectManager::get()->addResourceExternalHandleInfo(
+        res_handle, ExternalHandleInfo{
+                        .handle = import_handle->os_handle,
+                        .streamHandleType = import_handle->handle_type,
+                    });
+    const uint32_t glformat = virgl_format_to_gl(internal_create_args.format);
+    const auto fwkformat =
+        (gfxstream::FrameworkFormat)virgl_format_to_fwk_format(internal_create_args.format);
+    const bool linear =
+#ifdef GFXSTREAM_ENABLE_GUEST_VIRTIO_RESOURCE_TILING_CONTROL
+        !!(internal_create_args.bind & VIRGL_BIND_LINEAR);
+#else
+        false;
+#endif
+    FrameBuffer::getFB()->createColorBufferWithResourceHandle(
+        internal_create_args.width, internal_create_args.height, glformat, fwkformat,
+        internal_create_args.handle, linear);
+    FrameBuffer::getFB()->setGuestManagedColorBufferLifetime(true /* guest manages lifetime */);
+    FrameBuffer::getFB()->openColorBuffer(internal_create_args.handle);
+
+    VirtioGpuResource resource;
+    resource.mId = res_handle;
+    resource.mResourceType = resourceType;
+    resource.mCreateArgs = internal_create_args;
+
+    return resource;
+}
+
 /*static*/ std::optional<VirtioGpuResource> VirtioGpuResource::Create(
     const gfxstream::host::FeatureSet& features, uint32_t pageSize, uint32_t contextId,
     uint32_t resourceId, const struct stream_renderer_resource_create_args* createArgs,
@@ -237,6 +342,41 @@ int VirtioGpuResource::Destroy() {
     return 0;
 }
 
+int VirtioGpuResource::ImportHandle(const struct stream_renderer_handle* handle,
+                                    const struct stream_renderer_import_data* import_data) {
+    if (mResourceType != VirtioGpuResourceType::COLOR_BUFFER) {
+        stream_renderer_error(
+            "Failed to ImportResource: importing external handles to existing resources is only "
+            "supported for ColorBuffer resources.");
+        return -EINVAL;
+    }
+
+    auto colorBufferPtr = FrameBuffer::getFB()->findColorBuffer(mId);
+    if (!colorBufferPtr) {
+        stream_renderer_error(
+            "Failed to ImportResource: could not find colorBuffer for res_handle: %d", mId);
+        return -EINVAL;
+    }
+
+    const bool preserveContent =
+        (import_data->flags & STREAM_RENDERER_IMPORT_FLAG_PRESERVE_CONTENT);
+    bool importSuccess = false;
+    switch (handle->handle_type) {
+#if GFXSTREAM_ENABLE_HOST_GLES
+        case STREAM_HANDLE_TYPE_PLATFORM_EGL_NATIVE_PIXMAP:
+            importSuccess = colorBufferPtr->glOpImportEglNativePixmap(
+                reinterpret_cast<void*>(handle->os_handle), preserveContent);
+            break;
+#endif
+        default:
+            ERR("Unsupported handle_type: 0x%x, specified for importing to resource: %d",
+                handle->handle_type, mId);
+            return -EINVAL;
+    }
+
+    return (importSuccess ? 0 : -EINVAL);
+}
+
 void VirtioGpuResource::AttachIov(struct iovec* iov, uint32_t num_iovs) {
     mIovs.clear();
     mLinear.clear();
@@ -244,7 +384,7 @@ void VirtioGpuResource::AttachIov(struct iovec* iov, uint32_t num_iovs) {
     size_t linearSize = 0;
     if (num_iovs) {
         mIovs.reserve(num_iovs);
-        for (int i = 0; i < num_iovs; ++i) {
+        for (uint32_t i = 0; i < num_iovs; ++i) {
             mIovs.push_back(iov[i]);
             linearSize += iov[i].iov_len;
         }
@@ -316,33 +456,13 @@ int VirtioGpuResource::GetInfo(struct stream_renderer_resource_info* outInfo) co
         return ENOENT;
     }
 
-    uint32_t bpp = 4U;
-    switch (mCreateArgs->format) {
-        case VIRGL_FORMAT_B8G8R8A8_UNORM:
-            outInfo->drm_fourcc = DRM_FORMAT_ARGB8888;
-            break;
-        case VIRGL_FORMAT_B8G8R8X8_UNORM:
-            outInfo->drm_fourcc = DRM_FORMAT_XRGB8888;
-            break;
-        case VIRGL_FORMAT_B5G6R5_UNORM:
-            outInfo->drm_fourcc = DRM_FORMAT_RGB565;
-            bpp = 2U;
-            break;
-        case VIRGL_FORMAT_R8G8B8A8_UNORM:
-            outInfo->drm_fourcc = DRM_FORMAT_ABGR8888;
-            break;
-        case VIRGL_FORMAT_R8G8B8X8_UNORM:
-            outInfo->drm_fourcc = DRM_FORMAT_XBGR8888;
-            break;
-        case VIRGL_FORMAT_R8_UNORM:
-            outInfo->drm_fourcc = DRM_FORMAT_R8;
-            bpp = 1U;
-            break;
-        default:
-            return EINVAL;
+    auto formatInfo = VirglFormatInfo(mCreateArgs->format);
+    if (!formatInfo) {
+        return EINVAL;
     }
 
-    outInfo->stride = AlignUp(mCreateArgs->width * bpp, 16U);
+    outInfo->drm_fourcc = formatInfo->drm_fourcc;
+    outInfo->stride = AlignUp(mCreateArgs->width * formatInfo->bpp, 16U);
     outInfo->virgl_format = mCreateArgs->format;
     outInfo->handle = mCreateArgs->handle;
     outInfo->height = mCreateArgs->height;
@@ -357,10 +477,10 @@ int VirtioGpuResource::GetVulkanInfo(struct stream_renderer_vulkan_info* outInfo
     if (!mBlobMemory) {
         return -EINVAL;
     }
-    if (!std::holds_alternative<ExternalMemoryDescriptor>(*mBlobMemory)) {
+    if (!std::holds_alternative<ExternalMemoryInfo>(*mBlobMemory)) {
         return -EINVAL;
     }
-    auto& memory = std::get<ExternalMemoryDescriptor>(*mBlobMemory);
+    auto& memory = std::get<ExternalMemoryInfo>(*mBlobMemory);
     if (!memory->vulkanInfoOpt) {
         return -EINVAL;
     }
@@ -380,16 +500,17 @@ int VirtioGpuResource::GetCaching(uint32_t* outCaching) const {
         return -EINVAL;
     }
 
-    if (std::holds_alternative<RingBlobMemory>(*mBlobMemory)) {
+    if (!std::holds_alternative<ExternalMemoryMapping>(*mBlobMemory) ||
+        !std::holds_alternative<ExternalMemoryInfo>(*mBlobMemory)) {
         *outCaching = STREAM_RENDERER_MAP_CACHE_CACHED;
         return 0;
     } else if (std::holds_alternative<ExternalMemoryMapping>(*mBlobMemory)) {
         auto& memory = std::get<ExternalMemoryMapping>(*mBlobMemory);
         *outCaching = memory.caching;
         return 0;
-    } else if (std::holds_alternative<ExternalMemoryDescriptor>(*mBlobMemory)) {
-        auto& descriptor = std::get<ExternalMemoryDescriptor>(*mBlobMemory);
-        *outCaching = descriptor->caching;
+    } else if (std::holds_alternative<ExternalMemoryInfo>(*mBlobMemory)) {
+        auto& memory = std::get<ExternalMemoryInfo>(*mBlobMemory);
+        *outCaching = memory->caching;
         return 0;
     }
 
@@ -397,15 +518,6 @@ int VirtioGpuResource::GetCaching(uint32_t* outCaching) const {
     return -EINVAL;
 }
 
-int VirtioGpuResource::WaitSyncResource() {
-    if (mResourceType != VirtioGpuResourceType::COLOR_BUFFER) {
-        stream_renderer_error("waitSyncResource is undefined for non-ColorBuffer resource.");
-        return -EINVAL;
-    }
-
-    return FrameBuffer::getFB()->waitSyncColorBuffer(mId);
-}
-
 // Corresponds to Virtio GPU "TransferFromHost" commands and VMM requests to
 // copy into display buffers.
 int VirtioGpuResource::TransferRead(const GoldfishPipeServiceOps* ops, uint64_t offset,
@@ -792,12 +904,12 @@ int VirtioGpuResource::ExportBlob(struct stream_renderer_handle* outHandle) {
 #else
         outHandle->os_handle = static_cast<int64_t>(memory->releaseHandle());
 #endif
-        outHandle->handle_type = STREAM_MEM_HANDLE_TYPE_SHM;
+        outHandle->handle_type = STREAM_HANDLE_TYPE_MEM_SHM;
         return 0;
-    } else if (std::holds_alternative<ExternalMemoryDescriptor>(*mBlobMemory)) {
-        auto& memory = std::get<ExternalMemoryDescriptor>(*mBlobMemory);
+    } else if (std::holds_alternative<ExternalMemoryInfo>(*mBlobMemory)) {
+        auto& memory = std::get<ExternalMemoryInfo>(*mBlobMemory);
 
-        auto rawDescriptorOpt = memory->descriptor.release();
+        auto rawDescriptorOpt = memory->descriptorInfo.descriptor.release();
         if (!rawDescriptorOpt) {
             stream_renderer_error(
                 "failed to export blob for resource %u: failed to get raw handle.", mId);
@@ -810,7 +922,7 @@ int VirtioGpuResource::ExportBlob(struct stream_renderer_handle* outHandle) {
 #else
         outHandle->os_handle = static_cast<int64_t>(rawDescriptor);
 #endif
-        outHandle->handle_type = memory->handleType;
+        outHandle->handle_type = memory->descriptorInfo.streamHandleType;
         return 0;
     }
 
@@ -867,7 +979,7 @@ std::optional<VirtioGpuResourceSnapshot> VirtioGpuResource::Snapshot() const {
                 return std::nullopt;
             }
             resourceSnapshot.mutable_ring_blob()->Swap(&*snapshotRingBlobOpt);
-        } else if (std::holds_alternative<ExternalMemoryDescriptor>(*mBlobMemory)) {
+        } else if (std::holds_alternative<ExternalMemoryInfo>(*mBlobMemory)) {
             if (!mLatestAttachedContext) {
                 stream_renderer_error("Failed to snapshot resource %d: missing blob context?", mId);
                 return std::nullopt;
@@ -982,4 +1094,4 @@ std::optional<VirtioGpuResourceSnapshot> VirtioGpuResource::Snapshot() const {
 #endif  // #ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
 
 }  // namespace host
-}  // namespace gfxstream
\ No newline at end of file
+}  // namespace gfxstream
diff --git a/host/VirtioGpuResource.h b/host/VirtioGpuResource.h
index 93002c2aa..d7dae643f 100644
--- a/host/VirtioGpuResource.h
+++ b/host/VirtioGpuResource.h
@@ -60,6 +60,10 @@ class VirtioGpuResource {
         const struct stream_renderer_resource_create_args* args, struct iovec* iov,
         uint32_t num_iovs);
 
+    static std::optional<VirtioGpuResource> Create(
+        uint32_t res_handle, const struct stream_renderer_handle* import_handle,
+        const struct stream_renderer_import_data* import_data);
+
     static std::optional<VirtioGpuResource> Create(
         const gfxstream::host::FeatureSet& features, uint32_t pageSize, uint32_t contextId,
         uint32_t resourceId, const struct stream_renderer_resource_create_args* createArgs,
@@ -68,6 +72,9 @@ class VirtioGpuResource {
 
     int Destroy();
 
+    int ImportHandle(const stream_renderer_handle* handle,
+                     const stream_renderer_import_data* import_data);
+
     VirtioGpuResourceId GetId() const { return mId; }
 
     void AttachIov(struct iovec* iov, uint32_t num_iovs);
@@ -87,8 +94,6 @@ class VirtioGpuResource {
 
     void SetHostPipe(GoldfishHostPipe* pipe) { mHostPipe = pipe; }
 
-    int WaitSyncResource();
-
     // Corresponds to Virtio GPU "TransferFromHost" commands and VMM requests to
     // copy into display buffers.
     int TransferRead(const GoldfishPipeServiceOps* ops, uint64_t offset, stream_renderer_box* box,
@@ -170,11 +175,10 @@ class VirtioGpuResource {
     //   * For non ring blobs, the memory from the backend as either an external
     //     memory handle (`BlobDescriptorInfo`) or a raw mapping.
     using RingBlobMemory = std::shared_ptr<RingBlob>;
-    using ExternalMemoryDescriptor = std::shared_ptr<BlobDescriptorInfo>;
+    using ExternalMemoryInfo = std::shared_ptr<BlobDescriptorInfo>;
     using ExternalMemoryMapping = HostMemInfo;
 
-    using BlobMemory =
-        std::variant<RingBlobMemory, ExternalMemoryDescriptor, ExternalMemoryMapping>;
+    using BlobMemory = std::variant<RingBlobMemory, ExternalMemoryInfo, ExternalMemoryMapping>;
     std::optional<BlobMemory> mBlobMemory;
     // LINT.ThenChange(VirtioGpuResourceSnapshot.proto:virtio_gpu_resource)
 };
diff --git a/host/VirtioGpuTimelines.cpp b/host/VirtioGpuTimelines.cpp
index 12c74b430..a7f5515e6 100644
--- a/host/VirtioGpuTimelines.cpp
+++ b/host/VirtioGpuTimelines.cpp
@@ -30,7 +30,9 @@ std::unique_ptr<VirtioGpuTimelines> VirtioGpuTimelines::create(FenceCompletionCa
 }
 
 VirtioGpuTimelines::VirtioGpuTimelines(FenceCompletionCallback callback)
-    : mNextId(0), mFenceCompletionCallback(std::move(callback)) {}
+    : mFenceCompletionCallback(std::move(callback)), mNextId(0) {
+        gfxstream::host::InitializeTracing();
+    }
 
 TaskId VirtioGpuTimelines::enqueueTask(const Ring& ring) {
     std::lock_guard<std::mutex> lock(mTimelinesMutex);
@@ -162,3 +164,200 @@ void VirtioGpuTimelines::poll_locked(const Ring& ring) {
     }
     timelineQueue.erase(timelineQueue.begin(), i);
 }
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+
+std::optional<gfxstream::host::snapshot::VirtioGpuRing> SnapshotRing(const VirtioGpuRing& ring) {
+    gfxstream::host::snapshot::VirtioGpuRing snapshot;
+
+    if (std::holds_alternative<VirtioGpuRingGlobal>(ring)) {
+        snapshot.mutable_global();
+    } else if (std::holds_alternative<VirtioGpuRingContextSpecific>(ring)) {
+        auto& specific = std::get<VirtioGpuRingContextSpecific>(ring);
+
+        auto* specificSnapshot = snapshot.mutable_context_specific();
+        specificSnapshot->set_context_id(specific.mCtxId);
+        specificSnapshot->set_ring_id(specific.mRingIdx);
+    } else {
+        return std::nullopt;
+    }
+
+    return snapshot;
+}
+
+std::optional<VirtioGpuRing> RestoreRing(const gfxstream::host::snapshot::VirtioGpuRing& snapshot) {
+    if (snapshot.has_global()) {
+        return VirtioGpuRingGlobal{};
+    } else if (snapshot.has_context_specific()) {
+        const auto& specific = snapshot.context_specific();
+        return VirtioGpuRingContextSpecific{
+            .mCtxId = specific.context_id(),
+            .mRingIdx = static_cast<VirtioGpuRingIdx>(specific.ring_id()),
+        };
+    } else {
+        return std::nullopt;
+    }
+}
+
+/*static*/
+std::optional<gfxstream::host::snapshot::VirtioGpuTimelineItem>
+VirtioGpuTimelines::SnapshotTimelineItem(const TimelineItem& timelineItem) {
+    gfxstream::host::snapshot::VirtioGpuTimelineItem snapshot;
+
+    if (std::holds_alternative<FenceId>(timelineItem)) {
+        auto fenceId = std::get<FenceId>(timelineItem);
+
+        auto* fenceSnapshot = snapshot.mutable_fence();
+        fenceSnapshot->set_id(fenceId);
+    } else if (std::holds_alternative<std::shared_ptr<Task>>(timelineItem)) {
+        const auto& task = std::get<std::shared_ptr<Task>>(timelineItem);
+
+        auto ringOpt = SnapshotRing(task->mRing);
+        if (!ringOpt) {
+            stream_renderer_error("Failed to snapshot timeline item: failed to snapshot ring.");
+            return std::nullopt;
+        }
+
+        auto* taskSnapshot = snapshot.mutable_task();
+        taskSnapshot->set_id(task->mId);
+        taskSnapshot->mutable_ring()->Swap(&*ringOpt);
+        taskSnapshot->set_trace_id(task->mTraceId);
+        taskSnapshot->set_completed(task->mHasCompleted);
+    } else {
+        stream_renderer_error("Failed to snapshot timeline item: unhandled.");
+        return std::nullopt;
+    }
+
+    return snapshot;
+}
+
+/*static*/
+std::optional<VirtioGpuTimelines::TimelineItem> VirtioGpuTimelines::RestoreTimelineItem(
+    const gfxstream::host::snapshot::VirtioGpuTimelineItem& snapshot) {
+    if (snapshot.has_fence()) {
+        return snapshot.fence().id();
+    } else if (snapshot.has_task()) {
+        const auto& taskSnapshot = snapshot.task();
+
+        auto ringOpt = RestoreRing(taskSnapshot.ring());
+        if (!ringOpt) {
+            stream_renderer_error("Failed to restore timeline item: failed to restore ring.");
+            return std::nullopt;
+        }
+
+        auto task = std::make_shared<Task>(taskSnapshot.id(), *ringOpt, taskSnapshot.trace_id());
+        task->mHasCompleted = taskSnapshot.completed();
+        return task;
+    }
+
+    stream_renderer_error("Failed to restore timeline item: unhandled.");
+    return std::nullopt;
+}
+
+std::optional<gfxstream::host::snapshot::VirtioGpuTimeline> VirtioGpuTimelines::Timeline::Snapshot()
+    const {
+    gfxstream::host::snapshot::VirtioGpuTimeline timeline;
+    timeline.set_trace_id(mTraceTrackId);
+    for (const auto& timelineItem : mQueue) {
+        auto timelineItemSnapshotOpt = SnapshotTimelineItem(timelineItem);
+        if (!timelineItemSnapshotOpt) {
+            stream_renderer_error("Failed to snapshot timeline item.");
+            return std::nullopt;
+        }
+        timeline.mutable_items()->Add(std::move(*timelineItemSnapshotOpt));
+    }
+    return timeline;
+}
+
+/*static*/
+std::optional<VirtioGpuTimelines::Timeline> VirtioGpuTimelines::Timeline::Restore(
+    const gfxstream::host::snapshot::VirtioGpuTimeline& snapshot) {
+    VirtioGpuTimelines::Timeline timeline;
+    timeline.mTraceTrackId = snapshot.trace_id();
+    for (const auto& timelineItemSnapshot : snapshot.items()) {
+        auto timelineItemOpt = RestoreTimelineItem(timelineItemSnapshot);
+        if (!timelineItemOpt) {
+            stream_renderer_error("Failed to snapshot timeline item.");
+            return std::nullopt;
+        }
+        timeline.mQueue.emplace_back(std::move(*timelineItemOpt));
+    }
+    return timeline;
+}
+
+std::optional<gfxstream::host::snapshot::VirtioGpuTimelinesSnapshot> VirtioGpuTimelines::Snapshot()
+    const {
+    std::lock_guard<std::mutex> lock(mTimelinesMutex);
+
+    gfxstream::host::snapshot::VirtioGpuTimelinesSnapshot snapshot;
+    snapshot.set_next_id(mNextId);
+
+    for (const auto& [ring, timeline] : mTimelineQueues) {
+        auto ringSnapshotOpt = SnapshotRing(ring);
+        if (!ringSnapshotOpt) {
+            stream_renderer_error("Failed to snapshot timelines: failed to snapshot ring.");
+            return std::nullopt;
+        }
+
+        auto timelineSnapshotOpt = timeline.Snapshot();
+        if (!timelineSnapshotOpt) {
+            stream_renderer_error("Failed to snapshot timelines: failed to snapshot timeline.");
+            return std::nullopt;
+        }
+
+        auto* kv = snapshot.add_timelines();
+        kv->mutable_ring()->Swap(&*ringSnapshotOpt);
+        kv->mutable_timeline()->Swap(&*timelineSnapshotOpt);
+    }
+
+    return snapshot;
+}
+
+/*static*/
+std::unique_ptr<VirtioGpuTimelines> VirtioGpuTimelines::Restore(
+    FenceCompletionCallback callback,
+    const gfxstream::host::snapshot::VirtioGpuTimelinesSnapshot& snapshot) {
+    std::unique_ptr<VirtioGpuTimelines> timelines(new VirtioGpuTimelines(std::move(callback)));
+
+    std::lock_guard<std::mutex> lock(timelines->mTimelinesMutex);
+
+    timelines->mNextId.store(snapshot.next_id());
+
+    for (const auto& timelineSnapshot : snapshot.timelines()) {
+        if (!timelineSnapshot.has_ring()) {
+            stream_renderer_error("Failed to restore timelines: missing ring.");
+            return nullptr;
+        }
+        auto ringOpt = RestoreRing(timelineSnapshot.ring());
+        if (!ringOpt) {
+            stream_renderer_error("Failed to restore timelines: failed to restore ring.");
+            return nullptr;
+        }
+
+        if (!timelineSnapshot.has_timeline()) {
+            stream_renderer_error("Failed to restore timelines: missing timeline.");
+            return nullptr;
+        }
+        auto timelineOpt = Timeline::Restore(timelineSnapshot.timeline());
+        if (!timelineOpt) {
+            stream_renderer_error("Failed to restore timelines: failed to restore timeline.");
+            return nullptr;
+        }
+
+        timelines->mTimelineQueues[std::move(*ringOpt)] = std::move(*timelineOpt);
+    }
+
+    // Rebuild task index:
+    for (const auto& [_, timeline] : timelines->mTimelineQueues) {
+        for (const auto& timelineItem : timeline.mQueue) {
+            if (std::holds_alternative<std::shared_ptr<Task>>(timelineItem)) {
+                auto& task = std::get<std::shared_ptr<Task>>(timelineItem);
+                timelines->mTaskIdToTask[task->mId] = task;
+            }
+        }
+    }
+
+    return timelines;
+}
+
+#endif  // GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
\ No newline at end of file
diff --git a/host/VirtioGpuTimelines.h b/host/VirtioGpuTimelines.h
index fc0f2bb53..aeeb666e6 100644
--- a/host/VirtioGpuTimelines.h
+++ b/host/VirtioGpuTimelines.h
@@ -24,6 +24,10 @@
 #include <unordered_map>
 #include <variant>
 
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+#include "VirtioGpuTimelinesSnapshot.pb.h"
+#endif  // GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+#include "aemu/base/ThreadAnnotations.h"
 #include "gfxstream/virtio-gpu-gfxstream-renderer.h"
 
 typedef uint32_t VirtioGpuCtxId;
@@ -88,38 +92,73 @@ class VirtioGpuTimelines {
     void notifyTaskCompletion(TaskId);
     void poll();
 
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+    std::optional<gfxstream::host::snapshot::VirtioGpuTimelinesSnapshot> Snapshot() const;
+
+    static std::unique_ptr<VirtioGpuTimelines> Restore(
+        FenceCompletionCallback callback,
+        const gfxstream::host::snapshot::VirtioGpuTimelinesSnapshot& snapshot);
+#endif
+
    private:
     VirtioGpuTimelines(FenceCompletionCallback callback);
 
     struct Task {
+        Task(TaskId id, const Ring& ring, uint64_t traceId)
+            : mId(id), mRing(ring), mTraceId(traceId), mHasCompleted(false) {}
+
+        // LINT.IfChange(virtio_gpu_timeline_task)
         TaskId mId;
         Ring mRing;
         uint64_t mTraceId;
         std::atomic_bool mHasCompleted;
-        Task(TaskId id, const Ring& ring, uint64_t traceId)
-            : mId(id), mRing(ring), mTraceId(traceId), mHasCompleted(false) {}
+        // LINT.ThenChange(VirtioGpuTimelinesSnapshot.proto:virtio_gpu_timeline_task)
     };
 
+    // LINT.IfChange(virtio_gpu_timeline_item)
     using TimelineItem = std::variant<FenceId, std::shared_ptr<Task>>;
+    // LINT.ThenChange(VirtioGpuTimelinesSnapshot.proto:virtio_gpu_timeline_item)
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+    static std::optional<gfxstream::host::snapshot::VirtioGpuTimelineItem> SnapshotTimelineItem(
+        const TimelineItem& timelineItem);
+
+    static std::optional<TimelineItem> RestoreTimelineItem(
+        const gfxstream::host::snapshot::VirtioGpuTimelineItem& snapshot);
+#endif
+
     struct Timeline {
+        // LINT.IfChange(virtio_gpu_timeline)
         uint64_t mTraceTrackId;
         std::list<TimelineItem> mQueue;
+        // LINT.ThenChange(VirtioGpuTimelinesSnapshot.proto:virtio_gpu_timeline)
+
+#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_FRONTEND_SUPPORT
+        std::optional<gfxstream::host::snapshot::VirtioGpuTimeline> Snapshot() const;
+
+        static std::optional<Timeline> Restore(
+            const gfxstream::host::snapshot::VirtioGpuTimeline& snapshot);
+#endif
     };
 
-    Timeline& GetOrCreateTimelineLocked(const Ring& ring);
+    Timeline& GetOrCreateTimelineLocked(const Ring& ring) REQUIRES(mTimelinesMutex);
 
     // Go over the timeline, signal any fences without pending tasks, and remove
     // timeline items that are no longer needed.
-    void poll_locked(const Ring&);
+    void poll_locked(const Ring&) REQUIRES(mTimelinesMutex);
 
-    std::atomic<TaskId> mNextId;
     FenceCompletionCallback mFenceCompletionCallback;
-    std::mutex mTimelinesMutex;
+
+    mutable std::mutex mTimelinesMutex;
     // The mTaskIdToTask cache must be destroyed after the actual owner of Task,
     // mTimelineQueues, is destroyed, because the deleter of Task will
     // automatically remove the entry in mTaskIdToTask.
     std::unordered_map<TaskId, std::weak_ptr<Task>> mTaskIdToTask;
-    std::unordered_map<Ring, Timeline> mTimelineQueues;
+
+    // LINT.IfChange(virtio_gpu_timelines)
+    std::atomic<TaskId> mNextId;
+    std::unordered_map<Ring, Timeline> mTimelineQueues GUARDED_BY(mTimelinesMutex);
+    // LINT.ThenChange(VirtioGpuTimelinesSnapshot.proto:virtio_gpu_timelines)
 };
 
 #endif  // VIRTIO_GPU_TIMELINES_H
diff --git a/host/VirtioGpuTimelinesSnapshot.proto b/host/VirtioGpuTimelinesSnapshot.proto
new file mode 100644
index 000000000..5e939f426
--- /dev/null
+++ b/host/VirtioGpuTimelinesSnapshot.proto
@@ -0,0 +1,72 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package gfxstream.host.snapshot;
+
+message VirtioGpuGlobalRing {}
+
+message VirtioGpuContextSpecificRing {
+    optional uint32 context_id = 1;
+    optional uint32 ring_id = 2;
+}
+
+message VirtioGpuRing {
+    oneof ring {
+        VirtioGpuGlobalRing global = 1;
+        VirtioGpuContextSpecificRing context_specific = 2;
+    }
+}
+
+message VirtioGpuTimelineFence {
+    optional uint64 id = 1;
+}
+
+// LINT.IfChange(virtio_gpu_timeline_task)
+message VirtioGpuTimelineTask {
+    optional uint64 id = 1;
+    optional VirtioGpuRing ring = 2;
+    optional uint64 trace_id = 3;
+    optional bool completed = 4;
+}
+// LINT.ThenChange(VirtioGpuTimelines.h:virtio_gpu_timeline_task)
+
+// LINT.IfChange(virtio_gpu_timeline_item)
+message VirtioGpuTimelineItem {
+    oneof item {
+        VirtioGpuTimelineFence fence = 1;
+        VirtioGpuTimelineTask task = 2;
+    }
+}
+// LINT.ThenChange(VirtioGpuTimelines.h:virtio_gpu_timeline_item)
+
+// LINT.IfChange(virtio_gpu_timeline)
+message VirtioGpuTimeline {
+    optional uint64 trace_id = 1;
+    repeated VirtioGpuTimelineItem items = 2;
+}
+// LINT.ThenChange(VirtioGpuTimelines.h:virtio_gpu_timeline)
+
+// LINT.IfChange(virtio_gpu_timelines)
+message VirtioGpuTimelinesSnapshot {
+    optional uint64 next_id = 1;
+
+    message RingWithTimeline {
+        optional VirtioGpuRing ring = 1;
+        optional VirtioGpuTimeline timeline = 2;
+    }
+    repeated RingWithTimeline timelines = 2;
+}
+// LINT.ThenChange(VirtioGpuTimelines.h:virtio_gpu_timelines)
diff --git a/host/tests/VirtioGpuTimelines_unittest.cpp b/host/VirtioGpuTimelinesTests.cpp
similarity index 100%
rename from host/tests/VirtioGpuTimelines_unittest.cpp
rename to host/VirtioGpuTimelinesTests.cpp
diff --git a/host/apigen-codec-common/BUILD.bazel b/host/apigen-codec-common/BUILD.bazel
index 1172ba754..ccdc86749 100644
--- a/host/apigen-codec-common/BUILD.bazel
+++ b/host/apigen-codec-common/BUILD.bazel
@@ -1,5 +1,7 @@
 # File: project_root/src/apigen-codec-common/BUILD
 
+load("@rules_cc//cc:defs.bzl", "cc_library")
+
 cc_library(
     name = "apigen-codec-common",
     srcs = [
@@ -32,8 +34,8 @@ cc_library(
     includes = ["."],
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/aemu/base:aemu-base-headers",
-        "//hardware/google/aemu/host-common:aemu-host-common",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
+        "//:gfxstream-gl-host-common-headers",
+        "@aemu//base:aemu-base-headers",
+        "@aemu//host-common:aemu-host-common",
     ],
 )
diff --git a/host/backend/BUILD.bazel b/host/backend/BUILD.bazel
index 5de9100cc..8c0823a9c 100644
--- a/host/backend/BUILD.bazel
+++ b/host/backend/BUILD.bazel
@@ -1,9 +1,11 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
+
 cc_library(
     name = "gfxstream_backend",
     srcs = glob(["include/**/*.h"]),
     includes = ["include"],
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/gfxstream/common/utils:gfxstream_common_utils",
+        "//common/utils:gfxstream_common_utils",
     ],
-)
\ No newline at end of file
+)
diff --git a/host/backend/include/gfxstream/host/BackendCallbacks.h b/host/backend/include/gfxstream/host/BackendCallbacks.h
index 6efe6fe29..9224113e8 100644
--- a/host/backend/include/gfxstream/host/BackendCallbacks.h
+++ b/host/backend/include/gfxstream/host/BackendCallbacks.h
@@ -42,6 +42,12 @@ struct BackendCallbacks {
     using ScheduleAsyncWorkFunc =
         std::function<CancelableFuture(std::function<void()> work, std::string description)>;
     ScheduleAsyncWorkFunc scheduleAsyncWork;
+
+    using RegisterVulkanInstanceFunc = std::function<void(uint64_t id, const char* appName)>;
+    RegisterVulkanInstanceFunc registerVulkanInstance;
+
+    using UnregisterVulkanInstanceFunc = std::function<void(uint64_t id)>;
+    UnregisterVulkanInstanceFunc unregisterVulkanInstance;
 };
 
 }  // namespace host
diff --git a/host/features/Features.cpp b/host/features/Features.cpp
index 0e126aaea..1249204b1 100644
--- a/host/features/Features.cpp
+++ b/host/features/Features.cpp
@@ -22,23 +22,6 @@ FeatureSet::FeatureSet(const FeatureSet& rhs) : FeatureSet() {
     *this = rhs;
 }
 
-FeatureResult FeatureDependencyHandler::checkAllDependentFeaturesAreEnabled() {
-    // Only check for direct dependencies. Since we're verifying all enabled features, this should cover the whole span.
-    bool allDependenciesAreEnabled = true;
-    std::stringstream ss;
-    for (auto const&[feature, dependentFeatures] : VK_FEATURE_DEPENDENCY_MAP) {
-        if (feature->enabled && !dependentFeatures.empty()) {
-            for (auto const& dep : dependentFeatures) {
-                if (!dep->enabled) {
-                    ss << "Feature: " << feature->name << " requests missing dependency: " << dep->name << "\n";
-                    allDependenciesAreEnabled = false;
-                }
-            }
-        }
-    }
-    return {allDependenciesAreEnabled, ss.str()};
-};
-
 FeatureSet& FeatureSet::operator=(const FeatureSet& rhs) {
     for (const auto& [featureName, featureInfo] : rhs.map) {
         *map[featureName] = *featureInfo;
diff --git a/host/features/include/gfxstream/host/Features.h b/host/features/include/gfxstream/host/Features.h
index 6c03a703c..1b9e6b6f0 100644
--- a/host/features/include/gfxstream/host/Features.h
+++ b/host/features/include/gfxstream/host/Features.h
@@ -221,8 +221,10 @@ struct FeatureSet {
     };
     FeatureInfo BypassVulkanDeviceFeatureOverrides = {
         "BypassVulkanDeviceFeatureOverrides",
-        "We are force disabling (overriding) some vulkan features (private data, uniform inline block etc) which the device may naturally support."
-        "If toggled ON, this flag will cause the host side to not force disable anything and let the device fully advertise supported features.",
+        "We are force disabling (overriding) some vulkan features (private data, uniform inline "
+        "block etc) which the device may naturally support."
+        "If toggled ON, this flag will cause the host side to not force disable anything and let "
+        "the device fully advertise supported features.",
         &map,
     };
     FeatureInfo VulkanAllocateDeviceMemoryOnly = {
@@ -321,17 +323,12 @@ struct FeatureSet {
         "device properties for the guest queries.",
         &map,
     };
-};
-struct FeatureDependencyHandler {
-    FeatureDependencyHandler(const FeatureSet& set) : featureSetView(set){}
-    const FeatureSet& featureSetView;
-    const std::map<const FeatureInfo*, std::vector<const FeatureInfo*>> VK_FEATURE_DEPENDENCY_MAP= {
-        // List other dependencies here in the shape of:
-        // {FEATURE_X, {DEPENDENT_FEATURE_A, DEPENDENT_FEATURE_B}}
-        {&featureSetView.VulkanSnapshots, {&featureSetView.VulkanBatchedDescriptorSetUpdate, &featureSetView.Vulkan}},
+    FeatureInfo VulkanRobustness = {
+        "VulkanRobustness",
+        "If enabled, robustness extensions with all supported features will be enabled on "
+        "all created devices. (e.g. VK_EXT_robustness2)",
+        &map,
     };
-
-    FeatureResult checkAllDependentFeaturesAreEnabled();
 };
 
 #define GFXSTREAM_SET_FEATURE_ON_CONDITION(set, feature, condition) \
diff --git a/host/gl/Android.bp b/host/gl/Android.bp
index bf36ed372..5e21ad305 100644
--- a/host/gl/Android.bp
+++ b/host/gl/Android.bp
@@ -38,6 +38,7 @@ cc_library_static {
         "libgfxstream_host_features",
         "libgfxstream_host_gles1_dec",
         "libgfxstream_host_gles2_dec",
+        "libgfxstream_host_glestranslator_glcommon",
         "libgfxstream_host_glsnapshot",
     ],
 }
diff --git a/host/gl/BUILD.bazel b/host/gl/BUILD.bazel
index 88420f7d0..38256313b 100644
--- a/host/gl/BUILD.bazel
+++ b/host/gl/BUILD.bazel
@@ -1,3 +1,5 @@
+load("@rules_cc//cc:defs.bzl", "cc_library", "objc_library")
+
 cc_library(
     name = "gles1_dec",
     srcs = [
@@ -10,8 +12,8 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         ":GLSnapshot",
-        "//hardware/google/gfxstream/common/opengl:gfxstream_opengl_headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
+        "//common/opengl:gfxstream_opengl_headers",
+        "//host/apigen-codec-common",
     ],
 )
 
@@ -23,18 +25,21 @@ objc_library(
     hdrs = ["gl-host-common/include/host-common/opengl/macTouchOpenGL.h"],
     defines = ["EMUGL_BUILD"],
     includes = ["gl-host-common/include"],
+    target_compatible_with = [
+        "@platforms//os:macos",
+    ],
     deps = [
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
+        "//:gfxstream-gl-host-common-headers",
     ],
 )
 
 cc_library(
     name = "gl-common-headers",
-    hdrs = glob(["glestranslator/include/**/*.h"]),
+    hdrs = glob(["glestranslator/GLcommon/include/**/*.h"]),
     copts = ["-fno-exceptions"],
-    includes = ["glestranslator/include"],
+    includes = ["glestranslator/GLcommon/include"],
     visibility = ["//visibility:public"],
-    deps = ["//hardware/google/gfxstream/host/apigen-codec-common"],
+    deps = ["//host/apigen-codec-common"],
 )
 
 objc_library(
@@ -51,9 +56,12 @@ objc_library(
         "CoreGraphics",
         "OpenGL",
     ],
+    target_compatible_with = [
+        "@platforms//os:macos",
+    ],
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
+        "//:gfxstream-gl-host-common-headers",
     ],
     alwayslink = True,
 )
@@ -103,15 +111,16 @@ cc_library(
     deps =
         [
             ":gl-common-headers",
-            "//hardware/google/aemu/host-common:aemu-host-common-headers",
-            "//hardware/google/aemu/snapshot:aemu-snapshot",
-            "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-            "//hardware/google/gfxstream/common/etc:gfxstream_etc",
-            "//hardware/google/gfxstream/common/opengl:gfxstream_opengl_headers",
-            "//hardware/google/gfxstream/host/apigen-codec-common",
-            "//hardware/google/gfxstream/host/gl:gfxstream-gl-host-common",
-            "//hardware/google/gfxstream/host/gl/glestranslator/GLES_CM:GLES_CM_translator_static",
-            "//hardware/google/gfxstream/host/gl/glestranslator/GLES_V2:GLES_V2_translator_static",
+            "//:gfxstream-gl-host-common-headers",
+            "//common/etc:gfxstream_etc",
+            "//common/opengl:gfxstream_opengl_headers",
+            "//host:gfxstream_host_headers",
+            "//host/apigen-codec-common",
+            "//host/gl:gfxstream-gl-host-common",
+            "//host/gl/glestranslator/GLES_CM:GLES_CM_translator_static",
+            "//host/gl/glestranslator/GLES_V2:GLES_V2_translator_static",
+            "@aemu//host-common:aemu-host-common-headers",
+            "@aemu//snapshot:aemu-snapshot",
         ] + select({
             "@platforms//os:macos": [":egl_translator-darwin"],
             "//conditions:default": [],
@@ -154,10 +163,10 @@ cc_library(
     deps = [
         ":gl-common-headers",
         # "//external/angle:angle-headers",
-        "//hardware/google/gfxstream/common/opengl:gfxstream_opengl_headers",
-        "//hardware/google/aemu/snapshot:aemu-snapshot",
-        "//hardware/google/gfxstream/common/etc:gfxstream_etc",
-        "//hardware/google/gfxstream/host:gfxstream-compressedTextures",
+        "//common/opengl:gfxstream_opengl_headers",
+        "@aemu//snapshot:aemu-snapshot",
+        "//common/etc:gfxstream_etc",
+        "//host:gfxstream-compressedTextures",
     ],
 )
 
@@ -166,7 +175,6 @@ cc_library(
     srcs = [
         "gl-host-common/opengl/EmuglBackendList.cpp",
         "gl-host-common/opengl/GLProcessPipe.cpp",
-        "gl-host-common/opengl/GpuFrameBridge.cpp",
         "gl-host-common/opengl/OpenglEsPipe.cpp",
         "gl-host-common/opengl/emugl_config.cpp",
         "gl-host-common/opengl/gpuinfo.cpp",
@@ -197,10 +205,10 @@ cc_library(
     }),
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/aemu/snapshot:aemu-snapshot",
-        "//hardware/google/gfxstream/common/opengl:gfxstream_opengl_headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
-        "//hardware/google/gfxstream/host/features:gfxstream_features",
+        "//common/opengl:gfxstream_opengl_headers",
+        "//host/apigen-codec-common",
+        "//host/features:gfxstream_features",
+        "@aemu//snapshot:aemu-snapshot",
     ] + select({
         "@platforms//os:macos": ["gfxstream-gl-host-common-darwin"],
         "//conditions:default": [],
@@ -219,9 +227,9 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         ":GLSnapshot",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/common/opengl:gfxstream_opengl_headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
+        "//:gfxstream-gl-host-common-headers",
+        "//common/opengl:gfxstream_opengl_headers",
+        "//host/apigen-codec-common",
     ],
 )
 
@@ -236,7 +244,7 @@ cc_library(
     defines = ["EMUGL_BUILD"],
     includes = ["glsnapshot"],
     visibility = ["//visibility:public"],
-    deps = ["//hardware/google/gfxstream/host/apigen-codec-common"],
+    deps = ["//host/apigen-codec-common"],
 )
 
 cc_library(
@@ -249,7 +257,7 @@ cc_library(
         "OpenGLESDispatch/StaticDispatch.cpp",
         "OpenGLESDispatch/gles1_stubbed_in_translator_namespace.cpp",
         "OpenGLESDispatch/gles2_stubbed_in_translator_namespace.cpp",
-    ] + glob(["OpenGLESDispatch/*.h"]),
+    ],
     copts = [
         "-fno-exceptions",
         "-Wno-extern-c-compat",
@@ -260,9 +268,9 @@ cc_library(
         ":EGL_translator_static",
         ":gles1_dec",
         ":gles2_dec",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/common/opengl:gfxstream_opengl_headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
+        "//:gfxstream-gl-host-common-headers",
+        "//common/opengl:gfxstream_opengl_headers",
+        "//host/apigen-codec-common",
     ],
 )
 
@@ -288,7 +296,6 @@ cc_library(
         "YUVConverter.cpp",
     ] + glob([
         "*.h",
-        "glestranslator/include/**/*.h",
     ]),
     hdrs = [],
     copts = [
@@ -305,10 +312,10 @@ cc_library(
         ":gfxstream-gl-host-common",
         ":gles1_dec",
         ":gles2_dec",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/host:gfxstream_host_headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
-        "//hardware/google/gfxstream/host/gl:GLSnapshot",
+        "//:gfxstream-gl-host-common-headers",
+        "//host:gfxstream_host_headers",
+        "//host/apigen-codec-common",
+        "//host/gl:GLSnapshot",
     ],
 )
 
diff --git a/host/gl/CMakeLists.txt b/host/gl/CMakeLists.txt
index 45238f727..d617d17cc 100644
--- a/host/gl/CMakeLists.txt
+++ b/host/gl/CMakeLists.txt
@@ -40,6 +40,7 @@ target_link_libraries(
         gfxstream_egl_headers
         gles1_dec
         gles2_dec
+        GLcommon
         GLSnapshot
         OpenGLESDispatch)
 
diff --git a/host/gl/ColorBufferGl.cpp b/host/gl/ColorBufferGl.cpp
index 213de8af1..4e1856295 100644
--- a/host/gl/ColorBufferGl.cpp
+++ b/host/gl/ColorBufferGl.cpp
@@ -21,13 +21,13 @@
 
 #include "BorrowedImageGl.h"
 #include "DebugGl.h"
+#include "GLcommon/GLutils.h"
 #include "OpenGLESDispatch/DispatchTables.h"
 #include "OpenGLESDispatch/EGLDispatch.h"
 #include "RenderThreadInfoGl.h"
 #include "TextureDraw.h"
 #include "TextureResize.h"
 #include "gl/YUVConverter.h"
-#include "glestranslator/include/GLcommon/GLutils.h"
 #include "host-common/GfxstreamFatalError.h"
 #include "host-common/opengl/misc.h"
 
@@ -324,10 +324,6 @@ std::unique_ptr<ColorBufferGl> ColorBufferGl::create(EGLDisplay p_display, int p
         cb->m_BRSwizzle = true;
     }
 
-    cb->m_eglImage = s_egl.eglCreateImageKHR(
-            p_display, s_egl.eglGetCurrentContext(), EGL_GL_TEXTURE_2D_KHR,
-            (EGLClientBuffer)SafePointerFromUInt(cb->m_tex), NULL);
-
     cb->m_blitEGLImage = s_egl.eglCreateImageKHR(
             p_display, s_egl.eglGetCurrentContext(), EGL_GL_TEXTURE_2D_KHR,
             (EGLClientBuffer)SafePointerFromUInt(cb->m_blitTex), NULL);
@@ -350,9 +346,50 @@ std::unique_ptr<ColorBufferGl> ColorBufferGl::create(EGLDisplay p_display, int p
         cb->m_asyncReadbackType = GL_UNSIGNED_INT_8_8_8_8_REV;
     }
 
+    // Check the ExternalObjectManager for an external memory handle provided for import
+    auto extResourceHandleInfo =
+        ExternalObjectManager::get()->removeResourceExternalHandleInfo(hndl);
+    if (extResourceHandleInfo) {
+        switch (extResourceHandleInfo->streamHandleType) {
+            case STREAM_HANDLE_TYPE_PLATFORM_EGL_NATIVE_PIXMAP: {
+                void* nativePixmap = reinterpret_cast<void*>(extResourceHandleInfo->handle);
+                cb->m_eglImage =
+                    s_egl.eglCreateImageKHR(p_display, s_egl.eglGetCurrentContext(),
+                                            EGL_NATIVE_PIXMAP_KHR, nativePixmap, nullptr);
+                if (cb->m_eglImage == EGL_NO_IMAGE_KHR) {
+                    ERR("ColorBufferGl::create(): EGL_NATIVE_PIXMAP handle provided as external "
+                        "resource info, but failed to import pixmap (nativePixmap=0x%x)",
+                        nativePixmap);
+                    return nullptr;
+                }
+
+                // Assume nativePixmap is compatible with ColorBufferGl's current dimensions and
+                // internal format.
+                EGLBoolean setInfoRes = s_egl.eglSetImageInfoANDROID(
+                    p_display, cb->m_eglImage, cb->m_width, cb->m_height, cb->m_internalFormat);
+                if (EGL_TRUE != setInfoRes) {
+                    ERR("ColorBufferGl::create(): Failed to set image info");
+                    return nullptr;
+                }
+
+                s_gles2.glBindTexture(GL_TEXTURE_2D, cb->m_tex);
+                s_gles2.glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)cb->m_eglImage);
+            } break;
+            default:
+                ERR("ColorBufferGl::create -- external memory info was provided, but ",
+                    p_internalFormat);
+                return nullptr;
+        }
+    } else {
+        cb->m_eglImage =
+            s_egl.eglCreateImageKHR(p_display, s_egl.eglGetCurrentContext(), EGL_GL_TEXTURE_2D_KHR,
+                                    (EGLClientBuffer)SafePointerFromUInt(cb->m_tex), NULL);
+    }
+
     s_gles2.glPixelStorei(GL_UNPACK_ALIGNMENT, prevUnpackAlignment);
 
     s_gles2.glFinish();
+
     return cb;
 }
 
@@ -1171,63 +1208,28 @@ bool ColorBufferGl::importEglNativePixmap(void* pixmap, bool preserveContent) {
         return false;
     }
 
-    rebindEglImage(image, preserveContent);
-    return true;
-}
-
-bool ColorBufferGl::importEglImage(void* nativeEglImage, bool preserveContent) {
-    EGLImageKHR image = s_egl.eglImportImageANDROID(m_display, (EGLImage)nativeEglImage);
-
-    if (image == EGL_NO_IMAGE_KHR) return false;
-
-    // Assume nativeEglImage is compatible with ColorBufferGl's current dimensions and internal
-    // format.
-    EGLBoolean setInfoRes = s_egl.eglSetImageInfoANDROID(m_display, image, m_width, m_height, m_internalFormat);
+    RecursiveScopedContextBind context(m_helper);
 
-    if (EGL_TRUE != setInfoRes) {
-        s_egl.eglDestroyImageKHR(m_display, image);
-        return false;
+    std::vector<uint8_t> contents;
+    if (preserveContent) {
+        size_t bytes;
+        readContents(&bytes, nullptr);
+        contents.resize(bytes);
+        readContents(&bytes, contents.data());
     }
 
-    rebindEglImage(image, preserveContent);
-    return true;
-}
-
-std::vector<uint8_t> ColorBufferGl::getContents() {
-    // Assume there is a current context.
-    size_t bytes;
-    readContents(&bytes, nullptr);
-    std::vector<uint8_t> contents(bytes);
-    readContents(&bytes, contents.data());
-    return contents;
-}
-
-void ColorBufferGl::clearStorage() {
     s_gles2.glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)NULL);
     s_egl.eglDestroyImageKHR(m_display, m_eglImage);
-    m_eglImage = (EGLImageKHR)0;
-}
-
-void ColorBufferGl::restoreEglImage(EGLImageKHR image) {
-    s_gles2.glBindTexture(GL_TEXTURE_2D, m_tex);
 
     m_eglImage = image;
+    s_gles2.glBindTexture(GL_TEXTURE_2D, m_tex);
     s_gles2.glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)m_eglImage);
-}
-
-void ColorBufferGl::rebindEglImage(EGLImageKHR image, bool preserveContent) {
-    RecursiveScopedContextBind context(m_helper);
-
-    std::vector<uint8_t> contents;
-    if (preserveContent) {
-        contents = getContents();
-    }
-    clearStorage();
-    restoreEglImage(image);
 
     if (preserveContent) {
         replaceContents(contents.data(), m_numBytes);
     }
+
+    return true;
 }
 
 std::unique_ptr<BorrowedImageInfo> ColorBufferGl::getBorrowedImageInfo() {
diff --git a/host/gl/ColorBufferGl.h b/host/gl/ColorBufferGl.h
index 7666a617b..3ec925357 100644
--- a/host/gl/ColorBufferGl.h
+++ b/host/gl/ColorBufferGl.h
@@ -214,9 +214,6 @@ class ColorBufferGl {
                       bool dedicated, bool linearTiling);
     // Change to EGL native pixmap
     bool importEglNativePixmap(void* pixmap, bool preserveContent);
-    // Change to some other native EGL image.  nativeEglImage must not have
-    // been created from our s_egl.eglCreateImage.
-    bool importEglImage(void* nativeEglImage, bool preserveContent);
 
     void setSync(bool debug = false);
     void waitSync(bool debug = false);
@@ -230,14 +227,6 @@ class ColorBufferGl {
 private:
  ColorBufferGl(EGLDisplay display, HandleType hndl, GLuint width, GLuint height,
                ContextHelper* helper, TextureDraw* textureDraw);
- // Helper function to get contents.
- std::vector<uint8_t> getContents();
- // Helper function to clear current EGL image.
- void clearStorage();
- // Helper function to bind EGL image as texture. Assumes storage cleared.
- void restoreEglImage(EGLImageKHR image);
- // Helper function that does the above two operations in one go.
- void rebindEglImage(EGLImageKHR image, bool preserveContent);
 
 private:
     GLuint m_tex = 0;
diff --git a/host/gl/EmulatedEglConfig.cpp b/host/gl/EmulatedEglConfig.cpp
index 1d84562c3..bd82a3470 100644
--- a/host/gl/EmulatedEglConfig.cpp
+++ b/host/gl/EmulatedEglConfig.cpp
@@ -284,7 +284,7 @@ EGLint EmulatedEglConfigList::packConfigs(GLuint bufferByteSize, GLuint* buffer)
     // of the configs, their values.
     memcpy(buffer, kConfigAttributes, kConfigAttributesLen * kGLuintSize);
 
-    for (int i = 0; i < mConfigs.size(); ++i) {
+    for (int i = 0; i < (int)mConfigs.size(); ++i) {
         memcpy(buffer + (i + 1) * kConfigAttributesLen,
                mConfigs[i].mAttribValues.data(),
                kConfigAttributesLen * kGLuintSize);
diff --git a/host/gl/EmulatedEglConfig.h b/host/gl/EmulatedEglConfig.h
index 2a15006b8..ca6c98a25 100644
--- a/host/gl/EmulatedEglConfig.h
+++ b/host/gl/EmulatedEglConfig.h
@@ -124,7 +124,7 @@ class EmulatedEglConfigList {
     // which must be an integer between 0 and |size() - 1|. Returns
     // NULL in case of failure.
     const EmulatedEglConfig* get(int guestId) const {
-        if (guestId >= 0 && guestId < mConfigs.size()) {
+        if (guestId >= 0 && guestId < (int)mConfigs.size()) {
             return &mConfigs[guestId];
         } else {
             return NULL;
diff --git a/host/gl/EmulationGl.cpp b/host/gl/EmulationGl.cpp
index db3635285..e9d975718 100644
--- a/host/gl/EmulationGl.cpp
+++ b/host/gl/EmulationGl.cpp
@@ -461,6 +461,17 @@ std::unique_ptr<EmulationGl> EmulationGl::create(uint32_t width, uint32_t height
     if (s_egl.eglQueryVulkanInteropSupportANDROID) {
         emulationGl->mGlesVulkanInteropSupported = s_egl.eglQueryVulkanInteropSupportANDROID();
     }
+    if (emulationGl->mGlesVulkanInteropSupported) {
+        // Intel: b/271028352 workaround
+        const std::vector<const char*> disallowList = {"Intel", "AMD Radeon Pro WX 3200"};
+        const std::string& glesRenderer = emulationGl->getGlesRenderer();
+        for (const auto& disallowed : disallowList) {
+            if (strstr(glesRenderer.c_str(), disallowed)) {
+                emulationGl->mGlesVulkanInteropSupported = false;
+                break;
+            }
+        }
+    }
 
     emulationGl->mTextureDraw = std::make_unique<TextureDraw>();
     if (!emulationGl->mTextureDraw) {
@@ -504,16 +515,15 @@ std::unique_ptr<EmulationGl> EmulationGl::create(uint32_t width, uint32_t height
 
 EmulationGl::~EmulationGl() {
     if (mPbufferSurface) {
-        // TODO(b/267349580): remove after Mac issue fixed.
-        mTextureDraw.release();
-        // const auto* displaySurfaceGl =
-        //    reinterpret_cast<const DisplaySurfaceGl*>(mPbufferSurface->getImpl());
-        // RecursiveScopedContextBind contextBind(displaySurfaceGl->getContextHelper());
-        // if (contextBind.isOk()) {
-        //     mTextureDraw.reset();
-        // } else {
-        //     ERR("Failed to bind context for destroying TextureDraw.");
-        // }
+        const auto* displaySurfaceGl =
+            reinterpret_cast<const DisplaySurfaceGl*>(mPbufferSurface->getImpl());
+
+        RecursiveScopedContextBind contextBind(displaySurfaceGl->getContextHelper());
+        if (contextBind.isOk()) {
+            mTextureDraw.reset();
+        } else {
+            ERR("Failed to bind context for destroying TextureDraw.");
+        }
     }
 
     if (mEglDisplay != EGL_NO_DISPLAY) {
diff --git a/host/gl/YUVConverter.cpp b/host/gl/YUVConverter.cpp
index cb5a2687c..3aa0cb7d8 100644
--- a/host/gl/YUVConverter.cpp
+++ b/host/gl/YUVConverter.cpp
@@ -432,9 +432,11 @@ static void getYUVOffsets(int width,
         }
         case FRAMEWORK_FORMAT_GL_COMPATIBLE: {
             FATAL("Input not a YUV format! (FRAMEWORK_FORMAT_GL_COMPATIBLE)");
+            break;
         }
         default: {
             FATAL("Unknown format: 0x%x", format);
+            break;
         }
     }
 }
diff --git a/host/gl/gl-host-common/Android.bp b/host/gl/gl-host-common/Android.bp
index b6976c5c5..3e34cddb0 100644
--- a/host/gl/gl-host-common/Android.bp
+++ b/host/gl/gl-host-common/Android.bp
@@ -38,7 +38,6 @@ cc_library_static {
         "opengl/EmuglBackendList.cpp",
         "opengl/emugl_config.cpp",
         "opengl/GLProcessPipe.cpp",
-        "opengl/GpuFrameBridge.cpp",
         "opengl/gpuinfo.cpp",
         "opengl/logger.cpp",
         "opengl/misc.cpp",
diff --git a/host/gl/gl-host-common/CMakeLists.txt b/host/gl/gl-host-common/CMakeLists.txt
index e7a33736b..a452abc12 100644
--- a/host/gl/gl-host-common/CMakeLists.txt
+++ b/host/gl/gl-host-common/CMakeLists.txt
@@ -43,8 +43,6 @@ if (NOT TARGET gfxstream-gl-host-common)
             opengl/emugl_config.cpp
             # opengl/emugl_config_unittest.cpp
             opengl/GLProcessPipe.cpp
-            opengl/GpuFrameBridge.cpp
-            # opengl/GpuFrameBridge_unittest.cpp
             opengl/gpuinfo.cpp
             # opengl/gpuinfo_unittest.cpp
             opengl/logger.cpp
diff --git a/host/gl/gl-host-common/include/host-common/opengl/GpuFrameBridge.h b/host/gl/gl-host-common/include/host-common/opengl/GpuFrameBridge.h
deleted file mode 100644
index 03bc1d513..000000000
--- a/host/gl/gl-host-common/include/host-common/opengl/GpuFrameBridge.h
+++ /dev/null
@@ -1,77 +0,0 @@
-// Copyright (C) 2015 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#pragma once
-
-#include <cstdint>
-
-class Looper;
-namespace android {
-
-namespace base {
-class Looper;
-}  // namespace base
-
-namespace opengl {
-
-// GpuFrameBridge is a helper class to forward Gpu frame to its clients.
-// Usage is the following:
-// 1) Create a new GpuFrameBridge instance.
-// 2) Register the FrameAvailableCallback if needed.
-// 3) Call getRecordFrame or getRecordFrameAsync to receive frame.
-class GpuFrameBridge {
-public:
-    // Create a new GpuFrameBridge instance.
-    static GpuFrameBridge* create();
-
-    // Destructor
-    virtual ~GpuFrameBridge() {}
-
-    // Post callback (synchronous) specifically for recording purposes.
-    virtual void postRecordFrame(int width, int height, const void* pixels) = 0;
-
-    // Async version of postRecordFrame for use with async readback.
-    // Does not read the frame immediately.
-    virtual void postRecordFrameAsync(int width,
-                                      int height,
-                                      const void* pixels) = 0;
-
-    // Returns the currently displayed frame. This method is designed only for
-    // recording. Returns null if there is no frame available. Make sure to
-    // attach the postFrameRecording() as the callback or you will not get a
-    // valid frame.
-    virtual void* getRecordFrame() = 0;
-
-    // Async version of getRecordFrame.
-    virtual void* getRecordFrameAsync() = 0;
-
-    // Invalidates the recording buffers. Once called, getRecordFrame() and it's
-    // async version will return null until new data has been posted.
-    virtual void invalidateRecordingBuffers() = 0;
-
-    typedef void (*FrameAvailableCallback)(void* opaque);
-
-    virtual void setFrameReceiver(FrameAvailableCallback receiver, void* opaque) = 0;
-
-    virtual void setDisplayId(uint32_t displayId) = 0;
-
-    // virtual void setLooper(android::base::Looper* aLooper) = 0;
-
-protected:
-    GpuFrameBridge() {}
-    GpuFrameBridge(const GpuFrameBridge& other);
-};
-
-}  // namespace opengl
-}  // namespace android
diff --git a/host/gl/gl-host-common/include/host-common/opengl/emugl_config.h b/host/gl/gl-host-common/include/host-common/opengl/emugl_config.h
index 5316a6fe9..e19a405ec 100644
--- a/host/gl/gl-host-common/include/host-common/opengl/emugl_config.h
+++ b/host/gl/gl-host-common/include/host-common/opengl/emugl_config.h
@@ -112,8 +112,13 @@ SelectedRenderer emuglConfig_get_current_renderer();
 // the hw.gpu.mode hardware property.
 const char* emuglConfig_get_user_gpu_option();
 
+// Returns the full path for vulkan runtime library to be used
+const char* emuglConfig_get_vulkan_runtime_full_path();
+
+// Returns the properties of the hardware gpu to be used for emulation
 void emuglConfig_get_vulkan_hardware_gpu(char** vendor, int* major, int* minor, int* patch,
-                                         uint64_t* deviceMemBytes, uint32_t* driverVersion);
+                                         uint64_t* deviceMemBytes, uint32_t* driverVersion,
+                                         uint64_t* deviceMaxAllocationCount);
 
 // Returns a string representation of the renderer enum. Return value is a
 // static constant string, it is NOT heap-allocated.
diff --git a/host/gl/gl-host-common/meson.build b/host/gl/gl-host-common/meson.build
index c10f91298..d10283112 100644
--- a/host/gl/gl-host-common/meson.build
+++ b/host/gl/gl-host-common/meson.build
@@ -6,7 +6,6 @@ files_lib_gl_host_common = files(
   'opengl/EmuglBackendList.cpp',
   'opengl/emugl_config.cpp',
   'opengl/GLProcessPipe.cpp',
-  'opengl/GpuFrameBridge.cpp',
   'opengl/gpuinfo.cpp',
   'opengl/logger.cpp',
   'opengl/misc.cpp',
diff --git a/host/gl/gl-host-common/opengl/GpuFrameBridge.cpp b/host/gl/gl-host-common/opengl/GpuFrameBridge.cpp
deleted file mode 100644
index 717025df0..000000000
--- a/host/gl/gl-host-common/opengl/GpuFrameBridge.cpp
+++ /dev/null
@@ -1,242 +0,0 @@
-// Copyright (C) 2015 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "host-common/opengl/GpuFrameBridge.h"
-
-#include <stdio.h>   // for printf
-#include <stdlib.h>  // for NULL, free, malloc
-#include <string.h>  // for memcpy
-
-#include <atomic>  // for atomic_bool, memory_o...
-#include <memory>  // for unique_ptr
-
-#include "aemu/base/synchronization/Lock.h"  // for Lock, AutoLock
-#include "aemu/base/synchronization/MessageChannel.h"
-#include "host-common/opengles.h"  // for android_getFlushReadP...
-
-#ifdef _WIN32
-#undef ERROR
-#endif
-
-namespace android {
-namespace opengl {
-
-using android::base::AutoLock;
-using android::base::Lock;
-using android::base::MessageChannel;
-
-namespace {
-
-// A small structure to model a single frame of the GPU display,
-// as passed between the EmuGL and main loop thread.
-struct Frame {
-    int width;
-    int height;
-    void* pixels;
-    bool isValid;
-
-    Frame(int w, int h, const void* pixels)
-        : width(w), height(h), pixels(NULL), isValid(true) {
-        this->pixels = ::malloc(w * 4 * h);
-    }
-
-    ~Frame() { ::free(pixels); }
-};
-
-// Real implementation of GpuFrameBridge interface.
-class Bridge : public GpuFrameBridge {
-public:
-    // Constructor.
-    Bridge()
-        : GpuFrameBridge(),
-          mRecFrame(NULL),
-          mRecTmpFrame(NULL),
-          mRecFrameUpdated(false),
-          mReadPixelsFunc(android_getReadPixelsFunc()),
-          mFlushPixelPipeline(android_getFlushReadPixelPipeline()) {}
-
-    // The gpu bridge receives frames from a buffer that can contain multiple
-    // frames. usually the bridge is one frame behind. This is usually not a
-    // problem when we have a high enough framerate. However it is possible that
-    // the framerate drops really low (even <1). This can result in the bridge
-    // never delivering this "stuck frame".
-    //
-    // As a work around we will flush the reader pipeline if no frames are
-    // delivered within at most 2x kFrameDelayms
-    const long kMinFPS = 24;
-    const long kFrameDelayMs = 1000 / kMinFPS;
-
-    // Destructor
-    virtual ~Bridge() {
-        if (mRecFrame) {
-            delete mRecFrame;
-        }
-        if (mRecTmpFrame) {
-            delete mRecTmpFrame;
-        }
-    }
-
-    // virtual void setLooper(android::base::Looper* aLooper) override {
-    //     mTimer = std::unique_ptr<android::base::Looper::Timer>(
-    //             aLooper->createTimer(_on_frame_notify, this));
-    // }
-
-    void notify() {
-        AutoLock delay(mDelayLock);
-        switch (mDelayCallback) {
-            case FrameDelay::Reschedule:
-                // mTimer->startRelative(kFrameDelayMs);
-                mDelayCallback = FrameDelay::Scheduled;
-                break;
-            case FrameDelay::Scheduled:
-                // mTimer->stop();
-                mDelayCallback = FrameDelay::Firing;
-                delay.unlock();
-                mFlushPixelPipeline(mDisplayId);
-                break;
-            default:
-                assert(false);
-        }
-    }
-
-    // static void _on_frame_notify(void* opaque,
-    //                              android::base::Looper::Timer* timer) {
-    //     Bridge* worker = static_cast<Bridge*>(opaque);
-    //     worker->notify();
-    // }
-
-    // Implementation of the GpuFrameBridge::postRecordFrame() method, must be
-    // called from the EmuGL thread.
-    virtual void postRecordFrame(int width,
-                                 int height,
-                                 const void* pixels) override {
-        postFrame(width, height, pixels, true);
-    }
-
-    virtual void postRecordFrameAsync(int width,
-                                      int height,
-                                      const void* pixels) override {
-        postFrame(width, height, pixels, false);
-    }
-
-    virtual void* getRecordFrame() override {
-        if (mRecFrameUpdated.exchange(false)) {
-            AutoLock lock(mRecLock);
-            memcpy(mRecFrame->pixels, mRecTmpFrame->pixels,
-                   mRecFrame->width * mRecFrame->height * 4);
-            mRecFrame->isValid = true;
-        }
-        return mRecFrame && mRecFrame->isValid ? mRecFrame->pixels : nullptr;
-    }
-
-    virtual void* getRecordFrameAsync() override {
-        if (mRecFrameUpdated.exchange(false)) {
-            AutoLock lock(mRecLock);
-            mReadPixelsFunc(mRecFrame->pixels,
-                            mRecFrame->width * mRecFrame->height * 4,
-                            mDisplayId);
-            mRecFrame->isValid = true;
-        }
-        return mRecFrame && mRecFrame->isValid ? mRecFrame->pixels : nullptr;
-    }
-
-    virtual void invalidateRecordingBuffers() override {
-        {
-            AutoLock lock(mRecLock);
-            // Release the buffers because new recording in the furture may have
-            // different resolution if multi display changes its resolution.
-            if (mRecFrame) {
-                delete mRecFrame;
-                mRecFrame = nullptr;
-            }
-            if (mRecTmpFrame) {
-                delete mRecTmpFrame;
-                mRecTmpFrame = nullptr;
-            }
-        }
-        mRecFrameUpdated.store(false, std::memory_order_release);
-    }
-
-    void setFrameReceiver(FrameAvailableCallback receiver,
-                          void* opaque) override {
-        mReceiver = receiver;
-        mReceiverOpaque = opaque;
-    }
-
-    void postFrame(int width, int height, const void* pixels, bool copy) {
-        {
-            AutoLock lock(mRecLock);
-            if (!mRecFrame) {
-                mRecFrame = new Frame(width, height, pixels);
-            }
-            if (!mRecTmpFrame) {
-                mRecTmpFrame = new Frame(width, height, pixels);
-            }
-            if (copy) {
-                memcpy(mRecTmpFrame->pixels, pixels, width * height * 4);
-            }
-        }
-        mRecFrameUpdated.store(true, std::memory_order_release);
-        if (mReceiver) {
-            mReceiver(mReceiverOpaque);
-            AutoLock delay(mDelayLock);
-            switch (mDelayCallback) {
-                case FrameDelay::NotScheduled:
-                    // mTimer->startRelative(kFrameDelayMs);
-                    mDelayCallback = FrameDelay::Scheduled;
-                    break;
-                case FrameDelay::Firing:
-                    mDelayCallback = FrameDelay::NotScheduled;
-                    break;
-                default:
-                    mDelayCallback = FrameDelay::Reschedule;
-                    break;
-            }
-        }
-    }
-
-    virtual void setDisplayId(uint32_t displayId) override {
-        mDisplayId = displayId;
-    }
-    enum class FrameDelay {
-        NotScheduled = 0,  // No delay timer is scheduled
-        Scheduled,   // A delay timer has been scheduled and will flush the
-                     // pipeline on expiration
-        Reschedule,  // Do not flush the pipeline, but reschedule
-        Firing,      // A callback has been scheduled, nothing needs to happen
-    };
-
-private:
-    FrameAvailableCallback mReceiver = nullptr;
-    void* mReceiverOpaque = nullptr;
-    Lock mRecLock;
-    Frame* mRecFrame;
-    Frame* mRecTmpFrame;
-    std::atomic_bool mRecFrameUpdated;
-    ReadPixelsFunc mReadPixelsFunc = 0;
-    uint32_t mDisplayId = 0;
-    FlushReadPixelPipeline mFlushPixelPipeline = 0;
-
-    // std::unique_ptr<android::base::Looper::Timer> mTimer;
-    Lock mDelayLock;
-    FrameDelay mDelayCallback{FrameDelay::NotScheduled};
-};
-}  // namespace
-// static
-GpuFrameBridge* GpuFrameBridge::create() {
-    return new Bridge();
-}
-
-}  // namespace opengl
-}  // namespace android
diff --git a/host/gl/gl-host-common/opengl/GpuFrameBridge_unittest.cpp b/host/gl/gl-host-common/opengl/GpuFrameBridge_unittest.cpp
deleted file mode 100644
index 03c62dd70..000000000
--- a/host/gl/gl-host-common/opengl/GpuFrameBridge_unittest.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright (C) 2015 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "android/opengl/GpuFrameBridge.h"
-
-#include "android/base/async/Looper.h"
-#include "android/base/Log.h"
-#include "android/base/memory/ScopedPtr.h"
-
-#include <gtest/gtest.h>
-
-#include <errno.h>
-#include <stdlib.h>
-#include <string.h>
-
-namespace android {
-namespace opengl {
-
-using android::base::ScopedPtr;
-using android::base::Looper;
-
-TEST(GpuFrameBridge, postFrameWithinSingleThread) {
-    GpuFrameBridge* bridge =
-            GpuFrameBridge::create();
-    EXPECT_TRUE(bridge);
-
-    static const unsigned char kFrame0[4] = {
-        0xff, 0x80, 0x40, 0xff,
-    };
-
-    bridge->postRecordFrame(1, 1, kFrame0);
-    unsigned char* pixel = (unsigned char*)bridge->getRecordFrame();
-    for (size_t n = 0; n < sizeof(kFrame0); ++n) {
-        EXPECT_EQ(kFrame0[n], pixel[n]) << "# " << n;
-    }
-}
-
-}  // namespace opengl
-}  // namespace android
diff --git a/host/gl/gl-host-common/opengl/NativeGpuInfo_windows.cpp b/host/gl/gl-host-common/opengl/NativeGpuInfo_windows.cpp
index 17d019ed0..f187cb3c5 100644
--- a/host/gl/gl-host-common/opengl/NativeGpuInfo_windows.cpp
+++ b/host/gl/gl-host-common/opengl/NativeGpuInfo_windows.cpp
@@ -13,6 +13,7 @@
 // limitations under the License.
 
 #include "host-common/opengl/NativeGpuInfo.h"
+#include "host-common/opengl/emugl_config.h"
 
 #include "aemu/base/StringFormat.h"
 #include "aemu/base/containers/SmallVector.h"
@@ -380,7 +381,8 @@ bool badVulkanDllVersion() {
     // crashhandler_append_message_format(
     //     "checking for bad vulkan-1.dll version...\n");
 
-    if (!android::base::queryFileVersionInfo("vulkan-1.dll", &major, &minor, &build_1, &build_2)) {
+    const char* vulkanDllPath = emuglConfig_get_vulkan_runtime_full_path();
+    if (!android::base::queryFileVersionInfo(vulkanDllPath, &major, &minor, &build_1, &build_2)) {
         // crashhandler_append_message_format(
         //     "info on vulkan-1.dll cannot be found, continue.\n");
         // Information about vulkan-1.dll not available; not blacklisted
diff --git a/host/gl/gl-host-common/opengl/emugl_config.cpp b/host/gl/gl-host-common/opengl/emugl_config.cpp
index d8f3f1601..e650f9c63 100644
--- a/host/gl/gl-host-common/opengl/emugl_config.cpp
+++ b/host/gl/gl-host-common/opengl/emugl_config.cpp
@@ -235,7 +235,11 @@ bool emuglConfig_init(EmuglConfig* config,
             has_auto_no_window = true;
         } else {
             gpu_enabled = true;
-            gpu_mode = gpu_option;
+            if (!strcmp(gpu_option, "lavapipe")) {
+                gpu_mode = "swiftshader_indirect";
+            } else {
+                gpu_mode = gpu_option;
+            }
         }
     } else {
         // Support "hw.gpu.mode=on" in config.ini
@@ -399,6 +403,10 @@ void emuglConfig_setupEnv(const EmuglConfig* config) {
         android::base::setEnvironmentVariable("ANDROID_EMU_VK_ICD", "swiftshader");
     }
 
+    if (0 == strcmp(emuglConfig_get_user_gpu_option(), "lavapipe")) {
+        android::base::setEnvironmentVariable("ANDROID_EMU_VK_ICD", "lavapipe");
+    }
+
     if (!config->enabled) {
         // There is no real GPU emulation. As a special case, define
         // SDL_RENDER_DRIVER to 'software' to ensure that the
diff --git a/host/gl/gl-host-common/opengles.cpp b/host/gl/gl-host-common/opengles.cpp
index b83e95974..8da666886 100644
--- a/host/gl/gl-host-common/opengles.cpp
+++ b/host/gl/gl-host-common/opengles.cpp
@@ -14,72 +14,30 @@
 
 #include "host-common/opengles.h"
 
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <optional>
+
 #include "aemu/base/GLObjectCounter.h"
-#include "aemu/base/files/PathUtils.h"
-#include "aemu/base/files/Stream.h"
-#include "aemu/base/memory/MemoryTracker.h"
 #include "aemu/base/SharedLibrary.h"
-#include "aemu/base/system/System.h"
 #include "host-common/address_space_device.h"
 #include "host-common/address_space_graphics.h"
 #include "host-common/address_space_graphics_types.h"
 #include "host-common/GfxstreamFatalError.h"
-#include "host-common/GoldfishDma.h"
 #include "host-common/logging.h"
-#include "host-common/RefcountPipe.h"
-#include "host-common/FeatureControl.h"
-#include "host-common/globals.h"
-#include "host-common/opengl/emugl_config.h"
 #include "host-common/opengl/GLProcessPipe.h"
+#include "host-common/opengl/emugl_config.h"
 #include "host-common/opengl/logger.h"
 #include "host-common/opengl/gpuinfo.h"
 
-#include "render-utils/render_api_functions.h"
-#include "OpenGLESDispatch/EGLDispatch.h"
-#include "OpenGLESDispatch/GLESv2Dispatch.h"
-
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <optional>
-
-#define D(...)
-#define DD(...)
-
-#define I(fmt, ...)                                     \
-    do {                                                \
-        GFXSTREAM_LOG(stderr, 'I', fmt, ##__VA_ARGS__); \
-    } while (0);
-
-#define E(fmt, ...)                                     \
-    do {                                                \
-        GFXSTREAM_LOG(stderr, 'E', fmt, ##__VA_ARGS__); \
-    } while (0);
-
-
-using android::base::pj;
 using android::base::SharedLibrary;
 using android::emulation::asg::AddressSpaceGraphicsContext;
 using android::emulation::asg::ConsumerCallbacks;
 using android::emulation::asg::ConsumerInterface;
 using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
-using gfxstream::gl::EGLDispatch;
-using gfxstream::gl::GLESv2Dispatch;
-
-/* Name of the GLES rendering library we're going to use */
-#define RENDERER_LIB_NAME "libOpenglRender"
-
-/* Declared in "android/globals.h" */
-int  android_gles_fast_pipes = 1;
-
-// Define the Render API function pointers.
-#define FUNCTION_(ret, name, sig, params) \
-        inline ret (*name) sig = NULL;
-LIST_RENDER_API_FUNCTIONS(FUNCTION_)
-#undef FUNCTION_
 
 static bool sOpenglLoggerInitialized = false;
 static bool sRendererUsesSubWindow = false;
@@ -136,7 +94,6 @@ android_startOpenglesRenderer(int width, int height,
                               int* glesMinorVersion_out)
 {
     if (!sRenderLib) {
-        D("Can't start OpenGLES renderer without support libraries");
         return -1;
     }
 
@@ -146,13 +103,11 @@ android_startOpenglesRenderer(int width, int height,
 
     const GpuInfoList& gpuList = globalGpuInfoList();
     std::string gpuInfoAsString = gpuList.dump();
-    I("%s: gpu info", __func__);
-    I("%s", gpuInfoAsString.c_str());
+    INFO("%s: gpu info", __func__);
+    INFO("%s", gpuInfoAsString.c_str());
 
     sRenderLib->setRenderer(emuglConfig_get_current_renderer());
     sRenderLib->setAvdInfo(guestPhoneApi, guestApiLevel);
-    // sRenderLib->setCrashReporter(&crashhandler_die_format);
-    // sRenderLib->setFeatureController(&android::featurecontrol::isEnabled);
     sRenderLib->setSyncDevice(goldfish_sync_create_timeline,
             goldfish_sync_create_fence,
             goldfish_sync_timeline_inc,
@@ -169,19 +124,11 @@ android_startOpenglesRenderer(int width, int height,
     sRenderLib->setVmOps(*vm_operations);
     sRenderLib->setAddressSpaceDeviceControlOps(get_address_space_device_control_ops());
     sRenderLib->setWindowOps(*window_agent, *multi_display_agent);
-    // sRenderLib->setUsageTracker(android::base::CpuUsage::get(),
-    //                             android::base::MemoryTracker::get());
 
     const auto* features = reinterpret_cast<const gfxstream::host::FeatureSet*>(gfxstreamFeatures);
     sRenderer = sRenderLib->initRenderer(width, height, *features, sRendererUsesSubWindow, sEgl2egl);
     android_setOpenglesRenderer(&sRenderer);
 
-    // android::snapshot::Snapshotter::get().addOperationCallback(
-    //         [](android::snapshot::Snapshotter::Operation op,
-    //            android::snapshot::Snapshotter::Stage stage) {
-    //             sRenderer->snapshotOperationCallback(op, stage);
-    //         });
-
     android::emulation::registerOnLastRefCallback(
             sRenderLib->getOnLastColorBufferRef());
 
@@ -237,7 +184,7 @@ android_startOpenglesRenderer(int width, int height,
     AddressSpaceGraphicsContext::setConsumer(iface);
 
     if (!sRenderer) {
-        D("Can't start OpenGLES renderer?");
+        ERR("Can't start OpenGLES renderer?");
         return -1;
     }
 
@@ -253,8 +200,8 @@ android_asyncReadbackSupported() {
     if (sRenderer) {
         return sRenderer->asyncReadbackSupported();
     } else {
-        D("tried to query async readback support "
-          "before renderer initialized. Likely guest rendering");
+        VERBOSE("tried to query async readback support "
+                "before renderer initialized. Likely guest rendering");
         return false;
     }
 }
@@ -317,14 +264,14 @@ void android_getOpenglesHardwareStrings(char** vendor,
     assert(vendor != NULL && renderer != NULL && version != NULL);
     assert(*vendor == NULL && *renderer == NULL && *version == NULL);
     if (!sRenderer) {
-        D("Can't get OpenGL ES hardware strings when renderer not started");
+        ERR("Can't get OpenGL ES hardware strings when renderer not started");
         return;
     }
 
     const gfxstream::Renderer::HardwareStrings strings = sRenderer->getHardwareStrings();
-    D("OpenGL Vendor=[%s]", strings.vendor.c_str());
-    D("OpenGL Renderer=[%s]", strings.renderer.c_str());
-    D("OpenGL Version=[%s]", strings.version.c_str());
+    INFO("OpenGL Vendor=[%s]", strings.vendor.c_str());
+    INFO("OpenGL Renderer=[%s]", strings.renderer.c_str());
+    INFO("OpenGL Version=[%s]", strings.version.c_str());
 
     /* Special case for the default ES to GL translators: extract the strings
      * of the underlying OpenGL implementation. */
@@ -342,7 +289,7 @@ void android_getOpenglesHardwareStrings(char** vendor,
 
 void android_getOpenglesVersion(int* maj, int* min) {
     sRenderLib->getGlesVersion(maj, min);
-    fprintf(stderr, "%s: maj min %d %d\n", __func__, *maj, *min);
+    INFO("OpenGL ES version major:%d minor:%d", *maj, *min);
 }
 
 void
diff --git a/host/gl/gles1_dec/meson.build b/host/gl/gles1_dec/meson.build
index e151213cf..aa333661f 100644
--- a/host/gl/gles1_dec/meson.build
+++ b/host/gl/gles1_dec/meson.build
@@ -11,6 +11,6 @@ lib_gles1_dec = static_library(
   'gles1_dec',
   files_lib_gles1_dec,
   cpp_args: gfxstream_host_args,
-  include_directories: [inc_gfxstream_include, inc_include, inc_apigen_codec, inc_gles_translator],
+  include_directories: [inc_gfxstream_include, inc_include, inc_apigen_codec],
   dependencies: [aemu_base_dep, aemu_logging_dep]
 )
diff --git a/host/gl/gles2_dec/meson.build b/host/gl/gles2_dec/meson.build
index 91f0e169b..fe75aad2a 100644
--- a/host/gl/gles2_dec/meson.build
+++ b/host/gl/gles2_dec/meson.build
@@ -11,7 +11,7 @@ lib_gles2_dec = static_library(
   'gles2_dec',
   files_lib_gles2_dec,
   cpp_args: gfxstream_host_args,
-  include_directories: [inc_gfxstream_include, inc_include, inc_apigen_codec, inc_gles_translator,
+  include_directories: [inc_gfxstream_include, inc_include, inc_apigen_codec,
                         inc_gl_snapshot],
   link_with: lib_gl_snapshot,
   dependencies: [aemu_base_dep, aemu_logging_dep]
diff --git a/host/gl/glestranslator/EGL/EglImp.cpp b/host/gl/glestranslator/EGL/EglImp.cpp
index c0b97acc0..6702e0882 100644
--- a/host/gl/glestranslator/EGL/EglImp.cpp
+++ b/host/gl/glestranslator/EGL/EglImp.cpp
@@ -43,6 +43,7 @@
 #include "EglContext.h"
 #include "EglConfig.h"
 #include "EglOsApi.h"
+#include "GraphicsDriverLock.h"
 #include "ClientAPIExts.h"
 
 #include <EGL/egl.h>
@@ -57,6 +58,7 @@
 
 using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
+using gfxstream::graphicsDriverLock;
 
 //declarations
 
@@ -81,12 +83,11 @@ static bool unbindAuxiliaryContext();
 #define tls_thread  EglThreadInfo::get()
 
 EglGlobalInfo* g_eglInfo = NULL;
-android::base::Lock  s_eglLock;
 android::base::Lock  s_surfaceDestroyLock;
 
 void initGlobalInfo()
 {
-    android::base::AutoLock mutex(s_eglLock);
+    android::base::AutoLock mutex(*graphicsDriverLock());
     if (!g_eglInfo) {
         g_eglInfo = EglGlobalInfo::getInstance();
     }
@@ -794,7 +795,7 @@ EGLAPI EGLSurface EGLAPIENTRY eglCreateWindowSurface(EGLDisplay display, EGLConf
         RETURN_ERROR(EGL_NO_SURFACE,EGL_BAD_ALLOC);
     }
 
-    android::base::AutoLock mutex(s_eglLock);
+    android::base::AutoLock mutex(*graphicsDriverLock());
     unsigned int width,height;
     if(!dpy->nativeType()->checkWindowPixelFormatMatch(
             win, cfg->nativeFormat(), &width, &height)) {
@@ -857,7 +858,7 @@ EGLAPI EGLSurface EGLAPIENTRY eglCreatePbufferSurface(
 
     tmpPbSurfacePtr->getAttrib(EGL_MIPMAP_TEXTURE, &pbinfo.hasMipmap);
 
-    android::base::AutoLock mutex(s_eglLock);
+    android::base::AutoLock mutex(*graphicsDriverLock());
     EglOS::Surface* pb = dpy->nativeType()->createPbufferSurface(
             cfg->nativeFormat(), &pbinfo);
     if(!pb) {
@@ -871,7 +872,7 @@ EGLAPI EGLSurface EGLAPIENTRY eglCreatePbufferSurface(
 
 EGLAPI EGLBoolean EGLAPIENTRY eglDestroySurface(EGLDisplay display, EGLSurface surface) {
     VALIDATE_DISPLAY(display);
-    android::base::AutoLock mutex(s_eglLock);
+    android::base::AutoLock mutex(*graphicsDriverLock());
     SurfacePtr srfc = dpy->getSurface(surface);
     if(!srfc.get()) {
         RETURN_ERROR(EGL_FALSE,EGL_BAD_SURFACE);
@@ -1022,7 +1023,7 @@ static EGLContext eglCreateOrLoadContext(EGLDisplay display, EGLConfig config,
         assert(shareGroupId);
     }
 
-    android::base::AutoLock mutex(s_eglLock);
+    android::base::AutoLock mutex(*graphicsDriverLock());
 
     ContextPtr ctx(new EglContext(dpy, shareGroupId, cfg,
                                   glesCtx, glesVersion,
@@ -1053,7 +1054,7 @@ EGLAPI EGLBoolean EGLAPIENTRY eglDestroyContext(EGLDisplay display, EGLContext c
     VALIDATE_DISPLAY(display);
     VALIDATE_CONTEXT(context);
 
-    android::base::AutoLock mutex(s_eglLock);
+    android::base::AutoLock mutex(*graphicsDriverLock());
     dpy->removeContext(context);
     return EGL_TRUE;
 }
@@ -1120,6 +1121,7 @@ EGLAPI EGLBoolean EGLAPIENTRY eglMakeCurrent(EGLDisplay display,
     if(releaseContext) { //releasing current context
        if(prevCtx.get()) {
            g_eglInfo->getIface(prevCtx->version())->flush();
+           android::base::AutoLock mutex(*graphicsDriverLock());
            if(!dpy->nativeType()->makeCurrent(NULL,NULL,NULL)) {
                RETURN_ERROR(EGL_FALSE,EGL_BAD_ACCESS);
            }
@@ -1172,7 +1174,7 @@ EGLAPI EGLBoolean EGLAPIENTRY eglMakeCurrent(EGLDisplay display,
         }
 
         {
-            android::base::AutoLock mutex(s_eglLock);
+            android::base::AutoLock mutex(*graphicsDriverLock());
             if (!dpy->nativeType()->makeCurrent(
                         newReadPtr->native(),
                         newDrawPtr->native(),
@@ -1268,13 +1270,16 @@ EGLAPI EGLBoolean EGLAPIENTRY eglSwapBuffers(EGLDisplay display, EGLSurface surf
         RETURN_ERROR(EGL_FALSE,EGL_BAD_SURFACE);
     }
 
-    dpy->nativeType()->swapBuffers(Srfc->native());
+    {
+        android::base::AutoLock mutex(*graphicsDriverLock());
+        dpy->nativeType()->swapBuffers(Srfc->native());
+    }
     return EGL_TRUE;
 }
 
 EGLAPI EGLContext EGLAPIENTRY eglGetCurrentContext(void) {
     MEM_TRACE("EMUGL");
-    android::base::AutoLock mutex(s_eglLock);
+    android::base::AutoLock mutex(*graphicsDriverLock());
     ThreadInfo* thread = getThreadInfo();
     EglDisplay* dpy    = static_cast<EglDisplay*>(thread->eglDisplay);
     ContextPtr  ctx    = thread->eglContext;
@@ -1292,7 +1297,7 @@ EGLAPI EGLContext EGLAPIENTRY eglGetCurrentContext(void) {
 
 EGLAPI EGLSurface EGLAPIENTRY eglGetCurrentSurface(EGLint readdraw) {
     MEM_TRACE("EMUGL");
-    android::base::AutoLock mutex(s_eglLock);
+    android::base::AutoLock mutex(*graphicsDriverLock());
     if (!EglValidate::surfaceTarget(readdraw)) {
         return EGL_NO_SURFACE;
     }
@@ -1507,7 +1512,7 @@ EGLAPI EGLSyncKHR EGLAPIENTRY eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, con
 
 EGLAPI EGLint EGLAPIENTRY eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout) {
     MEM_TRACE("EMUGL");
-    android::base::AutoLock mutex(s_eglLock);
+    android::base::AutoLock mutex(*graphicsDriverLock());
     if (!g_eglInfo->isEgl2EglSyncSafeToUse()) {
         return EGL_CONDITION_SATISFIED_KHR;
     }
diff --git a/host/gl/glestranslator/EGL/EglOsApi_egl.cpp b/host/gl/glestranslator/EGL/EglOsApi_egl.cpp
index 40c9d7841..2fca845a6 100644
--- a/host/gl/glestranslator/EGL/EglOsApi_egl.cpp
+++ b/host/gl/glestranslator/EGL/EglOsApi_egl.cpp
@@ -512,9 +512,6 @@ void EglOsEglDisplay::queryConfigs(int renderableType,
                                    AddConfigCallback* addConfigFunc,
                                    void* addConfigOpaque) {
     D("%s\n", __FUNCTION__);
-    // ANGLE does not support GLES1 uses core profile engine.
-    // Querying underlying EGL with a conservative set of bits.
-    renderableType &= ~EGL_OPENGL_ES_BIT;
 
     const EGLint framebuffer_config_attributes[] = {
         EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
@@ -848,10 +845,10 @@ class EglEngine : public EglOS::Engine {
 public:
  EglEngine(bool nullEgl)
      :
+       EglOS::Engine(),
 #ifdef __QNX__  // Ensure libEGL is loaded prior to libGLES
        mDisplay(sHostDisplay(nullEgl)),
 #endif
-       EglOS::Engine(),
        mUseNullEgl(nullEgl) {
  }
 
diff --git a/host/gl/glestranslator/EGL/meson.build b/host/gl/glestranslator/EGL/meson.build
index 0758656b2..513aa3b5b 100644
--- a/host/gl/glestranslator/EGL/meson.build
+++ b/host/gl/glestranslator/EGL/meson.build
@@ -52,7 +52,7 @@ lib_egl_translator = static_library(
   'egl_translator',
   files_lib_egl_translator,
   cpp_args: egl_cpp_args + gfxstream_host_args,
-  include_directories: [inc_gfxstream_include, inc_include, inc_gles_translator, inc_apigen_codec,
+  include_directories: [inc_gfxstream_include, inc_include, inc_gl_common, inc_apigen_codec,
                         inc_gl_host_common, inc_stream_servers, inc_etc],
   link_with: [lib_gl_common, lib_apigen_codec, lib_gl_host_common],
   dependencies: [aemu_base_dep, aemu_common_dep, aemu_snapshot_dep,
diff --git a/host/gl/glestranslator/GLES_CM/BUILD.bazel b/host/gl/glestranslator/GLES_CM/BUILD.bazel
index 500df4018..6ffc87573 100644
--- a/host/gl/glestranslator/GLES_CM/BUILD.bazel
+++ b/host/gl/glestranslator/GLES_CM/BUILD.bazel
@@ -1,3 +1,5 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
+
 cc_library(
     name = "GLES_CM_translator_static",
     srcs = [
@@ -12,11 +14,10 @@ cc_library(
     ],
     visibility = ["//visibility:public"],
     deps = [
-        "//external/angle:angle-headers",
-        "//hardware/google/aemu/snapshot:aemu-snapshot",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
-        "//hardware/google/gfxstream/host/gl:gl_common",
-        "//hardware/google/gfxstream/third-party/glm",
+        "//:gfxstream-gl-host-common-headers",
+        "//host/apigen-codec-common",
+        "//host/gl:gl_common",
+        "//third-party/glm",
+        "@aemu//snapshot:aemu-snapshot",
     ],
 )
diff --git a/host/gl/glestranslator/GLES_CM/GLEScmContext.cpp b/host/gl/glestranslator/GLES_CM/GLEScmContext.cpp
index d21997d8d..0eb295b5a 100644
--- a/host/gl/glestranslator/GLES_CM/GLEScmContext.cpp
+++ b/host/gl/glestranslator/GLES_CM/GLEScmContext.cpp
@@ -588,11 +588,13 @@ void GLEScmContext::getColor(uint32_t count, std::vector<float>& out) const {
                     mColor.val.ubyteVal[1] / 255.0f,
                     mColor.val.ubyteVal[2] / 255.0f,
                     mColor.val.ubyteVal[3] / 255.0f, };
+            break;
         default:
             vec = { mColor.val.floatVal[0],
                     mColor.val.floatVal[1],
                     mColor.val.floatVal[2],
                     mColor.val.floatVal[3], };
+            break;
     }
 
     appendRepeatedVector(count, vec, out);
@@ -620,7 +622,7 @@ void GLEScmContext::appendRepeatedVector(uint32_t count, std::vector<float>& in,
     size_t previousOutSize = out.size();
     out.resize(previousOutSize + (count * in.size()));
     auto it = out.begin() + previousOutSize;
-    for (int i = 0; i < count; i++) {
+    for (uint32_t i = 0; i < count; i++) {
         std::copy(in.begin(), in.end(), it);
         it += in.size();
     }
diff --git a/host/gl/glestranslator/GLES_CM/GLEScmImp.cpp b/host/gl/glestranslator/GLES_CM/GLEScmImp.cpp
index 4342efb49..5d2ef0048 100644
--- a/host/gl/glestranslator/GLES_CM/GLEScmImp.cpp
+++ b/host/gl/glestranslator/GLES_CM/GLEScmImp.cpp
@@ -1213,10 +1213,12 @@ GL_API void GL_APIENTRY  glGetFloatv( GLenum pname, GLfloat *params) {
     case GL_COMPRESSED_TEXTURE_FORMATS:
         {
             int nparams = getCompressedFormats(1, NULL);
-            if (nparams>0) {
-                int * iparams = new int[nparams];
+            if (nparams > 0) {
+                int* iparams = new int[nparams];
                 getCompressedFormats(1, iparams);
-                for (int i=0; i<nparams; i++) params[i] = (GLfloat)iparams[i];
+                for (int paramIndex = 0; paramIndex < nparams; paramIndex++) {
+                    params[paramIndex] = (GLfloat)iparams[paramIndex];
+                }
                 delete [] iparams;
             }
         }
@@ -1341,8 +1343,10 @@ GL_API void GL_APIENTRY  glGetLightxv( GLenum light, GLenum pname, GLfixed *para
         case GL_SPECULAR:
         case GL_POSITION:
             params[3] = F2X(tmpParams[3]);
+            [[fallthrough]];
         case GL_SPOT_DIRECTION:
             params[2] = F2X(tmpParams[2]);
+            [[fallthrough]];
         case GL_SPOT_EXPONENT:
         case GL_SPOT_CUTOFF:
         case GL_CONSTANT_ATTENUATION:
@@ -1379,6 +1383,7 @@ GL_API void GL_APIENTRY  glGetMaterialxv( GLenum face, GLenum pname, GLfixed *pa
         params[3] = tmpParams[3];
         params[2] = tmpParams[2];
         params[1] = tmpParams[1];
+        [[fallthrough]];
     case GL_SHININESS:
         params[0] = tmpParams[0];
         break;
@@ -1556,9 +1561,11 @@ GL_API void GL_APIENTRY  glLightxv( GLenum light, GLenum pname, const GLfixed *p
         case GL_EMISSION:
         case GL_POSITION:
             tmpParams[3] = X2F(params[3]);
+            [[fallthrough]];
         case GL_SPOT_DIRECTION:
             tmpParams[2] = X2F(params[2]);
             tmpParams[1] = X2F(params[1]);
+            [[fallthrough]];
         case GL_SPOT_EXPONENT:
         case GL_SPOT_CUTOFF:
         case GL_CONSTANT_ATTENUATION:
@@ -2686,10 +2693,10 @@ GL_API void GLAPIENTRY glGetFramebufferAttachmentParameterivOES(GLenum target, G
     if (fbName) {
         auto fbObj = ctx->getFBOData(fbName);
         if (fbObj) {
-            GLenum target;
-            GLuint name = fbObj->getAttachment(attachment, &target, NULL);
+            GLenum attachmentTarget;
+            GLuint name = fbObj->getAttachment(attachment, &attachmentTarget, NULL);
             if (pname == GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES) {
-                *params = target;
+                *params = attachmentTarget;
                 return;
             }
             else if (pname == GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES) {
diff --git a/host/gl/glestranslator/GLES_CM/GLEScmUtils.cpp b/host/gl/glestranslator/GLES_CM/GLEScmUtils.cpp
index 891b4e366..ee9a4ef4c 100644
--- a/host/gl/glestranslator/GLES_CM/GLEScmUtils.cpp
+++ b/host/gl/glestranslator/GLES_CM/GLEScmUtils.cpp
@@ -94,6 +94,7 @@ size_t glParamSize(GLenum param)
     case GL_PROJECTION_MATRIX:
     case GL_TEXTURE_MATRIX:
         s = 16;
+        break;
     default:
         s = 1; // assume 1
     }
diff --git a/host/gl/glestranslator/GLES_CM/meson.build b/host/gl/glestranslator/GLES_CM/meson.build
index b8666b5b9..dccafd7f9 100644
--- a/host/gl/glestranslator/GLES_CM/meson.build
+++ b/host/gl/glestranslator/GLES_CM/meson.build
@@ -13,7 +13,7 @@ lib_glescm_translator = static_library(
   'glescm_translator',
   files_lib_glescm_translator,
   cpp_args: gfxstream_host_args,
-  include_directories: [inc_gfxstream_include, inc_include, inc_gles_translator, inc_glm,
+  include_directories: [inc_gfxstream_include, inc_include, inc_gl_common, inc_glm,
                         inc_etc],
   dependencies: [aemu_base_dep, aemu_logging_dep, aemu_snapshot_dep]
 )
diff --git a/host/gl/glestranslator/GLES_V2/BUILD.bazel b/host/gl/glestranslator/GLES_V2/BUILD.bazel
index bb38bbe88..839d9e338 100644
--- a/host/gl/glestranslator/GLES_V2/BUILD.bazel
+++ b/host/gl/glestranslator/GLES_V2/BUILD.bazel
@@ -1,3 +1,5 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
+
 cc_library(
     name = "GLES_V2_translator_static",
     srcs = [
@@ -27,9 +29,9 @@ cc_library(
     includes = ["."],
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
-        "//hardware/google/gfxstream/host/gl:gl_common",
+        "//:gfxstream-gl-host-common-headers",
+        "//host/apigen-codec-common",
+        "//host/gl:gl_common",
     ],
     alwayslink = True,
 )
diff --git a/host/gl/glestranslator/GLES_V2/GLESv2Imp.cpp b/host/gl/glestranslator/GLES_V2/GLESv2Imp.cpp
index 0dee561db..5e495c58b 100644
--- a/host/gl/glestranslator/GLES_V2/GLESv2Imp.cpp
+++ b/host/gl/glestranslator/GLES_V2/GLESv2Imp.cpp
@@ -1954,7 +1954,7 @@ GL_APICALL void  GL_APIENTRY glGetActiveAttrib(GLuint program, GLuint index, GLs
         GLint numActiveAttributes = 0;
         ctx->dispatcher().glGetProgramiv(
             globalProgramName, GL_ACTIVE_ATTRIBUTES, &numActiveAttributes);
-        SET_ERROR_IF(index >= numActiveAttributes, GL_INVALID_VALUE);
+        SET_ERROR_IF(index >= (GLuint)numActiveAttributes, GL_INVALID_VALUE);
         SET_ERROR_IF(bufsize < 0, GL_INVALID_VALUE);
 
         ProgramData* pData = (ProgramData*)objData;
@@ -1977,7 +1977,7 @@ GL_APICALL void  GL_APIENTRY glGetActiveUniform(GLuint program, GLuint index, GL
         GLint numActiveUniforms = 0;
         ctx->dispatcher().glGetProgramiv(globalProgramName, GL_ACTIVE_UNIFORMS,
                                          &numActiveUniforms);
-        SET_ERROR_IF(index >= numActiveUniforms, GL_INVALID_VALUE);
+        SET_ERROR_IF(index >= (GLuint)numActiveUniforms, GL_INVALID_VALUE);
         SET_ERROR_IF(bufsize < 0, GL_INVALID_VALUE);
 
         ProgramData* pData = (ProgramData*)objData;
@@ -2187,12 +2187,12 @@ static void s_glStateQueryTv(bool es2, GLenum pname, T* params, GLStateQueryFunc
         {
             int nparams = getCompressedFormats(2, NULL);
             if (nparams > 0) {
-                int* iparams = new int[nparams];
-                getCompressedFormats(2, iparams);
-                for (int i = 0; i < nparams; i++) {
-                    params[i] = (T)iparams[i];
+                int* compressedFormats = new int[nparams];
+                getCompressedFormats(2, compressedFormats);
+                for (int paramIndex = 0; paramIndex < nparams; paramIndex++) {
+                    params[paramIndex] = (T)compressedFormats[paramIndex];
                 }
-                delete [] iparams;
+                delete[] compressedFormats;
             }
         }
         break;
@@ -2503,6 +2503,7 @@ GL_APICALL void  GL_APIENTRY glGetIntegerv(GLenum pname, GLint* params){
     case GL_COLOR_CLEAR_VALUE:
     case GL_DEPTH_CLEAR_VALUE:
         ctx->dispatcher().glGetFloatv(pname, floatVals);
+        break;
     default:
         break;
     }
@@ -2548,18 +2549,17 @@ GL_APICALL void  GL_APIENTRY glGetFramebufferAttachmentParameteriv(GLenum target
     if (fbName) {
         auto fbObj = ctx->getFBOData(fbName);
         if (fbObj != NULL) {
-            GLenum target;
-            GLuint name = fbObj->getAttachment(attachment, &target, NULL);
+            GLenum attachmentTarget;
+            GLuint name = fbObj->getAttachment(attachment, &attachmentTarget, NULL);
             if (!name) {
                 SET_ERROR_IF(pname != GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE &&
                         pname != GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, GL_INVALID_ENUM);
             }
             if (pname == GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) {
-                if (target == GL_TEXTURE_2D) {
+                if (attachmentTarget == GL_TEXTURE_2D) {
                     *params = GL_TEXTURE;
                     return;
-                }
-                else if (target == GL_RENDERBUFFER) {
+                } else if (attachmentTarget == GL_RENDERBUFFER) {
                     *params = GL_RENDERBUFFER;
                     return;
                 } else {
@@ -3800,7 +3800,7 @@ GL_APICALL void  GL_APIENTRY glGetTexImage(GLenum target, GLint level, GLenum fo
             case GL_TEXTURE_3D: {
                 unsigned int layerImgSize = texImageSize(
                         format, type, packAlignment, width, height);
-                for (unsigned int d = 0; d < depth; d++) {
+                for (int d = 0; d < depth; d++) {
                     gl.glFramebufferTexture3DOES(
                             GL_READ_FRAMEBUFFER, attachment, target,
                             globalName, level, d);
@@ -3817,7 +3817,7 @@ GL_APICALL void  GL_APIENTRY glGetTexImage(GLenum target, GLint level, GLenum fo
             case GL_TEXTURE_2D_ARRAY: {
                 unsigned int layerImgSize = texImageSize(
                         format, type, packAlignment, width, height);
-                for (unsigned int d = 0; d < depth; d++) {
+                for (int d = 0; d < depth; d++) {
                     gl.glFramebufferTextureLayer(
                             GL_READ_FRAMEBUFFER, attachment,
                             globalName, level, d);
diff --git a/host/gl/glestranslator/GLES_V2/GLESv30Imp.cpp b/host/gl/glestranslator/GLES_V2/GLESv30Imp.cpp
index 60183b2cb..fdabf8626 100644
--- a/host/gl/glestranslator/GLES_V2/GLESv30Imp.cpp
+++ b/host/gl/glestranslator/GLES_V2/GLESv30Imp.cpp
@@ -485,7 +485,7 @@ static void internal_glDeleteSync(GLsync to_delete) {
 static void internal_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufsize, GLsizei *length, GLint *values) {
     GET_CTX_V2();
     if (!ctx->dispatcher().glGetSynciv) {
-        if (bufsize < sizeof(GLint)) return;
+        if ((long unsigned)bufsize < sizeof(GLint)) return;
         switch (pname) {
             case GL_OBJECT_TYPE:
                 if (length) *length = sizeof(GLint);
diff --git a/host/gl/glestranslator/GLES_V2/meson.build b/host/gl/glestranslator/GLES_V2/meson.build
index 28137abec..cff02f9be 100644
--- a/host/gl/glestranslator/GLES_V2/meson.build
+++ b/host/gl/glestranslator/GLES_V2/meson.build
@@ -17,7 +17,7 @@ lib_glesv2_translator = static_library(
   'glesv2_translator',
   files_lib_glesv2_translator,
   cpp_args: gfxstream_host_args,
-  include_directories: [inc_gfxstream_include, inc_include, inc_gles_translator, inc_stream_servers,
+  include_directories: [inc_gfxstream_include, inc_include, inc_gl_common, inc_stream_servers,
                         inc_etc],
   dependencies: [aemu_base_dep, aemu_logging_dep, aemu_snapshot_dep]
 )
diff --git a/host/gl/glestranslator/GLcommon/Android.bp b/host/gl/glestranslator/GLcommon/Android.bp
index 592931932..4c1cc99cc 100644
--- a/host/gl/glestranslator/GLcommon/Android.bp
+++ b/host/gl/glestranslator/GLcommon/Android.bp
@@ -47,4 +47,7 @@ cc_library_static {
         "TextureData.cpp",
         "TextureUtils.cpp",
     ],
+    export_include_dirs: [
+        "include",
+    ],
 }
diff --git a/host/gl/glestranslator/GLcommon/CMakeLists.txt b/host/gl/glestranslator/GLcommon/CMakeLists.txt
index 0b358f4fd..b77678eb6 100644
--- a/host/gl/glestranslator/GLcommon/CMakeLists.txt
+++ b/host/gl/glestranslator/GLcommon/CMakeLists.txt
@@ -25,7 +25,7 @@ target_include_directories(
     ${GFXSTREAM_REPO_ROOT}/include
     ${GFXSTREAM_REPO_ROOT}/host
     ${GFXSTREAM_REPO_ROOT}/host/apigen-codec-common
-    ${GFXSTREAM_REPO_ROOT}/host/gl/glestranslator/include)
+    ${GFXSTREAM_REPO_ROOT}/host/gl/glestranslator/GLcommon/include)
 target_link_libraries(
     GLcommon PUBLIC
     aemu-base.headers
diff --git a/host/gl/glestranslator/GLcommon/GLEScontext.cpp b/host/gl/glestranslator/GLcommon/GLEScontext.cpp
index 4678cee52..b5ec0182a 100644
--- a/host/gl/glestranslator/GLcommon/GLEScontext.cpp
+++ b/host/gl/glestranslator/GLcommon/GLEScontext.cpp
@@ -975,7 +975,7 @@ const GLvoid* GLEScontext::setPointer(GLenum arrType,GLint size,GLenum type,GLsi
                 m_shareGroup
                         ->getObjectData(NamedObjectType::VERTEXBUFFER,
                                         bufferName));
-        if(offset >= vbo->getSize() || vbo->getSize() - offset < size) {
+        if(offset >= vbo->getSize() || ((int)(vbo->getSize() - offset) < size)) {
 #ifdef _DEBUG
             ERR("Warning: Invalid pointer offset %u, arrType %d, type %d", offset, arrType, type);
 #endif
@@ -1143,7 +1143,12 @@ void GLEScontext::convertDirectVBO(GLESConversionArrays& cArrs,GLint first,GLsiz
 }
 
 unsigned int GLEScontext::findMaxIndex(GLsizei count,GLenum type,const GLvoid* indices) {
-    //finding max index
+    // finding max index
+    if (!indices || !GLESvalidate::drawType(type)) {
+        ERR("%s called with invalid arguments (%d, %u, %p)", __func__, count, type, indices);
+        return 0;
+    }
+
     unsigned int max = 0;
     if(type == GL_UNSIGNED_BYTE) {
         GLubyte*  b_indices  =(GLubyte *)indices;
diff --git a/host/gl/glestranslator/GLcommon/PaletteTexture.cpp b/host/gl/glestranslator/GLcommon/PaletteTexture.cpp
index 36a613b7b..70a40503f 100644
--- a/host/gl/glestranslator/GLcommon/PaletteTexture.cpp
+++ b/host/gl/glestranslator/GLcommon/PaletteTexture.cpp
@@ -46,7 +46,7 @@ void getPaletteInfo(GLenum internalFormat,unsigned int& indexSizeBits,unsigned i
     case GL_PALETTE4_RGBA4_OES:
     case GL_PALETTE4_RGB5_A1_OES:
         colorFrmt = GL_RGBA;
-        /* fall-through */
+        [[fallthrough]];
     case GL_PALETTE4_R5_G6_B5_OES:
         indexSizeBits = 4;
         colorSizeBytes = 2;
@@ -66,7 +66,7 @@ void getPaletteInfo(GLenum internalFormat,unsigned int& indexSizeBits,unsigned i
     case GL_PALETTE8_RGBA4_OES:
     case GL_PALETTE8_RGB5_A1_OES:
         colorFrmt = GL_RGBA;
-        /* fall-through */
+        [[fallthrough]];
     case GL_PALETTE8_R5_G6_B5_OES:
         indexSizeBits = 8;
         colorSizeBytes = 2;
diff --git a/host/gl/glestranslator/GLcommon/SaveableTexture.cpp b/host/gl/glestranslator/GLcommon/SaveableTexture.cpp
index 84928b115..048400c90 100644
--- a/host/gl/glestranslator/GLcommon/SaveableTexture.cpp
+++ b/host/gl/glestranslator/GLcommon/SaveableTexture.cpp
@@ -442,7 +442,7 @@ struct TextureDataReader {
                 D("with glFramebufferTexture3DOES + glReadPixels");
                 unsigned int layerImgSize = s_texImageSize(
                         format, type, 1, width, height);
-                for (unsigned int d = 0; d < depth; d++) {
+                for (int d = 0; d < depth; d++) {
                     gl.glFramebufferTexture3DOES(
                             fbTarget, attachment, target,
                             globalName, level, d);
@@ -460,7 +460,7 @@ struct TextureDataReader {
                 D("with glFramebufferTextureLayer + glReadPixels");
                 unsigned int layerImgSize = s_texImageSize(
                         format, type, 1, width, height);
-                for (unsigned int d = 0; d < depth; d++) {
+                for (int d = 0; d < depth; d++) {
                     gl.glFramebufferTextureLayer(
                             fbTarget, attachment,
                             globalName, level, d);
@@ -607,7 +607,7 @@ void SaveableTexture::onSave(
         GLint prevTex = 0;
         GLDispatch& dispatcher = GLEScontext::dispatcher();
         assert(dispatcher.glGetIntegerv);
-        for (int i = 0; i != android::base::arraySize(pixelStoreIndexes); ++i) {
+        for (int i = 0; i != (int)android::base::arraySize(pixelStoreIndexes); ++i) {
             if (isGles2Gles() && pixelStoreIndexes[i] != GL_PACK_ALIGNMENT &&
                 pixelStoreIndexes[i] != GL_UNPACK_ALIGNMENT) {
                 continue;
@@ -782,13 +782,13 @@ void SaveableTexture::onSave(
                 dispatcher.glGetTexParameteriv(m_target, plist[i], &param);
                 if (isSwizzleParam(plist[i]) && param != GL_ZERO &&
                         param != GL_ONE) {
-                    if (param == emulatedBaseSwizzle.toRed) {
+                    if (param == (GLint)emulatedBaseSwizzle.toRed) {
                         param = GL_RED;
-                    } else if (param == emulatedBaseSwizzle.toGreen) {
+                    } else if (param == (GLint)emulatedBaseSwizzle.toGreen) {
                         param = GL_GREEN;
-                    } else if (param == emulatedBaseSwizzle.toBlue) {
+                    } else if (param == (GLint)emulatedBaseSwizzle.toBlue) {
                         param = GL_BLUE;
-                    } else if (param == emulatedBaseSwizzle.toAlpha) {
+                    } else if (param == (GLint)emulatedBaseSwizzle.toAlpha) {
                         param = GL_ALPHA;
                     }
                 }
@@ -807,7 +807,7 @@ void SaveableTexture::onSave(
                     s->putBe32(pair.second);
                 });
         // Restore environment
-        for (int i = 0; i != android::base::arraySize(pixelStoreIndexes); ++i) {
+        for (int i = 0; i != (int)android::base::arraySize(pixelStoreIndexes); ++i) {
             if (isGles2Gles() && pixelStoreIndexes[i] != GL_PACK_ALIGNMENT &&
                 pixelStoreIndexes[i] != GL_UNPACK_ALIGNMENT) {
                 continue;
@@ -869,7 +869,7 @@ void SaveableTexture::restore() {
         static constexpr GLint pixelStoreDesired[] = {0, 0, 0, 0, 0, 1};
 
         GLint pixelStorePrev[android::base::arraySize(pixelStoreIndexes)];
-        for (int i = 0; i != android::base::arraySize(pixelStoreIndexes); ++i) {
+        for (int i = 0; i != (int)android::base::arraySize(pixelStoreIndexes); ++i) {
             if (isGles2Gles() && pixelStoreIndexes[i] != GL_PACK_ALIGNMENT &&
                 pixelStoreIndexes[i] != GL_UNPACK_ALIGNMENT) {
                 continue;
@@ -1026,7 +1026,7 @@ void SaveableTexture::restore() {
         }
         m_texParam.clear();
         // Restore environment
-        for (int i = 0; i != android::base::arraySize(pixelStoreIndexes); ++i) {
+        for (int i = 0; i != (int)android::base::arraySize(pixelStoreIndexes); ++i) {
             if (isGles2Gles() && pixelStoreIndexes[i] != GL_PACK_ALIGNMENT &&
                 pixelStoreIndexes[i] != GL_UNPACK_ALIGNMENT) {
                 continue;
diff --git a/host/gl/glestranslator/GLcommon/ScopedGLState.cpp b/host/gl/glestranslator/GLcommon/ScopedGLState.cpp
index 8c968fef7..4d5f8a033 100644
--- a/host/gl/glestranslator/GLcommon/ScopedGLState.cpp
+++ b/host/gl/glestranslator/GLcommon/ScopedGLState.cpp
@@ -101,6 +101,7 @@ ScopedGLState::~ScopedGLState() {
         switch (name) {
             case GL_DRAW_FRAMEBUFFER_BINDING:
                 gl.glBindFramebuffer(GL_DRAW_FRAMEBUFFER, v.intData[0]);
+                break;
             case GL_READ_FRAMEBUFFER_BINDING:
                 gl.glBindFramebuffer(GL_READ_FRAMEBUFFER, v.intData[0]);
                 break;
diff --git a/host/gl/glestranslator/GLcommon/ShareGroup.cpp b/host/gl/glestranslator/GLcommon/ShareGroup.cpp
index f581280c5..492a43152 100644
--- a/host/gl/glestranslator/GLcommon/ShareGroup.cpp
+++ b/host/gl/glestranslator/GLcommon/ShareGroup.cpp
@@ -55,6 +55,7 @@ ShareGroup::ShareGroup(GlobalNameSpace *globalNameSpace,
     if (stream) {
         m_needLoadRestore = true;
         int i = 0;
+        (void)i;
         for (auto ns : m_nameSpace) {
             GL_LOG("ShareGroup::%s: %p: start restore namespace for type %d\n", __func__, this, i);
             ns->postLoad(
@@ -82,6 +83,7 @@ void ShareGroup::onSave(android::base::Stream* stream) {
     assert(m_saveStage == PreSaved);
     m_saveStage = Saved;
     int i = 0;
+    (void)i;
     for (auto ns : m_nameSpace) {
         GL_LOG("ShareGroup::%s: %p: start saving type %d\n", __func__, this, i);
         ns->onSave(stream);
@@ -108,6 +110,7 @@ void ShareGroup::postLoadRestore() {
     android::base::AutoLock lock(m_restoreLock);
     if (m_needLoadRestore) {
         int i = 0;
+        (void)i;
         for (auto ns : m_nameSpace) {
             GL_LOG("ShareGroup::%s: %p: start post load restore namespace for type %d\n", __func__, this, i);
             ns->postLoadRestore([this](NamedObjectType p_type,
diff --git a/host/gl/glestranslator/GLcommon/TextureData.cpp b/host/gl/glestranslator/GLcommon/TextureData.cpp
index fda7b2330..63bc7a55f 100644
--- a/host/gl/glestranslator/GLcommon/TextureData.cpp
+++ b/host/gl/glestranslator/GLcommon/TextureData.cpp
@@ -53,8 +53,8 @@ TextureData::TextureData(android::base::Stream* stream) : ObjectData(stream) {
     });
 }
 
-void TextureData::onSave(android::base::Stream* stream, unsigned int globalName) const {
-    ObjectData::onSave(stream, globalName);
+void TextureData::onSave(android::base::Stream* stream, unsigned int overrideGlobalName) const {
+    ObjectData::onSave(stream, overrideGlobalName);
     // The current TextureData structure is wrong when dealing with mipmaps.
     stream->putBe32(target);
     stream->putBe32(width);
@@ -73,7 +73,7 @@ void TextureData::onSave(android::base::Stream* stream, unsigned int globalName)
     stream->write(crop_rect, sizeof(crop_rect));
     stream->putBe32(texStorageLevels);
     stream->putBe32(0); // deprecated mipmap level
-    stream->putBe32(globalName);
+    stream->putBe32(overrideGlobalName);
     saveCollection(stream, m_texParam,
                    [](android::base::Stream* stream,
                       const std::pair<const GLenum, GLint>& texParam) {
diff --git a/host/gl/glestranslator/GLcommon/TextureUtils.cpp b/host/gl/glestranslator/GLcommon/TextureUtils.cpp
index bd6e8df81..495b384fc 100644
--- a/host/gl/glestranslator/GLcommon/TextureUtils.cpp
+++ b/host/gl/glestranslator/GLcommon/TextureUtils.cpp
@@ -552,9 +552,9 @@ void doCompressedTexImage2D(GLEScontext* ctx, GLenum target, GLint level,
             delete [] uncompressed;
         }
     } else if (isRgtcFormat(internalformat)) {
-        GLint format, type;
+        GLint format = 0, type = 0;
         GLint convertedInternalFormat = decompressedInternalFormat(ctx, internalformat);
-        RGTCImageFormat rgtcFormat;
+        RGTCImageFormat rgtcFormat = BC4_UNORM;
         switch (internalformat) {
             case GL_COMPRESSED_RED_RGTC1_EXT:               // BC4U
                 format = GL_RED;
diff --git a/host/gl/glestranslator/include/GLcommon/FramebufferData.h b/host/gl/glestranslator/GLcommon/include/GLcommon/FramebufferData.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/FramebufferData.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/FramebufferData.h
diff --git a/host/gl/glestranslator/include/GLcommon/GLBackgroundLoader.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLBackgroundLoader.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/GLBackgroundLoader.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLBackgroundLoader.h
diff --git a/host/gl/glestranslator/include/GLcommon/GLDispatch.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLDispatch.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/GLDispatch.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLDispatch.h
diff --git a/host/gl/glestranslator/include/GLcommon/GLESbuffer.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLESbuffer.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/GLESbuffer.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLESbuffer.h
diff --git a/host/gl/glestranslator/include/GLcommon/GLEScontext.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLEScontext.h
similarity index 99%
rename from host/gl/glestranslator/include/GLcommon/GLEScontext.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLEScontext.h
index 44b87dfc9..f04551d0d 100644
--- a/host/gl/glestranslator/include/GLcommon/GLEScontext.h
+++ b/host/gl/glestranslator/GLcommon/include/GLcommon/GLEScontext.h
@@ -17,6 +17,7 @@
 #ifndef GLES_CONTEXT_H
 #define GLES_CONTEXT_H
 
+#include "aemu/base/ThreadAnnotations.h"
 #include "aemu/base/containers/Lookup.h"
 #include "aemu/base/files/Stream.h"
 #include "aemu/base/synchronization/Lock.h"
@@ -307,8 +308,8 @@ public:
     const char * getVendorString(bool isGles1) const;
     const char * getRendererString(bool isGles1) const;
     const char * getVersionString(bool isGles1) const;
-    void getGlobalLock();
-    void releaseGlobalLock();
+    void getGlobalLock() ACQUIRE(s_lock);
+    void releaseGlobalLock() RELEASE(s_lock);
     virtual const GLSupport*  getCaps() const = 0;
     static GLSupport* getCapsGlobal(){return &s_glSupport;};
     static bool vulkanInteropSupported() {
diff --git a/host/gl/glestranslator/include/GLcommon/GLESmacros.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLESmacros.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/GLESmacros.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLESmacros.h
diff --git a/host/gl/glestranslator/include/GLcommon/GLESpointer.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLESpointer.h
similarity index 98%
rename from host/gl/glestranslator/include/GLcommon/GLESpointer.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLESpointer.h
index 482e2d0da..677a4bc8e 100644
--- a/host/gl/glestranslator/include/GLcommon/GLESpointer.h
+++ b/host/gl/glestranslator/GLcommon/include/GLcommon/GLESpointer.h
@@ -42,7 +42,7 @@ public:
     GLuint getBufferName() const;
     GLboolean getNormalized() const { return m_normalize ? GL_TRUE : GL_FALSE; }
     const GLvoid* getData() const;
-    const GLsizei getDataSize() const { return m_dataSize; }
+    GLsizei getDataSize() const { return m_dataSize; }
     unsigned int getBufferOffset() const;
     void redirectPointerData();
     void getBufferConversions(const RangeList& rl, RangeList& rlOut);
diff --git a/host/gl/glestranslator/include/GLcommon/GLESvalidate.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLESvalidate.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/GLESvalidate.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLESvalidate.h
diff --git a/host/gl/glestranslator/include/GLcommon/GLLibrary.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLLibrary.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/GLLibrary.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLLibrary.h
diff --git a/host/gl/glestranslator/include/GLcommon/GLSnapshotSerializers.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLSnapshotSerializers.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/GLSnapshotSerializers.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLSnapshotSerializers.h
diff --git a/host/gl/glestranslator/include/GLcommon/GLconversion_macros.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLconversion_macros.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/GLconversion_macros.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLconversion_macros.h
diff --git a/host/gl/glestranslator/include/GLcommon/GLutils.h b/host/gl/glestranslator/GLcommon/include/GLcommon/GLutils.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/GLutils.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/GLutils.h
diff --git a/host/gl/glestranslator/include/GLcommon/NamedObject.h b/host/gl/glestranslator/GLcommon/include/GLcommon/NamedObject.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/NamedObject.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/NamedObject.h
diff --git a/host/gl/glestranslator/include/GLcommon/ObjectData.h b/host/gl/glestranslator/GLcommon/include/GLcommon/ObjectData.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/ObjectData.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/ObjectData.h
diff --git a/host/gl/glestranslator/include/GLcommon/ObjectNameSpace.h b/host/gl/glestranslator/GLcommon/include/GLcommon/ObjectNameSpace.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/ObjectNameSpace.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/ObjectNameSpace.h
diff --git a/host/gl/glestranslator/include/GLcommon/PaletteTexture.h b/host/gl/glestranslator/GLcommon/include/GLcommon/PaletteTexture.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/PaletteTexture.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/PaletteTexture.h
diff --git a/host/gl/glestranslator/include/GLcommon/RangeManip.h b/host/gl/glestranslator/GLcommon/include/GLcommon/RangeManip.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/RangeManip.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/RangeManip.h
diff --git a/host/gl/glestranslator/include/GLcommon/SaveableTexture.h b/host/gl/glestranslator/GLcommon/include/GLcommon/SaveableTexture.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/SaveableTexture.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/SaveableTexture.h
diff --git a/host/gl/glestranslator/include/GLcommon/ScopedGLState.h b/host/gl/glestranslator/GLcommon/include/GLcommon/ScopedGLState.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/ScopedGLState.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/ScopedGLState.h
diff --git a/host/gl/glestranslator/include/GLcommon/ShareGroup.h b/host/gl/glestranslator/GLcommon/include/GLcommon/ShareGroup.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/ShareGroup.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/ShareGroup.h
diff --git a/host/gl/glestranslator/include/GLcommon/TextureData.h b/host/gl/glestranslator/GLcommon/include/GLcommon/TextureData.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/TextureData.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/TextureData.h
diff --git a/host/gl/glestranslator/include/GLcommon/TextureUtils.h b/host/gl/glestranslator/GLcommon/include/GLcommon/TextureUtils.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/TextureUtils.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/TextureUtils.h
diff --git a/host/gl/glestranslator/include/GLcommon/TranslatorIfaces.h b/host/gl/glestranslator/GLcommon/include/GLcommon/TranslatorIfaces.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/TranslatorIfaces.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/TranslatorIfaces.h
diff --git a/host/gl/glestranslator/include/GLcommon/rgtc.h b/host/gl/glestranslator/GLcommon/include/GLcommon/rgtc.h
similarity index 100%
rename from host/gl/glestranslator/include/GLcommon/rgtc.h
rename to host/gl/glestranslator/GLcommon/include/GLcommon/rgtc.h
diff --git a/host/gl/glestranslator/GLcommon/meson.build b/host/gl/glestranslator/GLcommon/meson.build
index 686d94b7b..d1bf29ca2 100644
--- a/host/gl/glestranslator/GLcommon/meson.build
+++ b/host/gl/glestranslator/GLcommon/meson.build
@@ -27,7 +27,7 @@ lib_gl_common = static_library(
   'gl_common',
   files_lib_gl_common,
   cpp_args: gfxstream_host_args,
-  include_directories: [inc_etc, inc_gfxstream_include, inc_include, inc_stream_servers, inc_gles_translator],
+  include_directories: [inc_etc, inc_gfxstream_include, inc_include, inc_stream_servers, inc_gl_common],
   link_with: [lib_compressed_textures, lib_etc],
   dependencies: [aemu_base_dep, aemu_logging_dep, aemu_snapshot_dep]
 )
diff --git a/host/gl/meson.build b/host/gl/meson.build
index 11f97329c..f3247fada 100644
--- a/host/gl/meson.build
+++ b/host/gl/meson.build
@@ -2,7 +2,6 @@
 # SPDX-License-Identifier: MIT
 
 inc_gl_server = include_directories('.')
-inc_gles_translator = include_directories('glestranslator/include')
 inc_gl_snapshot = include_directories('glsnapshot')
 
 # snapshot
@@ -43,7 +42,7 @@ lib_gl_server = static_library(
   files_lib_gl_server,
   cpp_args: gfxstream_host_args,
   include_directories: [inc_gfxstream_include, inc_include, inc_stream_servers, inc_apigen_codec,
-                        inc_gl_snapshot, inc_gl_host_common, inc_host_features],
+                        inc_gl_snapshot, inc_gl_host_common, inc_host_features, inc_gl_common],
   link_with: [lib_gles1_dec, lib_gles2_dec, lib_apigen_codec, lib_gl_dispatch,
               lib_apigen_codec, lib_host_features],
   dependencies: [aemu_base_dep, aemu_common_dep, aemu_snapshot_dep]
diff --git a/host/include/gfxstream/virtio-gpu-gfxstream-renderer-goldfish.h b/host/include/gfxstream/virtio-gpu-gfxstream-renderer-goldfish.h
index 19323a2d5..bec83320f 100644
--- a/host/include/gfxstream/virtio-gpu-gfxstream-renderer-goldfish.h
+++ b/host/include/gfxstream/virtio-gpu-gfxstream-renderer-goldfish.h
@@ -28,7 +28,6 @@ VG_EXPORT void stream_renderer_set_service_ops(const GoldfishPipeServiceOps* ops
 VG_EXPORT int stream_renderer_snapshot_presave_pause();
 VG_EXPORT int stream_renderer_snapshot_save(void* saverStream);
 VG_EXPORT int stream_renderer_snapshot_postsave_resume();
-VG_EXPORT int stream_renderer_snapshot_postload_resume_for_testing();
 VG_EXPORT int stream_renderer_snapshot_load(void* loaderStream);
 
 #ifdef __cplusplus
diff --git a/host/include/gfxstream/virtio-gpu-gfxstream-renderer-unstable.h b/host/include/gfxstream/virtio-gpu-gfxstream-renderer-unstable.h
index eadee8d67..4f918cf12 100644
--- a/host/include/gfxstream/virtio-gpu-gfxstream-renderer-unstable.h
+++ b/host/include/gfxstream/virtio-gpu-gfxstream-renderer-unstable.h
@@ -72,20 +72,6 @@ VG_EXPORT void gfxstream_backend_setup_window(void* native_window_handle, int32_
 
 VG_EXPORT void stream_renderer_flush(uint32_t res_handle);
 
-// Platform resources and contexts support
-#define STREAM_RENDERER_PLATFORM_RESOURCE_USE_MASK 0xF0
-#define STREAM_RENDERER_PLATFORM_RESOURCE_TYPE_MASK 0x0F
-
-// types
-#define STREAM_RENDERER_PLATFORM_RESOURCE_TYPE_EGL_NATIVE_PIXMAP 0x01
-#define STREAM_RENDERER_PLATFORM_RESOURCE_TYPE_EGL_IMAGE 0x02
-#define STREAM_RENDERER_PLATFORM_RESOURCE_TYPE_VK_EXT_MEMORY_HANDLE 0x03
-
-// uses
-#define STREAM_RENDERER_PLATFORM_RESOURCE_USE_PRESERVE 0x10
-
-VG_EXPORT int stream_renderer_platform_import_resource(int res_handle, int res_info,
-                                                       void* resource);
 VG_EXPORT void* stream_renderer_platform_create_shared_egl_context(void);
 VG_EXPORT int stream_renderer_platform_destroy_shared_egl_context(void*);
 
@@ -112,7 +98,29 @@ VG_EXPORT int stream_renderer_restore(const char* dir);
 
 VG_EXPORT int stream_renderer_resume();
 
-VG_EXPORT int stream_renderer_wait_sync_resource(uint32_t res_handle);
+// Matches Resource3DInfo in rutabaga_gfx
+struct stream_renderer_3d_info {
+    uint32_t width;
+    uint32_t height;
+    uint32_t drm_fourcc;
+    uint32_t strides[4];
+    uint32_t offsets[4];
+    uint64_t modifier;
+};
+
+#define STREAM_RENDERER_IMPORT_FLAG_3D_INFO (1 << 0)
+#define STREAM_RENDERER_IMPORT_FLAG_VULKAN_INFO (1 << 1)
+#define STREAM_RENDERER_IMPORT_FLAG_RESOURCE_EXISTS (1 << 30)
+#define STREAM_RENDERER_IMPORT_FLAG_PRESERVE_CONTENT (1 << 31)
+struct stream_renderer_import_data {
+    uint32_t flags;
+    struct stream_renderer_3d_info info_3d;
+    struct stream_renderer_vulkan_info info_vulkan;
+};
+
+VG_EXPORT int stream_renderer_import_resource(
+    uint32_t res_handle, const struct stream_renderer_handle* import_handle,
+    const struct stream_renderer_import_data* import_data);
 
 #ifdef __cplusplus
 }  // extern "C"
diff --git a/host/include/gfxstream/virtio-gpu-gfxstream-renderer.h b/host/include/gfxstream/virtio-gpu-gfxstream-renderer.h
index 4f6000d6e..6ee681685 100644
--- a/host/include/gfxstream/virtio-gpu-gfxstream-renderer.h
+++ b/host/include/gfxstream/virtio-gpu-gfxstream-renderer.h
@@ -77,15 +77,21 @@ struct stream_renderer_fence {
     uint8_t ring_idx;
 };
 
-#define STREAM_MEM_HANDLE_TYPE_OPAQUE_FD 0x1
-#define STREAM_MEM_HANDLE_TYPE_DMABUF 0x2
-#define STREAM_MEM_HANDLE_TYPE_OPAQUE_WIN32 0x3
-#define STREAM_MEM_HANDLE_TYPE_SHM 0x4
-#define STREAM_MEM_HANDLE_TYPE_ZIRCON 0x5
-#define STREAM_FENCE_HANDLE_TYPE_OPAQUE_FD 0x6
-#define STREAM_FENCE_HANDLE_TYPE_SYNC_FD 0x7
-#define STREAM_FENCE_HANDLE_TYPE_OPAQUE_WIN32 0x8
-#define STREAM_FENCE_HANDLE_TYPE_ZIRCON 0x9
+#define STREAM_HANDLE_TYPE_MEM_OPAQUE_FD 0x1
+#define STREAM_HANDLE_TYPE_MEM_DMABUF 0x2
+#define STREAM_HANDLE_TYPE_MEM_OPAQUE_WIN32 0x3
+#define STREAM_HANDLE_TYPE_MEM_SHM 0x4
+#define STREAM_HANDLE_TYPE_MEM_ZIRCON 0x5
+
+#define STREAM_HANDLE_TYPE_SIGNAL_OPAQUE_FD 0x10
+#define STREAM_HANDLE_TYPE_SIGNAL_SYNC_FD 0x20
+#define STREAM_HANDLE_TYPE_SIGNAL_OPAQUE_WIN32 0x30
+#define STREAM_HANDLE_TYPE_SIGNAL_ZIRCON 0x40
+#define STREAM_HANDLE_TYPE_SIGNAL_EVENT_FD 0x50
+
+#define STREAM_HANDLE_TYPE_PLATFORM_SCREEN_BUFFER_QNX 0x01000000
+#define STREAM_HANDLE_TYPE_PLATFORM_EGL_NATIVE_PIXMAP 0x02000000
+
 struct stream_renderer_handle {
     int64_t os_handle;
     uint32_t handle_type;
diff --git a/host/magma/BUILD.bazel b/host/magma/BUILD.bazel
index 746150c5b..3b21245c4 100644
--- a/host/magma/BUILD.bazel
+++ b/host/magma/BUILD.bazel
@@ -1,3 +1,5 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
+
 cc_library(
     name = "gfxstream-magma-server",
     srcs = [
@@ -8,9 +10,9 @@ cc_library(
     includes = ["magma_dec"],
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/gfxstream/host:gfxstream_host_headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
-        "//hardware/google/gfxstream/third-party/fuchsia/magma:magma-headers",
+        "//host:gfxstream_host_headers",
+        "//host/apigen-codec-common",
+        "//third-party/fuchsia/magma:magma-headers",
     ],
 )
 
diff --git a/host/meson.build b/host/meson.build
index 0abe13b80..de30c8790 100644
--- a/host/meson.build
+++ b/host/meson.build
@@ -100,6 +100,7 @@ if use_auto
   use_magma = host_machine.system() == 'linux'
 endif
 
+gfxstream_host_args += '-DGFXSTREAM_MESON_BUILD=1'
 gfxstream_host_args += '-DGFXSTREAM_ENABLE_HOST_GLES=@0@'.format(use_gles ? '1' : '0')
 
 if use_magma
@@ -151,6 +152,8 @@ endif
 inc_stream_servers = include_directories('.')
 inc_host_include = include_directories('include')
 
+inc_gl_common = include_directories('gl/glestranslator/GLcommon/include')
+
 subdir('features')
 subdir('tracing')
 
@@ -186,6 +189,7 @@ files_lib_gfxstream_backend = files(
   'RendererImpl.cpp',
   'FrameBuffer.cpp',
   'GfxStreamAgents.cpp',
+  'GraphicsDriverLock.cpp',
   'virtio-gpu-gfxstream-renderer.cpp',
   'VirtioGpuContext.cpp',
   'VirtioGpuFrontend.cpp',
@@ -206,7 +210,7 @@ if use_gles
   files_lib_gfxstream_backend += files('RenderThreadInfoGl.cpp')
   files_lib_gfxstream_backend += files('RenderControl.cpp')
 
-  inc_gfxstream_backend += [inc_gl_server, inc_gl_snapshot, inc_gles_translator]
+  inc_gfxstream_backend += [inc_gl_server, inc_gl_snapshot, inc_gl_common]
   link_gfxstream_backend += lib_gl_server
 endif
 
diff --git a/host/renderControl_dec/BUILD.bazel b/host/renderControl_dec/BUILD.bazel
index b91b510db..bd36a87c0 100644
--- a/host/renderControl_dec/BUILD.bazel
+++ b/host/renderControl_dec/BUILD.bazel
@@ -1,3 +1,5 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
+
 cc_library(
     name = "renderControl_dec",
     srcs = [
@@ -7,7 +9,7 @@ cc_library(
     hdrs = [],
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/gfxstream/common/opengl:gfxstream_opengl_headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
+        "//common/opengl:gfxstream_opengl_headers",
+        "//host/apigen-codec-common",
     ],
 )
diff --git a/host/tests/CompositorVk_unittest.cpp b/host/tests/CompositorVk_unittest.cpp
index 25015e3cf..643dbefbe 100644
--- a/host/tests/CompositorVk_unittest.cpp
+++ b/host/tests/CompositorVk_unittest.cpp
@@ -292,7 +292,7 @@ class CompositorVkTest : public ::testing::Test {
         uint32_t physicalDeviceCount = 0;
         ASSERT_EQ(k_vk->vkEnumeratePhysicalDevices(m_vkInstance, &physicalDeviceCount, nullptr),
                   VK_SUCCESS);
-        ASSERT_GT(physicalDeviceCount, 0);
+        ASSERT_GT(physicalDeviceCount, (uint32_t)0);
         std::vector<VkPhysicalDevice> physicalDevices(physicalDeviceCount);
         ASSERT_EQ(k_vk->vkEnumeratePhysicalDevices(m_vkInstance, &physicalDeviceCount,
                                                    physicalDevices.data()),
@@ -300,7 +300,7 @@ class CompositorVkTest : public ::testing::Test {
         for (const auto &device : physicalDevices) {
             uint32_t queueFamilyCount = 0;
             k_vk->vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);
-            ASSERT_GT(queueFamilyCount, 0);
+            ASSERT_GT(queueFamilyCount, (uint32_t)0);
             std::vector<VkQueueFamilyProperties> queueFamilyProperties(queueFamilyCount);
             k_vk->vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount,
                                                            queueFamilyProperties.data());
diff --git a/host/tests/FrameBuffer_unittest.cpp b/host/tests/FrameBuffer_unittest.cpp
index 83f3d9b45..e7db7bf66 100644
--- a/host/tests/FrameBuffer_unittest.cpp
+++ b/host/tests/FrameBuffer_unittest.cpp
@@ -180,7 +180,7 @@ TEST_F(FrameBufferTest, FrameBufferBasic) {
 TEST_F(FrameBufferTest, CreateColorBuffer) {
     HandleType handle =
         mFb->createColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     // FramBuffer::finalize handles color buffer destruction here
 }
 
@@ -188,7 +188,7 @@ TEST_F(FrameBufferTest, CreateColorBuffer) {
 TEST_F(FrameBufferTest, CreateCloseColorBuffer) {
     HandleType handle =
         mFb->createColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     mFb->closeColorBuffer(handle);
 }
 
@@ -196,7 +196,7 @@ TEST_F(FrameBufferTest, CreateCloseColorBuffer) {
 TEST_F(FrameBufferTest, CreateOpenCloseColorBuffer) {
     HandleType handle =
         mFb->createColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     EXPECT_EQ(0, mFb->openColorBuffer(handle));
     mFb->closeColorBuffer(handle);
 }
@@ -206,7 +206,7 @@ TEST_F(FrameBufferTest, CreateOpenCloseColorBuffer) {
 TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer) {
     HandleType handle =
         mFb->createColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     EXPECT_EQ(0, mFb->openColorBuffer(handle));
 
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
@@ -225,7 +225,7 @@ TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer) {
 TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_ReadYUV420) {
     HandleType handle = mFb->createColorBuffer(mWidth, mHeight, GL_RGBA,
                                                FRAMEWORK_FORMAT_YUV_420_888);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     EXPECT_EQ(0, mFb->openColorBuffer(handle));
 
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
@@ -252,7 +252,7 @@ TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_ReadYUV420) {
 TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_ReadNV12) {
     HandleType handle = mFb->createColorBuffer(mWidth, mHeight, GL_RGBA,
                                                FRAMEWORK_FORMAT_NV12);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     EXPECT_EQ(0, mFb->openColorBuffer(handle));
 
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
@@ -282,7 +282,7 @@ TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_ReadNV12TOYUV420) {
     mHeight = 8;
     HandleType handle_nv12 = mFb->createColorBuffer(mWidth, mHeight, GL_RGBA,
                                                     FRAMEWORK_FORMAT_NV12);
-    EXPECT_NE(0, handle_nv12);
+    EXPECT_NE((HandleType)0, handle_nv12);
     EXPECT_EQ(0, mFb->openColorBuffer(handle_nv12));
 
     uint8_t forUpdate[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
@@ -306,7 +306,7 @@ TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_ReadNV12TOYUV420) {
     // yuv420
     HandleType handle_yuv420 = mFb->createColorBuffer(
             mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_YUV_420_888);
-    EXPECT_NE(0, handle_yuv420);
+    EXPECT_NE((HandleType)0, handle_yuv420);
     EXPECT_EQ(0, mFb->openColorBuffer(handle_yuv420));
 
     uint32_t textures[2] = {1, 2};
@@ -334,7 +334,7 @@ TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_ReadYV12) {
     mWidth = 20 * 16;
     HandleType handle = mFb->createColorBuffer(mWidth, mHeight, GL_RGBA,
                                                FRAMEWORK_FORMAT_YV12);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     EXPECT_EQ(0, mFb->openColorBuffer(handle));
 
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
@@ -364,7 +364,7 @@ TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_ReadYV12) {
 TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_FormatChange) {
     HandleType handle =
         mFb->createColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     EXPECT_EQ(0, mFb->openColorBuffer(handle));
 
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
@@ -384,19 +384,19 @@ TEST_F(FrameBufferTest, CreateOpenUpdateCloseColorBuffer_FormatChange) {
 // Tests obtaining EGL configs from FrameBuffer.
 TEST_F(FrameBufferTest, Configs) {
     const EmulatedEglConfigList* configs = mFb->getConfigs();
-    EXPECT_GE(configs->size(), 0);
+    EXPECT_GE(configs->size(), (size_t)0);
 }
 
 // Tests creating GL context from FrameBuffer.
 TEST_F(FrameBufferTest, CreateEmulatedEglContext) {
     HandleType handle = mFb->createEmulatedEglContext(0, 0, GLESApi_3_0);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
 }
 
 // Tests creating window surface from FrameBuffer.
 TEST_F(FrameBufferTest, CreateEmulatedEglWindowSurface) {
     HandleType handle = mFb->createEmulatedEglWindowSurface(0, mWidth, mHeight);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
 }
 
 // Tests eglMakeCurrent from FrameBuffer.
@@ -745,7 +745,7 @@ TEST_F(FrameBufferTest, VulkanInteropQuery) {
 TEST_F(FrameBufferTest, CreateColorBufferBGRA) {
     HandleType handle =
         mFb->createColorBuffer(mWidth, mHeight, GL_BGRA_EXT, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     // FramBuffer::finalize handles color buffer destruction here
 }
 
@@ -754,7 +754,7 @@ TEST_F(FrameBufferTest, CreateColorBufferBGRA) {
 TEST_F(FrameBufferTest, DISABLED_ReadColorBufferSwitchRedBlue) {
     HandleType handle =
         mFb->createColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     EXPECT_EQ(0, mFb->openColorBuffer(handle));
 
     TestTexture forUpdate = createTestPatternRGBA8888(mWidth, mHeight);
@@ -769,8 +769,8 @@ TEST_F(FrameBufferTest, DISABLED_ReadColorBufferSwitchRedBlue) {
     // Switch them back, so we get the original image
     uint8_t* forReadBytes = forRead.data();
 
-    for (uint32_t row = 0; row < mHeight; ++row) {
-        for (uint32_t col = 0; col < mWidth; ++col) {
+    for (int row = 0; row < mHeight; ++row) {
+        for (int col = 0; col < mWidth; ++col) {
             uint8_t* pixel = forReadBytes + mWidth * 4 * row + col * 4;
             // In RGBA8:
             //    3 2 1 0
@@ -801,7 +801,7 @@ TEST_F(FrameBufferTest, BindMultiDisplayColorBuffer) {
     EXPECT_EQ(0, mFb->createDisplay(&id));
     uint32_t handle =
         mFb->createColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-    EXPECT_NE(0, handle);
+    EXPECT_NE((HandleType)0, handle);
     EXPECT_EQ(0, mFb->setDisplayColorBuffer(id, handle));
     uint32_t getHandle = 0;
     mFb->getDisplayColorBuffer(id, &getHandle);
@@ -816,7 +816,7 @@ TEST_F(FrameBufferTest, BindMultiDisplayColorBuffer) {
 TEST_F(FrameBufferTest, SetMultiDisplayPosition) {
     uint32_t id = FrameBuffer::s_invalidIdMultiDisplay;
     mFb->createDisplay(&id);
-    EXPECT_NE(0, id);
+    EXPECT_NE((uint32_t)0, id);
     uint32_t w = mWidth / 2, h = mHeight / 2;
     EXPECT_EQ(0, mFb->setDisplayPose(id, -1, -1, w, h));
     int32_t x, y;
@@ -887,115 +887,5 @@ TEST_F(FrameBufferTest, ComposeMultiDisplay) {
     mFb->destroyEmulatedEglWindowSurface(surface);
 }
 
-#ifdef GFXSTREAM_HAS_X11
-// Tests basic pixmap import. Can we import a native pixmap and successfully
-// upload and read back some color?
-TEST_F(FrameBufferTest, PixmapImport_Basic) {
-    const int kWidth = 16;
-    const int kHeight = 16;
-    const int kBytesPerPixel = 4;
-
-    // Only run this test on display :0.
-    auto disp =  android::base::getEnvironmentVariable("DISPLAY");
-    if (disp != ":0" ) {
-        fprintf(stderr, "%s: Wawrning: Skipping test because DISPLAY is [%s] (not :0)\n", __func__,
-                disp.c_str());
-        return;
-    }
-
-    void* pixmap = createNativePixmap(kWidth, kHeight, kBytesPerPixel);
-    EXPECT_NE(nullptr, pixmap);
-
-    HandleType cb =
-        mFb->createColorBuffer(kWidth, kHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-    TestTexture forUpdate = createTestTextureRGBA8888SingleColor(kWidth, kHeight, 1.0f, 0.0f, 1.0f, 1.0f);
-    EXPECT_EQ(0, mFb->openColorBuffer(cb));
-    mFb->updateColorBuffer(cb, 0, 0, kWidth, kHeight, GL_RGBA, GL_UNSIGNED_BYTE, forUpdate.data());
-
-    EXPECT_TRUE(mFb->platformImportResource(cb, RESOURCE_TYPE_EGL_NATIVE_PIXMAP|RESOURCE_USE_PRESERVE, pixmap));
-
-    TestTexture forRead =
-        createTestTextureRGBA8888SingleColor(kWidth, kHeight, 0.0f, 0.0f, 0.0f, 0.0f);
-    mFb->readColorBuffer(cb, 0, 0, kWidth, kHeight, GL_RGBA, GL_UNSIGNED_BYTE, forRead.data(),
-                         forRead.size());
-
-    EXPECT_TRUE(ImageMatches(kWidth, kHeight, 4, kWidth, forUpdate.data(), forRead.data()));
-
-    mFb->closeColorBuffer(cb);
-
-    freeNativePixmap(pixmap);
-}
-
-// Similar to BasicBlit, except the color buffer is backed by a pixmap.
-// Can we render to the pixmap and read back contents?
-TEST_F(FrameBufferTest, PixmapImport_Blit) {
-    // Only run this test on display :0.
-    auto disp =  android::base::getEnvironmentVariable("DISPLAY");
-    if (disp != ":0" ) {
-        fprintf(stderr, "%s: Wawrning: Skipping test because DISPLAY is [%s] (not :0)\n", __func__,
-                disp.c_str());
-        return;
-    }
-
-    auto gl = LazyLoadedGLESv2Dispatch::get();
-
-    void* pixmap = createNativePixmap(mWidth, mHeight, 4);
-    EXPECT_NE(nullptr, pixmap);
-
-    HandleType colorBuffer =
-        mFb->createColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE);
-
-    EXPECT_TRUE(mFb->platformImportResource(colorBuffer, RESOURCE_TYPE_EGL_NATIVE_PIXMAP, pixmap));
-
-    HandleType context = mFb->createEmulatedEglContext(0, 0, GLESApi_3_0);
-    HandleType surface = mFb->createEmulatedEglWindowSurface(0, mWidth, mHeight);
-
-    EXPECT_TRUE(mFb->bindContext(context, surface, surface));
-    EXPECT_TRUE(mFb->setEmulatedEglWindowSurfaceColorBuffer(surface, colorBuffer));
-
-    float colors[3][4] = {
-        { 1.0f, 0.0f, 0.0f, 1.0f},
-        { 0.0f, 1.0f, 0.0f, 1.0f},
-        { 0.0f, 0.0f, 1.0f, 1.0f},
-    };
-
-    for (int i = 0; i < 3; i++) {
-        float* color = colors[i];
-
-        gl->glClearColor(color[0], color[1], color[2], color[3]);
-        gl->glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-        mFb->flushEmulatedEglWindowSurfaceColorBuffer(surface);
-
-        TestTexture targetBuffer =
-            createTestTextureRGBA8888SingleColor(
-                mWidth, mHeight, color[0], color[1], color[2], color[3]);
-
-        TestTexture forRead =
-            createTestTextureRGBA8888SingleColor(
-                mWidth, mHeight, 0.0f, 0.0f, 0.0f, 0.0f);
-
-        mFb->readColorBuffer(colorBuffer, 0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE,
-                             forRead.data(), forRead.size());
-
-        EXPECT_TRUE(
-            ImageMatches(
-                mWidth, mHeight, 4, mWidth,
-                targetBuffer.data(), forRead.data()));
-
-        if (mUseSubWindow) {
-            mFb->post(colorBuffer);
-            mWindow->messageLoop();
-        }
-    }
-
-    EXPECT_TRUE(mFb->bindContext(0, 0, 0));
-    mFb->closeColorBuffer(colorBuffer);
-    mFb->closeColorBuffer(colorBuffer);
-    mFb->destroyEmulatedEglWindowSurface(surface);
-
-    freeNativePixmap(pixmap);
-}
-#endif
-
 }  // namespace
 }  // namespace gfxstream
diff --git a/host/tests/GLSnapshotTestStateUtils.cpp b/host/tests/GLSnapshotTestStateUtils.cpp
index 46b0af325..a29cac903 100644
--- a/host/tests/GLSnapshotTestStateUtils.cpp
+++ b/host/tests/GLSnapshotTestStateUtils.cpp
@@ -25,23 +25,25 @@
 namespace gfxstream {
 namespace gl {
 
+static constexpr const GLenum kNoError = GL_NO_ERROR;
+
 GLuint createBuffer(const GLESv2Dispatch* gl, GlBufferData data) {
     // We bind to GL_ARRAY_BUFFER in order to set up buffer data,
     // so let's hold on to what the old binding was so we can restore it
     GLuint currentArrayBuffer;
     gl->glGetIntegerv(GL_ARRAY_BUFFER_BINDING, (GLint*)&currentArrayBuffer);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
 
     GLuint name;
     gl->glGenBuffers(1, &name);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
 
     gl->glBindBuffer(GL_ARRAY_BUFFER, name);
     gl->glBufferData(GL_ARRAY_BUFFER, data.size, data.bytes, data.usage);
 
     // Restore the old binding
     gl->glBindBuffer(GL_ARRAY_BUFFER, currentArrayBuffer);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     return name;
 };
 
@@ -89,21 +91,21 @@ std::vector<GLubyte> getTextureImageData(const GLESv2Dispatch* gl,
     GLuint auxFramebuffer;
     gl->glGenFramebuffers(1, &auxFramebuffer);
     gl->glBindFramebuffer(GL_FRAMEBUFFER, auxFramebuffer);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
 
     gl->glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, target,
                                texture, level);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     gl->glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE,
                      out.data());  // TODO(benzene): flexible format/type?
                                    // seems like RGBA/UNSIGNED_BYTE is the only
                                    // guaranteed supported format+type
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
 
     // restore old framebuffer
     gl->glBindFramebuffer(GL_FRAMEBUFFER, oldFramebuffer);
     gl->glDeleteFramebuffers(1, &auxFramebuffer);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
 
     return out;
 }
diff --git a/host/tests/GLSnapshotTesting.cpp b/host/tests/GLSnapshotTesting.cpp
index 8ea3945d7..062c6ee18 100644
--- a/host/tests/GLSnapshotTesting.cpp
+++ b/host/tests/GLSnapshotTesting.cpp
@@ -32,6 +32,8 @@
 namespace gfxstream {
 namespace gl {
 
+static constexpr const GLenum kNoError = GL_NO_ERROR;
+
 using android::base::StdioStream;
 using android::snapshot::TextureLoader;
 using android::snapshot::TextureSaver;
@@ -71,7 +73,7 @@ testing::AssertionResult compareGlobalGlBoolean(const GLESv2Dispatch* gl,
                                                 GLboolean expected) {
     GLboolean current;
     gl->glGetBooleanv(name, &current);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     return compareValue<GLboolean>(expected, current,
                                    "GL global boolean mismatch for parameter " +
                                            describeGlEnum(name) + ":");
@@ -82,7 +84,7 @@ testing::AssertionResult compareGlobalGlInt(const GLESv2Dispatch* gl,
                                             GLint expected) {
     GLint current;
     gl->glGetIntegerv(name, &current);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     return compareValue<GLint>(expected, current,
                                "GL global int mismatch for parameter " +
                                        describeGlEnum(name) + ":");
@@ -94,7 +96,7 @@ testing::AssertionResult compareGlobalGlInt_i(const GLESv2Dispatch* gl,
                                               GLint expected) {
     GLint current;
     gl->glGetIntegeri_v(name, index, &current);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     return compareValue<GLint>(expected, current,
                                "GL global int_i mismatch for parameter " +
                                        describeGlEnum(name) + ":" + std::to_string(index));
@@ -106,7 +108,7 @@ testing::AssertionResult compareGlobalGlFloat(const GLESv2Dispatch* gl,
                                               GLfloat expected) {
     GLfloat current;
     gl->glGetFloatv(name, &current);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     return compareValue<GLfloat>(expected, current,
                                  "GL global float mismatch for parameter " +
                                          describeGlEnum(name) + ":");
@@ -123,7 +125,7 @@ testing::AssertionResult compareVector(const std::vector<T>& expected,
     }
 
     int mismatches = 0;
-    for (int i = 0; i < expected.size(); i++) {
+    for (size_t i = 0; i < expected.size(); i++) {
         if (i >= actual.size()) {
             if (mismatches < 10) {
                 mismatches++;
@@ -181,7 +183,7 @@ testing::AssertionResult compareGlobalGlBooleanv(
     std::vector<GLboolean> current;
     current.resize(std::max(size, static_cast<GLuint>(expected.size())));
     gl->glGetBooleanv(name, &current[0]);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     return compareVector<GLboolean>(
             expected, current,
             "GL global booleanv parameter " + describeGlEnum(name));
@@ -197,7 +199,7 @@ testing::AssertionResult compareGlobalGlBooleanv_i(
     std::vector<GLboolean> current;
     current.resize(std::max(size, static_cast<GLuint>(expected.size())));
     gl->glGetBooleani_v(name, index,  &current[0]);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     return compareVector<GLboolean>(
             expected, current,
             "GL global booleanv_i parameter " + describeGlEnum(name) + ":" + std::to_string(index) );
@@ -210,7 +212,7 @@ testing::AssertionResult compareGlobalGlIntv(const GLESv2Dispatch* gl,
     std::vector<GLint> current;
     current.resize(std::max(size, static_cast<GLuint>(expected.size())));
     gl->glGetIntegerv(name, &current[0]);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     return compareVector<GLint>(
             expected, current,
             "GL global intv parameter " + describeGlEnum(name));
@@ -225,7 +227,7 @@ testing::AssertionResult compareGlobalGlFloatv(
     std::vector<GLfloat> current;
     current.resize(std::max(size, static_cast<GLuint>(expected.size())));
     gl->glGetFloatv(name, &current[0]);
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     return compareVector<GLfloat>(
             expected, current,
             "GL global floatv parameter " + describeGlEnum(name));
@@ -321,12 +323,12 @@ void SnapshotPreserveTest::doCheckedSnapshot() {
     {
         SCOPED_TRACE("during pre-snapshot default state check");
         defaultStateCheck();
-        ASSERT_EQ(GL_NO_ERROR, gl->glGetError());
+        ASSERT_EQ(kNoError, gl->glGetError());
     }
     {
         SCOPED_TRACE("during pre-snapshot state change");
         stateChange();
-        ASSERT_EQ(GL_NO_ERROR, gl->glGetError());
+        ASSERT_EQ(kNoError, gl->glGetError());
     }
     {
         SCOPED_TRACE("during pre-snapshot changed state check");
@@ -334,14 +336,14 @@ void SnapshotPreserveTest::doCheckedSnapshot() {
     }
     SnapshotTest::doSnapshot([this] {
         SCOPED_TRACE("during post-reset default state check");
-        EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+        EXPECT_EQ(kNoError, gl->glGetError());
         defaultStateCheck();
     });
-    EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+    EXPECT_EQ(kNoError, gl->glGetError());
     {
         SCOPED_TRACE("during post-snapshot changed state check");
         changedStateCheck();
-        EXPECT_EQ(GL_NO_ERROR, gl->glGetError());
+        EXPECT_EQ(kNoError, gl->glGetError());
     }
 }
 
diff --git a/host/tests/Magma_unittest.cpp b/host/tests/Magma_unittest.cpp
index 027f28309..210e64aa6 100644
--- a/host/tests/Magma_unittest.cpp
+++ b/host/tests/Magma_unittest.cpp
@@ -34,25 +34,25 @@ TEST_F(MagmaTest, MonotonicMap) {
     gfxstream::magma::MonotonicMap<uint64_t, MapTester> m;
 
     auto k1 = m.create(42, "hello");
-    EXPECT_EQ(k1, 1);
+    EXPECT_EQ(k1, (uint64_t)1);
     auto v1 = m.get(k1);
     ASSERT_NE(v1, nullptr);
-    EXPECT_EQ(v1->x, 42 + 5);
+    EXPECT_EQ(v1->x, (uint64_t)(42 + 5));
 
     auto k2 = m.create(5, "foo");
-    EXPECT_EQ(k2, 2);
+    EXPECT_EQ(k2, (uint64_t)2);
     auto v2 = m.get(k2);
     ASSERT_NE(v2, nullptr);
-    EXPECT_EQ(v2->x, 5 + 3);
+    EXPECT_EQ(v2->x, (uint64_t)(5 + 3));
 
     EXPECT_TRUE(m.erase(k1));
     EXPECT_FALSE(m.erase(k1));
 
     auto k3 = m.create(8, "bar");
-    EXPECT_EQ(k3, 3);
+    EXPECT_EQ(k3, (uint64_t)3);
     auto v3 = m.get(k3);
     ASSERT_NE(v3, nullptr);
-    EXPECT_EQ(v3->x, 11);
+    EXPECT_EQ(v3->x, (uint64_t)11);
 
     auto v2b = m.get(k2);
     EXPECT_EQ(v2, v2b);
diff --git a/host/tests/SampleApplication.cpp b/host/tests/SampleApplication.cpp
index 82b9712cc..422518e1d 100644
--- a/host/tests/SampleApplication.cpp
+++ b/host/tests/SampleApplication.cpp
@@ -345,9 +345,9 @@ void SampleApplication::drawWorkerWithCompose(ColorBufferQueue& app2sfQueue,
         app2sfQueue.dequeueBuffer(&appItem);
         if (appItem.sync) { appItem.sync->wait(EGL_FOREVER_KHR); }
 
-        hwc_rect_t displayFrame = {0, 0, mWidth, mHeight/2};
-        hwc_frect_t crop = {0.0, 0.0, (float)mWidth, (float)mHeight};
-        hwc_color_t color = {0, 0, 0, 0};
+        displayFrame = {0, 0, mWidth, mHeight/2};
+        crop = {0.0, 0.0, (float)mWidth, (float)mHeight};
+        color = {0, 0, 0, 0};
         autoComposeDevice.configureLayer(1,
                                          appItem.colorBuffer,
                                          HWC2_COMPOSITION_DEVICE,
diff --git a/host/tests/Vulkan_unittest.cpp b/host/tests/Vulkan_unittest.cpp
index 0d4c8b7ba..a1bb6c561 100644
--- a/host/tests/Vulkan_unittest.cpp
+++ b/host/tests/Vulkan_unittest.cpp
@@ -471,16 +471,20 @@ protected:
 };
 
 TEST_F(VulkanFrameBufferTest, VkColorBufferWithoutMemoryProperties) {
+    auto& vkEmulation = mFb->getEmulationVk();
+
     // Create a color buffer without any memory properties restriction.
-    EXPECT_TRUE(createVkColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE,
-                                    kArbitraryColorBufferHandle, true, /* vulkanOnly */
-                                    0                                  /* memoryProperty */
-                                    ));
-    EXPECT_TRUE(teardownVkColorBuffer(kArbitraryColorBufferHandle));
+    EXPECT_TRUE(vkEmulation.createVkColorBuffer(mWidth, mHeight, GL_RGBA,
+                                                FRAMEWORK_FORMAT_GL_COMPATIBLE,
+                                                kArbitraryColorBufferHandle, true, /* vulkanOnly */
+                                                0 /* memoryProperty */
+                                                ));
+    EXPECT_TRUE(vkEmulation.teardownVkColorBuffer(kArbitraryColorBufferHandle));
 }
 
 TEST_F(VulkanFrameBufferTest, VkColorBufferWithMemoryPropertyFlags) {
-    auto* vkEmulation = getGlobalVkEmulation();
+    auto& vkEmulation = mFb->getEmulationVk();
+
     VkMemoryPropertyFlags kTargetMemoryPropertyFlags =
             VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
 
@@ -519,12 +523,13 @@ TEST_F(VulkanFrameBufferTest, VkColorBufferWithMemoryPropertyFlags) {
         GTEST_SKIP();
     }
 
+    VkPhysicalDeviceMemoryProperties memProps;
+    mVk.vkGetPhysicalDeviceMemoryProperties(mPhysicalDevice, &memProps);
+
     int32_t memoryTypeIndex = 31;
     do {
         if (((1 << memoryTypeIndex) & memReq.memoryTypeBits) &&
-            (vkEmulation->deviceInfo.memProps.memoryTypes[memoryTypeIndex]
-                     .propertyFlags &
-             kTargetMemoryPropertyFlags)) {
+            (memProps.memoryTypes[memoryTypeIndex].propertyFlags & kTargetMemoryPropertyFlags)) {
             break;
         }
     } while (--memoryTypeIndex >= 0);
@@ -537,19 +542,19 @@ TEST_F(VulkanFrameBufferTest, VkColorBufferWithMemoryPropertyFlags) {
     }
 
     // Create a color buffer with the target memory property flags.
-    EXPECT_TRUE(createVkColorBuffer(mWidth, mHeight, GL_RGBA, FRAMEWORK_FORMAT_GL_COMPATIBLE,
-                                    kArbitraryColorBufferHandle, true, /* vulkanOnly */
-                                    static_cast<uint32_t>(kTargetMemoryPropertyFlags)));
+    EXPECT_TRUE(vkEmulation.createVkColorBuffer(mWidth, mHeight, GL_RGBA,
+                                                FRAMEWORK_FORMAT_GL_COMPATIBLE,
+                                                kArbitraryColorBufferHandle, true, /* vulkanOnly */
+                                                static_cast<uint32_t>(kTargetMemoryPropertyFlags)));
 
     uint32_t allocatedTypeIndex = 0u;
-    EXPECT_TRUE(getColorBufferAllocationInfo(kArbitraryColorBufferHandle, nullptr,
-                                             &allocatedTypeIndex, nullptr, nullptr));
+    EXPECT_TRUE(vkEmulation.getColorBufferAllocationInfo(kArbitraryColorBufferHandle, nullptr,
+                                                         &allocatedTypeIndex, nullptr, nullptr));
 
-    EXPECT_TRUE(vkEmulation->deviceInfo.memProps.memoryTypes[allocatedTypeIndex]
-                        .propertyFlags &
+    EXPECT_TRUE(memProps.memoryTypes[allocatedTypeIndex].propertyFlags &
                 kTargetMemoryPropertyFlags);
 
-    EXPECT_TRUE(teardownVkColorBuffer(kArbitraryColorBufferHandle));
+    EXPECT_TRUE(vkEmulation.teardownVkColorBuffer(kArbitraryColorBufferHandle));
 }
 
 #endif // !_WIN32
diff --git a/host/tracing/CMakeLists.txt b/host/tracing/CMakeLists.txt
index 62f428442..966814ae7 100644
--- a/host/tracing/CMakeLists.txt
+++ b/host/tracing/CMakeLists.txt
@@ -1,4 +1,4 @@
-if (NOT TARGET gfxstream-gl-host-common)
+if (NOT TARGET gfxstream_host_tracing)
     add_library(
         gfxstream_host_tracing.headers
         INTERFACE)
@@ -14,4 +14,11 @@ if (NOT TARGET gfxstream-gl-host-common)
         gfxstream_host_tracing
         PUBLIC
         gfxstream_host_tracing.headers)
+
+    if(GFXSTREAM_ENABLE_HOST_TRACING)
+        target_link_libraries(
+            gfxstream_host_tracing
+            PUBLIC
+            perfetto)
+    endif()
 endif()
diff --git a/host/tracing/include/gfxstream/host/Tracing.h b/host/tracing/include/gfxstream/host/Tracing.h
index d344a99a7..94cf8f3d6 100644
--- a/host/tracing/include/gfxstream/host/Tracing.h
+++ b/host/tracing/include/gfxstream/host/Tracing.h
@@ -26,7 +26,11 @@
 
 #ifdef GFXSTREAM_BUILD_WITH_TRACING
 
+#ifdef GFXSTREAM_BUILD_WITH_PERFETTO_SDK
+#include <perfetto.h>
+#else
 #include <perfetto/tracing.h>
+#endif
 
 PERFETTO_DEFINE_CATEGORIES(perfetto::Category(GFXSTREAM_TRACE_DEFAULT_CATEGORY)
                                .SetDescription("Default events")
diff --git a/host/virtio-gpu-gfxstream-renderer-goldfish.cpp b/host/virtio-gpu-gfxstream-renderer-goldfish.cpp
index 2009dff30..6ab12ec10 100644
--- a/host/virtio-gpu-gfxstream-renderer-goldfish.cpp
+++ b/host/virtio-gpu-gfxstream-renderer-goldfish.cpp
@@ -27,13 +27,6 @@ VG_EXPORT int stream_renderer_snapshot_postsave_resume() {
     return 0;
 }
 
-// In end2end tests, we don't really do snapshot save for render threads.
-// We will need to resume all render threads without waiting for snapshot.
-VG_EXPORT int stream_renderer_snapshot_postload_resume_for_testing() {
-    android_getOpenglesRenderer()->resumeAll(false);
-    return 0;
-}
-
 VG_EXPORT int stream_renderer_snapshot_save(void* saverStream) {
     auto* saver = static_cast<android::snapshot::SnapshotSaveStream*>(saverStream);
     android_getOpenglesRenderer()->save(saver->stream, saver->textureSaver);
diff --git a/host/virtio-gpu-gfxstream-renderer.cpp b/host/virtio-gpu-gfxstream-renderer.cpp
index 9f105497a..ac938c2a8 100644
--- a/host/virtio-gpu-gfxstream-renderer.cpp
+++ b/host/virtio-gpu-gfxstream-renderer.cpp
@@ -114,7 +114,6 @@ static char translate_severity(uint32_t type) {
 }
 
 using android::AndroidPipe;
-using android::base::ManagedDescriptor;
 using android::base::MetricsLogger;
 using gfxstream::host::VirtioGpuFrontend;
 
@@ -169,7 +168,15 @@ void stream_renderer_log(uint32_t type, const char* file, int line, const char*
         globalDebugCallback(globalUserData, &debug);
     } else {
         // Cannot use logging routines, fallback to stderr
-        fprintf(stderr, "stream_renderer_log error: %s\n", printbuf);
+        const char* logLevel = "error";
+        if (type == STREAM_RENDERER_DEBUG_WARN) {
+            logLevel = "warning";
+        } else if (type == STREAM_RENDERER_DEBUG_INFO) {
+            logLevel = "info";
+        } else if (type == STREAM_RENDERER_DEBUG_DEBUG) {
+            logLevel = "debug";
+        }
+        fprintf(stderr, "stream_renderer_log [%s]: %s\n", logLevel, printbuf);
     }
 }
 
@@ -181,6 +188,15 @@ VG_EXPORT int stream_renderer_resource_create(struct stream_renderer_resource_cr
     return sFrontend()->createResource(args, iov, num_iovs);
 }
 
+VG_EXPORT int stream_renderer_import_resource(
+    uint32_t res_handle, const struct stream_renderer_handle* import_handle,
+    const struct stream_renderer_import_data* import_data) {
+    GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
+                          "stream_renderer_import_resource()");
+
+    return sFrontend()->importResource(res_handle, import_handle, import_data);
+}
+
 VG_EXPORT void stream_renderer_resource_unref(uint32_t res_handle) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_unref()");
@@ -354,14 +370,6 @@ VG_EXPORT int stream_renderer_export_fence(uint64_t fence_id,
     return sFrontend()->exportFence(fence_id, handle);
 }
 
-VG_EXPORT int stream_renderer_platform_import_resource(int res_handle, int res_info,
-                                                       void* resource) {
-    GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                          "stream_renderer_platform_import_resource()");
-
-    return sFrontend()->platformImportResource(res_handle, res_info, resource);
-}
-
 VG_EXPORT void* stream_renderer_platform_create_shared_egl_context() {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_platform_create_shared_egl_context()");
@@ -376,13 +384,6 @@ VG_EXPORT int stream_renderer_platform_destroy_shared_egl_context(void* context)
     return sFrontend()->platformDestroySharedEglContext(context);
 }
 
-VG_EXPORT int stream_renderer_wait_sync_resource(uint32_t res_handle) {
-    GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
-                          "stream_renderer_wait_sync_resource()");
-
-    return sFrontend()->waitSyncResource(res_handle);
-}
-
 VG_EXPORT int stream_renderer_resource_map_info(uint32_t res_handle, uint32_t* map_info) {
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_STREAM_RENDERER_CATEGORY,
                           "stream_renderer_resource_map_info()");
@@ -574,8 +575,6 @@ static int stream_renderer_opengles_init(uint32_t display_width, uint32_t displa
 
     android::featurecontrol::productFeatureOverride();
 
-    gfxstream::vk::vkDispatch(false /* don't use test ICD */);
-
     auto androidHw = aemu_get_android_hw();
 
     androidHw->hw_gltransport_asg_writeBufferSize = 1048576;
@@ -584,9 +583,10 @@ static int stream_renderer_opengles_init(uint32_t display_width, uint32_t displa
     androidHw->hw_gltransport_drawFlushInterval = 10000;
 
     EmuglConfig config;
-
     // Make all the console agents available.
+#ifndef GFXSTREAM_MESON_BUILD
     android::emulation::injectGraphicsAgents(android::emulation::GfxStreamGraphicsAgentFactory());
+#endif
 
     emuglConfig_init(&config, true /* gpu enabled */, "auto",
                      enable_egl2egl ? "swiftshader_indirect" : "host", 64, /* bitness */
@@ -597,6 +597,8 @@ static int stream_renderer_opengles_init(uint32_t display_width, uint32_t displa
 
     emuglConfig_setupEnv(&config);
 
+    gfxstream::vk::vkDispatch(false /* don't use test ICD */);
+
     android_prepareOpenglesEmulation();
 
     {
@@ -727,7 +729,7 @@ int parseGfxstreamFeatures(const int renderer_flags,
         feature_info->enabled = feature_status == "enabled";
         feature_info->reason = "Overridden via STREAM_RENDERER_PARAM_RENDERER_FEATURES";
 
-        stream_renderer_error("Gfxstream feature %s %s", feature_name.c_str(),
+        stream_renderer_info("Gfxstream feature %s %s", feature_name.c_str(),
                               feature_status.c_str());
     }
 
@@ -978,7 +980,7 @@ VG_EXPORT int stream_renderer_init(struct stream_renderer_param* stream_renderer
     if (!skip_opengles) {
         // aemu currently does its own opengles initialization in
         // qemu/android/android-emu/android/opengles.cpp.
-        int ret =
+        ret =
             stream_renderer_opengles_init(display_width, display_height, renderer_flags, features);
         if (ret) {
             return ret;
diff --git a/host/vulkan/Android.bp b/host/vulkan/Android.bp
index a9364228d..513fc84e2 100644
--- a/host/vulkan/Android.bp
+++ b/host/vulkan/Android.bp
@@ -70,8 +70,10 @@ cc_library_static {
         "VkDecoderSnapshot.cpp",
         "VkDecoderSnapshotUtils.cpp",
         "VkEmulatedPhysicalDeviceMemory.cpp",
+        "VkEmulatedPhysicalDeviceQueue.cpp",
         "VkFormatUtils.cpp",
         "VkReconstruction.cpp",
+        "VulkanBoxedHandles.cpp",
         "VulkanDispatch.cpp",
         "VulkanHandleMapping.cpp",
         "VulkanStream.cpp",
@@ -135,3 +137,30 @@ cc_test_host {
         "general-tests",
     ],
 }
+
+// Run with `atest --host gfxstream_vkguestqueueutils_tests`
+cc_test_host {
+    name: "gfxstream_vkemulatedphysicaldevicequeue_tests",
+    defaults: ["gfxstream_defaults"],
+    srcs: [
+        "VkEmulatedPhysicalDeviceQueueTests.cpp",
+    ],
+    shared_libs: [
+        "libbase",
+        "liblog",
+    ],
+    static_libs: [
+        "gfxstream_base",
+        "gfxstream_host_common",
+        "libgfxstream_host_features",
+        "libgfxstream_host_vulkan_server",
+        "libgtest",
+        "libgmock",
+    ],
+    test_options: {
+        unit_test: true,
+    },
+    test_suites: [
+        "general-tests",
+    ],
+}
diff --git a/host/vulkan/BUILD.bazel b/host/vulkan/BUILD.bazel
index dc9de3d73..75b1a6b5b 100644
--- a/host/vulkan/BUILD.bazel
+++ b/host/vulkan/BUILD.bazel
@@ -1,3 +1,5 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
+
 cc_library(
     name = "gfxstream-vulkan-server",
     srcs = [
@@ -20,8 +22,10 @@ cc_library(
         "VkDecoderSnapshot.cpp",
         "VkDecoderSnapshotUtils.cpp",
         "VkEmulatedPhysicalDeviceMemory.cpp",
+        "VkEmulatedPhysicalDeviceQueue.cpp",
         "VkFormatUtils.cpp",
         "VkReconstruction.cpp",
+        "VulkanBoxedHandles.cpp",
         "VulkanDispatch.cpp",
         "VulkanHandleMapping.cpp",
         "VulkanStream.cpp",
@@ -60,18 +64,18 @@ cc_library(
     visibility = ["//visibility:public"],
     deps = [
         # "//external/angle:angle-headers",
-        "//hardware/google/aemu/snapshot:aemu-snapshot",
-        "//hardware/google/gfxstream/common/vulkan:gfxstream_vulkan_headers",
-        "//hardware/google/gfxstream/host:gfxstream-compressedTextures",
-        "//hardware/google/gfxstream/host:gfxstream_host_headers",
-        "//hardware/google/gfxstream/host/apigen-codec-common",
-        "//hardware/google/gfxstream/host/gl:gfxstream-gl-host-common",
-        "//hardware/google/gfxstream/host/gl:gl_headers",
-        "//hardware/google/gfxstream/host/vulkan:OpenglRender_vulkan_cereal",
-        "//hardware/google/gfxstream/host/vulkan:emulated_textures",
-        "//hardware/google/gfxstream/third-party/glm",
-        "//hardware/google/gfxstream/third-party/renderdoc",
-        "//hardware/google/gfxstream/utils:gfxstream_utils",
+        "@aemu//snapshot:aemu-snapshot",
+        "//common/vulkan:gfxstream_vulkan_headers",
+        "//host:gfxstream-compressedTextures",
+        "//host:gfxstream_host_headers",
+        "//host/apigen-codec-common",
+        "//host/gl:gfxstream-gl-host-common",
+        "//host/gl:gl_headers",
+        "//host/vulkan:OpenglRender_vulkan_cereal",
+        "//host/vulkan:emulated_textures",
+        "//third-party/glm",
+        "//third-party/renderdoc",
+        "//utils:gfxstream_utils",
     ],
 )
 
@@ -107,15 +111,15 @@ cc_library(
         "cereal/common",
     ],
     deps = [
-        "//hardware/google/aemu/base:aemu-base-headers",
-        "//hardware/google/aemu/host-common:aemu-host-common-headers",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/common/vulkan:gfxstream_vulkan_headers",
-        "//hardware/google/gfxstream/host:gfxstream_host_headers",
-        "//hardware/google/gfxstream/host/backend:gfxstream_backend",
-        "//hardware/google/gfxstream/host/features:gfxstream_features",
-        "//hardware/google/gfxstream/host/tracing:gfxstream_host_tracing",
-        "//hardware/google/gfxstream/utils:gfxstream_utils",
+        "//:gfxstream-gl-host-common-headers",
+        "//common/vulkan:gfxstream_vulkan_headers",
+        "//host:gfxstream_host_headers",
+        "//host/backend:gfxstream_backend",
+        "//host/features:gfxstream_features",
+        "//host/tracing:gfxstream_host_tracing",
+        "//utils:gfxstream_utils",
+        "@aemu//base:aemu-base-headers",
+        "@aemu//host-common:aemu-host-common-headers",
     ],
 )
 
@@ -148,10 +152,10 @@ cc_library(
         "cereal/common",
     ],
     deps = [
-        "//hardware/google/aemu/host-common:aemu-host-common-headers",
-        "//hardware/google/gfxstream:gfxstream-gl-host-common-headers",
-        "//hardware/google/gfxstream/common/vulkan:gfxstream_vulkan_headers",
-        "//hardware/google/gfxstream/host:gfxstream_host_headers",
-        "//hardware/google/gfxstream/utils:gfxstream_utils",
+        "//:gfxstream-gl-host-common-headers",
+        "//common/vulkan:gfxstream_vulkan_headers",
+        "//host:gfxstream_host_headers",
+        "//utils:gfxstream_utils",
+        "@aemu//host-common:aemu-host-common-headers",
     ],
 )
diff --git a/host/vulkan/BufferVk.cpp b/host/vulkan/BufferVk.cpp
index 234a6294b..9231869a7 100644
--- a/host/vulkan/BufferVk.cpp
+++ b/host/vulkan/BufferVk.cpp
@@ -20,45 +20,52 @@ namespace gfxstream {
 namespace vk {
 
 /*static*/
-std::unique_ptr<BufferVk> BufferVk::create(uint32_t handle, uint64_t size, bool vulkanOnly) {
-    if (!setupVkBuffer(size, handle, vulkanOnly, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)) {
+std::unique_ptr<BufferVk> BufferVk::create(VkEmulation& vkEmulation, uint32_t handle, uint64_t size,
+                                           bool vulkanOnly) {
+    if (!vkEmulation.setupVkBuffer(size, handle, vulkanOnly, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)) {
         ERR("Failed to create BufferVk:%d", handle);
         return nullptr;
     }
 
-    return std::unique_ptr<BufferVk>(new BufferVk(handle));
+    return std::unique_ptr<BufferVk>(new BufferVk(vkEmulation, handle));
 }
 
-BufferVk::BufferVk(uint32_t handle) : mHandle(handle) {}
+BufferVk::BufferVk(VkEmulation& vkEmulation, uint32_t handle)
+    : mVkEmulation(vkEmulation), mHandle(handle) {}
 
 BufferVk::~BufferVk() {
-    if (!teardownVkBuffer(mHandle)) {
+    if (!mVkEmulation.teardownVkBuffer(mHandle)) {
         ERR("Failed to destroy BufferVk:%d", mHandle);
     }
 }
 
 void BufferVk::readToBytes(uint64_t offset, uint64_t size, void* outBytes) {
-    readBufferToBytes(mHandle, offset, size, outBytes);
+    mVkEmulation.readBufferToBytes(mHandle, offset, size, outBytes);
 }
 
 bool BufferVk::updateFromBytes(uint64_t offset, uint64_t size, const void* bytes) {
-    return updateBufferFromBytes(mHandle, offset, size, bytes);
+    return mVkEmulation.updateBufferFromBytes(mHandle, offset, size, bytes);
 }
 
 std::optional<BlobDescriptorInfo> BufferVk::exportBlob() {
-    uint32_t streamHandleType = 0;
-    auto vkHandle = getBufferExtMemoryHandle(mHandle, &streamHandleType);
-    if (vkHandle != VK_EXT_MEMORY_HANDLE_INVALID) {
-        ManagedDescriptor descriptor(dupExternalMemory(vkHandle));
-        return BlobDescriptorInfo{
-            .descriptor = std::move(descriptor),
-            .handleType = streamHandleType,
-            .caching = 0,
-            .vulkanInfoOpt = std::nullopt,
-        };
-    } else {
+    auto dupHandleInfo = mVkEmulation.dupBufferExtMemoryHandle(mHandle);
+    if (!dupHandleInfo) {
         return std::nullopt;
     }
+    return BlobDescriptorInfo{
+        .descriptorInfo =
+            {
+#ifdef _WIN32
+                .descriptor = ManagedDescriptor(
+                    static_cast<DescriptorType>(reinterpret_cast<void*>(dupHandleInfo->handle))),
+#else
+                .descriptor = ManagedDescriptor(static_cast<DescriptorType>(dupHandleInfo->handle)),
+#endif
+                .streamHandleType = dupHandleInfo->streamHandleType,
+            },
+        .caching = 0,
+        .vulkanInfoOpt = std::nullopt,
+    };
 }
 
 }  // namespace vk
diff --git a/host/vulkan/BufferVk.h b/host/vulkan/BufferVk.h
index 231179b2d..34705035a 100644
--- a/host/vulkan/BufferVk.h
+++ b/host/vulkan/BufferVk.h
@@ -20,9 +20,12 @@
 namespace gfxstream {
 namespace vk {
 
+class VkEmulation;
+
 class BufferVk {
    public:
-    static std::unique_ptr<BufferVk> create(uint32_t handle, uint64_t size, bool vulkanOnly);
+    static std::unique_ptr<BufferVk> create(VkEmulation& vkEmulation, uint32_t handle,
+                                            uint64_t size, bool vulkanOnly);
 
     ~BufferVk();
 
@@ -33,7 +36,9 @@ class BufferVk {
     std::optional<BlobDescriptorInfo> exportBlob();
 
    private:
-    BufferVk(uint32_t handle);
+    BufferVk(VkEmulation& vkEmulation, uint32_t handle);
+
+    VkEmulation& mVkEmulation;
 
     const uint32_t mHandle;
 };
diff --git a/host/vulkan/CMakeLists.txt b/host/vulkan/CMakeLists.txt
index a3151b0b2..487dda9a0 100644
--- a/host/vulkan/CMakeLists.txt
+++ b/host/vulkan/CMakeLists.txt
@@ -26,13 +26,17 @@ add_library(gfxstream-vulkan-server
             VkDecoderSnapshot.cpp
             VkDecoderSnapshotUtils.cpp
             VkEmulatedPhysicalDeviceMemory.cpp
+            VkEmulatedPhysicalDeviceQueue.cpp
             VkFormatUtils.cpp
             VkReconstruction.cpp
+            VulkanBoxedHandles.cpp
             VulkanDispatch.cpp
             VulkanHandleMapping.cpp
             VulkanStream.cpp
             vk_util.cpp)
 set_source_files_properties(VkDecoder.cpp PROPERTIES COMPILE_FLAGS -Wno-unused-variable)
+set_source_files_properties(VkSubDecoder.cpp PROPERTIES COMPILE_FLAGS -Wno-unused-variable)
+set_source_files_properties(VkDecoderSnapshot.cpp PROPERTIES COMPILE_FLAGS -Wno-unused-variable)
 
 target_link_libraries(gfxstream-vulkan-server PUBLIC
         OpenglRender_vulkan_cereal
@@ -60,7 +64,17 @@ endif()
 if (NOT MSVC)
     target_compile_options(gfxstream-vulkan-server PRIVATE -fvisibility=hidden)
 endif()
-target_compile_options(gfxstream-vulkan-server PRIVATE -Wno-unused-value -Wno-return-type -Wno-return-type-c-linkage)
+target_compile_options(gfxstream-vulkan-server
+    PRIVATE
+    -Wall
+    -Wextra
+    -Werror
+    -Wno-missing-field-initializers
+    -Wno-unused-parameter
+    -Wno-unused-private-field
+    -Wno-return-type-c-linkage
+    -Wno-extern-c-compat
+    )
 
 target_include_directories(gfxstream-vulkan-server
                            PUBLIC
@@ -70,6 +84,7 @@ target_include_directories(gfxstream-vulkan-server
                            ${GFXSTREAM_REPO_ROOT}
                            ${GFXSTREAM_REPO_ROOT}/include
                            ${GFXSTREAM_REPO_ROOT}/host
+                           ${GFXSTREAM_REPO_ROOT}/host/tracing
                            ${GFXSTREAM_REPO_ROOT}/host/vulkan
                            ${GFXSTREAM_REPO_ROOT}/host/vulkan/cereal/common
                            ${GFXSTREAM_REPO_ROOT}/host/apigen-codec-common
diff --git a/host/vulkan/ColorBufferVk.cpp b/host/vulkan/ColorBufferVk.cpp
index 786d856f1..31b6b772c 100644
--- a/host/vulkan/ColorBufferVk.cpp
+++ b/host/vulkan/ColorBufferVk.cpp
@@ -20,73 +20,80 @@ namespace gfxstream {
 namespace vk {
 
 /*static*/
-std::unique_ptr<ColorBufferVk> ColorBufferVk::create(uint32_t handle, uint32_t width,
-                                                     uint32_t height, GLenum format,
+std::unique_ptr<ColorBufferVk> ColorBufferVk::create(VkEmulation& vkEmulation, uint32_t handle,
+                                                     uint32_t width, uint32_t height, GLenum format,
                                                      FrameworkFormat frameworkFormat,
                                                      bool vulkanOnly, uint32_t memoryProperty,
                                                      android::base::Stream* stream) {
-    if (!createVkColorBuffer(width, height, format, frameworkFormat, handle, vulkanOnly,
-                             memoryProperty)) {
+    if (!vkEmulation.createVkColorBuffer(width, height, format, frameworkFormat, handle, vulkanOnly,
+                                         memoryProperty)) {
         GL_LOG("Failed to create ColorBufferVk:%d", handle);
         return nullptr;
     }
-    if (getGlobalVkEmulation()->features.VulkanSnapshots.enabled && stream) {
+    if (vkEmulation.getFeatures().VulkanSnapshots.enabled && stream) {
         VkImageLayout currentLayout = static_cast<VkImageLayout>(stream->getBe32());
-        setColorBufferCurrentLayout(handle, currentLayout);
+        vkEmulation.setColorBufferCurrentLayout(handle, currentLayout);
     }
-    return std::unique_ptr<ColorBufferVk>(new ColorBufferVk(handle));
+    return std::unique_ptr<ColorBufferVk>(new ColorBufferVk(vkEmulation, handle));
 }
 
 void ColorBufferVk::onSave(android::base::Stream* stream) {
-    if (!getGlobalVkEmulation()->features.VulkanSnapshots.enabled) {
+    if (!mVkEmulation.getFeatures().VulkanSnapshots.enabled) {
         return;
     }
-    stream->putBe32(static_cast<uint32_t>(getColorBufferCurrentLayout(mHandle)));
+    stream->putBe32(static_cast<uint32_t>(mVkEmulation.getColorBufferCurrentLayout(mHandle)));
 }
 
-ColorBufferVk::ColorBufferVk(uint32_t handle) : mHandle(handle) {}
+ColorBufferVk::ColorBufferVk(VkEmulation& vkEmulation, uint32_t handle)
+    : mVkEmulation(vkEmulation), mHandle(handle) {}
 
 ColorBufferVk::~ColorBufferVk() {
-    if (!teardownVkColorBuffer(mHandle)) {
+    if (!mVkEmulation.teardownVkColorBuffer(mHandle)) {
         ERR("Failed to destroy ColorBufferVk:%d", mHandle);
     }
 }
 
 bool ColorBufferVk::readToBytes(std::vector<uint8_t>* outBytes) {
-    return readColorBufferToBytes(mHandle, outBytes);
+    return mVkEmulation.readColorBufferToBytes(mHandle, outBytes);
 }
 
 bool ColorBufferVk::readToBytes(uint32_t x, uint32_t y, uint32_t w, uint32_t h, void* outBytes,
                                 uint64_t outBytesSize) {
-    return readColorBufferToBytes(mHandle, x, y, w, h, outBytes, outBytesSize);
+    return mVkEmulation.readColorBufferToBytes(mHandle, x, y, w, h, outBytes, outBytesSize);
 }
 
 bool ColorBufferVk::updateFromBytes(const std::vector<uint8_t>& bytes) {
-    return updateColorBufferFromBytes(mHandle, bytes);
+    return mVkEmulation.updateColorBufferFromBytes(mHandle, bytes);
 }
 
 bool ColorBufferVk::updateFromBytes(uint32_t x, uint32_t y, uint32_t w, uint32_t h,
                                     const void* bytes) {
-    return updateColorBufferFromBytes(mHandle, x, y, w, h, bytes);
+    return mVkEmulation.updateColorBufferFromBytes(mHandle, x, y, w, h, bytes);
 }
 
-bool ColorBufferVk::importExtMemoryHandle(void* nativeResource, uint32_t type,
-                                          bool preserveContent) {
-    // TODO: Any need to support preserveContent?
-    assert(!preserveContent);
-    VK_EXT_MEMORY_HANDLE extMemoryHandle =
-        *reinterpret_cast<VK_EXT_MEMORY_HANDLE*>(&nativeResource);
-    return importExtMemoryHandleToVkColorBuffer(mHandle, type, extMemoryHandle);
+std::unique_ptr<BorrowedImageInfo> ColorBufferVk::borrowForComposition(bool colorBufferIsTarget) {
+    return mVkEmulation.borrowColorBufferForComposition(mHandle, colorBufferIsTarget);
 }
 
-int ColorBufferVk::waitSync() { return waitSyncVkColorBuffer(mHandle); }
+std::unique_ptr<BorrowedImageInfo> ColorBufferVk::borrowForDisplay() {
+    return mVkEmulation.borrowColorBufferForDisplay(mHandle);
+}
 
 std::optional<BlobDescriptorInfo> ColorBufferVk::exportBlob() {
-    auto info = exportColorBufferMemory(mHandle);
+    auto info = mVkEmulation.exportColorBufferMemory(mHandle);
     if (info) {
         return BlobDescriptorInfo{
-            .descriptor = std::move((*info).descriptor),
-            .handleType = (*info).streamHandleType,
+            .descriptorInfo =
+                {
+#ifdef _WIN32
+                    .descriptor = ManagedDescriptor(static_cast<DescriptorType>(
+                        reinterpret_cast<void*>(info->handleInfo.handle))),
+#else
+                    .descriptor =
+                        ManagedDescriptor(static_cast<DescriptorType>(info->handleInfo.handle)),
+#endif
+                    .streamHandleType = info->handleInfo.streamHandleType,
+                },
             .caching = 0,
             .vulkanInfoOpt = std::nullopt,
         };
diff --git a/host/vulkan/ColorBufferVk.h b/host/vulkan/ColorBufferVk.h
index a54e785b3..253ec5ff1 100644
--- a/host/vulkan/ColorBufferVk.h
+++ b/host/vulkan/ColorBufferVk.h
@@ -17,6 +17,7 @@
 #include <memory>
 #include <vector>
 
+#include "BorrowedImage.h"
 #include "ExternalObjectManager.h"
 #include "FrameworkFormats.h"
 #include "aemu/base/files/Stream.h"
@@ -24,11 +25,14 @@
 namespace gfxstream {
 namespace vk {
 
+class VkEmulation;
+
 class ColorBufferVk {
    public:
-    static std::unique_ptr<ColorBufferVk> create(uint32_t handle, uint32_t width, uint32_t height,
-                                                 GLenum format, FrameworkFormat frameworkFormat,
-                                                 bool vulkanOnly, uint32_t memoryProperty,
+    static std::unique_ptr<ColorBufferVk> create(VkEmulation& emulationVk, uint32_t handle,
+                                                 uint32_t width, uint32_t height, GLenum format,
+                                                 FrameworkFormat frameworkFormat, bool vulkanOnly,
+                                                 uint32_t memoryProperty,
                                                  android::base::Stream* stream = nullptr);
 
     ~ColorBufferVk();
@@ -40,15 +44,17 @@ class ColorBufferVk {
     bool updateFromBytes(const std::vector<uint8_t>& bytes);
     bool updateFromBytes(uint32_t x, uint32_t y, uint32_t w, uint32_t h, const void* bytes);
 
-    bool importExtMemoryHandle(void* nativeResource, uint32_t type, bool preserveContent);
+    std::unique_ptr<BorrowedImageInfo> borrowForComposition(bool colorBufferIsTarget);
+    std::unique_ptr<BorrowedImageInfo> borrowForDisplay();
 
     void onSave(android::base::Stream* stream);
 
-    int waitSync();
     std::optional<BlobDescriptorInfo> exportBlob();
 
    private:
-    ColorBufferVk(uint32_t handle);
+    ColorBufferVk(VkEmulation& emulationVk, uint32_t handle);
+
+    VkEmulation& mVkEmulation;
 
     const uint32_t mHandle;
 };
diff --git a/host/vulkan/CompositorVk.cpp b/host/vulkan/CompositorVk.cpp
index 27865f994..7617622fa 100644
--- a/host/vulkan/CompositorVk.cpp
+++ b/host/vulkan/CompositorVk.cpp
@@ -108,7 +108,8 @@ CompositorVk::RenderTarget::RenderTarget(const VulkanDispatch& vk, VkDevice vkDe
       m_height(height) {
     if (vkImageView == VK_NULL_HANDLE) {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-            << "CompositorVk found empty image view handle when creating RenderTarget.";
+            << "CompositorVk found empty image view handle when creating RenderTarget. Image: "
+            << m_vkImage << " Dimensions: " << m_width << "x" << m_height;
     }
 
     const VkFramebufferCreateInfo framebufferCi = {
@@ -1319,6 +1320,7 @@ CompositorVk::CompositionFinishedWaitable CompositorVk::compose(
     std::shared_future<PerFrameResources*> composeCompleteFutureForResources =
         std::async(std::launch::deferred, [composeCompleteFence, frameResources, traceId,
                                            this]() mutable {
+            (void)traceId;
             GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DEFAULT_CATEGORY, "Wait for compose fence",
                                   GFXSTREAM_TRACE_FLOW(traceId));
 
diff --git a/host/vulkan/DeviceLostHelper.cpp b/host/vulkan/DeviceLostHelper.cpp
index ed6f989a5..9b982da09 100644
--- a/host/vulkan/DeviceLostHelper.cpp
+++ b/host/vulkan/DeviceLostHelper.cpp
@@ -14,6 +14,10 @@
 
 #include "DeviceLostHelper.h"
 
+#include <algorithm>
+#include <iterator>
+#include <set>
+
 #include "host-common/logging.h"
 
 namespace gfxstream {
@@ -51,6 +55,24 @@ void DeviceLostHelper::addNeededDeviceExtensions(std::vector<const char*>* devic
     }
 }
 
+void DeviceLostHelper::onDeviceCreated(const DeviceWithQueues& deviceInfo) {
+    if (!mEnabled) {
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock(mDevicesMutex);
+    mDevices[deviceInfo.device] = deviceInfo;
+}
+
+void DeviceLostHelper::onDeviceDestroyed(VkDevice device) {
+    if (!mEnabled) {
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock(mDevicesMutex);
+    mDevices.erase(device);
+}
+
 void DeviceLostHelper::onBeginCommandBuffer(const VkCommandBuffer& commandBuffer,
                                             const VulkanDispatch* vk) {
     if (!mEnabled) {
@@ -87,15 +109,16 @@ void DeviceLostHelper::onFreeCommandBuffer(const VkCommandBuffer& commandBuffer)
     removeMarkersForCommandBuffer(commandBuffer);
 }
 
-void DeviceLostHelper::onDeviceLost(const std::vector<DeviceWithQueues>& devicesWithQueues) {
+void DeviceLostHelper::onDeviceLost() {
     if (!mEnabled) {
         return;
     }
 
     ERR("DeviceLostHelper starting lost device checks...");
 
-    for (const DeviceWithQueues& deviceWithQueues : devicesWithQueues) {
-        const auto& device = deviceWithQueues.device;
+    std::lock_guard<std::mutex> deviceLock(mDevicesMutex);
+
+    for (const auto& [device, deviceWithQueues] : mDevices) {
         const auto* deviceDispatch = deviceWithQueues.deviceDispatch;
         if (deviceDispatch->vkDeviceWaitIdle(device) != VK_ERROR_DEVICE_LOST) {
             continue;
@@ -108,32 +131,47 @@ void DeviceLostHelper::onDeviceLost(const std::vector<DeviceWithQueues>& devices
         };
         std::vector<CommandBufferOnQueue> unfinishedCommandBuffers;
 
-        for (const VkQueue& queue : deviceWithQueues.queues) {
-            std::vector<VkCheckpointDataNV> checkpointDatas;
+        for (const QueueWithMutex& queueInfo : deviceWithQueues.queues) {
+            VkQueue queue = queueInfo.queue;
 
-            uint32_t checkpointDataCount = 0;
-            deviceDispatch->vkGetQueueCheckpointDataNV(queue, &checkpointDataCount, nullptr);
-            if (checkpointDataCount == 0) continue;
+            std::vector<VkCheckpointDataNV> checkpointDatas;
+            {
+                std::lock_guard<std::mutex> queueLock(*queueInfo.queueMutex);
+
+                uint32_t checkpointDataCount = 0;
+                deviceDispatch->vkGetQueueCheckpointDataNV(queue, &checkpointDataCount, nullptr);
+                if (checkpointDataCount == 0) continue;
+
+                checkpointDatas.resize(static_cast<size_t>(checkpointDataCount),
+                                       VkCheckpointDataNV{
+                                           .sType = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
+                                       });
+                deviceDispatch->vkGetQueueCheckpointDataNV(queue, &checkpointDataCount,
+                                                           checkpointDatas.data());
+            }
 
-            checkpointDatas.resize(
-                static_cast<size_t>(checkpointDataCount),
-                VkCheckpointDataNV{
-                    .sType = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
-                });
-            deviceDispatch->vkGetQueueCheckpointDataNV(queue, &checkpointDataCount,
-                                                       checkpointDatas.data());
+            std::set<VkCommandBuffer> startedCommandBuffers;
+            std::set<VkCommandBuffer> finishedCommandBuffers;
 
-            std::unordered_set<VkCommandBuffer> unfinishedCommandBuffersForQueue;
             for (const VkCheckpointDataNV& checkpointData : checkpointDatas) {
                 const auto& marker =
                     *reinterpret_cast<const CheckpointMarker*>(checkpointData.pCheckpointMarker);
                 if (marker.type == MarkerType::kBegin) {
-                    unfinishedCommandBuffersForQueue.insert(marker.commandBuffer);
+                    startedCommandBuffers.insert(marker.commandBuffer);
                 } else {
-                    unfinishedCommandBuffersForQueue.erase(marker.commandBuffer);
+                    finishedCommandBuffers.erase(marker.commandBuffer);
                 }
             }
 
+            std::set<VkCommandBuffer> unfinishedCommandBuffersForQueue;
+
+            std::set_difference(startedCommandBuffers.begin(),                   //
+                                startedCommandBuffers.end(),                     //
+                                finishedCommandBuffers.begin(),                  //
+                                finishedCommandBuffers.end(),                    //
+                                std::inserter(unfinishedCommandBuffersForQueue,  //
+                                              unfinishedCommandBuffersForQueue.end()));
+
             for (const VkCommandBuffer commandBuffer : unfinishedCommandBuffersForQueue) {
                 unfinishedCommandBuffers.push_back(CommandBufferOnQueue{
                     .commandBuffer = commandBuffer,
diff --git a/host/vulkan/DeviceLostHelper.h b/host/vulkan/DeviceLostHelper.h
index 5b07eb20c..9293e5e51 100644
--- a/host/vulkan/DeviceLostHelper.h
+++ b/host/vulkan/DeviceLostHelper.h
@@ -18,9 +18,11 @@
 
 #include <memory>
 #include <mutex>
-#include <vector>
+#include <unordered_map>
 #include <unordered_set>
+#include <vector>
 
+#include "aemu/base/ThreadAnnotations.h"
 #include "vulkan/cereal/common/goldfish_vk_dispatch.h"
 
 namespace gfxstream {
@@ -41,18 +43,25 @@ class DeviceLostHelper {
 
     void addNeededDeviceExtensions(std::vector<const char*>* deviceExtensions);
 
+    struct QueueWithMutex {
+        VkQueue queue = VK_NULL_HANDLE;
+        std::shared_ptr<std::mutex> queueMutex;
+    };
+    struct DeviceWithQueues {
+        VkDevice device = VK_NULL_HANDLE;
+        const VulkanDispatch* deviceDispatch = nullptr;
+        std::vector<QueueWithMutex> queues;
+    };
+    void onDeviceCreated(const DeviceWithQueues& deviceInfo);
+    void onDeviceDestroyed(VkDevice device);
+
     void onBeginCommandBuffer(const VkCommandBuffer& commandBuffer, const VulkanDispatch* vk);
     void onEndCommandBuffer(const VkCommandBuffer& commandBuffer, const VulkanDispatch* vk);
 
     void onResetCommandBuffer(const VkCommandBuffer& commandBuffer);
     void onFreeCommandBuffer(const VkCommandBuffer& commandBuffer);
 
-    struct DeviceWithQueues {
-        VkDevice device;
-        const VulkanDispatch* deviceDispatch;
-        std::vector<VkQueue> queues;
-    };
-    void onDeviceLost(const std::vector<DeviceWithQueues>& devicesWithQueues);
+    void onDeviceLost();
 
    private:
     enum class MarkerType { kBegin, kEnd };
@@ -82,7 +91,11 @@ class DeviceLostHelper {
     bool mEnabled = false;
 
     std::mutex mMarkersMutex;
-    std::unordered_set<CheckpointMarker, CheckpointMarkerHash, CheckpointMarkerEq> mMarkers;
+    std::unordered_set<CheckpointMarker, CheckpointMarkerHash, CheckpointMarkerEq> mMarkers
+        GUARDED_BY(mMarkersMutex);
+
+    std::mutex mDevicesMutex;
+    std::unordered_map<VkDevice, DeviceWithQueues> mDevices GUARDED_BY(mDevicesMutex);
 };
 
 }  // namespace vk
diff --git a/host/vulkan/DeviceOpTracker.cpp b/host/vulkan/DeviceOpTracker.cpp
index 1f376994e..3447be4b9 100644
--- a/host/vulkan/DeviceOpTracker.cpp
+++ b/host/vulkan/DeviceOpTracker.cpp
@@ -27,7 +27,7 @@ namespace {
 using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 
-constexpr const size_t kSizeLoggingThreshold = 20;
+constexpr const size_t kSizeLoggingThreshold = 200;
 constexpr const auto kSizeLoggingTimeThreshold = std::chrono::seconds(1);
 
 constexpr const auto kAutoDeleteTimeThreshold = std::chrono::seconds(5);
@@ -68,8 +68,8 @@ void DeviceOpTracker::AddPendingGarbage(DeviceOpWaitable waitable, VkSemaphore s
     }
 }
 
-void DeviceOpTracker::Poll() {
-    std::lock_guard<std::mutex> lock(mPollFunctionsMutex);
+void DeviceOpTracker::PollAndProcessGarbage() {
+    std::lock_guard<std::mutex> pollFunctionsLock(mPollFunctionsMutex);
     mPollFunctions.erase(std::remove_if(mPollFunctions.begin(), mPollFunctions.end(),
                                         [](const PollFunction& pollingFunc) {
                                             DeviceOpStatus status = pollingFunc.func();
@@ -82,25 +82,22 @@ void DeviceOpTracker::Poll() {
         // when many requests have been done in a small amount of time.
         const auto now = std::chrono::system_clock::now();
         const auto old = now - kSizeLoggingTimeThreshold;
-        int numOldFuncs = std::count_if(
+        size_t numOldFuncs = std::count_if(
             mPollFunctions.begin(), mPollFunctions.end(), [old](const PollFunction& pollingFunc) {
                 return (pollingFunc.timepoint < old);
             });
         if (numOldFuncs > kSizeLoggingThreshold) {
-            WARN("VkDevice:%p has %d pending waitables, %d taking more than %d milliseconds.",
+            //TODO(b/382028853): should be a warning
+            VERBOSE("VkDevice:%p has %d pending waitables, %d taking more than %d milliseconds.",
                  mDevice, mPollFunctions.size(), numOldFuncs,
                  std::chrono::duration_cast<std::chrono::milliseconds>(kSizeLoggingTimeThreshold));
         }
     }
-}
-
-void DeviceOpTracker::PollAndProcessGarbage() {
-    Poll();
 
     const auto now = std::chrono::system_clock::now();
     const auto old = now - kAutoDeleteTimeThreshold;
     {
-        std::lock_guard<std::mutex> lock(mPendingGarbageMutex);
+        std::lock_guard<std::mutex> pendingGarbageLock(mPendingGarbageMutex);
 
         // Assuming that pending garbage is added to the queue in the roughly the order
         // they are used, encountering an unsignaled/pending waitable likely means that
diff --git a/host/vulkan/DeviceOpTracker.h b/host/vulkan/DeviceOpTracker.h
index eb91c66f5..4ff412978 100644
--- a/host/vulkan/DeviceOpTracker.h
+++ b/host/vulkan/DeviceOpTracker.h
@@ -25,6 +25,7 @@
 #include <variant>
 
 #include "VulkanDispatch.h"
+#include "aemu/base/ThreadAnnotations.h"
 
 namespace gfxstream {
 namespace vk {
@@ -59,11 +60,8 @@ class DeviceOpTracker {
     // semaphore can be destroyed once the waitable has finished.
     void AddPendingGarbage(DeviceOpWaitable waitable, VkSemaphore semaphore);
 
-    // Checks for completion of previously submitted waitables and sets their state accordingly .
-    // This function is thread-safe
-    void Poll();
-
-    // Calls Poll(), and also destroys dependent objects accordingly
+    // Checks for completion of previously submitted waitables and destroys dependent
+    // objects.
     void PollAndProcessGarbage();
 
     void OnDestroyDevice();
@@ -82,7 +80,7 @@ class DeviceOpTracker {
         std::chrono::time_point<std::chrono::system_clock> timepoint;
     };
     std::mutex mPollFunctionsMutex;
-    std::deque<PollFunction> mPollFunctions;
+    std::deque<PollFunction> mPollFunctions GUARDED_BY(mPollFunctionsMutex);
 
     struct PendingGarbage {
         DeviceOpWaitable waitable;
@@ -90,7 +88,7 @@ class DeviceOpTracker {
         std::chrono::time_point<std::chrono::system_clock> timepoint;
     };
     std::mutex mPendingGarbageMutex;
-    std::deque<PendingGarbage> mPendingGarbage;
+    std::deque<PendingGarbage> mPendingGarbage GUARDED_BY(mPendingGarbageMutex);
 };
 
 class DeviceOpBuilder {
diff --git a/host/vulkan/DisplayVk.cpp b/host/vulkan/DisplayVk.cpp
index 1f98a55ea..21b1965df 100644
--- a/host/vulkan/DisplayVk.cpp
+++ b/host/vulkan/DisplayVk.cpp
@@ -153,7 +153,7 @@ bool DisplayVk::recreateSwapchain() {
     int numSwapChainImages = m_swapChainStateVk->getVkImages().size();
 
     m_postResourceFutures.resize(numSwapChainImages, std::nullopt);
-    for (uint32_t i = 0; i < numSwapChainImages + 1; ++i) {
+    for (int i = 0; i < numSwapChainImages + 1; ++i) {
         m_freePostResources.emplace_back(PostResource::create(m_vk, m_vkDevice, m_vkCommandPool));
     }
 
diff --git a/host/vulkan/SwapChainStateVk.cpp b/host/vulkan/SwapChainStateVk.cpp
index 405c5c387..68ea8e85a 100644
--- a/host/vulkan/SwapChainStateVk.cpp
+++ b/host/vulkan/SwapChainStateVk.cpp
@@ -95,7 +95,7 @@ VkResult SwapChainStateVk::initSwapChainStateVk(const VkSwapchainCreateInfoKHR&
     m_vkImages.resize(imageCount);
     VK_CHECK(
         m_vk.vkGetSwapchainImagesKHR(m_vkDevice, m_vkSwapChain, &imageCount, m_vkImages.data()));
-    for (auto i = 0; i < m_vkImages.size(); i++) {
+    for (size_t i = 0; i < m_vkImages.size(); i++) {
         VkImageViewCreateInfo imageViewCi = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
             .image = m_vkImages[i],
diff --git a/host/vulkan/TrivialStream.h b/host/vulkan/TrivialStream.h
new file mode 100644
index 000000000..47f5c6012
--- /dev/null
+++ b/host/vulkan/TrivialStream.h
@@ -0,0 +1,68 @@
+// Copyright 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expresso or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <cstdlib>
+
+#include "render-utils/IOStream.h"
+
+namespace gfxstream {
+namespace vk {
+
+class TrivialStream : public IOStream {
+   public:
+    TrivialStream() : IOStream(4) {}
+    virtual ~TrivialStream() = default;
+
+    void* allocBuffer(size_t minSize) {
+        size_t allocSize = (m_bufsize < minSize ? minSize : m_bufsize);
+        if (!m_buf) {
+            m_buf = (unsigned char*)malloc(allocSize);
+        } else if (m_bufsize < allocSize) {
+            unsigned char* p = (unsigned char*)realloc(m_buf, allocSize);
+            if (p != NULL) {
+                m_buf = p;
+                m_bufsize = allocSize;
+            } else {
+                ERR("realloc (%zu) failed", allocSize);
+                free(m_buf);
+                m_buf = NULL;
+                m_bufsize = 0;
+            }
+        }
+
+        return m_buf;
+    }
+
+    int commitBuffer(size_t size) {
+        if (size == 0) return 0;
+        return writeFully(m_buf, size);
+    }
+
+    int writeFully(const void* buf, size_t len) { return 0; }
+
+    const unsigned char* readFully(void* buf, size_t len) { return NULL; }
+
+    virtual void* getDmaForReading(uint64_t guest_paddr) { return nullptr; }
+    virtual void unlockDma(uint64_t guest_paddr) {}
+
+   protected:
+    virtual const unsigned char* readRaw(void* buf, size_t* inout_len) { return nullptr; }
+    virtual void onSave(android::base::Stream* stream) {}
+    virtual unsigned char* onLoad(android::base::Stream* stream) { return nullptr; }
+};
+
+}  // namespace vk
+}  // namespace gfxstream
diff --git a/host/vulkan/VkAndroidNativeBuffer.cpp b/host/vulkan/VkAndroidNativeBuffer.cpp
index 05de21d07..54d53c4e1 100644
--- a/host/vulkan/VkAndroidNativeBuffer.cpp
+++ b/host/vulkan/VkAndroidNativeBuffer.cpp
@@ -32,7 +32,7 @@
 namespace gfxstream {
 namespace vk {
 
-#define VK_ANB_ERR(fmt, ...) INFO(fmt, ##__VA_ARGS__);
+#define VK_ANB_ERR(fmt, ...) ERR(fmt, ##__VA_ARGS__);
 
 #define ENABLE_VK_ANB_DEBUG 0
 
@@ -46,8 +46,6 @@ namespace vk {
 #define VK_ANB_DEBUG_OBJ(obj, fmt, ...)
 #endif
 
-using android::base::AutoLock;
-using android::base::Lock;
 using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 
@@ -56,7 +54,7 @@ AndroidNativeBufferInfo::QsriWaitFencePool::QsriWaitFencePool(VulkanDispatch* vk
 
 VkFence AndroidNativeBufferInfo::QsriWaitFencePool::getFenceFromPool() {
     VK_ANB_DEBUG("enter");
-    AutoLock lock(mLock);
+    std::lock_guard<std::mutex> lock(mMutex);
     VkFence fence = VK_NULL_HANDLE;
     if (mAvailableFences.empty()) {
         VkFenceCreateInfo fenceCreateInfo = {
@@ -96,7 +94,7 @@ AndroidNativeBufferInfo::QsriWaitFencePool::~QsriWaitFencePool() {
 }
 
 void AndroidNativeBufferInfo::QsriWaitFencePool::returnFence(VkFence fence) {
-    AutoLock lock(mLock);
+    std::lock_guard<std::mutex> lock(mMutex);
     if (!mUsedFences.erase(fence)) {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
             << "Return an unmanaged Qsri VkFence back to the pool.";
@@ -116,51 +114,51 @@ bool parseAndroidNativeBufferInfo(const VkImageCreateInfo* pCreateInfo,
     return structType == VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID;
 }
 
-VkResult prepareAndroidNativeBufferImage(VulkanDispatch* vk, VkDevice device,
-                                         android::base::BumpPool& allocator,
-                                         const VkImageCreateInfo* pCreateInfo,
-                                         const VkNativeBufferANDROID* nativeBufferANDROID,
-                                         const VkAllocationCallbacks* pAllocator,
-                                         const VkPhysicalDeviceMemoryProperties* memProps,
-                                         AndroidNativeBufferInfo* out) {
+/*static*/
+std::unique_ptr<AndroidNativeBufferInfo> AndroidNativeBufferInfo::create(
+    VkEmulation* emu,
+    VulkanDispatch* vk, VkDevice device, android::base::BumpPool& allocator,
+    const VkImageCreateInfo* pCreateInfo, const VkNativeBufferANDROID* nativeBufferANDROID,
+    const VkAllocationCallbacks* pAllocator, const VkPhysicalDeviceMemoryProperties* memProps) {
     bool colorBufferExportedToGl = false;
     bool externalMemoryCompatible = false;
 
-    out->vk = vk;
-    out->device = device;
-    out->vkFormat = pCreateInfo->format;
-    out->extent = pCreateInfo->extent;
-    out->usage = pCreateInfo->usage;
+    std::unique_ptr<AndroidNativeBufferInfo> out(new AndroidNativeBufferInfo());
+
+    out->mDeviceDispatch = vk;
+    out->mDevice = device;
+    out->mVkFormat = pCreateInfo->format;
+    out->mExtent = pCreateInfo->extent;
+    out->mUsage = pCreateInfo->usage;
 
     for (uint32_t i = 0; i < pCreateInfo->queueFamilyIndexCount; ++i) {
-        out->queueFamilyIndices.push_back(pCreateInfo->pQueueFamilyIndices[i]);
+        out->mQueueFamilyIndices.push_back(pCreateInfo->pQueueFamilyIndices[i]);
     }
 
-    out->format = nativeBufferANDROID->format;
-    out->stride = nativeBufferANDROID->stride;
-    out->colorBufferHandle = *static_cast<const uint32_t*>(nativeBufferANDROID->handle);
-
-    auto emu = getGlobalVkEmulation();
+    out->mAhbFormat = nativeBufferANDROID->format;
+    out->mStride = nativeBufferANDROID->stride;
+    out->mColorBufferHandle = *static_cast<const uint32_t*>(nativeBufferANDROID->handle);
 
-    if (!getColorBufferShareInfo(out->colorBufferHandle, &colorBufferExportedToGl,
-                                 &externalMemoryCompatible)) {
-        VK_ANB_ERR("Failed to query if ColorBuffer:%d exported to GL.", out->colorBufferHandle);
-        return VK_ERROR_INITIALIZATION_FAILED;
+    if (!emu->getColorBufferShareInfo(out->mColorBufferHandle, &colorBufferExportedToGl,
+                                      &externalMemoryCompatible)) {
+        VK_ANB_ERR("Failed to query if ColorBuffer:%d exported to GL.", out->mColorBufferHandle);
+        return nullptr;
     }
 
     if (externalMemoryCompatible) {
-        releaseColorBufferForGuestUse(out->colorBufferHandle);
-        out->externallyBacked = true;
+        emu->releaseColorBufferForGuestUse(out->mColorBufferHandle);
+        out->mExternallyBacked = true;
     }
 
-    out->useVulkanNativeImage =
-        (emu && emu->live && emu->guestVulkanOnly) || colorBufferExportedToGl;
+    out->mUseVulkanNativeImage =
+        (emu && emu->isGuestVulkanOnly()) || colorBufferExportedToGl;
 
     VkDeviceSize bindOffset = 0;
-    if (out->externallyBacked) {
+    if (out->mExternallyBacked) {
         VkImageCreateInfo createImageCi;
         deepcopy_VkImageCreateInfo(&allocator, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo,
                                    &createImageCi);
+
         auto* nativeBufferAndroid = vk_find_struct<VkNativeBufferANDROID>(&createImageCi);
         if (!nativeBufferAndroid) {
             GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
@@ -169,7 +167,48 @@ VkResult prepareAndroidNativeBufferImage(VulkanDispatch* vk, VkDevice device,
         }
         vk_struct_chain_remove(nativeBufferAndroid, &createImageCi);
 
-        // VkBindImageMemorySwapchainInfoKHR should also not be passed to image creation
+        const uint32_t importedColorBufferHandle =
+            *static_cast<const uint32_t*>(nativeBufferANDROID->handle);
+        if (importedColorBufferHandle == 0) {
+            VK_ANB_ERR(
+                "Failed to prepare ANB image: attempted to import a non-existent ColorBuffer.");
+            return nullptr;
+        }
+        const auto importedColorBufferInfoOpt = emu->getColorBufferInfo(importedColorBufferHandle);
+        if (!importedColorBufferInfoOpt) {
+            VK_ANB_ERR("Failed to prepare ANB image: ColorBuffer:%d info not found.",
+                       importedColorBufferHandle);
+            return nullptr;
+        }
+        const auto& importedColorBufferInfo = *importedColorBufferInfoOpt;
+        if (pCreateInfo == nullptr) {
+            VK_ANB_ERR("Failed to prepare ANB image: invalid pCreateInfo.");
+            return nullptr;
+        }
+        if (pCreateInfo->extent.width > importedColorBufferInfo.width) {
+            VK_ANB_ERR(
+                "Failed to prepare ANB image: attempted to create a VkImage with width:%d by "
+                "importing ColorBuffer:%d which only has width:%d",
+                pCreateInfo->extent.width, importedColorBufferHandle,
+                importedColorBufferInfo.width);
+            return nullptr;
+        }
+        if (pCreateInfo->extent.height > importedColorBufferInfo.height) {
+            VK_ANB_ERR(
+                "Failed to prepare ANB image: attempted to create a VkImage with height:%d by "
+                "importing ColorBuffer:%d which only has height:%d",
+                pCreateInfo->extent.height, importedColorBufferHandle,
+                importedColorBufferInfo.height);
+            return nullptr;
+        }
+
+        // Update create flags to match the color buffer imported
+        createImageCi.flags = importedColorBufferInfo.imageCreateInfoShallow.flags;
+
+        const auto& importedColorBufferMemoryInfo = importedColorBufferInfo.memory;
+
+        // VkBindImageMemorySwapchainInfoKHR may be included from the guest but
+        // should not be passed to the host driver.
         auto* bindSwapchainInfo = vk_find_struct<VkBindImageMemorySwapchainInfoKHR>(&createImageCi);
         vk_struct_chain_remove(bindSwapchainInfo, &createImageCi);
 
@@ -177,68 +216,85 @@ VkResult prepareAndroidNativeBufferImage(VulkanDispatch* vk, VkDevice device,
             GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
                 << "Unhandled VkExternalMemoryImageCreateInfo in the pNext chain.";
         }
+
         // Create the image with extension structure about external backing.
         VkExternalMemoryImageCreateInfo extImageCi = {
             VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
             0,
-            VK_EXT_MEMORY_HANDLE_TYPE_BIT,
+            static_cast<VkExternalMemoryHandleTypeFlags>(emu->getDefaultExternalMemoryHandleType()),
         };
-
 #if defined(__APPLE__)
-        if (emu->instanceSupportsMoltenVK) {
+        if (emu->supportsMoltenVk()) {
             // Change handle type requested to metal handle
             extImageCi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
         }
 #endif
-
         vk_insert_struct(createImageCi, extImageCi);
 
-        VkResult createResult = vk->vkCreateImage(device, &createImageCi, pAllocator, &out->image);
+        VkResult createResult =
+            vk->vkCreateImage(out->mDevice, &createImageCi, pAllocator, &out->mImage);
+        if (createResult != VK_SUCCESS) {
+            return nullptr;
+        }
 
-        if (createResult != VK_SUCCESS) return createResult;
+        vk->vkGetImageMemoryRequirements(out->mDevice, out->mImage, &out->mImageMemoryRequirements);
 
-        // Now import the backing memory.
-        const auto& cbInfo = getColorBufferInfo(out->colorBufferHandle);
-        const auto& memInfo = cbInfo.memory;
+        if (out->mImageMemoryRequirements.size > importedColorBufferMemoryInfo.size) {
+            VK_ANB_ERR(
+                "Failed to prepare ANB image: attempted to import memory that is not large enough "
+                "for the VkImage: image memory requirements size:%llu vs actual memory size:%llu, "
+                "CB: %u, %s, %ux%u",
+                out->mImageMemoryRequirements.size, importedColorBufferMemoryInfo.size,
+                importedColorBufferHandle, string_VkFormat(createImageCi.format),
+                createImageCi.extent.width, createImageCi.extent.height);
+
+            return nullptr;
+        }
 
-        vk->vkGetImageMemoryRequirements(device, out->image, &out->memReqs);
+        if (out->mImageMemoryRequirements.size < importedColorBufferMemoryInfo.size) {
+            out->mImageMemoryRequirements.size = importedColorBufferMemoryInfo.size;
+        }
 
-        if (out->memReqs.size < memInfo.size) {
-            out->memReqs.size = memInfo.size;
+        VkMemoryDedicatedAllocateInfo dedicatedInfo = {
+            VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
+            nullptr,
+            VK_NULL_HANDLE,
+            VK_NULL_HANDLE,
+        };
+        VkMemoryDedicatedAllocateInfo* dedicatedInfoPtr = nullptr;
+        if (importedColorBufferMemoryInfo.dedicatedAllocation) {
+            dedicatedInfo.image = out->mImage;
+            dedicatedInfoPtr = &dedicatedInfo;
         }
 
-        if (memInfo.dedicatedAllocation) {
-            if (!importExternalMemoryDedicatedImage(vk, device, &memInfo, out->image,
-                                                    &out->imageMemory)) {
-                VK_ANB_ERR(
-                    "VK_ANDROID_native_buffer: Failed to import external memory (dedicated)");
-                return VK_ERROR_INITIALIZATION_FAILED;
-            }
-        } else {
-            if (!importExternalMemory(vk, device, &memInfo, &out->imageMemory)) {
-                VK_ANB_ERR("VK_ANDROID_native_buffer: Failed to import external memory");
-                return VK_ERROR_INITIALIZATION_FAILED;
-            }
+        if (!emu->importExternalMemory(out->mDeviceDispatch, out->mDevice,
+                                  &importedColorBufferMemoryInfo, dedicatedInfoPtr,
+                                  &out->mImageMemory)) {
+            VK_ANB_ERR("VK_ANDROID_native_buffer: Failed to import external memory%s",
+                       importedColorBufferMemoryInfo.dedicatedAllocation ? " (dedicated)" : "");
+            return nullptr;
         }
 
-        bindOffset = memInfo.bindOffset;
+        bindOffset = importedColorBufferMemoryInfo.bindOffset;
     } else {
         // delete the info struct and pass to vkCreateImage, and also add
         // transfer src capability to allow us to copy to CPU.
         VkImageCreateInfo infoNoNative = *pCreateInfo;
         infoNoNative.pNext = nullptr;
         infoNoNative.usage |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
-        VkResult createResult = vk->vkCreateImage(device, &infoNoNative, pAllocator, &out->image);
 
-        if (createResult != VK_SUCCESS) return createResult;
+        VkResult createResult = vk->vkCreateImage(device, &infoNoNative, pAllocator, &out->mImage);
+        if (createResult != VK_SUCCESS) {
+            return nullptr;
+        }
 
-        vk->vkGetImageMemoryRequirements(device, out->image, &out->memReqs);
+        vk->vkGetImageMemoryRequirements(device, out->mImage, &out->mImageMemoryRequirements);
 
         uint32_t imageMemoryTypeIndex = 0;
         bool imageMemoryTypeIndexFound = false;
 
         for (uint32_t i = 0; i < VK_MAX_MEMORY_TYPES; ++i) {
-            bool supported = out->memReqs.memoryTypeBits & (1 << i);
+            bool supported = out->mImageMemoryRequirements.memoryTypeBits & (1 << i);
             if (supported) {
                 imageMemoryTypeIndex = i;
                 imageMemoryTypeIndexFound = true;
@@ -250,35 +306,31 @@ VkResult prepareAndroidNativeBufferImage(VulkanDispatch* vk, VkDevice device,
             VK_ANB_ERR(
                 "VK_ANDROID_native_buffer: could not obtain "
                 "image memory type index");
-            teardownAndroidNativeBufferImage(vk, out);
-            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+            return nullptr;
         }
 
-        out->imageMemoryTypeIndex = imageMemoryTypeIndex;
+        out->mImageMemoryTypeIndex = imageMemoryTypeIndex;
 
-        VkMemoryAllocateInfo allocInfo = {
+        const VkMemoryAllocateInfo allocInfo = {
             VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
             0,
-            out->memReqs.size,
-            out->imageMemoryTypeIndex,
+            out->mImageMemoryRequirements.size,
+            out->mImageMemoryTypeIndex,
         };
-
-        if (VK_SUCCESS != vk->vkAllocateMemory(device, &allocInfo, nullptr, &out->imageMemory)) {
+        if (VK_SUCCESS != vk->vkAllocateMemory(device, &allocInfo, nullptr, &out->mImageMemory)) {
             VK_ANB_ERR(
                 "VK_ANDROID_native_buffer: could not allocate "
                 "image memory. requested size: %zu",
-                (size_t)(out->memReqs.size));
-            teardownAndroidNativeBufferImage(vk, out);
-            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+                (size_t)(out->mImageMemoryRequirements.size));
+            return nullptr;
         }
     }
 
-    if (VK_SUCCESS != vk->vkBindImageMemory(device, out->image, out->imageMemory, bindOffset)) {
+    if (VK_SUCCESS != vk->vkBindImageMemory(device, out->mImage, out->mImageMemory, bindOffset)) {
         VK_ANB_ERR(
             "VK_ANDROID_native_buffer: could not bind "
             "image memory.");
-        teardownAndroidNativeBufferImage(vk, out);
-        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+        return nullptr;
     }
 
     // Allocate a staging memory and set up the staging buffer.
@@ -289,123 +341,115 @@ VkResult prepareAndroidNativeBufferImage(VulkanDispatch* vk, VkDevice device,
             VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
             0,
             0,
-            out->memReqs.size,
+            out->mImageMemoryRequirements.size,
             VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
             VK_SHARING_MODE_EXCLUSIVE,
             0,
             nullptr,
         };
-        if (out->queueFamilyIndices.size() > 1) {
+        if (out->mQueueFamilyIndices.size() > 1) {
             stagingBufferCreateInfo.sharingMode = VK_SHARING_MODE_CONCURRENT;
             stagingBufferCreateInfo.queueFamilyIndexCount =
-                static_cast<uint32_t>(out->queueFamilyIndices.size());
-            stagingBufferCreateInfo.pQueueFamilyIndices = out->queueFamilyIndices.data();
+                static_cast<uint32_t>(out->mQueueFamilyIndices.size());
+            stagingBufferCreateInfo.pQueueFamilyIndices = out->mQueueFamilyIndices.data();
         }
 
         if (VK_SUCCESS !=
-            vk->vkCreateBuffer(device, &stagingBufferCreateInfo, nullptr, &out->stagingBuffer)) {
+            vk->vkCreateBuffer(device, &stagingBufferCreateInfo, nullptr, &out->mStagingBuffer)) {
             VK_ANB_ERR(
                 "VK_ANDROID_native_buffer: could not create "
                 "staging buffer.");
-            teardownAndroidNativeBufferImage(vk, out);
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+            return nullptr;
         }
 
-        VkMemoryRequirements stagingMemReqs;
-        vk->vkGetBufferMemoryRequirements(device, out->stagingBuffer, &stagingMemReqs);
-        if (stagingMemReqs.size < out->memReqs.size) {
-            VK_ANB_ERR(
-                "VK_ANDROID_native_buffer: unexpected staging buffer size");
-            teardownAndroidNativeBufferImage(vk, out);
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        VkMemoryRequirements stagingMemoryRequirements;
+        vk->vkGetBufferMemoryRequirements(device, out->mStagingBuffer, &stagingMemoryRequirements);
+        if (stagingMemoryRequirements.size < out->mImageMemoryRequirements.size) {
+            VK_ANB_ERR("VK_ANDROID_native_buffer: unexpected staging buffer size");
+            return nullptr;
         }
 
+        uint32_t stagingMemoryTypeIndex = -1;
         bool stagingIndexRes =
-            getStagingMemoryTypeIndex(vk, device, memProps, &out->stagingMemoryTypeIndex);
-
+            getStagingMemoryTypeIndex(vk, device, memProps, &stagingMemoryTypeIndex);
         if (!stagingIndexRes) {
             VK_ANB_ERR(
                 "VK_ANDROID_native_buffer: could not obtain "
                 "staging memory type index");
-            teardownAndroidNativeBufferImage(vk, out);
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+            return nullptr;
         }
 
         VkMemoryAllocateInfo allocInfo = {
             VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
             0,
-            stagingMemReqs.size,
-            out->stagingMemoryTypeIndex,
+            stagingMemoryRequirements.size,
+            stagingMemoryTypeIndex,
         };
 
-        VkResult res = vk->vkAllocateMemory(device, &allocInfo, nullptr, &out->stagingMemory);
+        VkResult res =
+            vk->vkAllocateMemory(device, &allocInfo, nullptr, &out->mStagingBufferMemory);
         if (VK_SUCCESS != res) {
             VK_ANB_ERR(
                 "VK_ANDROID_native_buffer: could not allocate staging memory. "
                 "res = %d. requested size: %zu",
-                (int)res, (size_t)(out->memReqs.size));
-            teardownAndroidNativeBufferImage(vk, out);
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+                (int)res, (size_t)(stagingMemoryRequirements.size));
+            return nullptr;
         }
 
         if (VK_SUCCESS !=
-            vk->vkBindBufferMemory(device, out->stagingBuffer, out->stagingMemory, 0)) {
+            vk->vkBindBufferMemory(device, out->mStagingBuffer, out->mStagingBufferMemory, 0)) {
             VK_ANB_ERR(
                 "VK_ANDROID_native_buffer: could not bind "
                 "staging buffer to staging memory.");
-            teardownAndroidNativeBufferImage(vk, out);
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+            return nullptr;
         }
 
-        if (VK_SUCCESS != vk->vkMapMemory(device, out->stagingMemory, 0, VK_WHOLE_SIZE, 0,
-                                          (void**)&out->mappedStagingPtr)) {
-            VK_ANB_ERR(
-                "VK_ANDROID_native_buffer: could not map "
-                "staging buffer.");
-            teardownAndroidNativeBufferImage(vk, out);
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        if (VK_SUCCESS != vk->vkMapMemory(device, out->mStagingBufferMemory, 0, VK_WHOLE_SIZE, 0,
+                                          (void**)&out->mMappedStagingPtr)) {
+            VK_ANB_ERR("VK_ANDROID_native_buffer: could not map staging buffer.");
+            return nullptr;
         }
     }
 
-    out->qsriWaitFencePool =
-        std::make_unique<AndroidNativeBufferInfo::QsriWaitFencePool>(out->vk, out->device);
-    out->qsriTimeline = std::make_unique<VkQsriTimeline>();
-    return VK_SUCCESS;
-}
-
-void teardownAndroidNativeBufferImage(VulkanDispatch* vk, AndroidNativeBufferInfo* anbInfo) {
-    auto device = anbInfo->device;
-
-    auto image = anbInfo->image;
-    auto imageMemory = anbInfo->imageMemory;
+    out->mQsriWaitFencePool = std::make_unique<AndroidNativeBufferInfo::QsriWaitFencePool>(
+        out->mDeviceDispatch, out->mDevice);
+    out->mQsriTimeline = std::make_unique<VkQsriTimeline>();
 
-    auto stagingBuffer = anbInfo->stagingBuffer;
-    auto mappedPtr = anbInfo->mappedStagingPtr;
-    auto stagingMemory = anbInfo->stagingMemory;
+    return out;
+}
 
-    for (auto queueState : anbInfo->queueStates) {
-        queueState.teardown(vk, device);
+AndroidNativeBufferInfo::~AndroidNativeBufferInfo() {
+    if (mDeviceDispatch == nullptr) {
+        return;
     }
 
-    anbInfo->queueStates.clear();
+    if (mDevice == VK_NULL_HANDLE) {
+        return;
+    }
 
-    anbInfo->acquireQueueState.teardown(vk, device);
+    for (auto& queueState : mQueueStates) {
+        queueState.teardown(mDeviceDispatch, mDevice);
+    }
+    mQueueStates.clear();
 
-    if (image) vk->vkDestroyImage(device, image, nullptr);
-    if (imageMemory) vk->vkFreeMemory(device, imageMemory, nullptr);
-    if (stagingBuffer) vk->vkDestroyBuffer(device, stagingBuffer, nullptr);
-    if (mappedPtr) vk->vkUnmapMemory(device, stagingMemory);
-    if (stagingMemory) vk->vkFreeMemory(device, stagingMemory, nullptr);
+    mAcquireQueueState.teardown(mDeviceDispatch, mDevice);
 
-    anbInfo->vk = nullptr;
-    anbInfo->device = VK_NULL_HANDLE;
-    anbInfo->image = VK_NULL_HANDLE;
-    anbInfo->imageMemory = VK_NULL_HANDLE;
-    anbInfo->stagingBuffer = VK_NULL_HANDLE;
-    anbInfo->mappedStagingPtr = nullptr;
-    anbInfo->stagingMemory = VK_NULL_HANDLE;
+    if (mImage != VK_NULL_HANDLE) {
+        mDeviceDispatch->vkDestroyImage(mDevice, mImage, nullptr);
+    }
+    if (mImageMemory != VK_NULL_HANDLE) {
+        mDeviceDispatch->vkFreeMemory(mDevice, mImageMemory, nullptr);
+    }
 
-    anbInfo->qsriWaitFencePool = nullptr;
+    if (mMappedStagingPtr != nullptr) {
+        mDeviceDispatch->vkUnmapMemory(mDevice, mStagingBufferMemory);
+    }
+    if (mStagingBuffer != VK_NULL_HANDLE) {
+        mDeviceDispatch->vkDestroyBuffer(mDevice, mStagingBuffer, nullptr);
+    }
+    if (mStagingBufferMemory != VK_NULL_HANDLE) {
+        mDeviceDispatch->vkFreeMemory(mDevice, mStagingBufferMemory, nullptr);
+    }
 }
 
 void getGralloc0Usage(VkFormat format, VkImageUsageFlags imageUsage, int* usage_out) {
@@ -461,10 +505,10 @@ void getGralloc1Usage(VkFormat format, VkImageUsageFlags imageUsage,
 
 void AndroidNativeBufferInfo::QueueState::setup(VulkanDispatch* vk, VkDevice device,
                                                 VkQueue queueIn, uint32_t queueFamilyIndexIn,
-                                                android::base::Lock* queueLockIn) {
+                                                std::mutex* queueMutexIn) {
     queue = queueIn;
     queueFamilyIndex = queueFamilyIndexIn;
-    lock = queueLockIn;
+    queueMutex = queueMutexIn;
 
     VkCommandPoolCreateInfo poolCreateInfo = {
         VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
@@ -498,14 +542,14 @@ void AndroidNativeBufferInfo::QueueState::teardown(VulkanDispatch* vk, VkDevice
     }
 
     if (queue) {
-        AutoLock qlock(*lock);
+        std::lock_guard<std::mutex> lock(*queueMutex);
         vk->vkQueueWaitIdle(queue);
     }
     if (cb) vk->vkFreeCommandBuffers(device, pool, 1, &cb);
     if (pool) vk->vkDestroyCommandPool(device, pool, nullptr);
     if (fence) vk->vkDestroyFence(device, fence, nullptr);
 
-    lock = nullptr;
+    queueMutex = nullptr;
     queue = VK_NULL_HANDLE;
     pool = VK_NULL_HANDLE;
     cb = VK_NULL_HANDLE;
@@ -513,18 +557,17 @@ void AndroidNativeBufferInfo::QueueState::teardown(VulkanDispatch* vk, VkDevice
     queueFamilyIndex = 0;
 }
 
-VkResult setAndroidNativeImageSemaphoreSignaled(VulkanDispatch* vk, VkDevice device,
-                                                VkQueue defaultQueue,
-                                                uint32_t defaultQueueFamilyIndex,
-                                                Lock* defaultQueueLock, VkSemaphore semaphore,
-                                                VkFence fence, AndroidNativeBufferInfo* anbInfo) {
-    auto emu = getGlobalVkEmulation();
-
-    bool firstTimeSetup = !anbInfo->everSynced && !anbInfo->everAcquired;
-
-    anbInfo->everAcquired = true;
+VkResult AndroidNativeBufferInfo::on_vkAcquireImageANDROID(VkEmulation* emu,
+                                                           VulkanDispatch* vk, VkDevice device,
+                                                           VkQueue defaultQueue,
+                                                           uint32_t defaultQueueFamilyIndex,
+                                                           std::mutex* defaultQueueMutex,
+                                                           VkSemaphore semaphore, VkFence fence) {
+    const bool firstTimeSetup = !mEverSynced && !mEverAcquired;
+    mEverAcquired = true;
 
     if (firstTimeSetup) {
+        mLastUsedQueueFamilyIndex = defaultQueueFamilyIndex;
         VkSubmitInfo submitInfo = {
             VK_STRUCTURE_TYPE_SUBMIT_INFO,
             0,
@@ -536,94 +579,97 @@ VkResult setAndroidNativeImageSemaphoreSignaled(VulkanDispatch* vk, VkDevice dev
             (uint32_t)(semaphore == VK_NULL_HANDLE ? 0 : 1),
             semaphore == VK_NULL_HANDLE ? nullptr : &semaphore,
         };
-        AutoLock qlock(*defaultQueueLock);
+        std::lock_guard<std::mutex> qlock(*defaultQueueMutex);
         VK_CHECK(vk->vkQueueSubmit(defaultQueue, 1, &submitInfo, fence));
-    } else {
-        // Setup queue state for this queue family index.
-        auto queueFamilyIndex = anbInfo->lastUsedQueueFamilyIndex;
-        if (queueFamilyIndex >= anbInfo->queueStates.size()) {
-            anbInfo->queueStates.resize(queueFamilyIndex + 1);
-        }
-        AndroidNativeBufferInfo::QueueState& queueState =
-            anbInfo->queueStates[queueFamilyIndex];
-        if (!queueState.queue) {
-            queueState.setup(vk, anbInfo->device, defaultQueue, queueFamilyIndex, defaultQueueLock);
-        }
+        return VK_SUCCESS;
+    }
 
-        // If we used the Vulkan image without copying it back
-        // to the CPU, reset the layout to PRESENT.
-        if (anbInfo->useVulkanNativeImage) {
-            VkCommandBufferBeginInfo beginInfo = {
-                VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
-                0,
-                VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
-                nullptr /* no inheritance info */,
-            };
-
-            vk->vkBeginCommandBuffer(queueState.cb2, &beginInfo);
-
-            emu->debugUtilsHelper.cmdBeginDebugLabel(queueState.cb2,
-                                                     "vkAcquireImageANDROID(ColorBuffer:%d)",
-                                                     anbInfo->colorBufferHandle);
-
-            VkImageMemoryBarrier queueTransferBarrier = {
-                .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
-                .srcAccessMask = VK_ACCESS_MEMORY_READ_BIT | VK_ACCESS_MEMORY_WRITE_BIT,
-                .dstAccessMask = VK_ACCESS_MEMORY_READ_BIT | VK_ACCESS_MEMORY_WRITE_BIT,
-                .oldLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
-                .newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
-                .srcQueueFamilyIndex = VK_QUEUE_FAMILY_EXTERNAL,
-                .dstQueueFamilyIndex = anbInfo->lastUsedQueueFamilyIndex,
-                .image = anbInfo->image,
-                .subresourceRange =
-                    {
-                        VK_IMAGE_ASPECT_COLOR_BIT,
-                        0,
-                        1,
-                        0,
-                        1,
-                    },
-            };
-            vk->vkCmdPipelineBarrier(queueState.cb2, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
-                                     VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, 0, 0, nullptr, 0, nullptr,
-                                     1, &queueTransferBarrier);
-
-            emu->debugUtilsHelper.cmdEndDebugLabel(queueState.cb2);
-
-            vk->vkEndCommandBuffer(queueState.cb2);
-
-            VkSubmitInfo submitInfo = {
-                VK_STRUCTURE_TYPE_SUBMIT_INFO,
-                0,
-                0,
-                nullptr,
-                nullptr,
-                1,
-                &queueState.cb2,
-                (uint32_t)(semaphore == VK_NULL_HANDLE ? 0 : 1),
-                semaphore == VK_NULL_HANDLE ? nullptr : &semaphore,
-            };
-
-            AutoLock qlock(*queueState.lock);
-            // TODO(kaiyili): initiate ownership transfer from DisplayVk here
-            VK_CHECK(vk->vkQueueSubmit(queueState.queue, 1, &submitInfo, fence));
-        } else {
-            const AndroidNativeBufferInfo::QueueState& queueState =
-                anbInfo->queueStates[anbInfo->lastUsedQueueFamilyIndex];
-            VkSubmitInfo submitInfo = {
-                VK_STRUCTURE_TYPE_SUBMIT_INFO,
-                0,
-                0,
-                nullptr,
-                nullptr,
-                0,
-                nullptr,
-                (uint32_t)(semaphore == VK_NULL_HANDLE ? 0 : 1),
-                semaphore == VK_NULL_HANDLE ? nullptr : &semaphore,
-            };
-            AutoLock qlock(*queueState.lock);
-            VK_CHECK(vk->vkQueueSubmit(queueState.queue, 1, &submitInfo, fence));
-        }
+    if (mLastUsedQueueFamilyIndex == INVALID_QUEUE_FAMILY_INDEX) {
+        ERR("AndroidNativeBufferInfo missing last used queue.");
+        return VK_ERROR_INITIALIZATION_FAILED;
+    }
+
+    // Setup queue state for this queue family index.
+    auto queueFamilyIndex = mLastUsedQueueFamilyIndex;
+    if (queueFamilyIndex >= mQueueStates.size()) {
+        mQueueStates.resize(queueFamilyIndex + 1);
+    }
+    QueueState& queueState = mQueueStates[queueFamilyIndex];
+    if (!queueState.queue) {
+        queueState.setup(mDeviceDispatch, mDevice, defaultQueue, queueFamilyIndex,
+                         defaultQueueMutex);
+    }
+
+    // If we used the Vulkan image without copying it back
+    // to the CPU, reset the layout to PRESENT.
+    if (mUseVulkanNativeImage) {
+        VkCommandBufferBeginInfo beginInfo = {
+            VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
+            0,
+            VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
+            nullptr /* no inheritance info */,
+        };
+
+        vk->vkBeginCommandBuffer(queueState.cb2, &beginInfo);
+
+        emu->getDebugUtilsHelper().cmdBeginDebugLabel(
+            queueState.cb2, "vkAcquireImageANDROID(ColorBuffer:%d)", mColorBufferHandle);
+
+        VkImageMemoryBarrier queueTransferBarrier = {
+            .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
+            .srcAccessMask = VK_ACCESS_MEMORY_READ_BIT | VK_ACCESS_MEMORY_WRITE_BIT,
+            .dstAccessMask = VK_ACCESS_MEMORY_READ_BIT | VK_ACCESS_MEMORY_WRITE_BIT,
+            .oldLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
+            .newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
+            .srcQueueFamilyIndex = VK_QUEUE_FAMILY_EXTERNAL,
+            .dstQueueFamilyIndex = mLastUsedQueueFamilyIndex,
+            .image = mImage,
+            .subresourceRange =
+                {
+                    VK_IMAGE_ASPECT_COLOR_BIT,
+                    0,
+                    1,
+                    0,
+                    1,
+                },
+        };
+        vk->vkCmdPipelineBarrier(queueState.cb2, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
+                                 VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, 0, 0, nullptr, 0, nullptr, 1,
+                                 &queueTransferBarrier);
+
+        emu->getDebugUtilsHelper().cmdEndDebugLabel(queueState.cb2);
+
+        vk->vkEndCommandBuffer(queueState.cb2);
+
+        VkSubmitInfo submitInfo = {
+            VK_STRUCTURE_TYPE_SUBMIT_INFO,
+            0,
+            0,
+            nullptr,
+            nullptr,
+            1,
+            &queueState.cb2,
+            (uint32_t)(semaphore == VK_NULL_HANDLE ? 0 : 1),
+            semaphore == VK_NULL_HANDLE ? nullptr : &semaphore,
+        };
+
+        std::lock_guard<std::mutex> queueLock(*queueState.queueMutex);
+        // TODO(kaiyili): initiate ownership transfer from DisplayVk here
+        VK_CHECK(vk->vkQueueSubmit(queueState.queue, 1, &submitInfo, fence));
+    } else {
+        const VkSubmitInfo submitInfo = {
+            VK_STRUCTURE_TYPE_SUBMIT_INFO,
+            0,
+            0,
+            nullptr,
+            nullptr,
+            0,
+            nullptr,
+            (uint32_t)(semaphore == VK_NULL_HANDLE ? 0 : 1),
+            semaphore == VK_NULL_HANDLE ? nullptr : &semaphore,
+        };
+        std::lock_guard<std::mutex> queueLock(*queueState.queueMutex);
+        VK_CHECK(vk->vkQueueSubmit(queueState.queue, 1, &submitInfo, fence));
     }
 
     return VK_SUCCESS;
@@ -631,10 +677,10 @@ VkResult setAndroidNativeImageSemaphoreSignaled(VulkanDispatch* vk, VkDevice dev
 
 static constexpr uint64_t kTimeoutNs = 3ULL * 1000000000ULL;
 
-VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, VulkanDispatch* vk,
-                                uint32_t queueFamilyIndex, VkQueue queue, Lock* queueLock,
-                                uint32_t waitSemaphoreCount, const VkSemaphore* pWaitSemaphores,
-                                int* pNativeFenceFd, AndroidNativeBufferInfo* anbInfo) {
+VkResult AndroidNativeBufferInfo::on_vkQueueSignalReleaseImageANDROID(
+    VkEmulation* emu, VulkanDispatch* vk, uint32_t queueFamilyIndex,
+    VkQueue queue, std::mutex* queueMutex, uint32_t waitSemaphoreCount,
+    const VkSemaphore* pWaitSemaphores, int* pNativeFenceFd) {
     const uint64_t traceId = gfxstream::host::GetUniqueTracingId();
     GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DEFAULT_CATEGORY, "vkQSRI syncImageToColorBuffer()",
                           GFXSTREAM_TRACE_FLOW(traceId));
@@ -645,22 +691,20 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
     // Implicitly synchronized
     *pNativeFenceFd = -1;
 
-    anbInfo->everSynced = true;
-    anbInfo->lastUsedQueueFamilyIndex = queueFamilyIndex;
+    mEverSynced = true;
+    mLastUsedQueueFamilyIndex = queueFamilyIndex;
 
     // Setup queue state for this queue family index.
-    if (queueFamilyIndex >= anbInfo->queueStates.size()) {
-        anbInfo->queueStates.resize(queueFamilyIndex + 1);
+    if (queueFamilyIndex >= mQueueStates.size()) {
+        mQueueStates.resize(queueFamilyIndex + 1);
     }
 
-    auto& queueState = anbInfo->queueStates[queueFamilyIndex];
+    auto& queueState = mQueueStates[queueFamilyIndex];
 
     if (!queueState.queue) {
-        queueState.setup(vk, anbInfo->device, queue, queueFamilyIndex, queueLock);
+        queueState.setup(vk, mDevice, queue, queueFamilyIndex, queueMutex);
     }
 
-    auto emu = getGlobalVkEmulation();
-
     // Record our synchronization commands.
     VkCommandBufferBeginInfo beginInfo = {
         VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
@@ -671,13 +715,12 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
 
     vk->vkBeginCommandBuffer(queueState.cb, &beginInfo);
 
-    emu->debugUtilsHelper.cmdBeginDebugLabel(queueState.cb,
-                                             "vkQueueSignalReleaseImageANDROID(ColorBuffer:%d)",
-                                             anbInfo->colorBufferHandle);
+    emu->getDebugUtilsHelper().cmdBeginDebugLabel(
+        queueState.cb, "vkQueueSignalReleaseImageANDROID(ColorBuffer:%d)", mColorBufferHandle);
 
     // If using the Vulkan image directly (rather than copying it back to
     // the CPU), change its layout for that use.
-    if (anbInfo->useVulkanNativeImage) {
+    if (mUseVulkanNativeImage) {
         VkImageMemoryBarrier queueTransferBarrier = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
             .srcAccessMask = VK_ACCESS_MEMORY_READ_BIT | VK_ACCESS_MEMORY_WRITE_BIT,
@@ -686,7 +729,7 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
             .newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
             .srcQueueFamilyIndex = queueFamilyIndex,
             .dstQueueFamilyIndex = VK_QUEUE_FAMILY_EXTERNAL,
-            .image = anbInfo->image,
+            .image = mImage,
             .subresourceRange =
                 {
                     VK_IMAGE_ASPECT_COLOR_BIT,
@@ -717,7 +760,7 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
             VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
             VK_QUEUE_FAMILY_IGNORED,
             VK_QUEUE_FAMILY_IGNORED,
-            anbInfo->image,
+            mImage,
             {
                 VK_IMAGE_ASPECT_COLOR_BIT,
                 0,
@@ -733,8 +776,8 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
 
         VkBufferImageCopy region = {
             0 /* buffer offset */,
-            anbInfo->extent.width,
-            anbInfo->extent.height,
+            mExtent.width,
+            mExtent.height,
             {
                 VK_IMAGE_ASPECT_COLOR_BIT,
                 0,
@@ -742,12 +785,11 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
                 1,
             },
             {0, 0, 0},
-            anbInfo->extent,
+            mExtent,
         };
 
-        vk->vkCmdCopyImageToBuffer(queueState.cb, anbInfo->image,
-                                   VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, anbInfo->stagingBuffer, 1,
-                                   &region);
+        vk->vkCmdCopyImageToBuffer(queueState.cb, mImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+                                   mStagingBuffer, 1, &region);
 
         // Transfer back to present src.
         VkImageMemoryBarrier backToPresentSrc = {
@@ -759,7 +801,7 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
             VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
             VK_QUEUE_FAMILY_IGNORED,
             VK_QUEUE_FAMILY_IGNORED,
-            anbInfo->image,
+            mImage,
             {
                 VK_IMAGE_ASPECT_COLOR_BIT,
                 0,
@@ -774,7 +816,7 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
                                  &backToPresentSrc);
     }
 
-    emu->debugUtilsHelper.cmdEndDebugLabel(queueState.cb);
+    emu->getDebugUtilsHelper().cmdEndDebugLabel(queueState.cb);
 
     vk->vkEndCommandBuffer(queueState.cb);
 
@@ -794,15 +836,16 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
     };
 
     // TODO(kaiyili): initiate ownership transfer to DisplayVk here.
-    VkFence qsriFence = anbInfo->qsriWaitFencePool->getFenceFromPool();
-    AutoLock qLock(*queueLock);
+    VkFence qsriFence = mQsriWaitFencePool->getFenceFromPool();
+    std::lock_guard<std::mutex> qLock(*queueMutex);
     VK_CHECK(vk->vkQueueSubmit(queueState.queue, 1, &submitInfo, qsriFence));
-    auto waitForQsriFenceTask = [anbInfo, vk, device = anbInfo->device, qsriFence, traceId] {
+    auto waitForQsriFenceTask = [this, vk, device = mDevice, qsriFence, traceId] {
+        (void)traceId;
         GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DEFAULT_CATEGORY, "Wait for QSRI fence",
                               GFXSTREAM_TRACE_FLOW(traceId));
 
-        VK_ANB_DEBUG_OBJ(anbInfo, "wait callback: enter");
-        VK_ANB_DEBUG_OBJ(anbInfo, "wait callback: wait for fence %p...", qsriFence);
+        VK_ANB_DEBUG_OBJ(this, "wait callback: enter");
+        VK_ANB_DEBUG_OBJ(this, "wait callback: wait for fence %p...", qsriFence);
         VkResult res = vk->vkWaitForFences(device, 1, &qsriFence, VK_FALSE, kTimeoutNs);
         switch (res) {
             case VK_SUCCESS:
@@ -814,38 +857,35 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
                 ERR("Failed to wait for QSRI fence: %s\n", string_VkResult(res));
                 VK_CHECK(res);
         }
-        VK_ANB_DEBUG_OBJ(anbInfo, "wait callback: wait for fence %p...(done)", qsriFence);
-        anbInfo->qsriWaitFencePool->returnFence(qsriFence);
+        VK_ANB_DEBUG_OBJ(this, "wait callback: wait for fence %p...(done)", qsriFence);
+        mQsriWaitFencePool->returnFence(qsriFence);
     };
     fb->unlock();
 
-    if (anbInfo->useVulkanNativeImage) {
-        VK_ANB_DEBUG_OBJ(anbInfo, "using native image, so use sync thread to wait");
+    if (mUseVulkanNativeImage) {
+        VK_ANB_DEBUG_OBJ(this, "using native image, so use sync thread to wait");
         // Queue wait to sync thread with completion callback
         // Pass anbInfo by value to get a ref
-        auto waitable = callbacks.scheduleAsyncWork(
-            [waitForQsriFenceTask = std::move(waitForQsriFenceTask), anbInfo]() mutable {
+        auto waitable = emu->getCallbacks().scheduleAsyncWork(
+            [waitForQsriFenceTask = std::move(waitForQsriFenceTask), this]() mutable {
                 waitForQsriFenceTask();
-                anbInfo->qsriTimeline->signalNextPresentAndPoll();
+                mQsriTimeline->signalNextPresentAndPoll();
             },
             "wait for the guest Qsri VkFence signaled");
 
         queueState.latestUse = std::move(waitable);
     } else {
-        VK_ANB_DEBUG_OBJ(anbInfo, "not using native image, so wait right away");
+        VK_ANB_DEBUG_OBJ(this, "not using native image, so wait right away");
         waitForQsriFenceTask();
 
-        VkMappedMemoryRange toInvalidate = {
-            VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, 0, anbInfo->stagingMemory, 0, VK_WHOLE_SIZE,
+        const VkMappedMemoryRange toInvalidate = {
+            VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, 0, mStagingBufferMemory, 0, VK_WHOLE_SIZE,
         };
-
-        vk->vkInvalidateMappedMemoryRanges(anbInfo->device, 1, &toInvalidate);
-
-        uint32_t colorBufferHandle = anbInfo->colorBufferHandle;
+        vk->vkInvalidateMappedMemoryRanges(mDevice, 1, &toInvalidate);
 
         // Copy to from staging buffer to color buffer
         uint32_t bpp = 4; /* format always rgba8...not */
-        switch (anbInfo->vkFormat) {
+        switch (mVkFormat) {
             case VK_FORMAT_R5G6B5_UNORM_PACK16:
                 bpp = 2;
                 break;
@@ -858,15 +898,34 @@ VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, Vu
                 bpp = 4;
                 break;
         }
-        const void* bytes = anbInfo->mappedStagingPtr;
-        const size_t bytesSize = bpp * anbInfo->extent.width * anbInfo->extent.height;
-        callbacks.flushColorBufferFromBytes(colorBufferHandle, bytes, bytesSize);
+        const void* bytes = mMappedStagingPtr;
+        const size_t bytesSize = bpp * mExtent.width * mExtent.height;
+        emu->getCallbacks().flushColorBufferFromBytes(mColorBufferHandle, bytes, bytesSize);
 
-        anbInfo->qsriTimeline->signalNextPresentAndPoll();
+        mQsriTimeline->signalNextPresentAndPoll();
     }
 
     return VK_SUCCESS;
 }
 
+AsyncResult AndroidNativeBufferInfo::registerQsriCallback(VkImage image,
+                                                          VkQsriTimeline::Callback callback) {
+    if (!mDeviceDispatch) {
+        ERR("Attempted to register QSRI callback on VkImage:%p with uninitialized ANB info.",
+            image);
+        return AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
+    }
+
+    // Could be null or mismatched image, check later
+    if (image != mImage) {
+        ERR("Attempted on register QSRI callback on VkImage:%p with wrong image %p.", image,
+            mImage);
+        return AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
+    }
+
+    mQsriTimeline->registerCallbackForNextPresentAndPoll(std::move(callback));
+    return AsyncResult::OK_AND_CALLBACK_SCHEDULED;
+}
+
 }  // namespace vk
 }  // namespace gfxstream
diff --git a/host/vulkan/VkAndroidNativeBuffer.h b/host/vulkan/VkAndroidNativeBuffer.h
index 44380395d..b6340be45 100644
--- a/host/vulkan/VkAndroidNativeBuffer.h
+++ b/host/vulkan/VkAndroidNativeBuffer.h
@@ -18,13 +18,16 @@
 #include <atomic>
 #include <deque>
 #include <memory>
+#include <mutex>
 #include <optional>
 #include <unordered_set>
 #include <vector>
 
 #include "VkCommonOperations.h"
 #include "VkQsriTimeline.h"
+#include "aemu/base/AsyncResult.h"
 #include "aemu/base/BumpPool.h"
+#include "aemu/base/ThreadAnnotations.h"
 #include "aemu/base/synchronization/ConditionVariable.h"
 #include "aemu/base/synchronization/Lock.h"
 #include "gfxstream/host/BackendCallbacks.h"
@@ -33,37 +36,64 @@
 namespace gfxstream {
 namespace vk {
 
-struct AndroidNativeBufferInfo;
 struct VulkanDispatch;
 
 // This class provides methods to create and query information about Android
 // native buffers in the context of creating Android swapchain images that have
 // Android native buffer backing.
 
-// This is to be refactored to move to external memory only once we get that
-// working.
+class AndroidNativeBufferInfo {
+   public:
+    static std::unique_ptr<AndroidNativeBufferInfo> create(
+        VkEmulation* emu, VulkanDispatch* vk, VkDevice device, android::base::BumpPool& allocator,
+        const VkImageCreateInfo* pCreateInfo, const VkNativeBufferANDROID* nativeBufferANDROID,
+        const VkAllocationCallbacks* pAllocator, const VkPhysicalDeviceMemoryProperties* memProps);
 
-void teardownAndroidNativeBufferImage(VulkanDispatch* vk, AndroidNativeBufferInfo* anbInfo);
+    AndroidNativeBufferInfo(const AndroidNativeBufferInfo&) = delete;
+    AndroidNativeBufferInfo& operator=(const AndroidNativeBufferInfo&) = delete;
 
-struct AndroidNativeBufferInfo {
-    ~AndroidNativeBufferInfo() {
-        if (vk) {
-            teardownAndroidNativeBufferImage(vk, this);
-        }
-    }
+    AndroidNativeBufferInfo(AndroidNativeBufferInfo&&) = delete;
+    AndroidNativeBufferInfo& operator=(AndroidNativeBufferInfo&&) = delete;
 
-    VulkanDispatch* vk = nullptr;
-    VkDevice device = VK_NULL_HANDLE;
-    VkFormat vkFormat;
-    VkExtent3D extent;
-    VkImageUsageFlags usage;
-    std::vector<uint32_t> queueFamilyIndices;
+    ~AndroidNativeBufferInfo();
 
-    int format;
-    int stride;
-    uint32_t colorBufferHandle;
-    bool externallyBacked = false;
-    bool useVulkanNativeImage = false;
+    VkImage getImage() const { return mImage; }
+
+    bool isExternallyBacked() const { return mExternallyBacked; }
+
+    bool isUsingNativeImage() const { return mUseVulkanNativeImage; }
+
+    uint32_t getColorBufferHandle() const { return mColorBufferHandle; }
+
+    VkResult on_vkAcquireImageANDROID(VkEmulation* emu, VulkanDispatch* vk, VkDevice device, VkQueue defaultQueue,
+                                      uint32_t defaultQueueFamilyIndex,
+                                      std::mutex* defaultQueueMutex, VkSemaphore semaphore,
+                                      VkFence fence);
+
+    VkResult on_vkQueueSignalReleaseImageANDROID(VkEmulation* emu,
+                                                 VulkanDispatch* vk, uint32_t queueFamilyIndex,
+                                                 VkQueue queue, std::mutex* queueMutex,
+                                                 uint32_t waitSemaphoreCount,
+                                                 const VkSemaphore* pWaitSemaphores,
+                                                 int* pNativeFenceFd);
+
+    AsyncResult registerQsriCallback(VkImage image, VkQsriTimeline::Callback callback);
+
+   private:
+    AndroidNativeBufferInfo() = default;
+
+    VulkanDispatch* mDeviceDispatch = nullptr;
+    VkDevice mDevice = VK_NULL_HANDLE;
+    VkFormat mVkFormat;
+    VkExtent3D mExtent;
+    VkImageUsageFlags mUsage;
+    std::vector<uint32_t> mQueueFamilyIndices;
+
+    int mAhbFormat = 0;
+    int mStride = 0;
+    uint32_t mColorBufferHandle = 0;
+    bool mExternallyBacked = false;
+    bool mUseVulkanNativeImage = false;
 
     // We will be using separate allocations for image versus staging memory,
     // because not all host Vulkan drivers will support directly rendering to
@@ -71,19 +101,16 @@ struct AndroidNativeBufferInfo {
 
     // If we are using external memory, these memories are imported
     // to the current instance.
-    VkDeviceMemory imageMemory = VK_NULL_HANDLE;
-    VkDeviceMemory stagingMemory = VK_NULL_HANDLE;
-
-    VkBuffer stagingBuffer = VK_NULL_HANDLE;
+    VkDeviceMemory mImageMemory = VK_NULL_HANDLE;
+    uint32_t mImageMemoryTypeIndex = -1;
 
-    uint32_t imageMemoryTypeIndex;
-    uint32_t stagingMemoryTypeIndex;
-
-    uint8_t* mappedStagingPtr = nullptr;
+    VkDeviceMemory mStagingBufferMemory = VK_NULL_HANDLE;
+    VkBuffer mStagingBuffer = VK_NULL_HANDLE;
+    uint8_t* mMappedStagingPtr = nullptr;
 
     // To be populated later as we go.
-    VkImage image = VK_NULL_HANDLE;
-    VkMemoryRequirements memReqs;
+    VkImage mImage = VK_NULL_HANDLE;
+    VkMemoryRequirements mImageMemoryRequirements;
 
     // The queue over which we send the buffer/image copy commands depends on
     // the queue over which vkQueueSignalReleaseImageANDROID happens.
@@ -95,16 +122,16 @@ struct AndroidNativeBufferInfo {
         VkCommandBuffer cb = VK_NULL_HANDLE;
         VkCommandBuffer cb2 = VK_NULL_HANDLE;
         VkFence fence = VK_NULL_HANDLE;
-        android::base::Lock* lock = nullptr;
+        std::mutex* queueMutex = nullptr;
         uint32_t queueFamilyIndex = 0;
         std::optional<CancelableFuture> latestUse;
         void setup(VulkanDispatch* vk, VkDevice device, VkQueue queue, uint32_t queueFamilyIndex,
-                   android::base::Lock* queueLock);
+                   std::mutex* queueMutex);
         void teardown(VulkanDispatch* vk, VkDevice device);
     };
     // We keep one QueueState for each queue family index used by the guest
     // in vkQueuePresentKHR.
-    std::vector<QueueState> queueStates;
+    std::vector<QueueState> mQueueStates;
 
     // Did we ever sync the Vulkan image with a ColorBuffer?
     // If so, set everSynced along with the queue family index
@@ -112,14 +139,15 @@ struct AndroidNativeBufferInfo {
     // If the swapchain image was created with exclusive sharing
     // mode (reflected in this struct's |sharingMode| field),
     // this part doesn't really matter.
-    bool everSynced = false;
-    uint32_t lastUsedQueueFamilyIndex;
+    bool mEverSynced = false;
+    static constexpr uint32_t INVALID_QUEUE_FAMILY_INDEX = std::numeric_limits<uint32_t>::max();
+    uint32_t mLastUsedQueueFamilyIndex = INVALID_QUEUE_FAMILY_INDEX;
 
     // On first acquire, we might use a different queue family
     // to initially set the semaphore/fence to be signaled.
     // Track that here.
-    bool everAcquired = false;
-    QueueState acquireQueueState;
+    bool mEverAcquired = false;
+    QueueState mAcquireQueueState;
 
     // State that is of interest when interacting with sync fds and SyncThread.
     // Protected by this lock and condition variable.
@@ -131,46 +159,25 @@ struct AndroidNativeBufferInfo {
         void returnFence(VkFence fence);
 
        private:
-        android::base::Lock mLock;
+        std::mutex mMutex;
 
         VulkanDispatch* mVk;
         VkDevice mDevice;
 
         // A pool of vkFences for waiting (optimization so we don't keep recreating them every
         // time).
-        std::vector<VkFence> mAvailableFences;
-        std::unordered_set<VkFence> mUsedFences;
+        std::vector<VkFence> mAvailableFences GUARDED_BY(mMutex);
+        std::unordered_set<VkFence> mUsedFences GUARDED_BY(mMutex);
     };
 
-    std::unique_ptr<QsriWaitFencePool> qsriWaitFencePool = nullptr;
-    std::unique_ptr<VkQsriTimeline> qsriTimeline = nullptr;
+    std::unique_ptr<QsriWaitFencePool> mQsriWaitFencePool;
+    std::unique_ptr<VkQsriTimeline> mQsriTimeline;
 };
 
-VkResult prepareAndroidNativeBufferImage(VulkanDispatch* vk, VkDevice device,
-                                         android::base::BumpPool& allocator,
-                                         const VkImageCreateInfo* pCreateInfo,
-                                         const VkNativeBufferANDROID* nativeBufferANDROID,
-                                         const VkAllocationCallbacks* pAllocator,
-                                         const VkPhysicalDeviceMemoryProperties* memProps,
-                                         AndroidNativeBufferInfo* out);
-
 void getGralloc0Usage(VkFormat format, VkImageUsageFlags imageUsage, int* usage_out);
 void getGralloc1Usage(VkFormat format, VkImageUsageFlags imageUsage,
                       VkSwapchainImageUsageFlagsANDROID swapchainImageUsage,
                       uint64_t* consumerUsage_out, uint64_t* producerUsage_out);
 
-VkResult setAndroidNativeImageSemaphoreSignaled(VulkanDispatch* vk, VkDevice device,
-                                                VkQueue defaultQueue,
-                                                uint32_t defaultQueueFamilyIndex,
-                                                android::base::Lock* defaultQueueLock,
-                                                VkSemaphore semaphore, VkFence fence,
-                                                AndroidNativeBufferInfo* anbInfo);
-
-VkResult syncImageToColorBuffer(gfxstream::host::BackendCallbacks& callbacks, VulkanDispatch* vk,
-                                uint32_t queueFamilyIndex, VkQueue queue,
-                                android::base::Lock* queueLock, uint32_t waitSemaphoreCount,
-                                const VkSemaphore* pWaitSemaphores, int* pNativeFenceFd,
-                                AndroidNativeBufferInfo* anbInfo);
-
 }  // namespace vk
 }  // namespace gfxstream
diff --git a/host/vulkan/VkCommonOperations.cpp b/host/vulkan/VkCommonOperations.cpp
index 717a2130a..5b304fc5c 100644
--- a/host/vulkan/VkCommonOperations.cpp
+++ b/host/vulkan/VkCommonOperations.cpp
@@ -25,7 +25,6 @@
 #include <sstream>
 #include <unordered_set>
 
-#include "ExternalObjectManager.h"
 #include "VkDecoderGlobalState.h"
 #include "VkEmulatedPhysicalDeviceMemory.h"
 #include "VkFormatUtils.h"
@@ -59,7 +58,6 @@ namespace {
 
 using android::base::AutoLock;
 using android::base::kNullopt;
-using android::base::ManagedDescriptor;
 using android::base::Optional;
 using android::base::StaticLock;
 using android::base::StaticMap;
@@ -76,8 +74,6 @@ using emugl::FatalError;
 constexpr size_t kPageBits = 12;
 constexpr size_t kPageSize = 1u << kPageBits;
 
-static int kMaxDebugMarkerAnnotations = 10;
-
 static std::optional<std::string> sMemoryLogPath = std::nullopt;
 
 const char* string_AstcEmulationMode(AstcEmulationMode mode) {
@@ -96,27 +92,92 @@ const char* string_AstcEmulationMode(AstcEmulationMode mode) {
 
 static StaticMap<VkDevice, uint32_t> sKnownStagingTypeIndices;
 
-static android::base::StaticLock sVkEmulationLock;
+std::optional<GenericDescriptorInfo> VkEmulation::exportMemoryHandle(VkDevice device,
+                                                                     VkDeviceMemory memory) {
+    GenericDescriptorInfo ret;
 
-static bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32_t y,
-                                             uint32_t w, uint32_t h, const void* pixels,
-                                             size_t inputPixelsSize);
+#if defined(__unix__)
+    VkMemoryGetFdInfoKHR memoryGetFdInfo = {
+        .sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
+        .pNext = nullptr,
+        .memory = memory,
+        .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
+    };
+    ret.streamHandleType = STREAM_HANDLE_TYPE_MEM_OPAQUE_FD;
 
-#if !defined(__QNX__)
-VK_EXT_MEMORY_HANDLE dupExternalMemory(VK_EXT_MEMORY_HANDLE h) {
-#ifdef _WIN32
+#if defined(__linux__)
+    if (supportsDmaBuf()) {
+        memoryGetFdInfo.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+        ret.streamHandleType = STREAM_HANDLE_TYPE_MEM_DMABUF;
+    }
+#endif
+
+    int fd = -1;
+    if (mDeviceInfo.getMemoryHandleFunc(mDevice, &memoryGetFdInfo, &fd) != VK_SUCCESS) {
+        return std::nullopt;
+    };
+
+    ret.descriptor = ManagedDescriptor(fd);
+
+#elif defined(_WIN32)
+    VkMemoryGetWin32HandleInfoKHR memoryGetHandleInfo = {
+        .sType = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
+        .pNext = nullptr,
+        .memory = memory,
+        .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
+    };
+    ret.streamHandleType = STREAM_HANDLE_TYPE_MEM_OPAQUE_WIN32;
+
+    HANDLE handle;
+    if (mDeviceInfo.getMemoryHandleFunc(mDevice, &memoryGetHandleInfo, &handle) != VK_SUCCESS) {
+        return std::nullopt;
+    }
+
+    ret.descriptor = ManagedDescriptor(handle);
+#else
+    ERR("Unsupported external memory handle type.");
+    return std::nullopt;
+#endif
+
+    return std::move(ret);
+}
+
+static std::optional<ExternalHandleInfo> dupExternalMemory(std::optional<ExternalHandleInfo> handleInfo) {
+    if (!handleInfo) {
+        ERR("dupExternalMemory: No external memory handle info provided to duplicate the external memory");
+        return std::nullopt;
+    }
+#if defined(_WIN32)
     auto myProcessHandle = GetCurrentProcess();
-    VK_EXT_MEMORY_HANDLE res;
-    DuplicateHandle(myProcessHandle, h,     // source process and handle
+    HANDLE res;
+    DuplicateHandle(myProcessHandle,
+                    static_cast<HANDLE>(
+                        reinterpret_cast<void*>(handleInfo->handle)),  // source process and handle
                     myProcessHandle, &res,  // target process and pointer to handle
                     0 /* desired access (ignored) */, true /* inherit */,
                     DUPLICATE_SAME_ACCESS /* same access option */);
-    return res;
+    return ExternalHandleInfo{
+        .handle = reinterpret_cast<ExternalHandleType>(res),
+        .streamHandleType = handleInfo->streamHandleType,
+    };
+#elif defined(__QNX__)
+    if (STREAM_HANDLE_TYPE_PLATFORM_SCREEN_BUFFER_QNX == handleInfo->streamHandleType) {
+        // No dup required for the screen_buffer handle
+        return ExternalHandleInfo{
+            .handle = handleInfo->handle,
+            .streamHandleType = handleInfo->streamHandleType,
+        };
+    }
+    // TODO(aruby@blackberry.com): Support dup-ing for OPAQUE_FD or DMABUF types on QNX
+    return std::nullopt;
 #else
-    return dup(h);
+    // TODO(aruby@blackberry.com): Check handleType?
+    return ExternalHandleInfo{
+        .handle = static_cast<ExternalHandleType>(dup(handleInfo->handle)),
+        .streamHandleType = handleInfo->streamHandleType,
+    };
 #endif
 }
-#endif
 
 bool getStagingMemoryTypeIndex(VulkanDispatch* vk, VkDevice device,
                                const VkPhysicalDeviceMemoryProperties* memProps,
@@ -218,7 +279,25 @@ bool getStagingMemoryTypeIndex(VulkanDispatch* vk, VkDevice device,
     return true;
 }
 
-static VkEmulation* sVkEmulation = nullptr;
+VkExternalMemoryHandleTypeFlagBits VkEmulation::getDefaultExternalMemoryHandleType() {
+#if defined(_WIN32)
+    return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+#else
+
+#if defined(__APPLE__)
+    if (mInstanceSupportsMoltenVK) {
+        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
+    }
+#endif
+
+#if defined(__QNX__)
+    // TODO(aruby@blackberry.com): Use (DMABUF|OPAQUE_FD) on QNX, when screen_buffer not supported?
+    return VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX;
+#endif
+
+    return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+#endif
+}
 
 static bool extensionsSupported(const std::vector<VkExtensionProperties>& currentProps,
                                 const std::vector<const char*>& wantedExtNames) {
@@ -287,15 +366,9 @@ static bool formatRequiresYcbcrConversion(VkFormat format) {
     }
 }
 
-// For a given ImageSupportInfo, populates usageWithExternalHandles and
-// requiresDedicatedAllocation. memoryTypeBits are populated later once the
-// device is created, because that needs a test image to be created.
-// If we don't support external memory, it's assumed dedicated allocations are
-// not needed.
-// Precondition: sVkEmulation instance has been created and ext memory caps known.
-// Returns false if the query failed.
-static bool getImageFormatExternalMemorySupportInfo(VulkanDispatch* vk, VkPhysicalDevice physdev,
-                                                    VkEmulation::ImageSupportInfo* info) {
+bool VkEmulation::populateImageFormatExternalMemorySupportInfo(VulkanDispatch* vk,
+                                                               VkPhysicalDevice physdev,
+                                                               ImageSupportInfo* info) {
     // Currently there is nothing special we need to do about
     // VkFormatProperties2, so just use the normal version
     // and put it in the format2 struct.
@@ -308,7 +381,7 @@ static bool getImageFormatExternalMemorySupportInfo(VulkanDispatch* vk, VkPhysic
         outFormatProps,
     };
 
-    if (!sVkEmulation->instanceSupportsExternalMemoryCapabilities) {
+    if (!mInstanceSupportsExternalMemoryCapabilities) {
         info->supportsExternalMemory = false;
         info->requiresDedicatedAllocation = false;
 
@@ -349,14 +422,8 @@ static bool getImageFormatExternalMemorySupportInfo(VulkanDispatch* vk, VkPhysic
     VkPhysicalDeviceExternalImageFormatInfo extInfo = {
         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
         0,
-        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
+        getDefaultExternalMemoryHandleType(),
     };
-#if defined(__APPLE__)
-    if (sVkEmulation->instanceSupportsMoltenVK) {
-        // Using a different handle type when in MoltenVK mode
-        extInfo.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
-    }
-#endif
 
     VkPhysicalDeviceImageFormatInfo2 formatInfo2 = {
         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
@@ -388,7 +455,7 @@ static bool getImageFormatExternalMemorySupportInfo(VulkanDispatch* vk, VkPhysic
                                               0,
                                           }};
 
-    VkResult res = sVkEmulation->getImageFormatProperties2Func(physdev, &formatInfo2, &outProps2);
+    VkResult res = mGetImageFormatProperties2Func(physdev, &formatInfo2, &outProps2);
 
     if (res != VK_SUCCESS) {
         if (res == VK_ERROR_FORMAT_NOT_SUPPORTED) {
@@ -422,13 +489,7 @@ static bool getImageFormatExternalMemorySupportInfo(VulkanDispatch* vk, VkPhysic
     VkExternalMemoryHandleTypeFlags compatibleHandleTypes =
         outExternalProps.externalMemoryProperties.compatibleHandleTypes;
 
-    VkExternalMemoryHandleTypeFlags handleTypeNeeded = VK_EXT_MEMORY_HANDLE_TYPE_BIT;
-#if defined(__APPLE__)
-    if (sVkEmulation->instanceSupportsMoltenVK) {
-        // Using a different handle type when in MoltenVK mode
-        handleTypeNeeded = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
-    }
-#endif
+    VkExternalMemoryHandleTypeFlags handleTypeNeeded = getDefaultExternalMemoryHandleType();
 
     info->supportsExternalMemory = (handleTypeNeeded & compatibleHandleTypes) &&
                                    (VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT & featureFlags) &&
@@ -485,7 +546,7 @@ static std::string decodeDriverVersion(uint32_t vendorId, uint32_t driverVersion
     return result.str();
 }
 
-static std::vector<VkEmulation::ImageSupportInfo> getBasicImageSupportList() {
+/*static*/ std::vector<VkEmulation::ImageSupportInfo> VkEmulation::getBasicImageSupportList() {
     struct ImageFeatureCombo {
         VkFormat format;
         VkImageCreateFlags createFlags = 0;
@@ -502,6 +563,7 @@ static std::vector<VkEmulation::ImageSupportInfo> getBasicImageSupportList() {
          VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT | VK_IMAGE_CREATE_EXTENDED_USAGE_BIT},
 
         {VK_FORMAT_R5G6B5_UNORM_PACK16},
+        {VK_FORMAT_A1R5G5B5_UNORM_PACK16},
 
         {VK_FORMAT_R16G16B16A16_SFLOAT},
         {VK_FORMAT_R16G16B16_SFLOAT},
@@ -509,6 +571,11 @@ static std::vector<VkEmulation::ImageSupportInfo> getBasicImageSupportList() {
         {VK_FORMAT_B8G8R8A8_UNORM,
          VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT | VK_IMAGE_CREATE_EXTENDED_USAGE_BIT},
 
+        {VK_FORMAT_B4G4R4A4_UNORM_PACK16,
+         VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT | VK_IMAGE_CREATE_EXTENDED_USAGE_BIT},
+        {VK_FORMAT_R4G4B4A4_UNORM_PACK16,
+         VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT | VK_IMAGE_CREATE_EXTENDED_USAGE_BIT},
+
         {VK_FORMAT_R8_UNORM,
          VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT | VK_IMAGE_CREATE_EXTENDED_USAGE_BIT},
         {VK_FORMAT_R16_UNORM,
@@ -522,8 +589,7 @@ static std::vector<VkEmulation::ImageSupportInfo> getBasicImageSupportList() {
         {VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK},
         {VK_FORMAT_ASTC_4x4_UNORM_BLOCK},
 
-        // TODO: YUV formats used in Android
-        // Fails on Mac
+        // YUV formats used in Android
         {VK_FORMAT_G8_B8R8_2PLANE_420_UNORM},
         {VK_FORMAT_G8_B8R8_2PLANE_422_UNORM},
         {VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM},
@@ -584,7 +650,7 @@ static std::vector<VkEmulation::ImageSupportInfo> getBasicImageSupportList() {
     for (auto combo : depthCombos) {
         for (auto t : types) {
             for (auto u : depthUsageFlags) {
-                VkEmulation::ImageSupportInfo info;
+                ImageSupportInfo info;
                 info.format = combo.format;
                 info.type = t;
                 info.tiling = VK_IMAGE_TILING_OPTIMAL;
@@ -604,13 +670,14 @@ static std::vector<VkEmulation::ImageSupportInfo> getBasicImageSupportList() {
 // quality, stability and performance issues of current GPUs.
 // Only one Vulkan device is selected; this makes things simple for now, but we
 // could consider utilizing multiple devices in use cases that make sense.
-int getSelectedGpuIndex(const std::vector<VkEmulation::DeviceSupportInfo>& deviceInfos) {
-    const int physdevCount = deviceInfos.size();
-    if (physdevCount == 1) {
+int VkEmulation::getSelectedGpuIndex(
+    const std::vector<VkEmulation::DeviceSupportInfo>& deviceInfos) {
+    const int physicalDeviceCount = deviceInfos.size();
+    if (physicalDeviceCount == 1) {
         return 0;
     }
 
-    if (!sVkEmulation->instanceSupportsGetPhysicalDeviceProperties2) {
+    if (!mInstanceSupportsGetPhysicalDeviceProperties2) {
         // If we don't support physical device ID properties, pick the first physical device
         WARN("Instance doesn't support '%s', picking the first physical device",
              VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);
@@ -634,7 +701,7 @@ int getSelectedGpuIndex(const std::vector<VkEmulation::DeviceSupportInfo>& devic
                 std::transform(enforcedGpuStr.begin(), enforcedGpuStr.end(), enforcedGpuStr.begin(),
                                [](unsigned char c) { return std::tolower(c); });
 
-                for (int i = 0; i < physdevCount; ++i) {
+                for (int i = 0; i < physicalDeviceCount; ++i) {
                     std::string deviceName = std::string(deviceInfos[i].physdevProps.deviceName);
                     std::transform(deviceName.begin(), deviceName.end(), deviceName.begin(),
                                    [](unsigned char c) { return std::tolower(c); });
@@ -647,7 +714,7 @@ int getSelectedGpuIndex(const std::vector<VkEmulation::DeviceSupportInfo>& devic
             }
         }
 
-        if (enforceGpuIndex != -1 && enforceGpuIndex >= 0 && enforceGpuIndex < deviceInfos.size()) {
+        if (enforceGpuIndex != -1 && enforceGpuIndex >= 0 && enforceGpuIndex < (int)deviceInfos.size()) {
             INFO("Selecting GPU (%s) at index %d.",
                  deviceInfos[enforceGpuIndex].physdevProps.deviceName, enforceGpuIndex);
         } else {
@@ -681,7 +748,7 @@ int getSelectedGpuIndex(const std::vector<VkEmulation::DeviceSupportInfo>& devic
 
         // Prefer discrete GPUs, then integrated and then others..
         const int deviceType = deviceInfo.physdevProps.deviceType;
-        deviceScore += deviceTypeScoreTable[deviceInfo.physdevProps.deviceType];
+        deviceScore += deviceTypeScoreTable[deviceType];
 
         // Prefer higher level of Vulkan API support, restrict version numbers to
         // common limits to ensure an always increasing scoring change
@@ -694,7 +761,7 @@ int getSelectedGpuIndex(const std::vector<VkEmulation::DeviceSupportInfo>& devic
     };
 
     uint32_t maxScore = 0;
-    for (int i = 0; i < physdevCount; ++i) {
+    for (int i = 0; i < physicalDeviceCount; ++i) {
         const uint32_t score = getDeviceScore(deviceInfos[i]);
         VERBOSE("Device selection score for '%s' = %d", deviceInfos[i].physdevProps.deviceName,
                 score);
@@ -707,9 +774,10 @@ int getSelectedGpuIndex(const std::vector<VkEmulation::DeviceSupportInfo>& devic
     return selectedGpuIndex;
 }
 
-VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
-                                     gfxstream::host::BackendCallbacks callbacks,
-                                     gfxstream::host::FeatureSet features) {
+/*static*/
+std::unique_ptr<VkEmulation> VkEmulation::create(VulkanDispatch* gvk,
+                                                 gfxstream::host::BackendCallbacks callbacks,
+                                                 gfxstream::host::FeatureSet features) {
 // Downstream branches can provide abort logic or otherwise use result without a new macro
 #define VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(res, ...) \
     do {                                               \
@@ -718,20 +786,17 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         return nullptr;                                \
     } while (0)
 
-    AutoLock lock(sVkEmulationLock);
-
-    if (sVkEmulation) return sVkEmulation;
-
-    if (!vkDispatchValid(vk)) {
+    if (!vkDispatchValid(gvk)) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER, "Dispatch is invalid.");
     }
 
-    sVkEmulation = new VkEmulation;
-    sVkEmulation->callbacks = callbacks;
-    sVkEmulation->features = features;
+    std::unique_ptr<VkEmulation> emulation(new VkEmulation());
+
+    std::lock_guard<std::mutex> lock(emulation->mMutex);
 
-    sVkEmulation->gvk = vk;
-    auto gvk = vk;
+    emulation->mCallbacks = callbacks;
+    emulation->mFeatures = features;
+    emulation->mGvk = gvk;
 
     std::vector<const char*> getPhysicalDeviceProperties2InstanceExtNames = {
         VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,
@@ -781,9 +846,9 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     };
 #endif
 
+    std::vector<VkExtensionProperties>& instanceExts = emulation->mInstanceExtensions;
     uint32_t instanceExtCount = 0;
     gvk->vkEnumerateInstanceExtensionProperties(nullptr, &instanceExtCount, nullptr);
-    std::vector<VkExtensionProperties>& instanceExts = sVkEmulation->instanceExtensions;
     instanceExts.resize(instanceExtCount);
     gvk->vkEnumerateInstanceExtensionProperties(nullptr, &instanceExtCount, instanceExts.data());
 
@@ -816,7 +881,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 
     const bool debugUtilsSupported =
         extensionsSupported(instanceExts, {VK_EXT_DEBUG_UTILS_EXTENSION_NAME});
-    const bool debugUtilsRequested = sVkEmulation->features.VulkanDebugUtils.enabled;
+    const bool debugUtilsRequested = emulation->mFeatures.VulkanDebugUtils.enabled;
     const bool debugUtilsAvailableAndRequested = debugUtilsSupported && debugUtilsRequested;
     if (debugUtilsAvailableAndRequested) {
         selectedInstanceExtensionNames.emplace(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
@@ -855,7 +920,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         }
     }
 
-    if (sVkEmulation->features.VulkanNativeSwapchain.enabled) {
+    if (emulation->mFeatures.VulkanNativeSwapchain.enabled) {
         for (auto extension : SwapChainStateVk::getRequiredInstanceExtensions()) {
             selectedInstanceExtensionNames.emplace(extension);
         }
@@ -899,19 +964,17 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
             VK_VERSION_MAJOR(appInfo.apiVersion), VK_VERSION_MINOR(appInfo.apiVersion),
             VK_VERSION_PATCH(appInfo.apiVersion));
 
-    VkResult res = gvk->vkCreateInstance(&instCi, nullptr, &sVkEmulation->instance);
-
+    VkResult res = gvk->vkCreateInstance(&instCi, nullptr, &emulation->mInstance);
     if (res != VK_SUCCESS) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(res, "Failed to create Vulkan instance. Error %s.",
                                              string_VkResult(res));
     }
 
     // Create instance level dispatch.
-    sVkEmulation->ivk = new VulkanDispatch;
-    init_vulkan_dispatch_from_instance(vk, sVkEmulation->instance, sVkEmulation->ivk);
-
-    auto ivk = sVkEmulation->ivk;
+    emulation->mIvk = new VulkanDispatch();
+    init_vulkan_dispatch_from_instance(gvk, emulation->mInstance, emulation->mIvk);
 
+    auto ivk = emulation->mIvk;
     if (!vulkan_dispatch_check_instance_VK_VERSION_1_0(ivk)) {
         ERR("Warning: Vulkan 1.0 APIs missing from instance");
     }
@@ -930,16 +993,15 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
             VERBOSE("Found out that we can create a higher version instance.");
             appInfo.apiVersion = VK_MAKE_VERSION(1, 1, 0);
 
-            gvk->vkDestroyInstance(sVkEmulation->instance, nullptr);
-
-            VkResult res = gvk->vkCreateInstance(&instCi, nullptr, &sVkEmulation->instance);
+            gvk->vkDestroyInstance(emulation->mInstance, nullptr);
 
+            res = gvk->vkCreateInstance(&instCi, nullptr, &emulation->mInstance);
             if (res != VK_SUCCESS) {
                 VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(
                     res, "Failed to create Vulkan 1.1 instance. Error %s.", string_VkResult(res));
             }
 
-            init_vulkan_dispatch_from_instance(vk, sVkEmulation->instance, sVkEmulation->ivk);
+            init_vulkan_dispatch_from_instance(gvk, emulation->mInstance, emulation->mIvk);
 
             VERBOSE("Created Vulkan 1.1 instance on second try.");
 
@@ -949,44 +1011,45 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         }
     }
 
-    sVkEmulation->vulkanInstanceVersion = appInfo.apiVersion;
+    emulation->mVulkanInstanceVersion = appInfo.apiVersion;
 
     // https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIDProperties.html
     // Provided by VK_VERSION_1_1, or VK_KHR_external_fence_capabilities, VK_KHR_external_memory_capabilities,
     // VK_KHR_external_semaphore_capabilities
-    sVkEmulation->instanceSupportsPhysicalDeviceIDProperties =
-        externalFenceCapabilitiesSupported || externalMemoryCapabilitiesSupported ||
-        externalSemaphoreCapabilitiesSupported;
-
-    sVkEmulation->instanceSupportsGetPhysicalDeviceProperties2 = getPhysicalDeviceProperties2Supported;
-    sVkEmulation->instanceSupportsExternalMemoryCapabilities = externalMemoryCapabilitiesSupported;
-    sVkEmulation->instanceSupportsExternalSemaphoreCapabilities =
+    emulation->mInstanceSupportsPhysicalDeviceIDProperties = externalFenceCapabilitiesSupported ||
+                                                             externalMemoryCapabilitiesSupported ||
+                                                             externalSemaphoreCapabilitiesSupported;
+
+    emulation->mInstanceSupportsGetPhysicalDeviceProperties2 =
+        getPhysicalDeviceProperties2Supported;
+    emulation->mInstanceSupportsExternalMemoryCapabilities = externalMemoryCapabilitiesSupported;
+    emulation->mInstanceSupportsExternalSemaphoreCapabilities =
         externalSemaphoreCapabilitiesSupported;
-    sVkEmulation->instanceSupportsExternalFenceCapabilities = externalFenceCapabilitiesSupported;
-    sVkEmulation->instanceSupportsSurface = surfaceSupported;
+    emulation->mInstanceSupportsExternalFenceCapabilities = externalFenceCapabilitiesSupported;
+    emulation->mInstanceSupportsSurface = surfaceSupported;
 #if defined(__APPLE__)
-    sVkEmulation->instanceSupportsMoltenVK = useMoltenVK;
+    emulation->mInstanceSupportsMoltenVK = useMoltenVK;
 #endif
 
-    if (sVkEmulation->instanceSupportsGetPhysicalDeviceProperties2) {
-        sVkEmulation->getImageFormatProperties2Func = vk_util::getVkInstanceProcAddrWithFallback<
+    if (emulation->mInstanceSupportsGetPhysicalDeviceProperties2) {
+        emulation->mGetImageFormatProperties2Func = vk_util::getVkInstanceProcAddrWithFallback<
             vk_util::vk_fn_info::GetPhysicalDeviceImageFormatProperties2>(
-            {ivk->vkGetInstanceProcAddr, vk->vkGetInstanceProcAddr}, sVkEmulation->instance);
-        sVkEmulation->getPhysicalDeviceProperties2Func = vk_util::getVkInstanceProcAddrWithFallback<
+            {ivk->vkGetInstanceProcAddr, gvk->vkGetInstanceProcAddr}, emulation->mInstance);
+        emulation->mGetPhysicalDeviceProperties2Func = vk_util::getVkInstanceProcAddrWithFallback<
             vk_util::vk_fn_info::GetPhysicalDeviceProperties2>(
-            {ivk->vkGetInstanceProcAddr, vk->vkGetInstanceProcAddr}, sVkEmulation->instance);
-        sVkEmulation->getPhysicalDeviceFeatures2Func = vk_util::getVkInstanceProcAddrWithFallback<
+            {ivk->vkGetInstanceProcAddr, gvk->vkGetInstanceProcAddr}, emulation->mInstance);
+        emulation->mGetPhysicalDeviceFeatures2Func = vk_util::getVkInstanceProcAddrWithFallback<
             vk_util::vk_fn_info::GetPhysicalDeviceFeatures2>(
-            {ivk->vkGetInstanceProcAddr, vk->vkGetInstanceProcAddr}, sVkEmulation->instance);
+            {ivk->vkGetInstanceProcAddr, gvk->vkGetInstanceProcAddr}, emulation->mInstance);
 
-        if (!sVkEmulation->getPhysicalDeviceProperties2Func) {
+        if (!emulation->mGetPhysicalDeviceProperties2Func) {
             ERR("Warning: device claims to support ID properties "
                 "but vkGetPhysicalDeviceProperties2 could not be found");
         }
     }
 
 #if defined(__APPLE__)
-    if (sVkEmulation->instanceSupportsMoltenVK) {
+    if (emulation->mInstanceSupportsMoltenVK) {
         // Enable some specific extensions on MacOS when moltenVK is used.
         externalMemoryDeviceExtNames.push_back(VK_EXT_METAL_OBJECTS_EXTENSION_NAME);
         externalMemoryDeviceExtNames.push_back(VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME);
@@ -996,36 +1059,37 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     }
 #endif
 
-    uint32_t physdevCount = 0;
-    ivk->vkEnumeratePhysicalDevices(sVkEmulation->instance, &physdevCount, nullptr);
-    std::vector<VkPhysicalDevice> physdevs(physdevCount);
-    ivk->vkEnumeratePhysicalDevices(sVkEmulation->instance, &physdevCount, physdevs.data());
+    uint32_t physicalDeviceCount = 0;
+    ivk->vkEnumeratePhysicalDevices(emulation->mInstance, &physicalDeviceCount, nullptr);
+    std::vector<VkPhysicalDevice> physicalDevices(physicalDeviceCount);
+    ivk->vkEnumeratePhysicalDevices(emulation->mInstance, &physicalDeviceCount,
+                                    physicalDevices.data());
 
-    VERBOSE("Found %d Vulkan physical devices.", physdevCount);
+    VERBOSE("Found %d Vulkan physical devices.", physicalDeviceCount);
 
-    if (physdevCount == 0) {
+    if (physicalDeviceCount == 0) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER, "No physical devices available.");
     }
 
-    std::vector<VkEmulation::DeviceSupportInfo> deviceInfos(physdevCount);
+    std::vector<DeviceSupportInfo> deviceInfos(physicalDeviceCount);
 
-    for (int i = 0; i < physdevCount; ++i) {
-        ivk->vkGetPhysicalDeviceProperties(physdevs[i], &deviceInfos[i].physdevProps);
+    for (uint32_t i = 0; i < physicalDeviceCount; ++i) {
+        ivk->vkGetPhysicalDeviceProperties(physicalDevices[i], &deviceInfos[i].physdevProps);
 
         VERBOSE("Considering Vulkan physical device %d : %s", i,
                 deviceInfos[i].physdevProps.deviceName);
 
         // It's easier to figure out the staging buffer along with
         // external memories if we have the memory properties on hand.
-        ivk->vkGetPhysicalDeviceMemoryProperties(physdevs[i], &deviceInfos[i].memProps);
+        ivk->vkGetPhysicalDeviceMemoryProperties(physicalDevices[i], &deviceInfos[i].memProps);
 
         uint32_t deviceExtensionCount = 0;
-        ivk->vkEnumerateDeviceExtensionProperties(physdevs[i], nullptr, &deviceExtensionCount,
-                                                  nullptr);
+        ivk->vkEnumerateDeviceExtensionProperties(physicalDevices[i], nullptr,
+                                                  &deviceExtensionCount, nullptr);
         std::vector<VkExtensionProperties>& deviceExts = deviceInfos[i].extensions;
         deviceExts.resize(deviceExtensionCount);
-        ivk->vkEnumerateDeviceExtensionProperties(physdevs[i], nullptr, &deviceExtensionCount,
-                                                  deviceExts.data());
+        ivk->vkEnumerateDeviceExtensionProperties(physicalDevices[i], nullptr,
+                                                  &deviceExtensionCount, deviceExts.data());
 
         deviceInfos[i].supportsExternalMemoryImport = false;
         deviceInfos[i].supportsExternalMemoryExport = false;
@@ -1039,7 +1103,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         }
 #endif
 
-        if (sVkEmulation->instanceSupportsExternalMemoryCapabilities) {
+        if (emulation->mInstanceSupportsExternalMemoryCapabilities) {
             deviceInfos[i].supportsExternalMemoryExport =
                 deviceInfos[i].supportsExternalMemoryImport =
                     extensionsSupported(deviceExts, externalMemoryDeviceExtNames);
@@ -1049,7 +1113,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 #endif
         }
 
-        if (sVkEmulation->instanceSupportsGetPhysicalDeviceProperties2) {
+        if (emulation->mInstanceSupportsGetPhysicalDeviceProperties2) {
             deviceInfos[i].supportsDriverProperties =
                 extensionsSupported(deviceExts, {VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME}) ||
                 (deviceInfos[i].physdevProps.apiVersion >= VK_API_VERSION_1_2);
@@ -1064,7 +1128,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
             VkPhysicalDeviceIDProperties idProps = {
                 VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR,
             };
-            if (sVkEmulation->instanceSupportsPhysicalDeviceIDProperties) {
+            if (emulation->mInstanceSupportsPhysicalDeviceIDProperties) {
                 vk_append_struct(&devicePropsChain, &idProps);
             }
 
@@ -1081,7 +1145,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
             if(deviceInfos[i].supportsExternalMemoryHostProps) {
                 vk_append_struct(&devicePropsChain, &externalMemoryHostProps);
             }
-            sVkEmulation->getPhysicalDeviceProperties2Func(physdevs[i], &deviceProps);
+            emulation->mGetPhysicalDeviceProperties2Func(physicalDevices[i], &deviceProps);
             deviceInfos[i].idProps = vk_make_orphan_copy(idProps);
             deviceInfos[i].externalMemoryHostProps = vk_make_orphan_copy(externalMemoryHostProps);
 
@@ -1109,10 +1173,17 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
             deviceInfos[i].driverVersion = driverVersion;
         }
 
-        bool dmaBufBlockList = deviceInfos[i].driverVendor == "NVIDIA (Vendor 0x10de)";
+// TODO(aruby@qnx.com): Remove once dmabuf extension support has been flushed out on QNX
+#if !defined(__QNX__)
+        bool dmaBufBlockList = (deviceInfos[i].driverVendor == "NVIDIA (Vendor 0x10de)");
+#ifdef CONFIG_AEMU
+        // TODO(b/400999642): dma_buf support should be checked with image format support
+        dmaBufBlockList |= (deviceInfos[i].driverVendor == "radv (Vendor 0x1002)");
+#endif
         deviceInfos[i].supportsDmaBuf =
             extensionsSupported(deviceExts, {VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME}) &&
             !dmaBufBlockList;
+#endif
 
         deviceInfos[i].hasSamplerYcbcrConversionExtension =
             extensionsSupported(deviceExts, {VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME});
@@ -1120,7 +1191,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         deviceInfos[i].hasNvidiaDeviceDiagnosticCheckpointsExtension =
             extensionsSupported(deviceExts, {VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME});
 
-        if (sVkEmulation->getPhysicalDeviceFeatures2Func) {
+        if (emulation->mGetPhysicalDeviceFeatures2Func) {
             VkPhysicalDeviceFeatures2 features2 = {
                 .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
             };
@@ -1154,7 +1225,16 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
                 vk_append_struct(&features2Chain, &privateDataFeatures);
             }
 
-            sVkEmulation->getPhysicalDeviceFeatures2Func(physdevs[i], &features2);
+            VkPhysicalDeviceRobustness2FeaturesEXT robustness2Features = {
+                .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT};
+            const bool robustnessRequested = emulation->mFeatures.VulkanRobustness.enabled;
+            const bool robustnessSupported =
+                extensionsSupported(deviceExts, {VK_EXT_ROBUSTNESS_2_EXTENSION_NAME});
+            if (robustnessRequested && robustnessSupported) {
+                vk_append_struct(&features2Chain, &robustness2Features);
+            }
+
+            emulation->mGetPhysicalDeviceFeatures2Func(physicalDevices[i], &features2);
 
             deviceInfos[i].supportsSamplerYcbcrConversion =
                 samplerYcbcrConversionFeatures.samplerYcbcrConversion == VK_TRUE;
@@ -1164,6 +1244,15 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 
             deviceInfos[i].supportsPrivateData = (privateDataFeatures.privateData == VK_TRUE);
 
+            // Enable robustness only when requested
+            if (robustnessRequested && robustnessSupported) {
+                deviceInfos[i].robustness2Features = vk_make_orphan_copy(robustness2Features);
+            } else if (robustnessRequested) {
+                WARN(
+                    "VulkanRobustness was requested but the "
+                    "VK_EXT_robustness2 extension is not supported.");
+            }
+
 #if defined(__QNX__)
             deviceInfos[i].supportsExternalMemoryImport =
                 extMemScreenBufferFeatures.screenBufferImport == VK_TRUE;
@@ -1173,9 +1262,10 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         }
 
         uint32_t queueFamilyCount = 0;
-        ivk->vkGetPhysicalDeviceQueueFamilyProperties(physdevs[i], &queueFamilyCount, nullptr);
+        ivk->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevices[i], &queueFamilyCount,
+                                                      nullptr);
         std::vector<VkQueueFamilyProperties> queueFamilyProps(queueFamilyCount);
-        ivk->vkGetPhysicalDeviceQueueFamilyProperties(physdevs[i], &queueFamilyCount,
+        ivk->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevices[i], &queueFamilyCount,
                                                       queueFamilyProps.data());
 
         for (uint32_t j = 0; j < queueFamilyCount; ++j) {
@@ -1205,28 +1295,28 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 
     // When there are multiple physical devices, find the best one or enable selecting
     // the one enforced by environment variable setting.
-    int selectedGpuIndex = getSelectedGpuIndex(deviceInfos);
+    int selectedGpuIndex = emulation->getSelectedGpuIndex(deviceInfos);
 
-    sVkEmulation->physdev = physdevs[selectedGpuIndex];
-    sVkEmulation->physicalDeviceIndex = selectedGpuIndex;
-    sVkEmulation->deviceInfo = deviceInfos[selectedGpuIndex];
-    // Postcondition: sVkEmulation has valid device support info
+    emulation->mPhysicalDevice = physicalDevices[selectedGpuIndex];
+    emulation->mPhysicalDeviceIndex = selectedGpuIndex;
+    emulation->mDeviceInfo = deviceInfos[selectedGpuIndex];
+    // Postcondition: emulation has valid device support info
 
     // Collect image support info of the selected device
-    sVkEmulation->imageSupportInfo = getBasicImageSupportList();
-    for (size_t i = 0; i < sVkEmulation->imageSupportInfo.size(); ++i) {
-        getImageFormatExternalMemorySupportInfo(ivk, sVkEmulation->physdev,
-                                                &sVkEmulation->imageSupportInfo[i]);
+    emulation->mImageSupportInfo = getBasicImageSupportList();
+    for (size_t i = 0; i < emulation->mImageSupportInfo.size(); ++i) {
+        emulation->populateImageFormatExternalMemorySupportInfo(ivk, emulation->mPhysicalDevice,
+                                                                &emulation->mImageSupportInfo[i]);
     }
 
-    if (!sVkEmulation->deviceInfo.hasGraphicsQueueFamily) {
+    if (!emulation->mDeviceInfo.hasGraphicsQueueFamily) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER,
                                              "No Vulkan devices with graphics queues found.");
     }
 
-    auto deviceVersion = sVkEmulation->deviceInfo.physdevProps.apiVersion;
+    auto deviceVersion = emulation->mDeviceInfo.physdevProps.apiVersion;
     INFO("Selecting Vulkan device: %s, Version: %d.%d.%d",
-         sVkEmulation->deviceInfo.physdevProps.deviceName, VK_VERSION_MAJOR(deviceVersion),
+         emulation->mDeviceInfo.physdevProps.deviceName, VK_VERSION_MAJOR(deviceVersion),
          VK_VERSION_MINOR(deviceVersion), VK_VERSION_PATCH(deviceVersion));
 
     VERBOSE(
@@ -1239,36 +1329,31 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         "hasSamplerYcbcrConversionExtension = %d\n"
         "supportsSamplerYcbcrConversion = %d\n"
         "glInteropSupported = %d",
-        sVkEmulation->deviceInfo.hasGraphicsQueueFamily,
-        sVkEmulation->deviceInfo.hasComputeQueueFamily,
-        sVkEmulation->deviceInfo.supportsExternalMemoryImport,
-        sVkEmulation->deviceInfo.supportsExternalMemoryExport,
-        sVkEmulation->deviceInfo.supportsDriverProperties,
-        sVkEmulation->deviceInfo.hasSamplerYcbcrConversionExtension,
-        sVkEmulation->deviceInfo.supportsSamplerYcbcrConversion,
-        sVkEmulation->deviceInfo.glInteropSupported);
+        emulation->mDeviceInfo.hasGraphicsQueueFamily, emulation->mDeviceInfo.hasComputeQueueFamily,
+        emulation->mDeviceInfo.supportsExternalMemoryImport,
+        emulation->mDeviceInfo.supportsExternalMemoryExport,
+        emulation->mDeviceInfo.supportsDriverProperties,
+        emulation->mDeviceInfo.hasSamplerYcbcrConversionExtension,
+        emulation->mDeviceInfo.supportsSamplerYcbcrConversion,
+        emulation->mDeviceInfo.glInteropSupported);
 
     float priority = 1.0f;
     VkDeviceQueueCreateInfo dqCi = {
-        VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
-        0,
-        0,
-        sVkEmulation->deviceInfo.graphicsQueueFamilyIndices[0],
-        1,
-        &priority,
+        VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,           0, 0,
+        emulation->mDeviceInfo.graphicsQueueFamilyIndices[0], 1, &priority,
     };
 
     std::unordered_set<const char*> selectedDeviceExtensionNames_;
 
-    if (sVkEmulation->deviceInfo.supportsExternalMemoryImport ||
-        sVkEmulation->deviceInfo.supportsExternalMemoryExport) {
+    if (emulation->mDeviceInfo.supportsExternalMemoryImport ||
+        emulation->mDeviceInfo.supportsExternalMemoryExport) {
         for (auto extension : externalMemoryDeviceExtNames) {
             selectedDeviceExtensionNames_.emplace(extension);
         }
     }
 
 #if defined(__linux__)
-    if (sVkEmulation->deviceInfo.supportsDmaBuf) {
+    if (emulation->mDeviceInfo.supportsDmaBuf) {
         selectedDeviceExtensionNames_.emplace(VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME);
     }
 #endif
@@ -1278,13 +1363,13 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     // in releaseColorBufferForGuestUse for the apps using Vulkan swapchain
     selectedDeviceExtensionNames_.emplace(VK_KHR_SWAPCHAIN_EXTENSION_NAME);
 
-    if (sVkEmulation->features.VulkanNativeSwapchain.enabled) {
+    if (emulation->mFeatures.VulkanNativeSwapchain.enabled) {
         for (auto extension : SwapChainStateVk::getRequiredDeviceExtensions()) {
             selectedDeviceExtensionNames_.emplace(extension);
         }
     }
 
-    if (sVkEmulation->deviceInfo.hasSamplerYcbcrConversionExtension) {
+    if (emulation->mDeviceInfo.hasSamplerYcbcrConversionExtension) {
         selectedDeviceExtensionNames_.emplace(VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME);
     }
 
@@ -1296,6 +1381,10 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     }
 #endif
 
+    if (emulation->mDeviceInfo.robustness2Features) {
+        selectedDeviceExtensionNames_.emplace(VK_EXT_ROBUSTNESS_2_EXTENSION_NAME);
+    }
+
     std::vector<const char*> selectedDeviceExtensionNames(selectedDeviceExtensionNames_.begin(),
                                                           selectedDeviceExtensionNames_.end());
 
@@ -1316,7 +1405,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 
     std::unique_ptr<VkPhysicalDeviceSamplerYcbcrConversionFeatures> samplerYcbcrConversionFeatures =
         nullptr;
-    if (sVkEmulation->deviceInfo.supportsSamplerYcbcrConversion) {
+    if (emulation->mDeviceInfo.supportsSamplerYcbcrConversion) {
         samplerYcbcrConversionFeatures =
             std::make_unique<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(
                 VkPhysicalDeviceSamplerYcbcrConversionFeatures{
@@ -1329,7 +1418,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 #if defined(__QNX__)
     std::unique_ptr<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>
         extMemScreenBufferFeaturesQNX = nullptr;
-    if (sVkEmulation->deviceInfo.supportsExternalMemoryImport) {
+    if (emulation->mDeviceInfo.supportsExternalMemoryImport) {
         extMemScreenBufferFeaturesQNX = std::make_unique<
             VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>(
             VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX{
@@ -1342,9 +1431,9 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 #endif
 
     const bool commandBufferCheckpointsSupported =
-        sVkEmulation->deviceInfo.supportsNvidiaDeviceDiagnosticCheckpoints;
+        emulation->mDeviceInfo.supportsNvidiaDeviceDiagnosticCheckpoints;
     const bool commandBufferCheckpointsRequested =
-        sVkEmulation->features.VulkanCommandBufferCheckpoints.enabled;
+        emulation->mFeatures.VulkanCommandBufferCheckpoints.enabled;
     const bool commandBufferCheckpointsSupportedAndRequested =
         commandBufferCheckpointsSupported && commandBufferCheckpointsRequested;
     VkPhysicalDeviceDiagnosticsConfigFeaturesNV deviceDiagnosticsConfigFeatures = {
@@ -1360,7 +1449,15 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
             "VK_NV_device_diagnostic_checkpoints extension is not supported.");
     }
 
-    ivk->vkCreateDevice(sVkEmulation->physdev, &dCi, nullptr, &sVkEmulation->device);
+    VkPhysicalDeviceRobustness2FeaturesEXT r2features = {};
+    if (emulation->mDeviceInfo.robustness2Features) {
+        r2features = *emulation->mDeviceInfo.robustness2Features;
+        INFO("Enabling VK_EXT_robustness2 (%d %d %d).", r2features.robustBufferAccess2,
+             r2features.robustImageAccess2, r2features.nullDescriptor);
+        vk_append_struct(&deviceCiChain, &r2features);
+    }
+
+    ivk->vkCreateDevice(emulation->mPhysicalDevice, &dCi, nullptr, &emulation->mDevice);
 
     if (res != VK_SUCCESS) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(res, "Failed to create Vulkan device. Error %s.",
@@ -1368,10 +1465,10 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     }
 
     // device created; populate dispatch table
-    sVkEmulation->dvk = new VulkanDispatch;
-    init_vulkan_dispatch_from_device(ivk, sVkEmulation->device, sVkEmulation->dvk);
+    emulation->mDvk = new VulkanDispatch();
+    init_vulkan_dispatch_from_device(ivk, emulation->mDevice, emulation->mDvk);
 
-    auto dvk = sVkEmulation->dvk;
+    auto dvk = emulation->mDvk;
 
     // Check if the dispatch table has everything 1.1 related
     if (!vulkan_dispatch_check_device_VK_VERSION_1_0(dvk)) {
@@ -1383,45 +1480,45 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         }
     }
 
-    if (sVkEmulation->deviceInfo.supportsExternalMemoryImport) {
-        sVkEmulation->deviceInfo.getImageMemoryRequirements2Func =
+    if (emulation->mDeviceInfo.supportsExternalMemoryImport) {
+        emulation->mDeviceInfo.getImageMemoryRequirements2Func =
             reinterpret_cast<PFN_vkGetImageMemoryRequirements2KHR>(
-                dvk->vkGetDeviceProcAddr(sVkEmulation->device, "vkGetImageMemoryRequirements2KHR"));
-        if (!sVkEmulation->deviceInfo.getImageMemoryRequirements2Func) {
+                dvk->vkGetDeviceProcAddr(emulation->mDevice, "vkGetImageMemoryRequirements2KHR"));
+        if (!emulation->mDeviceInfo.getImageMemoryRequirements2Func) {
             VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER,
                                                  "Cannot find vkGetImageMemoryRequirements2KHR.");
         }
-        sVkEmulation->deviceInfo.getBufferMemoryRequirements2Func =
-            reinterpret_cast<PFN_vkGetBufferMemoryRequirements2KHR>(dvk->vkGetDeviceProcAddr(
-                sVkEmulation->device, "vkGetBufferMemoryRequirements2KHR"));
-        if (!sVkEmulation->deviceInfo.getBufferMemoryRequirements2Func) {
+        emulation->mDeviceInfo.getBufferMemoryRequirements2Func =
+            reinterpret_cast<PFN_vkGetBufferMemoryRequirements2KHR>(
+                dvk->vkGetDeviceProcAddr(emulation->mDevice, "vkGetBufferMemoryRequirements2KHR"));
+        if (!emulation->mDeviceInfo.getBufferMemoryRequirements2Func) {
             VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER,
                                                  "Cannot find vkGetBufferMemoryRequirements2KHR");
         }
     }
-    if (sVkEmulation->deviceInfo.supportsExternalMemoryExport) {
+    if (emulation->mDeviceInfo.supportsExternalMemoryExport) {
 #ifdef _WIN32
         // Use vkGetMemoryWin32HandleKHR
-        sVkEmulation->deviceInfo.getMemoryHandleFunc =
+        emulation->mDeviceInfo.getMemoryHandleFunc =
             reinterpret_cast<PFN_vkGetMemoryWin32HandleKHR>(
-                dvk->vkGetDeviceProcAddr(sVkEmulation->device, "vkGetMemoryWin32HandleKHR"));
-        if (!sVkEmulation->deviceInfo.getMemoryHandleFunc) {
+                dvk->vkGetDeviceProcAddr(emulation->mDevice, "vkGetMemoryWin32HandleKHR"));
+        if (!emulation->mDeviceInfo.getMemoryHandleFunc) {
             VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER,
                                                  "Cannot find vkGetMemoryWin32HandleKHR");
         }
 #else
-        if (sVkEmulation->instanceSupportsMoltenVK) {
+        if (emulation->mInstanceSupportsMoltenVK) {
             // We'll use vkGetMemoryMetalHandleEXT, no need to save into getMemoryHandleFunc
-            sVkEmulation->deviceInfo.getMemoryHandleFunc = nullptr;
-            if (!dvk->vkGetDeviceProcAddr(sVkEmulation->device, "vkGetMemoryMetalHandleEXT")) {
+            emulation->mDeviceInfo.getMemoryHandleFunc = nullptr;
+            if (!dvk->vkGetDeviceProcAddr(emulation->mDevice, "vkGetMemoryMetalHandleEXT")) {
                 VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER,
                                                      "Cannot find vkGetMemoryMetalHandleEXT");
             }
         } else {
             // Use vkGetMemoryFdKHR
-            sVkEmulation->deviceInfo.getMemoryHandleFunc = reinterpret_cast<PFN_vkGetMemoryFdKHR>(
-                dvk->vkGetDeviceProcAddr(sVkEmulation->device, "vkGetMemoryFdKHR"));
-            if (!sVkEmulation->deviceInfo.getMemoryHandleFunc) {
+            emulation->mDeviceInfo.getMemoryHandleFunc = reinterpret_cast<PFN_vkGetMemoryFdKHR>(
+                dvk->vkGetDeviceProcAddr(emulation->mDevice, "vkGetMemoryFdKHR"));
+            if (!emulation->mDeviceInfo.getMemoryHandleFunc) {
                 VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER,
                                                      "Cannot find vkGetMemoryFdKHR");
             }
@@ -1431,15 +1528,15 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
 
     VERBOSE("Vulkan logical device created and extension functions obtained.");
 
-    sVkEmulation->queueLock = std::make_shared<android::base::Lock>();
+    emulation->mQueueLock = std::make_shared<android::base::Lock>();
     {
-        android::base::AutoLock lock(*sVkEmulation->queueLock);
-        dvk->vkGetDeviceQueue(sVkEmulation->device,
-                              sVkEmulation->deviceInfo.graphicsQueueFamilyIndices[0], 0,
-                              &sVkEmulation->queue);
+        android::base::AutoLock queueLock(*emulation->mQueueLock);
+        dvk->vkGetDeviceQueue(emulation->mDevice,
+                              emulation->mDeviceInfo.graphicsQueueFamilyIndices[0], 0,
+                              &emulation->mQueue);
     }
 
-    sVkEmulation->queueFamilyIndex = sVkEmulation->deviceInfo.graphicsQueueFamilyIndices[0];
+    emulation->mQueueFamilyIndex = emulation->mDeviceInfo.graphicsQueueFamilyIndices[0];
 
     VERBOSE("Vulkan device queue obtained.");
 
@@ -1447,11 +1544,11 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
         0,
         VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
-        sVkEmulation->queueFamilyIndex,
+        emulation->mQueueFamilyIndex,
     };
 
-    VkResult poolCreateRes = dvk->vkCreateCommandPool(sVkEmulation->device, &poolCi, nullptr,
-                                                      &sVkEmulation->commandPool);
+    VkResult poolCreateRes =
+        dvk->vkCreateCommandPool(emulation->mDevice, &poolCi, nullptr, &emulation->mCommandPool);
 
     if (poolCreateRes != VK_SUCCESS) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(poolCreateRes,
@@ -1462,13 +1559,13 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     VkCommandBufferAllocateInfo cbAi = {
         VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
         0,
-        sVkEmulation->commandPool,
+        emulation->mCommandPool,
         VK_COMMAND_BUFFER_LEVEL_PRIMARY,
         1,
     };
 
     VkResult cbAllocRes =
-        dvk->vkAllocateCommandBuffers(sVkEmulation->device, &cbAi, &sVkEmulation->commandBuffer);
+        dvk->vkAllocateCommandBuffers(emulation->mDevice, &cbAi, &emulation->mCommandBuffer);
 
     if (cbAllocRes != VK_SUCCESS) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(cbAllocRes,
@@ -1482,8 +1579,8 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         0,
     };
 
-    VkResult fenceCreateRes = dvk->vkCreateFence(sVkEmulation->device, &fenceCi, nullptr,
-                                                 &sVkEmulation->commandBufferFence);
+    VkResult fenceCreateRes =
+        dvk->vkCreateFence(emulation->mDevice, &fenceCi, nullptr, &emulation->mCommandBufferFence);
 
     if (fenceCreateRes != VK_SUCCESS) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(
@@ -1501,7 +1598,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
         VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
         0,
         0,
-        sVkEmulation->staging.size,
+        emulation->mStaging.size,
         VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
         VK_SHARING_MODE_EXCLUSIVE,
         0,
@@ -1509,7 +1606,7 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     };
 
     VkResult bufCreateRes =
-        dvk->vkCreateBuffer(sVkEmulation->device, &bufCi, nullptr, &sVkEmulation->staging.buffer);
+        dvk->vkCreateBuffer(emulation->mDevice, &bufCi, nullptr, &emulation->mStaging.buffer);
 
     if (bufCreateRes != VK_SUCCESS) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(bufCreateRes,
@@ -1518,34 +1615,33 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     }
 
     VkMemoryRequirements memReqs;
-    dvk->vkGetBufferMemoryRequirements(sVkEmulation->device, sVkEmulation->staging.buffer,
-                                       &memReqs);
+    dvk->vkGetBufferMemoryRequirements(emulation->mDevice, emulation->mStaging.buffer, &memReqs);
 
-    sVkEmulation->staging.memory.size = memReqs.size;
+    emulation->mStaging.memory.size = memReqs.size;
 
     bool gotStagingTypeIndex =
-        getStagingMemoryTypeIndex(dvk, sVkEmulation->device, &sVkEmulation->deviceInfo.memProps,
-                                  &sVkEmulation->staging.memory.typeIndex);
+        getStagingMemoryTypeIndex(dvk, emulation->mDevice, &emulation->mDeviceInfo.memProps,
+                                  &emulation->mStaging.memory.typeIndex);
 
     if (!gotStagingTypeIndex) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER,
                                              "Failed to determine staging memory type index.");
     }
 
-    if (!((1 << sVkEmulation->staging.memory.typeIndex) & memReqs.memoryTypeBits)) {
+    if (!((1 << emulation->mStaging.memory.typeIndex) & memReqs.memoryTypeBits)) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(
             ABORT_REASON_OTHER,
             "Failed: Inconsistent determination of memory type index for staging buffer");
     }
 
-    if (!allocExternalMemory(dvk, &sVkEmulation->staging.memory, false /* not external */,
-                             kNullopt /* deviceAlignment */)) {
+    if (!emulation->allocExternalMemory(dvk, &emulation->mStaging.memory, false /* not external */,
+                                        kNullopt /* deviceAlignment */)) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(ABORT_REASON_OTHER,
                                              "Failed to allocate memory for staging buffer.");
     }
 
     VkResult stagingBufferBindRes = dvk->vkBindBufferMemory(
-        sVkEmulation->device, sVkEmulation->staging.buffer, sVkEmulation->staging.memory.memory, 0);
+        emulation->mDevice, emulation->mStaging.buffer, emulation->mStaging.memory.memory, 0);
 
     if (stagingBufferBindRes != VK_SUCCESS) {
         VK_EMU_INIT_RETURN_OR_ABORT_ON_ERROR(stagingBufferBindRes,
@@ -1554,144 +1650,259 @@ VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
     }
 
     if (debugUtilsAvailableAndRequested) {
-        sVkEmulation->debugUtilsAvailableAndRequested = true;
-        sVkEmulation->debugUtilsHelper =
-            DebugUtilsHelper::withUtilsEnabled(sVkEmulation->device, sVkEmulation->ivk);
+        emulation->mDebugUtilsAvailableAndRequested = true;
+        emulation->mDebugUtilsHelper =
+            DebugUtilsHelper::withUtilsEnabled(emulation->mDevice, emulation->mIvk);
 
-        sVkEmulation->debugUtilsHelper.addDebugLabel(sVkEmulation->instance, "AEMU_Instance");
-        sVkEmulation->debugUtilsHelper.addDebugLabel(sVkEmulation->device, "AEMU_Device");
-        sVkEmulation->debugUtilsHelper.addDebugLabel(sVkEmulation->staging.buffer,
-                                                     "AEMU_StagingBuffer");
-        sVkEmulation->debugUtilsHelper.addDebugLabel(sVkEmulation->commandBuffer,
-                                                     "AEMU_CommandBuffer");
+        emulation->mDebugUtilsHelper.addDebugLabel(emulation->mInstance, "AEMU_Instance");
+        emulation->mDebugUtilsHelper.addDebugLabel(emulation->mDevice, "AEMU_Device");
+        emulation->mDebugUtilsHelper.addDebugLabel(emulation->mStaging.buffer,
+                                                   "AEMU_StagingBuffer");
+        emulation->mDebugUtilsHelper.addDebugLabel(emulation->mCommandBuffer, "AEMU_CommandBuffer");
     }
 
     if (commandBufferCheckpointsSupportedAndRequested) {
-        sVkEmulation->commandBufferCheckpointsSupportedAndRequested = true;
-        sVkEmulation->deviceLostHelper.enableWithNvidiaDeviceDiagnosticCheckpoints();
+        emulation->mCommandBufferCheckpointsSupportedAndRequested = true;
+        emulation->mDeviceLostHelper.enableWithNvidiaDeviceDiagnosticCheckpoints();
     }
 
     VERBOSE("Vulkan global emulation state successfully initialized.");
-    sVkEmulation->live = true;
 
-    sVkEmulation->transferQueueCommandBufferPool.resize(0);
+    emulation->mTransferQueueCommandBufferPool.resize(0);
 
-    return sVkEmulation;
+    return emulation;
 }
 
-std::optional<VkEmulation::RepresentativeColorBufferMemoryTypeInfo>
-findRepresentativeColorBufferMemoryTypeIndexLocked();
-
-void initVkEmulationFeatures(std::unique_ptr<VkEmulationFeatures> features) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        ERR("VkEmulation is either not initialized or destroyed.");
-        return;
-    }
-
-    AutoLock lock(sVkEmulationLock);
+void VkEmulation::initFeatures(Features features) {
+    std::lock_guard<std::mutex> lock(mMutex);
     INFO("Initializing VkEmulation features:");
-    INFO("    glInteropSupported: %s", features->glInteropSupported ? "true" : "false");
-    INFO("    useDeferredCommands: %s", features->deferredCommands ? "true" : "false");
+    INFO("    glInteropSupported: %s", features.glInteropSupported ? "true" : "false");
+    INFO("    useDeferredCommands: %s", features.deferredCommands ? "true" : "false");
     INFO("    createResourceWithRequirements: %s",
-         features->createResourceWithRequirements ? "true" : "false");
-    INFO("    useVulkanComposition: %s", features->useVulkanComposition ? "true" : "false");
-    INFO("    useVulkanNativeSwapchain: %s", features->useVulkanNativeSwapchain ? "true" : "false");
-    INFO("    enable guestRenderDoc: %s", features->guestRenderDoc ? "true" : "false");
-    INFO("    ASTC LDR emulation mode: %d", features->astcLdrEmulationMode);
-    INFO("    enable ETC2 emulation: %s", features->enableEtc2Emulation ? "true" : "false");
-    INFO("    enable Ycbcr emulation: %s", features->enableYcbcrEmulation ? "true" : "false");
-    INFO("    guestVulkanOnly: %s", features->guestVulkanOnly ? "true" : "false");
-    INFO("    useDedicatedAllocations: %s", features->useDedicatedAllocations ? "true" : "false");
-    sVkEmulation->deviceInfo.glInteropSupported = features->glInteropSupported;
-    sVkEmulation->useDeferredCommands = features->deferredCommands;
-    sVkEmulation->useCreateResourcesWithRequirements = features->createResourceWithRequirements;
-    sVkEmulation->guestRenderDoc = std::move(features->guestRenderDoc);
-    sVkEmulation->astcLdrEmulationMode = features->astcLdrEmulationMode;
-    sVkEmulation->enableEtc2Emulation = features->enableEtc2Emulation;
-    sVkEmulation->enableYcbcrEmulation = features->enableYcbcrEmulation;
-    sVkEmulation->guestVulkanOnly = features->guestVulkanOnly;
-    sVkEmulation->useDedicatedAllocations = features->useDedicatedAllocations;
-
-    if (features->useVulkanComposition) {
-        if (sVkEmulation->compositorVk) {
+         features.createResourceWithRequirements ? "true" : "false");
+    INFO("    useVulkanComposition: %s", features.useVulkanComposition ? "true" : "false");
+    INFO("    useVulkanNativeSwapchain: %s", features.useVulkanNativeSwapchain ? "true" : "false");
+    INFO("    enable guestRenderDoc: %s", features.guestRenderDoc ? "true" : "false");
+    INFO("    ASTC LDR emulation mode: %s", string_AstcEmulationMode(features.astcLdrEmulationMode));
+    INFO("    enable ETC2 emulation: %s", features.enableEtc2Emulation ? "true" : "false");
+    INFO("    enable Ycbcr emulation: %s", features.enableYcbcrEmulation ? "true" : "false");
+    INFO("    guestVulkanOnly: %s", features.guestVulkanOnly ? "true" : "false");
+    INFO("    useDedicatedAllocations: %s", features.useDedicatedAllocations ? "true" : "false");
+    mDeviceInfo.glInteropSupported = features.glInteropSupported;
+    mUseDeferredCommands = features.deferredCommands;
+    mUseCreateResourcesWithRequirements = features.createResourceWithRequirements;
+    mGuestRenderDoc = std::move(features.guestRenderDoc);
+    mAstcLdrEmulationMode = features.astcLdrEmulationMode;
+    mEnableEtc2Emulation = features.enableEtc2Emulation;
+    mEnableYcbcrEmulation = features.enableYcbcrEmulation;
+    mGuestVulkanOnly = features.guestVulkanOnly;
+    mUseDedicatedAllocations = features.useDedicatedAllocations;
+
+    if (features.useVulkanComposition) {
+        if (mCompositorVk) {
             ERR("Reset VkEmulation::compositorVk.");
         }
-        sVkEmulation->compositorVk =
-            CompositorVk::create(*sVkEmulation->ivk, sVkEmulation->device, sVkEmulation->physdev,
-                                 sVkEmulation->queue, sVkEmulation->queueLock,
-                                 sVkEmulation->queueFamilyIndex, 3, sVkEmulation->debugUtilsHelper);
+        mCompositorVk = CompositorVk::create(*mIvk, mDevice, mPhysicalDevice, mQueue, mQueueLock,
+                                             mQueueFamilyIndex, 3, mDebugUtilsHelper);
     }
 
-    if (features->useVulkanNativeSwapchain) {
-        if (sVkEmulation->displayVk) {
+    if (features.useVulkanNativeSwapchain) {
+        if (mDisplayVk) {
             ERR("Reset VkEmulation::displayVk.");
         }
-        sVkEmulation->displayVk = std::make_unique<DisplayVk>(
-            *sVkEmulation->ivk, sVkEmulation->physdev, sVkEmulation->queueFamilyIndex,
-            sVkEmulation->queueFamilyIndex, sVkEmulation->device, sVkEmulation->queue,
-            sVkEmulation->queueLock, sVkEmulation->queue, sVkEmulation->queueLock);
-    }
-
-    sVkEmulation->representativeColorBufferMemoryTypeInfo =
-        findRepresentativeColorBufferMemoryTypeIndexLocked();
-    if (sVkEmulation->representativeColorBufferMemoryTypeInfo) {
-        VERBOSE(
-            "Representative ColorBuffer memory type using host memory type index %d "
-            "and guest memory type index :%d",
-            sVkEmulation->representativeColorBufferMemoryTypeInfo->hostMemoryTypeIndex,
-            sVkEmulation->representativeColorBufferMemoryTypeInfo->guestMemoryTypeIndex);
-    } else {
+        mDisplayVk = std::make_unique<DisplayVk>(*mIvk, mPhysicalDevice, mQueueFamilyIndex,
+                                                 mQueueFamilyIndex, mDevice, mQueue, mQueueLock,
+                                                 mQueue, mQueueLock);
+    }
+
+    auto representativeInfo = findRepresentativeColorBufferMemoryTypeIndexLocked();
+    if (!representativeInfo) {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
             << "Failed to find memory type for ColorBuffers.";
     }
+    mRepresentativeColorBufferMemoryTypeInfo = *representativeInfo;
+    VERBOSE(
+        "Representative ColorBuffer memory type using host memory type index %d "
+        "and guest memory type index :%d",
+        mRepresentativeColorBufferMemoryTypeInfo.hostMemoryTypeIndex,
+        mRepresentativeColorBufferMemoryTypeInfo.guestMemoryTypeIndex);
 }
 
-VkEmulation* getGlobalVkEmulation() {
-    if (sVkEmulation && !sVkEmulation->live) return nullptr;
-    return sVkEmulation;
+VkEmulation::~VkEmulation() {
+    std::lock_guard<std::mutex> lock(mMutex);
+
+    mCompositorVk.reset();
+    mDisplayVk.reset();
+
+    freeExternalMemoryLocked(mDvk, &mStaging.memory);
+
+    mDvk->vkDestroyBuffer(mDevice, mStaging.buffer, nullptr);
+    mDvk->vkDestroyFence(mDevice, mCommandBufferFence, nullptr);
+    mDvk->vkFreeCommandBuffers(mDevice, mCommandPool, 1, &mCommandBuffer);
+    mDvk->vkDestroyCommandPool(mDevice, mCommandPool, nullptr);
+
+    mIvk->vkDestroyDevice(mDevice, nullptr);
+
+    mGvk->vkDestroyInstance(mInstance, nullptr);
 }
 
-void teardownGlobalVkEmulation() {
-    if (!sVkEmulation) return;
+bool VkEmulation::isYcbcrEmulationEnabled() const { return mEnableYcbcrEmulation; }
 
-    // Don't try to tear down something that did not set up completely; too risky
-    if (!sVkEmulation->live) return;
+bool VkEmulation::isEtc2EmulationEnabled() const { return mEnableEtc2Emulation; }
 
-    sVkEmulation->compositorVk.reset();
-    sVkEmulation->displayVk.reset();
+bool VkEmulation::deferredCommandsEnabled() const { return mUseDeferredCommands; }
 
-    freeExternalMemoryLocked(sVkEmulation->dvk, &sVkEmulation->staging.memory);
+bool VkEmulation::createResourcesWithRequirementsEnabled() const {
+    return mUseCreateResourcesWithRequirements;
+}
 
-    sVkEmulation->dvk->vkDestroyBuffer(sVkEmulation->device, sVkEmulation->staging.buffer, nullptr);
+bool VkEmulation::supportsGetPhysicalDeviceProperties2() const {
+    return mInstanceSupportsGetPhysicalDeviceProperties2;
+}
 
-    sVkEmulation->dvk->vkDestroyFence(sVkEmulation->device, sVkEmulation->commandBufferFence,
-                                      nullptr);
+bool VkEmulation::supportsExternalMemoryCapabilities() const {
+    return mInstanceSupportsExternalMemoryCapabilities;
+}
 
-    sVkEmulation->dvk->vkFreeCommandBuffers(sVkEmulation->device, sVkEmulation->commandPool, 1,
-                                            &sVkEmulation->commandBuffer);
+bool VkEmulation::supportsExternalSemaphoreCapabilities() const {
+    return mInstanceSupportsExternalSemaphoreCapabilities;
+}
 
-    sVkEmulation->dvk->vkDestroyCommandPool(sVkEmulation->device, sVkEmulation->commandPool,
-                                            nullptr);
+bool VkEmulation::supportsExternalFenceCapabilities() const {
+    return mInstanceSupportsExternalFenceCapabilities;
+}
 
-    sVkEmulation->ivk->vkDestroyDevice(sVkEmulation->device, nullptr);
-    sVkEmulation->gvk->vkDestroyInstance(sVkEmulation->instance, nullptr);
+bool VkEmulation::supportsSurfaces() const { return mInstanceSupportsSurface; }
 
-    VkDecoderGlobalState::reset();
+bool VkEmulation::supportsMoltenVk() const { return mInstanceSupportsMoltenVK; }
 
-    sVkEmulation->live = false;
-    delete sVkEmulation;
-    sVkEmulation = nullptr;
+bool VkEmulation::supportsPhysicalDeviceIDProperties() const {
+    return mInstanceSupportsPhysicalDeviceIDProperties;
 }
 
-void onVkDeviceLost() { VkDecoderGlobalState::get()->on_DeviceLost(); }
+bool VkEmulation::supportsPrivateData() const { return mDeviceInfo.supportsPrivateData; }
 
-std::unique_ptr<gfxstream::DisplaySurface> createDisplaySurface(FBNativeWindowType window,
-                                                                uint32_t width, uint32_t height) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        return nullptr;
+bool VkEmulation::supportsExternalMemoryImport() const {
+    return mDeviceInfo.supportsExternalMemoryImport;
+}
+
+bool VkEmulation::supportsDmaBuf() const { return mDeviceInfo.supportsDmaBuf; }
+
+bool VkEmulation::supportsExternalMemoryHostProperties() const {
+    return mDeviceInfo.supportsExternalMemoryHostProps;
+}
+
+std::optional<VkPhysicalDeviceRobustness2FeaturesEXT> VkEmulation::getRobustness2Features() const {
+    return mDeviceInfo.robustness2Features;
+}
+
+VkPhysicalDeviceExternalMemoryHostPropertiesEXT VkEmulation::externalMemoryHostProperties() const {
+    return mDeviceInfo.externalMemoryHostProps;
+}
+
+bool VkEmulation::isGuestVulkanOnly() const { return mGuestVulkanOnly; }
+
+bool VkEmulation::commandBufferCheckpointsEnabled() const {
+    return mCommandBufferCheckpointsSupportedAndRequested;
+}
+
+bool VkEmulation::supportsSamplerYcbcrConversion() const {
+    return mDeviceInfo.supportsSamplerYcbcrConversion;
+}
+
+bool VkEmulation::debugUtilsEnabled() const { return mDebugUtilsAvailableAndRequested; }
+
+DebugUtilsHelper& VkEmulation::getDebugUtilsHelper() { return mDebugUtilsHelper; }
+
+DeviceLostHelper& VkEmulation::getDeviceLostHelper() { return mDeviceLostHelper; }
+
+const gfxstream::host::FeatureSet& VkEmulation::getFeatures() const { return mFeatures; }
+
+const gfxstream::host::BackendCallbacks& VkEmulation::getCallbacks() const { return mCallbacks; }
+
+AstcEmulationMode VkEmulation::getAstcLdrEmulationMode() const { return mAstcLdrEmulationMode; }
+
+emugl::RenderDocWithMultipleVkInstances* VkEmulation::getRenderDoc() {
+    return mGuestRenderDoc.get();
+}
+
+Compositor* VkEmulation::getCompositor() { return mCompositorVk.get(); }
+
+DisplayVk* VkEmulation::getDisplay() { return mDisplayVk.get(); }
+
+VkInstance VkEmulation::getInstance() { return mInstance; }
+
+std::optional<std::array<uint8_t, VK_UUID_SIZE>> VkEmulation::getDeviceUuid() {
+    if (!supportsPhysicalDeviceIDProperties()) {
+        return std::nullopt;
+    }
+
+    std::array<uint8_t, VK_UUID_SIZE> uuid;
+    std::memcpy(uuid.data(), mDeviceInfo.idProps.deviceUUID, VK_UUID_SIZE);
+    return uuid;
+}
+
+std::optional<std::array<uint8_t, VK_UUID_SIZE>> VkEmulation::getDriverUuid() {
+    if (!supportsPhysicalDeviceIDProperties()) {
+        return std::nullopt;
     }
 
-    auto surfaceVk = DisplaySurfaceVk::create(*sVkEmulation->ivk, sVkEmulation->instance, window);
+    std::array<uint8_t, VK_UUID_SIZE> uuid;
+    std::memcpy(uuid.data(), mDeviceInfo.idProps.driverUUID, VK_UUID_SIZE);
+    return uuid;
+}
+
+std::string VkEmulation::getGpuVendor() const { return mDeviceInfo.driverVendor; }
+
+std::string VkEmulation::getGpuName() const { return mDeviceInfo.physdevProps.deviceName; }
+
+std::string VkEmulation::getGpuVersionString() const {
+    std::stringstream builder;
+    builder << "Vulkan "                                            //
+            << VK_API_VERSION_MAJOR(mVulkanInstanceVersion) << "."  //
+            << VK_API_VERSION_MINOR(mVulkanInstanceVersion) << "."  //
+            << VK_API_VERSION_PATCH(mVulkanInstanceVersion) << " "  //
+            << getGpuVendor() << " "                                //
+            << getGpuName();
+    return builder.str();
+}
+
+std::string VkEmulation::getInstanceExtensionsString() const {
+    std::stringstream builder;
+    for (const auto& instanceExtension : mInstanceExtensions) {
+        if (builder.tellp() != 0) {
+            builder << " ";
+        }
+        builder << instanceExtension.extensionName;
+    }
+    return builder.str();
+}
+
+std::string VkEmulation::getDeviceExtensionsString() const {
+    std::stringstream builder;
+    for (const auto& deviceExtension : mDeviceInfo.extensions) {
+        if (builder.tellp() != 0) {
+            builder << " ";
+        }
+        builder << deviceExtension.extensionName;
+    }
+    return builder.str();
+}
+
+const VkPhysicalDeviceProperties VkEmulation::getPhysicalDeviceProperties() const {
+    return mDeviceInfo.physdevProps;
+}
+
+VkEmulation::RepresentativeColorBufferMemoryTypeInfo
+VkEmulation::getRepresentativeColorBufferMemoryTypeInfo() const {
+    return mRepresentativeColorBufferMemoryTypeInfo;
+}
+
+void VkEmulation::onVkDeviceLost() { VkDecoderGlobalState::get()->on_DeviceLost(); }
+
+std::unique_ptr<gfxstream::DisplaySurface> VkEmulation::createDisplaySurface(
+    FBNativeWindowType window, uint32_t width, uint32_t height) {
+    auto surfaceVk = DisplaySurfaceVk::create(*mIvk, mInstance, window);
     if (!surfaceVk) {
         ERR("Failed to create DisplaySurfaceVk.");
         return nullptr;
@@ -1701,7 +1912,8 @@ std::unique_ptr<gfxstream::DisplaySurface> createDisplaySurface(FBNativeWindowTy
 }
 
 #ifdef __APPLE__
-static MTLResource_id getMtlResourceFromVkDeviceMemory(VulkanDispatch* vk, VkDeviceMemory memory) {
+MTLResource_id VkEmulation::getMtlResourceFromVkDeviceMemory(VulkanDispatch* vk,
+                                                             VkDeviceMemory memory) {
     if (memory == VK_NULL_HANDLE) {
         WARN("Requested metal resource handle for null memory!");
         return nullptr;
@@ -1715,7 +1927,7 @@ static MTLResource_id getMtlResourceFromVkDeviceMemory(VulkanDispatch* vk, VkDev
     };
 
     MTLResource_id outputHandle = nullptr;
-    vk->vkGetMemoryMetalHandleEXT(sVkEmulation->device, &getMetalHandleInfo, &outputHandle);
+    vk->vkGetMemoryMetalHandleEXT(mDevice, &getMetalHandleInfo, &outputHandle);
     if (outputHandle == nullptr) {
         ERR("vkGetMemoryMetalHandleEXT returned null");
     }
@@ -1724,14 +1936,15 @@ static MTLResource_id getMtlResourceFromVkDeviceMemory(VulkanDispatch* vk, VkDev
 #endif
 
 // Precondition: sVkEmulation has valid device support info
-bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* info,
-                         bool actuallyExternal, Optional<uint64_t> deviceAlignment,
-                         Optional<VkBuffer> bufferForDedicatedAllocation,
-                         Optional<VkImage> imageForDedicatedAllocation) {
+bool VkEmulation::allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* info,
+                                      bool actuallyExternal, Optional<uint64_t> deviceAlignment,
+                                      Optional<VkBuffer> bufferForDedicatedAllocation,
+                                      Optional<VkImage> imageForDedicatedAllocation) {
     VkExportMemoryAllocateInfo exportAi = {
         .sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
         .pNext = nullptr,
-        .handleTypes = VK_EXT_MEMORY_HANDLE_TYPE_BIT,
+        .handleTypes =
+            static_cast<VkExternalMemoryHandleTypeFlags>(getDefaultExternalMemoryHandleType()),
     };
 
     VkMemoryDedicatedAllocateInfo dedicatedAllocInfo = {
@@ -1750,15 +1963,14 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
 
     auto allocInfoChain = vk_make_chain_iterator(&allocInfo);
 
-
-    if (sVkEmulation->deviceInfo.supportsExternalMemoryExport && actuallyExternal) {
+    if (mDeviceInfo.supportsExternalMemoryExport && actuallyExternal) {
 #ifdef __APPLE__
-        if (sVkEmulation->instanceSupportsMoltenVK) {
+        if (mInstanceSupportsMoltenVK) {
             // Change handle type for metal resources
             exportAi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
         }
 #endif
-        if (sVkEmulation->deviceInfo.supportsDmaBuf) {
+        if (mDeviceInfo.supportsDmaBuf) {
             exportAi.handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
         }
 
@@ -1781,21 +1993,20 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
     constexpr size_t kMaxAllocationAttempts = 20u;
 
     while (!memoryAllocated) {
-        VkResult allocRes =
-            vk->vkAllocateMemory(sVkEmulation->device, &allocInfo, nullptr, &info->memory);
+        VkResult allocRes = vk->vkAllocateMemory(mDevice, &allocInfo, nullptr, &info->memory);
 
         if (allocRes != VK_SUCCESS) {
-            VERBOSE("allocExternalMemory: failed in vkAllocateMemory: %s",
-                    string_VkResult(allocRes));
+            VERBOSE("%s: failed in vkAllocateMemory: %s",
+                    __func__, string_VkResult(allocRes));
             break;
         }
 
-        if (sVkEmulation->deviceInfo.memProps.memoryTypes[info->typeIndex].propertyFlags &
+        if (mDeviceInfo.memProps.memoryTypes[info->typeIndex].propertyFlags &
             VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
-            VkResult mapRes = vk->vkMapMemory(sVkEmulation->device, info->memory, 0, info->size, 0,
-                                              &info->mappedPtr);
+            VkResult mapRes =
+                vk->vkMapMemory(mDevice, info->memory, 0, info->size, 0, &info->mappedPtr);
             if (mapRes != VK_SUCCESS) {
-                VERBOSE("allocExternalMemory: failed in vkMapMemory: %s", string_VkResult(mapRes));
+                VERBOSE("%s: failed in vkMapMemory: %s", __func__, string_VkResult(mapRes));
                 break;
             }
         }
@@ -1820,14 +2031,14 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
         } else {
             allocationAttempts.push_back(info->memory);
 
-            VERBOSE("allocExternalMemory: attempt #%zu failed; deviceAlignment: %" PRIu64
+            VERBOSE("%s: attempt #%zu failed; deviceAlignment: %" PRIu64
                     ", mappedPtrPageOffset: %" PRIu64,
-                    allocationAttempts.size(), deviceAlignment.valueOr(0), mappedPtrPageOffset);
+                    __func__, allocationAttempts.size(), deviceAlignment.valueOr(0), mappedPtrPageOffset);
 
             if (allocationAttempts.size() >= kMaxAllocationAttempts) {
                 VERBOSE(
-                    "allocExternalMemory: unable to allocate memory with CPU mapped ptr aligned to "
-                    "page");
+                    "%s: unable to allocate memory with CPU mapped ptr aligned to "
+                    "page", __func__);
                 break;
             }
         }
@@ -1835,17 +2046,16 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
 
     // clean up previous failed attempts
     for (const auto& mem : allocationAttempts) {
-        vk->vkFreeMemory(sVkEmulation->device, mem, nullptr /* allocator */);
+        vk->vkFreeMemory(mDevice, mem, nullptr /* allocator */);
     }
     if (!memoryAllocated) {
         return false;
     }
 
-    if (!sVkEmulation->deviceInfo.supportsExternalMemoryExport || !actuallyExternal) {
+    if (!mDeviceInfo.supportsExternalMemoryExport || !actuallyExternal) {
         return true;
     }
 
-    VkExternalMemoryHandleTypeFlagBits vkHandleType = VK_EXT_MEMORY_HANDLE_TYPE_BIT;
     uint32_t streamHandleType = 0;
     VkResult exportRes = VK_SUCCESS;
     bool validHandle = false;
@@ -1854,18 +2064,21 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
         VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
         0,
         info->memory,
-        vkHandleType,
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
     };
 
-    exportRes = sVkEmulation->deviceInfo.getMemoryHandleFunc(
-        sVkEmulation->device, &getWin32HandleInfo, &info->externalHandle);
-    validHandle = (VK_EXT_MEMORY_HANDLE_INVALID != info->externalHandle);
-    info->streamHandleType = STREAM_MEM_HANDLE_TYPE_OPAQUE_WIN32;
-#elif !defined(__QNX__)
+    HANDLE exportHandle = NULL;
+    exportRes = mDeviceInfo.getMemoryHandleFunc(mDevice, &getWin32HandleInfo, &exportHandle);
+    validHandle = (VK_SUCCESS == exportRes) && (NULL != exportHandle);
+    info->handleInfo = ExternalHandleInfo{
+        .handle = reinterpret_cast<ExternalHandleType>(exportHandle),
+        .streamHandleType = STREAM_HANDLE_TYPE_MEM_OPAQUE_WIN32,
+    };
+#else
 
     bool opaqueFd = true;
 #if defined(__APPLE__)
-    if (sVkEmulation->instanceSupportsMoltenVK) {
+    if (mInstanceSupportsMoltenVK) {
         opaqueFd = false;
         info->externalMetalHandle = getMtlResourceFromVkDeviceMemory(vk, info->memory);
         validHandle = (nullptr != info->externalMetalHandle);
@@ -1879,11 +2092,12 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
 #endif
 
     if (opaqueFd) {
-        if (sVkEmulation->deviceInfo.supportsDmaBuf) {
+        streamHandleType = STREAM_HANDLE_TYPE_MEM_OPAQUE_FD;
+        VkExternalMemoryHandleTypeFlagBits vkHandleType =
+            VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        if (mDeviceInfo.supportsDmaBuf) {
             vkHandleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
-            info->streamHandleType = STREAM_MEM_HANDLE_TYPE_DMABUF;
-        } else {
-            info->streamHandleType = STREAM_MEM_HANDLE_TYPE_OPAQUE_FD;
+            streamHandleType = STREAM_HANDLE_TYPE_MEM_DMABUF;
         }
 
         VkMemoryGetFdInfoKHR getFdInfo = {
@@ -1892,50 +2106,63 @@ bool allocExternalMemory(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* in
             info->memory,
             vkHandleType,
         };
-        exportRes = sVkEmulation->deviceInfo.getMemoryHandleFunc(sVkEmulation->device, &getFdInfo,
-                                                                 &info->externalHandle);
-        validHandle = (VK_EXT_MEMORY_HANDLE_INVALID != info->externalHandle);
+        int exportFd = -1;
+        exportRes = mDeviceInfo.getMemoryHandleFunc(mDevice, &getFdInfo, &exportFd);
+        validHandle = (VK_SUCCESS == exportRes) && (-1 != exportFd);
+        info->handleInfo = ExternalHandleInfo{
+            .handle = exportFd,
+            .streamHandleType = streamHandleType,
+        };
     }
 #endif
 
     if (exportRes != VK_SUCCESS || !validHandle) {
-        WARN("allocExternalMemory: Failed to get external memory, result: %s",
-             string_VkResult(exportRes));
+        WARN("%s: Failed to get external memory, result: %s",
+             __func__, string_VkResult(exportRes));
         return false;
     }
 
     return true;
 }
 
-void freeExternalMemoryLocked(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* info) {
+void VkEmulation::freeExternalMemoryLocked(VulkanDispatch* vk,
+                                           VkEmulation::ExternalMemoryInfo* info) {
     if (!info->memory) return;
 
-    if (sVkEmulation->deviceInfo.memProps.memoryTypes[info->typeIndex].propertyFlags &
+    if (mDeviceInfo.memProps.memoryTypes[info->typeIndex].propertyFlags &
         VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
-        if (sVkEmulation->occupiedGpas.find(info->gpa) != sVkEmulation->occupiedGpas.end()) {
-            sVkEmulation->occupiedGpas.erase(info->gpa);
+        if (mOccupiedGpas.find(info->gpa) != mOccupiedGpas.end()) {
+            mOccupiedGpas.erase(info->gpa);
             get_emugl_vm_operations().unmapUserBackedRam(info->gpa, info->sizeToPage);
             info->gpa = 0u;
         }
 
         if (info->mappedPtr != nullptr) {
-            vk->vkUnmapMemory(sVkEmulation->device, info->memory);
+            vk->vkUnmapMemory(mDevice, info->memory);
             info->mappedPtr = nullptr;
             info->pageAlignedHva = nullptr;
         }
     }
 
-    vk->vkFreeMemory(sVkEmulation->device, info->memory, nullptr);
+    vk->vkFreeMemory(mDevice, info->memory, nullptr);
 
     info->memory = VK_NULL_HANDLE;
 
-    if (info->externalHandle != VK_EXT_MEMORY_HANDLE_INVALID) {
+    if (info->handleInfo) {
 #ifdef _WIN32
-        CloseHandle(info->externalHandle);
-#elif !defined(__QNX__)
-        close(info->externalHandle);
+        CloseHandle(static_cast<HANDLE>(reinterpret_cast<void*>(info->handleInfo->handle)));
+#else
+        switch (info->handleInfo->streamHandleType) {
+            case STREAM_HANDLE_TYPE_MEM_OPAQUE_FD:
+            case STREAM_HANDLE_TYPE_MEM_DMABUF:
+                close(info->handleInfo->handle);
+                break;
+            case STREAM_HANDLE_TYPE_PLATFORM_SCREEN_BUFFER_QNX:
+            default:
+                break;
+        }
 #endif
-        info->externalHandle = VK_EXT_MEMORY_HANDLE_INVALID;
+        info->handleInfo = std::nullopt;
     }
 
 #if defined(__APPLE__)
@@ -1945,125 +2172,71 @@ void freeExternalMemoryLocked(VulkanDispatch* vk, VkEmulation::ExternalMemoryInf
 #endif
 }
 
-bool importExternalMemory(VulkanDispatch* vk, VkDevice targetDevice,
-                          const VkEmulation::ExternalMemoryInfo* info, VkDeviceMemory* out) {
+bool VkEmulation::importExternalMemory(VulkanDispatch* vk, VkDevice targetDevice,
+                                       const VkEmulation::ExternalMemoryInfo* info,
+                                       VkMemoryDedicatedAllocateInfo* dedicatedAllocInfoPtr,
+                                       VkDeviceMemory* out) {
     const void* importInfoPtr = nullptr;
+    auto handleInfo = info->handleInfo;
 #ifdef _WIN32
-    VkImportMemoryWin32HandleInfoKHR importInfo = {
-        VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
-        0,
-        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
-        info->externalHandle,
-        0,
-    };
-    importInfoPtr = &importInfo;
-#elif defined(__QNX__)
-    VkImportScreenBufferInfoQNX importInfo = {
-        VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
-        NULL,
-        info->externalHandle,
-    };
-    importInfoPtr = &importInfo;
-#else
-
-    bool opaqueFd = true;
-#ifdef __APPLE__
-    VkImportMemoryMetalHandleInfoEXT importInfoMetalInfo = {
-        VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
-        0,
-        VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT,
-        nullptr
-    };
-    if (sVkEmulation->instanceSupportsMoltenVK) {
-        opaqueFd = false;
-        importInfoMetalInfo.handle = info->externalMetalHandle;
-        importInfoPtr = &importInfoMetalInfo;
-    }
-#endif
-
-    VkImportMemoryFdInfoKHR importInfoFd = {
-        VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
-        0,
-        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
-        VK_EXT_MEMORY_HANDLE_INVALID,
-    };
-    if (opaqueFd) {
-        importInfoFd.fd = dupExternalMemory(info->externalHandle);
-        importInfoPtr = &importInfoFd;
-    }
-#endif
-    VkMemoryAllocateInfo allocInfo = {
-        VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
-        importInfoPtr,
-        info->size,
-        info->typeIndex,
-    };
-
-    VkResult res = vk->vkAllocateMemory(targetDevice, &allocInfo, nullptr, out);
-
-    if (res != VK_SUCCESS) {
-        ERR("importExternalMemory: Failed with %s", string_VkResult(res));
+    if (!handleInfo) {
+        ERR("importExternalMemory: external handle info is not available, cannot retrieve win32 "
+            "handle.");
         return false;
     }
-
-    return true;
-}
-
-bool importExternalMemoryDedicatedImage(VulkanDispatch* vk, VkDevice targetDevice,
-                                        const VkEmulation::ExternalMemoryInfo* info, VkImage image,
-                                        VkDeviceMemory* out) {
-    VkMemoryDedicatedAllocateInfo dedicatedInfo = {
-        VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
-        0,
-        image,
-        VK_NULL_HANDLE,
-    };
-
-    const void* importInfoPtr = nullptr;
-#ifdef _WIN32
     VkImportMemoryWin32HandleInfoKHR importInfo = {
         VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
-        &dedicatedInfo,
-        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
-        info->externalHandle,
+        dedicatedAllocInfoPtr,
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
+        static_cast<HANDLE>(reinterpret_cast<void*>(handleInfo->handle)),
         0,
     };
     importInfoPtr = &importInfo;
 #elif defined(__QNX__)
+    if (!handleInfo) {
+        ERR("importExternalMemory: external handle info is not available, cannot retrieve "
+            "screen_buffer_t handle.");
+        return false;
+    }
     VkImportScreenBufferInfoQNX importInfo = {
         VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
-        &dedicatedInfo,
-        info->externalHandle,
+        dedicatedAllocInfoPtr,
+        static_cast<screen_buffer_t>(reinterpret_cast<void*>(handleInfo->handle)),
     };
     importInfoPtr = &importInfo;
-#else
-
-    bool opaqueFd = true;
-#ifdef __APPLE__
+#elif defined(__APPLE__)
     VkImportMemoryMetalHandleInfoEXT importInfoMetalInfo = {
-        VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
-        &dedicatedInfo,
-        VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT,
-        nullptr
-    };
-    if (sVkEmulation->instanceSupportsMoltenVK) {
+        VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT, dedicatedAllocInfoPtr,
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT, nullptr};
+    if (mInstanceSupportsMoltenVK) {
         importInfoMetalInfo.handle = info->externalMetalHandle;
         importInfoPtr = &importInfoMetalInfo;
-        opaqueFd = false;
     }
 #endif
 
     VkImportMemoryFdInfoKHR importInfoFd = {
         VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
-        &dedicatedInfo,
-        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
+        dedicatedAllocInfoPtr,
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
         -1,
     };
-    if (opaqueFd) {
-        importInfoFd.fd = dupExternalMemory(info->externalHandle);
+    if (!importInfoPtr) {
+        if (!handleInfo) {
+            ERR("importExternalMemory: external handle info is not available, cannot retrieve "
+                "information required to duplicate the external handle.");
+            return false;
+        }
+        auto dupHandle = dupExternalMemory(handleInfo);
+        if (!dupHandle) {
+            ERR("importExternalMemory: Failed to duplicate handleInfo.handle: 0x%x, "
+                "streamHandleType: %d",
+                handleInfo->handle, handleInfo->streamHandleType);
+            return false;
+        }
+        importInfoFd.fd = dupHandle->handle;
         importInfoPtr = &importInfoFd;
     }
-#endif
+
     VkMemoryAllocateInfo allocInfo = {
         VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
         importInfoPtr,
@@ -2074,7 +2247,7 @@ bool importExternalMemoryDedicatedImage(VulkanDispatch* vk, VkDevice targetDevic
     VkResult res = vk->vkAllocateMemory(targetDevice, &allocInfo, nullptr, out);
 
     if (res != VK_SUCCESS) {
-        ERR("importExternalMemoryDedicatedImage: Failed with %s", string_VkResult(res));
+        ERR("importExternalMemory: Failed with %s", string_VkResult(res));
         return false;
     }
 
@@ -2094,7 +2267,7 @@ static VkFormat glFormat2VkFormat(GLint internalFormat) {
             // b/281550953
             // RGB8 is not supported on many vulkan drivers.
             // Try RGBA8 instead.
-            // Note: copyImageData() performs channel conversion for this case.
+            // Note: updateColorBufferFromBytesLocked() performs channel conversion for this case.
             return VK_FORMAT_R8G8B8A8_UNORM;
         case GL_RGB565:
             return VK_FORMAT_R5G6B5_UNORM_PACK16;
@@ -2105,8 +2278,19 @@ static VkFormat glFormat2VkFormat(GLint internalFormat) {
             return VK_FORMAT_R8G8B8A8_UNORM;
         case GL_RGB5_A1_OES:
             return VK_FORMAT_A1R5G5B5_UNORM_PACK16;
-        case GL_RGBA4_OES:
+        case GL_RGBA4_OES: {
+            // TODO: add R4G4B4A4 support to lavapipe, and check support programmatically
+            const bool lavapipe =
+                (android::base::getEnvironmentVariable("ANDROID_EMU_VK_ICD").compare("lavapipe") ==
+                 0);
+            if (lavapipe) {
+                // RGBA4 is not supported on lavapipe, use more widely available BGRA4 instead.
+                // Note: updateColorBufferFromBytesLocked() performs channel conversion for this
+                // case.
+                return VK_FORMAT_B4G4R4A4_UNORM_PACK16;
+            }
             return VK_FORMAT_R4G4B4A4_UNORM_PACK16;
+        }
         case GL_RGB10_A2:
         case GL_UNSIGNED_INT_10_10_10_2_OES:
             return VK_FORMAT_A2R10G10B10_UNORM_PACK32;
@@ -2137,10 +2321,10 @@ static VkFormat glFormat2VkFormat(GLint internalFormat) {
     }
 };
 
-static bool isFormatVulkanCompatible(GLenum internalFormat) {
+bool VkEmulation::isFormatVulkanCompatible(GLenum internalFormat) {
     VkFormat vkFormat = glFormat2VkFormat(internalFormat);
 
-    for (const auto& supportInfo : sVkEmulation->imageSupportInfo) {
+    for (const auto& supportInfo : mImageSupportInfo) {
         if (supportInfo.format == vkFormat && supportInfo.supported) {
             return true;
         }
@@ -2149,15 +2333,11 @@ static bool isFormatVulkanCompatible(GLenum internalFormat) {
     return false;
 }
 
-bool getColorBufferShareInfo(uint32_t colorBufferHandle, bool* glExported,
-                             bool* externalMemoryCompatible) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Vulkan emulation not available.";
-    }
+bool VkEmulation::getColorBufferShareInfo(uint32_t colorBufferHandle, bool* glExported,
+                                          bool* externalMemoryCompatible) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    AutoLock lock(sVkEmulationLock);
-
-    auto info = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto info = android::base::find(mColorBuffers, colorBufferHandle);
     if (!info) {
         return false;
     }
@@ -2167,10 +2347,12 @@ bool getColorBufferShareInfo(uint32_t colorBufferHandle, bool* glExported,
     return true;
 }
 
-bool getColorBufferAllocationInfoLocked(uint32_t colorBufferHandle, VkDeviceSize* outSize,
-                                        uint32_t* outMemoryTypeIndex,
-                                        bool* outMemoryIsDedicatedAlloc, void** outMappedPtr) {
-    auto info = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+bool VkEmulation::getColorBufferAllocationInfoLocked(uint32_t colorBufferHandle,
+                                                     VkDeviceSize* outSize,
+                                                     uint32_t* outMemoryTypeIndex,
+                                                     bool* outMemoryIsDedicatedAlloc,
+                                                     void** outMappedPtr) {
+    auto info = android::base::find(mColorBuffers, colorBufferHandle);
     if (!info) {
         return false;
     }
@@ -2194,14 +2376,11 @@ bool getColorBufferAllocationInfoLocked(uint32_t colorBufferHandle, VkDeviceSize
     return true;
 }
 
-bool getColorBufferAllocationInfo(uint32_t colorBufferHandle, VkDeviceSize* outSize,
-                                  uint32_t* outMemoryTypeIndex, bool* outMemoryIsDedicatedAlloc,
-                                  void** outMappedPtr) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Vulkan emulation not available.";
-    }
-
-    AutoLock lock(sVkEmulationLock);
+bool VkEmulation::getColorBufferAllocationInfo(uint32_t colorBufferHandle, VkDeviceSize* outSize,
+                                               uint32_t* outMemoryTypeIndex,
+                                               bool* outMemoryIsDedicatedAlloc,
+                                               void** outMappedPtr) {
+    std::lock_guard<std::mutex> lock(mMutex);
     return getColorBufferAllocationInfoLocked(colorBufferHandle, outSize, outMemoryTypeIndex,
                                               outMemoryIsDedicatedAlloc, outMappedPtr);
 }
@@ -2212,8 +2391,8 @@ bool getColorBufferAllocationInfo(uint32_t colorBufferHandle, VkDeviceSize* outS
 // Eg. this avoids returning a host coherent memory type when only device local
 // memory flag is requested, which may be slow or not support some other features,
 // such as association with optimal-tiling images on some implementations.
-static uint32_t getValidMemoryTypeIndex(uint32_t requiredMemoryTypeBits,
-                                        VkMemoryPropertyFlags memoryProperty = 0) {
+uint32_t VkEmulation::getValidMemoryTypeIndex(uint32_t requiredMemoryTypeBits,
+                                              VkMemoryPropertyFlags memoryProperty) {
     uint32_t secondBest = ~0;
     bool found = false;
     for (int32_t i = 0; i <= 31; i++) {
@@ -2223,7 +2402,7 @@ static uint32_t getValidMemoryTypeIndex(uint32_t requiredMemoryTypeBits,
         }
 
         const VkMemoryPropertyFlags memPropertyFlags =
-            sVkEmulation->deviceInfo.memProps.memoryTypes[i].propertyFlags;
+            mDeviceInfo.memProps.memoryTypes[i].propertyFlags;
 
         // Exact match, return immediately
         if (memPropertyFlags == memoryProperty) {
@@ -2251,10 +2430,10 @@ static uint32_t getValidMemoryTypeIndex(uint32_t requiredMemoryTypeBits,
 
 // pNext, sharingMode, queueFamilyIndexCount, pQueueFamilyIndices, and initialLayout won't be
 // filled.
-static std::unique_ptr<VkImageCreateInfo> generateColorBufferVkImageCreateInfo_locked(
+std::unique_ptr<VkImageCreateInfo> VkEmulation::generateColorBufferVkImageCreateInfoLocked(
     VkFormat format, uint32_t width, uint32_t height, VkImageTiling tiling) {
     const VkEmulation::ImageSupportInfo* maybeImageSupportInfo = nullptr;
-    for (const auto& supportInfo : sVkEmulation->imageSupportInfo) {
+    for (const auto& supportInfo : mImageSupportInfo) {
         if (supportInfo.format == format && supportInfo.supported) {
             maybeImageSupportInfo = &supportInfo;
             break;
@@ -2315,55 +2494,39 @@ static std::unique_ptr<VkImageCreateInfo> generateColorBufferVkImageCreateInfo_l
     });
 }
 
-std::unique_ptr<VkImageCreateInfo> generateColorBufferVkImageCreateInfo(VkFormat format,
-                                                                        uint32_t width,
-                                                                        uint32_t height,
-                                                                        VkImageTiling tiling) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Host Vulkan device lost";
-    }
-    AutoLock lock(sVkEmulationLock);
-    return generateColorBufferVkImageCreateInfo_locked(format, width, height, tiling);
+std::unique_ptr<VkImageCreateInfo> VkEmulation::generateColorBufferVkImageCreateInfo(
+    VkFormat format, uint32_t width, uint32_t height, VkImageTiling tiling) {
+    std::lock_guard<std::mutex> lock(mMutex);
+    return generateColorBufferVkImageCreateInfoLocked(format, width, height, tiling);
 }
 
-static bool updateExternalMemoryInfo(VK_EXT_MEMORY_HANDLE extMemHandle,
-                                     const VkMemoryRequirements* pMemReqs,
-                                     VkEmulation::ExternalMemoryInfo* pInfo) {
-    // Set externalHandle on the output info
-    pInfo->externalHandle = extMemHandle;
-    pInfo->dedicatedAllocation = true;
-
+bool VkEmulation::updateMemReqsForExtMem(std::optional<ExternalHandleInfo> extMemHandleInfo,
+                                         VkMemoryRequirements* pMemReqs) {
 #if defined(__QNX__)
-    VkScreenBufferPropertiesQNX screenBufferProps = {
-        VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX,
-        0,
-    };
-    auto vk = sVkEmulation->dvk;
-    VkResult queryRes =
-        vk->vkGetScreenBufferPropertiesQNX(sVkEmulation->device, extMemHandle, &screenBufferProps);
-    if (VK_SUCCESS != queryRes) {
-        ERR("Failed to get QNX Screen Buffer properties, VK error: %s", string_VkResult(queryRes));
-        return false;
-    }
-    if (!((1 << pInfo->typeIndex) & screenBufferProps.memoryTypeBits)) {
-        ERR("QNX Screen buffer can not be imported to memory (typeIndex=%d): %d", pInfo->typeIndex);
-        return false;
-    }
-    if (screenBufferProps.allocationSize < pMemReqs->size) {
-        ERR("QNX Screen buffer allocationSize (0x%lx) is not large enough for ColorBuffer image "
-            "size requirements (0x%lx)",
-            screenBufferProps.allocationSize, pMemReqs->size);
-        return false;
-    }
-    // Use the actual allocationSize for VkDeviceMemory object creation
-    pInfo->size = screenBufferProps.allocationSize;
-#endif
-
-#ifdef __APPLE__
-    // importExtMemoryHandleToVkColorBuffer is not supported with MoltenVK
-    if (sVkEmulation->instanceSupportsMoltenVK) {
-        WARN("Unexpected call to updateExternalMemoryInfo!");
-        pInfo->externalMetalHandle = nullptr;
+    if (STREAM_HANDLE_TYPE_PLATFORM_SCREEN_BUFFER_QNX == extMemHandleInfo->streamHandleType) {
+        VkScreenBufferPropertiesQNX screenBufferProps = {
+            VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX,
+            0,
+        };
+        VkResult queryRes = dvk->vkGetScreenBufferPropertiesQNX(
+            device, (screen_buffer_t)extMemHandleInfo->handle, &screenBufferProps);
+        if (VK_SUCCESS != queryRes) {
+            ERR("Failed to get QNX Screen Buffer properties, VK error: %s",
+                string_VkResult(queryRes));
+            return false;
+        }
+        if (screenBufferProps.allocationSize < pMemReqs->size) {
+            ERR("QNX Screen buffer allocationSize (0x%lx) is not large enough for ColorBuffer "
+                "image "
+                "size requirements (0x%lx)",
+                screenBufferProps.allocationSize, pMemReqs->size);
+            return false;
+        }
+        // Change memory requirements to the actual allocationSize; this may be larger
+        // than the original memory requirements
+        pMemReqs->size = screenBufferProps.allocationSize;
+        // Mask the memoryTypeBits with the ones available for screen_buffer import
+        pMemReqs->memoryTypeBits = screenBufferProps.memoryTypeBits;
     }
 #endif
 
@@ -2386,33 +2549,42 @@ static bool updateExternalMemoryInfo(VK_EXT_MEMORY_HANDLE extMemHandle,
 // buffers of one type index for image and one type index for buffer
 // to begin with, via filtering from the host.
 
-bool initializeVkColorBufferLocked(
-    uint32_t colorBufferHandle, VK_EXT_MEMORY_HANDLE extMemHandle = VK_EXT_MEMORY_HANDLE_INVALID) {
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
-    // Not initialized
-    if (!infoPtr) {
+bool VkEmulation::createVkColorBufferLocked(uint32_t width, uint32_t height, GLenum internalFormat,
+                                            FrameworkFormat frameworkFormat,
+                                            uint32_t colorBufferHandle, bool vulkanOnly,
+                                            uint32_t memoryProperty) {
+    if (!isFormatVulkanCompatible(internalFormat)) {
+        ERR("Failed to create Vk ColorBuffer: format:%d not compatible.", internalFormat);
         return false;
     }
-    // Already initialized Vulkan memory and other related Vulkan objects
-    if (infoPtr->initialized) {
-        return true;
-    }
 
-    if (!isFormatVulkanCompatible(infoPtr->internalFormat)) {
-        VERBOSE("Failed to create Vk ColorBuffer: format:%d not compatible.",
-                infoPtr->internalFormat);
+    // Check the ExternalObjectManager for an external memory handle provided for import
+    auto extMemHandleInfo =
+        ExternalObjectManager::get()->removeResourceExternalHandleInfo(colorBufferHandle);
+    if (extMemHandleInfo && !mDeviceInfo.supportsExternalMemoryImport) {
+        ERR("Failed to initialize Vk ColorBuffer -- extMemHandleInfo provided, but device does "
+            "not support externalMemoryImport");
         return false;
     }
 
-    const bool extMemImport = (VK_EXT_MEMORY_HANDLE_INVALID != extMemHandle);
-    if (extMemImport && !sVkEmulation->deviceInfo.supportsExternalMemoryImport) {
-        ERR("Failed to initialize Vk ColorBuffer -- extMemHandle provided, but device does "
-            "not support externalMemoryImport");
-        return false;
+    VkEmulation::ColorBufferInfo res;
+
+    res.handle = colorBufferHandle;
+    res.width = width;
+    res.height = height;
+    res.memoryProperty = memoryProperty;
+    res.internalFormat = internalFormat;
+    res.frameworkFormat = frameworkFormat;
+    res.frameworkStride = 0;
+
+    if (vulkanOnly) {
+        res.vulkanMode = VkEmulation::VulkanMode::VulkanOnly;
     }
 
+    mColorBuffers[colorBufferHandle] = res;
+    auto infoPtr = &mColorBuffers[colorBufferHandle];
+
     VkFormat vkFormat;
-    bool glCompatible = (infoPtr->frameworkFormat == FRAMEWORK_FORMAT_GL_COMPATIBLE);
     switch (infoPtr->frameworkFormat) {
         case FrameworkFormat::FRAMEWORK_FORMAT_GL_COMPATIBLE:
             vkFormat = glFormat2VkFormat(infoPtr->internalFormat);
@@ -2436,7 +2608,7 @@ bool initializeVkColorBufferLocked(
     VkImageTiling tiling = (infoPtr->memoryProperty & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
                                ? VK_IMAGE_TILING_LINEAR
                                : VK_IMAGE_TILING_OPTIMAL;
-    std::unique_ptr<VkImageCreateInfo> imageCi = generateColorBufferVkImageCreateInfo_locked(
+    std::unique_ptr<VkImageCreateInfo> imageCi = generateColorBufferVkImageCreateInfoLocked(
         vkFormat, infoPtr->width, infoPtr->height, tiling);
     // pNext will be filled later.
     if (imageCi == nullptr) {
@@ -2452,10 +2624,10 @@ bool initializeVkColorBufferLocked(
     VkExternalMemoryImageCreateInfo extImageCi = {
         VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
         0,
-        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
+        static_cast<VkExternalMemoryHandleTypeFlags>(getDefaultExternalMemoryHandleType()),
     };
 #if defined(__APPLE__)
-    if (sVkEmulation->instanceSupportsMoltenVK) {
+    if (mInstanceSupportsMoltenVK) {
         // Using a different handle type when in MoltenVK mode
         extImageCi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
     }
@@ -2463,27 +2635,27 @@ bool initializeVkColorBufferLocked(
 
     VkExternalMemoryImageCreateInfo* extImageCiPtr = nullptr;
 
-    if (extMemImport || sVkEmulation->deviceInfo.supportsExternalMemoryExport) {
+    if (extMemHandleInfo || mDeviceInfo.supportsExternalMemoryExport) {
         extImageCiPtr = &extImageCi;
     }
 
     imageCi->pNext = extImageCiPtr;
 
-    auto vk = sVkEmulation->dvk;
+    auto vk = mDvk;
 
-    VkResult createRes =
-        vk->vkCreateImage(sVkEmulation->device, imageCi.get(), nullptr, &infoPtr->image);
+    VkResult createRes = vk->vkCreateImage(mDevice, imageCi.get(), nullptr, &infoPtr->image);
     if (createRes != VK_SUCCESS) {
         VERBOSE("Failed to create Vulkan image for ColorBuffer %d, error: %s", colorBufferHandle,
                 string_VkResult(createRes));
         return false;
     }
 
-    bool useDedicated = sVkEmulation->useDedicatedAllocations;
+    bool useDedicated = mUseDedicatedAllocations;
 
     infoPtr->imageCreateInfoShallow = vk_make_orphan_copy(*imageCi);
-    infoPtr->currentQueueFamilyIndex = sVkEmulation->queueFamilyIndex;
+    infoPtr->currentQueueFamilyIndex = mQueueFamilyIndex;
 
+    VkMemoryRequirements memReqs;
     if (!useDedicated && vk->vkGetImageMemoryRequirements2KHR) {
         VkMemoryDedicatedRequirements dedicated_reqs{
             VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS, nullptr};
@@ -2491,11 +2663,30 @@ bool initializeVkColorBufferLocked(
 
         VkImageMemoryRequirementsInfo2 info{VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
                                             nullptr, infoPtr->image};
-        vk->vkGetImageMemoryRequirements2KHR(sVkEmulation->device, &info, &reqs);
+        vk->vkGetImageMemoryRequirements2KHR(mDevice, &info, &reqs);
         useDedicated = dedicated_reqs.requiresDedicatedAllocation;
-        infoPtr->memReqs = reqs.memoryRequirements;
+        memReqs = reqs.memoryRequirements;
     } else {
-        vk->vkGetImageMemoryRequirements(sVkEmulation->device, infoPtr->image, &infoPtr->memReqs);
+        vk->vkGetImageMemoryRequirements(mDevice, infoPtr->image, &memReqs);
+    }
+
+    if (extMemHandleInfo) {
+        infoPtr->memory.handleInfo = extMemHandleInfo;
+        infoPtr->memory.dedicatedAllocation = true;
+        // External memory might change the memReqs for allocation
+        if (!updateMemReqsForExtMem(extMemHandleInfo, &memReqs)) {
+            ERR("Failed to update memReqs for ColorBuffer memory allocation with external memory: "
+                "%d\n",
+                colorBufferHandle);
+            return false;
+        }
+#if defined(__APPLE_)
+        // importExtMemoryHandleToVkColorBuffer is not supported with MoltenVK
+        if (mInstanceSupportsMoltenVK) {
+            WARN("extMemhandleInfo import in ColorBuffer creation is unexpected.");
+            infoPtr->memory.externalMetalHandle = nullptr;
+        }
+#endif
     }
 
     // Currently we only care about two memory properties: DEVICE_LOCAL
@@ -2504,48 +2695,46 @@ bool initializeVkColorBufferLocked(
     infoPtr->memoryProperty = infoPtr->memoryProperty & (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
                                                          VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
 
-    infoPtr->memory.size = infoPtr->memReqs.size;
+    infoPtr->memory.size = memReqs.size;
 
     // Determine memory type.
     infoPtr->memory.typeIndex =
-        getValidMemoryTypeIndex(infoPtr->memReqs.memoryTypeBits, infoPtr->memoryProperty);
+        getValidMemoryTypeIndex(memReqs.memoryTypeBits, infoPtr->memoryProperty);
 
     const VkFormat imageVkFormat = infoPtr->imageCreateInfoShallow.format;
     VERBOSE(
-        "ColorBuffer %d, dimensions: %dx%d, format: %s, "
-        "allocation size and type index: %lu, %d, "
-        "allocated memory property: %d, "
-        "requested memory property: %d",
-        colorBufferHandle, infoPtr->width, infoPtr->height,
-        string_VkFormat(imageVkFormat),
+        "ColorBuffer %u, %ux%u, %s, "
+        "Memory [size: %llu, type: %d, props: %u / %u]",
+        colorBufferHandle, infoPtr->width, infoPtr->height, string_VkFormat(imageVkFormat),
         infoPtr->memory.size, infoPtr->memory.typeIndex,
-        sVkEmulation->deviceInfo.memProps.memoryTypes[infoPtr->memory.typeIndex].propertyFlags,
+        mDeviceInfo.memProps.memoryTypes[infoPtr->memory.typeIndex].propertyFlags,
         infoPtr->memoryProperty);
 
+    const bool isHostVisible = (infoPtr->memoryProperty & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
+    Optional<uint64_t> deviceAlignment =
+        (!extMemHandleInfo && isHostVisible) ? Optional<uint64_t>(memReqs.alignment) : kNullopt;
     Optional<VkImage> dedicatedImage = useDedicated ? Optional<VkImage>(infoPtr->image) : kNullopt;
-    if (VK_EXT_MEMORY_HANDLE_INVALID != extMemHandle) {
-        if (!updateExternalMemoryInfo(extMemHandle, &infoPtr->memReqs, &infoPtr->memory)) {
-            ERR("Failed to update external memory info for ColorBuffer: %d\n", colorBufferHandle);
-            return false;
-        }
+    if (extMemHandleInfo) {
+        VkMemoryDedicatedAllocateInfo dedicatedInfo = {
+            VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
+            nullptr,
+            VK_NULL_HANDLE,
+            VK_NULL_HANDLE,
+        };
+        VkMemoryDedicatedAllocateInfo* dedicatedInfoPtr = nullptr;
         if (useDedicated) {
-            if (!importExternalMemoryDedicatedImage(vk, sVkEmulation->device, &infoPtr->memory,
-                                                    *dedicatedImage, &infoPtr->memory.memory)) {
-                ERR("Failed to import external memory with dedicated Image for colorBuffer: %d\n",
-                    colorBufferHandle);
-                return false;
-            }
-        } else if (!importExternalMemory(vk, sVkEmulation->device, &infoPtr->memory,
-                                         &infoPtr->memory.memory)) {
-            ERR("Failed to import external memory for colorBuffer: %d\n", colorBufferHandle);
+            dedicatedInfo.image = *dedicatedImage;
+            dedicatedInfoPtr = &dedicatedInfo;
+        }
+        if (!importExternalMemory(vk, mDevice, &infoPtr->memory, dedicatedInfoPtr,
+                                  &infoPtr->memory.memory)) {
+            ERR("Failed to import external memory%s for colorBuffer: %d\n",
+                dedicatedInfoPtr ? " (dedicated)" : "", colorBufferHandle);
             return false;
         }
 
         infoPtr->externalMemoryCompatible = true;
     } else {
-        bool isHostVisible = infoPtr->memoryProperty & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
-        Optional<uint64_t> deviceAlignment =
-            isHostVisible ? Optional<uint64_t>(infoPtr->memReqs.alignment) : kNullopt;
         bool allocRes = allocExternalMemory(vk, &infoPtr->memory, true /*actuallyExternal*/,
                                             deviceAlignment, kNullopt, dedicatedImage);
         if (!allocRes) {
@@ -2553,15 +2742,20 @@ bool initializeVkColorBufferLocked(
             return false;
         }
 
-        infoPtr->externalMemoryCompatible = sVkEmulation->deviceInfo.supportsExternalMemoryExport;
+        infoPtr->externalMemoryCompatible = mDeviceInfo.supportsExternalMemoryExport;
     }
 
     infoPtr->memory.pageOffset = reinterpret_cast<uint64_t>(infoPtr->memory.mappedPtr) % kPageSize;
-    infoPtr->memory.bindOffset =
-        infoPtr->memory.pageOffset ? kPageSize - infoPtr->memory.pageOffset : 0u;
+    if (deviceAlignment.hasValue()) {
+        infoPtr->memory.bindOffset =
+            infoPtr->memory.pageOffset ? kPageSize - infoPtr->memory.pageOffset : 0u;
+    } else {
+        // Allocated as aligned..
+        infoPtr->memory.bindOffset = 0;
+    }
 
     VkResult bindImageMemoryRes = vk->vkBindImageMemory(
-        sVkEmulation->device, infoPtr->image, infoPtr->memory.memory, infoPtr->memory.bindOffset);
+        mDevice, infoPtr->image, infoPtr->memory.memory, infoPtr->memory.bindOffset);
 
     if (bindImageMemoryRes != VK_SUCCESS) {
         ERR("Failed to bind image memory. Error: %s", string_VkResult(bindImageMemoryRes));
@@ -2572,6 +2766,12 @@ bool initializeVkColorBufferLocked(
                                               nullptr, VK_NULL_HANDLE};
     const bool addConversion = formatRequiresYcbcrConversion(imageVkFormat);
     if (addConversion) {
+        if (!mDeviceInfo.supportsSamplerYcbcrConversion) {
+            ERR("VkFormat: %d requires conversion, but device does not have required extension "
+                " for conversion (%s)",
+                imageVkFormat, VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME);
+            return false;
+        }
         VkSamplerYcbcrConversionCreateInfo ycbcrCreateInfo = {
             VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
             nullptr,
@@ -2585,8 +2785,8 @@ bool initializeVkColorBufferLocked(
             VK_FILTER_NEAREST,
             VK_FALSE};
 
-        createRes = vk->vkCreateSamplerYcbcrConversion(sVkEmulation->device, &ycbcrCreateInfo,
-                                                       nullptr, &infoPtr->ycbcrConversion);
+        createRes = vk->vkCreateSamplerYcbcrConversion(mDevice, &ycbcrCreateInfo, nullptr,
+                                                       &infoPtr->ycbcrConversion);
         if (createRes != VK_SUCCESS) {
             VERBOSE(
                 "Failed to create Vulkan ycbcrConversion for ColorBuffer %d with format %s [%d], "
@@ -2621,66 +2821,33 @@ bool initializeVkColorBufferLocked(
                 .layerCount = 1,
             },
     };
-    createRes =
-        vk->vkCreateImageView(sVkEmulation->device, &imageViewCi, nullptr, &infoPtr->imageView);
+    createRes = vk->vkCreateImageView(mDevice, &imageViewCi, nullptr, &infoPtr->imageView);
     if (createRes != VK_SUCCESS) {
         VERBOSE("Failed to create Vulkan image view for ColorBuffer %d, Error: %s",
                 colorBufferHandle, string_VkResult(createRes));
         return false;
     }
 
-    sVkEmulation->debugUtilsHelper.addDebugLabel(infoPtr->image, "ColorBuffer:%d",
-                                                 colorBufferHandle);
-    sVkEmulation->debugUtilsHelper.addDebugLabel(infoPtr->imageView, "ColorBuffer:%d",
-                                                 colorBufferHandle);
-    sVkEmulation->debugUtilsHelper.addDebugLabel(infoPtr->memory.memory, "ColorBuffer:%d",
-                                                 colorBufferHandle);
+    mDebugUtilsHelper.addDebugLabel(infoPtr->image, "ColorBuffer:%d", colorBufferHandle);
+    mDebugUtilsHelper.addDebugLabel(infoPtr->imageView, "ColorBuffer:%d", colorBufferHandle);
+    mDebugUtilsHelper.addDebugLabel(infoPtr->memory.memory, "ColorBuffer:%d", colorBufferHandle);
 
     infoPtr->initialized = true;
 
     return true;
 }
 
-static bool createVkColorBufferLocked(uint32_t width, uint32_t height, GLenum internalFormat,
-                                      FrameworkFormat frameworkFormat, uint32_t colorBufferHandle,
-                                      bool vulkanOnly, uint32_t memoryProperty) {
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
-    // Already initialized
-    if (infoPtr) {
-        return true;
-    }
-
-    VkEmulation::ColorBufferInfo res;
-
-    res.handle = colorBufferHandle;
-    res.width = width;
-    res.height = height;
-    res.memoryProperty = memoryProperty;
-    res.internalFormat = internalFormat;
-    res.frameworkFormat = frameworkFormat;
-    res.frameworkStride = 0;
-
-    if (vulkanOnly) {
-        res.vulkanMode = VkEmulation::VulkanMode::VulkanOnly;
-    }
-
-    sVkEmulation->colorBuffers[colorBufferHandle] = res;
-    return true;
-}
-
-bool isFormatSupported(GLenum format) {
+bool VkEmulation::isFormatSupported(GLenum format) {
     VkFormat vkFormat = glFormat2VkFormat(format);
     bool supported = !gfxstream::vk::formatIsDepthOrStencil(vkFormat);
     // TODO(b/356603558): add proper Vulkan querying, for now preserve existing assumption
     if (!supported) {
-        for (size_t i = 0; i < sVkEmulation->imageSupportInfo.size(); ++i) {
+        for (size_t i = 0; i < mImageSupportInfo.size(); ++i) {
             // Only enable depth/stencil if it is usable as an attachment
-            if (sVkEmulation->imageSupportInfo[i].format == vkFormat &&
-                gfxstream::vk::formatIsDepthOrStencil(
-                    sVkEmulation->imageSupportInfo[i].format) &&
-                sVkEmulation->imageSupportInfo[i].supported &&
-                sVkEmulation->imageSupportInfo[i]
-                        .formatProps2.formatProperties.optimalTilingFeatures &
+            if (mImageSupportInfo[i].format == vkFormat &&
+                gfxstream::vk::formatIsDepthOrStencil(mImageSupportInfo[i].format) &&
+                mImageSupportInfo[i].supported &&
+                mImageSupportInfo[i].formatProps2.formatProperties.optimalTilingFeatures &
                     VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) {
                 supported = true;
             }
@@ -2689,51 +2856,35 @@ bool isFormatSupported(GLenum format) {
     return supported;
 }
 
-bool createVkColorBuffer(uint32_t width, uint32_t height, GLenum internalFormat,
-                         FrameworkFormat frameworkFormat, uint32_t colorBufferHandle,
-                         bool vulkanOnly, uint32_t memoryProperty) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "VkEmulation not available.";
-    }
-
-    AutoLock lock(sVkEmulationLock);
-    if (!createVkColorBufferLocked(width, height, internalFormat, frameworkFormat,
-                                   colorBufferHandle, vulkanOnly, memoryProperty)) {
+bool VkEmulation::createVkColorBuffer(uint32_t width, uint32_t height, GLenum internalFormat,
+                                      FrameworkFormat frameworkFormat, uint32_t colorBufferHandle,
+                                      bool vulkanOnly, uint32_t memoryProperty) {
+    std::lock_guard<std::mutex> lock(mMutex);
+    auto infoPtr = android::base::find(mColorBuffers, colorBufferHandle);
+    if (infoPtr) {
+        VERBOSE("ColorBuffer already exists for handle: %d", colorBufferHandle);
         return false;
     }
 
-    const auto& deviceInfo = sVkEmulation->deviceInfo;
-    if (!deviceInfo.supportsExternalMemoryExport && deviceInfo.supportsExternalMemoryImport) {
-        /* Returns, deferring initialization of the Vulkan components themselves.
-         * Platforms that support import but not export of external memory must
-         * use importExtMemoryHandleToVkColorBuffer(). Otherwise, the colorBuffer
-         * memory can not be externalized.
-         */
-        return true;
-    }
-
-    return initializeVkColorBufferLocked(colorBufferHandle);
+    return createVkColorBufferLocked(width, height, internalFormat, frameworkFormat,
+                                     colorBufferHandle, vulkanOnly, memoryProperty);
 }
 
-std::optional<VkColorBufferMemoryExport> exportColorBufferMemory(uint32_t colorBufferHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        return std::nullopt;
-    }
+std::optional<VkEmulation::VkColorBufferMemoryExport> VkEmulation::exportColorBufferMemory(
+    uint32_t colorBufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    AutoLock lock(sVkEmulationLock);
-
-    const auto& deviceInfo = sVkEmulation->deviceInfo;
-    if (!deviceInfo.supportsExternalMemoryExport && deviceInfo.supportsExternalMemoryImport) {
+    if (!mDeviceInfo.supportsExternalMemoryExport && mDeviceInfo.supportsExternalMemoryImport) {
         return std::nullopt;
     }
 
-    auto info = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto info = android::base::find(mColorBuffers, colorBufferHandle);
     if (!info) {
         return std::nullopt;
     }
 
     if ((info->vulkanMode != VkEmulation::VulkanMode::VulkanOnly) &&
-        !deviceInfo.glInteropSupported) {
+        !mDeviceInfo.glInteropSupported) {
         return std::nullopt;
     }
 
@@ -2741,85 +2892,74 @@ std::optional<VkColorBufferMemoryExport> exportColorBufferMemory(uint32_t colorB
         return std::nullopt;
     }
 
-#if !defined(__QNX__)
-    ManagedDescriptor descriptor(dupExternalMemory(info->memory.externalHandle));
+    auto handleInfo = info->memory.handleInfo;
+    if (!handleInfo) {
+        ERR("Could not export ColorBuffer memory, no external handle info available");
+        return std::nullopt;
+    }
+
+    auto dupHandle = dupExternalMemory(handleInfo);
+    if (!dupHandle) {
+        ERR("Could not dup external memory handle: 0x%x, with handleType: %d", handleInfo->handle,
+            handleInfo->streamHandleType);
+        return std::nullopt;
+    }
 
     info->glExported = true;
 
     return VkColorBufferMemoryExport{
-        .descriptor = std::move(descriptor),
+        .handleInfo = *dupHandle,
         .size = info->memory.size,
-        .streamHandleType = info->memory.streamHandleType,
         .linearTiling = info->imageCreateInfoShallow.tiling == VK_IMAGE_TILING_LINEAR,
         .dedicatedAllocation = info->memory.dedicatedAllocation,
     };
-#else
-    return std::nullopt;
-#endif
 }
 
-bool teardownVkColorBufferLocked(uint32_t colorBufferHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) return false;
+bool VkEmulation::teardownVkColorBufferLocked(uint32_t colorBufferHandle) {
+    auto vk = mDvk;
 
-    auto vk = sVkEmulation->dvk;
-
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto infoPtr = android::base::find(mColorBuffers, colorBufferHandle);
 
     if (!infoPtr) return false;
 
     if (infoPtr->initialized) {
         auto& info = *infoPtr;
         {
-            android::base::AutoLock lock(*sVkEmulation->queueLock);
-            VK_CHECK(vk->vkQueueWaitIdle(sVkEmulation->queue));
+            android::base::AutoLock queueLock(*mQueueLock);
+            VK_CHECK(vk->vkQueueWaitIdle(mQueue));
+        }
+        vk->vkDestroyImageView(mDevice, info.imageView, nullptr);
+        if (mDeviceInfo.hasSamplerYcbcrConversionExtension) {
+            vk->vkDestroySamplerYcbcrConversion(mDevice, info.ycbcrConversion, nullptr);
         }
-        vk->vkDestroyImageView(sVkEmulation->device, info.imageView, nullptr);
-        vk->vkDestroySamplerYcbcrConversion(sVkEmulation->device, info.ycbcrConversion, nullptr);
-        vk->vkDestroyImage(sVkEmulation->device, info.image, nullptr);
+        vk->vkDestroyImage(mDevice, info.image, nullptr);
         freeExternalMemoryLocked(vk, &info.memory);
     }
 
-    sVkEmulation->colorBuffers.erase(colorBufferHandle);
+    mColorBuffers.erase(colorBufferHandle);
 
     return true;
 }
 
-bool teardownVkColorBuffer(uint32_t colorBufferHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) return false;
-
-    AutoLock lock(sVkEmulationLock);
+bool VkEmulation::teardownVkColorBuffer(uint32_t colorBufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
     return teardownVkColorBufferLocked(colorBufferHandle);
 }
 
-bool importExtMemoryHandleToVkColorBuffer(uint32_t colorBufferHandle, uint32_t type,
-                                          VK_EXT_MEMORY_HANDLE extMemHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "VkEmulation not available.";
-    }
-    if (VK_EXT_MEMORY_HANDLE_INVALID == extMemHandle) {
-        return false;
-    }
+std::optional<VkEmulation::ColorBufferInfo> VkEmulation::getColorBufferInfo(
+    uint32_t colorBufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    AutoLock lock(sVkEmulationLock);
-    // Initialize the colorBuffer with the external memory handle
-    // Note that this will fail if the colorBuffer memory was previously initialized.
-    return initializeVkColorBufferLocked(colorBufferHandle, extMemHandle);
-}
-
-VkEmulation::ColorBufferInfo getColorBufferInfo(uint32_t colorBufferHandle) {
-    VkEmulation::ColorBufferInfo res;
-
-    AutoLock lock(sVkEmulationLock);
-
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
-
-    if (!infoPtr) return res;
+    auto infoPtr = android::base::find(mColorBuffers, colorBufferHandle);
+    if (!infoPtr) {
+        return std::nullopt;
+    }
 
-    res = *infoPtr;
-    return res;
+    return *infoPtr;
 }
 
-bool colorBufferNeedsUpdateBetweenGlAndVk(const VkEmulation::ColorBufferInfo& colorBufferInfo) {
+bool VkEmulation::colorBufferNeedsUpdateBetweenGlAndVk(
+    const VkEmulation::ColorBufferInfo& colorBufferInfo) {
     // GL is not used.
     if (colorBufferInfo.vulkanMode == VkEmulation::VulkanMode::VulkanOnly) {
         return false;
@@ -2838,14 +2978,10 @@ bool colorBufferNeedsUpdateBetweenGlAndVk(const VkEmulation::ColorBufferInfo& co
     return true;
 }
 
-bool colorBufferNeedsUpdateBetweenGlAndVk(uint32_t colorBufferHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        return false;
-    }
-
-    AutoLock lock(sVkEmulationLock);
+bool VkEmulation::colorBufferNeedsUpdateBetweenGlAndVk(uint32_t colorBufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto colorBufferInfo = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto colorBufferInfo = android::base::find(mColorBuffers, colorBufferHandle);
     if (!colorBufferInfo) {
         return false;
     }
@@ -2853,15 +2989,10 @@ bool colorBufferNeedsUpdateBetweenGlAndVk(uint32_t colorBufferHandle) {
     return colorBufferNeedsUpdateBetweenGlAndVk(*colorBufferInfo);
 }
 
-bool readColorBufferToBytes(uint32_t colorBufferHandle, std::vector<uint8_t>* bytes) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        VERBOSE("VkEmulation not available.");
-        return false;
-    }
-
-    AutoLock lock(sVkEmulationLock);
+bool VkEmulation::readColorBufferToBytes(uint32_t colorBufferHandle, std::vector<uint8_t>* bytes) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto colorBufferInfo = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto colorBufferInfo = android::base::find(mColorBuffers, colorBufferHandle);
     if (!colorBufferInfo) {
         VERBOSE("Failed to read from ColorBuffer:%d, not found.", colorBufferHandle);
         bytes->clear();
@@ -2891,27 +3022,19 @@ bool readColorBufferToBytes(uint32_t colorBufferHandle, std::vector<uint8_t>* by
     return true;
 }
 
-bool readColorBufferToBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                            uint32_t h, void* outPixels, uint64_t outPixelsSize) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        ERR("VkEmulation not available.");
-        return false;
-    }
-
-    AutoLock lock(sVkEmulationLock);
+bool VkEmulation::readColorBufferToBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y,
+                                         uint32_t w, uint32_t h, void* outPixels,
+                                         uint64_t outPixelsSize) {
+    std::lock_guard<std::mutex> lock(mMutex);
     return readColorBufferToBytesLocked(colorBufferHandle, x, y, w, h, outPixels, outPixelsSize);
 }
 
-bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                                  uint32_t h, void* outPixels, uint64_t outPixelsSize) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        ERR("VkEmulation not available.");
-        return false;
-    }
-
-    auto vk = sVkEmulation->dvk;
+bool VkEmulation::readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32_t y,
+                                               uint32_t w, uint32_t h, void* outPixels,
+                                               uint64_t outPixelsSize) {
+    auto vk = mDvk;
 
-    auto colorBufferInfo = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto colorBufferInfo = android::base::find(mColorBuffers, colorBufferHandle);
     if (!colorBufferInfo) {
         ERR("Failed to read from ColorBuffer:%d, not found.", colorBufferHandle);
         return false;
@@ -2955,13 +3078,10 @@ bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32
         .pNext = nullptr,
         .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
     };
+    VK_CHECK(vk->vkBeginCommandBuffer(mCommandBuffer, &beginInfo));
 
-    VkCommandBuffer commandBuffer = sVkEmulation->commandBuffer;
-
-    VK_CHECK(vk->vkBeginCommandBuffer(commandBuffer, &beginInfo));
-
-    sVkEmulation->debugUtilsHelper.cmdBeginDebugLabel(
-        commandBuffer, "readColorBufferToBytes(ColorBuffer:%d)", colorBufferHandle);
+    mDebugUtilsHelper.cmdBeginDebugLabel(mCommandBuffer, "readColorBufferToBytes(ColorBuffer:%d)",
+                                         colorBufferHandle);
 
     VkImageLayout currentLayout = colorBufferInfo->currentLayout;
     VkImageLayout transferSrcLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
@@ -2986,12 +3106,12 @@ bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32
             },
     };
 
-    vk->vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
+    vk->vkCmdPipelineBarrier(mCommandBuffer, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
                              VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, 0, 0, nullptr, 0, nullptr, 1,
                              &toTransferSrcImageBarrier);
 
-    vk->vkCmdCopyImageToBuffer(commandBuffer, colorBufferInfo->image,
-                               VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, sVkEmulation->staging.buffer,
+    vk->vkCmdCopyImageToBuffer(mCommandBuffer, colorBufferInfo->image,
+                               VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, mStaging.buffer,
                                bufferImageCopies.size(), bufferImageCopies.data());
 
     // Change back to original layout
@@ -3016,16 +3136,16 @@ bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32
                     .layerCount = 1,
                 },
         };
-        vk->vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
+        vk->vkCmdPipelineBarrier(mCommandBuffer, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
                                  VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, 0, 0, nullptr, 0, nullptr, 1,
                                  &toCurrentLayoutImageBarrier);
     } else {
         colorBufferInfo->currentLayout = transferSrcLayout;
     }
 
-    sVkEmulation->debugUtilsHelper.cmdEndDebugLabel(commandBuffer);
+    mDebugUtilsHelper.cmdEndDebugLabel(mCommandBuffer);
 
-    VK_CHECK(vk->vkEndCommandBuffer(commandBuffer));
+    VK_CHECK(vk->vkEndCommandBuffer(mCommandBuffer));
 
     const VkSubmitInfo submitInfo = {
         .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
@@ -3034,44 +3154,43 @@ bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32
         .pWaitSemaphores = nullptr,
         .pWaitDstStageMask = nullptr,
         .commandBufferCount = 1,
-        .pCommandBuffers = &commandBuffer,
+        .pCommandBuffers = &mCommandBuffer,
         .signalSemaphoreCount = 0,
         .pSignalSemaphores = nullptr,
     };
 
     {
-        android::base::AutoLock lock(*sVkEmulation->queueLock);
-        VK_CHECK(vk->vkQueueSubmit(sVkEmulation->queue, 1, &submitInfo,
-                                   sVkEmulation->commandBufferFence));
+        android::base::AutoLock queueLock(*mQueueLock);
+        VK_CHECK(vk->vkQueueSubmit(mQueue, 1, &submitInfo, mCommandBufferFence));
     }
 
     static constexpr uint64_t ANB_MAX_WAIT_NS = 5ULL * 1000ULL * 1000ULL * 1000ULL;
-    VkResult waitRes = vk->vkWaitForFences(
-        sVkEmulation->device, 1, &sVkEmulation->commandBufferFence, VK_TRUE, ANB_MAX_WAIT_NS);
+    VkResult waitRes =
+        vk->vkWaitForFences(mDevice, 1, &mCommandBufferFence, VK_TRUE, ANB_MAX_WAIT_NS);
     if (waitRes == VK_TIMEOUT) {
         // Give a warning and try once more on a timeout error
         ERR("readColorBufferToBytesLocked vkWaitForFences failed with timeout error "
             "(cb:%d, x:%d, y:%d, w:%d, h:%d, bufferCopySize:%llu), retrying...",
             colorBufferHandle, x, y, w, h, bufferCopySize);
-        waitRes = vk->vkWaitForFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence,
-                                      VK_TRUE, ANB_MAX_WAIT_NS*2);
+        waitRes =
+            vk->vkWaitForFences(mDevice, 1, &mCommandBufferFence, VK_TRUE, ANB_MAX_WAIT_NS * 2);
     }
 
     VK_CHECK(waitRes);
 
-    VK_CHECK(vk->vkResetFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence));
+    VK_CHECK(vk->vkResetFences(mDevice, 1, &mCommandBufferFence));
 
     const VkMappedMemoryRange toInvalidate = {
         .sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
         .pNext = nullptr,
-        .memory = sVkEmulation->staging.memory.memory,
+        .memory = mStaging.memory.memory,
         .offset = 0,
         .size = VK_WHOLE_SIZE,
     };
 
-    VK_CHECK(vk->vkInvalidateMappedMemoryRanges(sVkEmulation->device, 1, &toInvalidate));
+    VK_CHECK(vk->vkInvalidateMappedMemoryRanges(mDevice, 1, &toInvalidate));
 
-    const auto* stagingBufferPtr = sVkEmulation->staging.memory.mappedPtr;
+    const auto* stagingBufferPtr = mStaging.memory.mappedPtr;
     if (bufferCopySize > outPixelsSize) {
         ERR("Invalid buffer size for readColorBufferToBytes operation."
             "Required: %llu, Actual: %llu",
@@ -3083,15 +3202,11 @@ bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32
     return true;
 }
 
-bool updateColorBufferFromBytes(uint32_t colorBufferHandle, const std::vector<uint8_t>& bytes) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        VERBOSE("VkEmulation not available.");
-        return false;
-    }
+bool VkEmulation::updateColorBufferFromBytes(uint32_t colorBufferHandle,
+                                             const std::vector<uint8_t>& bytes) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    AutoLock lock(sVkEmulationLock);
-
-    auto colorBufferInfo = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto colorBufferInfo = android::base::find(mColorBuffers, colorBufferHandle);
     if (!colorBufferInfo) {
         VERBOSE("Failed to update ColorBuffer:%d, not found.", colorBufferHandle);
         return false;
@@ -3102,14 +3217,9 @@ bool updateColorBufferFromBytes(uint32_t colorBufferHandle, const std::vector<ui
         colorBufferInfo->imageCreateInfoShallow.extent.height, bytes.data(), bytes.size());
 }
 
-bool updateColorBufferFromBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                                uint32_t h, const void* pixels) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        ERR("VkEmulation not available.");
-        return false;
-    }
-
-    AutoLock lock(sVkEmulationLock);
+bool VkEmulation::updateColorBufferFromBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y,
+                                             uint32_t w, uint32_t h, const void* pixels) {
+    std::lock_guard<std::mutex> lock(mMutex);
     return updateColorBufferFromBytesLocked(colorBufferHandle, x, y, w, h, pixels, 0);
 }
 
@@ -3125,17 +3235,26 @@ static void convertRgbToRgbaPixels(void* dst, const void* src, uint32_t w, uint3
     }
 }
 
-static bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32_t y,
-                                             uint32_t w, uint32_t h, const void* pixels,
-                                             size_t inputPixelsSize) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        ERR("VkEmulation not available.");
-        return false;
+static void convertRgba4ToBGRA4Pixels(void* dst, const void* src, uint32_t w, uint32_t h) {
+    const size_t pixelCount = w * h;
+    const uint16_t* srcPixels = reinterpret_cast<const uint16_t*>(src);
+    uint16_t* dstPixels = reinterpret_cast<uint16_t*>(dst);
+    for (size_t i = 0; i < pixelCount; ++i) {
+        const uint16_t rgba4_pixel = srcPixels[i];
+        const uint8_t red = (rgba4_pixel >> 12) & 0xF;
+        const uint8_t green = (rgba4_pixel >> 8) & 0xF;
+        const uint8_t blue = (rgba4_pixel >> 4) & 0xF;
+        const uint8_t alpha = rgba4_pixel & 0xF;
+        dstPixels[i] = (blue << 12) | (green << 8) | (red << 4) | alpha;
     }
+}
 
-    auto vk = sVkEmulation->dvk;
+bool VkEmulation::updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_t x,
+                                                   uint32_t y, uint32_t w, uint32_t h,
+                                                   const void* pixels, size_t inputPixelsSize) {
+    auto vk = mDvk;
 
-    auto colorBufferInfo = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto colorBufferInfo = android::base::find(mColorBuffers, colorBufferHandle);
     if (!colorBufferInfo) {
         ERR("Failed to update ColorBuffer:%d, not found.", colorBufferHandle);
         return false;
@@ -3152,9 +3271,10 @@ static bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_
         return false;
     }
 
+    const VkFormat creationFormat = colorBufferInfo->imageCreateInfoShallow.format;
     VkDeviceSize dstBufferSize = 0;
     std::vector<VkBufferImageCopy> bufferImageCopies;
-    if (!getFormatTransferInfo(colorBufferInfo->imageCreateInfoShallow.format,
+    if (!getFormatTransferInfo(creationFormat,
                                colorBufferInfo->imageCreateInfoShallow.extent.width,
                                colorBufferInfo->imageCreateInfoShallow.extent.height,
                                &dstBufferSize, &bufferImageCopies)) {
@@ -3162,17 +3282,18 @@ static bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_
         return false;
     }
 
-    const VkDeviceSize stagingBufferSize = sVkEmulation->staging.size;
+    const VkDeviceSize stagingBufferSize = mStaging.size;
     if (dstBufferSize > stagingBufferSize) {
         ERR("Failed to update ColorBuffer:%d, transfer size %" PRIu64
             " too large for staging buffer size:%" PRIu64 ".",
             colorBufferHandle, dstBufferSize, stagingBufferSize);
         return false;
     }
-
-    bool isThreeByteRgb =
+    const bool isRGBA4onBGRA4 = (colorBufferInfo->internalFormat == GL_RGBA4_OES) &&
+                          (creationFormat == VK_FORMAT_B4G4R4A4_UNORM_PACK16);
+    const bool isThreeByteRgb =
         (colorBufferInfo->internalFormat == GL_RGB || colorBufferInfo->internalFormat == GL_RGB8);
-    size_t expectedInputSize = (isThreeByteRgb ? dstBufferSize / 4 * 3 : dstBufferSize);
+    const size_t expectedInputSize = (isThreeByteRgb ? dstBufferSize / 4 * 3 : dstBufferSize);
 
     if (inputPixelsSize != 0 && inputPixelsSize != expectedInputSize) {
         ERR("Unexpected contents size when trying to update ColorBuffer:%d, "
@@ -3181,13 +3302,15 @@ static bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_
         return false;
     }
 
-    auto* stagingBufferPtr = sVkEmulation->staging.memory.mappedPtr;
+    auto* stagingBufferPtr = mStaging.memory.mappedPtr;
 
     if (isThreeByteRgb) {
         // Convert RGB to RGBA, since only for these types glFormat2VkFormat() makes
         // an incompatible choice of 4-byte backing VK_FORMAT_R8G8B8A8_UNORM.
         // b/281550953
         convertRgbToRgbaPixels(stagingBufferPtr, pixels, w, h);
+    } else if(isRGBA4onBGRA4) {
+        convertRgba4ToBGRA4Pixels(stagingBufferPtr, pixels, w, h);
     } else {
         std::memcpy(stagingBufferPtr, pixels, dstBufferSize);
     }
@@ -3208,16 +3331,12 @@ static bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_
         .pNext = nullptr,
         .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
     };
+    VK_CHECK(vk->vkBeginCommandBuffer(mCommandBuffer, &beginInfo));
 
-    VkCommandBuffer commandBuffer = sVkEmulation->commandBuffer;
+    mDebugUtilsHelper.cmdBeginDebugLabel(
+        mCommandBuffer, "updateColorBufferFromBytes(ColorBuffer:%d)", colorBufferHandle);
 
-    VK_CHECK(vk->vkBeginCommandBuffer(commandBuffer, &beginInfo));
-
-    sVkEmulation->debugUtilsHelper.cmdBeginDebugLabel(
-        commandBuffer, "updateColorBufferFromBytes(ColorBuffer:%d)", colorBufferHandle);
-
-    bool isSnapshotLoad =
-        VkDecoderGlobalState::get()->getSnapshotState() == VkDecoderGlobalState::Loading;
+    const bool isSnapshotLoad = VkDecoderGlobalState::get()->isSnapshotCurrentlyLoading();
     VkImageLayout currentLayout = colorBufferInfo->currentLayout;
     if (isSnapshotLoad) {
         currentLayout = VK_IMAGE_LAYOUT_UNDEFINED;
@@ -3242,12 +3361,12 @@ static bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_
             },
     };
 
-    vk->vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+    vk->vkCmdPipelineBarrier(mCommandBuffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
                              VK_PIPELINE_STAGE_HOST_BIT, 0, 0, nullptr, 0, nullptr, 1,
                              &toTransferDstImageBarrier);
 
     // Copy from staging buffer to color buffer image
-    vk->vkCmdCopyBufferToImage(commandBuffer, sVkEmulation->staging.buffer, colorBufferInfo->image,
+    vk->vkCmdCopyBufferToImage(mCommandBuffer, mStaging.buffer, colorBufferInfo->image,
                                VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, bufferImageCopies.size(),
                                bufferImageCopies.data());
 
@@ -3271,16 +3390,16 @@ static bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_
                     .layerCount = 1,
                 },
         };
-        vk->vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_HOST_BIT,
+        vk->vkCmdPipelineBarrier(mCommandBuffer, VK_PIPELINE_STAGE_HOST_BIT,
                                  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, 0, 0, nullptr, 0, nullptr, 1,
                                  &toCurrentLayoutImageBarrier);
     } else {
         colorBufferInfo->currentLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
     }
 
-    sVkEmulation->debugUtilsHelper.cmdEndDebugLabel(commandBuffer);
+    mDebugUtilsHelper.cmdEndDebugLabel(mCommandBuffer);
 
-    VK_CHECK(vk->vkEndCommandBuffer(commandBuffer));
+    VK_CHECK(vk->vkEndCommandBuffer(mCommandBuffer));
 
     const VkSubmitInfo submitInfo = {
         .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
@@ -3289,58 +3408,57 @@ static bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_
         .pWaitSemaphores = nullptr,
         .pWaitDstStageMask = nullptr,
         .commandBufferCount = 1,
-        .pCommandBuffers = &commandBuffer,
+        .pCommandBuffers = &mCommandBuffer,
         .signalSemaphoreCount = 0,
         .pSignalSemaphores = nullptr,
     };
 
     {
-        android::base::AutoLock lock(*sVkEmulation->queueLock);
-        VK_CHECK(vk->vkQueueSubmit(sVkEmulation->queue, 1, &submitInfo,
-                                   sVkEmulation->commandBufferFence));
+        android::base::AutoLock queueLock(*mQueueLock);
+        VK_CHECK(vk->vkQueueSubmit(mQueue, 1, &submitInfo, mCommandBufferFence));
     }
 
     static constexpr uint64_t ANB_MAX_WAIT_NS = 5ULL * 1000ULL * 1000ULL * 1000ULL;
+    VK_CHECK(vk->vkWaitForFences(mDevice, 1, &mCommandBufferFence, VK_TRUE, ANB_MAX_WAIT_NS));
 
-    VK_CHECK(vk->vkWaitForFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence,
-                                 VK_TRUE, ANB_MAX_WAIT_NS));
-
-    VK_CHECK(vk->vkResetFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence));
+    VK_CHECK(vk->vkResetFences(mDevice, 1, &mCommandBufferFence));
 
     const VkMappedMemoryRange toInvalidate = {
         .sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
         .pNext = nullptr,
-        .memory = sVkEmulation->staging.memory.memory,
+        .memory = mStaging.memory.memory,
         .offset = 0,
         .size = VK_WHOLE_SIZE,
     };
-    VK_CHECK(vk->vkInvalidateMappedMemoryRanges(sVkEmulation->device, 1, &toInvalidate));
+    VK_CHECK(vk->vkInvalidateMappedMemoryRanges(mDevice, 1, &toInvalidate));
 
     return true;
 }
 
-VK_EXT_MEMORY_HANDLE getColorBufferExtMemoryHandle(uint32_t colorBuffer) {
-    if (!sVkEmulation || !sVkEmulation->live) return VK_EXT_MEMORY_HANDLE_INVALID;
+std::optional<ExternalHandleInfo> VkEmulation::dupColorBufferExtMemoryHandle(
+    uint32_t colorBufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    AutoLock lock(sVkEmulationLock);
-
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBuffer);
+    auto infoPtr = android::base::find(mColorBuffers, colorBufferHandle);
 
     if (!infoPtr) {
-        // Color buffer not found; this is usually OK.
-        return VK_EXT_MEMORY_HANDLE_INVALID;
+        return std::nullopt;
+    }
+
+    auto handleInfo = infoPtr->memory.handleInfo;
+    if (!handleInfo) {
+        ERR("Could not dup ColorBuffer external memory handle, no external handle info available");
+        return std::nullopt;
     }
 
-    return infoPtr->memory.externalHandle;
+    return dupExternalMemory(handleInfo);
 }
 
 #ifdef __APPLE__
-MTLResource_id getColorBufferMetalMemoryHandle(uint32_t colorBuffer) {
-    if (!sVkEmulation || !sVkEmulation->live) return nullptr;
-
-    AutoLock lock(sVkEmulationLock);
+MTLResource_id VkEmulation::getColorBufferMetalMemoryHandle(uint32_t colorBuffer) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBuffer);
+    auto infoPtr = android::base::find(mColorBuffers, colorBuffer);
 
     if (!infoPtr) {
         // Color buffer not found; this is usually OK.
@@ -3350,13 +3468,11 @@ MTLResource_id getColorBufferMetalMemoryHandle(uint32_t colorBuffer) {
     return infoPtr->memory.externalMetalHandle;
 }
 
-// TODO0(b/351765838): Temporary function for MoltenVK
-VkImage getColorBufferVkImage(uint32_t colorBufferHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) return nullptr;
+// TODO(b/351765838): Temporary function for MoltenVK
+VkImage VkEmulation::getColorBufferVkImage(uint32_t colorBufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    AutoLock lock(sVkEmulationLock);
-
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto infoPtr = android::base::find(mColorBuffers, colorBufferHandle);
 
     if (!infoPtr) {
         // Color buffer not found; this is usually OK.
@@ -3367,12 +3483,10 @@ VkImage getColorBufferVkImage(uint32_t colorBufferHandle) {
 }
 #endif  // __APPLE__
 
-bool setColorBufferVulkanMode(uint32_t colorBuffer, uint32_t vulkanMode) {
-    if (!sVkEmulation || !sVkEmulation->live) return false;
-
-    AutoLock lock(sVkEmulationLock);
+bool VkEmulation::setColorBufferVulkanMode(uint32_t colorBuffer, uint32_t vulkanMode) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBuffer);
+    auto infoPtr = android::base::find(mColorBuffers, colorBuffer);
 
     if (!infoPtr) {
         return false;
@@ -3383,18 +3497,16 @@ bool setColorBufferVulkanMode(uint32_t colorBuffer, uint32_t vulkanMode) {
     return true;
 }
 
-int32_t mapGpaToBufferHandle(uint32_t bufferHandle, uint64_t gpa, uint64_t size) {
-    if (!sVkEmulation || !sVkEmulation->live) return VK_ERROR_DEVICE_LOST;
-
-    AutoLock lock(sVkEmulationLock);
+int32_t VkEmulation::mapGpaToBufferHandle(uint32_t bufferHandle, uint64_t gpa, uint64_t size) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
     VkEmulation::ExternalMemoryInfo* memoryInfoPtr = nullptr;
 
-    auto colorBufferInfoPtr = android::base::find(sVkEmulation->colorBuffers, bufferHandle);
+    auto colorBufferInfoPtr = android::base::find(mColorBuffers, bufferHandle);
     if (colorBufferInfoPtr) {
         memoryInfoPtr = &colorBufferInfoPtr->memory;
     }
-    auto bufferInfoPtr = android::base::find(sVkEmulation->buffers, bufferHandle);
+    auto bufferInfoPtr = android::base::find(mBuffers, bufferHandle);
     if (bufferInfoPtr) {
         memoryInfoPtr = &bufferInfoPtr->memory;
     }
@@ -3424,7 +3536,7 @@ int32_t mapGpaToBufferHandle(uint32_t bufferHandle, uint64_t gpa, uint64_t size)
             memoryInfoPtr->mappedPtr, memoryInfoPtr->pageAlignedHva, memoryInfoPtr->gpa,
             memoryInfoPtr->gpa + memoryInfoPtr->sizeToPage);
 
-    if (sVkEmulation->occupiedGpas.find(gpa) != sVkEmulation->occupiedGpas.end()) {
+    if (mOccupiedGpas.find(gpa) != mOccupiedGpas.end()) {
         // emugl::emugl_crash_reporter("FATAL: already mapped gpa 0x%lx! ", gpa);
         return VK_ERROR_MEMORY_MAP_FAILED;
     }
@@ -3432,20 +3544,17 @@ int32_t mapGpaToBufferHandle(uint32_t bufferHandle, uint64_t gpa, uint64_t size)
     get_emugl_vm_operations().mapUserBackedRam(gpa, memoryInfoPtr->pageAlignedHva,
                                                memoryInfoPtr->sizeToPage);
 
-    sVkEmulation->occupiedGpas.insert(gpa);
+    mOccupiedGpas.insert(gpa);
 
     return memoryInfoPtr->pageOffset;
 }
 
-bool getBufferAllocationInfo(uint32_t bufferHandle, VkDeviceSize* outSize,
-                             uint32_t* outMemoryTypeIndex, bool* outMemoryIsDedicatedAlloc) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Vulkan emulation not available.";
-    }
-
-    AutoLock lock(sVkEmulationLock);
+bool VkEmulation::getBufferAllocationInfo(uint32_t bufferHandle, VkDeviceSize* outSize,
+                                          uint32_t* outMemoryTypeIndex,
+                                          bool* outMemoryIsDedicatedAlloc) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto info = android::base::find(sVkEmulation->buffers, bufferHandle);
+    auto info = android::base::find(mBuffers, bufferHandle);
     if (!info) {
         return false;
     }
@@ -3465,17 +3574,18 @@ bool getBufferAllocationInfo(uint32_t bufferHandle, VkDeviceSize* outSize,
     return true;
 }
 
-bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32_t memoryProperty) {
+bool VkEmulation::setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly,
+                                uint32_t memoryProperty) {
     if (vulkanOnly == false) {
         ERR("Data buffers should be vulkanOnly. Setup failed.");
         return false;
     }
 
-    auto vk = sVkEmulation->dvk;
+    auto vk = mDvk;
 
-    AutoLock lock(sVkEmulationLock);
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto infoPtr = android::base::find(sVkEmulation->buffers, bufferHandle);
+    auto infoPtr = android::base::find(mBuffers, bufferHandle);
 
     // Already setup
     if (infoPtr) {
@@ -3498,17 +3608,11 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
     VkExternalMemoryBufferCreateInfo extBufferCi = {
         VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
         0,
-        VK_EXT_MEMORY_HANDLE_TYPE_BIT,
+        static_cast<VkExternalMemoryHandleTypeFlags>(getDefaultExternalMemoryHandleType()),
     };
-#if defined(__APPLE__)
-    if (sVkEmulation->instanceSupportsMoltenVK) {
-        // Using a different handle type when in MoltenVK mode
-        extBufferCi.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT;
-    }
-#endif
+
     void* extBufferCiPtr = nullptr;
-    if (sVkEmulation->deviceInfo.supportsExternalMemoryImport ||
-        sVkEmulation->deviceInfo.supportsExternalMemoryExport) {
+    if (mDeviceInfo.supportsExternalMemoryImport || mDeviceInfo.supportsExternalMemoryExport) {
         extBufferCiPtr = &extBufferCi;
     }
 
@@ -3523,7 +3627,7 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
         /* pQueueFamilyIndices */ nullptr,
     };
 
-    VkResult createRes = vk->vkCreateBuffer(sVkEmulation->device, &bufferCi, nullptr, &res.buffer);
+    VkResult createRes = vk->vkCreateBuffer(mDevice, &bufferCi, nullptr, &res.buffer);
 
     if (createRes != VK_SUCCESS) {
         WARN("Failed to create Vulkan Buffer for Buffer %d, Error: %s", bufferHandle,
@@ -3531,6 +3635,7 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
         return false;
     }
     bool useDedicated = false;
+    VkMemoryRequirements memReqs;
     if (vk->vkGetBufferMemoryRequirements2KHR) {
         VkMemoryDedicatedRequirements dedicated_reqs{
             VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS, nullptr};
@@ -3538,11 +3643,11 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
 
         VkBufferMemoryRequirementsInfo2 info{VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
                                              nullptr, res.buffer};
-        vk->vkGetBufferMemoryRequirements2KHR(sVkEmulation->device, &info, &reqs);
+        vk->vkGetBufferMemoryRequirements2KHR(mDevice, &info, &reqs);
         useDedicated = dedicated_reqs.requiresDedicatedAllocation;
-        res.memReqs = reqs.memoryRequirements;
+        memReqs = reqs.memoryRequirements;
     } else {
-        vk->vkGetBufferMemoryRequirements(sVkEmulation->device, res.buffer, &res.memReqs);
+        vk->vkGetBufferMemoryRequirements(mDevice, res.buffer, &memReqs);
     }
 
     // Currently we only care about two memory properties: DEVICE_LOCAL
@@ -3551,10 +3656,10 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
     memoryProperty = memoryProperty &
                      (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
 
-    res.memory.size = res.memReqs.size;
+    res.memory.size = memReqs.size;
 
     // Determine memory type.
-    res.memory.typeIndex = getValidMemoryTypeIndex(res.memReqs.memoryTypeBits, memoryProperty);
+    res.memory.typeIndex = getValidMemoryTypeIndex(memReqs.memoryTypeBits, memoryProperty);
 
     VERBOSE(
         "Buffer %d "
@@ -3562,12 +3667,11 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
         "allocated memory property: %d, "
         "requested memory property: %d",
         bufferHandle, res.memory.size, res.memory.typeIndex,
-        sVkEmulation->deviceInfo.memProps.memoryTypes[res.memory.typeIndex].propertyFlags,
-        memoryProperty);
+        mDeviceInfo.memProps.memoryTypes[res.memory.typeIndex].propertyFlags, memoryProperty);
 
     bool isHostVisible = memoryProperty & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
     Optional<uint64_t> deviceAlignment =
-        isHostVisible ? Optional<uint64_t>(res.memReqs.alignment) : kNullopt;
+        isHostVisible ? Optional<uint64_t>(memReqs.alignment) : kNullopt;
     Optional<VkBuffer> dedicated_buffer = useDedicated ? Optional<VkBuffer>(res.buffer) : kNullopt;
     bool allocRes = allocExternalMemory(vk, &res.memory, true /* actuallyExternal */,
                                         deviceAlignment, dedicated_buffer);
@@ -3580,7 +3684,7 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
     res.memory.bindOffset = res.memory.pageOffset ? kPageSize - res.memory.pageOffset : 0u;
 
     VkResult bindBufferMemoryRes =
-        vk->vkBindBufferMemory(sVkEmulation->device, res.buffer, res.memory.memory, 0);
+        vk->vkBindBufferMemory(mDevice, res.buffer, res.memory.memory, 0);
 
     if (bindBufferMemoryRes != VK_SUCCESS) {
         ERR("Failed to bind buffer memory. Error: %s\n", string_VkResult(bindBufferMemoryRes));
@@ -3590,8 +3694,8 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
     bool isHostVisibleMemory = memoryProperty & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
 
     if (isHostVisibleMemory) {
-        VkResult mapMemoryRes = vk->vkMapMemory(sVkEmulation->device, res.memory.memory, 0,
-                                                res.memory.size, {}, &res.memory.mappedPtr);
+        VkResult mapMemoryRes = vk->vkMapMemory(mDevice, res.memory.memory, 0, res.memory.size, {},
+                                                &res.memory.mappedPtr);
 
         if (mapMemoryRes != VK_SUCCESS) {
             ERR("Failed to map image memory. Error: %s\n", string_VkResult(mapMemoryRes));
@@ -3601,58 +3705,55 @@ bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly, uint32
 
     res.glExported = false;
 
-    sVkEmulation->buffers[bufferHandle] = res;
+    mBuffers[bufferHandle] = res;
 
-    sVkEmulation->debugUtilsHelper.addDebugLabel(res.buffer, "Buffer:%d", bufferHandle);
-    sVkEmulation->debugUtilsHelper.addDebugLabel(res.memory.memory, "Buffer:%d", bufferHandle);
+    mDebugUtilsHelper.addDebugLabel(res.buffer, "Buffer:%d", bufferHandle);
+    mDebugUtilsHelper.addDebugLabel(res.memory.memory, "Buffer:%d", bufferHandle);
 
     return allocRes;
 }
 
-bool teardownVkBuffer(uint32_t bufferHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) return false;
+bool VkEmulation::teardownVkBuffer(uint32_t bufferHandle) {
+    auto vk = mDvk;
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto vk = sVkEmulation->dvk;
-    AutoLock lock(sVkEmulationLock);
-
-    auto infoPtr = android::base::find(sVkEmulation->buffers, bufferHandle);
+    auto infoPtr = android::base::find(mBuffers, bufferHandle);
     if (!infoPtr) return false;
     {
-        android::base::AutoLock lock(*sVkEmulation->queueLock);
-        VK_CHECK(vk->vkQueueWaitIdle(sVkEmulation->queue));
+        android::base::AutoLock queueLock(*mQueueLock);
+        VK_CHECK(vk->vkQueueWaitIdle(mQueue));
     }
     auto& info = *infoPtr;
 
-    vk->vkDestroyBuffer(sVkEmulation->device, info.buffer, nullptr);
+    vk->vkDestroyBuffer(mDevice, info.buffer, nullptr);
     freeExternalMemoryLocked(vk, &info.memory);
-    sVkEmulation->buffers.erase(bufferHandle);
+    mBuffers.erase(bufferHandle);
 
     return true;
 }
 
-VK_EXT_MEMORY_HANDLE getBufferExtMemoryHandle(uint32_t bufferHandle,
-                                              uint32_t* outStreamHandleType) {
-    if (!sVkEmulation || !sVkEmulation->live) return VK_EXT_MEMORY_HANDLE_INVALID;
-
-    AutoLock lock(sVkEmulationLock);
+std::optional<ExternalHandleInfo> VkEmulation::dupBufferExtMemoryHandle(uint32_t bufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto infoPtr = android::base::find(sVkEmulation->buffers, bufferHandle);
+    auto infoPtr = android::base::find(mBuffers, bufferHandle);
     if (!infoPtr) {
-        // Color buffer not found; this is usually OK.
-        return VK_EXT_MEMORY_HANDLE_INVALID;
+        return std::nullopt;
     }
 
-    *outStreamHandleType = infoPtr->memory.streamHandleType;
-    return infoPtr->memory.externalHandle;
+    auto handleInfo = infoPtr->memory.handleInfo;
+    if (!handleInfo) {
+        ERR("Could not dup Buffer external memory handle, no external handle info available");
+        return std::nullopt;
+    }
+
+    return dupExternalMemory(handleInfo);
 }
 
 #ifdef __APPLE__
-MTLResource_id getBufferMetalMemoryHandle(uint32_t bufferHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) return nullptr;
-
-    AutoLock lock(sVkEmulationLock);
+MTLResource_id VkEmulation::getBufferMetalMemoryHandle(uint32_t bufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto infoPtr = android::base::find(sVkEmulation->buffers, bufferHandle);
+    auto infoPtr = android::base::find(mBuffers, bufferHandle);
     if (!infoPtr) {
         // Color buffer not found; this is usually OK.
         return nullptr;
@@ -3662,23 +3763,19 @@ MTLResource_id getBufferMetalMemoryHandle(uint32_t bufferHandle) {
 }
 #endif
 
-bool readBufferToBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size, void* outBytes) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        ERR("VkEmulation not available.");
-        return false;
-    }
-
-    auto vk = sVkEmulation->dvk;
+bool VkEmulation::readBufferToBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size,
+                                    void* outBytes) {
+    auto vk = mDvk;
 
-    AutoLock lock(sVkEmulationLock);
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto bufferInfo = android::base::find(sVkEmulation->buffers, bufferHandle);
+    auto bufferInfo = android::base::find(mBuffers, bufferHandle);
     if (!bufferInfo) {
         ERR("Failed to read from Buffer:%d, not found.", bufferHandle);
         return false;
     }
 
-    const auto& stagingBufferInfo = sVkEmulation->staging;
+    const auto& stagingBufferInfo = mStaging;
     if (size > stagingBufferInfo.size) {
         ERR("Failed to read from Buffer:%d, staging buffer too small.", bufferHandle);
         return false;
@@ -3689,25 +3786,22 @@ bool readBufferToBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size, vo
         .pNext = nullptr,
         .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
     };
+    VK_CHECK(vk->vkBeginCommandBuffer(mCommandBuffer, &beginInfo));
 
-    VkCommandBuffer commandBuffer = sVkEmulation->commandBuffer;
-
-    VK_CHECK(vk->vkBeginCommandBuffer(commandBuffer, &beginInfo));
-
-    sVkEmulation->debugUtilsHelper.cmdBeginDebugLabel(commandBuffer, "readBufferToBytes(Buffer:%d)",
-                                                      bufferHandle);
+    mDebugUtilsHelper.cmdBeginDebugLabel(mCommandBuffer, "readBufferToBytes(Buffer:%d)",
+                                         bufferHandle);
 
     const VkBufferCopy bufferCopy = {
         .srcOffset = offset,
         .dstOffset = 0,
         .size = size,
     };
-    vk->vkCmdCopyBuffer(commandBuffer, bufferInfo->buffer, stagingBufferInfo.buffer, 1,
+    vk->vkCmdCopyBuffer(mCommandBuffer, bufferInfo->buffer, stagingBufferInfo.buffer, 1,
                         &bufferCopy);
 
-    sVkEmulation->debugUtilsHelper.cmdEndDebugLabel(commandBuffer);
+    mDebugUtilsHelper.cmdEndDebugLabel(mCommandBuffer);
 
-    VK_CHECK(vk->vkEndCommandBuffer(commandBuffer));
+    VK_CHECK(vk->vkEndCommandBuffer(mCommandBuffer));
 
     const VkSubmitInfo submitInfo = {
         .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
@@ -3716,23 +3810,21 @@ bool readBufferToBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size, vo
         .pWaitSemaphores = nullptr,
         .pWaitDstStageMask = nullptr,
         .commandBufferCount = 1,
-        .pCommandBuffers = &commandBuffer,
+        .pCommandBuffers = &mCommandBuffer,
         .signalSemaphoreCount = 0,
         .pSignalSemaphores = nullptr,
     };
 
     {
-        android::base::AutoLock lock(*sVkEmulation->queueLock);
-        VK_CHECK(vk->vkQueueSubmit(sVkEmulation->queue, 1, &submitInfo,
-                                   sVkEmulation->commandBufferFence));
+        android::base::AutoLock queueLock(*mQueueLock);
+        VK_CHECK(vk->vkQueueSubmit(mQueue, 1, &submitInfo, mCommandBufferFence));
     }
 
     static constexpr uint64_t ANB_MAX_WAIT_NS = 5ULL * 1000ULL * 1000ULL * 1000ULL;
 
-    VK_CHECK(vk->vkWaitForFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence,
-                                 VK_TRUE, ANB_MAX_WAIT_NS));
+    VK_CHECK(vk->vkWaitForFences(mDevice, 1, &mCommandBufferFence, VK_TRUE, ANB_MAX_WAIT_NS));
 
-    VK_CHECK(vk->vkResetFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence));
+    VK_CHECK(vk->vkResetFences(mDevice, 1, &mCommandBufferFence));
 
     const VkMappedMemoryRange toInvalidate = {
         .sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
@@ -3742,7 +3834,7 @@ bool readBufferToBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size, vo
         .size = size,
     };
 
-    VK_CHECK(vk->vkInvalidateMappedMemoryRanges(sVkEmulation->device, 1, &toInvalidate));
+    VK_CHECK(vk->vkInvalidateMappedMemoryRanges(mDevice, 1, &toInvalidate));
 
     const void* srcPtr = reinterpret_cast<const void*>(
         reinterpret_cast<const char*>(stagingBufferInfo.memory.mappedPtr));
@@ -3753,24 +3845,19 @@ bool readBufferToBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size, vo
     return true;
 }
 
-bool updateBufferFromBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size,
-                           const void* bytes) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        ERR("VkEmulation not available.");
-        return false;
-    }
+bool VkEmulation::updateBufferFromBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size,
+                                        const void* bytes) {
+    auto vk = mDvk;
 
-    auto vk = sVkEmulation->dvk;
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    AutoLock lock(sVkEmulationLock);
-
-    auto bufferInfo = android::base::find(sVkEmulation->buffers, bufferHandle);
+    auto bufferInfo = android::base::find(mBuffers, bufferHandle);
     if (!bufferInfo) {
         ERR("Failed to update Buffer:%d, not found.", bufferHandle);
         return false;
     }
 
-    const auto& stagingBufferInfo = sVkEmulation->staging;
+    const auto& stagingBufferInfo = mStaging;
     if (size > stagingBufferInfo.size) {
         ERR("Failed to update Buffer:%d, staging buffer too small.", bufferHandle);
         return false;
@@ -3789,32 +3876,29 @@ bool updateBufferFromBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size
         .offset = 0,
         .size = size,
     };
-    VK_CHECK(vk->vkFlushMappedMemoryRanges(sVkEmulation->device, 1, &toFlush));
+    VK_CHECK(vk->vkFlushMappedMemoryRanges(mDevice, 1, &toFlush));
 
     const VkCommandBufferBeginInfo beginInfo = {
         .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
         .pNext = nullptr,
         .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
     };
+    VK_CHECK(vk->vkBeginCommandBuffer(mCommandBuffer, &beginInfo));
 
-    VkCommandBuffer commandBuffer = sVkEmulation->commandBuffer;
-
-    VK_CHECK(vk->vkBeginCommandBuffer(commandBuffer, &beginInfo));
-
-    sVkEmulation->debugUtilsHelper.cmdBeginDebugLabel(
-        commandBuffer, "updateBufferFromBytes(Buffer:%d)", bufferHandle);
+    mDebugUtilsHelper.cmdBeginDebugLabel(mCommandBuffer, "updateBufferFromBytes(Buffer:%d)",
+                                         bufferHandle);
 
     const VkBufferCopy bufferCopy = {
         .srcOffset = 0,
         .dstOffset = offset,
         .size = size,
     };
-    vk->vkCmdCopyBuffer(commandBuffer, stagingBufferInfo.buffer, bufferInfo->buffer, 1,
+    vk->vkCmdCopyBuffer(mCommandBuffer, stagingBufferInfo.buffer, bufferInfo->buffer, 1,
                         &bufferCopy);
 
-    sVkEmulation->debugUtilsHelper.cmdEndDebugLabel(commandBuffer);
+    mDebugUtilsHelper.cmdEndDebugLabel(mCommandBuffer);
 
-    VK_CHECK(vk->vkEndCommandBuffer(commandBuffer));
+    VK_CHECK(vk->vkEndCommandBuffer(mCommandBuffer));
 
     const VkSubmitInfo submitInfo = {
         .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
@@ -3823,34 +3907,33 @@ bool updateBufferFromBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size
         .pWaitSemaphores = nullptr,
         .pWaitDstStageMask = nullptr,
         .commandBufferCount = 1,
-        .pCommandBuffers = &commandBuffer,
+        .pCommandBuffers = &mCommandBuffer,
         .signalSemaphoreCount = 0,
         .pSignalSemaphores = nullptr,
     };
 
     {
-        android::base::AutoLock lock(*sVkEmulation->queueLock);
-        VK_CHECK(vk->vkQueueSubmit(sVkEmulation->queue, 1, &submitInfo,
-                                   sVkEmulation->commandBufferFence));
+        android::base::AutoLock queueLock(*mQueueLock);
+        VK_CHECK(vk->vkQueueSubmit(mQueue, 1, &submitInfo, mCommandBufferFence));
     }
 
     static constexpr uint64_t ANB_MAX_WAIT_NS = 5ULL * 1000ULL * 1000ULL * 1000ULL;
+    VK_CHECK(vk->vkWaitForFences(mDevice, 1, &mCommandBufferFence, VK_TRUE, ANB_MAX_WAIT_NS));
 
-    VK_CHECK(vk->vkWaitForFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence,
-                                 VK_TRUE, ANB_MAX_WAIT_NS));
-
-    VK_CHECK(vk->vkResetFences(sVkEmulation->device, 1, &sVkEmulation->commandBufferFence));
+    VK_CHECK(vk->vkResetFences(mDevice, 1, &mCommandBufferFence));
 
     return true;
 }
 
-VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_tohost(
+VkExternalMemoryHandleTypeFlags VkEmulation::transformExternalMemoryHandleTypeFlags_tohost(
     VkExternalMemoryHandleTypeFlags bits) {
     VkExternalMemoryHandleTypeFlags res = bits;
 
-    // Transform Android/Fuchsia/Linux bits to host bits.
+    // Drop OPAQUE_FD_BIT if it was set. Host's default external memory bits
+    // may set them again below
     if (bits & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT) {
         res &= ~VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        res |= getDefaultExternalMemoryHandleType();
     }
 
 #ifdef _WIN32
@@ -3858,43 +3941,36 @@ VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_tohost(
     res &= ~VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
 #endif
 
+    // Replace guest AHardwareBuffer bits with host's default external memory bits
     if (bits & VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID) {
         res &= ~VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID;
-
-        VkExternalMemoryHandleTypeFlagBits handleTypeNeeded = VK_EXT_MEMORY_HANDLE_TYPE_BIT;
-#if defined(__APPLE__)
-        if (sVkEmulation->instanceSupportsMoltenVK) {
-            // Using a different handle type when in MoltenVK mode
-            handleTypeNeeded = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
-        }
-#endif
-        res |= handleTypeNeeded;
+        res |= getDefaultExternalMemoryHandleType();
     }
 
+    // Replace guest Zircon VMO bits with host's default external memory bits
     if (bits & VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA) {
         res &= ~VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA;
-        res |= VK_EXT_MEMORY_HANDLE_TYPE_BIT;
+        res |= getDefaultExternalMemoryHandleType();
     }
 
-#if defined(__QNX__)
-    // QNX only: Replace DMA_BUF_BIT_EXT with SCREEN_BUFFER_BIT_QNX for host calls
-    if (bits & VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT) {
+    // If the host does not support dmabuf, replace guest Linux DMA_BUF bits with
+    // the host's default external memory bits,
+    if (!mDeviceInfo.supportsDmaBuf && (bits & VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT)) {
         res &= ~VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
-        res |= VK_EXT_MEMORY_HANDLE_TYPE_BIT;
+        res |= getDefaultExternalMemoryHandleType();
     }
-#endif
 
     return res;
 }
 
-VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_fromhost(
+VkExternalMemoryHandleTypeFlags VkEmulation::transformExternalMemoryHandleTypeFlags_fromhost(
     VkExternalMemoryHandleTypeFlags hostBits,
     VkExternalMemoryHandleTypeFlags wantedGuestHandleType) {
     VkExternalMemoryHandleTypeFlags res = hostBits;
 
-    VkExternalMemoryHandleTypeFlagBits handleTypeUsed = VK_EXT_MEMORY_HANDLE_TYPE_BIT;
+    VkExternalMemoryHandleTypeFlagBits handleTypeUsed = getDefaultExternalMemoryHandleType();
 #if defined(__APPLE__)
-    if (sVkEmulation->instanceSupportsMoltenVK) {
+    if (mInstanceSupportsMoltenVK) {
         // Using a different handle type when in MoltenVK mode
         handleTypeUsed = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
     }
@@ -3912,7 +3988,7 @@ VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_fromhost(
     return res;
 }
 
-VkExternalMemoryProperties transformExternalMemoryProperties_tohost(
+VkExternalMemoryProperties VkEmulation::transformExternalMemoryProperties_tohost(
     VkExternalMemoryProperties props) {
     VkExternalMemoryProperties res = props;
     res.exportFromImportedHandleTypes =
@@ -3922,7 +3998,7 @@ VkExternalMemoryProperties transformExternalMemoryProperties_tohost(
     return res;
 }
 
-VkExternalMemoryProperties transformExternalMemoryProperties_fromhost(
+VkExternalMemoryProperties VkEmulation::transformExternalMemoryProperties_fromhost(
     VkExternalMemoryProperties props, VkExternalMemoryHandleTypeFlags wantedGuestHandleType) {
     VkExternalMemoryProperties res = props;
     res.exportFromImportedHandleTypes = transformExternalMemoryHandleTypeFlags_fromhost(
@@ -3932,10 +4008,10 @@ VkExternalMemoryProperties transformExternalMemoryProperties_fromhost(
     return res;
 }
 
-void setColorBufferCurrentLayout(uint32_t colorBufferHandle, VkImageLayout layout) {
-    AutoLock lock(sVkEmulationLock);
+void VkEmulation::setColorBufferCurrentLayout(uint32_t colorBufferHandle, VkImageLayout layout) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto infoPtr = android::base::find(mColorBuffers, colorBufferHandle);
     if (!infoPtr) {
         ERR("Invalid ColorBuffer handle %d.", static_cast<int>(colorBufferHandle));
         return;
@@ -3943,10 +4019,10 @@ void setColorBufferCurrentLayout(uint32_t colorBufferHandle, VkImageLayout layou
     infoPtr->currentLayout = layout;
 }
 
-VkImageLayout getColorBufferCurrentLayout(uint32_t colorBufferHandle) {
-    AutoLock lock(sVkEmulationLock);
+VkImageLayout VkEmulation::getColorBufferCurrentLayout(uint32_t colorBufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto infoPtr = android::base::find(mColorBuffers, colorBufferHandle);
     if (!infoPtr) {
         ERR("Invalid ColorBuffer handle %d.", static_cast<int>(colorBufferHandle));
         return VK_IMAGE_LAYOUT_UNDEFINED;
@@ -3954,40 +4030,10 @@ VkImageLayout getColorBufferCurrentLayout(uint32_t colorBufferHandle) {
     return infoPtr->currentLayout;
 }
 
-void setColorBufferLatestUse(uint32_t colorBufferHandle, DeviceOpWaitable waitable,
-                             DeviceOpTrackerPtr tracker) {
-    AutoLock lock(sVkEmulationLock);
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
-    if (!infoPtr) {
-        ERR("Invalid ColorBuffer handle %d.", static_cast<int>(colorBufferHandle));
-        return;
-    }
-
-    infoPtr->latestUse = waitable;
-    infoPtr->latestUseTracker = tracker;
-}
-
-int waitSyncVkColorBuffer(uint32_t colorBufferHandle) {
-    AutoLock lock(sVkEmulationLock);
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
-    if (!infoPtr) {
-        ERR("Invalid ColorBuffer handle %d.", static_cast<int>(colorBufferHandle));
-        return -1;
-    }
-
-    if (infoPtr->latestUse && infoPtr->latestUseTracker) {
-        while (!IsDone(*infoPtr->latestUse)) {
-            infoPtr->latestUseTracker->Poll();
-        }
-    }
-
-    return 0;
-}
-
 // Allocate a ready to use VkCommandBuffer for queue transfer. The caller needs
 // to signal the returned VkFence when the VkCommandBuffer completes.
-static std::tuple<VkCommandBuffer, VkFence> allocateQueueTransferCommandBuffer_locked() {
-    auto vk = sVkEmulation->dvk;
+std::tuple<VkCommandBuffer, VkFence> VkEmulation::allocateQueueTransferCommandBufferLocked() {
+    auto vk = mDvk;
     // Check if a command buffer in the pool is ready to use. If the associated
     // VkFence is ready, vkGetFenceStatus will return VK_SUCCESS, and the
     // associated command buffer should be ready to use, so we return that
@@ -3996,10 +4042,10 @@ static std::tuple<VkCommandBuffer, VkFence> allocateQueueTransferCommandBuffer_l
     // search and test the next command buffer. If the VkFence is in an error
     // state, vkGetFenceStatus will return with other VkResult variants, we will
     // abort.
-    for (auto& [commandBuffer, fence] : sVkEmulation->transferQueueCommandBufferPool) {
-        auto res = vk->vkGetFenceStatus(sVkEmulation->device, fence);
+    for (auto& [commandBuffer, fence] : mTransferQueueCommandBufferPool) {
+        auto res = vk->vkGetFenceStatus(mDevice, fence);
         if (res == VK_SUCCESS) {
-            VK_CHECK(vk->vkResetFences(sVkEmulation->device, 1, &fence));
+            VK_CHECK(vk->vkResetFences(mDevice, 1, &fence));
             VK_CHECK(vk->vkResetCommandBuffer(commandBuffer,
                                               VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT));
             return std::make_tuple(commandBuffer, fence);
@@ -4015,43 +4061,38 @@ static std::tuple<VkCommandBuffer, VkFence> allocateQueueTransferCommandBuffer_l
     VkCommandBufferAllocateInfo allocateInfo = {
         .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
         .pNext = nullptr,
-        .commandPool = sVkEmulation->commandPool,
+        .commandPool = mCommandPool,
         .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
         .commandBufferCount = 1,
     };
-    VK_CHECK(vk->vkAllocateCommandBuffers(sVkEmulation->device, &allocateInfo, &commandBuffer));
+    VK_CHECK(vk->vkAllocateCommandBuffers(mDevice, &allocateInfo, &commandBuffer));
     VkFence fence;
     VkFenceCreateInfo fenceCi = {
         .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
         .pNext = nullptr,
         .flags = 0,
     };
-    VK_CHECK(vk->vkCreateFence(sVkEmulation->device, &fenceCi, nullptr, &fence));
+    VK_CHECK(vk->vkCreateFence(mDevice, &fenceCi, nullptr, &fence));
 
-    const int cbIndex = static_cast<int>(sVkEmulation->transferQueueCommandBufferPool.size());
-    sVkEmulation->transferQueueCommandBufferPool.emplace_back(commandBuffer, fence);
+    const int cbIndex = static_cast<int>(mTransferQueueCommandBufferPool.size());
+    mTransferQueueCommandBufferPool.emplace_back(commandBuffer, fence);
 
     VERBOSE(
         "Create a new command buffer for queue transfer for a total of %d "
         "transfer command buffers",
         (cbIndex + 1));
 
-    sVkEmulation->debugUtilsHelper.addDebugLabel(commandBuffer, "QueueTransferCommandBuffer:%d",
-                                                 cbIndex);
+    mDebugUtilsHelper.addDebugLabel(commandBuffer, "QueueTransferCommandBuffer:%d", cbIndex);
 
     return std::make_tuple(commandBuffer, fence);
 }
 
 const VkImageLayout kGuestUseDefaultImageLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
 
-void releaseColorBufferForGuestUse(uint32_t colorBufferHandle) {
-    if (!sVkEmulation || !sVkEmulation->live) {
-        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Host Vulkan device lost";
-    }
+void VkEmulation::releaseColorBufferForGuestUse(uint32_t colorBufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    AutoLock lock(sVkEmulationLock);
-
-    auto infoPtr = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto infoPtr = android::base::find(mColorBuffers, colorBufferHandle);
     if (!infoPtr) {
         ERR("Failed to find ColorBuffer handle %d.", static_cast<int>(colorBufferHandle));
         return;
@@ -4109,8 +4150,8 @@ void releaseColorBufferForGuestUse(uint32_t colorBufferHandle) {
         return;
     }
 
-    auto vk = sVkEmulation->dvk;
-    auto [commandBuffer, fence] = allocateQueueTransferCommandBuffer_locked();
+    auto vk = mDvk;
+    auto [commandBuffer, fence] = allocateQueueTransferCommandBufferLocked();
 
     VK_CHECK(vk->vkResetCommandBuffer(commandBuffer, 0));
 
@@ -4122,7 +4163,7 @@ void releaseColorBufferForGuestUse(uint32_t colorBufferHandle) {
     };
     VK_CHECK(vk->vkBeginCommandBuffer(commandBuffer, &beginInfo));
 
-    sVkEmulation->debugUtilsHelper.cmdBeginDebugLabel(
+    mDebugUtilsHelper.cmdBeginDebugLabel(
         commandBuffer, "releaseColorBufferForGuestUse(ColorBuffer:%d)", colorBufferHandle);
 
     if (layoutTransitionBarrier) {
@@ -4136,7 +4177,7 @@ void releaseColorBufferForGuestUse(uint32_t colorBufferHandle) {
                                  &queueTransferBarrier.value());
     }
 
-    sVkEmulation->debugUtilsHelper.cmdEndDebugLabel(commandBuffer);
+    mDebugUtilsHelper.cmdEndDebugLabel(commandBuffer);
 
     VK_CHECK(vk->vkEndCommandBuffer(commandBuffer));
 
@@ -4152,19 +4193,19 @@ void releaseColorBufferForGuestUse(uint32_t colorBufferHandle) {
         .pSignalSemaphores = nullptr,
     };
     {
-        android::base::AutoLock lock(*sVkEmulation->queueLock);
-        VK_CHECK(vk->vkQueueSubmit(sVkEmulation->queue, 1, &submitInfo, fence));
+        android::base::AutoLock queueLock(*mQueueLock);
+        VK_CHECK(vk->vkQueueSubmit(mQueue, 1, &submitInfo, fence));
     }
 
     static constexpr uint64_t ANB_MAX_WAIT_NS = 5ULL * 1000ULL * 1000ULL * 1000ULL;
-    VK_CHECK(vk->vkWaitForFences(sVkEmulation->device, 1, &fence, VK_TRUE, ANB_MAX_WAIT_NS));
+    VK_CHECK(vk->vkWaitForFences(mDevice, 1, &fence, VK_TRUE, ANB_MAX_WAIT_NS));
 }
 
-std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForComposition(uint32_t colorBufferHandle,
-                                                                     bool colorBufferIsTarget) {
-    AutoLock lock(sVkEmulationLock);
+std::unique_ptr<BorrowedImageInfoVk> VkEmulation::borrowColorBufferForComposition(
+    uint32_t colorBufferHandle, bool colorBufferIsTarget) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto colorBufferInfo = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto colorBufferInfo = android::base::find(mColorBuffers, colorBufferHandle);
     if (!colorBufferInfo) {
         ERR("Invalid ColorBuffer handle %d.", static_cast<int>(colorBufferHandle));
         return nullptr;
@@ -4179,10 +4220,10 @@ std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForComposition(uint32_t co
     compositorInfo->imageCreateInfo = colorBufferInfo->imageCreateInfoShallow;
     compositorInfo->preBorrowLayout = colorBufferInfo->currentLayout;
     compositorInfo->preBorrowQueueFamilyIndex = colorBufferInfo->currentQueueFamilyIndex;
-    if (colorBufferIsTarget && sVkEmulation->displayVk) {
+    if (colorBufferIsTarget && mDisplayVk) {
         // Instruct the compositor to perform the layout transition after use so
         // that it is ready to be blitted to the display.
-        compositorInfo->postBorrowQueueFamilyIndex = sVkEmulation->queueFamilyIndex;
+        compositorInfo->postBorrowQueueFamilyIndex = mQueueFamilyIndex;
         compositorInfo->postBorrowLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
     } else {
         // Instruct the compositor to perform the queue transfer release after use
@@ -4201,10 +4242,11 @@ std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForComposition(uint32_t co
     return compositorInfo;
 }
 
-std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForDisplay(uint32_t colorBufferHandle) {
-    AutoLock lock(sVkEmulationLock);
+std::unique_ptr<BorrowedImageInfoVk> VkEmulation::borrowColorBufferForDisplay(
+    uint32_t colorBufferHandle) {
+    std::lock_guard<std::mutex> lock(mMutex);
 
-    auto colorBufferInfo = android::base::find(sVkEmulation->colorBuffers, colorBufferHandle);
+    auto colorBufferInfo = android::base::find(mColorBuffers, colorBufferHandle);
     if (!colorBufferInfo) {
         ERR("Invalid ColorBuffer handle %d.", static_cast<int>(colorBufferHandle));
         return nullptr;
@@ -4218,7 +4260,7 @@ std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForDisplay(uint32_t colorB
     compositorInfo->imageView = colorBufferInfo->imageView;
     compositorInfo->imageCreateInfo = colorBufferInfo->imageCreateInfoShallow;
     compositorInfo->preBorrowLayout = colorBufferInfo->currentLayout;
-    compositorInfo->preBorrowQueueFamilyIndex = sVkEmulation->queueFamilyIndex;
+    compositorInfo->preBorrowQueueFamilyIndex = mQueueFamilyIndex;
 
     // Instruct the display to perform the queue transfer release after use so
     // that the color buffer can be acquired by the guest.
@@ -4232,7 +4274,7 @@ std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForDisplay(uint32_t colorB
 }
 
 std::optional<VkEmulation::RepresentativeColorBufferMemoryTypeInfo>
-findRepresentativeColorBufferMemoryTypeIndexLocked() {
+VkEmulation::findRepresentativeColorBufferMemoryTypeIndexLocked() {
     constexpr const uint32_t kArbitraryWidth = 64;
     constexpr const uint32_t kArbitraryHeight = 64;
     constexpr const uint32_t kArbitraryHandle = std::numeric_limits<uint32_t>::max();
@@ -4242,10 +4284,6 @@ findRepresentativeColorBufferMemoryTypeIndexLocked() {
         ERR("Failed to setup memory type index test ColorBuffer.");
         return std::nullopt;
     }
-    if (!initializeVkColorBufferLocked(kArbitraryHandle)) {
-        ERR("Failed to initialize memory type index test ColorBuffer.");
-        return std::nullopt;
-    }
 
     uint32_t hostMemoryTypeIndex = 0;
     if (!getColorBufferAllocationInfoLocked(kArbitraryHandle, nullptr, &hostMemoryTypeIndex,
@@ -4259,8 +4297,8 @@ findRepresentativeColorBufferMemoryTypeIndexLocked() {
         return std::nullopt;
     }
 
-    EmulatedPhysicalDeviceMemoryProperties helper(sVkEmulation->deviceInfo.memProps,
-                                                  hostMemoryTypeIndex, sVkEmulation->features);
+    EmulatedPhysicalDeviceMemoryProperties helper(mDeviceInfo.memProps, hostMemoryTypeIndex,
+                                                  mFeatures);
     uint32_t guestMemoryTypeIndex = helper.getGuestColorBufferMemoryTypeIndex();
 
     return VkEmulation::RepresentativeColorBufferMemoryTypeInfo{
diff --git a/host/vulkan/VkCommonOperations.h b/host/vulkan/VkCommonOperations.h
index 389182745..9e14b4dc5 100644
--- a/host/vulkan/VkCommonOperations.h
+++ b/host/vulkan/VkCommonOperations.h
@@ -27,23 +27,19 @@
 #include "CompositorVk.h"
 #include "DebugUtilsHelper.h"
 #include "DeviceLostHelper.h"
-#include "DeviceOpTracker.h"
 #include "DisplayVk.h"
+#include "ExternalObjectManager.h"
 #include "FrameworkFormats.h"
-#include "aemu/base/ManagedDescriptor.hpp"
 #include "aemu/base/Optional.h"
-#include "aemu/base/synchronization/Lock.h"
+#include "aemu/base/ThreadAnnotations.h"
 #include "gfxstream/host/BackendCallbacks.h"
 #include "gfxstream/host/Features.h"
 #include "goldfish_vk_private_defs.h"
 #include "utils/GfxApiLogger.h"
 #include "utils/RenderDoc.h"
 
-#ifdef _WIN32
-typedef void* HANDLE;
-#endif
-
 #if defined(_WIN32)
+typedef void* HANDLE;
 // External sync objects are HANDLE on Windows
 typedef HANDLE VK_EXT_SYNC_HANDLE;
 // corresponds to INVALID_HANDLE_VALUE
@@ -54,25 +50,6 @@ typedef int VK_EXT_SYNC_HANDLE;
 #define VK_EXT_SYNC_HANDLE_INVALID (-1)
 #endif
 
-#if defined(_WIN32)
-// External memory objects are HANDLE on Windows
-typedef HANDLE VK_EXT_MEMORY_HANDLE;
-// corresponds to INVALID_HANDLE_VALUE
-#define VK_EXT_MEMORY_HANDLE_INVALID (VK_EXT_MEMORY_HANDLE)(uintptr_t)(-1)
-#define VK_EXT_MEMORY_HANDLE_TYPE_BIT VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT
-#elif defined(__QNX__)
-#include <screen/screen.h>
-// External memory objects are screen_buffer_t handles on QNX
-typedef screen_buffer_t VK_EXT_MEMORY_HANDLE;
-#define VK_EXT_MEMORY_HANDLE_INVALID (VK_EXT_MEMORY_HANDLE) nullptr
-#define VK_EXT_MEMORY_HANDLE_TYPE_BIT VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX
-#else
-// External memory objects are fd's on other POSIX systems
-typedef int VK_EXT_MEMORY_HANDLE;
-#define VK_EXT_MEMORY_HANDLE_INVALID (-1)
-#define VK_EXT_MEMORY_HANDLE_TYPE_BIT VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT
-#endif
-
 namespace gfxstream {
 namespace vk {
 
@@ -86,8 +63,6 @@ bool getStagingMemoryTypeIndex(VulkanDispatch* vk, VkDevice device,
                                const VkPhysicalDeviceMemoryProperties* memProps,
                                uint32_t* typeIndex);
 
-VK_EXT_MEMORY_HANDLE dupExternalMemory(VK_EXT_MEMORY_HANDLE);
-
 enum class AstcEmulationMode {
     Disabled,  // No ASTC emulation (ie: ASTC not supported unless the GPU supports it natively)
     Cpu,       // Decompress ASTC textures on the CPU
@@ -100,146 +75,136 @@ enum class AstcEmulationMode {
 // associated with a ColorBuffer handle, and depending on host-side support for
 // GL_EXT_memory_object, also be able to zero-copy render into and readback
 // with the traditional GL pipeline.
-struct VkEmulation {
-    // Whether initialization succeeded.
-    bool live = false;
+class VkEmulation {
+   public:
+    ~VkEmulation();
 
-    gfxstream::host::BackendCallbacks callbacks;
+    static std::unique_ptr<VkEmulation> create(VulkanDispatch* vk,
+                                               gfxstream::host::BackendCallbacks callbacks,
+                                               gfxstream::host::FeatureSet features);
 
-    gfxstream::host::FeatureSet features;
+    struct Features {
+        bool glInteropSupported = false;
+        bool deferredCommands = false;
+        bool createResourceWithRequirements = false;
+        bool useVulkanComposition = false;
+        bool useVulkanNativeSwapchain = false;
+        std::unique_ptr<emugl::RenderDocWithMultipleVkInstances> guestRenderDoc = nullptr;
+        AstcEmulationMode astcLdrEmulationMode = AstcEmulationMode::Disabled;
+        bool enableEtc2Emulation = false;
+        bool enableYcbcrEmulation = false;
+        bool guestVulkanOnly = false;
+        bool useDedicatedAllocations = false;
+    };
+    void initFeatures(Features features);
 
-    // Whether to use deferred command submission.
-    bool useDeferredCommands = false;
+    bool isYcbcrEmulationEnabled() const;
 
-    // Whether to fuse memory requirements getting with resource creation.
-    bool useCreateResourcesWithRequirements = false;
+    bool isEtc2EmulationEnabled() const;
 
-    // RenderDoc integration for guest VkInstances.
-    std::unique_ptr<emugl::RenderDocWithMultipleVkInstances> guestRenderDoc = nullptr;
+    bool deferredCommandsEnabled() const;
+    bool createResourcesWithRequirementsEnabled() const;
 
-    // Whether to use ASTC emulation. Our current ASTC decoder implementation may lead to device
-    // lost on certain device on Windows.
-    AstcEmulationMode astcLdrEmulationMode = AstcEmulationMode::Disabled;
+    bool supportsExternalMemoryCapabilities() const;
+    bool supportsExternalSemaphoreCapabilities() const;
+    bool supportsExternalFenceCapabilities() const;
+    bool supportsSurfaces() const;
+    bool supportsMoltenVk() const;
 
-    // Whether to use ETC2 emulation.
-    bool enableEtc2Emulation = false;
+    bool supportsGetPhysicalDeviceProperties2() const;
 
-    // Whether to use Ycbcr emulation. If this feature is turned on, Ycbcr request will always use
-    // the emulation path regardless of whether the host Vulkan driver actually supports Ycbcr
-    // conversion or not.
-    bool enableYcbcrEmulation = false;
+    bool supportsPhysicalDeviceIDProperties() const;
 
-    bool guestVulkanOnly = false;
+    std::optional<std::array<uint8_t, VK_UUID_SIZE>> getDeviceUuid();
+    std::optional<std::array<uint8_t, VK_UUID_SIZE>> getDriverUuid();
 
-    bool useDedicatedAllocations = false;
+    bool supportsPrivateData() const;
 
-    // Instance and device for creating the system-wide shareable objects.
-    VkInstance instance = VK_NULL_HANDLE;
-    VkPhysicalDevice physdev = VK_NULL_HANDLE;
-    VkDevice device = VK_NULL_HANDLE;
+    bool supportsExternalMemoryImport() const;
 
-    // Physical device index
-    uint32_t physicalDeviceIndex = 0;
+    bool supportsDmaBuf() const;
 
-    // Global, instance and device dispatch tables.
-    VulkanDispatch* gvk = nullptr;
-    VulkanDispatch* ivk = nullptr;
-    VulkanDispatch* dvk = nullptr;
-
-    bool instanceSupportsPhysicalDeviceIDProperties = false;
-    bool instanceSupportsGetPhysicalDeviceProperties2 = false;
-    bool instanceSupportsExternalMemoryCapabilities = false;
-    bool instanceSupportsExternalSemaphoreCapabilities = false;
-    bool instanceSupportsExternalFenceCapabilities = false;
-    bool instanceSupportsSurface = false;
-    PFN_vkGetPhysicalDeviceImageFormatProperties2KHR getImageFormatProperties2Func = nullptr;
-    PFN_vkGetPhysicalDeviceProperties2KHR getPhysicalDeviceProperties2Func = nullptr;
-    PFN_vkGetPhysicalDeviceFeatures2 getPhysicalDeviceFeatures2Func = nullptr;
+    bool supportsExternalMemoryHostProperties() const;
 
-#if defined(__APPLE__)
-    bool instanceSupportsMoltenVK = false;
-#else
-    static const bool instanceSupportsMoltenVK = false;
-#endif
+    std::optional<VkPhysicalDeviceRobustness2FeaturesEXT> getRobustness2Features() const;
 
-    bool debugUtilsAvailableAndRequested = false;
-    DebugUtilsHelper debugUtilsHelper = DebugUtilsHelper::withUtilsDisabled();
+    VkPhysicalDeviceExternalMemoryHostPropertiesEXT externalMemoryHostProperties() const;
 
-    bool commandBufferCheckpointsSupportedAndRequested = false;
-    DeviceLostHelper deviceLostHelper{};
+    bool isGuestVulkanOnly() const;
 
-    // Queue, command pool, and command buffer
-    // for running commands to sync stuff system-wide.
-    // TODO(b/197362803): Encapsulate host side VkQueue and the lock.
-    VkQueue queue = VK_NULL_HANDLE;
-    std::shared_ptr<android::base::Lock> queueLock = nullptr;
-    uint32_t queueFamilyIndex = 0;
-    VkCommandPool commandPool = VK_NULL_HANDLE;
-    VkCommandBuffer commandBuffer = VK_NULL_HANDLE;
-    VkFence commandBufferFence = VK_NULL_HANDLE;
+    bool commandBufferCheckpointsEnabled() const;
 
-    struct ImageSupportInfo {
-        // Input parameters
-        VkFormat format;
-        VkImageType type;
-        VkImageTiling tiling;
-        VkImageUsageFlags usageFlags;
-        VkImageCreateFlags createFlags;
+    bool supportsSamplerYcbcrConversion() const;
 
-        // Output parameters
-        bool supported = false;
-        bool supportsExternalMemory = false;
-        bool requiresDedicatedAllocation = false;
+    bool debugUtilsEnabled() const;
 
-        // Keep the raw output around.
-        VkFormatProperties2 formatProps2;
-        VkImageFormatProperties2 imageFormatProps2;
-        VkExternalImageFormatProperties extFormatProps;
+    DebugUtilsHelper& getDebugUtilsHelper();
 
-        // Populated later when device is available.
-        uint32_t memoryTypeBits = 0;
-        bool memoryTypeBitsKnown = false;
-    };
+    DeviceLostHelper& getDeviceLostHelper();
 
-    std::vector<ImageSupportInfo> imageSupportInfo;
+    const gfxstream::host::FeatureSet& getFeatures() const;
 
-    struct DeviceSupportInfo {
-        bool hasGraphicsQueueFamily = false;
-        bool hasComputeQueueFamily = false;
-        bool supportsExternalMemoryImport = false;
-        bool supportsExternalMemoryExport = false;
-        bool supportsDmaBuf = false;
-        bool supportsDriverProperties = false;
-        bool supportsExternalMemoryHostProps = false;
-        bool hasSamplerYcbcrConversionExtension = false;
-        bool supportsSamplerYcbcrConversion = false;
-        bool glInteropSupported = false;
-        bool hasNvidiaDeviceDiagnosticCheckpointsExtension = false;
-        bool supportsNvidiaDeviceDiagnosticCheckpoints = false;
-        bool supportsPrivateData = false;
+    const gfxstream::host::BackendCallbacks& getCallbacks() const;
 
-        std::vector<VkExtensionProperties> extensions;
+    AstcEmulationMode getAstcLdrEmulationMode() const;
 
-        std::vector<uint32_t> graphicsQueueFamilyIndices;
-        std::vector<uint32_t> computeQueueFamilyIndices;
+    emugl::RenderDocWithMultipleVkInstances* getRenderDoc();
 
-        VkPhysicalDeviceProperties physdevProps;
-        VkPhysicalDeviceMemoryProperties memProps;
-        VkPhysicalDeviceIDPropertiesKHR idProps;
-        VkPhysicalDeviceExternalMemoryHostPropertiesEXT externalMemoryHostProps;
+    Compositor* getCompositor();
 
-        std::string driverVendor;
-        std::string driverVersion;
+    DisplayVk* getDisplay();
 
-        PFN_vkGetImageMemoryRequirements2KHR getImageMemoryRequirements2Func = nullptr;
-        PFN_vkGetBufferMemoryRequirements2KHR getBufferMemoryRequirements2Func = nullptr;
+    VkInstance getInstance();
 
-#ifdef _WIN32
-        PFN_vkGetMemoryWin32HandleKHR getMemoryHandleFunc = nullptr;
-#else
-        PFN_vkGetMemoryFdKHR getMemoryHandleFunc = nullptr;
-#endif
+    std::string getGpuVendor() const;
+    std::string getGpuName() const;
+    std::string getGpuVersionString() const;
+    std::string getInstanceExtensionsString() const;
+    std::string getDeviceExtensionsString() const;
+
+    const VkPhysicalDeviceProperties getPhysicalDeviceProperties() const;
+
+    struct RepresentativeColorBufferMemoryTypeInfo {
+        // The host memory type index used for Buffer/ColorBuffer allocations.
+        uint32_t hostMemoryTypeIndex;
+
+        // The guest memory type index that will be returned to guest processes querying
+        // the memory type index of host AHardwareBuffer/ColorBuffer allocations. This may
+        // point to an emulated memory type so that the host can control which memory flags are
+        // exposed to the guest (i.e. hide VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT from the guest).
+        uint32_t guestMemoryTypeIndex;
     };
+    RepresentativeColorBufferMemoryTypeInfo getRepresentativeColorBufferMemoryTypeInfo() const;
+
+    void onVkDeviceLost();
+
+    VkExternalMemoryHandleTypeFlagBits getDefaultExternalMemoryHandleType();
+
+    std::unique_ptr<gfxstream::DisplaySurface> createDisplaySurface(FBNativeWindowType window,
+                                                                    uint32_t width,
+                                                                    uint32_t height);
+
+    // ColorBuffer operations
+
+    bool getColorBufferShareInfo(uint32_t colorBufferHandle, bool* glExported,
+                                 bool* externalMemoryCompatible);
+
+    bool getColorBufferAllocationInfo(uint32_t colorBufferHandle, VkDeviceSize* outSize,
+                                      uint32_t* outMemoryTypeIndex, bool* outMemoryIsDedicatedAlloc,
+                                      void** outMappedPtr);
+
+    std::unique_ptr<VkImageCreateInfo> generateColorBufferVkImageCreateInfo(VkFormat format,
+                                                                            uint32_t width,
+                                                                            uint32_t height,
+                                                                            VkImageTiling tiling);
+
+    bool isFormatSupported(GLenum format);
+
+    bool createVkColorBuffer(uint32_t width, uint32_t height, GLenum format,
+                             FrameworkFormat frameworkFormat, uint32_t colorBufferHandle,
+                             bool vulkanOnly, uint32_t memoryProperty);
+
+    bool teardownVkColorBuffer(uint32_t colorBufferHandle);
 
     struct ExternalMemoryInfo {
         // Input fields
@@ -264,27 +229,25 @@ struct VkEmulation {
         // guest physical address.
         uintptr_t gpa = 0u;
 
-        VK_EXT_MEMORY_HANDLE externalHandle = VK_EXT_MEMORY_HANDLE_INVALID;
+        std::optional<ExternalHandleInfo> handleInfo = std::nullopt;
 #ifdef __APPLE__
         // This is used as an external handle when MoltenVK is enabled
         MTLResource_id externalMetalHandle = nullptr;
 #endif
-        uint32_t streamHandleType;
 
         bool dedicatedAllocation = false;
     };
 
-    // 128 mb staging buffer (really, just a few 4K frames or one 4k HDR frame)
-    // ought to be big enough for anybody!
-    static constexpr VkDeviceSize kDefaultStagingBufferSize = 128ULL * 1048576ULL;
+    bool allocExternalMemory(
+        VulkanDispatch* vk, ExternalMemoryInfo* info, bool actuallyExternal = true,
+        android::base::Optional<uint64_t> deviceAlignment = android::base::kNullopt,
+        android::base::Optional<VkBuffer> bufferForDedicatedAllocation = android::base::kNullopt,
+        android::base::Optional<VkImage> imageForDedicatedAllocation = android::base::kNullopt);
 
-    struct StagingBufferInfo {
-        // TODO: Don't actually use this as external memory until host visible
-        // external is supported on all platforms
-        ExternalMemoryInfo memory;
-        VkBuffer buffer = VK_NULL_HANDLE;
-        VkDeviceSize size = kDefaultStagingBufferSize;
-    };
+    bool importExternalMemory(VulkanDispatch* vk, VkDevice targetDevice,
+                              const ExternalMemoryInfo* info,
+                              VkMemoryDedicatedAllocateInfo* dedicatedAllocInfo,
+                              VkDeviceMemory* out);
 
     enum class VulkanMode {
         // Default: ColorBuffers can still be used with the existing GL-based
@@ -324,6 +287,7 @@ struct VkEmulation {
 
         VulkanOnly = 1,
     };
+
     struct ColorBufferInfo {
         ExternalMemoryInfo memory;
 
@@ -342,7 +306,6 @@ struct VkEmulation {
         VkImageView imageView = VK_NULL_HANDLE;
         VkSamplerYcbcrConversion ycbcrConversion = VK_NULL_HANDLE;
         VkImageCreateInfo imageCreateInfoShallow = {};
-        VkMemoryRequirements memReqs;
 
         VkImageLayout currentLayout = VK_IMAGE_LAYOUT_UNDEFINED;
         uint32_t currentQueueFamilyIndex = VK_QUEUE_FAMILY_EXTERNAL;
@@ -351,10 +314,8 @@ struct VkEmulation {
         bool externalMemoryCompatible = false;
 
         VulkanMode vulkanMode = VulkanMode::Default;
-
-        std::optional<DeviceOpWaitable> latestUse;
-        DeviceOpTrackerPtr latestUseTracker = nullptr;
     };
+    std::optional<VkEmulation::ColorBufferInfo> getColorBufferInfo(uint32_t colorBufferHandle);
 
     struct BufferInfo {
         ExternalMemoryInfo memory;
@@ -366,224 +327,345 @@ struct VkEmulation {
         VkSharingMode sharingMode;
 
         VkBuffer buffer = VK_NULL_HANDLE;
-        VkMemoryRequirements memReqs;
 
         bool glExported = false;
         VulkanMode vulkanMode = VulkanMode::Default;
     };
 
-    // Track what is supported on whatever device was selected.
-    DeviceSupportInfo deviceInfo;
+    std::optional<ExternalHandleInfo> dupColorBufferExtMemoryHandle(uint32_t colorBufferHandle);
+#ifdef __APPLE__
+    MTLResource_id getColorBufferMetalMemoryHandle(uint32_t colorBufferHandle);
+    VkImage getColorBufferVkImage(uint32_t colorBufferHandle);
+#endif
 
-    // Track additional vulkan diagnostics
-    uint32_t vulkanInstanceVersion;
-    std::vector<VkExtensionProperties> instanceExtensions;
+    struct VkColorBufferMemoryExport {
+        ExternalHandleInfo handleInfo;
+        uint64_t size = 0;
+        bool linearTiling = false;
+        bool dedicatedAllocation = false;
+    };
+    std::optional<VkColorBufferMemoryExport> exportColorBufferMemory(uint32_t colorBufferHandle);
 
-    // A single staging buffer to perform most transfers to/from OpenGL on the
-    // host. It is shareable across instances. The memory is shareable but the
-    // buffer is not; other users need to create buffers that
-    // bind to imported versions of the memory.
-    StagingBufferInfo staging;
+    bool setColorBufferVulkanMode(uint32_t colorBufferHandle, uint32_t vulkanMode);
+    int32_t mapGpaToBufferHandle(uint32_t bufferHandle, uint64_t gpa, uint64_t size = 0);
 
-    // ColorBuffers are intended to back the guest's shareable images.
-    // For example:
-    // Android: gralloc
-    // Fuchsia: ImagePipeHandle
-    // Linux: dmabuf
-    std::unordered_map<uint32_t, ColorBufferInfo> colorBuffers;
+    bool colorBufferNeedsUpdateBetweenGlAndVk(uint32_t colorBufferHandle);
 
-    // Buffers are intended to back the guest's shareable Vulkan buffers.
-    std::unordered_map<uint32_t, BufferInfo> buffers;
+    bool readColorBufferToBytes(uint32_t colorBufferHandle, std::vector<uint8_t>* bytes);
+    bool readColorBufferToBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
+                                uint32_t h, void* outPixels, uint64_t outPixelsSize);
 
-    // In order to support VK_KHR_external_memory_(fd|win32) we need also to
-    // support the concept of plain external memories that are just memory and
-    // not necessarily images. These are then intended to pass through to the
-    // guest in some way, with 1:1 mapping between guest and host external
-    // memory handles.
-    std::unordered_map<uint32_t, ExternalMemoryInfo> externalMemories;
+    bool updateColorBufferFromBytes(uint32_t colorBufferHandle, const std::vector<uint8_t>& bytes);
+    bool updateColorBufferFromBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
+                                    uint32_t h, const void* pixels);
 
-    // The host keeps a set of occupied guest memory addresses to avoid a
-    // host memory address mapped to guest twice.
-    std::unordered_set<uint64_t> occupiedGpas;
+    // Data buffer operations
+    bool getBufferAllocationInfo(uint32_t bufferHandle, VkDeviceSize* outSize,
+                                 uint32_t* outMemoryTypeIndex, bool* outMemoryIsDedicatedAlloc);
 
-    // We can also consider using a single external memory object to back all
-    // host visible allocations in the guest. This would save memory, but we
-    // would also need to automatically add
-    // VkExternalMemory(Image|Buffer)CreateInfo, or if it is already there, OR
-    // it with the handle types on the host.
-    // A rough sketch: Some memories/images/buffers in the guest
-    // are backed by host visible memory:
-    // There is already a virtual memory type for those things in the current
-    // implementation. The guest doesn't know whether the pointer or the
-    // VkDeviceMemory object is backed by host external or non external.
-    // TODO: are all possible buffer / image usages compatible with
-    // external backing?
-    // TODO: try switching to this
-    ExternalMemoryInfo virtualHostVisibleHeap;
+    bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly = false,
+                       uint32_t memoryProperty = 0);
+    bool teardownVkBuffer(uint32_t bufferHandle);
 
-    // Every command buffer in the pool is associated with a VkFence which is
-    // signaled only if the command buffer completes.
-    std::vector<std::tuple<VkCommandBuffer, VkFence>> transferQueueCommandBufferPool;
+    std::optional<GenericDescriptorInfo> exportMemoryHandle(VkDevice device, VkDeviceMemory memory);
+    std::optional<ExternalHandleInfo> dupBufferExtMemoryHandle(uint32_t bufferHandle);
+#ifdef __APPLE__
+    MTLResource_id getBufferMetalMemoryHandle(uint32_t bufferHandle);
+    MTLResource_id getMtlResourceFromVkDeviceMemory(VulkanDispatch* vk, VkDeviceMemory memory);
+#endif
 
-    std::unique_ptr<CompositorVk> compositorVk;
+    bool readBufferToBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size, void* outBytes);
+    bool updateBufferFromBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size,
+                               const void* bytes);
 
-    // The implementation for Vulkan native swapchain. Only initialized in initVkEmulationFeatures
-    // if useVulkanNativeSwapchain is set.
-    std::unique_ptr<DisplayVk> displayVk;
+    VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_tohost(
+        VkExternalMemoryHandleTypeFlags bits);
 
-    struct RepresentativeColorBufferMemoryTypeInfo {
-        // The host memory type index used for Buffer/ColorBuffer allocations.
-        uint32_t hostMemoryTypeIndex;
+    VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_fromhost(
+        VkExternalMemoryHandleTypeFlags hostBits,
+        VkExternalMemoryHandleTypeFlags wantedGuestHandleType);
 
-        // The guest memory type index that will be returned to guest processes querying
-        // the memory type index of host AHardwareBuffer/ColorBuffer allocations. This may
-        // point to an emulated memory type so that the host can control which memory flags are
-        // exposed to the guest (i.e. hide VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT from the guest).
-        uint32_t guestMemoryTypeIndex;
-    };
-    std::optional<RepresentativeColorBufferMemoryTypeInfo> representativeColorBufferMemoryTypeInfo;
-};
+    VkExternalMemoryProperties transformExternalMemoryProperties_tohost(
+        VkExternalMemoryProperties props);
 
-VkEmulation* createGlobalVkEmulation(VulkanDispatch* vk,
-                                     gfxstream::host::BackendCallbacks callbacks,
-                                     gfxstream::host::FeatureSet features);
-
-struct VkEmulationFeatures {
-    bool glInteropSupported = false;
-    bool deferredCommands = false;
-    bool createResourceWithRequirements = false;
-    bool useVulkanComposition = false;
-    bool useVulkanNativeSwapchain = false;
-    std::unique_ptr<emugl::RenderDocWithMultipleVkInstances> guestRenderDoc = nullptr;
-    AstcEmulationMode astcLdrEmulationMode = AstcEmulationMode::Disabled;
-    bool enableEtc2Emulation = false;
-    bool enableYcbcrEmulation = false;
-    bool guestVulkanOnly = false;
-    bool useDedicatedAllocations = false;
-};
-void initVkEmulationFeatures(std::unique_ptr<VkEmulationFeatures>);
+    VkExternalMemoryProperties transformExternalMemoryProperties_fromhost(
+        VkExternalMemoryProperties props, VkExternalMemoryHandleTypeFlags wantedGuestHandleType);
+
+    void setColorBufferCurrentLayout(uint32_t colorBufferHandle, VkImageLayout);
+
+    VkImageLayout getColorBufferCurrentLayout(uint32_t colorBufferHandle);
 
-VkEmulation* getGlobalVkEmulation();
-void teardownGlobalVkEmulation();
+    void releaseColorBufferForGuestUse(uint32_t colorBufferHandle);
 
-void onVkDeviceLost();
+    std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForComposition(uint32_t colorBufferHandle,
+                                                                         bool colorBufferIsTarget);
+    std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForDisplay(uint32_t colorBufferHandle);
 
-std::unique_ptr<gfxstream::DisplaySurface> createDisplaySurface(FBNativeWindowType window,
-                                                                uint32_t width, uint32_t height);
+   private:
+    VkEmulation() = default;
+
+    std::optional<RepresentativeColorBufferMemoryTypeInfo>
+    findRepresentativeColorBufferMemoryTypeIndexLocked() REQUIRES(mMutex);
+
+    struct ImageSupportInfo {
+        // Input parameters
+        VkFormat format;
+        VkImageType type;
+        VkImageTiling tiling;
+        VkImageUsageFlags usageFlags;
+        VkImageCreateFlags createFlags;
 
-bool allocExternalMemory(
-    VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* info, bool actuallyExternal = true,
-    android::base::Optional<uint64_t> deviceAlignment = android::base::kNullopt,
-    android::base::Optional<VkBuffer> bufferForDedicatedAllocation = android::base::kNullopt,
-    android::base::Optional<VkImage> imageForDedicatedAllocation = android::base::kNullopt);
-void freeExternalMemoryLocked(VulkanDispatch* vk, VkEmulation::ExternalMemoryInfo* info);
+        // Output parameters
+        bool supported = false;
+        bool supportsExternalMemory = false;
+        bool requiresDedicatedAllocation = false;
 
-bool importExternalMemory(VulkanDispatch* vk, VkDevice targetDevice,
-                          const VkEmulation::ExternalMemoryInfo* info, VkDeviceMemory* out);
-bool importExternalMemoryDedicatedImage(VulkanDispatch* vk, VkDevice targetDevice,
-                                        const VkEmulation::ExternalMemoryInfo* info, VkImage image,
-                                        VkDeviceMemory* out);
+        // Keep the raw output around.
+        VkFormatProperties2 formatProps2;
+        VkImageFormatProperties2 imageFormatProps2;
+        VkExternalImageFormatProperties extFormatProps;
+    };
 
-// ColorBuffer operations
+    static std::vector<VkEmulation::ImageSupportInfo> getBasicImageSupportList();
 
-bool getColorBufferShareInfo(uint32_t colorBufferHandle, bool* glExported,
-                             bool* externalMemoryCompatible);
+    // For a given ImageSupportInfo, populates usageWithExternalHandles and
+    // requiresDedicatedAllocation. memoryTypeBits are populated later once the
+    // device is created, because that needs a test image to be created.
+    // If we don't support external memory, it's assumed dedicated allocations are
+    // not needed.
+    // Precondition: sVkEmulation instance has been created and ext memory caps known.
+    // Returns false if the query failed.
+    bool populateImageFormatExternalMemorySupportInfo(VulkanDispatch* vk, VkPhysicalDevice physdev,
+                                                      ImageSupportInfo* info);
 
-bool getColorBufferAllocationInfo(uint32_t colorBufferHandle, VkDeviceSize* outSize,
-                                  uint32_t* outMemoryTypeIndex, bool* outMemoryIsDedicatedAlloc,
-                                  void** outMappedPtr);
+    struct DeviceSupportInfo {
+        bool hasGraphicsQueueFamily = false;
+        bool hasComputeQueueFamily = false;
+        bool supportsExternalMemoryImport = false;
+        bool supportsExternalMemoryExport = false;
+        bool supportsDmaBuf = false;
+        bool supportsDriverProperties = false;
+        bool supportsExternalMemoryHostProps = false;
+        bool hasSamplerYcbcrConversionExtension = false;
+        bool supportsSamplerYcbcrConversion = false;
+        bool glInteropSupported = false;
+        bool hasNvidiaDeviceDiagnosticCheckpointsExtension = false;
+        bool supportsNvidiaDeviceDiagnosticCheckpoints = false;
+        bool supportsPrivateData = false;
 
-std::unique_ptr<VkImageCreateInfo> generateColorBufferVkImageCreateInfo(VkFormat format,
-                                                                        uint32_t width,
-                                                                        uint32_t height,
-                                                                        VkImageTiling tiling);
+        std::vector<VkExtensionProperties> extensions;
 
-bool isFormatSupported(GLenum format);
+        std::vector<uint32_t> graphicsQueueFamilyIndices;
+        std::vector<uint32_t> computeQueueFamilyIndices;
 
-bool createVkColorBuffer(uint32_t width, uint32_t height, GLenum format,
-                         FrameworkFormat frameworkFormat, uint32_t colorBufferHandle,
-                         bool vulkanOnly, uint32_t memoryProperty);
+        VkPhysicalDeviceProperties physdevProps;
+        VkPhysicalDeviceMemoryProperties memProps;
+        VkPhysicalDeviceIDPropertiesKHR idProps;
+        VkPhysicalDeviceExternalMemoryHostPropertiesEXT externalMemoryHostProps;
 
-bool teardownVkColorBuffer(uint32_t colorBufferHandle);
+        std::string driverVendor;
+        std::string driverVersion;
 
-bool importExtMemoryHandleToVkColorBuffer(uint32_t colorBufferHandle, uint32_t type,
-                                          VK_EXT_MEMORY_HANDLE extMemHandle);
+        PFN_vkGetImageMemoryRequirements2KHR getImageMemoryRequirements2Func = nullptr;
+        PFN_vkGetBufferMemoryRequirements2KHR getBufferMemoryRequirements2Func = nullptr;
 
-VkEmulation::ColorBufferInfo getColorBufferInfo(uint32_t colorBufferHandle);
-VK_EXT_MEMORY_HANDLE getColorBufferExtMemoryHandle(uint32_t colorBufferHandle);
-#ifdef __APPLE__
-MTLResource_id getColorBufferMetalMemoryHandle(uint32_t colorBufferHandle);
-VkImage getColorBufferVkImage(uint32_t colorBufferHandle);
+#ifdef _WIN32
+        PFN_vkGetMemoryWin32HandleKHR getMemoryHandleFunc = nullptr;
+#else
+        PFN_vkGetMemoryFdKHR getMemoryHandleFunc = nullptr;
 #endif
 
-struct VkColorBufferMemoryExport {
-    android::base::ManagedDescriptor descriptor;
-    uint64_t size = 0;
-    uint32_t streamHandleType = 0;
-    bool linearTiling = false;
-    bool dedicatedAllocation = false;
-};
-std::optional<VkColorBufferMemoryExport> exportColorBufferMemory(uint32_t colorBufferHandle);
+        // Set only if requested and supported
+        std::optional<VkPhysicalDeviceRobustness2FeaturesEXT> robustness2Features;
+    };
 
-bool setColorBufferVulkanMode(uint32_t colorBufferHandle, uint32_t vulkanMode);
-int32_t mapGpaToBufferHandle(uint32_t bufferHandle, uint64_t gpa, uint64_t size = 0);
+    uint32_t getValidMemoryTypeIndex(uint32_t requiredMemoryTypeBits,
+                                     VkMemoryPropertyFlags memoryProperty = 0);
 
-bool colorBufferNeedsUpdateBetweenGlAndVk(uint32_t colorBufferHandle);
+    int getSelectedGpuIndex(const std::vector<DeviceSupportInfo>& deviceInfos);
 
-bool readColorBufferToBytes(uint32_t colorBufferHandle, std::vector<uint8_t>* bytes);
-bool readColorBufferToBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                            uint32_t h, void* outPixels, uint64_t outPixelsSize);
-bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                                  uint32_t h, void* outPixels, uint64_t outPixelsSize);
+    bool isFormatVulkanCompatible(GLenum internalFormat);
 
-bool updateColorBufferFromBytes(uint32_t colorBufferHandle, const std::vector<uint8_t>& bytes);
-bool updateColorBufferFromBytes(uint32_t colorBufferHandle, uint32_t x, uint32_t y, uint32_t w,
-                                uint32_t h, const void* pixels);
+    bool getColorBufferAllocationInfoLocked(uint32_t colorBufferHandle, VkDeviceSize* outSize,
+                                            uint32_t* outMemoryTypeIndex,
+                                            bool* outMemoryIsDedicatedAlloc, void** outMappedPtr) REQUIRES(mMutex);
 
-// Data buffer operations
-bool getBufferAllocationInfo(uint32_t bufferHandle, VkDeviceSize* outSize,
-                             uint32_t* outMemoryTypeIndex, bool* outMemoryIsDedicatedAlloc);
+    std::unique_ptr<VkImageCreateInfo> generateColorBufferVkImageCreateInfoLocked(
+        VkFormat format, uint32_t width, uint32_t height, VkImageTiling tiling) REQUIRES(mMutex);
 
-bool setupVkBuffer(uint64_t size, uint32_t bufferHandle, bool vulkanOnly = false,
-                   uint32_t memoryProperty = 0);
-bool teardownVkBuffer(uint32_t bufferHandle);
+    bool createVkColorBufferLocked(uint32_t width, uint32_t height, GLenum internalFormat,
+                                   FrameworkFormat frameworkFormat, uint32_t colorBufferHandle,
+                                   bool vulkanOnly, uint32_t memoryProperty) REQUIRES(mMutex);
 
-VK_EXT_MEMORY_HANDLE getBufferExtMemoryHandle(uint32_t bufferHandle, uint32_t* outStreamHandleType);
-#ifdef __APPLE__
-MTLResource_id getBufferMetalMemoryHandle(uint32_t bufferHandle);
+    bool teardownVkColorBufferLocked(uint32_t colorBufferHandle) REQUIRES(mMutex);
+
+    bool colorBufferNeedsUpdateBetweenGlAndVk(const VkEmulation::ColorBufferInfo& colorBufferInfo);
+
+    bool readColorBufferToBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32_t y,
+                                      uint32_t w, uint32_t h, void* outPixels,
+                                      uint64_t outPixelsSize) REQUIRES(mMutex);
+
+    bool updateColorBufferFromBytesLocked(uint32_t colorBufferHandle, uint32_t x, uint32_t y,
+                                          uint32_t w, uint32_t h, const void* pixels,
+                                          size_t inputPixelsSize) REQUIRES(mMutex);
+
+    bool updateMemReqsForExtMem(std::optional<ExternalHandleInfo> extMemHandleInfo,
+                                VkMemoryRequirements* pMemReqs);
+
+    std::tuple<VkCommandBuffer, VkFence> allocateQueueTransferCommandBufferLocked() REQUIRES(mMutex);
+
+    void freeExternalMemoryLocked(VulkanDispatch* vk, ExternalMemoryInfo* info) REQUIRES(mMutex);
+
+    std::mutex mMutex;
+
+    gfxstream::host::BackendCallbacks mCallbacks;
+
+    gfxstream::host::FeatureSet mFeatures;
+
+    RepresentativeColorBufferMemoryTypeInfo mRepresentativeColorBufferMemoryTypeInfo;
+
+    // Whether to use deferred command submission.
+    bool mUseDeferredCommands = false;
+
+    // Whether to fuse memory requirements getting with resource creation.
+    bool mUseCreateResourcesWithRequirements = false;
+
+    // RenderDoc integration for guest VkInstances.
+    std::unique_ptr<emugl::RenderDocWithMultipleVkInstances> mGuestRenderDoc;
+
+    // Whether to use ASTC emulation. Our current ASTC decoder implementation may lead to device
+    // lost on certain device on Windows.
+    AstcEmulationMode mAstcLdrEmulationMode = AstcEmulationMode::Disabled;
+
+    // Whether to use ETC2 emulation.
+    bool mEnableEtc2Emulation = false;
+
+    // Whether to use Ycbcr emulation. If this feature is turned on, Ycbcr request will always use
+    // the emulation path regardless of whether the host Vulkan driver actually supports Ycbcr
+    // conversion or not.
+    bool mEnableYcbcrEmulation = false;
+
+    bool mGuestVulkanOnly = false;
+
+    bool mUseDedicatedAllocations = false;
+
+    // Instance and device for creating the system-wide shareable objects.
+    VkInstance mInstance = VK_NULL_HANDLE;
+    uint32_t mVulkanInstanceVersion = 0;
+    std::vector<VkExtensionProperties> mInstanceExtensions;
+
+    uint32_t mPhysicalDeviceIndex = 0;
+    VkPhysicalDevice mPhysicalDevice = VK_NULL_HANDLE;
+
+    VkDevice mDevice = VK_NULL_HANDLE;
+
+    // Global, instance and device dispatch tables.
+    VulkanDispatch* mGvk = nullptr;
+    VulkanDispatch* mIvk = nullptr;
+    VulkanDispatch* mDvk = nullptr;
+
+    bool mInstanceSupportsPhysicalDeviceIDProperties = false;
+    bool mInstanceSupportsGetPhysicalDeviceProperties2 = false;
+    bool mInstanceSupportsExternalMemoryCapabilities = false;
+    bool mInstanceSupportsExternalSemaphoreCapabilities = false;
+    bool mInstanceSupportsExternalFenceCapabilities = false;
+    bool mInstanceSupportsSurface = false;
+#if defined(__APPLE__)
+    bool mInstanceSupportsMoltenVK = false;
+#else
+    static const bool mInstanceSupportsMoltenVK = false;
 #endif
 
-bool readBufferToBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size, void* outBytes);
-bool updateBufferFromBytes(uint32_t bufferHandle, uint64_t offset, uint64_t size,
-                           const void* bytes);
+    PFN_vkGetPhysicalDeviceImageFormatProperties2KHR mGetImageFormatProperties2Func = nullptr;
+    PFN_vkGetPhysicalDeviceProperties2KHR mGetPhysicalDeviceProperties2Func = nullptr;
+    PFN_vkGetPhysicalDeviceFeatures2 mGetPhysicalDeviceFeatures2Func = nullptr;
+
+    bool mDebugUtilsAvailableAndRequested = false;
+    DebugUtilsHelper mDebugUtilsHelper = DebugUtilsHelper::withUtilsDisabled();
+
+    bool mCommandBufferCheckpointsSupportedAndRequested = false;
+    DeviceLostHelper mDeviceLostHelper{};
+
+    // Queue, command pool, and command buffer
+    // for running commands to sync stuff system-wide.
+    // TODO(b/197362803): Encapsulate host side VkQueue and the lock.
+    VkQueue mQueue = VK_NULL_HANDLE;
+    std::shared_ptr<android::base::Lock> mQueueLock = nullptr;
+    uint32_t mQueueFamilyIndex = 0;
+
+    VkCommandPool mCommandPool = VK_NULL_HANDLE;
+    VkCommandBuffer mCommandBuffer = VK_NULL_HANDLE;
+    VkFence mCommandBufferFence = VK_NULL_HANDLE;
+
+    std::vector<ImageSupportInfo> mImageSupportInfo;
+
+    // 128 mb staging buffer (really, just a few 4K frames or one 4k HDR frame)
+    // ought to be big enough for anybody!
+    static constexpr VkDeviceSize kDefaultStagingBufferSize = 128ULL * 1048576ULL;
+
+    struct StagingBufferInfo {
+        // TODO: Don't actually use this as external memory until host visible
+        // external is supported on all platforms
+        ExternalMemoryInfo memory;
+        VkBuffer buffer = VK_NULL_HANDLE;
+        VkDeviceSize size = kDefaultStagingBufferSize;
+    };
 
-VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_tohost(
-    VkExternalMemoryHandleTypeFlags bits);
+    // Track what is supported on whatever device was selected.
+    DeviceSupportInfo mDeviceInfo;
 
-VkExternalMemoryHandleTypeFlags transformExternalMemoryHandleTypeFlags_fromhost(
-    VkExternalMemoryHandleTypeFlags hostBits,
-    VkExternalMemoryHandleTypeFlags wantedGuestHandleType);
+    // A single staging buffer to perform most transfers to/from OpenGL on the
+    // host. It is shareable across instances. The memory is shareable but the
+    // buffer is not; other users need to create buffers that
+    // bind to imported versions of the memory.
+    StagingBufferInfo mStaging GUARDED_BY(mMutex);
 
-VkExternalMemoryProperties transformExternalMemoryProperties_tohost(
-    VkExternalMemoryProperties props);
+    // ColorBuffers are intended to back the guest's shareable images.
+    // For example:
+    // Android: gralloc
+    // Fuchsia: ImagePipeHandle
+    // Linux: dmabuf
+    std::unordered_map<uint32_t, ColorBufferInfo> mColorBuffers GUARDED_BY(mMutex);
 
-VkExternalMemoryProperties transformExternalMemoryProperties_fromhost(
-    VkExternalMemoryProperties props, VkExternalMemoryHandleTypeFlags wantedGuestHandleType);
+    // Buffers are intended to back the guest's shareable Vulkan buffers.
+    std::unordered_map<uint32_t, BufferInfo> mBuffers GUARDED_BY(mMutex);
 
-void setColorBufferCurrentLayout(uint32_t colorBufferHandle, VkImageLayout);
+    // In order to support VK_KHR_external_memory_(fd|win32) we need also to
+    // support the concept of plain external memories that are just memory and
+    // not necessarily images. These are then intended to pass through to the
+    // guest in some way, with 1:1 mapping between guest and host external
+    // memory handles.
+    std::unordered_map<uint32_t, ExternalMemoryInfo> mExternalMemories GUARDED_BY(mMutex);
 
-VkImageLayout getColorBufferCurrentLayout(uint32_t colorBufferHandle);
+    // The host keeps a set of occupied guest memory addresses to avoid a
+    // host memory address mapped to guest twice.
+    std::unordered_set<uint64_t> mOccupiedGpas GUARDED_BY(mMutex);
 
-void setColorBufferLatestUse(uint32_t colorBufferHandle, DeviceOpWaitable waitable,
-                             DeviceOpTrackerPtr tracker);
+    // We can also consider using a single external memory object to back all
+    // host visible allocations in the guest. This would save memory, but we
+    // would also need to automatically add
+    // VkExternalMemory(Image|Buffer)CreateInfo, or if it is already there, OR
+    // it with the handle types on the host.
+    // A rough sketch: Some memories/images/buffers in the guest
+    // are backed by host visible memory:
+    // There is already a virtual memory type for those things in the current
+    // implementation. The guest doesn't know whether the pointer or the
+    // VkDeviceMemory object is backed by host external or non external.
+    // TODO: are all possible buffer / image usages compatible with
+    // external backing?
+    // TODO: try switching to this
+    ExternalMemoryInfo mVirtualHostVisibleHeap;
 
-int waitSyncVkColorBuffer(uint32_t colorBufferHandle);
+    // Every command buffer in the pool is associated with a VkFence which is
+    // signaled only if the command buffer completes.
+    std::vector<std::tuple<VkCommandBuffer, VkFence>> mTransferQueueCommandBufferPool GUARDED_BY(mMutex);
 
-void releaseColorBufferForGuestUse(uint32_t colorBufferHandle);
+    std::unique_ptr<CompositorVk> mCompositorVk;
 
-std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForComposition(uint32_t colorBufferHandle,
-                                                                     bool colorBufferIsTarget);
-std::unique_ptr<BorrowedImageInfoVk> borrowColorBufferForDisplay(uint32_t colorBufferHandle);
+    // The implementation for Vulkan native swapchain. Only initialized in initVkEmulationFeatures
+    // if useVulkanNativeSwapchain is set.
+    std::unique_ptr<DisplayVk> mDisplayVk;
+};
 
 }  // namespace vk
 }  // namespace gfxstream
diff --git a/host/vulkan/VkDecoder.cpp b/host/vulkan/VkDecoder.cpp
index ccc354a70..acf441fa1 100644
--- a/host/vulkan/VkDecoder.cpp
+++ b/host/vulkan/VkDecoder.cpp
@@ -40,6 +40,7 @@
 #include "FrameBuffer.h"
 #include "VkDecoderGlobalState.h"
 #include "VkDecoderSnapshot.h"
+#include "VulkanBoxedHandles.h"
 #include "VulkanDispatch.h"
 #include "VulkanStream.h"
 #include "aemu/base/BumpPool.h"
@@ -55,6 +56,8 @@
 #include "host-common/logging.h"
 #include "render-utils/IOStream.h"
 #define MAX_PACKET_LENGTH (400 * 1024 * 1024)  // 400MB
+#define CC_LIKELY(exp) (__builtin_expect(!!(exp), true))
+#define CC_UNLIKELY(exp) (__builtin_expect(!!(exp), false))
 
 namespace gfxstream {
 namespace vk {
@@ -70,14 +73,12 @@ class VkDecoder::Impl {
           m_state(VkDecoderGlobalState::get()),
           m_vkStream(nullptr, m_state->getFeatures()),
           m_vkMemReadingStream(nullptr, m_state->getFeatures()),
-          m_boxedHandleUnwrapMapping(m_state),
           m_boxedHandleCreateMapping(m_state),
-          m_boxedHandleDestroyMapping(m_state),
-          m_boxedHandleUnwrapAndDeleteMapping(m_state),
-          m_boxedHandleUnwrapAndDeletePreserveBoxedMapping(m_state),
+          m_boxedHandleUnwrapMapping(m_state),
           m_prevSeqno(std::nullopt),
           m_queueSubmitWithCommandsEnabled(
-              m_state->getFeatures().VulkanQueueSubmitWithCommands.enabled) {}
+              m_state->getFeatures().VulkanQueueSubmitWithCommands.enabled),
+          m_snapshotsEnabled(m_state->snapshotsEnabled()) {}
     VulkanStream* stream() { return &m_vkStream; }
     VulkanMemReadingStream* readStream() { return &m_vkMemReadingStream; }
 
@@ -93,14 +94,12 @@ class VkDecoder::Impl {
     VkDecoderGlobalState* m_state;
     VulkanStream m_vkStream;
     VulkanMemReadingStream m_vkMemReadingStream;
-    BoxedHandleUnwrapMapping m_boxedHandleUnwrapMapping;
     BoxedHandleCreateMapping m_boxedHandleCreateMapping;
-    BoxedHandleDestroyMapping m_boxedHandleDestroyMapping;
-    BoxedHandleUnwrapAndDeleteMapping m_boxedHandleUnwrapAndDeleteMapping;
+    BoxedHandleUnwrapMapping m_boxedHandleUnwrapMapping;
     android::base::BumpPool m_pool;
-    BoxedHandleUnwrapAndDeletePreserveBoxedMapping m_boxedHandleUnwrapAndDeletePreserveBoxedMapping;
     std::optional<uint32_t> m_prevSeqno;
     bool m_queueSubmitWithCommandsEnabled = false;
+    const bool m_snapshotsEnabled = false;
 };
 
 VkDecoder::VkDecoder() : mImpl(new VkDecoder::Impl()) {}
@@ -129,10 +128,8 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
     if (len < 8) return 0;
     unsigned char* ptr = (unsigned char*)buf;
     const unsigned char* const end = (const unsigned char*)buf + len;
-    if (m_forSnapshotLoad) {
-        ptr += m_state->setCreatedHandlesForSnapshotLoad(ptr);
-    }
     while (end - ptr >= 8) {
+        const uint8_t* packet = (const uint8_t*)ptr;
         uint32_t opcode = *(uint32_t*)ptr;
         uint32_t packetLen = *(uint32_t*)(ptr + 4);
 
@@ -151,7 +148,6 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
         vkReadStream->setBuf((uint8_t*)(ptr + 8));
         uint8_t* readStreamPtr = vkReadStream->getBuf();
         uint8_t** readStreamPtrPtr = &readStreamPtr;
-        uint8_t* snapshotTraceBegin = vkReadStream->beginTrace();
         vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
 
         std::unique_ptr<EventHangMetadata::HangAnnotations> executionData =
@@ -213,6 +209,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
             }
         }
 
+        VkSnapshotApiCallInfo* snapshotApiCallInfo = nullptr;
+        if (m_snapshotsEnabled) {
+            snapshotApiCallInfo = m_state->snapshot()->createApiCallInfo();
+        }
+
         gfx_logger.recordCommandExecution();
 
         auto executionWatchdog =
@@ -221,7 +222,6 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 .setAnnotations(std::move(executionData))
                 .build();
 
-        auto vk = m_vk;
         switch (opcode) {
 #ifdef VK_VERSION_1_0
             case OP_vkCreateInstance: {
@@ -264,9 +264,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pInstance);
                 }
-                VkResult vkCreateInstance_VkResult_return = (VkResult)0;
-                vkCreateInstance_VkResult_return =
-                    m_state->on_vkCreateInstance(&m_pool, pCreateInfo, pAllocator, pInstance);
+                VkResult vkCreateInstance_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                vkCreateInstance_VkResult_return = m_state->on_vkCreateInstance(
+                    &m_pool, snapshotApiCallInfo, pCreateInfo, pAllocator, pInstance);
                 if ((vkCreateInstance_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateInstance_VkResult_return, opcode, context);
@@ -278,13 +278,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((VkInstance*)pInstance, 8 * 1);
                 vkStream->write(&vkCreateInstance_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCreateInstance(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, vkCreateInstance_VkResult_return,
-                                                          pCreateInfo, pAllocator, pInstance);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCreateInstance(
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
+                        vkCreateInstance_VkResult_return, pCreateInfo, pAllocator, pInstance);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -301,6 +298,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
+                auto vk = dispatch_VkInstance(instance);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -319,14 +317,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkDestroyInstance 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)instance, (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyInstance(&m_pool, instance, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyInstance(&m_pool, snapshotApiCallInfo, instance,
+                                                  pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyInstance(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, instance, pAllocator);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyInstance(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, instance, pAllocator);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -344,6 +342,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
+                auto vk = dispatch_VkInstance(instance);
                 // Begin manual dispatchable handle unboxing for pPhysicalDeviceCount;
                 vkReadStream->unsetHandleMapping();
                 // WARNING PTR CHECK
@@ -386,9 +385,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pPhysicalDeviceCount,
                             (unsigned long long)pPhysicalDevices);
                 }
-                VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
-                vkEnumeratePhysicalDevices_VkResult_return = m_state->on_vkEnumeratePhysicalDevices(
-                    &m_pool, instance, pPhysicalDeviceCount, pPhysicalDevices);
+                VkResult vkEnumeratePhysicalDevices_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkEnumeratePhysicalDevices_VkResult_return =
+                        m_state->on_vkEnumeratePhysicalDevices(&m_pool, snapshotApiCallInfo,
+                                                               instance, pPhysicalDeviceCount,
+                                                               pPhysicalDevices);
+                }
                 if ((vkEnumeratePhysicalDevices_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkEnumeratePhysicalDevices_VkResult_return, opcode,
@@ -418,12 +421,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 vkStream->write(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkEnumeratePhysicalDevices(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkEnumeratePhysicalDevices_VkResult_return, instance, pPhysicalDeviceCount,
                         pPhysicalDevices);
                 }
@@ -443,6 +443,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pFeatures;
                 vkReadStream->unsetHandleMapping();
                 vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures));
@@ -458,7 +459,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)pFeatures);
                 }
-                m_state->on_vkGetPhysicalDeviceFeatures(&m_pool, physicalDevice, pFeatures);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceFeatures(&m_pool, snapshotApiCallInfo,
+                                                            physicalDevice, pFeatures);
+                }
                 vkStream->unsetHandleMapping();
                 if (pFeatures) {
                     transform_fromhost_VkPhysicalDeviceFeatures(
@@ -467,12 +471,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkPhysicalDeviceFeatures(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                  (VkPhysicalDeviceFeatures*)(pFeatures));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceFeatures(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice, pFeatures);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -491,6 +492,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                 *readStreamPtrPtr += sizeof(VkFormat);
                 // Begin manual dispatchable handle unboxing for pFormatProperties;
@@ -510,8 +512,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)format, (unsigned long long)pFormatProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceFormatProperties(&m_pool, physicalDevice, format,
-                                                                pFormatProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceFormatProperties(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, format, pFormatProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pFormatProperties) {
                     transform_fromhost_VkFormatProperties(m_state,
@@ -520,12 +524,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkFormatProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                            (VkFormatProperties*)(pFormatProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceFormatProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice, format,
                         pFormatProperties);
                 }
                 vkReadStream->clearPool();
@@ -549,6 +550,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                 *readStreamPtrPtr += sizeof(VkFormat);
                 memcpy((VkImageType*)&type, *readStreamPtrPtr, sizeof(VkImageType));
@@ -579,11 +581,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)tiling, (unsigned long long)usage,
                             (unsigned long long)flags, (unsigned long long)pImageFormatProperties);
                 }
-                VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
-                vkGetPhysicalDeviceImageFormatProperties_VkResult_return =
-                    m_state->on_vkGetPhysicalDeviceImageFormatProperties(
-                        &m_pool, physicalDevice, format, type, tiling, usage, flags,
-                        pImageFormatProperties);
+                VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPhysicalDeviceImageFormatProperties_VkResult_return =
+                        m_state->on_vkGetPhysicalDeviceImageFormatProperties(
+                            &m_pool, snapshotApiCallInfo, physicalDevice, format, type, tiling,
+                            usage, flags, pImageFormatProperties);
+                }
                 if ((vkGetPhysicalDeviceImageFormatProperties_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -599,12 +604,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPhysicalDeviceImageFormatProperties_VkResult_return, physicalDevice,
                         format, type, tiling, usage, flags, pImageFormatProperties);
                 }
@@ -624,6 +626,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pProperties;
                 vkReadStream->unsetHandleMapping();
                 vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties));
@@ -640,7 +643,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)pProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceProperties(&m_pool, physicalDevice, pProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceProperties(&m_pool, snapshotApiCallInfo,
+                                                              physicalDevice, pProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pProperties) {
                     transform_fromhost_VkPhysicalDeviceProperties(
@@ -649,12 +655,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkPhysicalDeviceProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                    (VkPhysicalDeviceProperties*)(pProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetPhysicalDeviceProperties(snapshotTraceBegin,
-                                                                       snapshotTraceBytes, &m_pool,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetPhysicalDeviceProperties(&m_pool, snapshotApiCallInfo,
+                                                                       packet, packetLen,
                                                                        physicalDevice, pProperties);
                 }
                 vkReadStream->clearPool();
@@ -674,6 +677,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                 vkReadStream->unsetHandleMapping();
                 // WARNING PTR CHECK
@@ -719,8 +723,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pQueueFamilyPropertyCount,
                             (unsigned long long)pQueueFamilyProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceQueueFamilyProperties(
-                    &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceQueueFamilyProperties(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, pQueueFamilyPropertyCount,
+                        pQueueFamilyProperties);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
@@ -749,12 +756,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pQueueFamilyPropertyCount, pQueueFamilyProperties);
                 }
                 vkReadStream->clearPool();
@@ -773,6 +777,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pMemoryProperties;
                 vkReadStream->unsetHandleMapping();
                 vkReadStream->alloc((void**)&pMemoryProperties,
@@ -790,8 +795,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)pMemoryProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceMemoryProperties(&m_pool, physicalDevice,
-                                                                pMemoryProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceMemoryProperties(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, pMemoryProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryProperties) {
                     transform_fromhost_VkPhysicalDeviceMemoryProperties(
@@ -801,12 +808,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                     (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pMemoryProperties);
                 }
                 vkReadStream->clearPool();
@@ -834,18 +838,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return =
                     (PFN_vkVoidFunction)0;
-                vkGetInstanceProcAddr_PFN_vkVoidFunction_return =
-                    vk->vkGetInstanceProcAddr(unboxed_instance, pName);
+                if (CC_LIKELY(vk)) {
+                    vkGetInstanceProcAddr_PFN_vkVoidFunction_return =
+                        vk->vkGetInstanceProcAddr(unboxed_instance, pName);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return,
                                 sizeof(PFN_vkVoidFunction));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetInstanceProcAddr(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetInstanceProcAddr_PFN_vkVoidFunction_return, instance, pName);
                 }
                 vkReadStream->clearPool();
@@ -873,18 +876,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return =
                     (PFN_vkVoidFunction)0;
-                vkGetDeviceProcAddr_PFN_vkVoidFunction_return =
-                    vk->vkGetDeviceProcAddr(unboxed_device, pName);
+                if (CC_LIKELY(vk)) {
+                    vkGetDeviceProcAddr_PFN_vkVoidFunction_return =
+                        vk->vkGetDeviceProcAddr(unboxed_device, pName);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return,
                                 sizeof(PFN_vkVoidFunction));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceProcAddr(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetDeviceProcAddr_PFN_vkVoidFunction_return, device, pName);
                 }
                 vkReadStream->clearPool();
@@ -904,6 +906,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDeviceCreateInfo));
                 reservedunmarshal_VkDeviceCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkDeviceCreateInfo*)(pCreateInfo),
@@ -939,9 +942,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pCreateInfo, (unsigned long long)pAllocator,
                             (unsigned long long)pDevice);
                 }
-                VkResult vkCreateDevice_VkResult_return = (VkResult)0;
-                vkCreateDevice_VkResult_return = m_state->on_vkCreateDevice(
-                    &m_pool, physicalDevice, pCreateInfo, pAllocator, pDevice);
+                VkResult vkCreateDevice_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateDevice_VkResult_return =
+                        m_state->on_vkCreateDevice(&m_pool, snapshotApiCallInfo, physicalDevice,
+                                                   pCreateInfo, pAllocator, pDevice);
+                }
                 if ((vkCreateDevice_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateDevice_VkResult_return, opcode, context);
@@ -953,12 +959,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((VkDevice*)pDevice, 8 * 1);
                 vkStream->write(&vkCreateDevice_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCreateDevice(snapshotTraceBegin, snapshotTraceBytes,
-                                                        &m_pool, vkCreateDevice_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCreateDevice(&m_pool, snapshotApiCallInfo, packet,
+                                                        packetLen, vkCreateDevice_VkResult_return,
                                                         physicalDevice, pCreateInfo, pAllocator,
                                                         pDevice);
                 }
@@ -977,6 +980,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // WARNING PTR CHECK
                 memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                 android::base::Stream::fromBe64((uint8_t*)&pAllocator);
@@ -995,14 +999,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkDestroyDevice 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)device, (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyDevice(&m_pool, device, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyDevice(&m_pool, snapshotApiCallInfo, device, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyDevice(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, device, pAllocator);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyDevice(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, device, pAllocator);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -1070,10 +1073,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)pLayerName,
                             (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                 }
-                VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
+                VkResult vkEnumerateInstanceExtensionProperties_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
                 vkEnumerateInstanceExtensionProperties_VkResult_return =
-                    vk->vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount,
-                                                               pProperties);
+                    m_state->on_vkEnumerateInstanceExtensionProperties(
+                        &m_pool, snapshotApiCallInfo, pLayerName, pPropertyCount, pProperties);
                 if ((vkEnumerateInstanceExtensionProperties_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -1109,12 +1113,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkEnumerateInstanceExtensionProperties_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkEnumerateInstanceExtensionProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkEnumerateInstanceExtensionProperties_VkResult_return, pLayerName,
                         pPropertyCount, pProperties);
                 }
@@ -1136,6 +1137,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 if (vkReadStream->getFeatureBits() &
                     VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT) {
                     // WARNING PTR CHECK
@@ -1192,10 +1194,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pLayerName, (unsigned long long)pPropertyCount,
                             (unsigned long long)pProperties);
                 }
-                VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
-                vkEnumerateDeviceExtensionProperties_VkResult_return =
-                    m_state->on_vkEnumerateDeviceExtensionProperties(
-                        &m_pool, physicalDevice, pLayerName, pPropertyCount, pProperties);
+                VkResult vkEnumerateDeviceExtensionProperties_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkEnumerateDeviceExtensionProperties_VkResult_return =
+                        m_state->on_vkEnumerateDeviceExtensionProperties(
+                            &m_pool, snapshotApiCallInfo, physicalDevice, pLayerName,
+                            pPropertyCount, pProperties);
+                }
                 if ((vkEnumerateDeviceExtensionProperties_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkEnumerateDeviceExtensionProperties_VkResult_return,
@@ -1230,12 +1236,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkEnumerateDeviceExtensionProperties_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkEnumerateDeviceExtensionProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkEnumerateDeviceExtensionProperties_VkResult_return, physicalDevice,
                         pLayerName, pPropertyCount, pProperties);
                 }
@@ -1289,9 +1292,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)pPropertyCount,
                             (unsigned long long)pProperties);
                 }
-                VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
+                VkResult vkEnumerateInstanceLayerProperties_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
                 vkEnumerateInstanceLayerProperties_VkResult_return =
-                    vk->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
+                    m_vk->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
                 if ((vkEnumerateInstanceLayerProperties_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkEnumerateInstanceLayerProperties_VkResult_return,
@@ -1325,12 +1329,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkEnumerateInstanceLayerProperties_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkEnumerateInstanceLayerProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkEnumerateInstanceLayerProperties_VkResult_return, pPropertyCount,
                         pProperties);
                 }
@@ -1395,10 +1396,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)physicalDevice,
                         (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                 }
-                VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
-                vkEnumerateDeviceLayerProperties_VkResult_return =
-                    vk->vkEnumerateDeviceLayerProperties(unboxed_physicalDevice, pPropertyCount,
-                                                         pProperties);
+                VkResult vkEnumerateDeviceLayerProperties_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkEnumerateDeviceLayerProperties_VkResult_return =
+                        vk->vkEnumerateDeviceLayerProperties(unboxed_physicalDevice, pPropertyCount,
+                                                             pProperties);
+                }
                 if ((vkEnumerateDeviceLayerProperties_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkEnumerateDeviceLayerProperties_VkResult_return,
@@ -1432,12 +1436,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkEnumerateDeviceLayerProperties_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkEnumerateDeviceLayerProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkEnumerateDeviceLayerProperties_VkResult_return, physicalDevice,
                         pPropertyCount, pProperties);
                 }
@@ -1458,6 +1459,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&queueIndex, *readStreamPtrPtr, sizeof(uint32_t));
@@ -1475,7 +1477,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)queueFamilyIndex,
                         (unsigned long long)queueIndex, (unsigned long long)pQueue);
                 }
-                m_state->on_vkGetDeviceQueue(&m_pool, device, queueFamilyIndex, queueIndex, pQueue);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetDeviceQueue(&m_pool, snapshotApiCallInfo, device,
+                                                 queueFamilyIndex, queueIndex, pQueue);
+                }
                 vkStream->unsetHandleMapping();
                 uint64_t cgen_var_2;
                 static_assert(8 == sizeof(VkQueue),
@@ -1483,12 +1488,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->handleMapping()->mapHandles_VkQueue((VkQueue*)pQueue, 1);
                 vkStream->write((VkQueue*)pQueue, 8 * 1);
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetDeviceQueue(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, device, queueFamilyIndex,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetDeviceQueue(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, device, queueFamilyIndex,
                                                           queueIndex, pQueue);
                 }
                 vkReadStream->clearPool();
@@ -1507,6 +1509,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&submitCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pSubmits,
@@ -1529,21 +1532,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)queue, (unsigned long long)submitCount,
                             (unsigned long long)pSubmits, (unsigned long long)fence);
                 }
-                VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
-                vkQueueSubmit_VkResult_return =
-                    m_state->on_vkQueueSubmit(&m_pool, queue, submitCount, pSubmits, fence);
+                VkResult vkQueueSubmit_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkQueueSubmit_VkResult_return = m_state->on_vkQueueSubmit(
+                        &m_pool, snapshotApiCallInfo, queue, submitCount, pSubmits, fence);
+                }
                 if ((vkQueueSubmit_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkQueueSubmit_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkQueueSubmit(snapshotTraceBegin, snapshotTraceBytes,
-                                                       &m_pool, vkQueueSubmit_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkQueueSubmit(&m_pool, snapshotApiCallInfo, packet,
+                                                       packetLen, vkQueueSubmit_VkResult_return,
                                                        queue, submitCount, pSubmits, fence);
                 }
                 vkReadStream->clearPool();
@@ -1560,26 +1562,27 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 if (m_logCalls) {
                     fprintf(stderr, "stream %p: call vkQueueWaitIdle 0x%llx \n", ioStream,
                             (unsigned long long)queue);
                 }
                 if (m_queueSubmitWithCommandsEnabled)
                     seqnoPtr->fetch_add(1, std::memory_order_seq_cst);
-                VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
-                vkQueueWaitIdle_VkResult_return = m_state->on_vkQueueWaitIdle(&m_pool, queue);
+                VkResult vkQueueWaitIdle_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkQueueWaitIdle_VkResult_return =
+                        m_state->on_vkQueueWaitIdle(&m_pool, snapshotApiCallInfo, queue);
+                }
                 if ((vkQueueWaitIdle_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkQueueWaitIdle_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkQueueWaitIdle(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, vkQueueWaitIdle_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkQueueWaitIdle(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, vkQueueWaitIdle_VkResult_return,
                                                          queue);
                 }
                 vkReadStream->clearPool();
@@ -1603,21 +1606,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 if (m_queueSubmitWithCommandsEnabled)
                     seqnoPtr->fetch_add(1, std::memory_order_seq_cst);
-                VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
-                vkDeviceWaitIdle_VkResult_return = vk->vkDeviceWaitIdle(unboxed_device);
+                VkResult vkDeviceWaitIdle_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkDeviceWaitIdle_VkResult_return = vk->vkDeviceWaitIdle(unboxed_device);
+                }
                 if ((vkDeviceWaitIdle_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkDeviceWaitIdle_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDeviceWaitIdle(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, vkDeviceWaitIdle_VkResult_return,
-                                                          device);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDeviceWaitIdle(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen,
+                                                          vkDeviceWaitIdle_VkResult_return, device);
                 }
                 vkReadStream->clearPool();
                 break;
@@ -1634,6 +1636,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkMemoryAllocateInfo));
                 reservedunmarshal_VkMemoryAllocateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                        (VkMemoryAllocateInfo*)(pAllocateInfo),
@@ -1670,9 +1673,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pMemory);
                 }
-                VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
-                vkAllocateMemory_VkResult_return = m_state->on_vkAllocateMemory(
-                    &m_pool, device, pAllocateInfo, pAllocator, pMemory);
+                VkResult vkAllocateMemory_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkAllocateMemory_VkResult_return = m_state->on_vkAllocateMemory(
+                        &m_pool, snapshotApiCallInfo, device, pAllocateInfo, pAllocator, pMemory);
+                }
                 if ((vkAllocateMemory_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(
@@ -1690,14 +1695,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkAllocateMemory(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, vkAllocateMemory_VkResult_return,
-                                                          device, pAllocateInfo, pAllocator,
-                                                          pMemory);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkAllocateMemory(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen,
+                                                          vkAllocateMemory_VkResult_return, device,
+                                                          pAllocateInfo, pAllocator, pMemory);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -1714,6 +1716,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for memory;
                 VkDeviceMemory boxed_memory_preserve;
                 uint64_t cgen_var_1;
@@ -1742,14 +1745,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)memory,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkFreeMemory(&m_pool, device, memory, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkFreeMemory(&m_pool, snapshotApiCallInfo, device, memory,
+                                             pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkFreeMemory(snapshotTraceBegin, snapshotTraceBytes,
-                                                      &m_pool, device, boxed_memory_preserve,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkFreeMemory(&m_pool, snapshotApiCallInfo, packet,
+                                                      packetLen, device, boxed_memory_preserve,
                                                       pAllocator);
                 }
                 delete_VkDeviceMemory(boxed_memory_preserve);
@@ -1771,6 +1774,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -1801,9 +1805,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)offset, (unsigned long long)size,
                         (unsigned long long)flags, (unsigned long long)ppData);
                 }
-                VkResult vkMapMemory_VkResult_return = (VkResult)0;
-                vkMapMemory_VkResult_return =
-                    m_state->on_vkMapMemory(&m_pool, device, memory, offset, size, flags, ppData);
+                VkResult vkMapMemory_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkMapMemory_VkResult_return = m_state->on_vkMapMemory(
+                        &m_pool, snapshotApiCallInfo, device, memory, offset, size, flags, ppData);
+                }
                 if ((vkMapMemory_VkResult_return) == VK_ERROR_DEVICE_LOST) m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkMapMemory_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
@@ -1815,12 +1821,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 vkStream->write(&vkMapMemory_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkMapMemory(snapshotTraceBegin, snapshotTraceBytes,
-                                                     &m_pool, vkMapMemory_VkResult_return, device,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkMapMemory(&m_pool, snapshotApiCallInfo, packet,
+                                                     packetLen, vkMapMemory_VkResult_return, device,
                                                      memory, offset, size, flags, ppData);
                 }
                 vkReadStream->clearPool();
@@ -1837,6 +1840,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -1846,14 +1850,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkUnmapMemory 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)device, (unsigned long long)memory);
                 }
-                m_state->on_vkUnmapMemory(&m_pool, device, memory);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkUnmapMemory(&m_pool, snapshotApiCallInfo, device, memory);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkUnmapMemory(snapshotTraceBegin, snapshotTraceBytes,
-                                                       &m_pool, device, memory);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkUnmapMemory(&m_pool, snapshotApiCallInfo, packet,
+                                                       packetLen, device, memory);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -1934,9 +1937,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         packetLen += 8 + readStream;
                     }
                 }
-                VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
-                vkFlushMappedMemoryRanges_VkResult_return =
-                    vk->vkFlushMappedMemoryRanges(unboxed_device, memoryRangeCount, pMemoryRanges);
+                VkResult vkFlushMappedMemoryRanges_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkFlushMappedMemoryRanges_VkResult_return = vk->vkFlushMappedMemoryRanges(
+                        unboxed_device, memoryRangeCount, pMemoryRanges);
+                }
                 if ((vkFlushMappedMemoryRanges_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkFlushMappedMemoryRanges_VkResult_return, opcode,
@@ -1944,12 +1949,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkFlushMappedMemoryRanges(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkFlushMappedMemoryRanges_VkResult_return, device, memoryRangeCount,
                         pMemoryRanges);
                 }
@@ -1994,9 +1996,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)memoryRangeCount,
                         (unsigned long long)pMemoryRanges);
                 }
-                VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
-                vkInvalidateMappedMemoryRanges_VkResult_return = vk->vkInvalidateMappedMemoryRanges(
-                    unboxed_device, memoryRangeCount, pMemoryRanges);
+                VkResult vkInvalidateMappedMemoryRanges_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkInvalidateMappedMemoryRanges_VkResult_return =
+                        vk->vkInvalidateMappedMemoryRanges(unboxed_device, memoryRangeCount,
+                                                           pMemoryRanges);
+                }
                 if ((vkInvalidateMappedMemoryRanges_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkInvalidateMappedMemoryRanges_VkResult_return, opcode,
@@ -2024,12 +2030,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkInvalidateMappedMemoryRanges(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkInvalidateMappedMemoryRanges_VkResult_return, device, memoryRangeCount,
                         pMemoryRanges);
                 }
@@ -2069,16 +2072,16 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)memory,
                             (unsigned long long)pCommittedMemoryInBytes);
                 }
-                vk->vkGetDeviceMemoryCommitment(unboxed_device, memory, pCommittedMemoryInBytes);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDeviceMemoryCommitment(unboxed_device, memory,
+                                                    pCommittedMemoryInBytes);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceMemoryCommitment(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, memory,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, memory,
                         pCommittedMemoryInBytes);
                 }
                 vkReadStream->clearPool();
@@ -2098,6 +2101,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -2115,21 +2119,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)buffer,
                             (unsigned long long)memory, (unsigned long long)memoryOffset);
                 }
-                VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
-                vkBindBufferMemory_VkResult_return =
-                    m_state->on_vkBindBufferMemory(&m_pool, device, buffer, memory, memoryOffset);
+                VkResult vkBindBufferMemory_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkBindBufferMemory_VkResult_return = m_state->on_vkBindBufferMemory(
+                        &m_pool, snapshotApiCallInfo, device, buffer, memory, memoryOffset);
+                }
                 if ((vkBindBufferMemory_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkBindBufferMemory_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkBindBufferMemory(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkBindBufferMemory_VkResult_return, device, buffer, memory, memoryOffset);
                 }
                 vkReadStream->clearPool();
@@ -2149,6 +2152,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -2166,21 +2170,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)image,
                             (unsigned long long)memory, (unsigned long long)memoryOffset);
                 }
-                VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
-                vkBindImageMemory_VkResult_return =
-                    m_state->on_vkBindImageMemory(&m_pool, device, image, memory, memoryOffset);
+                VkResult vkBindImageMemory_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkBindImageMemory_VkResult_return = m_state->on_vkBindImageMemory(
+                        &m_pool, snapshotApiCallInfo, device, image, memory, memoryOffset);
+                }
                 if ((vkBindImageMemory_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkBindImageMemory_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkBindImageMemory(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkBindImageMemory_VkResult_return, device, image, memory, memoryOffset);
                 }
                 vkReadStream->clearPool();
@@ -2199,6 +2202,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -2219,8 +2223,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)buffer,
                             (unsigned long long)pMemoryRequirements);
                 }
-                m_state->on_vkGetBufferMemoryRequirements(&m_pool, device, buffer,
-                                                          pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetBufferMemoryRequirements(&m_pool, snapshotApiCallInfo, device,
+                                                              buffer, pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements(
@@ -2229,13 +2235,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                              (VkMemoryRequirements*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetBufferMemoryRequirements(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, buffer,
-                        pMemoryRequirements);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetBufferMemoryRequirements(&m_pool, snapshotApiCallInfo,
+                                                                       packet, packetLen, device,
+                                                                       buffer, pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -2253,6 +2256,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -2273,8 +2277,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)image,
                             (unsigned long long)pMemoryRequirements);
                 }
-                m_state->on_vkGetImageMemoryRequirements(&m_pool, device, image,
-                                                         pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetImageMemoryRequirements(&m_pool, snapshotApiCallInfo, device,
+                                                             image, pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements(
@@ -2283,13 +2289,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                              (VkMemoryRequirements*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetImageMemoryRequirements(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image,
-                        pMemoryRequirements);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetImageMemoryRequirements(&m_pool, snapshotApiCallInfo,
+                                                                      packet, packetLen, device,
+                                                                      image, pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -2363,9 +2366,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pSparseMemoryRequirementCount,
                             (unsigned long long)pSparseMemoryRequirements);
                 }
-                vk->vkGetImageSparseMemoryRequirements(unboxed_device, image,
-                                                       pSparseMemoryRequirementCount,
-                                                       pSparseMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetImageSparseMemoryRequirements(unboxed_device, image,
+                                                           pSparseMemoryRequirementCount,
+                                                           pSparseMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
@@ -2397,12 +2402,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetImageSparseMemoryRequirements(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, image,
                         pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -2486,9 +2488,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)tiling, (unsigned long long)pPropertyCount,
                             (unsigned long long)pProperties);
                 }
-                vk->vkGetPhysicalDeviceSparseImageFormatProperties(unboxed_physicalDevice, format,
-                                                                   type, samples, usage, tiling,
-                                                                   pPropertyCount, pProperties);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPhysicalDeviceSparseImageFormatProperties(
+                        unboxed_physicalDevice, format, type, samples, usage, tiling,
+                        pPropertyCount, pProperties);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
@@ -2517,12 +2521,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice, format,
                         type, samples, usage, tiling, pPropertyCount, pProperties);
                 }
                 vkReadStream->clearPool();
@@ -2542,6 +2543,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pBindInfo,
@@ -2567,21 +2569,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)queue, (unsigned long long)bindInfoCount,
                             (unsigned long long)pBindInfo, (unsigned long long)fence);
                 }
-                VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
-                vkQueueBindSparse_VkResult_return =
-                    m_state->on_vkQueueBindSparse(&m_pool, queue, bindInfoCount, pBindInfo, fence);
+                VkResult vkQueueBindSparse_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkQueueBindSparse_VkResult_return = m_state->on_vkQueueBindSparse(
+                        &m_pool, snapshotApiCallInfo, queue, bindInfoCount, pBindInfo, fence);
+                }
                 if ((vkQueueBindSparse_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkQueueBindSparse_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueueBindSparse(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkQueueBindSparse_VkResult_return, queue, bindInfoCount, pBindInfo, fence);
                 }
                 vkReadStream->clearPool();
@@ -2600,6 +2601,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFenceCreateInfo));
                 reservedunmarshal_VkFenceCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkFenceCreateInfo*)(pCreateInfo),
@@ -2633,9 +2635,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pFence);
                 }
-                VkResult vkCreateFence_VkResult_return = (VkResult)0;
-                vkCreateFence_VkResult_return =
-                    m_state->on_vkCreateFence(&m_pool, device, pCreateInfo, pAllocator, pFence);
+                VkResult vkCreateFence_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateFence_VkResult_return = m_state->on_vkCreateFence(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pFence);
+                }
                 if ((vkCreateFence_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateFence_VkResult_return, opcode, context);
@@ -2651,12 +2655,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateFence_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCreateFence(snapshotTraceBegin, snapshotTraceBytes,
-                                                       &m_pool, vkCreateFence_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCreateFence(&m_pool, snapshotApiCallInfo, packet,
+                                                       packetLen, vkCreateFence_VkResult_return,
                                                        device, pCreateInfo, pAllocator, pFence);
                 }
                 vkReadStream->clearPool();
@@ -2674,6 +2675,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for fence;
                 VkFence boxed_fence_preserve;
                 uint64_t cgen_var_1;
@@ -2701,14 +2703,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)fence,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyFence(&m_pool, device, fence, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyFence(&m_pool, snapshotApiCallInfo, device, fence,
+                                               pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyFence(snapshotTraceBegin, snapshotTraceBytes,
-                                                        &m_pool, device, boxed_fence_preserve,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyFence(&m_pool, snapshotApiCallInfo, packet,
+                                                        packetLen, device, boxed_fence_preserve,
                                                         pAllocator);
                 }
                 delete_VkFence(boxed_fence_preserve);
@@ -2727,6 +2729,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((uint32_t*)&fenceCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
@@ -2745,21 +2748,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)fenceCount,
                             (unsigned long long)pFences);
                 }
-                VkResult vkResetFences_VkResult_return = (VkResult)0;
-                vkResetFences_VkResult_return =
-                    m_state->on_vkResetFences(&m_pool, device, fenceCount, pFences);
+                VkResult vkResetFences_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkResetFences_VkResult_return = m_state->on_vkResetFences(
+                        &m_pool, snapshotApiCallInfo, device, fenceCount, pFences);
+                }
                 if ((vkResetFences_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkResetFences_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkResetFences_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkResetFences(snapshotTraceBegin, snapshotTraceBytes,
-                                                       &m_pool, vkResetFences_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkResetFences(&m_pool, snapshotApiCallInfo, packet,
+                                                       packetLen, vkResetFences_VkResult_return,
                                                        device, fenceCount, pFences);
                 }
                 vkReadStream->clearPool();
@@ -2772,14 +2774,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                                       "VkDecoder vkGetFenceStatus");
                 VkDevice device;
                 VkFence fence;
-                // Begin non wrapped dispatchable handle unboxing for device;
+                // Begin global wrapped dispatchable handle unboxing for device;
                 uint64_t cgen_var_0;
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
-                auto unboxed_device = unbox_VkDevice(device);
                 auto vk = dispatch_VkDevice(device);
-                // End manual dispatchable handle unboxing for device;
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -2788,21 +2788,21 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkGetFenceStatus 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)device, (unsigned long long)fence);
                 }
-                VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
-                vkGetFenceStatus_VkResult_return = vk->vkGetFenceStatus(unboxed_device, fence);
+                VkResult vkGetFenceStatus_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetFenceStatus_VkResult_return =
+                        m_state->on_vkGetFenceStatus(&m_pool, snapshotApiCallInfo, device, fence);
+                }
                 if ((vkGetFenceStatus_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetFenceStatus_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetFenceStatus(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, vkGetFenceStatus_VkResult_return,
-                                                          device, fence);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetFenceStatus(
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
+                        vkGetFenceStatus_VkResult_return, device, fence);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -2817,14 +2817,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 const VkFence* pFences;
                 VkBool32 waitAll;
                 uint64_t timeout;
-                // Begin non wrapped dispatchable handle unboxing for device;
+                // Begin global wrapped dispatchable handle unboxing for device;
                 uint64_t cgen_var_0;
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
-                auto unboxed_device = unbox_VkDevice(device);
                 auto vk = dispatch_VkDevice(device);
-                // End manual dispatchable handle unboxing for device;
                 memcpy((uint32_t*)&fenceCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
@@ -2851,21 +2849,21 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 if (m_queueSubmitWithCommandsEnabled)
                     seqnoPtr->fetch_add(1, std::memory_order_seq_cst);
-                VkResult vkWaitForFences_VkResult_return = (VkResult)0;
-                vkWaitForFences_VkResult_return =
-                    vk->vkWaitForFences(unboxed_device, fenceCount, pFences, waitAll, timeout);
+                VkResult vkWaitForFences_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkWaitForFences_VkResult_return =
+                        m_state->on_vkWaitForFences(&m_pool, snapshotApiCallInfo, device,
+                                                    fenceCount, pFences, waitAll, timeout);
+                }
                 if ((vkWaitForFences_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkWaitForFences_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkWaitForFences_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkWaitForFences(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, vkWaitForFences_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkWaitForFences(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, vkWaitForFences_VkResult_return,
                                                          device, fenceCount, pFences, waitAll,
                                                          timeout);
                 }
@@ -2884,6 +2882,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSemaphoreCreateInfo));
                 reservedunmarshal_VkSemaphoreCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                         (VkSemaphoreCreateInfo*)(pCreateInfo),
@@ -2919,9 +2918,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pSemaphore);
                 }
-                VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
-                vkCreateSemaphore_VkResult_return = m_state->on_vkCreateSemaphore(
-                    &m_pool, device, pCreateInfo, pAllocator, pSemaphore);
+                VkResult vkCreateSemaphore_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateSemaphore_VkResult_return = m_state->on_vkCreateSemaphore(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pSemaphore);
+                }
                 if ((vkCreateSemaphore_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateSemaphore_VkResult_return, opcode, context);
@@ -2937,12 +2938,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateSemaphore(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateSemaphore_VkResult_return, device, pCreateInfo, pAllocator,
                         pSemaphore);
                 }
@@ -2962,6 +2960,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for semaphore;
                 VkSemaphore boxed_semaphore_preserve;
                 uint64_t cgen_var_1;
@@ -2989,14 +2988,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)semaphore,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroySemaphore(&m_pool, device, semaphore, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroySemaphore(&m_pool, snapshotApiCallInfo, device, semaphore,
+                                                   pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroySemaphore(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, device,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroySemaphore(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, device,
                                                             boxed_semaphore_preserve, pAllocator);
                 }
                 delete_VkSemaphore(boxed_semaphore_preserve);
@@ -3052,9 +3051,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pEvent);
                 }
-                VkResult vkCreateEvent_VkResult_return = (VkResult)0;
-                vkCreateEvent_VkResult_return =
-                    vk->vkCreateEvent(unboxed_device, pCreateInfo, pAllocator, pEvent);
+                VkResult vkCreateEvent_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateEvent_VkResult_return =
+                        vk->vkCreateEvent(unboxed_device, pCreateInfo, pAllocator, pEvent);
+                }
                 if ((vkCreateEvent_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateEvent_VkResult_return, opcode, context);
@@ -3071,12 +3072,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateEvent_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCreateEvent(snapshotTraceBegin, snapshotTraceBytes,
-                                                       &m_pool, vkCreateEvent_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCreateEvent(&m_pool, snapshotApiCallInfo, packet,
+                                                       packetLen, vkCreateEvent_VkResult_return,
                                                        device, pCreateInfo, pAllocator, pEvent);
                 }
                 vkReadStream->clearPool();
@@ -3124,14 +3122,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)event,
                             (unsigned long long)pAllocator);
                 }
-                vk->vkDestroyEvent(unboxed_device, event, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    vk->vkDestroyEvent(unboxed_device, event, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyEvent(snapshotTraceBegin, snapshotTraceBytes,
-                                                        &m_pool, device, boxed_event_preserve,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyEvent(&m_pool, snapshotApiCallInfo, packet,
+                                                        packetLen, device, boxed_event_preserve,
                                                         pAllocator);
                 }
                 delete_VkEvent(boxed_event_preserve);
@@ -3161,21 +3158,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkGetEventStatus 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)device, (unsigned long long)event);
                 }
-                VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
-                vkGetEventStatus_VkResult_return = vk->vkGetEventStatus(unboxed_device, event);
+                VkResult vkGetEventStatus_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetEventStatus_VkResult_return = vk->vkGetEventStatus(unboxed_device, event);
+                }
                 if ((vkGetEventStatus_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetEventStatus_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetEventStatus(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, vkGetEventStatus_VkResult_return,
-                                                          device, event);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetEventStatus(
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
+                        vkGetEventStatus_VkResult_return, device, event);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -3202,18 +3198,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkSetEvent 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)device, (unsigned long long)event);
                 }
-                VkResult vkSetEvent_VkResult_return = (VkResult)0;
-                vkSetEvent_VkResult_return = vk->vkSetEvent(unboxed_device, event);
+                VkResult vkSetEvent_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkSetEvent_VkResult_return = vk->vkSetEvent(unboxed_device, event);
+                }
                 if ((vkSetEvent_VkResult_return) == VK_ERROR_DEVICE_LOST) m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkSetEvent_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkSetEvent_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkSetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkSetEvent(&m_pool, snapshotApiCallInfo, packet, packetLen,
                                                     vkSetEvent_VkResult_return, device, event);
                 }
                 vkReadStream->clearPool();
@@ -3241,21 +3236,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkResetEvent 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)device, (unsigned long long)event);
                 }
-                VkResult vkResetEvent_VkResult_return = (VkResult)0;
-                vkResetEvent_VkResult_return = vk->vkResetEvent(unboxed_device, event);
+                VkResult vkResetEvent_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkResetEvent_VkResult_return = vk->vkResetEvent(unboxed_device, event);
+                }
                 if ((vkResetEvent_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkResetEvent_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkResetEvent_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkResetEvent(snapshotTraceBegin, snapshotTraceBytes,
-                                                      &m_pool, vkResetEvent_VkResult_return, device,
-                                                      event);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkResetEvent(&m_pool, snapshotApiCallInfo, packet,
+                                                      packetLen, vkResetEvent_VkResult_return,
+                                                      device, event);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -3312,9 +3306,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pQueryPool);
                 }
-                VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
-                vkCreateQueryPool_VkResult_return =
-                    vk->vkCreateQueryPool(unboxed_device, pCreateInfo, pAllocator, pQueryPool);
+                VkResult vkCreateQueryPool_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateQueryPool_VkResult_return =
+                        vk->vkCreateQueryPool(unboxed_device, pCreateInfo, pAllocator, pQueryPool);
+                }
                 if ((vkCreateQueryPool_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateQueryPool_VkResult_return, opcode, context);
@@ -3331,12 +3327,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateQueryPool(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateQueryPool_VkResult_return, device, pCreateInfo, pAllocator,
                         pQueryPool);
                 }
@@ -3386,14 +3379,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)queryPool,
                             (unsigned long long)pAllocator);
                 }
-                vk->vkDestroyQueryPool(unboxed_device, queryPool, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    vk->vkDestroyQueryPool(unboxed_device, queryPool, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyQueryPool(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, device,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyQueryPool(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, device,
                                                             boxed_queryPool_preserve, pAllocator);
                 }
                 delete_VkQueryPool(boxed_queryPool_preserve);
@@ -3451,10 +3443,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dataSize, (unsigned long long)pData,
                             (unsigned long long)stride, (unsigned long long)flags);
                 }
-                VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
-                vkGetQueryPoolResults_VkResult_return =
-                    vk->vkGetQueryPoolResults(unboxed_device, queryPool, firstQuery, queryCount,
-                                              dataSize, pData, stride, flags);
+                VkResult vkGetQueryPoolResults_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetQueryPoolResults_VkResult_return =
+                        vk->vkGetQueryPoolResults(unboxed_device, queryPool, firstQuery, queryCount,
+                                                  dataSize, pData, stride, flags);
+                }
                 if ((vkGetQueryPoolResults_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetQueryPoolResults_VkResult_return, opcode,
@@ -3463,12 +3457,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                 vkStream->write(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetQueryPoolResults(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetQueryPoolResults_VkResult_return, device, queryPool, firstQuery,
                         queryCount, dataSize, pData, stride, flags);
                 }
@@ -3488,6 +3479,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                 reservedunmarshal_VkBufferCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkBufferCreateInfo*)(pCreateInfo),
@@ -3522,9 +3514,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pBuffer);
                 }
-                VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
-                vkCreateBuffer_VkResult_return =
-                    m_state->on_vkCreateBuffer(&m_pool, device, pCreateInfo, pAllocator, pBuffer);
+                VkResult vkCreateBuffer_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateBuffer_VkResult_return = m_state->on_vkCreateBuffer(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pBuffer);
+                }
                 if ((vkCreateBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateBuffer_VkResult_return, opcode, context);
@@ -3540,12 +3534,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCreateBuffer(snapshotTraceBegin, snapshotTraceBytes,
-                                                        &m_pool, vkCreateBuffer_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCreateBuffer(&m_pool, snapshotApiCallInfo, packet,
+                                                        packetLen, vkCreateBuffer_VkResult_return,
                                                         device, pCreateInfo, pAllocator, pBuffer);
                 }
                 vkReadStream->clearPool();
@@ -3564,6 +3555,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for buffer;
                 VkBuffer boxed_buffer_preserve;
                 uint64_t cgen_var_1;
@@ -3591,14 +3583,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)buffer,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyBuffer(&m_pool, device, buffer, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyBuffer(&m_pool, snapshotApiCallInfo, device, buffer,
+                                                pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyBuffer(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, device, boxed_buffer_preserve,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyBuffer(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, device, boxed_buffer_preserve,
                                                          pAllocator);
                 }
                 delete_VkBuffer(boxed_buffer_preserve);
@@ -3657,9 +3649,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pView);
                 }
-                VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
-                vkCreateBufferView_VkResult_return =
-                    vk->vkCreateBufferView(unboxed_device, pCreateInfo, pAllocator, pView);
+                VkResult vkCreateBufferView_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateBufferView_VkResult_return =
+                        vk->vkCreateBufferView(unboxed_device, pCreateInfo, pAllocator, pView);
+                }
                 if ((vkCreateBufferView_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateBufferView_VkResult_return, opcode, context);
@@ -3676,12 +3670,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateBufferView(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateBufferView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                 }
                 vkReadStream->clearPool();
@@ -3731,14 +3722,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)bufferView,
                             (unsigned long long)pAllocator);
                 }
-                vk->vkDestroyBufferView(unboxed_device, bufferView, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    vk->vkDestroyBufferView(unboxed_device, bufferView, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyBufferView(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, device,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyBufferView(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, device,
                                                              boxed_bufferView_preserve, pAllocator);
                 }
                 delete_VkBufferView(boxed_bufferView_preserve);
@@ -3758,6 +3748,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                 reservedunmarshal_VkImageCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkImageCreateInfo*)(pCreateInfo),
@@ -3792,9 +3783,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pImage);
                 }
-                VkResult vkCreateImage_VkResult_return = (VkResult)0;
-                vkCreateImage_VkResult_return =
-                    m_state->on_vkCreateImage(&m_pool, device, pCreateInfo, pAllocator, pImage);
+                VkResult vkCreateImage_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateImage_VkResult_return = m_state->on_vkCreateImage(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pImage);
+                }
                 if ((vkCreateImage_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateImage_VkResult_return, opcode, context);
@@ -3810,12 +3803,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateImage_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCreateImage(snapshotTraceBegin, snapshotTraceBytes,
-                                                       &m_pool, vkCreateImage_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCreateImage(&m_pool, snapshotApiCallInfo, packet,
+                                                       packetLen, vkCreateImage_VkResult_return,
                                                        device, pCreateInfo, pAllocator, pImage);
                 }
                 vkReadStream->clearPool();
@@ -3833,6 +3823,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for image;
                 VkImage boxed_image_preserve;
                 uint64_t cgen_var_1;
@@ -3860,14 +3851,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)image,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyImage(&m_pool, device, image, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyImage(&m_pool, snapshotApiCallInfo, device, image,
+                                               pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyImage(snapshotTraceBegin, snapshotTraceBytes,
-                                                        &m_pool, device, boxed_image_preserve,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyImage(&m_pool, snapshotApiCallInfo, packet,
+                                                        packetLen, device, boxed_image_preserve,
                                                         pAllocator);
                 }
                 delete_VkImage(boxed_image_preserve);
@@ -3919,7 +3910,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)image,
                             (unsigned long long)pSubresource, (unsigned long long)pLayout);
                 }
-                vk->vkGetImageSubresourceLayout(unboxed_device, image, pSubresource, pLayout);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetImageSubresourceLayout(unboxed_device, image, pSubresource, pLayout);
+                }
                 vkStream->unsetHandleMapping();
                 if (pLayout) {
                     transform_fromhost_VkSubresourceLayout(m_state,
@@ -3928,13 +3921,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkSubresourceLayout(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                             (VkSubresourceLayout*)(pLayout));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetImageSubresourceLayout(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image,
-                        pSubresource, pLayout);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetImageSubresourceLayout(&m_pool, snapshotApiCallInfo,
+                                                                     packet, packetLen, device,
+                                                                     image, pSubresource, pLayout);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -3953,6 +3943,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageViewCreateInfo));
                 reservedunmarshal_VkImageViewCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                         (VkImageViewCreateInfo*)(pCreateInfo),
@@ -3988,9 +3979,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pView);
                 }
-                VkResult vkCreateImageView_VkResult_return = (VkResult)0;
-                vkCreateImageView_VkResult_return =
-                    m_state->on_vkCreateImageView(&m_pool, device, pCreateInfo, pAllocator, pView);
+                VkResult vkCreateImageView_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateImageView_VkResult_return = m_state->on_vkCreateImageView(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pView);
+                }
                 if ((vkCreateImageView_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateImageView_VkResult_return, opcode, context);
@@ -4006,12 +3999,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateImageView_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateImageView(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateImageView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                 }
                 vkReadStream->clearPool();
@@ -4030,6 +4020,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for imageView;
                 VkImageView boxed_imageView_preserve;
                 uint64_t cgen_var_1;
@@ -4057,14 +4048,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)imageView,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyImageView(&m_pool, device, imageView, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyImageView(&m_pool, snapshotApiCallInfo, device, imageView,
+                                                   pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyImageView(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, device,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyImageView(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, device,
                                                             boxed_imageView_preserve, pAllocator);
                 }
                 delete_VkImageView(boxed_imageView_preserve);
@@ -4085,6 +4076,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkShaderModuleCreateInfo));
                 reservedunmarshal_VkShaderModuleCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                            (VkShaderModuleCreateInfo*)(pCreateInfo),
@@ -4121,9 +4113,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pShaderModule);
                 }
-                VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
-                vkCreateShaderModule_VkResult_return = m_state->on_vkCreateShaderModule(
-                    &m_pool, device, pCreateInfo, pAllocator, pShaderModule);
+                VkResult vkCreateShaderModule_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateShaderModule_VkResult_return =
+                        m_state->on_vkCreateShaderModule(&m_pool, snapshotApiCallInfo, device,
+                                                         pCreateInfo, pAllocator, pShaderModule);
+                }
                 if ((vkCreateShaderModule_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateShaderModule_VkResult_return, opcode, context);
@@ -4140,12 +4135,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateShaderModule(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateShaderModule_VkResult_return, device, pCreateInfo, pAllocator,
                         pShaderModule);
                 }
@@ -4196,14 +4188,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)shaderModule,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyShaderModule(&m_pool, device, shaderModule, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyShaderModule(&m_pool, snapshotApiCallInfo, device,
+                                                      shaderModule, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyShaderModule(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_shaderModule_preserve, pAllocator);
                 }
                 delayed_delete_VkShaderModule(boxed_shaderModule_preserve, unboxed_device, nullptr);
@@ -4224,6 +4216,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineCacheCreateInfo));
                 reservedunmarshal_VkPipelineCacheCreateInfo(
                     vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
@@ -4260,9 +4253,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pPipelineCache);
                 }
-                VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
-                vkCreatePipelineCache_VkResult_return = m_state->on_vkCreatePipelineCache(
-                    &m_pool, device, pCreateInfo, pAllocator, pPipelineCache);
+                VkResult vkCreatePipelineCache_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreatePipelineCache_VkResult_return =
+                        m_state->on_vkCreatePipelineCache(&m_pool, snapshotApiCallInfo, device,
+                                                          pCreateInfo, pAllocator, pPipelineCache);
+                }
                 if ((vkCreatePipelineCache_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreatePipelineCache_VkResult_return, opcode,
@@ -4280,12 +4276,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreatePipelineCache(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreatePipelineCache_VkResult_return, device, pCreateInfo, pAllocator,
                         pPipelineCache);
                 }
@@ -4305,6 +4298,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for pipelineCache;
                 VkPipelineCache boxed_pipelineCache_preserve;
                 uint64_t cgen_var_1;
@@ -4334,14 +4328,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pipelineCache,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyPipelineCache(&m_pool, device, pipelineCache, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyPipelineCache(&m_pool, snapshotApiCallInfo, device,
+                                                       pipelineCache, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyPipelineCache(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_pipelineCache_preserve, pAllocator);
                 }
                 delete_VkPipelineCache(boxed_pipelineCache_preserve);
@@ -4399,9 +4393,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pipelineCache,
                             (unsigned long long)pDataSize, (unsigned long long)pData);
                 }
-                VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
-                vkGetPipelineCacheData_VkResult_return =
-                    vk->vkGetPipelineCacheData(unboxed_device, pipelineCache, pDataSize, pData);
+                VkResult vkGetPipelineCacheData_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPipelineCacheData_VkResult_return =
+                        vk->vkGetPipelineCacheData(unboxed_device, pipelineCache, pDataSize, pData);
+                }
                 if ((vkGetPipelineCacheData_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetPipelineCacheData_VkResult_return, opcode,
@@ -4422,12 +4418,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 vkStream->write(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPipelineCacheData(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPipelineCacheData_VkResult_return, device, pipelineCache, pDataSize,
                         pData);
                 }
@@ -4477,9 +4470,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)dstCache,
                             (unsigned long long)srcCacheCount, (unsigned long long)pSrcCaches);
                 }
-                VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
-                vkMergePipelineCaches_VkResult_return =
-                    vk->vkMergePipelineCaches(unboxed_device, dstCache, srcCacheCount, pSrcCaches);
+                VkResult vkMergePipelineCaches_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkMergePipelineCaches_VkResult_return = vk->vkMergePipelineCaches(
+                        unboxed_device, dstCache, srcCacheCount, pSrcCaches);
+                }
                 if ((vkMergePipelineCaches_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkMergePipelineCaches_VkResult_return, opcode,
@@ -4487,12 +4482,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkMergePipelineCaches(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkMergePipelineCaches_VkResult_return, device, dstCache, srcCacheCount,
                         pSrcCaches);
                 }
@@ -4515,6 +4507,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -4571,10 +4564,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos,
                             (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                 }
-                VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
-                vkCreateGraphicsPipelines_VkResult_return = m_state->on_vkCreateGraphicsPipelines(
-                    &m_pool, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
-                    pPipelines);
+                VkResult vkCreateGraphicsPipelines_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateGraphicsPipelines_VkResult_return =
+                        m_state->on_vkCreateGraphicsPipelines(&m_pool, snapshotApiCallInfo, device,
+                                                              pipelineCache, createInfoCount,
+                                                              pCreateInfos, pAllocator, pPipelines);
+                }
                 if ((vkCreateGraphicsPipelines_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateGraphicsPipelines_VkResult_return, opcode,
@@ -4595,12 +4591,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateGraphicsPipelines(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateGraphicsPipelines_VkResult_return, device, pipelineCache,
                         createInfoCount, pCreateInfos, pAllocator, pPipelines);
                 }
@@ -4623,6 +4616,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -4679,10 +4673,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos,
                             (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                 }
-                VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
-                vkCreateComputePipelines_VkResult_return = m_state->on_vkCreateComputePipelines(
-                    &m_pool, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
-                    pPipelines);
+                VkResult vkCreateComputePipelines_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateComputePipelines_VkResult_return = m_state->on_vkCreateComputePipelines(
+                        &m_pool, snapshotApiCallInfo, device, pipelineCache, createInfoCount,
+                        pCreateInfos, pAllocator, pPipelines);
+                }
                 if ((vkCreateComputePipelines_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateComputePipelines_VkResult_return, opcode,
@@ -4703,12 +4699,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateComputePipelines(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateComputePipelines_VkResult_return, device, pipelineCache,
                         createInfoCount, pCreateInfos, pAllocator, pPipelines);
                 }
@@ -4728,6 +4721,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for pipeline;
                 VkPipeline boxed_pipeline_preserve;
                 uint64_t cgen_var_1;
@@ -4755,15 +4749,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pipeline,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyPipeline(&m_pool, device, pipeline, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyPipeline(&m_pool, snapshotApiCallInfo, device, pipeline,
+                                                  pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyPipeline(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, device, boxed_pipeline_preserve,
-                                                           pAllocator);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyPipeline(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, device,
+                                                           boxed_pipeline_preserve, pAllocator);
                 }
                 delete_VkPipeline(boxed_pipeline_preserve);
                 vkReadStream->clearPool();
@@ -4778,14 +4772,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 const VkPipelineLayoutCreateInfo* pCreateInfo;
                 const VkAllocationCallbacks* pAllocator;
                 VkPipelineLayout* pPipelineLayout;
-                // Begin non wrapped dispatchable handle unboxing for device;
+                // Begin global wrapped dispatchable handle unboxing for device;
                 uint64_t cgen_var_0;
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
-                auto unboxed_device = unbox_VkDevice(device);
                 auto vk = dispatch_VkDevice(device);
-                // End manual dispatchable handle unboxing for device;
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineLayoutCreateInfo));
                 reservedunmarshal_VkPipelineLayoutCreateInfo(
                     vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
@@ -4822,35 +4814,32 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pPipelineLayout);
                 }
-                m_state->lock();
-                VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
-                vkCreatePipelineLayout_VkResult_return = vk->vkCreatePipelineLayout(
-                    unboxed_device, pCreateInfo, pAllocator, pPipelineLayout);
+                VkResult vkCreatePipelineLayout_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreatePipelineLayout_VkResult_return = m_state->on_vkCreatePipelineLayout(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator,
+                        pPipelineLayout);
+                }
                 if ((vkCreatePipelineLayout_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreatePipelineLayout_VkResult_return, opcode,
                                              context);
-                m_state->unlock();
                 vkStream->unsetHandleMapping();
-                // Begin auto non dispatchable handle create for pPipelineLayout;
-                if (vkCreatePipelineLayout_VkResult_return == VK_SUCCESS)
-                    vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
+                // Begin manual non dispatchable handle create for pPipelineLayout;
+                vkStream->unsetHandleMapping();
                 uint64_t cgen_var_3;
                 static_assert(8 == sizeof(VkPipelineLayout),
                               "handle map overwrite requires VkPipelineLayout to be 8 bytes long");
                 vkStream->handleMapping()->mapHandles_VkPipelineLayout(
                     (VkPipelineLayout*)pPipelineLayout, 1);
                 vkStream->write((VkPipelineLayout*)pPipelineLayout, 8 * 1);
-                // Begin auto non dispatchable handle create for pPipelineLayout;
+                // Begin manual non dispatchable handle create for pPipelineLayout;
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreatePipelineLayout(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreatePipelineLayout_VkResult_return, device, pCreateInfo, pAllocator,
                         pPipelineLayout);
                 }
@@ -4902,19 +4891,18 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)pipelineLayout, (unsigned long long)pAllocator);
                 }
-                std::function<void()> delayed_remove_callback = [vk, unboxed_device, pipelineLayout,
+                std::function<void()> delayed_remove_callback = [vk, device, pipelineLayout,
                                                                  pAllocator]() {
-                    auto state = VkDecoderGlobalState::get();
-                    // state already locked;
-                    vk->vkDestroyPipelineLayout(unboxed_device, pipelineLayout, pAllocator);
+                    auto m_state = VkDecoderGlobalState::get();
+                    if (CC_LIKELY(vk)) {
+                        m_state->on_vkDestroyPipelineLayout(nullptr, nullptr, device,
+                                                            pipelineLayout, pAllocator);
+                    }
                 };
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyPipelineLayout(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_pipelineLayout_preserve, pAllocator);
                 }
                 delayed_delete_VkPipelineLayout(boxed_pipelineLayout_preserve, unboxed_device,
@@ -4936,6 +4924,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerCreateInfo));
                 reservedunmarshal_VkSamplerCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                       (VkSamplerCreateInfo*)(pCreateInfo),
@@ -4971,9 +4960,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pSampler);
                 }
-                VkResult vkCreateSampler_VkResult_return = (VkResult)0;
-                vkCreateSampler_VkResult_return =
-                    m_state->on_vkCreateSampler(&m_pool, device, pCreateInfo, pAllocator, pSampler);
+                VkResult vkCreateSampler_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateSampler_VkResult_return = m_state->on_vkCreateSampler(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pSampler);
+                }
                 if ((vkCreateSampler_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateSampler_VkResult_return, opcode, context);
@@ -4989,12 +4980,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateSampler_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCreateSampler(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, vkCreateSampler_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCreateSampler(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, vkCreateSampler_VkResult_return,
                                                          device, pCreateInfo, pAllocator, pSampler);
                 }
                 vkReadStream->clearPool();
@@ -5013,6 +5001,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for sampler;
                 VkSampler boxed_sampler_preserve;
                 uint64_t cgen_var_1;
@@ -5040,14 +5029,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)sampler,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroySampler(&m_pool, device, sampler, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroySampler(&m_pool, snapshotApiCallInfo, device, sampler,
+                                                 pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroySampler(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, device, boxed_sampler_preserve,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroySampler(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, device, boxed_sampler_preserve,
                                                           pAllocator);
                 }
                 delete_VkSampler(boxed_sampler_preserve);
@@ -5068,6 +5057,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo,
                                     sizeof(const VkDescriptorSetLayoutCreateInfo));
                 reservedunmarshal_VkDescriptorSetLayoutCreateInfo(
@@ -5107,10 +5097,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pSetLayout);
                 }
-                VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
-                vkCreateDescriptorSetLayout_VkResult_return =
-                    m_state->on_vkCreateDescriptorSetLayout(&m_pool, device, pCreateInfo,
-                                                            pAllocator, pSetLayout);
+                VkResult vkCreateDescriptorSetLayout_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateDescriptorSetLayout_VkResult_return =
+                        m_state->on_vkCreateDescriptorSetLayout(&m_pool, snapshotApiCallInfo,
+                                                                device, pCreateInfo, pAllocator,
+                                                                pSetLayout);
+                }
                 if ((vkCreateDescriptorSetLayout_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateDescriptorSetLayout_VkResult_return, opcode,
@@ -5129,12 +5122,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateDescriptorSetLayout(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateDescriptorSetLayout_VkResult_return, device, pCreateInfo,
                         pAllocator, pSetLayout);
                 }
@@ -5154,6 +5144,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for descriptorSetLayout;
                 VkDescriptorSetLayout boxed_descriptorSetLayout_preserve;
                 uint64_t cgen_var_1;
@@ -5185,15 +5176,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)descriptorSetLayout,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyDescriptorSetLayout(&m_pool, device, descriptorSetLayout,
-                                                         pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyDescriptorSetLayout(&m_pool, snapshotApiCallInfo, device,
+                                                             descriptorSetLayout, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyDescriptorSetLayout(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_descriptorSetLayout_preserve, pAllocator);
                 }
                 delete_VkDescriptorSetLayout(boxed_descriptorSetLayout_preserve);
@@ -5214,6 +5204,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorPoolCreateInfo));
                 reservedunmarshal_VkDescriptorPoolCreateInfo(
                     vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
@@ -5250,9 +5241,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pDescriptorPool);
                 }
-                VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
-                vkCreateDescriptorPool_VkResult_return = m_state->on_vkCreateDescriptorPool(
-                    &m_pool, device, pCreateInfo, pAllocator, pDescriptorPool);
+                VkResult vkCreateDescriptorPool_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateDescriptorPool_VkResult_return = m_state->on_vkCreateDescriptorPool(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator,
+                        pDescriptorPool);
+                }
                 if ((vkCreateDescriptorPool_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateDescriptorPool_VkResult_return, opcode,
@@ -5270,12 +5264,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateDescriptorPool(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateDescriptorPool_VkResult_return, device, pCreateInfo, pAllocator,
                         pDescriptorPool);
                 }
@@ -5295,6 +5286,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for descriptorPool;
                 VkDescriptorPool boxed_descriptorPool_preserve;
                 uint64_t cgen_var_1;
@@ -5324,14 +5316,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)descriptorPool, (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyDescriptorPool(&m_pool, device, descriptorPool, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyDescriptorPool(&m_pool, snapshotApiCallInfo, device,
+                                                        descriptorPool, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyDescriptorPool(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_descriptorPool_preserve, pAllocator);
                 }
                 delete_VkDescriptorPool(boxed_descriptorPool_preserve);
@@ -5351,6 +5343,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -5364,9 +5357,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)descriptorPool, (unsigned long long)flags);
                 }
-                VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
-                vkResetDescriptorPool_VkResult_return =
-                    m_state->on_vkResetDescriptorPool(&m_pool, device, descriptorPool, flags);
+                VkResult vkResetDescriptorPool_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkResetDescriptorPool_VkResult_return = m_state->on_vkResetDescriptorPool(
+                        &m_pool, snapshotApiCallInfo, device, descriptorPool, flags);
+                }
                 if ((vkResetDescriptorPool_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkResetDescriptorPool_VkResult_return, opcode,
@@ -5374,12 +5369,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkResetDescriptorPool(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkResetDescriptorPool_VkResult_return, device, descriptorPool, flags);
                 }
                 vkReadStream->clearPool();
@@ -5398,6 +5390,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pAllocateInfo,
                                     sizeof(const VkDescriptorSetAllocateInfo));
                 reservedunmarshal_VkDescriptorSetAllocateInfo(
@@ -5428,9 +5421,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo,
                             (unsigned long long)pDescriptorSets);
                 }
-                VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
-                vkAllocateDescriptorSets_VkResult_return = m_state->on_vkAllocateDescriptorSets(
-                    &m_pool, device, pAllocateInfo, pDescriptorSets);
+                VkResult vkAllocateDescriptorSets_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkAllocateDescriptorSets_VkResult_return = m_state->on_vkAllocateDescriptorSets(
+                        &m_pool, snapshotApiCallInfo, device, pAllocateInfo, pDescriptorSets);
+                }
                 if ((vkAllocateDescriptorSets_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkAllocateDescriptorSets_VkResult_return, opcode,
@@ -5453,12 +5448,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkAllocateDescriptorSets(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkAllocateDescriptorSets_VkResult_return, device, pAllocateInfo,
                         pDescriptorSets);
                 }
@@ -5479,6 +5471,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -5522,21 +5515,21 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)descriptorSetCount,
                             (unsigned long long)pDescriptorSets);
                 }
-                VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
-                vkFreeDescriptorSets_VkResult_return = m_state->on_vkFreeDescriptorSets(
-                    &m_pool, device, descriptorPool, descriptorSetCount, pDescriptorSets);
+                VkResult vkFreeDescriptorSets_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkFreeDescriptorSets_VkResult_return = m_state->on_vkFreeDescriptorSets(
+                        &m_pool, snapshotApiCallInfo, device, descriptorPool, descriptorSetCount,
+                        pDescriptorSets);
+                }
                 if ((vkFreeDescriptorSets_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkFreeDescriptorSets_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkFreeDescriptorSets(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkFreeDescriptorSets_VkResult_return, device, descriptorPool,
                         descriptorSetCount, boxed_pDescriptorSets_preserve);
                 }
@@ -5559,6 +5552,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((uint32_t*)&descriptorWriteCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pDescriptorWrites,
@@ -5599,16 +5593,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)descriptorCopyCount,
                             (unsigned long long)pDescriptorCopies);
                 }
-                m_state->on_vkUpdateDescriptorSets(&m_pool, device, descriptorWriteCount,
-                                                   pDescriptorWrites, descriptorCopyCount,
-                                                   pDescriptorCopies);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkUpdateDescriptorSets(&m_pool, snapshotApiCallInfo, device,
+                                                       descriptorWriteCount, pDescriptorWrites,
+                                                       descriptorCopyCount, pDescriptorCopies);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkUpdateDescriptorSets(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         descriptorWriteCount, pDescriptorWrites, descriptorCopyCount,
                         pDescriptorCopies);
                 }
@@ -5629,6 +5622,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFramebufferCreateInfo));
                 reservedunmarshal_VkFramebufferCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                           (VkFramebufferCreateInfo*)(pCreateInfo),
@@ -5665,9 +5659,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pFramebuffer);
                 }
-                VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
-                vkCreateFramebuffer_VkResult_return = m_state->on_vkCreateFramebuffer(
-                    &m_pool, device, pCreateInfo, pAllocator, pFramebuffer);
+                VkResult vkCreateFramebuffer_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateFramebuffer_VkResult_return =
+                        m_state->on_vkCreateFramebuffer(&m_pool, snapshotApiCallInfo, device,
+                                                        pCreateInfo, pAllocator, pFramebuffer);
+                }
                 if ((vkCreateFramebuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateFramebuffer_VkResult_return, opcode, context);
@@ -5684,12 +5681,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateFramebuffer(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateFramebuffer_VkResult_return, device, pCreateInfo, pAllocator,
                         pFramebuffer);
                 }
@@ -5709,6 +5703,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for framebuffer;
                 VkFramebuffer boxed_framebuffer_preserve;
                 uint64_t cgen_var_1;
@@ -5737,14 +5732,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)framebuffer,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyFramebuffer(&m_pool, device, framebuffer, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyFramebuffer(&m_pool, snapshotApiCallInfo, device,
+                                                     framebuffer, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyFramebuffer(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_framebuffer_preserve, pAllocator);
                 }
                 delete_VkFramebuffer(boxed_framebuffer_preserve);
@@ -5765,6 +5760,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo));
                 reservedunmarshal_VkRenderPassCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                          (VkRenderPassCreateInfo*)(pCreateInfo),
@@ -5801,9 +5797,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                 }
-                VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
-                vkCreateRenderPass_VkResult_return = m_state->on_vkCreateRenderPass(
-                    &m_pool, device, pCreateInfo, pAllocator, pRenderPass);
+                VkResult vkCreateRenderPass_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateRenderPass_VkResult_return = m_state->on_vkCreateRenderPass(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pRenderPass);
+                }
                 if ((vkCreateRenderPass_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateRenderPass_VkResult_return, opcode, context);
@@ -5819,12 +5817,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateRenderPass(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateRenderPass_VkResult_return, device, pCreateInfo, pAllocator,
                         pRenderPass);
                 }
@@ -5844,6 +5839,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for renderPass;
                 VkRenderPass boxed_renderPass_preserve;
                 uint64_t cgen_var_1;
@@ -5872,14 +5868,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)renderPass,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyRenderPass(&m_pool, device, renderPass, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyRenderPass(&m_pool, snapshotApiCallInfo, device,
+                                                    renderPass, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyRenderPass(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, device,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyRenderPass(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, device,
                                                              boxed_renderPass_preserve, pAllocator);
                 }
                 delete_VkRenderPass(boxed_renderPass_preserve);
@@ -5921,7 +5917,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)renderPass,
                             (unsigned long long)pGranularity);
                 }
-                vk->vkGetRenderAreaGranularity(unboxed_device, renderPass, pGranularity);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetRenderAreaGranularity(unboxed_device, renderPass, pGranularity);
+                }
                 vkStream->unsetHandleMapping();
                 if (pGranularity) {
                     transform_fromhost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
@@ -5929,13 +5927,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkExtent2D(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                    (VkExtent2D*)(pGranularity));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetRenderAreaGranularity(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, renderPass,
-                        pGranularity);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetRenderAreaGranularity(&m_pool, snapshotApiCallInfo,
+                                                                    packet, packetLen, device,
+                                                                    renderPass, pGranularity);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -5954,6 +5949,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkCommandPoolCreateInfo));
                 reservedunmarshal_VkCommandPoolCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                           (VkCommandPoolCreateInfo*)(pCreateInfo),
@@ -5990,9 +5986,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pCommandPool);
                 }
-                VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
-                vkCreateCommandPool_VkResult_return = m_state->on_vkCreateCommandPool(
-                    &m_pool, device, pCreateInfo, pAllocator, pCommandPool);
+                VkResult vkCreateCommandPool_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateCommandPool_VkResult_return =
+                        m_state->on_vkCreateCommandPool(&m_pool, snapshotApiCallInfo, device,
+                                                        pCreateInfo, pAllocator, pCommandPool);
+                }
                 if ((vkCreateCommandPool_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateCommandPool_VkResult_return, opcode, context);
@@ -6009,12 +6008,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateCommandPool(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateCommandPool_VkResult_return, device, pCreateInfo, pAllocator,
                         pCommandPool);
                 }
@@ -6034,6 +6030,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for commandPool;
                 VkCommandPool boxed_commandPool_preserve;
                 uint64_t cgen_var_1;
@@ -6062,14 +6059,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)commandPool,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyCommandPool(&m_pool, device, commandPool, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyCommandPool(&m_pool, snapshotApiCallInfo, device,
+                                                     commandPool, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyCommandPool(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_commandPool_preserve, pAllocator);
                 }
                 delete_VkCommandPool(boxed_commandPool_preserve);
@@ -6089,6 +6086,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -6102,21 +6100,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)commandPool,
                             (unsigned long long)flags);
                 }
-                VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
-                vkResetCommandPool_VkResult_return =
-                    m_state->on_vkResetCommandPool(&m_pool, device, commandPool, flags);
+                VkResult vkResetCommandPool_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkResetCommandPool_VkResult_return = m_state->on_vkResetCommandPool(
+                        &m_pool, snapshotApiCallInfo, device, commandPool, flags);
+                }
                 if ((vkResetCommandPool_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkResetCommandPool_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkResetCommandPool(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkResetCommandPool_VkResult_return, device, commandPool, flags);
                 }
                 vkReadStream->clearPool();
@@ -6135,6 +6132,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pAllocateInfo,
                                     sizeof(const VkCommandBufferAllocateInfo));
                 reservedunmarshal_VkCommandBufferAllocateInfo(
@@ -6165,9 +6163,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo,
                             (unsigned long long)pCommandBuffers);
                 }
-                VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
-                vkAllocateCommandBuffers_VkResult_return = m_state->on_vkAllocateCommandBuffers(
-                    &m_pool, device, pAllocateInfo, pCommandBuffers);
+                VkResult vkAllocateCommandBuffers_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkAllocateCommandBuffers_VkResult_return = m_state->on_vkAllocateCommandBuffers(
+                        &m_pool, snapshotApiCallInfo, device, pAllocateInfo, pCommandBuffers);
+                }
                 if ((vkAllocateCommandBuffers_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkAllocateCommandBuffers_VkResult_return, opcode,
@@ -6186,12 +6186,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 vkStream->write(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkAllocateCommandBuffers(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkAllocateCommandBuffers_VkResult_return, device, pAllocateInfo,
                         pCommandBuffers);
                 }
@@ -6212,6 +6209,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -6254,15 +6252,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)commandBufferCount,
                             (unsigned long long)pCommandBuffers);
                 }
-                m_state->on_vkFreeCommandBuffers(&m_pool, device, commandPool, commandBufferCount,
-                                                 pCommandBuffers);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkFreeCommandBuffers(&m_pool, snapshotApiCallInfo, device,
+                                                     commandPool, commandBufferCount,
+                                                     pCommandBuffers);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkFreeCommandBuffers(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, commandPool,
                         commandBufferCount, boxed_pCommandBuffers_preserve);
                 }
                 if (((commandBufferCount))) {
@@ -6286,6 +6284,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                 reservedunmarshal_VkCommandBufferBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                            (VkCommandBufferBeginInfo*)(pBeginInfo),
@@ -6299,21 +6298,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pBeginInfo);
                 }
-                VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
-                vkBeginCommandBuffer_VkResult_return =
-                    m_state->on_vkBeginCommandBuffer(&m_pool, commandBuffer, pBeginInfo, context);
+                VkResult vkBeginCommandBuffer_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkBeginCommandBuffer_VkResult_return = m_state->on_vkBeginCommandBuffer(
+                        &m_pool, snapshotApiCallInfo, commandBuffer, pBeginInfo, context);
+                }
                 if ((vkBeginCommandBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkBeginCommandBuffer_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkBeginCommandBuffer(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkBeginCommandBuffer_VkResult_return, commandBuffer, pBeginInfo);
                 }
                 vkReadStream->clearPool();
@@ -6331,25 +6329,25 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 if (m_logCalls) {
                     fprintf(stderr, "stream %p: call vkEndCommandBuffer 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer);
                 }
-                VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
-                vkEndCommandBuffer_VkResult_return =
-                    m_state->on_vkEndCommandBuffer(&m_pool, commandBuffer, context);
+                VkResult vkEndCommandBuffer_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkEndCommandBuffer_VkResult_return = m_state->on_vkEndCommandBuffer(
+                        &m_pool, snapshotApiCallInfo, commandBuffer, context);
+                }
                 if ((vkEndCommandBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkEndCommandBuffer_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkEndCommandBuffer(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkEndCommandBuffer_VkResult_return, commandBuffer);
                 }
                 vkReadStream->clearPool();
@@ -6368,6 +6366,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr,
                        sizeof(VkCommandBufferResetFlags));
                 *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
@@ -6375,21 +6374,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkResetCommandBuffer 0x%llx 0x%llx \n",
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)flags);
                 }
-                VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
-                vkResetCommandBuffer_VkResult_return =
-                    m_state->on_vkResetCommandBuffer(&m_pool, commandBuffer, flags);
+                VkResult vkResetCommandBuffer_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkResetCommandBuffer_VkResult_return = m_state->on_vkResetCommandBuffer(
+                        &m_pool, snapshotApiCallInfo, commandBuffer, flags);
+                }
                 if ((vkResetCommandBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkResetCommandBuffer_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkResetCommandBuffer(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkResetCommandBuffer_VkResult_return, commandBuffer, flags);
                 }
                 vkReadStream->clearPool();
@@ -6409,6 +6407,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr,
                        sizeof(VkPipelineBindPoint));
                 *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
@@ -6421,14 +6420,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pipelineBindPoint, (unsigned long long)pipeline);
                 }
-                m_state->on_vkCmdBindPipeline(&m_pool, commandBuffer, pipelineBindPoint, pipeline);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdBindPipeline(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                  pipelineBindPoint, pipeline);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBindPipeline(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, commandBuffer,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBindPipeline(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, commandBuffer,
                                                            pipelineBindPoint, pipeline);
                 }
                 vkReadStream->clearPool();
@@ -6474,15 +6473,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)firstViewport, (unsigned long long)viewportCount,
                             (unsigned long long)pViewports);
                 }
-                vk->vkCmdSetViewport(unboxed_commandBuffer, firstViewport, viewportCount,
-                                     pViewports);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetViewport(unboxed_commandBuffer, firstViewport, viewportCount,
+                                         pViewports);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetViewport(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, commandBuffer, firstViewport,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetViewport(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, commandBuffer, firstViewport,
                                                           viewportCount, pViewports);
                 }
                 vkReadStream->clearPool();
@@ -6527,14 +6525,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)firstScissor, (unsigned long long)scissorCount,
                             (unsigned long long)pScissors);
                 }
-                vk->vkCmdSetScissor(unboxed_commandBuffer, firstScissor, scissorCount, pScissors);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetScissor(unboxed_commandBuffer, firstScissor, scissorCount,
+                                        pScissors);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetScissor(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, commandBuffer, firstScissor,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetScissor(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, commandBuffer, firstScissor,
                                                          scissorCount, pScissors);
                 }
                 vkReadStream->clearPool();
@@ -6562,14 +6560,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdSetLineWidth 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)lineWidth);
                 }
-                vk->vkCmdSetLineWidth(unboxed_commandBuffer, lineWidth);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetLineWidth(unboxed_commandBuffer, lineWidth);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetLineWidth(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, commandBuffer, lineWidth);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetLineWidth(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, commandBuffer, lineWidth);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -6606,15 +6603,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)depthBiasClamp,
                             (unsigned long long)depthBiasSlopeFactor);
                 }
-                vk->vkCmdSetDepthBias(unboxed_commandBuffer, depthBiasConstantFactor,
-                                      depthBiasClamp, depthBiasSlopeFactor);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBias(unboxed_commandBuffer, depthBiasConstantFactor,
+                                          depthBiasClamp, depthBiasSlopeFactor);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetDepthBias(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                 }
                 vkReadStream->clearPool();
@@ -6643,15 +6639,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)blendConstants);
                 }
-                vk->vkCmdSetBlendConstants(unboxed_commandBuffer, blendConstants);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetBlendConstants(unboxed_commandBuffer, blendConstants);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetBlendConstants(snapshotTraceBegin,
-                                                                snapshotTraceBytes, &m_pool,
-                                                                commandBuffer, blendConstants);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetBlendConstants(&m_pool, snapshotApiCallInfo,
+                                                                packet, packetLen, commandBuffer,
+                                                                blendConstants);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -6682,15 +6677,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)minDepthBounds, (unsigned long long)maxDepthBounds);
                 }
-                vk->vkCmdSetDepthBounds(unboxed_commandBuffer, minDepthBounds, maxDepthBounds);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBounds(unboxed_commandBuffer, minDepthBounds, maxDepthBounds);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetDepthBounds(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, commandBuffer, minDepthBounds,
-                                                             maxDepthBounds);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetDepthBounds(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, commandBuffer,
+                                                             minDepthBounds, maxDepthBounds);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -6723,14 +6717,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)faceMask, (unsigned long long)compareMask);
                 }
-                vk->vkCmdSetStencilCompareMask(unboxed_commandBuffer, faceMask, compareMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilCompareMask(unboxed_commandBuffer, faceMask, compareMask);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetStencilCompareMask(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, faceMask,
                         compareMask);
                 }
                 vkReadStream->clearPool();
@@ -6764,15 +6757,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)faceMask, (unsigned long long)writeMask);
                 }
-                vk->vkCmdSetStencilWriteMask(unboxed_commandBuffer, faceMask, writeMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilWriteMask(unboxed_commandBuffer, faceMask, writeMask);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetStencilWriteMask(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask,
-                        writeMask);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetStencilWriteMask(&m_pool, snapshotApiCallInfo,
+                                                                  packet, packetLen, commandBuffer,
+                                                                  faceMask, writeMask);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -6805,15 +6797,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)faceMask, (unsigned long long)reference);
                 }
-                vk->vkCmdSetStencilReference(unboxed_commandBuffer, faceMask, reference);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilReference(unboxed_commandBuffer, faceMask, reference);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetStencilReference(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask,
-                        reference);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetStencilReference(&m_pool, snapshotApiCallInfo,
+                                                                  packet, packetLen, commandBuffer,
+                                                                  faceMask, reference);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -6837,6 +6828,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr,
                        sizeof(VkPipelineBindPoint));
                 *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
@@ -6880,16 +6872,16 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dynamicOffsetCount,
                             (unsigned long long)pDynamicOffsets);
                 }
-                m_state->on_vkCmdBindDescriptorSets(
-                    &m_pool, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount,
-                    pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdBindDescriptorSets(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                        pipelineBindPoint, layout, firstSet,
+                                                        descriptorSetCount, pDescriptorSets,
+                                                        dynamicOffsetCount, pDynamicOffsets);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdBindDescriptorSets(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets,
                         dynamicOffsetCount, pDynamicOffsets);
                 }
@@ -6928,15 +6920,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer,
                             (unsigned long long)offset, (unsigned long long)indexType);
                 }
-                vk->vkCmdBindIndexBuffer(unboxed_commandBuffer, buffer, offset, indexType);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindIndexBuffer(unboxed_commandBuffer, buffer, offset, indexType);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBindIndexBuffer(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer,
-                        offset, indexType);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBindIndexBuffer(&m_pool, snapshotApiCallInfo, packet,
+                                                              packetLen, commandBuffer, buffer,
+                                                              offset, indexType);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -6988,15 +6979,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)firstBinding, (unsigned long long)bindingCount,
                             (unsigned long long)pBuffers, (unsigned long long)pOffsets);
                 }
-                vk->vkCmdBindVertexBuffers(unboxed_commandBuffer, firstBinding, bindingCount,
-                                           pBuffers, pOffsets);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindVertexBuffers(unboxed_commandBuffer, firstBinding, bindingCount,
+                                               pBuffers, pOffsets);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdBindVertexBuffers(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         firstBinding, bindingCount, pBuffers, pOffsets);
                 }
                 vkReadStream->clearPool();
@@ -7035,14 +7025,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)vertexCount, (unsigned long long)instanceCount,
                             (unsigned long long)firstVertex, (unsigned long long)firstInstance);
                 }
-                vk->vkCmdDraw(unboxed_commandBuffer, vertexCount, instanceCount, firstVertex,
-                              firstInstance);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDraw(unboxed_commandBuffer, vertexCount, instanceCount, firstVertex,
+                                  firstInstance);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdDraw(snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdDraw(&m_pool, snapshotApiCallInfo, packet, packetLen,
                                                    commandBuffer, vertexCount, instanceCount,
                                                    firstVertex, firstInstance);
                 }
@@ -7088,15 +7077,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)firstIndex, (unsigned long long)vertexOffset,
                             (unsigned long long)firstInstance);
                 }
-                vk->vkCmdDrawIndexed(unboxed_commandBuffer, indexCount, instanceCount, firstIndex,
-                                     vertexOffset, firstInstance);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndexed(unboxed_commandBuffer, indexCount, instanceCount,
+                                         firstIndex, vertexOffset, firstInstance);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdDrawIndexed(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, indexCount,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, indexCount,
                         instanceCount, firstIndex, vertexOffset, firstInstance);
                 }
                 vkReadStream->clearPool();
@@ -7139,14 +7127,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)offset, (unsigned long long)drawCount,
                         (unsigned long long)stride);
                 }
-                vk->vkCmdDrawIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdDrawIndirect(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, commandBuffer, buffer, offset,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdDrawIndirect(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, commandBuffer, buffer, offset,
                                                            drawCount, stride);
                 }
                 vkReadStream->clearPool();
@@ -7189,15 +7176,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)offset, (unsigned long long)drawCount,
                             (unsigned long long)stride);
                 }
-                vk->vkCmdDrawIndexedIndirect(unboxed_commandBuffer, buffer, offset, drawCount,
-                                             stride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndexedIndirect(unboxed_commandBuffer, buffer, offset, drawCount,
+                                                 stride);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdDrawIndexedIndirect(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, buffer,
                         offset, drawCount, stride);
                 }
                 vkReadStream->clearPool();
@@ -7232,14 +7218,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)groupCountX, (unsigned long long)groupCountY,
                             (unsigned long long)groupCountZ);
                 }
-                vk->vkCmdDispatch(unboxed_commandBuffer, groupCountX, groupCountY, groupCountZ);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDispatch(unboxed_commandBuffer, groupCountX, groupCountY, groupCountZ);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdDispatch(snapshotTraceBegin, snapshotTraceBytes,
-                                                       &m_pool, commandBuffer, groupCountX,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdDispatch(&m_pool, snapshotApiCallInfo, packet,
+                                                       packetLen, commandBuffer, groupCountX,
                                                        groupCountY, groupCountZ);
                 }
                 vkReadStream->clearPool();
@@ -7273,15 +7258,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer,
                             (unsigned long long)offset);
                 }
-                vk->vkCmdDispatchIndirect(unboxed_commandBuffer, buffer, offset);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDispatchIndirect(unboxed_commandBuffer, buffer, offset);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdDispatchIndirect(snapshotTraceBegin,
-                                                               snapshotTraceBytes, &m_pool,
-                                                               commandBuffer, buffer, offset);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdDispatchIndirect(&m_pool, snapshotApiCallInfo, packet,
+                                                               packetLen, commandBuffer, buffer,
+                                                               offset);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -7333,15 +7317,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)srcBuffer, (unsigned long long)dstBuffer,
                             (unsigned long long)regionCount, (unsigned long long)pRegions);
                 }
-                vk->vkCmdCopyBuffer(unboxed_commandBuffer, srcBuffer, dstBuffer, regionCount,
-                                    pRegions);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdCopyBuffer(unboxed_commandBuffer, srcBuffer, dstBuffer, regionCount,
+                                        pRegions);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdCopyBuffer(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, commandBuffer, srcBuffer,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdCopyBuffer(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, commandBuffer, srcBuffer,
                                                          dstBuffer, regionCount, pRegions);
                 }
                 vkReadStream->clearPool();
@@ -7364,6 +7347,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -7397,15 +7381,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dstImage, (unsigned long long)dstImageLayout,
                             (unsigned long long)regionCount, (unsigned long long)pRegions);
                 }
-                m_state->on_vkCmdCopyImage(&m_pool, commandBuffer, srcImage, srcImageLayout,
-                                           dstImage, dstImageLayout, regionCount, pRegions);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdCopyImage(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                               srcImage, srcImageLayout, dstImage, dstImageLayout,
+                                               regionCount, pRegions);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdCopyImage(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, srcImage,
                         srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                 }
                 vkReadStream->clearPool();
@@ -7468,15 +7452,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)regionCount, (unsigned long long)pRegions,
                             (unsigned long long)filter);
                 }
-                vk->vkCmdBlitImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage,
-                                   dstImageLayout, regionCount, pRegions, filter);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBlitImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage,
+                                       dstImageLayout, regionCount, pRegions, filter);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdBlitImage(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, srcImage,
                         srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                 }
                 vkReadStream->clearPool();
@@ -7499,6 +7482,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -7533,15 +7517,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dstImageLayout, (unsigned long long)regionCount,
                             (unsigned long long)pRegions);
                 }
-                m_state->on_vkCmdCopyBufferToImage(&m_pool, commandBuffer, srcBuffer, dstImage,
-                                                   dstImageLayout, regionCount, pRegions, context);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdCopyBufferToImage(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                       srcBuffer, dstImage, dstImageLayout,
+                                                       regionCount, pRegions, context);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdCopyBufferToImage(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, srcBuffer,
                         dstImage, dstImageLayout, regionCount, pRegions);
                 }
                 vkReadStream->clearPool();
@@ -7564,6 +7548,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -7598,15 +7583,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dstBuffer, (unsigned long long)regionCount,
                             (unsigned long long)pRegions);
                 }
-                m_state->on_vkCmdCopyImageToBuffer(&m_pool, commandBuffer, srcImage, srcImageLayout,
-                                                   dstBuffer, regionCount, pRegions);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdCopyImageToBuffer(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                       srcImage, srcImageLayout, dstBuffer,
+                                                       regionCount, pRegions);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdCopyImageToBuffer(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, srcImage,
                         srcImageLayout, dstBuffer, regionCount, pRegions);
                 }
                 vkReadStream->clearPool();
@@ -7650,14 +7635,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)dstOffset, (unsigned long long)dataSize,
                         (unsigned long long)pData);
                 }
-                vk->vkCmdUpdateBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, dataSize, pData);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdUpdateBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, dataSize,
+                                          pData);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdUpdateBuffer(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, commandBuffer, dstBuffer,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdUpdateBuffer(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, commandBuffer, dstBuffer,
                                                            dstOffset, dataSize, pData);
                 }
                 vkReadStream->clearPool();
@@ -7699,14 +7684,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dstBuffer, (unsigned long long)dstOffset,
                             (unsigned long long)size, (unsigned long long)data);
                 }
-                vk->vkCmdFillBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, size, data);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdFillBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, size, data);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdFillBuffer(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, commandBuffer, dstBuffer,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdFillBuffer(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, commandBuffer, dstBuffer,
                                                          dstOffset, size, data);
                 }
                 vkReadStream->clearPool();
@@ -7767,15 +7751,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)imageLayout, (unsigned long long)pColor,
                             (unsigned long long)rangeCount, (unsigned long long)pRanges);
                 }
-                vk->vkCmdClearColorImage(unboxed_commandBuffer, image, imageLayout, pColor,
-                                         rangeCount, pRanges);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdClearColorImage(unboxed_commandBuffer, image, imageLayout, pColor,
+                                             rangeCount, pRanges);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdClearColorImage(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, image,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, image,
                         imageLayout, pColor, rangeCount, pRanges);
                 }
                 vkReadStream->clearPool();
@@ -7838,15 +7821,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)imageLayout, (unsigned long long)pDepthStencil,
                             (unsigned long long)rangeCount, (unsigned long long)pRanges);
                 }
-                vk->vkCmdClearDepthStencilImage(unboxed_commandBuffer, image, imageLayout,
-                                                pDepthStencil, rangeCount, pRanges);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdClearDepthStencilImage(unboxed_commandBuffer, image, imageLayout,
+                                                    pDepthStencil, rangeCount, pRanges);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdClearDepthStencilImage(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, image,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, image,
                         imageLayout, pDepthStencil, rangeCount, pRanges);
                 }
                 vkReadStream->clearPool();
@@ -7906,15 +7888,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)attachmentCount, (unsigned long long)pAttachments,
                             (unsigned long long)rectCount, (unsigned long long)pRects);
                 }
-                vk->vkCmdClearAttachments(unboxed_commandBuffer, attachmentCount, pAttachments,
-                                          rectCount, pRects);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdClearAttachments(unboxed_commandBuffer, attachmentCount, pAttachments,
+                                              rectCount, pRects);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdClearAttachments(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         attachmentCount, pAttachments, rectCount, pRects);
                 }
                 vkReadStream->clearPool();
@@ -7976,15 +7957,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dstImage, (unsigned long long)dstImageLayout,
                             (unsigned long long)regionCount, (unsigned long long)pRegions);
                 }
-                vk->vkCmdResolveImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage,
-                                      dstImageLayout, regionCount, pRegions);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResolveImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage,
+                                          dstImageLayout, regionCount, pRegions);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdResolveImage(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, srcImage,
                         srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                 }
                 vkReadStream->clearPool();
@@ -8018,14 +7998,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)event,
                             (unsigned long long)stageMask);
                 }
-                vk->vkCmdSetEvent(unboxed_commandBuffer, event, stageMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetEvent(unboxed_commandBuffer, event, stageMask);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetEvent(snapshotTraceBegin, snapshotTraceBytes,
-                                                       &m_pool, commandBuffer, event, stageMask);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetEvent(&m_pool, snapshotApiCallInfo, packet,
+                                                       packetLen, commandBuffer, event, stageMask);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -8059,14 +8038,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)event,
                             (unsigned long long)stageMask);
                 }
-                vk->vkCmdResetEvent(unboxed_commandBuffer, event, stageMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResetEvent(unboxed_commandBuffer, event, stageMask);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdResetEvent(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, commandBuffer, event, stageMask);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdResetEvent(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, commandBuffer, event,
+                                                         stageMask);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -8176,17 +8155,16 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)imageMemoryBarrierCount,
                             (unsigned long long)pImageMemoryBarriers);
                 }
-                vk->vkCmdWaitEvents(unboxed_commandBuffer, eventCount, pEvents, srcStageMask,
-                                    dstStageMask, memoryBarrierCount, pMemoryBarriers,
-                                    bufferMemoryBarrierCount, pBufferMemoryBarriers,
-                                    imageMemoryBarrierCount, pImageMemoryBarriers);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWaitEvents(unboxed_commandBuffer, eventCount, pEvents, srcStageMask,
+                                        dstStageMask, memoryBarrierCount, pMemoryBarriers,
+                                        bufferMemoryBarrierCount, pBufferMemoryBarriers,
+                                        imageMemoryBarrierCount, pImageMemoryBarriers);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdWaitEvents(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, eventCount,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, eventCount,
                         pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers,
                         bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount,
                         pImageMemoryBarriers);
@@ -8215,6 +8193,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 memcpy((VkPipelineStageFlags*)&srcStageMask, *readStreamPtrPtr,
                        sizeof(VkPipelineStageFlags));
                 *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
@@ -8285,17 +8264,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)imageMemoryBarrierCount,
                             (unsigned long long)pImageMemoryBarriers);
                 }
-                m_state->on_vkCmdPipelineBarrier(
-                    &m_pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags,
-                    memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount,
-                    pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdPipelineBarrier(
+                        &m_pool, snapshotApiCallInfo, commandBuffer, srcStageMask, dstStageMask,
+                        dependencyFlags, memoryBarrierCount, pMemoryBarriers,
+                        bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount,
+                        pImageMemoryBarriers);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdPipelineBarrier(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount,
                         pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers,
                         imageMemoryBarrierCount, pImageMemoryBarriers);
@@ -8337,14 +8316,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool,
                         (unsigned long long)query, (unsigned long long)flags);
                 }
-                vk->vkCmdBeginQuery(unboxed_commandBuffer, queryPool, query, flags);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginQuery(unboxed_commandBuffer, queryPool, query, flags);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBeginQuery(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, commandBuffer, queryPool, query,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBeginQuery(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, commandBuffer, queryPool, query,
                                                          flags);
                 }
                 vkReadStream->clearPool();
@@ -8378,14 +8356,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)queryPool, (unsigned long long)query);
                 }
-                vk->vkCmdEndQuery(unboxed_commandBuffer, queryPool, query);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndQuery(unboxed_commandBuffer, queryPool, query);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdEndQuery(snapshotTraceBegin, snapshotTraceBytes,
-                                                       &m_pool, commandBuffer, queryPool, query);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdEndQuery(&m_pool, snapshotApiCallInfo, packet,
+                                                       packetLen, commandBuffer, queryPool, query);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -8424,14 +8401,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)queryPool, (unsigned long long)firstQuery,
                             (unsigned long long)queryCount);
                 }
-                vk->vkCmdResetQueryPool(unboxed_commandBuffer, queryPool, firstQuery, queryCount);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResetQueryPool(unboxed_commandBuffer, queryPool, firstQuery,
+                                            queryCount);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdResetQueryPool(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, commandBuffer, queryPool,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdResetQueryPool(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, commandBuffer, queryPool,
                                                              firstQuery, queryCount);
                 }
                 vkReadStream->clearPool();
@@ -8472,15 +8449,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pipelineStage, (unsigned long long)queryPool,
                             (unsigned long long)query);
                 }
-                vk->vkCmdWriteTimestamp(unboxed_commandBuffer, pipelineStage, queryPool, query);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWriteTimestamp(unboxed_commandBuffer, pipelineStage, queryPool, query);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdWriteTimestamp(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, commandBuffer, pipelineStage,
-                                                             queryPool, query);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdWriteTimestamp(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, commandBuffer,
+                                                             pipelineStage, queryPool, query);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -8536,15 +8512,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dstOffset, (unsigned long long)stride,
                             (unsigned long long)flags);
                 }
-                vk->vkCmdCopyQueryPoolResults(unboxed_commandBuffer, queryPool, firstQuery,
-                                              queryCount, dstBuffer, dstOffset, stride, flags);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdCopyQueryPoolResults(unboxed_commandBuffer, queryPool, firstQuery,
+                                                  queryCount, dstBuffer, dstOffset, stride, flags);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdCopyQueryPoolResults(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, queryPool,
                         firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                 }
                 vkReadStream->clearPool();
@@ -8593,15 +8568,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)stageFlags, (unsigned long long)offset,
                             (unsigned long long)size, (unsigned long long)pValues);
                 }
-                vk->vkCmdPushConstants(unboxed_commandBuffer, layout, stageFlags, offset, size,
-                                       pValues);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdPushConstants(unboxed_commandBuffer, layout, stageFlags, offset, size,
+                                           pValues);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdPushConstants(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, commandBuffer, layout,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdPushConstants(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, commandBuffer, layout,
                                                             stageFlags, offset, size, pValues);
                 }
                 vkReadStream->clearPool();
@@ -8621,6 +8595,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                 reservedunmarshal_VkRenderPassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                         (VkRenderPassBeginInfo*)(pRenderPassBegin),
@@ -8636,16 +8611,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pRenderPassBegin, (unsigned long long)contents);
                 }
-                m_state->on_vkCmdBeginRenderPass(&m_pool, commandBuffer, pRenderPassBegin,
-                                                 contents);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdBeginRenderPass(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                     pRenderPassBegin, contents);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBeginRenderPass(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        pRenderPassBegin, contents);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBeginRenderPass(&m_pool, snapshotApiCallInfo, packet,
+                                                              packetLen, commandBuffer,
+                                                              pRenderPassBegin, contents);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -8672,14 +8646,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdNextSubpass 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)contents);
                 }
-                vk->vkCmdNextSubpass(unboxed_commandBuffer, contents);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdNextSubpass(unboxed_commandBuffer, contents);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdNextSubpass(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, commandBuffer, contents);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdNextSubpass(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, commandBuffer, contents);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -8703,14 +8676,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdEndRenderPass 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer);
                 }
-                vk->vkCmdEndRenderPass(unboxed_commandBuffer);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRenderPass(unboxed_commandBuffer);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdEndRenderPass(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, commandBuffer);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdEndRenderPass(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, commandBuffer);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -8729,6 +8701,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 memcpy((uint32_t*)&commandBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pCommandBuffers,
@@ -8750,16 +8723,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)commandBufferCount,
                             (unsigned long long)pCommandBuffers);
                 }
-                m_state->on_vkCmdExecuteCommands(&m_pool, commandBuffer, commandBufferCount,
-                                                 pCommandBuffers);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdExecuteCommands(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                     commandBufferCount, pCommandBuffers);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdExecuteCommands(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        commandBufferCount, pCommandBuffers);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdExecuteCommands(&m_pool, snapshotApiCallInfo, packet,
+                                                              packetLen, commandBuffer,
+                                                              commandBufferCount, pCommandBuffers);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -8781,9 +8753,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkEnumerateInstanceVersion 0x%llx \n",
                             ioStream, (unsigned long long)pApiVersion);
                 }
-                VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
-                vkEnumerateInstanceVersion_VkResult_return =
-                    m_state->on_vkEnumerateInstanceVersion(&m_pool, pApiVersion);
+                VkResult vkEnumerateInstanceVersion_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                vkEnumerateInstanceVersion_VkResult_return = m_state->on_vkEnumerateInstanceVersion(
+                    &m_pool, snapshotApiCallInfo, pApiVersion);
                 if ((vkEnumerateInstanceVersion_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkEnumerateInstanceVersion_VkResult_return, opcode,
@@ -8792,12 +8764,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
                 vkStream->write(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkEnumerateInstanceVersion(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkEnumerateInstanceVersion_VkResult_return, pApiVersion);
                 }
                 vkReadStream->clearPool();
@@ -8816,6 +8785,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pBindInfos,
@@ -8836,21 +8806,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount,
                             (unsigned long long)pBindInfos);
                 }
-                VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
-                vkBindBufferMemory2_VkResult_return =
-                    m_state->on_vkBindBufferMemory2(&m_pool, device, bindInfoCount, pBindInfos);
+                VkResult vkBindBufferMemory2_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkBindBufferMemory2_VkResult_return = m_state->on_vkBindBufferMemory2(
+                        &m_pool, snapshotApiCallInfo, device, bindInfoCount, pBindInfos);
+                }
                 if ((vkBindBufferMemory2_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkBindBufferMemory2_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkBindBufferMemory2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkBindBufferMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                 }
                 vkReadStream->clearPool();
@@ -8869,6 +8838,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pBindInfos,
@@ -8889,21 +8859,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount,
                             (unsigned long long)pBindInfos);
                 }
-                VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
-                vkBindImageMemory2_VkResult_return =
-                    m_state->on_vkBindImageMemory2(&m_pool, device, bindInfoCount, pBindInfos);
+                VkResult vkBindImageMemory2_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkBindImageMemory2_VkResult_return = m_state->on_vkBindImageMemory2(
+                        &m_pool, snapshotApiCallInfo, device, bindInfoCount, pBindInfos);
+                }
                 if ((vkBindImageMemory2_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkBindImageMemory2_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkBindImageMemory2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkBindImageMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                 }
                 vkReadStream->clearPool();
@@ -8948,18 +8917,18 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)remoteDeviceIndex,
                             (unsigned long long)pPeerMemoryFeatures);
                 }
-                vk->vkGetDeviceGroupPeerMemoryFeatures(unboxed_device, heapIndex, localDeviceIndex,
-                                                       remoteDeviceIndex, pPeerMemoryFeatures);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDeviceGroupPeerMemoryFeatures(unboxed_device, heapIndex,
+                                                           localDeviceIndex, remoteDeviceIndex,
+                                                           pPeerMemoryFeatures);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures,
                                 sizeof(VkPeerMemoryFeatureFlags));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceGroupPeerMemoryFeatures(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, heapIndex,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, heapIndex,
                         localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                 }
                 vkReadStream->clearPool();
@@ -8987,14 +8956,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdSetDeviceMask 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)deviceMask);
                 }
-                vk->vkCmdSetDeviceMask(unboxed_commandBuffer, deviceMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDeviceMask(unboxed_commandBuffer, deviceMask);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetDeviceMask(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, commandBuffer, deviceMask);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetDeviceMask(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, commandBuffer, deviceMask);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -9041,15 +9009,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)baseGroupZ, (unsigned long long)groupCountX,
                             (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                 }
-                vk->vkCmdDispatchBase(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ,
-                                      groupCountX, groupCountY, groupCountZ);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDispatchBase(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ,
+                                          groupCountX, groupCountY, groupCountZ);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdDispatchBase(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, baseGroupX,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, baseGroupX,
                         baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                 }
                 vkReadStream->clearPool();
@@ -9068,6 +9035,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
+                auto vk = dispatch_VkInstance(instance);
                 // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                 vkReadStream->unsetHandleMapping();
                 // WARNING PTR CHECK
@@ -9116,11 +9084,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)pPhysicalDeviceGroupCount,
                         (unsigned long long)pPhysicalDeviceGroupProperties);
                 }
-                VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
-                vkEnumeratePhysicalDeviceGroups_VkResult_return =
-                    m_state->on_vkEnumeratePhysicalDeviceGroups(&m_pool, instance,
-                                                                pPhysicalDeviceGroupCount,
-                                                                pPhysicalDeviceGroupProperties);
+                VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkEnumeratePhysicalDeviceGroups_VkResult_return =
+                        m_state->on_vkEnumeratePhysicalDeviceGroups(
+                            &m_pool, snapshotApiCallInfo, instance, pPhysicalDeviceGroupCount,
+                            pPhysicalDeviceGroupProperties);
+                }
                 if ((vkEnumeratePhysicalDeviceGroups_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkEnumeratePhysicalDeviceGroups_VkResult_return,
@@ -9157,12 +9128,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 vkStream->write(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkEnumeratePhysicalDeviceGroups(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkEnumeratePhysicalDeviceGroups_VkResult_return, instance,
                         pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                 }
@@ -9182,6 +9150,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                 reservedunmarshal_VkImageMemoryRequirementsInfo2(
                     vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
@@ -9206,8 +9175,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pInfo,
                             (unsigned long long)pMemoryRequirements);
                 }
-                m_state->on_vkGetImageMemoryRequirements2(&m_pool, device, pInfo,
-                                                          pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetImageMemoryRequirements2(&m_pool, snapshotApiCallInfo, device,
+                                                              pInfo, pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements2(
@@ -9216,13 +9187,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkMemoryRequirements2*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetImageMemoryRequirements2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
-                        pMemoryRequirements);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetImageMemoryRequirements2(&m_pool, snapshotApiCallInfo,
+                                                                       packet, packetLen, device,
+                                                                       pInfo, pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -9240,6 +9208,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                 reservedunmarshal_VkBufferMemoryRequirementsInfo2(
                     vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
@@ -9265,8 +9234,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)pInfo,
                         (unsigned long long)pMemoryRequirements);
                 }
-                m_state->on_vkGetBufferMemoryRequirements2(&m_pool, device, pInfo,
-                                                           pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetBufferMemoryRequirements2(&m_pool, snapshotApiCallInfo, device,
+                                                               pInfo, pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements2(
@@ -9275,12 +9246,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkMemoryRequirements2*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetBufferMemoryRequirements2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -9360,9 +9328,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pSparseMemoryRequirementCount,
                             (unsigned long long)pSparseMemoryRequirements);
                 }
-                vk->vkGetImageSparseMemoryRequirements2(unboxed_device, pInfo,
-                                                        pSparseMemoryRequirementCount,
-                                                        pSparseMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetImageSparseMemoryRequirements2(unboxed_device, pInfo,
+                                                            pSparseMemoryRequirementCount,
+                                                            pSparseMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
@@ -9394,12 +9364,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetImageSparseMemoryRequirements2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -9418,6 +9385,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pFeatures;
                 vkReadStream->unsetHandleMapping();
                 vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
@@ -9433,7 +9401,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)pFeatures);
                 }
-                m_state->on_vkGetPhysicalDeviceFeatures2(&m_pool, physicalDevice, pFeatures);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceFeatures2(&m_pool, snapshotApiCallInfo,
+                                                             physicalDevice, pFeatures);
+                }
                 vkStream->unsetHandleMapping();
                 if (pFeatures) {
                     transform_fromhost_VkPhysicalDeviceFeatures2(
@@ -9442,12 +9413,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkPhysicalDeviceFeatures2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkPhysicalDeviceFeatures2*)(pFeatures));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceFeatures2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice, pFeatures);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -9465,6 +9433,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pProperties;
                 vkReadStream->unsetHandleMapping();
                 vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
@@ -9481,7 +9450,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)pProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceProperties2(&m_pool, physicalDevice, pProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceProperties2(&m_pool, snapshotApiCallInfo,
+                                                               physicalDevice, pProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pProperties) {
                     transform_fromhost_VkPhysicalDeviceProperties2(
@@ -9490,12 +9462,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkPhysicalDeviceProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkPhysicalDeviceProperties2*)(pProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceProperties2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pProperties);
                 }
                 vkReadStream->clearPool();
@@ -9515,6 +9484,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                 *readStreamPtrPtr += sizeof(VkFormat);
                 // Begin manual dispatchable handle unboxing for pFormatProperties;
@@ -9534,8 +9504,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)format, (unsigned long long)pFormatProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceFormatProperties2(&m_pool, physicalDevice, format,
-                                                                 pFormatProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceFormatProperties2(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, format, pFormatProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pFormatProperties) {
                     transform_fromhost_VkFormatProperties2(
@@ -9544,12 +9516,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkFormatProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                             (VkFormatProperties2*)(pFormatProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice, format,
                         pFormatProperties);
                 }
                 vkReadStream->clearPool();
@@ -9569,6 +9538,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 vkReadStream->alloc((void**)&pImageFormatInfo,
                                     sizeof(const VkPhysicalDeviceImageFormatInfo2));
                 reservedunmarshal_VkPhysicalDeviceImageFormatInfo2(
@@ -9597,10 +9567,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pImageFormatInfo,
                             (unsigned long long)pImageFormatProperties);
                 }
-                VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
-                vkGetPhysicalDeviceImageFormatProperties2_VkResult_return =
-                    m_state->on_vkGetPhysicalDeviceImageFormatProperties2(
-                        &m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
+                VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPhysicalDeviceImageFormatProperties2_VkResult_return =
+                        m_state->on_vkGetPhysicalDeviceImageFormatProperties2(
+                            &m_pool, snapshotApiCallInfo, physicalDevice, pImageFormatInfo,
+                            pImageFormatProperties);
+                }
                 if ((vkGetPhysicalDeviceImageFormatProperties2_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -9617,12 +9591,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, physicalDevice,
                         pImageFormatInfo, pImageFormatProperties);
                 }
@@ -9643,6 +9614,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                 vkReadStream->unsetHandleMapping();
                 // WARNING PTR CHECK
@@ -9688,8 +9660,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pQueueFamilyPropertyCount,
                             (unsigned long long)pQueueFamilyProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceQueueFamilyProperties2(
-                    &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceQueueFamilyProperties2(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, pQueueFamilyPropertyCount,
+                        pQueueFamilyProperties);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
@@ -9718,12 +9693,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pQueueFamilyPropertyCount, pQueueFamilyProperties);
                 }
                 vkReadStream->clearPool();
@@ -9742,6 +9714,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pMemoryProperties;
                 vkReadStream->unsetHandleMapping();
                 vkReadStream->alloc((void**)&pMemoryProperties,
@@ -9759,8 +9732,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)pMemoryProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceMemoryProperties2(&m_pool, physicalDevice,
-                                                                 pMemoryProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceMemoryProperties2(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, pMemoryProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryProperties) {
                     transform_fromhost_VkPhysicalDeviceMemoryProperties2(
@@ -9770,12 +9745,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                     (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pMemoryProperties);
                 }
                 vkReadStream->clearPool();
@@ -9851,8 +9823,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pFormatInfo, (unsigned long long)pPropertyCount,
                             (unsigned long long)pProperties);
                 }
-                vk->vkGetPhysicalDeviceSparseImageFormatProperties2(
-                    unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPhysicalDeviceSparseImageFormatProperties2(
+                        unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
@@ -9881,12 +9855,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pFormatInfo, pPropertyCount, pProperties);
                 }
                 vkReadStream->clearPool();
@@ -9921,14 +9892,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)commandPool,
                             (unsigned long long)flags);
                 }
-                vk->vkTrimCommandPool(unboxed_device, commandPool, flags);
+                if (CC_LIKELY(vk)) {
+                    vk->vkTrimCommandPool(unboxed_device, commandPool, flags);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkTrimCommandPool(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, device, commandPool, flags);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkTrimCommandPool(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, device, commandPool, flags);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -9946,6 +9916,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pQueueInfo, sizeof(const VkDeviceQueueInfo2));
                 reservedunmarshal_VkDeviceQueueInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkDeviceQueueInfo2*)(pQueueInfo),
@@ -9965,7 +9936,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pQueueInfo,
                             (unsigned long long)pQueue);
                 }
-                m_state->on_vkGetDeviceQueue2(&m_pool, device, pQueueInfo, pQueue);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetDeviceQueue2(&m_pool, snapshotApiCallInfo, device, pQueueInfo,
+                                                  pQueue);
+                }
                 vkStream->unsetHandleMapping();
                 uint64_t cgen_var_2;
                 static_assert(8 == sizeof(VkQueue),
@@ -9973,12 +9947,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->handleMapping()->mapHandles_VkQueue((VkQueue*)pQueue, 1);
                 vkStream->write((VkQueue*)pQueue, 8 * 1);
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetDeviceQueue2(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, device, pQueueInfo, pQueue);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetDeviceQueue2(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, device, pQueueInfo, pQueue);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -9997,6 +9968,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo,
                                     sizeof(const VkSamplerYcbcrConversionCreateInfo));
                 reservedunmarshal_VkSamplerYcbcrConversionCreateInfo(
@@ -10036,10 +10008,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pYcbcrConversion);
                 }
-                VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
-                vkCreateSamplerYcbcrConversion_VkResult_return =
-                    m_state->on_vkCreateSamplerYcbcrConversion(&m_pool, device, pCreateInfo,
-                                                               pAllocator, pYcbcrConversion);
+                VkResult vkCreateSamplerYcbcrConversion_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateSamplerYcbcrConversion_VkResult_return =
+                        m_state->on_vkCreateSamplerYcbcrConversion(&m_pool, snapshotApiCallInfo,
+                                                                   device, pCreateInfo, pAllocator,
+                                                                   pYcbcrConversion);
+                }
                 if ((vkCreateSamplerYcbcrConversion_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateSamplerYcbcrConversion_VkResult_return, opcode,
@@ -10058,12 +10034,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateSamplerYcbcrConversion(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateSamplerYcbcrConversion_VkResult_return, device, pCreateInfo,
                         pAllocator, pYcbcrConversion);
                 }
@@ -10083,6 +10056,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                 VkSamplerYcbcrConversion boxed_ycbcrConversion_preserve;
                 uint64_t cgen_var_1;
@@ -10114,15 +10088,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)ycbcrConversion,
                         (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroySamplerYcbcrConversion(&m_pool, device, ycbcrConversion,
-                                                            pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroySamplerYcbcrConversion(
+                        &m_pool, snapshotApiCallInfo, device, ycbcrConversion, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroySamplerYcbcrConversion(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_ycbcrConversion_preserve, pAllocator);
                 }
                 delete_VkSamplerYcbcrConversion(boxed_ycbcrConversion_preserve);
@@ -10143,6 +10116,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo,
                                     sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                 reservedunmarshal_VkDescriptorUpdateTemplateCreateInfo(
@@ -10184,10 +10158,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pAllocator,
                             (unsigned long long)pDescriptorUpdateTemplate);
                 }
-                VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
-                vkCreateDescriptorUpdateTemplate_VkResult_return =
-                    m_state->on_vkCreateDescriptorUpdateTemplate(
-                        &m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
+                VkResult vkCreateDescriptorUpdateTemplate_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateDescriptorUpdateTemplate_VkResult_return =
+                        m_state->on_vkCreateDescriptorUpdateTemplate(
+                            &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator,
+                            pDescriptorUpdateTemplate);
+                }
                 if ((vkCreateDescriptorUpdateTemplate_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateDescriptorUpdateTemplate_VkResult_return,
@@ -10207,12 +10185,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkCreateDescriptorUpdateTemplate_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateDescriptorUpdateTemplate(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateDescriptorUpdateTemplate_VkResult_return, device, pCreateInfo,
                         pAllocator, pDescriptorUpdateTemplate);
                 }
@@ -10232,6 +10207,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for
                 // descriptorUpdateTemplate;
                 VkDescriptorUpdateTemplate boxed_descriptorUpdateTemplate_preserve;
@@ -10266,15 +10242,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)descriptorUpdateTemplate,
                         (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyDescriptorUpdateTemplate(&m_pool, device,
-                                                              descriptorUpdateTemplate, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyDescriptorUpdateTemplate(
+                        &m_pool, snapshotApiCallInfo, device, descriptorUpdateTemplate, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyDescriptorUpdateTemplate(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_descriptorUpdateTemplate_preserve, pAllocator);
                 }
                 delete_VkDescriptorUpdateTemplate(boxed_descriptorUpdateTemplate_preserve);
@@ -10326,15 +10301,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)descriptorUpdateTemplate,
                             (unsigned long long)pData);
                 }
-                vk->vkUpdateDescriptorSetWithTemplate(unboxed_device, descriptorSet,
-                                                      descriptorUpdateTemplate, pData);
+                if (CC_LIKELY(vk)) {
+                    vk->vkUpdateDescriptorSetWithTemplate(unboxed_device, descriptorSet,
+                                                          descriptorUpdateTemplate, pData);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkUpdateDescriptorSetWithTemplate(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, descriptorSet,
                         descriptorUpdateTemplate, pData);
                 }
                 vkReadStream->clearPool();
@@ -10389,8 +10363,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pExternalBufferInfo,
                             (unsigned long long)pExternalBufferProperties);
                 }
-                vk->vkGetPhysicalDeviceExternalBufferProperties(
-                    unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPhysicalDeviceExternalBufferProperties(
+                        unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pExternalBufferProperties) {
                     m_state->transformImpl_VkExternalBufferProperties_fromhost(
@@ -10402,12 +10378,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                     (VkExternalBufferProperties*)(pExternalBufferProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceExternalBufferProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pExternalBufferInfo, pExternalBufferProperties);
                 }
                 vkReadStream->clearPool();
@@ -10458,8 +10431,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pExternalFenceInfo,
                             (unsigned long long)pExternalFenceProperties);
                 }
-                vk->vkGetPhysicalDeviceExternalFenceProperties(
-                    unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPhysicalDeviceExternalFenceProperties(
+                        unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pExternalFenceProperties) {
                     transform_fromhost_VkExternalFenceProperties(
@@ -10469,12 +10444,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                     (VkExternalFenceProperties*)(pExternalFenceProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceExternalFenceProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pExternalFenceInfo, pExternalFenceProperties);
                 }
                 vkReadStream->clearPool();
@@ -10494,6 +10466,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 vkReadStream->alloc((void**)&pExternalSemaphoreInfo,
                                     sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                 reservedunmarshal_VkPhysicalDeviceExternalSemaphoreInfo(
@@ -10524,8 +10497,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pExternalSemaphoreInfo,
                             (unsigned long long)pExternalSemaphoreProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceExternalSemaphoreProperties(
-                    &m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceExternalSemaphoreProperties(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, pExternalSemaphoreInfo,
+                        pExternalSemaphoreProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pExternalSemaphoreProperties) {
                     transform_fromhost_VkExternalSemaphoreProperties(
@@ -10535,12 +10511,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                     (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphoreProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                 }
                 vkReadStream->clearPool();
@@ -10588,7 +10561,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                         (unsigned long long)pSupport);
                 }
-                vk->vkGetDescriptorSetLayoutSupport(unboxed_device, pCreateInfo, pSupport);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDescriptorSetLayoutSupport(unboxed_device, pCreateInfo, pSupport);
+                }
                 vkStream->unsetHandleMapping();
                 if (pSupport) {
                     transform_fromhost_VkDescriptorSetLayoutSupport(
@@ -10597,12 +10572,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkDescriptorSetLayoutSupport(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkDescriptorSetLayoutSupport*)(pSupport));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDescriptorSetLayoutSupport(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pCreateInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pCreateInfo,
                         pSupport);
                 }
                 vkReadStream->clearPool();
@@ -10656,15 +10628,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount,
                             (unsigned long long)stride);
                 }
-                vk->vkCmdDrawIndirectCount(unboxed_commandBuffer, buffer, offset, countBuffer,
-                                           countBufferOffset, maxDrawCount, stride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndirectCount(unboxed_commandBuffer, buffer, offset, countBuffer,
+                                               countBufferOffset, maxDrawCount, stride);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdDrawIndirectCount(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, buffer,
                         offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                 }
                 vkReadStream->clearPool();
@@ -10716,16 +10687,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount,
                             (unsigned long long)stride);
                 }
-                vk->vkCmdDrawIndexedIndirectCount(unboxed_commandBuffer, buffer, offset,
-                                                  countBuffer, countBufferOffset, maxDrawCount,
-                                                  stride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndexedIndirectCount(unboxed_commandBuffer, buffer, offset,
+                                                      countBuffer, countBufferOffset, maxDrawCount,
+                                                      stride);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdDrawIndexedIndirectCount(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, buffer,
                         offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                 }
                 vkReadStream->clearPool();
@@ -10745,6 +10715,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2));
                 reservedunmarshal_VkRenderPassCreateInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                           (VkRenderPassCreateInfo2*)(pCreateInfo),
@@ -10781,9 +10752,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                 }
-                VkResult vkCreateRenderPass2_VkResult_return = (VkResult)0;
-                vkCreateRenderPass2_VkResult_return = m_state->on_vkCreateRenderPass2(
-                    &m_pool, device, pCreateInfo, pAllocator, pRenderPass);
+                VkResult vkCreateRenderPass2_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateRenderPass2_VkResult_return = m_state->on_vkCreateRenderPass2(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pRenderPass);
+                }
                 if ((vkCreateRenderPass2_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateRenderPass2_VkResult_return, opcode, context);
@@ -10799,12 +10772,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateRenderPass2_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateRenderPass2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateRenderPass2_VkResult_return, device, pCreateInfo, pAllocator,
                         pRenderPass);
                 }
@@ -10825,6 +10795,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                 reservedunmarshal_VkRenderPassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                         (VkRenderPassBeginInfo*)(pRenderPassBegin),
@@ -10847,16 +10818,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pRenderPassBegin,
                             (unsigned long long)pSubpassBeginInfo);
                 }
-                m_state->on_vkCmdBeginRenderPass2(&m_pool, commandBuffer, pRenderPassBegin,
-                                                  pSubpassBeginInfo);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdBeginRenderPass2(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                      pRenderPassBegin, pSubpassBeginInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBeginRenderPass2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        pRenderPassBegin, pSubpassBeginInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBeginRenderPass2(&m_pool, snapshotApiCallInfo, packet,
+                                                               packetLen, commandBuffer,
+                                                               pRenderPassBegin, pSubpassBeginInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -10900,14 +10870,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pSubpassBeginInfo,
                             (unsigned long long)pSubpassEndInfo);
                 }
-                vk->vkCmdNextSubpass2(unboxed_commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdNextSubpass2(unboxed_commandBuffer, pSubpassBeginInfo,
+                                          pSubpassEndInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdNextSubpass2(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, commandBuffer,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdNextSubpass2(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, commandBuffer,
                                                            pSubpassBeginInfo, pSubpassEndInfo);
                 }
                 vkReadStream->clearPool();
@@ -10942,14 +10912,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pSubpassEndInfo);
                 }
-                vk->vkCmdEndRenderPass2(unboxed_commandBuffer, pSubpassEndInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRenderPass2(unboxed_commandBuffer, pSubpassEndInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdEndRenderPass2(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, commandBuffer,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdEndRenderPass2(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, commandBuffer,
                                                              pSubpassEndInfo);
                 }
                 vkReadStream->clearPool();
@@ -10987,14 +10956,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)queryPool,
                             (unsigned long long)firstQuery, (unsigned long long)queryCount);
                 }
-                vk->vkResetQueryPool(unboxed_device, queryPool, firstQuery, queryCount);
+                if (CC_LIKELY(vk)) {
+                    vk->vkResetQueryPool(unboxed_device, queryPool, firstQuery, queryCount);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkResetQueryPool(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, device, queryPool, firstQuery,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkResetQueryPool(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, device, queryPool, firstQuery,
                                                           queryCount);
                 }
                 vkReadStream->clearPool();
@@ -11032,9 +11000,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)semaphore,
                             (unsigned long long)pValue);
                 }
-                VkResult vkGetSemaphoreCounterValue_VkResult_return = (VkResult)0;
-                vkGetSemaphoreCounterValue_VkResult_return =
-                    vk->vkGetSemaphoreCounterValue(unboxed_device, semaphore, pValue);
+                VkResult vkGetSemaphoreCounterValue_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetSemaphoreCounterValue_VkResult_return =
+                        vk->vkGetSemaphoreCounterValue(unboxed_device, semaphore, pValue);
+                }
                 if ((vkGetSemaphoreCounterValue_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetSemaphoreCounterValue_VkResult_return, opcode,
@@ -11043,12 +11013,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((uint64_t*)pValue, sizeof(uint64_t));
                 vkStream->write(&vkGetSemaphoreCounterValue_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetSemaphoreCounterValue(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetSemaphoreCounterValue_VkResult_return, device, semaphore, pValue);
                 }
                 vkReadStream->clearPool();
@@ -11062,14 +11029,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 VkDevice device;
                 const VkSemaphoreWaitInfo* pWaitInfo;
                 uint64_t timeout;
-                // Begin non wrapped dispatchable handle unboxing for device;
+                // Begin global wrapped dispatchable handle unboxing for device;
                 uint64_t cgen_var_0;
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
-                auto unboxed_device = unbox_VkDevice(device);
                 auto vk = dispatch_VkDevice(device);
-                // End manual dispatchable handle unboxing for device;
                 vkReadStream->alloc((void**)&pWaitInfo, sizeof(const VkSemaphoreWaitInfo));
                 reservedunmarshal_VkSemaphoreWaitInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                       (VkSemaphoreWaitInfo*)(pWaitInfo),
@@ -11087,22 +11052,21 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 if (m_queueSubmitWithCommandsEnabled)
                     seqnoPtr->fetch_add(1, std::memory_order_seq_cst);
-                VkResult vkWaitSemaphores_VkResult_return = (VkResult)0;
-                vkWaitSemaphores_VkResult_return =
-                    vk->vkWaitSemaphores(unboxed_device, pWaitInfo, timeout);
+                VkResult vkWaitSemaphores_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkWaitSemaphores_VkResult_return = m_state->on_vkWaitSemaphores(
+                        &m_pool, snapshotApiCallInfo, device, pWaitInfo, timeout);
+                }
                 if ((vkWaitSemaphores_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkWaitSemaphores_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkWaitSemaphores_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkWaitSemaphores(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, vkWaitSemaphores_VkResult_return,
-                                                          device, pWaitInfo, timeout);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkWaitSemaphores(
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
+                        vkWaitSemaphores_VkResult_return, device, pWaitInfo, timeout);
                 }
                 vkReadStream->clearPool();
                 break;
@@ -11112,14 +11076,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                                       "VkDecoder vkSignalSemaphore");
                 VkDevice device;
                 const VkSemaphoreSignalInfo* pSignalInfo;
-                // Begin non wrapped dispatchable handle unboxing for device;
+                // Begin global wrapped dispatchable handle unboxing for device;
                 uint64_t cgen_var_0;
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
-                auto unboxed_device = unbox_VkDevice(device);
                 auto vk = dispatch_VkDevice(device);
-                // End manual dispatchable handle unboxing for device;
                 vkReadStream->alloc((void**)&pSignalInfo, sizeof(const VkSemaphoreSignalInfo));
                 reservedunmarshal_VkSemaphoreSignalInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                         (VkSemaphoreSignalInfo*)(pSignalInfo),
@@ -11132,21 +11094,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkSignalSemaphore 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)device, (unsigned long long)pSignalInfo);
                 }
-                VkResult vkSignalSemaphore_VkResult_return = (VkResult)0;
-                vkSignalSemaphore_VkResult_return =
-                    vk->vkSignalSemaphore(unboxed_device, pSignalInfo);
+                VkResult vkSignalSemaphore_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkSignalSemaphore_VkResult_return = m_state->on_vkSignalSemaphore(
+                        &m_pool, snapshotApiCallInfo, device, pSignalInfo);
+                }
                 if ((vkSignalSemaphore_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkSignalSemaphore_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkSignalSemaphore_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkSignalSemaphore(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkSignalSemaphore_VkResult_return, device, pSignalInfo);
                 }
                 vkReadStream->clearPool();
@@ -11181,18 +11142,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 VkDeviceAddress vkGetBufferDeviceAddress_VkDeviceAddress_return =
                     (VkDeviceAddress)0;
-                vkGetBufferDeviceAddress_VkDeviceAddress_return =
-                    vk->vkGetBufferDeviceAddress(unboxed_device, pInfo);
+                if (CC_LIKELY(vk)) {
+                    vkGetBufferDeviceAddress_VkDeviceAddress_return =
+                        vk->vkGetBufferDeviceAddress(unboxed_device, pInfo);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetBufferDeviceAddress_VkDeviceAddress_return,
                                 sizeof(VkDeviceAddress));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetBufferDeviceAddress(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetBufferDeviceAddress_VkDeviceAddress_return, device, pInfo);
                 }
                 vkReadStream->clearPool();
@@ -11227,17 +11187,16 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                 }
                 uint64_t vkGetBufferOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
-                vkGetBufferOpaqueCaptureAddress_uint64_t_return =
-                    vk->vkGetBufferOpaqueCaptureAddress(unboxed_device, pInfo);
+                if (CC_LIKELY(vk)) {
+                    vkGetBufferOpaqueCaptureAddress_uint64_t_return =
+                        vk->vkGetBufferOpaqueCaptureAddress(unboxed_device, pInfo);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetBufferOpaqueCaptureAddress_uint64_t_return, sizeof(uint64_t));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetBufferOpaqueCaptureAddress(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetBufferOpaqueCaptureAddress_uint64_t_return, device, pInfo);
                 }
                 vkReadStream->clearPool();
@@ -11274,18 +11233,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                 }
                 uint64_t vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
-                vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return =
-                    vk->vkGetDeviceMemoryOpaqueCaptureAddress(unboxed_device, pInfo);
+                if (CC_LIKELY(vk)) {
+                    vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return =
+                        vk->vkGetDeviceMemoryOpaqueCaptureAddress(unboxed_device, pInfo);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return,
                                 sizeof(uint64_t));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceMemoryOpaqueCaptureAddress(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return, device, pInfo);
                 }
                 vkReadStream->clearPool();
@@ -11352,10 +11310,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)physicalDevice,
                         (unsigned long long)pToolCount, (unsigned long long)pToolProperties);
                 }
-                VkResult vkGetPhysicalDeviceToolProperties_VkResult_return = (VkResult)0;
-                vkGetPhysicalDeviceToolProperties_VkResult_return =
-                    vk->vkGetPhysicalDeviceToolProperties(unboxed_physicalDevice, pToolCount,
-                                                          pToolProperties);
+                VkResult vkGetPhysicalDeviceToolProperties_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPhysicalDeviceToolProperties_VkResult_return =
+                        vk->vkGetPhysicalDeviceToolProperties(unboxed_physicalDevice, pToolCount,
+                                                              pToolProperties);
+                }
                 if ((vkGetPhysicalDeviceToolProperties_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetPhysicalDeviceToolProperties_VkResult_return,
@@ -11390,12 +11351,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetPhysicalDeviceToolProperties_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceToolProperties(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPhysicalDeviceToolProperties_VkResult_return, physicalDevice,
                         pToolCount, pToolProperties);
                 }
@@ -11457,9 +11415,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                         (unsigned long long)pAllocator, (unsigned long long)pPrivateDataSlot);
                 }
-                VkResult vkCreatePrivateDataSlot_VkResult_return = (VkResult)0;
-                vkCreatePrivateDataSlot_VkResult_return = vk->vkCreatePrivateDataSlot(
-                    unboxed_device, pCreateInfo, pAllocator, pPrivateDataSlot);
+                VkResult vkCreatePrivateDataSlot_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreatePrivateDataSlot_VkResult_return = vk->vkCreatePrivateDataSlot(
+                        unboxed_device, pCreateInfo, pAllocator, pPrivateDataSlot);
+                }
                 if ((vkCreatePrivateDataSlot_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreatePrivateDataSlot_VkResult_return, opcode,
@@ -11478,12 +11438,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreatePrivateDataSlot_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreatePrivateDataSlot(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreatePrivateDataSlot_VkResult_return, device, pCreateInfo, pAllocator,
                         pPrivateDataSlot);
                 }
@@ -11535,14 +11492,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)privateDataSlot, (unsigned long long)pAllocator);
                 }
-                vk->vkDestroyPrivateDataSlot(unboxed_device, privateDataSlot, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    vk->vkDestroyPrivateDataSlot(unboxed_device, privateDataSlot, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyPrivateDataSlot(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_privateDataSlot_preserve, pAllocator);
                 }
                 delete_VkPrivateDataSlot(boxed_privateDataSlot_preserve);
@@ -11586,23 +11542,22 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)objectHandle, (unsigned long long)privateDataSlot,
                         (unsigned long long)data);
                 }
-                VkResult vkSetPrivateData_VkResult_return = (VkResult)0;
-                vkSetPrivateData_VkResult_return = vk->vkSetPrivateData(
-                    unboxed_device, objectType, objectHandle, privateDataSlot, data);
+                VkResult vkSetPrivateData_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkSetPrivateData_VkResult_return = vk->vkSetPrivateData(
+                        unboxed_device, objectType, objectHandle, privateDataSlot, data);
+                }
                 if ((vkSetPrivateData_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkSetPrivateData_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkSetPrivateData_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkSetPrivateData(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, vkSetPrivateData_VkResult_return,
-                                                          device, objectType, objectHandle,
-                                                          privateDataSlot, data);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkSetPrivateData(
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
+                        vkSetPrivateData_VkResult_return, device, objectType, objectHandle,
+                        privateDataSlot, data);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -11647,18 +11602,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)objectHandle, (unsigned long long)privateDataSlot,
                         (unsigned long long)pData);
                 }
-                vk->vkGetPrivateData(unboxed_device, objectType, objectHandle, privateDataSlot,
-                                     pData);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPrivateData(unboxed_device, objectType, objectHandle, privateDataSlot,
+                                         pData);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write((uint64_t*)pData, sizeof(uint64_t));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetPrivateData(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, device, objectType, objectHandle,
-                                                          privateDataSlot, pData);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetPrivateData(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, device, objectType,
+                                                          objectHandle, privateDataSlot, pData);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -11696,14 +11650,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)event,
                             (unsigned long long)pDependencyInfo);
                 }
-                vk->vkCmdSetEvent2(unboxed_commandBuffer, event, pDependencyInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetEvent2(unboxed_commandBuffer, event, pDependencyInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetEvent2(snapshotTraceBegin, snapshotTraceBytes,
-                                                        &m_pool, commandBuffer, event,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetEvent2(&m_pool, snapshotApiCallInfo, packet,
+                                                        packetLen, commandBuffer, event,
                                                         pDependencyInfo);
                 }
                 vkReadStream->clearPool();
@@ -11738,14 +11691,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)event,
                             (unsigned long long)stageMask);
                 }
-                vk->vkCmdResetEvent2(unboxed_commandBuffer, event, stageMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResetEvent2(unboxed_commandBuffer, event, stageMask);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdResetEvent2(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, commandBuffer, event, stageMask);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdResetEvent2(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, commandBuffer, event,
+                                                          stageMask);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -11800,14 +11753,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)commandBuffer, (unsigned long long)eventCount,
                         (unsigned long long)pEvents, (unsigned long long)pDependencyInfos);
                 }
-                vk->vkCmdWaitEvents2(unboxed_commandBuffer, eventCount, pEvents, pDependencyInfos);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWaitEvents2(unboxed_commandBuffer, eventCount, pEvents,
+                                         pDependencyInfos);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdWaitEvents2(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, commandBuffer, eventCount,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdWaitEvents2(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, commandBuffer, eventCount,
                                                           pEvents, pDependencyInfos);
                 }
                 vkReadStream->clearPool();
@@ -11826,6 +11779,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pDependencyInfo, sizeof(const VkDependencyInfo));
                 reservedunmarshal_VkDependencyInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                    (VkDependencyInfo*)(pDependencyInfo),
@@ -11839,15 +11793,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pDependencyInfo);
                 }
-                m_state->on_vkCmdPipelineBarrier2(&m_pool, commandBuffer, pDependencyInfo);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdPipelineBarrier2(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                      pDependencyInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdPipelineBarrier2(snapshotTraceBegin,
-                                                               snapshotTraceBytes, &m_pool,
-                                                               commandBuffer, pDependencyInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdPipelineBarrier2(&m_pool, snapshotApiCallInfo, packet,
+                                                               packetLen, commandBuffer,
+                                                               pDependencyInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -11886,15 +11840,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)stage,
                             (unsigned long long)queryPool, (unsigned long long)query);
                 }
-                vk->vkCmdWriteTimestamp2(unboxed_commandBuffer, stage, queryPool, query);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWriteTimestamp2(unboxed_commandBuffer, stage, queryPool, query);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdWriteTimestamp2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, stage,
-                        queryPool, query);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdWriteTimestamp2(&m_pool, snapshotApiCallInfo, packet,
+                                                              packetLen, commandBuffer, stage,
+                                                              queryPool, query);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -11912,6 +11865,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&submitCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pSubmits,
@@ -11935,21 +11889,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)queue, (unsigned long long)submitCount,
                             (unsigned long long)pSubmits, (unsigned long long)fence);
                 }
-                VkResult vkQueueSubmit2_VkResult_return = (VkResult)0;
-                vkQueueSubmit2_VkResult_return =
-                    m_state->on_vkQueueSubmit2(&m_pool, queue, submitCount, pSubmits, fence);
+                VkResult vkQueueSubmit2_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkQueueSubmit2_VkResult_return = m_state->on_vkQueueSubmit2(
+                        &m_pool, snapshotApiCallInfo, queue, submitCount, pSubmits, fence);
+                }
                 if ((vkQueueSubmit2_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkQueueSubmit2_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkQueueSubmit2_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkQueueSubmit2(snapshotTraceBegin, snapshotTraceBytes,
-                                                        &m_pool, vkQueueSubmit2_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkQueueSubmit2(&m_pool, snapshotApiCallInfo, packet,
+                                                        packetLen, vkQueueSubmit2_VkResult_return,
                                                         queue, submitCount, pSubmits, fence);
                 }
                 vkReadStream->clearPool();
@@ -11983,14 +11936,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdCopyBuffer2 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)pCopyBufferInfo);
                 }
-                vk->vkCmdCopyBuffer2(unboxed_commandBuffer, pCopyBufferInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdCopyBuffer2(unboxed_commandBuffer, pCopyBufferInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdCopyBuffer2(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, commandBuffer, pCopyBufferInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdCopyBuffer2(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, commandBuffer,
+                                                          pCopyBufferInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12008,6 +11961,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pCopyImageInfo, sizeof(const VkCopyImageInfo2));
                 reservedunmarshal_VkCopyImageInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                    (VkCopyImageInfo2*)(pCopyImageInfo),
@@ -12019,14 +11973,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdCopyImage2 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)pCopyImageInfo);
                 }
-                m_state->on_vkCmdCopyImage2(&m_pool, commandBuffer, pCopyImageInfo);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdCopyImage2(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                pCopyImageInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdCopyImage2(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, commandBuffer, pCopyImageInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdCopyImage2(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, commandBuffer, pCopyImageInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12044,6 +11998,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pCopyBufferToImageInfo,
                                     sizeof(const VkCopyBufferToImageInfo2));
                 reservedunmarshal_VkCopyBufferToImageInfo2(
@@ -12058,16 +12013,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pCopyBufferToImageInfo);
                 }
-                m_state->on_vkCmdCopyBufferToImage2(&m_pool, commandBuffer, pCopyBufferToImageInfo,
-                                                    context);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdCopyBufferToImage2(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                        pCopyBufferToImageInfo, context);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdCopyBufferToImage2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        pCopyBufferToImageInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdCopyBufferToImage2(&m_pool, snapshotApiCallInfo,
+                                                                 packet, packetLen, commandBuffer,
+                                                                 pCopyBufferToImageInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12085,6 +12039,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pCopyImageToBufferInfo,
                                     sizeof(const VkCopyImageToBufferInfo2));
                 reservedunmarshal_VkCopyImageToBufferInfo2(
@@ -12099,15 +12054,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pCopyImageToBufferInfo);
                 }
-                m_state->on_vkCmdCopyImageToBuffer2(&m_pool, commandBuffer, pCopyImageToBufferInfo);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdCopyImageToBuffer2(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                        pCopyImageToBufferInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdCopyImageToBuffer2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        pCopyImageToBufferInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdCopyImageToBuffer2(&m_pool, snapshotApiCallInfo,
+                                                                 packet, packetLen, commandBuffer,
+                                                                 pCopyImageToBufferInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12139,14 +12094,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdBlitImage2 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)pBlitImageInfo);
                 }
-                vk->vkCmdBlitImage2(unboxed_commandBuffer, pBlitImageInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBlitImage2(unboxed_commandBuffer, pBlitImageInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBlitImage2(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, commandBuffer, pBlitImageInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBlitImage2(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, commandBuffer, pBlitImageInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12180,14 +12134,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)commandBuffer,
                             (unsigned long long)pResolveImageInfo);
                 }
-                vk->vkCmdResolveImage2(unboxed_commandBuffer, pResolveImageInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResolveImage2(unboxed_commandBuffer, pResolveImageInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdResolveImage2(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, commandBuffer,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdResolveImage2(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, commandBuffer,
                                                             pResolveImageInfo);
                 }
                 vkReadStream->clearPool();
@@ -12221,14 +12174,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pRenderingInfo);
                 }
-                vk->vkCmdBeginRendering(unboxed_commandBuffer, pRenderingInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginRendering(unboxed_commandBuffer, pRenderingInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBeginRendering(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, commandBuffer,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBeginRendering(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, commandBuffer,
                                                              pRenderingInfo);
                 }
                 vkReadStream->clearPool();
@@ -12253,14 +12205,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdEndRendering 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer);
                 }
-                vk->vkCmdEndRendering(unboxed_commandBuffer);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRendering(unboxed_commandBuffer);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdEndRendering(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, commandBuffer);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdEndRendering(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, commandBuffer);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12287,14 +12238,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdSetCullMode 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)cullMode);
                 }
-                vk->vkCmdSetCullMode(unboxed_commandBuffer, cullMode);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetCullMode(unboxed_commandBuffer, cullMode);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetCullMode(snapshotTraceBegin, snapshotTraceBytes,
-                                                          &m_pool, commandBuffer, cullMode);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetCullMode(&m_pool, snapshotApiCallInfo, packet,
+                                                          packetLen, commandBuffer, cullMode);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12321,14 +12271,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdSetFrontFace 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)frontFace);
                 }
-                vk->vkCmdSetFrontFace(unboxed_commandBuffer, frontFace);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetFrontFace(unboxed_commandBuffer, frontFace);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetFrontFace(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, commandBuffer, frontFace);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetFrontFace(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, commandBuffer, frontFace);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12357,15 +12306,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)primitiveTopology);
                 }
-                vk->vkCmdSetPrimitiveTopology(unboxed_commandBuffer, primitiveTopology);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPrimitiveTopology(unboxed_commandBuffer, primitiveTopology);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetPrimitiveTopology(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        primitiveTopology);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetPrimitiveTopology(&m_pool, snapshotApiCallInfo,
+                                                                   packet, packetLen, commandBuffer,
+                                                                   primitiveTopology);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12406,15 +12354,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)viewportCount, (unsigned long long)pViewports);
                 }
-                vk->vkCmdSetViewportWithCount(unboxed_commandBuffer, viewportCount, pViewports);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetViewportWithCount(unboxed_commandBuffer, viewportCount, pViewports);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetViewportWithCount(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        viewportCount, pViewports);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetViewportWithCount(&m_pool, snapshotApiCallInfo,
+                                                                   packet, packetLen, commandBuffer,
+                                                                   viewportCount, pViewports);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12454,15 +12401,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)scissorCount, (unsigned long long)pScissors);
                 }
-                vk->vkCmdSetScissorWithCount(unboxed_commandBuffer, scissorCount, pScissors);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetScissorWithCount(unboxed_commandBuffer, scissorCount, pScissors);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetScissorWithCount(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        scissorCount, pScissors);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetScissorWithCount(&m_pool, snapshotApiCallInfo,
+                                                                  packet, packetLen, commandBuffer,
+                                                                  scissorCount, pScissors);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12547,15 +12493,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pBuffers, (unsigned long long)pOffsets,
                             (unsigned long long)pSizes, (unsigned long long)pStrides);
                 }
-                vk->vkCmdBindVertexBuffers2(unboxed_commandBuffer, firstBinding, bindingCount,
-                                            pBuffers, pOffsets, pSizes, pStrides);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindVertexBuffers2(unboxed_commandBuffer, firstBinding, bindingCount,
+                                                pBuffers, pOffsets, pSizes, pStrides);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdBindVertexBuffers2(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
                 }
                 vkReadStream->clearPool();
@@ -12584,15 +12529,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthTestEnable);
                 }
-                vk->vkCmdSetDepthTestEnable(unboxed_commandBuffer, depthTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthTestEnable(unboxed_commandBuffer, depthTestEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetDepthTestEnable(snapshotTraceBegin,
-                                                                 snapshotTraceBytes, &m_pool,
-                                                                 commandBuffer, depthTestEnable);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetDepthTestEnable(&m_pool, snapshotApiCallInfo,
+                                                                 packet, packetLen, commandBuffer,
+                                                                 depthTestEnable);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12620,15 +12564,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthWriteEnable);
                 }
-                vk->vkCmdSetDepthWriteEnable(unboxed_commandBuffer, depthWriteEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthWriteEnable(unboxed_commandBuffer, depthWriteEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetDepthWriteEnable(snapshotTraceBegin,
-                                                                  snapshotTraceBytes, &m_pool,
-                                                                  commandBuffer, depthWriteEnable);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetDepthWriteEnable(&m_pool, snapshotApiCallInfo,
+                                                                  packet, packetLen, commandBuffer,
+                                                                  depthWriteEnable);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12656,15 +12599,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthCompareOp);
                 }
-                vk->vkCmdSetDepthCompareOp(unboxed_commandBuffer, depthCompareOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthCompareOp(unboxed_commandBuffer, depthCompareOp);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetDepthCompareOp(snapshotTraceBegin,
-                                                                snapshotTraceBytes, &m_pool,
-                                                                commandBuffer, depthCompareOp);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetDepthCompareOp(&m_pool, snapshotApiCallInfo,
+                                                                packet, packetLen, commandBuffer,
+                                                                depthCompareOp);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12693,14 +12635,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthBoundsTestEnable);
                 }
-                vk->vkCmdSetDepthBoundsTestEnable(unboxed_commandBuffer, depthBoundsTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBoundsTestEnable(unboxed_commandBuffer, depthBoundsTestEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetDepthBoundsTestEnable(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         depthBoundsTestEnable);
                 }
                 vkReadStream->clearPool();
@@ -12729,15 +12670,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)stencilTestEnable);
                 }
-                vk->vkCmdSetStencilTestEnable(unboxed_commandBuffer, stencilTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilTestEnable(unboxed_commandBuffer, stencilTestEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetStencilTestEnable(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        stencilTestEnable);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetStencilTestEnable(&m_pool, snapshotApiCallInfo,
+                                                                   packet, packetLen, commandBuffer,
+                                                                   stencilTestEnable);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12782,16 +12722,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)passOp, (unsigned long long)depthFailOp,
                             (unsigned long long)compareOp);
                 }
-                vk->vkCmdSetStencilOp(unboxed_commandBuffer, faceMask, failOp, passOp, depthFailOp,
-                                      compareOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilOp(unboxed_commandBuffer, faceMask, failOp, passOp,
+                                          depthFailOp, compareOp);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetStencilOp(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, commandBuffer, faceMask, failOp,
-                                                           passOp, depthFailOp, compareOp);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetStencilOp(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, commandBuffer, faceMask,
+                                                           failOp, passOp, depthFailOp, compareOp);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12820,14 +12759,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)rasterizerDiscardEnable);
                 }
-                vk->vkCmdSetRasterizerDiscardEnable(unboxed_commandBuffer, rasterizerDiscardEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetRasterizerDiscardEnable(unboxed_commandBuffer,
+                                                        rasterizerDiscardEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetRasterizerDiscardEnable(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         rasterizerDiscardEnable);
                 }
                 vkReadStream->clearPool();
@@ -12856,15 +12795,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthBiasEnable);
                 }
-                vk->vkCmdSetDepthBiasEnable(unboxed_commandBuffer, depthBiasEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBiasEnable(unboxed_commandBuffer, depthBiasEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetDepthBiasEnable(snapshotTraceBegin,
-                                                                 snapshotTraceBytes, &m_pool,
-                                                                 commandBuffer, depthBiasEnable);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetDepthBiasEnable(&m_pool, snapshotApiCallInfo,
+                                                                 packet, packetLen, commandBuffer,
+                                                                 depthBiasEnable);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -12893,14 +12831,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)primitiveRestartEnable);
                 }
-                vk->vkCmdSetPrimitiveRestartEnable(unboxed_commandBuffer, primitiveRestartEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPrimitiveRestartEnable(unboxed_commandBuffer,
+                                                       primitiveRestartEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetPrimitiveRestartEnable(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         primitiveRestartEnable);
                 }
                 vkReadStream->clearPool();
@@ -12947,7 +12885,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pInfo,
                             (unsigned long long)pMemoryRequirements);
                 }
-                vk->vkGetDeviceBufferMemoryRequirements(unboxed_device, pInfo, pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDeviceBufferMemoryRequirements(unboxed_device, pInfo,
+                                                            pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements2(
@@ -12956,12 +12897,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkMemoryRequirements2*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceBufferMemoryRequirements(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -13008,7 +12946,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pInfo,
                             (unsigned long long)pMemoryRequirements);
                 }
-                vk->vkGetDeviceImageMemoryRequirements(unboxed_device, pInfo, pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDeviceImageMemoryRequirements(unboxed_device, pInfo,
+                                                           pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements2(
@@ -13017,12 +12958,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkMemoryRequirements2*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceImageMemoryRequirements(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -13101,9 +13039,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pSparseMemoryRequirementCount,
                             (unsigned long long)pSparseMemoryRequirements);
                 }
-                vk->vkGetDeviceImageSparseMemoryRequirements(unboxed_device, pInfo,
-                                                             pSparseMemoryRequirementCount,
-                                                             pSparseMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDeviceImageSparseMemoryRequirements(unboxed_device, pInfo,
+                                                                 pSparseMemoryRequirementCount,
+                                                                 pSparseMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
@@ -13135,12 +13075,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceImageSparseMemoryRequirements(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -13201,9 +13138,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pSwapchain);
                 }
-                VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
-                vkCreateSwapchainKHR_VkResult_return =
-                    vk->vkCreateSwapchainKHR(unboxed_device, pCreateInfo, pAllocator, pSwapchain);
+                VkResult vkCreateSwapchainKHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateSwapchainKHR_VkResult_return = vk->vkCreateSwapchainKHR(
+                        unboxed_device, pCreateInfo, pAllocator, pSwapchain);
+                }
                 if ((vkCreateSwapchainKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateSwapchainKHR_VkResult_return, opcode, context);
@@ -13221,12 +13160,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateSwapchainKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateSwapchainKHR_VkResult_return, device, pCreateInfo, pAllocator,
                         pSwapchain);
                 }
@@ -13277,14 +13213,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)swapchain,
                             (unsigned long long)pAllocator);
                 }
-                vk->vkDestroySwapchainKHR(unboxed_device, swapchain, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    vk->vkDestroySwapchainKHR(unboxed_device, swapchain, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroySwapchainKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_swapchain_preserve, pAllocator);
                 }
                 delete_VkSwapchainKHR(boxed_swapchain_preserve);
@@ -13354,9 +13289,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)pSwapchainImageCount,
                         (unsigned long long)pSwapchainImages);
                 }
-                VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
-                vkGetSwapchainImagesKHR_VkResult_return = vk->vkGetSwapchainImagesKHR(
-                    unboxed_device, swapchain, pSwapchainImageCount, pSwapchainImages);
+                VkResult vkGetSwapchainImagesKHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetSwapchainImagesKHR_VkResult_return = vk->vkGetSwapchainImagesKHR(
+                        unboxed_device, swapchain, pSwapchainImageCount, pSwapchainImages);
+                }
                 if ((vkGetSwapchainImagesKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetSwapchainImagesKHR_VkResult_return, opcode,
@@ -13382,12 +13319,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 vkStream->write(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetSwapchainImagesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetSwapchainImagesKHR_VkResult_return, device, swapchain,
                         pSwapchainImageCount, pSwapchainImages);
                 }
@@ -13442,9 +13376,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)timeout, (unsigned long long)semaphore,
                             (unsigned long long)fence, (unsigned long long)pImageIndex);
                 }
-                VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
-                vkAcquireNextImageKHR_VkResult_return = vk->vkAcquireNextImageKHR(
-                    unboxed_device, swapchain, timeout, semaphore, fence, pImageIndex);
+                VkResult vkAcquireNextImageKHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkAcquireNextImageKHR_VkResult_return = vk->vkAcquireNextImageKHR(
+                        unboxed_device, swapchain, timeout, semaphore, fence, pImageIndex);
+                }
                 if ((vkAcquireNextImageKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkAcquireNextImageKHR_VkResult_return, opcode,
@@ -13453,12 +13389,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                 vkStream->write(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkAcquireNextImageKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkAcquireNextImageKHR_VkResult_return, device, swapchain, timeout,
                         semaphore, fence, pImageIndex);
                 }
@@ -13477,6 +13410,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 vkReadStream->alloc((void**)&pPresentInfo, sizeof(const VkPresentInfoKHR));
                 reservedunmarshal_VkPresentInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                    (VkPresentInfoKHR*)(pPresentInfo),
@@ -13488,21 +13422,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkQueuePresentKHR 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)queue, (unsigned long long)pPresentInfo);
                 }
-                VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
-                vkQueuePresentKHR_VkResult_return =
-                    m_state->on_vkQueuePresentKHR(&m_pool, queue, pPresentInfo);
+                VkResult vkQueuePresentKHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkQueuePresentKHR_VkResult_return = m_state->on_vkQueuePresentKHR(
+                        &m_pool, snapshotApiCallInfo, queue, pPresentInfo);
+                }
                 if ((vkQueuePresentKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkQueuePresentKHR_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueuePresentKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkQueuePresentKHR_VkResult_return, queue, pPresentInfo);
                 }
                 vkReadStream->clearPool();
@@ -13543,10 +13476,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device,
                         (unsigned long long)pDeviceGroupPresentCapabilities);
                 }
-                VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
-                vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return =
-                    vk->vkGetDeviceGroupPresentCapabilitiesKHR(unboxed_device,
-                                                               pDeviceGroupPresentCapabilities);
+                VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return =
+                        vk->vkGetDeviceGroupPresentCapabilitiesKHR(unboxed_device,
+                                                                   pDeviceGroupPresentCapabilities);
+                }
                 if ((vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -13564,12 +13500,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceGroupPresentCapabilitiesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, device,
                         pDeviceGroupPresentCapabilities);
                 }
@@ -13616,9 +13549,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)surface,
                             (unsigned long long)pModes);
                 }
-                VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
-                vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return =
-                    vk->vkGetDeviceGroupSurfacePresentModesKHR(unboxed_device, surface, pModes);
+                VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return =
+                        vk->vkGetDeviceGroupSurfacePresentModesKHR(unboxed_device, surface, pModes);
+                }
                 if ((vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -13635,12 +13571,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceGroupSurfacePresentModesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, device, surface,
                         pModes);
                 }
@@ -13709,10 +13642,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)surface, (unsigned long long)pRectCount,
                             (unsigned long long)pRects);
                 }
-                VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
-                vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return =
-                    vk->vkGetPhysicalDevicePresentRectanglesKHR(unboxed_physicalDevice, surface,
-                                                                pRectCount, pRects);
+                VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return =
+                        vk->vkGetPhysicalDevicePresentRectanglesKHR(unboxed_physicalDevice, surface,
+                                                                    pRectCount, pRects);
+                }
                 if ((vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -13746,12 +13682,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDevicePresentRectanglesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, physicalDevice,
                         surface, pRectCount, pRects);
                 }
@@ -13793,9 +13726,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pAcquireInfo,
                             (unsigned long long)pImageIndex);
                 }
-                VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
-                vkAcquireNextImage2KHR_VkResult_return =
-                    vk->vkAcquireNextImage2KHR(unboxed_device, pAcquireInfo, pImageIndex);
+                VkResult vkAcquireNextImage2KHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkAcquireNextImage2KHR_VkResult_return =
+                        vk->vkAcquireNextImage2KHR(unboxed_device, pAcquireInfo, pImageIndex);
+                }
                 if ((vkAcquireNextImage2KHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkAcquireNextImage2KHR_VkResult_return, opcode,
@@ -13804,12 +13739,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                 vkStream->write(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkAcquireNextImage2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkAcquireNextImage2KHR_VkResult_return, device, pAcquireInfo, pImageIndex);
                 }
                 vkReadStream->clearPool();
@@ -13845,15 +13777,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pRenderingInfo);
                 }
-                vk->vkCmdBeginRenderingKHR(unboxed_commandBuffer, pRenderingInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginRenderingKHR(unboxed_commandBuffer, pRenderingInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBeginRenderingKHR(snapshotTraceBegin,
-                                                                snapshotTraceBytes, &m_pool,
-                                                                commandBuffer, pRenderingInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBeginRenderingKHR(&m_pool, snapshotApiCallInfo,
+                                                                packet, packetLen, commandBuffer,
+                                                                pRenderingInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -13877,14 +13808,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdEndRenderingKHR 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer);
                 }
-                vk->vkCmdEndRenderingKHR(unboxed_commandBuffer);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRenderingKHR(unboxed_commandBuffer);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdEndRenderingKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdEndRenderingKHR(&m_pool, snapshotApiCallInfo, packet,
+                                                              packetLen, commandBuffer);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -13904,6 +13834,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pFeatures;
                 vkReadStream->unsetHandleMapping();
                 vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
@@ -13920,7 +13851,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)pFeatures);
                 }
-                m_state->on_vkGetPhysicalDeviceFeatures2KHR(&m_pool, physicalDevice, pFeatures);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceFeatures2KHR(&m_pool, snapshotApiCallInfo,
+                                                                physicalDevice, pFeatures);
+                }
                 vkStream->unsetHandleMapping();
                 if (pFeatures) {
                     transform_fromhost_VkPhysicalDeviceFeatures2(
@@ -13929,12 +13863,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkPhysicalDeviceFeatures2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkPhysicalDeviceFeatures2*)(pFeatures));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceFeatures2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice, pFeatures);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -13952,6 +13883,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pProperties;
                 vkReadStream->unsetHandleMapping();
                 vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
@@ -13968,7 +13900,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)pProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceProperties2KHR(&m_pool, physicalDevice, pProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceProperties2KHR(&m_pool, snapshotApiCallInfo,
+                                                                  physicalDevice, pProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pProperties) {
                     transform_fromhost_VkPhysicalDeviceProperties2(
@@ -13977,12 +13912,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkPhysicalDeviceProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkPhysicalDeviceProperties2*)(pProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceProperties2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pProperties);
                 }
                 vkReadStream->clearPool();
@@ -14002,6 +13934,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                 *readStreamPtrPtr += sizeof(VkFormat);
                 // Begin manual dispatchable handle unboxing for pFormatProperties;
@@ -14021,8 +13954,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)format, (unsigned long long)pFormatProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceFormatProperties2KHR(&m_pool, physicalDevice, format,
-                                                                    pFormatProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceFormatProperties2KHR(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, format, pFormatProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pFormatProperties) {
                     transform_fromhost_VkFormatProperties2(
@@ -14031,12 +13966,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkFormatProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                             (VkFormatProperties2*)(pFormatProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice, format,
                         pFormatProperties);
                 }
                 vkReadStream->clearPool();
@@ -14056,6 +13988,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 vkReadStream->alloc((void**)&pImageFormatInfo,
                                     sizeof(const VkPhysicalDeviceImageFormatInfo2));
                 reservedunmarshal_VkPhysicalDeviceImageFormatInfo2(
@@ -14084,10 +14017,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pImageFormatInfo,
                             (unsigned long long)pImageFormatProperties);
                 }
-                VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
-                vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return =
-                    m_state->on_vkGetPhysicalDeviceImageFormatProperties2KHR(
-                        &m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
+                VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return =
+                        m_state->on_vkGetPhysicalDeviceImageFormatProperties2KHR(
+                            &m_pool, snapshotApiCallInfo, physicalDevice, pImageFormatInfo,
+                            pImageFormatProperties);
+                }
                 if ((vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -14104,12 +14041,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return,
                         physicalDevice, pImageFormatInfo, pImageFormatProperties);
                 }
@@ -14178,8 +14112,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pQueueFamilyPropertyCount,
                             (unsigned long long)pQueueFamilyProperties);
                 }
-                vk->vkGetPhysicalDeviceQueueFamilyProperties2KHR(
-                    unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPhysicalDeviceQueueFamilyProperties2KHR(
+                        unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
@@ -14208,12 +14144,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pQueueFamilyPropertyCount, pQueueFamilyProperties);
                 }
                 vkReadStream->clearPool();
@@ -14232,6 +14165,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 // Begin manual dispatchable handle unboxing for pMemoryProperties;
                 vkReadStream->unsetHandleMapping();
                 vkReadStream->alloc((void**)&pMemoryProperties,
@@ -14250,8 +14184,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)physicalDevice,
                         (unsigned long long)pMemoryProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceMemoryProperties2KHR(&m_pool, physicalDevice,
-                                                                    pMemoryProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceMemoryProperties2KHR(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, pMemoryProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryProperties) {
                     transform_fromhost_VkPhysicalDeviceMemoryProperties2(
@@ -14261,12 +14197,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                     (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pMemoryProperties);
                 }
                 vkReadStream->clearPool();
@@ -14343,8 +14276,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pFormatInfo, (unsigned long long)pPropertyCount,
                             (unsigned long long)pProperties);
                 }
-                vk->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
-                    unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
+                        unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
@@ -14373,12 +14308,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pFormatInfo, pPropertyCount, pProperties);
                 }
                 vkReadStream->clearPool();
@@ -14415,15 +14347,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)commandPool,
                             (unsigned long long)flags);
                 }
-                vk->vkTrimCommandPoolKHR(unboxed_device, commandPool, flags);
+                if (CC_LIKELY(vk)) {
+                    vk->vkTrimCommandPoolKHR(unboxed_device, commandPool, flags);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkTrimCommandPoolKHR(snapshotTraceBegin,
-                                                              snapshotTraceBytes, &m_pool, device,
-                                                              commandPool, flags);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkTrimCommandPoolKHR(&m_pool, snapshotApiCallInfo, packet,
+                                                              packetLen, device, commandPool,
+                                                              flags);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -14479,8 +14410,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pExternalBufferInfo,
                             (unsigned long long)pExternalBufferProperties);
                 }
-                vk->vkGetPhysicalDeviceExternalBufferPropertiesKHR(
-                    unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPhysicalDeviceExternalBufferPropertiesKHR(
+                        unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pExternalBufferProperties) {
                     m_state->transformImpl_VkExternalBufferProperties_fromhost(
@@ -14492,12 +14425,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                     (VkExternalBufferProperties*)(pExternalBufferProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceExternalBufferPropertiesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pExternalBufferInfo, pExternalBufferProperties);
                 }
                 vkReadStream->clearPool();
@@ -14520,6 +14450,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPhysicalDevice*)&physicalDevice =
                     (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                 vkReadStream->alloc((void**)&pExternalSemaphoreInfo,
                                     sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                 reservedunmarshal_VkPhysicalDeviceExternalSemaphoreInfo(
@@ -14550,8 +14481,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pExternalSemaphoreInfo,
                             (unsigned long long)pExternalSemaphoreProperties);
                 }
-                m_state->on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
-                    &m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
+                        &m_pool, snapshotApiCallInfo, physicalDevice, pExternalSemaphoreInfo,
+                        pExternalSemaphoreProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pExternalSemaphoreProperties) {
                     transform_fromhost_VkExternalSemaphoreProperties(
@@ -14561,12 +14495,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                     (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                 }
                 vkReadStream->clearPool();
@@ -14586,6 +14517,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pImportSemaphoreFdInfo,
                                     sizeof(const VkImportSemaphoreFdInfoKHR));
                 reservedunmarshal_VkImportSemaphoreFdInfoKHR(
@@ -14600,9 +14532,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)pImportSemaphoreFdInfo);
                 }
-                VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
-                vkImportSemaphoreFdKHR_VkResult_return =
-                    m_state->on_vkImportSemaphoreFdKHR(&m_pool, device, pImportSemaphoreFdInfo);
+                VkResult vkImportSemaphoreFdKHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkImportSemaphoreFdKHR_VkResult_return = m_state->on_vkImportSemaphoreFdKHR(
+                        &m_pool, snapshotApiCallInfo, device, pImportSemaphoreFdInfo);
+                }
                 if ((vkImportSemaphoreFdKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkImportSemaphoreFdKHR_VkResult_return, opcode,
@@ -14610,12 +14544,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkImportSemaphoreFdKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkImportSemaphoreFdKHR_VkResult_return, device, pImportSemaphoreFdInfo);
                 }
                 vkReadStream->clearPool();
@@ -14634,6 +14565,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkSemaphoreGetFdInfoKHR));
                 reservedunmarshal_VkSemaphoreGetFdInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                           (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo),
@@ -14652,9 +14584,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo,
                             (unsigned long long)pFd);
                 }
-                VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
-                vkGetSemaphoreFdKHR_VkResult_return =
-                    m_state->on_vkGetSemaphoreFdKHR(&m_pool, device, pGetFdInfo, pFd);
+                VkResult vkGetSemaphoreFdKHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetSemaphoreFdKHR_VkResult_return = m_state->on_vkGetSemaphoreFdKHR(
+                        &m_pool, snapshotApiCallInfo, device, pGetFdInfo, pFd);
+                }
                 if ((vkGetSemaphoreFdKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetSemaphoreFdKHR_VkResult_return, opcode, context);
@@ -14662,12 +14596,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((int*)pFd, sizeof(int));
                 vkStream->write(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetSemaphoreFdKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetSemaphoreFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                 }
                 vkReadStream->clearPool();
@@ -14689,6 +14620,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo,
                                     sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                 reservedunmarshal_VkDescriptorUpdateTemplateCreateInfo(
@@ -14730,10 +14662,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pAllocator,
                             (unsigned long long)pDescriptorUpdateTemplate);
                 }
-                VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
-                vkCreateDescriptorUpdateTemplateKHR_VkResult_return =
-                    m_state->on_vkCreateDescriptorUpdateTemplateKHR(
-                        &m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
+                VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateDescriptorUpdateTemplateKHR_VkResult_return =
+                        m_state->on_vkCreateDescriptorUpdateTemplateKHR(
+                            &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator,
+                            pDescriptorUpdateTemplate);
+                }
                 if ((vkCreateDescriptorUpdateTemplateKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateDescriptorUpdateTemplateKHR_VkResult_return,
@@ -14753,12 +14689,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateDescriptorUpdateTemplateKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateDescriptorUpdateTemplateKHR_VkResult_return, device, pCreateInfo,
                         pAllocator, pDescriptorUpdateTemplate);
                 }
@@ -14778,6 +14711,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for
                 // descriptorUpdateTemplate;
                 VkDescriptorUpdateTemplate boxed_descriptorUpdateTemplate_preserve;
@@ -14812,15 +14746,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)descriptorUpdateTemplate,
                             (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroyDescriptorUpdateTemplateKHR(
-                    &m_pool, device, descriptorUpdateTemplate, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroyDescriptorUpdateTemplateKHR(
+                        &m_pool, snapshotApiCallInfo, device, descriptorUpdateTemplate, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyDescriptorUpdateTemplateKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_descriptorUpdateTemplate_preserve, pAllocator);
                 }
                 delete_VkDescriptorUpdateTemplate(boxed_descriptorUpdateTemplate_preserve);
@@ -14872,15 +14805,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)descriptorUpdateTemplate,
                             (unsigned long long)pData);
                 }
-                vk->vkUpdateDescriptorSetWithTemplateKHR(unboxed_device, descriptorSet,
-                                                         descriptorUpdateTemplate, pData);
+                if (CC_LIKELY(vk)) {
+                    vk->vkUpdateDescriptorSetWithTemplateKHR(unboxed_device, descriptorSet,
+                                                             descriptorUpdateTemplate, pData);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkUpdateDescriptorSetWithTemplateKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, descriptorSet,
                         descriptorUpdateTemplate, pData);
                 }
                 vkReadStream->clearPool();
@@ -14902,6 +14834,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2));
                 reservedunmarshal_VkRenderPassCreateInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                           (VkRenderPassCreateInfo2*)(pCreateInfo),
@@ -14938,9 +14871,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                 }
-                VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
-                vkCreateRenderPass2KHR_VkResult_return = m_state->on_vkCreateRenderPass2KHR(
-                    &m_pool, device, pCreateInfo, pAllocator, pRenderPass);
+                VkResult vkCreateRenderPass2KHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateRenderPass2KHR_VkResult_return = m_state->on_vkCreateRenderPass2KHR(
+                        &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pRenderPass);
+                }
                 if ((vkCreateRenderPass2KHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateRenderPass2KHR_VkResult_return, opcode,
@@ -14957,12 +14892,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateRenderPass2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateRenderPass2KHR_VkResult_return, device, pCreateInfo, pAllocator,
                         pRenderPass);
                 }
@@ -14983,6 +14915,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                 reservedunmarshal_VkRenderPassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                         (VkRenderPassBeginInfo*)(pRenderPassBegin),
@@ -15006,15 +14939,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pRenderPassBegin,
                             (unsigned long long)pSubpassBeginInfo);
                 }
-                m_state->on_vkCmdBeginRenderPass2KHR(&m_pool, commandBuffer, pRenderPassBegin,
-                                                     pSubpassBeginInfo);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdBeginRenderPass2KHR(&m_pool, snapshotApiCallInfo,
+                                                         commandBuffer, pRenderPassBegin,
+                                                         pSubpassBeginInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdBeginRenderPass2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         pRenderPassBegin, pSubpassBeginInfo);
                 }
                 vkReadStream->clearPool();
@@ -15059,15 +14992,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pSubpassBeginInfo,
                             (unsigned long long)pSubpassEndInfo);
                 }
-                vk->vkCmdNextSubpass2KHR(unboxed_commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdNextSubpass2KHR(unboxed_commandBuffer, pSubpassBeginInfo,
+                                             pSubpassEndInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdNextSubpass2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
-                        pSubpassBeginInfo, pSubpassEndInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdNextSubpass2KHR(&m_pool, snapshotApiCallInfo, packet,
+                                                              packetLen, commandBuffer,
+                                                              pSubpassBeginInfo, pSubpassEndInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -15101,15 +15034,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pSubpassEndInfo);
                 }
-                vk->vkCmdEndRenderPass2KHR(unboxed_commandBuffer, pSubpassEndInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRenderPass2KHR(unboxed_commandBuffer, pSubpassEndInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdEndRenderPass2KHR(snapshotTraceBegin,
-                                                                snapshotTraceBytes, &m_pool,
-                                                                commandBuffer, pSubpassEndInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdEndRenderPass2KHR(&m_pool, snapshotApiCallInfo,
+                                                                packet, packetLen, commandBuffer,
+                                                                pSubpassEndInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -15161,8 +15093,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pExternalFenceInfo,
                             (unsigned long long)pExternalFenceProperties);
                 }
-                vk->vkGetPhysicalDeviceExternalFencePropertiesKHR(
-                    unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPhysicalDeviceExternalFencePropertiesKHR(
+                        unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
+                }
                 vkStream->unsetHandleMapping();
                 if (pExternalFenceProperties) {
                     transform_fromhost_VkExternalFenceProperties(
@@ -15172,12 +15106,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                     (VkExternalFenceProperties*)(pExternalFenceProperties));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceExternalFencePropertiesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, physicalDevice,
                         pExternalFenceInfo, pExternalFenceProperties);
                 }
                 vkReadStream->clearPool();
@@ -15213,21 +15144,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkImportFenceFdKHR 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)device, (unsigned long long)pImportFenceFdInfo);
                 }
-                VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
-                vkImportFenceFdKHR_VkResult_return =
-                    vk->vkImportFenceFdKHR(unboxed_device, pImportFenceFdInfo);
+                VkResult vkImportFenceFdKHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkImportFenceFdKHR_VkResult_return =
+                        vk->vkImportFenceFdKHR(unboxed_device, pImportFenceFdInfo);
+                }
                 if ((vkImportFenceFdKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkImportFenceFdKHR_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkImportFenceFdKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkImportFenceFdKHR_VkResult_return, device, pImportFenceFdInfo);
                 }
                 vkReadStream->clearPool();
@@ -15267,9 +15197,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo,
                             (unsigned long long)pFd);
                 }
-                VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
-                vkGetFenceFdKHR_VkResult_return =
-                    vk->vkGetFenceFdKHR(unboxed_device, pGetFdInfo, pFd);
+                VkResult vkGetFenceFdKHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetFenceFdKHR_VkResult_return =
+                        vk->vkGetFenceFdKHR(unboxed_device, pGetFdInfo, pFd);
+                }
                 if ((vkGetFenceFdKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetFenceFdKHR_VkResult_return, opcode, context);
@@ -15277,12 +15209,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((int*)pFd, sizeof(int));
                 vkStream->write(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetFenceFdKHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, vkGetFenceFdKHR_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetFenceFdKHR(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, vkGetFenceFdKHR_VkResult_return,
                                                          device, pGetFdInfo, pFd);
                 }
                 vkReadStream->clearPool();
@@ -15303,6 +15232,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                 reservedunmarshal_VkImageMemoryRequirementsInfo2(
                     vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
@@ -15328,8 +15258,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)pInfo,
                         (unsigned long long)pMemoryRequirements);
                 }
-                m_state->on_vkGetImageMemoryRequirements2KHR(&m_pool, device, pInfo,
-                                                             pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetImageMemoryRequirements2KHR(
+                        &m_pool, snapshotApiCallInfo, device, pInfo, pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements2(
@@ -15338,12 +15270,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkMemoryRequirements2*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetImageMemoryRequirements2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -15362,6 +15291,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                 reservedunmarshal_VkBufferMemoryRequirementsInfo2(
                     vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
@@ -15387,8 +15317,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)pInfo,
                         (unsigned long long)pMemoryRequirements);
                 }
-                m_state->on_vkGetBufferMemoryRequirements2KHR(&m_pool, device, pInfo,
-                                                              pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetBufferMemoryRequirements2KHR(
+                        &m_pool, snapshotApiCallInfo, device, pInfo, pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements2(
@@ -15397,12 +15329,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkMemoryRequirements2*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetBufferMemoryRequirements2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -15482,9 +15411,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pSparseMemoryRequirementCount,
                             (unsigned long long)pSparseMemoryRequirements);
                 }
-                vk->vkGetImageSparseMemoryRequirements2KHR(unboxed_device, pInfo,
-                                                           pSparseMemoryRequirementCount,
-                                                           pSparseMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetImageSparseMemoryRequirements2KHR(unboxed_device, pInfo,
+                                                               pSparseMemoryRequirementCount,
+                                                               pSparseMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
@@ -15516,12 +15447,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetImageSparseMemoryRequirements2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -15543,6 +15471,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo,
                                     sizeof(const VkSamplerYcbcrConversionCreateInfo));
                 reservedunmarshal_VkSamplerYcbcrConversionCreateInfo(
@@ -15582,10 +15511,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pYcbcrConversion);
                 }
-                VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
-                vkCreateSamplerYcbcrConversionKHR_VkResult_return =
-                    m_state->on_vkCreateSamplerYcbcrConversionKHR(&m_pool, device, pCreateInfo,
-                                                                  pAllocator, pYcbcrConversion);
+                VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateSamplerYcbcrConversionKHR_VkResult_return =
+                        m_state->on_vkCreateSamplerYcbcrConversionKHR(&m_pool, snapshotApiCallInfo,
+                                                                      device, pCreateInfo,
+                                                                      pAllocator, pYcbcrConversion);
+                }
                 if ((vkCreateSamplerYcbcrConversionKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateSamplerYcbcrConversionKHR_VkResult_return,
@@ -15605,12 +15538,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkCreateSamplerYcbcrConversionKHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateSamplerYcbcrConversionKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateSamplerYcbcrConversionKHR_VkResult_return, device, pCreateInfo,
                         pAllocator, pYcbcrConversion);
                 }
@@ -15630,6 +15560,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                 VkSamplerYcbcrConversion boxed_ycbcrConversion_preserve;
                 uint64_t cgen_var_1;
@@ -15661,15 +15592,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)ycbcrConversion, (unsigned long long)pAllocator);
                 }
-                m_state->on_vkDestroySamplerYcbcrConversionKHR(&m_pool, device, ycbcrConversion,
-                                                               pAllocator);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkDestroySamplerYcbcrConversionKHR(
+                        &m_pool, snapshotApiCallInfo, device, ycbcrConversion, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroySamplerYcbcrConversionKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device,
                         boxed_ycbcrConversion_preserve, pAllocator);
                 }
                 delete_VkSamplerYcbcrConversion(boxed_ycbcrConversion_preserve);
@@ -15691,6 +15621,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pBindInfos,
@@ -15712,9 +15643,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount,
                             (unsigned long long)pBindInfos);
                 }
-                VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
-                vkBindBufferMemory2KHR_VkResult_return =
-                    m_state->on_vkBindBufferMemory2KHR(&m_pool, device, bindInfoCount, pBindInfos);
+                VkResult vkBindBufferMemory2KHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkBindBufferMemory2KHR_VkResult_return = m_state->on_vkBindBufferMemory2KHR(
+                        &m_pool, snapshotApiCallInfo, device, bindInfoCount, pBindInfos);
+                }
                 if ((vkBindBufferMemory2KHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkBindBufferMemory2KHR_VkResult_return, opcode,
@@ -15722,12 +15655,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkBindBufferMemory2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkBindBufferMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                 }
                 vkReadStream->clearPool();
@@ -15746,6 +15676,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pBindInfos,
@@ -15766,9 +15697,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount,
                             (unsigned long long)pBindInfos);
                 }
-                VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
-                vkBindImageMemory2KHR_VkResult_return =
-                    m_state->on_vkBindImageMemory2KHR(&m_pool, device, bindInfoCount, pBindInfos);
+                VkResult vkBindImageMemory2KHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkBindImageMemory2KHR_VkResult_return = m_state->on_vkBindImageMemory2KHR(
+                        &m_pool, snapshotApiCallInfo, device, bindInfoCount, pBindInfos);
+                }
                 if ((vkBindImageMemory2KHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkBindImageMemory2KHR_VkResult_return, opcode,
@@ -15776,12 +15709,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkBindImageMemory2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkBindImageMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                 }
                 vkReadStream->clearPool();
@@ -15831,7 +15761,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pSupport);
                 }
-                vk->vkGetDescriptorSetLayoutSupportKHR(unboxed_device, pCreateInfo, pSupport);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDescriptorSetLayoutSupportKHR(unboxed_device, pCreateInfo, pSupport);
+                }
                 vkStream->unsetHandleMapping();
                 if (pSupport) {
                     transform_fromhost_VkDescriptorSetLayoutSupport(
@@ -15840,12 +15772,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkDescriptorSetLayoutSupport(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkDescriptorSetLayoutSupport*)(pSupport));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDescriptorSetLayoutSupportKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pCreateInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pCreateInfo,
                         pSupport);
                 }
                 vkReadStream->clearPool();
@@ -15882,18 +15811,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 VkDeviceAddress vkGetBufferDeviceAddressKHR_VkDeviceAddress_return =
                     (VkDeviceAddress)0;
-                vkGetBufferDeviceAddressKHR_VkDeviceAddress_return =
-                    vk->vkGetBufferDeviceAddressKHR(unboxed_device, pInfo);
+                if (CC_LIKELY(vk)) {
+                    vkGetBufferDeviceAddressKHR_VkDeviceAddress_return =
+                        vk->vkGetBufferDeviceAddressKHR(unboxed_device, pInfo);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetBufferDeviceAddressKHR_VkDeviceAddress_return,
                                 sizeof(VkDeviceAddress));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetBufferDeviceAddressKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetBufferDeviceAddressKHR_VkDeviceAddress_return, device, pInfo);
                 }
                 vkReadStream->clearPool();
@@ -15928,18 +15856,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                 }
                 uint64_t vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
-                vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return =
-                    vk->vkGetBufferOpaqueCaptureAddressKHR(unboxed_device, pInfo);
+                if (CC_LIKELY(vk)) {
+                    vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return =
+                        vk->vkGetBufferOpaqueCaptureAddressKHR(unboxed_device, pInfo);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return,
                                 sizeof(uint64_t));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetBufferOpaqueCaptureAddressKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return, device, pInfo);
                 }
                 vkReadStream->clearPool();
@@ -15976,18 +15903,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                 }
                 uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
-                vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return =
-                    vk->vkGetDeviceMemoryOpaqueCaptureAddressKHR(unboxed_device, pInfo);
+                if (CC_LIKELY(vk)) {
+                    vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return =
+                        vk->vkGetDeviceMemoryOpaqueCaptureAddressKHR(unboxed_device, pInfo);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return,
                                 sizeof(uint64_t));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceMemoryOpaqueCaptureAddressKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return, device, pInfo);
                 }
                 vkReadStream->clearPool();
@@ -16063,10 +15989,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pPipelineInfo,
                             (unsigned long long)pExecutableCount, (unsigned long long)pProperties);
                 }
-                VkResult vkGetPipelineExecutablePropertiesKHR_VkResult_return = (VkResult)0;
-                vkGetPipelineExecutablePropertiesKHR_VkResult_return =
-                    vk->vkGetPipelineExecutablePropertiesKHR(unboxed_device, pPipelineInfo,
-                                                             pExecutableCount, pProperties);
+                VkResult vkGetPipelineExecutablePropertiesKHR_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPipelineExecutablePropertiesKHR_VkResult_return =
+                        vk->vkGetPipelineExecutablePropertiesKHR(unboxed_device, pPipelineInfo,
+                                                                 pExecutableCount, pProperties);
+                }
                 if ((vkGetPipelineExecutablePropertiesKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetPipelineExecutablePropertiesKHR_VkResult_return,
@@ -16101,12 +16030,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetPipelineExecutablePropertiesKHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPipelineExecutablePropertiesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPipelineExecutablePropertiesKHR_VkResult_return, device, pPipelineInfo,
                         pExecutableCount, pProperties);
                 }
@@ -16182,10 +16108,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pExecutableInfo,
                             (unsigned long long)pStatisticCount, (unsigned long long)pStatistics);
                 }
-                VkResult vkGetPipelineExecutableStatisticsKHR_VkResult_return = (VkResult)0;
-                vkGetPipelineExecutableStatisticsKHR_VkResult_return =
-                    vk->vkGetPipelineExecutableStatisticsKHR(unboxed_device, pExecutableInfo,
-                                                             pStatisticCount, pStatistics);
+                VkResult vkGetPipelineExecutableStatisticsKHR_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPipelineExecutableStatisticsKHR_VkResult_return =
+                        vk->vkGetPipelineExecutableStatisticsKHR(unboxed_device, pExecutableInfo,
+                                                                 pStatisticCount, pStatistics);
+                }
                 if ((vkGetPipelineExecutableStatisticsKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetPipelineExecutableStatisticsKHR_VkResult_return,
@@ -16220,12 +16149,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetPipelineExecutableStatisticsKHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPipelineExecutableStatisticsKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPipelineExecutableStatisticsKHR_VkResult_return, device,
                         pExecutableInfo, pStatisticCount, pStatistics);
                 }
@@ -16310,11 +16236,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pInternalRepresentations);
                 }
                 VkResult vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return =
-                    (VkResult)0;
-                vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return =
-                    vk->vkGetPipelineExecutableInternalRepresentationsKHR(
-                        unboxed_device, pExecutableInfo, pInternalRepresentationCount,
-                        pInternalRepresentations);
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return =
+                        vk->vkGetPipelineExecutableInternalRepresentationsKHR(
+                            unboxed_device, pExecutableInfo, pInternalRepresentationCount,
+                            pInternalRepresentations);
+                }
                 if ((vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -16354,12 +16282,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPipelineExecutableInternalRepresentationsKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return, device,
                         pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
                 }
@@ -16402,14 +16327,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)event,
                             (unsigned long long)pDependencyInfo);
                 }
-                vk->vkCmdSetEvent2KHR(unboxed_commandBuffer, event, pDependencyInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetEvent2KHR(unboxed_commandBuffer, event, pDependencyInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetEvent2KHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                           &m_pool, commandBuffer, event,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetEvent2KHR(&m_pool, snapshotApiCallInfo, packet,
+                                                           packetLen, commandBuffer, event,
                                                            pDependencyInfo);
                 }
                 vkReadStream->clearPool();
@@ -16444,14 +16368,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)event,
                             (unsigned long long)stageMask);
                 }
-                vk->vkCmdResetEvent2KHR(unboxed_commandBuffer, event, stageMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResetEvent2KHR(unboxed_commandBuffer, event, stageMask);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdResetEvent2KHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, commandBuffer, event,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdResetEvent2KHR(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, commandBuffer, event,
                                                              stageMask);
                 }
                 vkReadStream->clearPool();
@@ -16508,15 +16431,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)eventCount, (unsigned long long)pEvents,
                             (unsigned long long)pDependencyInfos);
                 }
-                vk->vkCmdWaitEvents2KHR(unboxed_commandBuffer, eventCount, pEvents,
-                                        pDependencyInfos);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWaitEvents2KHR(unboxed_commandBuffer, eventCount, pEvents,
+                                            pDependencyInfos);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdWaitEvents2KHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, commandBuffer, eventCount,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdWaitEvents2KHR(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, commandBuffer, eventCount,
                                                              pEvents, pDependencyInfos);
                 }
                 vkReadStream->clearPool();
@@ -16551,15 +16473,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pDependencyInfo);
                 }
-                vk->vkCmdPipelineBarrier2KHR(unboxed_commandBuffer, pDependencyInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdPipelineBarrier2KHR(unboxed_commandBuffer, pDependencyInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdPipelineBarrier2KHR(snapshotTraceBegin,
-                                                                  snapshotTraceBytes, &m_pool,
-                                                                  commandBuffer, pDependencyInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdPipelineBarrier2KHR(&m_pool, snapshotApiCallInfo,
+                                                                  packet, packetLen, commandBuffer,
+                                                                  pDependencyInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -16599,15 +16520,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)commandBuffer, (unsigned long long)stage,
                         (unsigned long long)queryPool, (unsigned long long)query);
                 }
-                vk->vkCmdWriteTimestamp2KHR(unboxed_commandBuffer, stage, queryPool, query);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWriteTimestamp2KHR(unboxed_commandBuffer, stage, queryPool, query);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdWriteTimestamp2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, stage,
-                        queryPool, query);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdWriteTimestamp2KHR(&m_pool, snapshotApiCallInfo,
+                                                                 packet, packetLen, commandBuffer,
+                                                                 stage, queryPool, query);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -16653,21 +16573,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)queue, (unsigned long long)submitCount,
                             (unsigned long long)pSubmits, (unsigned long long)fence);
                 }
-                VkResult vkQueueSubmit2KHR_VkResult_return = (VkResult)0;
-                vkQueueSubmit2KHR_VkResult_return =
-                    vk->vkQueueSubmit2KHR(unboxed_queue, submitCount, pSubmits, fence);
+                VkResult vkQueueSubmit2KHR_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkQueueSubmit2KHR_VkResult_return =
+                        vk->vkQueueSubmit2KHR(unboxed_queue, submitCount, pSubmits, fence);
+                }
                 if ((vkQueueSubmit2KHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkQueueSubmit2KHR_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkQueueSubmit2KHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueueSubmit2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkQueueSubmit2KHR_VkResult_return, queue, submitCount, pSubmits, fence);
                 }
                 vkReadStream->clearPool();
@@ -16711,15 +16630,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dstBuffer, (unsigned long long)dstOffset,
                             (unsigned long long)marker);
                 }
-                vk->vkCmdWriteBufferMarker2AMD(unboxed_commandBuffer, stage, dstBuffer, dstOffset,
-                                               marker);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWriteBufferMarker2AMD(unboxed_commandBuffer, stage, dstBuffer,
+                                                   dstOffset, marker);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdWriteBufferMarker2AMD(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, stage,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, stage,
                         dstBuffer, dstOffset, marker);
                 }
                 vkReadStream->clearPool();
@@ -16782,8 +16700,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pCheckpointDataCount,
                             (unsigned long long)pCheckpointData);
                 }
-                vk->vkGetQueueCheckpointData2NV(unboxed_queue, pCheckpointDataCount,
-                                                pCheckpointData);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetQueueCheckpointData2NV(unboxed_queue, pCheckpointDataCount,
+                                                    pCheckpointData);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pCheckpointDataCount;
@@ -16812,12 +16732,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetQueueCheckpointData2NV(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, queue,
                         pCheckpointDataCount, pCheckpointData);
                 }
                 vkReadStream->clearPool();
@@ -16854,14 +16771,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pCopyBufferInfo);
                 }
-                vk->vkCmdCopyBuffer2KHR(unboxed_commandBuffer, pCopyBufferInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdCopyBuffer2KHR(unboxed_commandBuffer, pCopyBufferInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdCopyBuffer2KHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, commandBuffer,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdCopyBuffer2KHR(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, commandBuffer,
                                                              pCopyBufferInfo);
                 }
                 vkReadStream->clearPool();
@@ -16880,6 +16796,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pCopyImageInfo, sizeof(const VkCopyImageInfo2));
                 reservedunmarshal_VkCopyImageInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                    (VkCopyImageInfo2*)(pCopyImageInfo),
@@ -16891,14 +16808,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdCopyImage2KHR 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)pCopyImageInfo);
                 }
-                m_state->on_vkCmdCopyImage2KHR(&m_pool, commandBuffer, pCopyImageInfo);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdCopyImage2KHR(&m_pool, snapshotApiCallInfo, commandBuffer,
+                                                   pCopyImageInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdCopyImage2KHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, commandBuffer, pCopyImageInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdCopyImage2KHR(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, commandBuffer,
+                                                            pCopyImageInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -16916,6 +16834,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pCopyBufferToImageInfo,
                                     sizeof(const VkCopyBufferToImageInfo2));
                 reservedunmarshal_VkCopyBufferToImageInfo2(
@@ -16930,15 +16849,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pCopyBufferToImageInfo);
                 }
-                m_state->on_vkCmdCopyBufferToImage2KHR(&m_pool, commandBuffer,
-                                                       pCopyBufferToImageInfo, context);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdCopyBufferToImage2KHR(&m_pool, snapshotApiCallInfo,
+                                                           commandBuffer, pCopyBufferToImageInfo,
+                                                           context);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdCopyBufferToImage2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         pCopyBufferToImageInfo);
                 }
                 vkReadStream->clearPool();
@@ -16957,6 +16876,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pCopyImageToBufferInfo,
                                     sizeof(const VkCopyImageToBufferInfo2));
                 reservedunmarshal_VkCopyImageToBufferInfo2(
@@ -16971,15 +16891,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pCopyImageToBufferInfo);
                 }
-                m_state->on_vkCmdCopyImageToBuffer2KHR(&m_pool, commandBuffer,
-                                                       pCopyImageToBufferInfo);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCmdCopyImageToBuffer2KHR(&m_pool, snapshotApiCallInfo,
+                                                           commandBuffer, pCopyImageToBufferInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdCopyImageToBuffer2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         pCopyImageToBufferInfo);
                 }
                 vkReadStream->clearPool();
@@ -17012,14 +16931,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdBlitImage2KHR 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)pBlitImageInfo);
                 }
-                vk->vkCmdBlitImage2KHR(unboxed_commandBuffer, pBlitImageInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBlitImage2KHR(unboxed_commandBuffer, pBlitImageInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBlitImage2KHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, commandBuffer, pBlitImageInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBlitImage2KHR(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, commandBuffer,
+                                                            pBlitImageInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -17053,15 +16972,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pResolveImageInfo);
                 }
-                vk->vkCmdResolveImage2KHR(unboxed_commandBuffer, pResolveImageInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResolveImage2KHR(unboxed_commandBuffer, pResolveImageInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdResolveImage2KHR(snapshotTraceBegin,
-                                                               snapshotTraceBytes, &m_pool,
-                                                               commandBuffer, pResolveImageInfo);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdResolveImage2KHR(&m_pool, snapshotApiCallInfo, packet,
+                                                               packetLen, commandBuffer,
+                                                               pResolveImageInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -17109,8 +17027,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pInfo,
                             (unsigned long long)pMemoryRequirements);
                 }
-                vk->vkGetDeviceBufferMemoryRequirementsKHR(unboxed_device, pInfo,
-                                                           pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDeviceBufferMemoryRequirementsKHR(unboxed_device, pInfo,
+                                                               pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements2(
@@ -17119,12 +17039,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkMemoryRequirements2*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceBufferMemoryRequirementsKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -17171,8 +17088,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pInfo,
                             (unsigned long long)pMemoryRequirements);
                 }
-                vk->vkGetDeviceImageMemoryRequirementsKHR(unboxed_device, pInfo,
-                                                          pMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDeviceImageMemoryRequirementsKHR(unboxed_device, pInfo,
+                                                              pMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 if (pMemoryRequirements) {
                     transform_fromhost_VkMemoryRequirements2(
@@ -17181,12 +17100,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkMemoryRequirements2*)(pMemoryRequirements));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceImageMemoryRequirementsKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -17265,9 +17181,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pSparseMemoryRequirementCount,
                             (unsigned long long)pSparseMemoryRequirements);
                 }
-                vk->vkGetDeviceImageSparseMemoryRequirementsKHR(unboxed_device, pInfo,
-                                                                pSparseMemoryRequirementCount,
-                                                                pSparseMemoryRequirements);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDeviceImageSparseMemoryRequirementsKHR(unboxed_device, pInfo,
+                                                                    pSparseMemoryRequirementCount,
+                                                                    pSparseMemoryRequirements);
+                }
                 vkStream->unsetHandleMapping();
                 // WARNING PTR CHECK
                 uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
@@ -17299,12 +17217,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     }
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceImageSparseMemoryRequirementsKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo,
                         pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                 }
                 vkReadStream->clearPool();
@@ -17349,16 +17264,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)offset, (unsigned long long)size,
                             (unsigned long long)indexType);
                 }
-                vk->vkCmdBindIndexBuffer2KHR(unboxed_commandBuffer, buffer, offset, size,
-                                             indexType);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindIndexBuffer2KHR(unboxed_commandBuffer, buffer, offset, size,
+                                                 indexType);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBindIndexBuffer2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer,
-                        offset, size, indexType);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBindIndexBuffer2KHR(&m_pool, snapshotApiCallInfo,
+                                                                  packet, packetLen, commandBuffer,
+                                                                  buffer, offset, size, indexType);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -17403,8 +17317,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device,
                         (unsigned long long)pRenderingAreaInfo, (unsigned long long)pGranularity);
                 }
-                vk->vkGetRenderingAreaGranularityKHR(unboxed_device, pRenderingAreaInfo,
-                                                     pGranularity);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetRenderingAreaGranularityKHR(unboxed_device, pRenderingAreaInfo,
+                                                         pGranularity);
+                }
                 vkStream->unsetHandleMapping();
                 if (pGranularity) {
                     transform_fromhost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
@@ -17412,12 +17328,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkExtent2D(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                    (VkExtent2D*)(pGranularity));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetRenderingAreaGranularityKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pRenderingAreaInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pRenderingAreaInfo,
                         pGranularity);
                 }
                 vkReadStream->clearPool();
@@ -17464,7 +17377,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pInfo,
                             (unsigned long long)pLayout);
                 }
-                vk->vkGetDeviceImageSubresourceLayoutKHR(unboxed_device, pInfo, pLayout);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetDeviceImageSubresourceLayoutKHR(unboxed_device, pInfo, pLayout);
+                }
                 vkStream->unsetHandleMapping();
                 if (pLayout) {
                     transform_fromhost_VkSubresourceLayout2KHR(m_state,
@@ -17473,12 +17388,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkSubresourceLayout2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                 (VkSubresourceLayout2KHR*)(pLayout));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetDeviceImageSubresourceLayoutKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pLayout);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pInfo, pLayout);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -17529,7 +17441,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)image,
                             (unsigned long long)pSubresource, (unsigned long long)pLayout);
                 }
-                vk->vkGetImageSubresourceLayout2KHR(unboxed_device, image, pSubresource, pLayout);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetImageSubresourceLayout2KHR(unboxed_device, image, pSubresource,
+                                                        pLayout);
+                }
                 vkStream->unsetHandleMapping();
                 if (pLayout) {
                     transform_fromhost_VkSubresourceLayout2KHR(m_state,
@@ -17538,12 +17453,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkSubresourceLayout2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                 (VkSubresourceLayout2KHR*)(pLayout));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetImageSubresourceLayout2KHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, image,
                         pSubresource, pLayout);
                 }
                 vkReadStream->clearPool();
@@ -17579,15 +17491,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)lineStippleFactor,
                             (unsigned long long)lineStipplePattern);
                 }
-                vk->vkCmdSetLineStippleKHR(unboxed_commandBuffer, lineStippleFactor,
-                                           lineStipplePattern);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetLineStippleKHR(unboxed_commandBuffer, lineStippleFactor,
+                                               lineStipplePattern);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetLineStippleKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         lineStippleFactor, lineStipplePattern);
                 }
                 vkReadStream->clearPool();
@@ -17609,6 +17520,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                 *readStreamPtrPtr += sizeof(VkFormat);
                 memcpy((VkImageUsageFlags*)&imageUsage, *readStreamPtrPtr,
@@ -17626,10 +17538,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)format,
                             (unsigned long long)imageUsage, (unsigned long long)grallocUsage);
                 }
-                VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
-                vkGetSwapchainGrallocUsageANDROID_VkResult_return =
-                    m_state->on_vkGetSwapchainGrallocUsageANDROID(&m_pool, device, format,
-                                                                  imageUsage, grallocUsage);
+                VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetSwapchainGrallocUsageANDROID_VkResult_return =
+                        m_state->on_vkGetSwapchainGrallocUsageANDROID(
+                            &m_pool, snapshotApiCallInfo, device, format, imageUsage, grallocUsage);
+                }
                 if ((vkGetSwapchainGrallocUsageANDROID_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetSwapchainGrallocUsageANDROID_VkResult_return,
@@ -17639,12 +17554,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetSwapchainGrallocUsageANDROID_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetSwapchainGrallocUsageANDROID(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetSwapchainGrallocUsageANDROID_VkResult_return, device, format,
                         imageUsage, grallocUsage);
                 }
@@ -17666,6 +17578,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -17689,9 +17602,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)nativeFenceFd, (unsigned long long)semaphore,
                             (unsigned long long)fence);
                 }
-                VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
-                vkAcquireImageANDROID_VkResult_return = m_state->on_vkAcquireImageANDROID(
-                    &m_pool, device, image, nativeFenceFd, semaphore, fence);
+                VkResult vkAcquireImageANDROID_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkAcquireImageANDROID_VkResult_return =
+                        m_state->on_vkAcquireImageANDROID(&m_pool, snapshotApiCallInfo, device,
+                                                          image, nativeFenceFd, semaphore, fence);
+                }
                 if ((vkAcquireImageANDROID_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkAcquireImageANDROID_VkResult_return, opcode,
@@ -17699,12 +17615,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkAcquireImageANDROID(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkAcquireImageANDROID_VkResult_return, device, image, nativeFenceFd,
                         semaphore, fence);
                 }
@@ -17726,6 +17639,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&waitSemaphoreCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 // WARNING PTR CHECK
@@ -17765,10 +17679,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pWaitSemaphores, (unsigned long long)image,
                             (unsigned long long)pNativeFenceFd);
                 }
-                VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
-                vkQueueSignalReleaseImageANDROID_VkResult_return =
-                    m_state->on_vkQueueSignalReleaseImageANDROID(
-                        &m_pool, queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
+                VkResult vkQueueSignalReleaseImageANDROID_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkQueueSignalReleaseImageANDROID_VkResult_return =
+                        m_state->on_vkQueueSignalReleaseImageANDROID(
+                            &m_pool, snapshotApiCallInfo, queue, waitSemaphoreCount,
+                            pWaitSemaphores, image, pNativeFenceFd);
+                }
                 if ((vkQueueSignalReleaseImageANDROID_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkQueueSignalReleaseImageANDROID_VkResult_return,
@@ -17778,12 +17696,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkQueueSignalReleaseImageANDROID_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueueSignalReleaseImageANDROID(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkQueueSignalReleaseImageANDROID_VkResult_return, queue, waitSemaphoreCount,
                         pWaitSemaphores, image, pNativeFenceFd);
                 }
@@ -17806,6 +17721,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                 *readStreamPtrPtr += sizeof(VkFormat);
                 memcpy((VkImageUsageFlags*)&imageUsage, *readStreamPtrPtr,
@@ -17833,11 +17749,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)grallocConsumerUsage,
                             (unsigned long long)grallocProducerUsage);
                 }
-                VkResult vkGetSwapchainGrallocUsage2ANDROID_VkResult_return = (VkResult)0;
-                vkGetSwapchainGrallocUsage2ANDROID_VkResult_return =
-                    m_state->on_vkGetSwapchainGrallocUsage2ANDROID(
-                        &m_pool, device, format, imageUsage, swapchainImageUsage,
-                        grallocConsumerUsage, grallocProducerUsage);
+                VkResult vkGetSwapchainGrallocUsage2ANDROID_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetSwapchainGrallocUsage2ANDROID_VkResult_return =
+                        m_state->on_vkGetSwapchainGrallocUsage2ANDROID(
+                            &m_pool, snapshotApiCallInfo, device, format, imageUsage,
+                            swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage);
+                }
                 if ((vkGetSwapchainGrallocUsage2ANDROID_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetSwapchainGrallocUsage2ANDROID_VkResult_return,
@@ -17848,12 +17767,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetSwapchainGrallocUsage2ANDROID_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetSwapchainGrallocUsage2ANDROID(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetSwapchainGrallocUsage2ANDROID_VkResult_return, device, format,
                         imageUsage, swapchainImageUsage, grallocConsumerUsage,
                         grallocProducerUsage);
@@ -17919,9 +17835,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pCallback);
                 }
-                VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
-                vkCreateDebugReportCallbackEXT_VkResult_return = vk->vkCreateDebugReportCallbackEXT(
-                    unboxed_instance, pCreateInfo, pAllocator, pCallback);
+                VkResult vkCreateDebugReportCallbackEXT_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateDebugReportCallbackEXT_VkResult_return =
+                        vk->vkCreateDebugReportCallbackEXT(unboxed_instance, pCreateInfo,
+                                                           pAllocator, pCallback);
+                }
                 if ((vkCreateDebugReportCallbackEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateDebugReportCallbackEXT_VkResult_return, opcode,
@@ -17941,12 +17861,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateDebugReportCallbackEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateDebugReportCallbackEXT_VkResult_return, instance, pCreateInfo,
                         pAllocator, pCallback);
                 }
@@ -18000,14 +17917,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)instance, (unsigned long long)callback,
                         (unsigned long long)pAllocator);
                 }
-                vk->vkDestroyDebugReportCallbackEXT(unboxed_instance, callback, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    vk->vkDestroyDebugReportCallbackEXT(unboxed_instance, callback, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyDebugReportCallbackEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, instance,
                         boxed_callback_preserve, pAllocator);
                 }
                 delete_VkDebugReportCallbackEXT(boxed_callback_preserve);
@@ -18060,15 +17976,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)location, (unsigned long long)messageCode,
                             (unsigned long long)pLayerPrefix, (unsigned long long)pMessage);
                 }
-                vk->vkDebugReportMessageEXT(unboxed_instance, flags, objectType, object, location,
-                                            messageCode, pLayerPrefix, pMessage);
+                if (CC_LIKELY(vk)) {
+                    vk->vkDebugReportMessageEXT(unboxed_instance, flags, objectType, object,
+                                                location, messageCode, pLayerPrefix, pMessage);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDebugReportMessageEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, flags,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, instance, flags,
                         objectType, object, location, messageCode, pLayerPrefix, pMessage);
                 }
                 vkReadStream->clearPool();
@@ -18136,15 +18051,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pBuffers, (unsigned long long)pOffsets,
                             (unsigned long long)pSizes);
                 }
-                vk->vkCmdBindTransformFeedbackBuffersEXT(unboxed_commandBuffer, firstBinding,
-                                                         bindingCount, pBuffers, pOffsets, pSizes);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindTransformFeedbackBuffersEXT(unboxed_commandBuffer, firstBinding,
+                                                             bindingCount, pBuffers, pOffsets,
+                                                             pSizes);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdBindTransformFeedbackBuffersEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
                 }
                 vkReadStream->clearPool();
@@ -18213,16 +18128,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pCounterBuffers,
                             (unsigned long long)pCounterBufferOffsets);
                 }
-                vk->vkCmdBeginTransformFeedbackEXT(unboxed_commandBuffer, firstCounterBuffer,
-                                                   counterBufferCount, pCounterBuffers,
-                                                   pCounterBufferOffsets);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginTransformFeedbackEXT(unboxed_commandBuffer, firstCounterBuffer,
+                                                       counterBufferCount, pCounterBuffers,
+                                                       pCounterBufferOffsets);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdBeginTransformFeedbackEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         firstCounterBuffer, counterBufferCount, pCounterBuffers,
                         pCounterBufferOffsets);
                 }
@@ -18292,16 +18206,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pCounterBuffers,
                             (unsigned long long)pCounterBufferOffsets);
                 }
-                vk->vkCmdEndTransformFeedbackEXT(unboxed_commandBuffer, firstCounterBuffer,
-                                                 counterBufferCount, pCounterBuffers,
-                                                 pCounterBufferOffsets);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndTransformFeedbackEXT(unboxed_commandBuffer, firstCounterBuffer,
+                                                     counterBufferCount, pCounterBuffers,
+                                                     pCounterBufferOffsets);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdEndTransformFeedbackEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         firstCounterBuffer, counterBufferCount, pCounterBuffers,
                         pCounterBufferOffsets);
                 }
@@ -18347,16 +18260,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)queryPool, (unsigned long long)query,
                             (unsigned long long)flags, (unsigned long long)index);
                 }
-                vk->vkCmdBeginQueryIndexedEXT(unboxed_commandBuffer, queryPool, query, flags,
-                                              index);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginQueryIndexedEXT(unboxed_commandBuffer, queryPool, query, flags,
+                                                  index);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdBeginQueryIndexedEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool,
-                        query, flags, index);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdBeginQueryIndexedEXT(&m_pool, snapshotApiCallInfo,
+                                                                   packet, packetLen, commandBuffer,
+                                                                   queryPool, query, flags, index);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -18395,15 +18307,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool,
                         (unsigned long long)query, (unsigned long long)index);
                 }
-                vk->vkCmdEndQueryIndexedEXT(unboxed_commandBuffer, queryPool, query, index);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndQueryIndexedEXT(unboxed_commandBuffer, queryPool, query, index);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdEndQueryIndexedEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool,
-                        query, index);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdEndQueryIndexedEXT(&m_pool, snapshotApiCallInfo,
+                                                                 packet, packetLen, commandBuffer,
+                                                                 queryPool, query, index);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -18454,16 +18365,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)counterBufferOffset,
                             (unsigned long long)counterOffset, (unsigned long long)vertexStride);
                 }
-                vk->vkCmdDrawIndirectByteCountEXT(unboxed_commandBuffer, instanceCount,
-                                                  firstInstance, counterBuffer, counterBufferOffset,
-                                                  counterOffset, vertexStride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndirectByteCountEXT(
+                        unboxed_commandBuffer, instanceCount, firstInstance, counterBuffer,
+                        counterBufferOffset, counterOffset, vertexStride);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdDrawIndirectByteCountEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         instanceCount, firstInstance, counterBuffer, counterBufferOffset,
                         counterOffset, vertexStride);
                 }
@@ -18500,9 +18410,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkSetDebugUtilsObjectNameEXT 0x%llx 0x%llx \n",
                             ioStream, (unsigned long long)device, (unsigned long long)pNameInfo);
                 }
-                VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
-                vkSetDebugUtilsObjectNameEXT_VkResult_return =
-                    vk->vkSetDebugUtilsObjectNameEXT(unboxed_device, pNameInfo);
+                VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkSetDebugUtilsObjectNameEXT_VkResult_return =
+                        vk->vkSetDebugUtilsObjectNameEXT(unboxed_device, pNameInfo);
+                }
                 if ((vkSetDebugUtilsObjectNameEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkSetDebugUtilsObjectNameEXT_VkResult_return, opcode,
@@ -18510,12 +18422,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkSetDebugUtilsObjectNameEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkSetDebugUtilsObjectNameEXT_VkResult_return, device, pNameInfo);
                 }
                 vkReadStream->clearPool();
@@ -18548,9 +18457,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkSetDebugUtilsObjectTagEXT 0x%llx 0x%llx \n",
                             ioStream, (unsigned long long)device, (unsigned long long)pTagInfo);
                 }
-                VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
-                vkSetDebugUtilsObjectTagEXT_VkResult_return =
-                    vk->vkSetDebugUtilsObjectTagEXT(unboxed_device, pTagInfo);
+                VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkSetDebugUtilsObjectTagEXT_VkResult_return =
+                        vk->vkSetDebugUtilsObjectTagEXT(unboxed_device, pTagInfo);
+                }
                 if ((vkSetDebugUtilsObjectTagEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkSetDebugUtilsObjectTagEXT_VkResult_return, opcode,
@@ -18558,12 +18469,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkSetDebugUtilsObjectTagEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkSetDebugUtilsObjectTagEXT_VkResult_return, device, pTagInfo);
                 }
                 vkReadStream->clearPool();
@@ -18597,14 +18505,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             "stream %p: call vkQueueBeginDebugUtilsLabelEXT 0x%llx 0x%llx \n",
                             ioStream, (unsigned long long)queue, (unsigned long long)pLabelInfo);
                 }
-                vk->vkQueueBeginDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkQueueBeginDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueueBeginDebugUtilsLabelEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pLabelInfo);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, queue, pLabelInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -18627,14 +18534,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkQueueEndDebugUtilsLabelEXT 0x%llx \n",
                             ioStream, (unsigned long long)queue);
                 }
-                vk->vkQueueEndDebugUtilsLabelEXT(unboxed_queue);
+                if (CC_LIKELY(vk)) {
+                    vk->vkQueueEndDebugUtilsLabelEXT(unboxed_queue);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkQueueEndDebugUtilsLabelEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkQueueEndDebugUtilsLabelEXT(&m_pool, snapshotApiCallInfo,
+                                                                      packet, packetLen, queue);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -18667,14 +18573,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             "stream %p: call vkQueueInsertDebugUtilsLabelEXT 0x%llx 0x%llx \n",
                             ioStream, (unsigned long long)queue, (unsigned long long)pLabelInfo);
                 }
-                vk->vkQueueInsertDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkQueueInsertDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueueInsertDebugUtilsLabelEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pLabelInfo);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, queue, pLabelInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -18708,14 +18613,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pLabelInfo);
                 }
-                vk->vkCmdBeginDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdBeginDebugUtilsLabelEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pLabelInfo);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, pLabelInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -18739,14 +18643,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdEndDebugUtilsLabelEXT 0x%llx \n",
                             ioStream, (unsigned long long)commandBuffer);
                 }
-                vk->vkCmdEndDebugUtilsLabelEXT(unboxed_commandBuffer);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndDebugUtilsLabelEXT(unboxed_commandBuffer);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdEndDebugUtilsLabelEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -18781,14 +18684,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pLabelInfo);
                 }
-                vk->vkCmdInsertDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdInsertDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdInsertDebugUtilsLabelEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pLabelInfo);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, pLabelInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -18849,9 +18751,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo,
                             (unsigned long long)pAllocator, (unsigned long long)pMessenger);
                 }
-                VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
-                vkCreateDebugUtilsMessengerEXT_VkResult_return = vk->vkCreateDebugUtilsMessengerEXT(
-                    unboxed_instance, pCreateInfo, pAllocator, pMessenger);
+                VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateDebugUtilsMessengerEXT_VkResult_return =
+                        vk->vkCreateDebugUtilsMessengerEXT(unboxed_instance, pCreateInfo,
+                                                           pAllocator, pMessenger);
+                }
                 if ((vkCreateDebugUtilsMessengerEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateDebugUtilsMessengerEXT_VkResult_return, opcode,
@@ -18871,12 +18777,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                 vkStream->write(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateDebugUtilsMessengerEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateDebugUtilsMessengerEXT_VkResult_return, instance, pCreateInfo,
                         pAllocator, pMessenger);
                 }
@@ -18930,14 +18833,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)instance, (unsigned long long)messenger,
                         (unsigned long long)pAllocator);
                 }
-                vk->vkDestroyDebugUtilsMessengerEXT(unboxed_instance, messenger, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    vk->vkDestroyDebugUtilsMessengerEXT(unboxed_instance, messenger, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkDestroyDebugUtilsMessengerEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, instance,
                         boxed_messenger_preserve, pAllocator);
                 }
                 delete_VkDebugUtilsMessengerEXT(boxed_messenger_preserve);
@@ -18984,15 +18886,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)messageSeverity, (unsigned long long)messageTypes,
                             (unsigned long long)pCallbackData);
                 }
-                vk->vkSubmitDebugUtilsMessageEXT(unboxed_instance, messageSeverity, messageTypes,
-                                                 pCallbackData);
+                if (CC_LIKELY(vk)) {
+                    vk->vkSubmitDebugUtilsMessageEXT(unboxed_instance, messageSeverity,
+                                                     messageTypes, pCallbackData);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkSubmitDebugUtilsMessageEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, messageSeverity,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, instance, messageSeverity,
                         messageTypes, pCallbackData);
                 }
                 vkReadStream->clearPool();
@@ -19038,10 +18939,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)image,
                             (unsigned long long)pProperties);
                 }
-                VkResult vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return = (VkResult)0;
-                vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return =
-                    vk->vkGetImageDrmFormatModifierPropertiesEXT(unboxed_device, image,
-                                                                 pProperties);
+                VkResult vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return =
+                        vk->vkGetImageDrmFormatModifierPropertiesEXT(unboxed_device, image,
+                                                                     pProperties);
+                }
                 if ((vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -19058,12 +18962,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetImageDrmFormatModifierPropertiesEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return, device, image,
                         pProperties);
                 }
@@ -19115,10 +19016,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pHostPointer,
                             (unsigned long long)pMemoryHostPointerProperties);
                 }
-                VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
-                vkGetMemoryHostPointerPropertiesEXT_VkResult_return =
-                    vk->vkGetMemoryHostPointerPropertiesEXT(
-                        unboxed_device, handleType, pHostPointer, pMemoryHostPointerProperties);
+                VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetMemoryHostPointerPropertiesEXT_VkResult_return =
+                        vk->vkGetMemoryHostPointerPropertiesEXT(
+                            unboxed_device, handleType, pHostPointer, pMemoryHostPointerProperties);
+                }
                 if ((vkGetMemoryHostPointerPropertiesEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetMemoryHostPointerPropertiesEXT_VkResult_return,
@@ -19134,12 +19038,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetMemoryHostPointerPropertiesEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetMemoryHostPointerPropertiesEXT_VkResult_return, device, handleType,
                         pHostPointer, pMemoryHostPointerProperties);
                 }
@@ -19207,10 +19108,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)physicalDevice,
                             (unsigned long long)pToolCount, (unsigned long long)pToolProperties);
                 }
-                VkResult vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return = (VkResult)0;
-                vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return =
-                    vk->vkGetPhysicalDeviceToolPropertiesEXT(unboxed_physicalDevice, pToolCount,
-                                                             pToolProperties);
+                VkResult vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return =
+                        vk->vkGetPhysicalDeviceToolPropertiesEXT(unboxed_physicalDevice, pToolCount,
+                                                                 pToolProperties);
+                }
                 if ((vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return,
@@ -19245,12 +19149,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetPhysicalDeviceToolPropertiesEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return, physicalDevice,
                         pToolCount, pToolProperties);
                 }
@@ -19287,15 +19188,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)lineStippleFactor,
                             (unsigned long long)lineStipplePattern);
                 }
-                vk->vkCmdSetLineStippleEXT(unboxed_commandBuffer, lineStippleFactor,
-                                           lineStipplePattern);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetLineStippleEXT(unboxed_commandBuffer, lineStippleFactor,
+                                               lineStipplePattern);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetLineStippleEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         lineStippleFactor, lineStipplePattern);
                 }
                 vkReadStream->clearPool();
@@ -19326,14 +19226,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)cullMode);
                 }
-                vk->vkCmdSetCullModeEXT(unboxed_commandBuffer, cullMode);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetCullModeEXT(unboxed_commandBuffer, cullMode);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetCullModeEXT(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, commandBuffer, cullMode);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetCullModeEXT(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, commandBuffer, cullMode);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -19361,14 +19260,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)frontFace);
                 }
-                vk->vkCmdSetFrontFaceEXT(unboxed_commandBuffer, frontFace);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetFrontFaceEXT(unboxed_commandBuffer, frontFace);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetFrontFaceEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, frontFace);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetFrontFaceEXT(&m_pool, snapshotApiCallInfo, packet,
+                                                              packetLen, commandBuffer, frontFace);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -19397,14 +19295,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)primitiveTopology);
                 }
-                vk->vkCmdSetPrimitiveTopologyEXT(unboxed_commandBuffer, primitiveTopology);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPrimitiveTopologyEXT(unboxed_commandBuffer, primitiveTopology);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetPrimitiveTopologyEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         primitiveTopology);
                 }
                 vkReadStream->clearPool();
@@ -19446,14 +19343,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)viewportCount, (unsigned long long)pViewports);
                 }
-                vk->vkCmdSetViewportWithCountEXT(unboxed_commandBuffer, viewportCount, pViewports);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetViewportWithCountEXT(unboxed_commandBuffer, viewportCount,
+                                                     pViewports);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetViewportWithCountEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         viewportCount, pViewports);
                 }
                 vkReadStream->clearPool();
@@ -19494,14 +19391,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)scissorCount, (unsigned long long)pScissors);
                 }
-                vk->vkCmdSetScissorWithCountEXT(unboxed_commandBuffer, scissorCount, pScissors);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetScissorWithCountEXT(unboxed_commandBuffer, scissorCount, pScissors);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetScissorWithCountEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         scissorCount, pScissors);
                 }
                 vkReadStream->clearPool();
@@ -19587,15 +19483,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pBuffers, (unsigned long long)pOffsets,
                             (unsigned long long)pSizes, (unsigned long long)pStrides);
                 }
-                vk->vkCmdBindVertexBuffers2EXT(unboxed_commandBuffer, firstBinding, bindingCount,
-                                               pBuffers, pOffsets, pSizes, pStrides);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindVertexBuffers2EXT(unboxed_commandBuffer, firstBinding,
+                                                   bindingCount, pBuffers, pOffsets, pSizes,
+                                                   pStrides);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdBindVertexBuffers2EXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
                 }
                 vkReadStream->clearPool();
@@ -19624,14 +19520,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthTestEnable);
                 }
-                vk->vkCmdSetDepthTestEnableEXT(unboxed_commandBuffer, depthTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthTestEnableEXT(unboxed_commandBuffer, depthTestEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetDepthTestEnableEXT(snapshotTraceBegin,
-                                                                    snapshotTraceBytes, &m_pool,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetDepthTestEnableEXT(&m_pool, snapshotApiCallInfo,
+                                                                    packet, packetLen,
                                                                     commandBuffer, depthTestEnable);
                 }
                 vkReadStream->clearPool();
@@ -19660,14 +19555,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthWriteEnable);
                 }
-                vk->vkCmdSetDepthWriteEnableEXT(unboxed_commandBuffer, depthWriteEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthWriteEnableEXT(unboxed_commandBuffer, depthWriteEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetDepthWriteEnableEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         depthWriteEnable);
                 }
                 vkReadStream->clearPool();
@@ -19696,15 +19590,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthCompareOp);
                 }
-                vk->vkCmdSetDepthCompareOpEXT(unboxed_commandBuffer, depthCompareOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthCompareOpEXT(unboxed_commandBuffer, depthCompareOp);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetDepthCompareOpEXT(snapshotTraceBegin,
-                                                                   snapshotTraceBytes, &m_pool,
-                                                                   commandBuffer, depthCompareOp);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetDepthCompareOpEXT(&m_pool, snapshotApiCallInfo,
+                                                                   packet, packetLen, commandBuffer,
+                                                                   depthCompareOp);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -19733,14 +19626,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthBoundsTestEnable);
                 }
-                vk->vkCmdSetDepthBoundsTestEnableEXT(unboxed_commandBuffer, depthBoundsTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBoundsTestEnableEXT(unboxed_commandBuffer,
+                                                         depthBoundsTestEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetDepthBoundsTestEnableEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         depthBoundsTestEnable);
                 }
                 vkReadStream->clearPool();
@@ -19769,14 +19662,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)stencilTestEnable);
                 }
-                vk->vkCmdSetStencilTestEnableEXT(unboxed_commandBuffer, stencilTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilTestEnableEXT(unboxed_commandBuffer, stencilTestEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetStencilTestEnableEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         stencilTestEnable);
                 }
                 vkReadStream->clearPool();
@@ -19822,15 +19714,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)passOp, (unsigned long long)depthFailOp,
                             (unsigned long long)compareOp);
                 }
-                vk->vkCmdSetStencilOpEXT(unboxed_commandBuffer, faceMask, failOp, passOp,
-                                         depthFailOp, compareOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilOpEXT(unboxed_commandBuffer, faceMask, failOp, passOp,
+                                             depthFailOp, compareOp);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetStencilOpEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, faceMask,
                         failOp, passOp, depthFailOp, compareOp);
                 }
                 vkReadStream->clearPool();
@@ -19867,9 +19758,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)pCopyMemoryToImageInfo);
                 }
-                VkResult vkCopyMemoryToImageEXT_VkResult_return = (VkResult)0;
-                vkCopyMemoryToImageEXT_VkResult_return =
-                    vk->vkCopyMemoryToImageEXT(unboxed_device, pCopyMemoryToImageInfo);
+                VkResult vkCopyMemoryToImageEXT_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCopyMemoryToImageEXT_VkResult_return =
+                        vk->vkCopyMemoryToImageEXT(unboxed_device, pCopyMemoryToImageInfo);
+                }
                 if ((vkCopyMemoryToImageEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCopyMemoryToImageEXT_VkResult_return, opcode,
@@ -19877,12 +19770,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkCopyMemoryToImageEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCopyMemoryToImageEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCopyMemoryToImageEXT_VkResult_return, device, pCopyMemoryToImageInfo);
                 }
                 vkReadStream->clearPool();
@@ -19917,9 +19807,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)pCopyImageToMemoryInfo);
                 }
-                VkResult vkCopyImageToMemoryEXT_VkResult_return = (VkResult)0;
-                vkCopyImageToMemoryEXT_VkResult_return =
-                    vk->vkCopyImageToMemoryEXT(unboxed_device, pCopyImageToMemoryInfo);
+                VkResult vkCopyImageToMemoryEXT_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCopyImageToMemoryEXT_VkResult_return =
+                        vk->vkCopyImageToMemoryEXT(unboxed_device, pCopyImageToMemoryInfo);
+                }
                 if ((vkCopyImageToMemoryEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCopyImageToMemoryEXT_VkResult_return, opcode,
@@ -19927,12 +19819,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkCopyImageToMemoryEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCopyImageToMemoryEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCopyImageToMemoryEXT_VkResult_return, device, pCopyImageToMemoryInfo);
                 }
                 vkReadStream->clearPool();
@@ -19967,9 +19856,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)pCopyImageToImageInfo);
                 }
-                VkResult vkCopyImageToImageEXT_VkResult_return = (VkResult)0;
-                vkCopyImageToImageEXT_VkResult_return =
-                    vk->vkCopyImageToImageEXT(unboxed_device, pCopyImageToImageInfo);
+                VkResult vkCopyImageToImageEXT_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCopyImageToImageEXT_VkResult_return =
+                        vk->vkCopyImageToImageEXT(unboxed_device, pCopyImageToImageInfo);
+                }
                 if ((vkCopyImageToImageEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCopyImageToImageEXT_VkResult_return, opcode,
@@ -19977,12 +19868,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkCopyImageToImageEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCopyImageToImageEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCopyImageToImageEXT_VkResult_return, device, pCopyImageToImageInfo);
                 }
                 vkReadStream->clearPool();
@@ -20026,9 +19914,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)transitionCount, (unsigned long long)pTransitions);
                 }
-                VkResult vkTransitionImageLayoutEXT_VkResult_return = (VkResult)0;
-                vkTransitionImageLayoutEXT_VkResult_return =
-                    vk->vkTransitionImageLayoutEXT(unboxed_device, transitionCount, pTransitions);
+                VkResult vkTransitionImageLayoutEXT_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkTransitionImageLayoutEXT_VkResult_return = vk->vkTransitionImageLayoutEXT(
+                        unboxed_device, transitionCount, pTransitions);
+                }
                 if ((vkTransitionImageLayoutEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkTransitionImageLayoutEXT_VkResult_return, opcode,
@@ -20036,12 +19926,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkTransitionImageLayoutEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkTransitionImageLayoutEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkTransitionImageLayoutEXT_VkResult_return, device, transitionCount,
                         pTransitions);
                 }
@@ -20094,7 +19981,10 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)image,
                             (unsigned long long)pSubresource, (unsigned long long)pLayout);
                 }
-                vk->vkGetImageSubresourceLayout2EXT(unboxed_device, image, pSubresource, pLayout);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetImageSubresourceLayout2EXT(unboxed_device, image, pSubresource,
+                                                        pLayout);
+                }
                 vkStream->unsetHandleMapping();
                 if (pLayout) {
                     transform_fromhost_VkSubresourceLayout2KHR(m_state,
@@ -20103,12 +19993,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 marshal_VkSubresourceLayout2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                 (VkSubresourceLayout2KHR*)(pLayout));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetImageSubresourceLayout2EXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, image,
                         pSubresource, pLayout);
                 }
                 vkReadStream->clearPool();
@@ -20144,9 +20031,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkReleaseSwapchainImagesEXT 0x%llx 0x%llx \n",
                             ioStream, (unsigned long long)device, (unsigned long long)pReleaseInfo);
                 }
-                VkResult vkReleaseSwapchainImagesEXT_VkResult_return = (VkResult)0;
-                vkReleaseSwapchainImagesEXT_VkResult_return =
-                    vk->vkReleaseSwapchainImagesEXT(unboxed_device, pReleaseInfo);
+                VkResult vkReleaseSwapchainImagesEXT_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkReleaseSwapchainImagesEXT_VkResult_return =
+                        vk->vkReleaseSwapchainImagesEXT(unboxed_device, pReleaseInfo);
+                }
                 if ((vkReleaseSwapchainImagesEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkReleaseSwapchainImagesEXT_VkResult_return, opcode,
@@ -20154,12 +20043,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkReleaseSwapchainImagesEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkReleaseSwapchainImagesEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkReleaseSwapchainImagesEXT_VkResult_return, device, pReleaseInfo);
                 }
                 vkReadStream->clearPool();
@@ -20222,9 +20108,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                         (unsigned long long)pAllocator, (unsigned long long)pPrivateDataSlot);
                 }
-                VkResult vkCreatePrivateDataSlotEXT_VkResult_return = (VkResult)0;
-                vkCreatePrivateDataSlotEXT_VkResult_return = vk->vkCreatePrivateDataSlotEXT(
-                    unboxed_device, pCreateInfo, pAllocator, pPrivateDataSlot);
+                VkResult vkCreatePrivateDataSlotEXT_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreatePrivateDataSlotEXT_VkResult_return = vk->vkCreatePrivateDataSlotEXT(
+                        unboxed_device, pCreateInfo, pAllocator, pPrivateDataSlot);
+                }
                 if ((vkCreatePrivateDataSlotEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreatePrivateDataSlotEXT_VkResult_return, opcode,
@@ -20236,12 +20124,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write((uint64_t*)&cgen_var_3, 8);
                 vkStream->write(&vkCreatePrivateDataSlotEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreatePrivateDataSlotEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreatePrivateDataSlotEXT_VkResult_return, device, pCreateInfo, pAllocator,
                         pPrivateDataSlot);
                 }
@@ -20289,15 +20174,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device,
                             (unsigned long long)privateDataSlot, (unsigned long long)pAllocator);
                 }
-                vk->vkDestroyPrivateDataSlotEXT(unboxed_device, privateDataSlot, pAllocator);
+                if (CC_LIKELY(vk)) {
+                    vk->vkDestroyPrivateDataSlotEXT(unboxed_device, privateDataSlot, pAllocator);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkDestroyPrivateDataSlotEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, privateDataSlot,
-                        pAllocator);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkDestroyPrivateDataSlotEXT(&m_pool, snapshotApiCallInfo,
+                                                                     packet, packetLen, device,
+                                                                     privateDataSlot, pAllocator);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -20339,21 +20223,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)objectHandle, (unsigned long long)privateDataSlot,
                         (unsigned long long)data);
                 }
-                VkResult vkSetPrivateDataEXT_VkResult_return = (VkResult)0;
-                vkSetPrivateDataEXT_VkResult_return = vk->vkSetPrivateDataEXT(
-                    unboxed_device, objectType, objectHandle, privateDataSlot, data);
+                VkResult vkSetPrivateDataEXT_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkSetPrivateDataEXT_VkResult_return = vk->vkSetPrivateDataEXT(
+                        unboxed_device, objectType, objectHandle, privateDataSlot, data);
+                }
                 if ((vkSetPrivateDataEXT_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkSetPrivateDataEXT_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkSetPrivateDataEXT_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkSetPrivateDataEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkSetPrivateDataEXT_VkResult_return, device, objectType, objectHandle,
                         privateDataSlot, data);
                 }
@@ -20400,17 +20283,16 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         (unsigned long long)objectHandle, (unsigned long long)privateDataSlot,
                         (unsigned long long)pData);
                 }
-                vk->vkGetPrivateDataEXT(unboxed_device, objectType, objectHandle, privateDataSlot,
-                                        pData);
+                if (CC_LIKELY(vk)) {
+                    vk->vkGetPrivateDataEXT(unboxed_device, objectType, objectHandle,
+                                            privateDataSlot, pData);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write((uint64_t*)pData, sizeof(uint64_t));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetPrivateDataEXT(snapshotTraceBegin, snapshotTraceBytes,
-                                                             &m_pool, device, objectType,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetPrivateDataEXT(&m_pool, snapshotApiCallInfo, packet,
+                                                             packetLen, device, objectType,
                                                              objectHandle, privateDataSlot, pData);
                 }
                 vkReadStream->clearPool();
@@ -20442,14 +20324,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)patchControlPoints);
                 }
-                vk->vkCmdSetPatchControlPointsEXT(unboxed_commandBuffer, patchControlPoints);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPatchControlPointsEXT(unboxed_commandBuffer, patchControlPoints);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetPatchControlPointsEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         patchControlPoints);
                 }
                 vkReadStream->clearPool();
@@ -20479,15 +20360,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)rasterizerDiscardEnable);
                 }
-                vk->vkCmdSetRasterizerDiscardEnableEXT(unboxed_commandBuffer,
-                                                       rasterizerDiscardEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetRasterizerDiscardEnableEXT(unboxed_commandBuffer,
+                                                           rasterizerDiscardEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetRasterizerDiscardEnableEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         rasterizerDiscardEnable);
                 }
                 vkReadStream->clearPool();
@@ -20516,14 +20396,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)depthBiasEnable);
                 }
-                vk->vkCmdSetDepthBiasEnableEXT(unboxed_commandBuffer, depthBiasEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBiasEnableEXT(unboxed_commandBuffer, depthBiasEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetDepthBiasEnableEXT(snapshotTraceBegin,
-                                                                    snapshotTraceBytes, &m_pool,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetDepthBiasEnableEXT(&m_pool, snapshotApiCallInfo,
+                                                                    packet, packetLen,
                                                                     commandBuffer, depthBiasEnable);
                 }
                 vkReadStream->clearPool();
@@ -20551,14 +20430,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkCmdSetLogicOpEXT 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)commandBuffer, (unsigned long long)logicOp);
                 }
-                vk->vkCmdSetLogicOpEXT(unboxed_commandBuffer, logicOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetLogicOpEXT(unboxed_commandBuffer, logicOp);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkCmdSetLogicOpEXT(snapshotTraceBegin, snapshotTraceBytes,
-                                                            &m_pool, commandBuffer, logicOp);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkCmdSetLogicOpEXT(&m_pool, snapshotApiCallInfo, packet,
+                                                            packetLen, commandBuffer, logicOp);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -20587,15 +20465,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)primitiveRestartEnable);
                 }
-                vk->vkCmdSetPrimitiveRestartEnableEXT(unboxed_commandBuffer,
-                                                      primitiveRestartEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPrimitiveRestartEnableEXT(unboxed_commandBuffer,
+                                                          primitiveRestartEnable);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetPrimitiveRestartEnableEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         primitiveRestartEnable);
                 }
                 vkReadStream->clearPool();
@@ -20634,15 +20511,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)attachmentCount,
                             (unsigned long long)pColorWriteEnables);
                 }
-                vk->vkCmdSetColorWriteEnableEXT(unboxed_commandBuffer, attachmentCount,
-                                                pColorWriteEnables);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetColorWriteEnableEXT(unboxed_commandBuffer, attachmentCount,
+                                                    pColorWriteEnables);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetColorWriteEnableEXT(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         attachmentCount, pColorWriteEnables);
                 }
                 vkReadStream->clearPool();
@@ -20663,6 +20539,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -20686,10 +20563,13 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)device, (unsigned long long)memory,
                         (unsigned long long)pAddress);
                 }
-                VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
-                vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return =
-                    m_state->on_vkMapMemoryIntoAddressSpaceGOOGLE(&m_pool, device, memory,
-                                                                  pAddress);
+                VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return =
+                        m_state->on_vkMapMemoryIntoAddressSpaceGOOGLE(&m_pool, snapshotApiCallInfo,
+                                                                      device, memory, pAddress);
+                }
                 if ((vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return,
@@ -20704,12 +20584,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkMapMemoryIntoAddressSpaceGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, device, memory,
                         pAddress);
                 }
@@ -20738,6 +20615,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -20860,18 +20738,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pImageInfos, (unsigned long long)pBufferInfos,
                             (unsigned long long)pBufferViews);
                 }
-                m_state->on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-                    &m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount,
-                    bufferInfoCount, bufferViewCount, pImageInfoEntryIndices,
-                    pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos,
-                    pBufferViews);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
+                        &m_pool, snapshotApiCallInfo, device, descriptorSet,
+                        descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount,
+                        pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices,
+                        pImageInfos, pBufferInfos, pBufferViews);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, descriptorSet,
                         descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount,
                         pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices,
                         pImageInfos, pBufferInfos, pBufferViews);
@@ -20892,6 +20769,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                 reservedunmarshal_VkCommandBufferBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                            (VkCommandBufferBeginInfo*)(pBeginInfo),
@@ -20906,15 +20784,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)pBeginInfo);
                 }
-                m_state->on_vkBeginCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, pBeginInfo,
-                                                            context);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkBeginCommandBufferAsyncGOOGLE(&m_pool, snapshotApiCallInfo,
+                                                                commandBuffer, pBeginInfo, context);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkBeginCommandBufferAsyncGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pBeginInfo);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, pBeginInfo);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -20931,18 +20808,19 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 if (m_logCalls) {
                     fprintf(stderr, "stream %p: call vkEndCommandBufferAsyncGOOGLE 0x%llx \n",
                             ioStream, (unsigned long long)commandBuffer);
                 }
-                m_state->on_vkEndCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, context);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkEndCommandBufferAsyncGOOGLE(&m_pool, snapshotApiCallInfo,
+                                                              commandBuffer, context);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkEndCommandBufferAsyncGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -20960,6 +20838,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr,
                        sizeof(VkCommandBufferResetFlags));
                 *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
@@ -20968,14 +20847,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             "stream %p: call vkResetCommandBufferAsyncGOOGLE 0x%llx 0x%llx \n",
                             ioStream, (unsigned long long)commandBuffer, (unsigned long long)flags);
                 }
-                m_state->on_vkResetCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, flags);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkResetCommandBufferAsyncGOOGLE(&m_pool, snapshotApiCallInfo,
+                                                                commandBuffer, flags);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkResetCommandBufferAsyncGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, flags);
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer, flags);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -20994,6 +20873,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 *readStreamPtrPtr += 1 * 8;
                 *(VkCommandBuffer*)&commandBuffer =
                     (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
+                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                 memcpy((uint32_t*)&needHostSync, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&sequenceNumber, *readStreamPtrPtr, sizeof(uint32_t));
@@ -21004,15 +20884,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)commandBuffer,
                             (unsigned long long)needHostSync, (unsigned long long)sequenceNumber);
                 }
-                m_state->on_vkCommandBufferHostSyncGOOGLE(&m_pool, commandBuffer, needHostSync,
-                                                          sequenceNumber);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCommandBufferHostSyncGOOGLE(
+                        &m_pool, snapshotApiCallInfo, commandBuffer, needHostSync, sequenceNumber);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCommandBufferHostSyncGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         needHostSync, sequenceNumber);
                 }
                 vkReadStream->clearPool();
@@ -21033,6 +20912,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                 reservedunmarshal_VkImageCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkImageCreateInfo*)(pCreateInfo),
@@ -21080,10 +20960,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pAllocator, (unsigned long long)pImage,
                             (unsigned long long)pMemoryRequirements);
                 }
-                VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
-                vkCreateImageWithRequirementsGOOGLE_VkResult_return =
-                    m_state->on_vkCreateImageWithRequirementsGOOGLE(
-                        &m_pool, device, pCreateInfo, pAllocator, pImage, pMemoryRequirements);
+                VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateImageWithRequirementsGOOGLE_VkResult_return =
+                        m_state->on_vkCreateImageWithRequirementsGOOGLE(
+                            &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pImage,
+                            pMemoryRequirements);
+                }
                 if ((vkCreateImageWithRequirementsGOOGLE_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateImageWithRequirementsGOOGLE_VkResult_return,
@@ -21107,12 +20991,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkCreateImageWithRequirementsGOOGLE_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateImageWithRequirementsGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateImageWithRequirementsGOOGLE_VkResult_return, device, pCreateInfo,
                         pAllocator, pImage, pMemoryRequirements);
                 }
@@ -21134,6 +21015,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                 reservedunmarshal_VkBufferCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkBufferCreateInfo*)(pCreateInfo),
@@ -21181,10 +21063,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pAllocator, (unsigned long long)pBuffer,
                             (unsigned long long)pMemoryRequirements);
                 }
-                VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
-                vkCreateBufferWithRequirementsGOOGLE_VkResult_return =
-                    m_state->on_vkCreateBufferWithRequirementsGOOGLE(
-                        &m_pool, device, pCreateInfo, pAllocator, pBuffer, pMemoryRequirements);
+                VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateBufferWithRequirementsGOOGLE_VkResult_return =
+                        m_state->on_vkCreateBufferWithRequirementsGOOGLE(
+                            &m_pool, snapshotApiCallInfo, device, pCreateInfo, pAllocator, pBuffer,
+                            pMemoryRequirements);
+                }
                 if ((vkCreateBufferWithRequirementsGOOGLE_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateBufferWithRequirementsGOOGLE_VkResult_return,
@@ -21208,12 +21094,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkCreateBufferWithRequirementsGOOGLE_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateBufferWithRequirementsGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateBufferWithRequirementsGOOGLE_VkResult_return, device, pCreateInfo,
                         pAllocator, pBuffer, pMemoryRequirements);
                 }
@@ -21235,6 +21118,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -21281,10 +21165,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pAddress, (unsigned long long)pSize,
                             (unsigned long long)pHostmemId);
                 }
-                VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
-                vkGetMemoryHostAddressInfoGOOGLE_VkResult_return =
-                    m_state->on_vkGetMemoryHostAddressInfoGOOGLE(&m_pool, device, memory, pAddress,
-                                                                 pSize, pHostmemId);
+                VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetMemoryHostAddressInfoGOOGLE_VkResult_return =
+                        m_state->on_vkGetMemoryHostAddressInfoGOOGLE(&m_pool, snapshotApiCallInfo,
+                                                                     device, memory, pAddress,
+                                                                     pSize, pHostmemId);
+                }
                 if ((vkGetMemoryHostAddressInfoGOOGLE_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetMemoryHostAddressInfoGOOGLE_VkResult_return,
@@ -21311,12 +21199,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetMemoryHostAddressInfoGOOGLE_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetMemoryHostAddressInfoGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, device, memory, pAddress,
                         pSize, pHostmemId);
                 }
@@ -21336,6 +21221,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 // Begin manual non dispatchable handle destroy unboxing for memory;
                 VkDeviceMemory boxed_memory_preserve;
                 uint64_t cgen_var_1;
@@ -21365,9 +21251,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)memory,
                             (unsigned long long)pAllocator);
                 }
-                VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
-                vkFreeMemorySyncGOOGLE_VkResult_return =
-                    m_state->on_vkFreeMemorySyncGOOGLE(&m_pool, device, memory, pAllocator);
+                VkResult vkFreeMemorySyncGOOGLE_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkFreeMemorySyncGOOGLE_VkResult_return = m_state->on_vkFreeMemorySyncGOOGLE(
+                        &m_pool, snapshotApiCallInfo, device, memory, pAllocator);
+                }
                 if ((vkFreeMemorySyncGOOGLE_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkFreeMemorySyncGOOGLE_VkResult_return, opcode,
@@ -21375,12 +21263,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkFreeMemorySyncGOOGLE_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkFreeMemorySyncGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkFreeMemorySyncGOOGLE_VkResult_return, device, boxed_memory_preserve,
                         pAllocator);
                 }
@@ -21401,6 +21286,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&needHostSync, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&sequenceNumber, *readStreamPtrPtr, sizeof(uint32_t));
@@ -21410,15 +21296,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)queue, (unsigned long long)needHostSync,
                             (unsigned long long)sequenceNumber);
                 }
-                m_state->on_vkQueueHostSyncGOOGLE(&m_pool, queue, needHostSync, sequenceNumber);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkQueueHostSyncGOOGLE(&m_pool, snapshotApiCallInfo, queue,
+                                                      needHostSync, sequenceNumber);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkQueueHostSyncGOOGLE(snapshotTraceBegin,
-                                                               snapshotTraceBytes, &m_pool, queue,
-                                                               needHostSync, sequenceNumber);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkQueueHostSyncGOOGLE(&m_pool, snapshotApiCallInfo, packet,
+                                                               packetLen, queue, needHostSync,
+                                                               sequenceNumber);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -21437,6 +21323,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&submitCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pSubmits,
@@ -21461,15 +21348,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)queue, (unsigned long long)submitCount,
                         (unsigned long long)pSubmits, (unsigned long long)fence);
                 }
-                m_state->on_vkQueueSubmitAsyncGOOGLE(&m_pool, queue, submitCount, pSubmits, fence);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkQueueSubmitAsyncGOOGLE(&m_pool, snapshotApiCallInfo, queue,
+                                                         submitCount, pSubmits, fence);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkQueueSubmitAsyncGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, submitCount,
-                        pSubmits, fence);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkQueueSubmitAsyncGOOGLE(&m_pool, snapshotApiCallInfo,
+                                                                  packet, packetLen, queue,
+                                                                  submitCount, pSubmits, fence);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -21485,18 +21372,18 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 if (m_logCalls) {
                     fprintf(stderr, "stream %p: call vkQueueWaitIdleAsyncGOOGLE 0x%llx \n",
                             ioStream, (unsigned long long)queue);
                 }
-                m_state->on_vkQueueWaitIdleAsyncGOOGLE(&m_pool, queue);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkQueueWaitIdleAsyncGOOGLE(&m_pool, snapshotApiCallInfo, queue);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkQueueWaitIdleAsyncGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkQueueWaitIdleAsyncGOOGLE(&m_pool, snapshotApiCallInfo,
+                                                                    packet, packetLen, queue);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -21515,6 +21402,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pBindInfo,
@@ -21541,15 +21429,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)queue, (unsigned long long)bindInfoCount,
                             (unsigned long long)pBindInfo, (unsigned long long)fence);
                 }
-                m_state->on_vkQueueBindSparseAsyncGOOGLE(&m_pool, queue, bindInfoCount, pBindInfo,
-                                                         fence);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkQueueBindSparseAsyncGOOGLE(&m_pool, snapshotApiCallInfo, queue,
+                                                             bindInfoCount, pBindInfo, fence);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueueBindSparseAsyncGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, bindInfoCount,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, queue, bindInfoCount,
                         pBindInfo, fence);
                 }
                 vkReadStream->clearPool();
@@ -21569,6 +21456,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                 *readStreamPtrPtr += sizeof(VkFormat);
                 // Begin manual dispatchable handle unboxing for pOffset;
@@ -21588,18 +21476,17 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)format,
                             (unsigned long long)pOffset, (unsigned long long)pRowPitchAlignment);
                 }
-                m_state->on_vkGetLinearImageLayoutGOOGLE(&m_pool, device, format, pOffset,
-                                                         pRowPitchAlignment);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetLinearImageLayoutGOOGLE(&m_pool, snapshotApiCallInfo, device,
+                                                             format, pOffset, pRowPitchAlignment);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write((VkDeviceSize*)pOffset, sizeof(VkDeviceSize));
                 vkStream->write((VkDeviceSize*)pRowPitchAlignment, sizeof(VkDeviceSize));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetLinearImageLayoutGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, format, pOffset,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, format, pOffset,
                         pRowPitchAlignment);
                 }
                 vkReadStream->clearPool();
@@ -21619,6 +21506,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                 reservedunmarshal_VkImageCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkImageCreateInfo*)(pCreateInfo),
@@ -21644,18 +21532,18 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo,
                             (unsigned long long)pOffset, (unsigned long long)pRowPitchAlignment);
                 }
-                m_state->on_vkGetLinearImageLayout2GOOGLE(&m_pool, device, pCreateInfo, pOffset,
-                                                          pRowPitchAlignment);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkGetLinearImageLayout2GOOGLE(&m_pool, snapshotApiCallInfo, device,
+                                                              pCreateInfo, pOffset,
+                                                              pRowPitchAlignment);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write((VkDeviceSize*)pOffset, sizeof(VkDeviceSize));
                 vkStream->write((VkDeviceSize*)pRowPitchAlignment, sizeof(VkDeviceSize));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetLinearImageLayout2GOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pCreateInfo,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, pCreateInfo,
                         pOffset, pRowPitchAlignment);
                 }
                 vkReadStream->clearPool();
@@ -21675,6 +21563,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 // No unbox for commandBuffer
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
@@ -21695,16 +21584,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 if (m_queueSubmitWithCommandsEnabled)
                     seqnoPtr->fetch_add(1, std::memory_order_seq_cst);
-                m_state->on_vkQueueFlushCommandsGOOGLE(&m_pool, queue, commandBuffer, dataSize,
-                                                       pData, context);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkQueueFlushCommandsGOOGLE(&m_pool, snapshotApiCallInfo, queue,
+                                                           commandBuffer, dataSize, pData, context);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkQueueFlushCommandsGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, commandBuffer,
-                        dataSize, pData);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkQueueFlushCommandsGOOGLE(&m_pool, snapshotApiCallInfo,
+                                                                    packet, packetLen, queue,
+                                                                    commandBuffer, dataSize, pData);
                 }
                 vkReadStream->clearPool();
                 break;
@@ -21728,6 +21616,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&descriptorPoolCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pDescriptorPools,
@@ -21812,18 +21701,18 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pendingDescriptorWriteCount,
                             (unsigned long long)pPendingDescriptorWrites);
                 }
-                m_state->on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
-                    &m_pool, queue, descriptorPoolCount, pDescriptorPools, descriptorSetCount,
-                    pSetLayouts, pDescriptorSetPoolIds, pDescriptorSetWhichPool,
-                    pDescriptorSetPendingAllocation, pDescriptorWriteStartingIndices,
-                    pendingDescriptorWriteCount, pPendingDescriptorWrites);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
+                        &m_pool, snapshotApiCallInfo, queue, descriptorPoolCount, pDescriptorPools,
+                        descriptorSetCount, pSetLayouts, pDescriptorSetPoolIds,
+                        pDescriptorSetWhichPool, pDescriptorSetPendingAllocation,
+                        pDescriptorWriteStartingIndices, pendingDescriptorWriteCount,
+                        pPendingDescriptorWrites);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueueCommitDescriptorSetUpdatesGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, descriptorPoolCount,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, queue, descriptorPoolCount,
                         pDescriptorPools, descriptorSetCount, pSetLayouts, pDescriptorSetPoolIds,
                         pDescriptorSetWhichPool, pDescriptorSetPendingAllocation,
                         pDescriptorWriteStartingIndices, pendingDescriptorWriteCount,
@@ -21846,6 +21735,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -21876,8 +21766,11 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)descriptorPool, (unsigned long long)pPoolIdCount,
                             (unsigned long long)pPoolIds);
                 }
-                m_state->on_vkCollectDescriptorPoolIdsGOOGLE(&m_pool, device, descriptorPool,
-                                                             pPoolIdCount, pPoolIds);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkCollectDescriptorPoolIdsGOOGLE(&m_pool, snapshotApiCallInfo,
+                                                                 device, descriptorPool,
+                                                                 pPoolIdCount, pPoolIds);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write((uint32_t*)pPoolIdCount, sizeof(uint32_t));
                 // WARNING PTR CHECK
@@ -21887,12 +21780,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     vkStream->write((uint64_t*)pPoolIds, (*(pPoolIdCount)) * sizeof(uint64_t));
                 }
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCollectDescriptorPoolIdsGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorPool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, descriptorPool,
                         pPoolIdCount, pPoolIds);
                 }
                 vkReadStream->clearPool();
@@ -21912,6 +21802,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&waitSemaphoreCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 // WARNING PTR CHECK
@@ -21945,15 +21836,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)waitSemaphoreCount,
                             (unsigned long long)pWaitSemaphores, (unsigned long long)image);
                 }
-                m_state->on_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
-                    &m_pool, queue, waitSemaphoreCount, pWaitSemaphores, image);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
+                        &m_pool, snapshotApiCallInfo, queue, waitSemaphoreCount, pWaitSemaphores,
+                        image);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, waitSemaphoreCount,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, queue, waitSemaphoreCount,
                         pWaitSemaphores, image);
                 }
                 vkReadStream->clearPool();
@@ -21974,6 +21865,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 // No unbox for commandBuffer
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
@@ -21997,15 +21889,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)deviceMemory, (unsigned long long)dataOffset,
                             (unsigned long long)dataSize);
                 }
-                m_state->on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(
-                    &m_pool, queue, commandBuffer, deviceMemory, dataOffset, dataSize, context);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(
+                        &m_pool, snapshotApiCallInfo, queue, commandBuffer, deviceMemory,
+                        dataOffset, dataSize, context);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkQueueFlushCommandsFromAuxMemoryGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, queue, commandBuffer,
                         deviceMemory, dataOffset, dataSize);
                 }
                 vkReadStream->clearPool();
@@ -22023,6 +21915,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -22032,21 +21925,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                     fprintf(stderr, "stream %p: call vkGetBlobGOOGLE 0x%llx 0x%llx \n", ioStream,
                             (unsigned long long)device, (unsigned long long)memory);
                 }
-                VkResult vkGetBlobGOOGLE_VkResult_return = (VkResult)0;
-                vkGetBlobGOOGLE_VkResult_return =
-                    m_state->on_vkGetBlobGOOGLE(&m_pool, device, memory);
+                VkResult vkGetBlobGOOGLE_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetBlobGOOGLE_VkResult_return =
+                        m_state->on_vkGetBlobGOOGLE(&m_pool, snapshotApiCallInfo, device, memory);
+                }
                 if ((vkGetBlobGOOGLE_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetBlobGOOGLE_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetBlobGOOGLE_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkGetBlobGOOGLE(snapshotTraceBegin, snapshotTraceBytes,
-                                                         &m_pool, vkGetBlobGOOGLE_VkResult_return,
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkGetBlobGOOGLE(&m_pool, snapshotApiCallInfo, packet,
+                                                         packetLen, vkGetBlobGOOGLE_VkResult_return,
                                                          device, memory);
                 }
                 vkReadStream->clearPool();
@@ -22076,6 +21968,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -22213,18 +22106,18 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pBufferViews,
                             (unsigned long long)pInlineUniformBlockData);
                 }
-                m_state->on_vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-                    &m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount,
-                    bufferInfoCount, bufferViewCount, inlineUniformBlockCount,
-                    pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices,
-                    pImageInfos, pBufferInfos, pBufferViews, pInlineUniformBlockData);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
+                        &m_pool, snapshotApiCallInfo, device, descriptorSet,
+                        descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount,
+                        inlineUniformBlockCount, pImageInfoEntryIndices, pBufferInfoEntryIndices,
+                        pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews,
+                        pInlineUniformBlockData);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, device, descriptorSet,
                         descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount,
                         inlineUniformBlockCount, pImageInfoEntryIndices, pBufferInfoEntryIndices,
                         pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews,
@@ -22247,6 +22140,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
+                auto vk = dispatch_VkQueue(queue);
                 memcpy((uint32_t*)&submitCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
                 vkReadStream->alloc((void**)&pSubmits,
@@ -22272,15 +22166,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)queue, (unsigned long long)submitCount,
                         (unsigned long long)pSubmits, (unsigned long long)fence);
                 }
-                m_state->on_vkQueueSubmitAsync2GOOGLE(&m_pool, queue, submitCount, pSubmits, fence);
+                if (CC_LIKELY(vk)) {
+                    m_state->on_vkQueueSubmitAsync2GOOGLE(&m_pool, snapshotApiCallInfo, queue,
+                                                          submitCount, pSubmits, fence);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
-                    m_state->snapshot()->vkQueueSubmitAsync2GOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, submitCount,
-                        pSubmits, fence);
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->vkQueueSubmitAsync2GOOGLE(&m_pool, snapshotApiCallInfo,
+                                                                   packet, packetLen, queue,
+                                                                   submitCount, pSubmits, fence);
                 }
                 vkReadStream->clearPool();
                 if (m_queueSubmitWithCommandsEnabled)
@@ -22298,6 +22192,7 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
+                auto vk = dispatch_VkDevice(device);
                 uint64_t cgen_var_1;
                 memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
@@ -22310,21 +22205,20 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             ioStream, (unsigned long long)device, (unsigned long long)semaphore,
                             (unsigned long long)syncId);
                 }
-                VkResult vkGetSemaphoreGOOGLE_VkResult_return = (VkResult)0;
-                vkGetSemaphoreGOOGLE_VkResult_return =
-                    m_state->on_vkGetSemaphoreGOOGLE(&m_pool, device, semaphore, syncId);
+                VkResult vkGetSemaphoreGOOGLE_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetSemaphoreGOOGLE_VkResult_return = m_state->on_vkGetSemaphoreGOOGLE(
+                        &m_pool, snapshotApiCallInfo, device, semaphore, syncId);
+                }
                 if ((vkGetSemaphoreGOOGLE_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkGetSemaphoreGOOGLE_VkResult_return, opcode, context);
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetSemaphoreGOOGLE_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetSemaphoreGOOGLE(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetSemaphoreGOOGLE_VkResult_return, device, semaphore, syncId);
                 }
                 vkReadStream->clearPool();
@@ -22410,16 +22304,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)width, (unsigned long long)height,
                             (unsigned long long)depth);
                 }
-                vk->vkCmdTraceRaysKHR(unboxed_commandBuffer, pRaygenShaderBindingTable,
-                                      pMissShaderBindingTable, pHitShaderBindingTable,
-                                      pCallableShaderBindingTable, width, height, depth);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdTraceRaysKHR(unboxed_commandBuffer, pRaygenShaderBindingTable,
+                                          pMissShaderBindingTable, pHitShaderBindingTable,
+                                          pCallableShaderBindingTable, width, height, depth);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdTraceRaysKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable,
                         pCallableShaderBindingTable, width, height, depth);
                 }
@@ -22507,10 +22400,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pCreateInfos, (unsigned long long)pAllocator,
                             (unsigned long long)pPipelines);
                 }
-                VkResult vkCreateRayTracingPipelinesKHR_VkResult_return = (VkResult)0;
-                vkCreateRayTracingPipelinesKHR_VkResult_return = vk->vkCreateRayTracingPipelinesKHR(
-                    unboxed_device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos,
-                    pAllocator, pPipelines);
+                VkResult vkCreateRayTracingPipelinesKHR_VkResult_return =
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkCreateRayTracingPipelinesKHR_VkResult_return =
+                        vk->vkCreateRayTracingPipelinesKHR(unboxed_device, deferredOperation,
+                                                           pipelineCache, createInfoCount,
+                                                           pCreateInfos, pAllocator, pPipelines);
+                }
                 if ((vkCreateRayTracingPipelinesKHR_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
                 m_state->on_CheckOutOfMemory(vkCreateRayTracingPipelinesKHR_VkResult_return, opcode,
@@ -22525,12 +22422,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 vkStream->write(&vkCreateRayTracingPipelinesKHR_VkResult_return, sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCreateRayTracingPipelinesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkCreateRayTracingPipelinesKHR_VkResult_return, device, deferredOperation,
                         pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                 }
@@ -22582,10 +22476,12 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)dataSize, (unsigned long long)pData);
                 }
                 VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return =
-                    (VkResult)0;
-                vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return =
-                    vk->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
-                        unboxed_device, pipeline, firstGroup, groupCount, dataSize, pData);
+                    VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return =
+                        vk->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
+                            unboxed_device, pipeline, firstGroup, groupCount, dataSize, pData);
+                }
                 if ((vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return) ==
                     VK_ERROR_DEVICE_LOST)
                     m_state->on_DeviceLost();
@@ -22597,12 +22493,9 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 vkStream->write(&vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return,
                                 sizeof(VkResult));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return, device,
                         pipeline, firstGroup, groupCount, dataSize, pData);
                 }
@@ -22681,16 +22574,15 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                             (unsigned long long)pCallableShaderBindingTable,
                             (unsigned long long)indirectDeviceAddress);
                 }
-                vk->vkCmdTraceRaysIndirectKHR(unboxed_commandBuffer, pRaygenShaderBindingTable,
-                                              pMissShaderBindingTable, pHitShaderBindingTable,
-                                              pCallableShaderBindingTable, indirectDeviceAddress);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdTraceRaysIndirectKHR(
+                        unboxed_commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable,
+                        pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdTraceRaysIndirectKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable,
                         pCallableShaderBindingTable, indirectDeviceAddress);
                 }
@@ -22732,19 +22624,18 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                 }
                 VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return =
                     (VkDeviceSize)0;
-                vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return =
-                    vk->vkGetRayTracingShaderGroupStackSizeKHR(unboxed_device, pipeline, group,
-                                                               groupShader);
+                if (CC_LIKELY(vk)) {
+                    vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return =
+                        vk->vkGetRayTracingShaderGroupStackSizeKHR(unboxed_device, pipeline, group,
+                                                                   groupShader);
+                }
                 vkStream->unsetHandleMapping();
                 vkStream->write(&vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return,
                                 sizeof(VkDeviceSize));
                 vkStream->commitWrite();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkGetRayTracingShaderGroupStackSizeKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen,
                         vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return, device,
                         pipeline, group, groupShader);
                 }
@@ -22776,15 +22667,14 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
                         ioStream, (unsigned long long)commandBuffer,
                         (unsigned long long)pipelineStackSize);
                 }
-                vk->vkCmdSetRayTracingPipelineStackSizeKHR(unboxed_commandBuffer,
-                                                           pipelineStackSize);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetRayTracingPipelineStackSizeKHR(unboxed_commandBuffer,
+                                                               pipelineStackSize);
+                }
                 vkStream->unsetHandleMapping();
-                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) -
-                                         (uintptr_t)snapshotTraceBegin);
-                size_t snapshotTraceBytes = vkReadStream->endTrace();
-                if (m_state->snapshotsEnabled()) {
+                if (m_snapshotsEnabled) {
                     m_state->snapshot()->vkCmdSetRayTracingPipelineStackSizeKHR(
-                        snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer,
+                        &m_pool, snapshotApiCallInfo, packet, packetLen, commandBuffer,
                         pipelineStackSize);
                 }
                 vkReadStream->clearPool();
@@ -22794,16 +22684,22 @@ size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream,
             }
 #endif
             default: {
+                if (m_snapshotsEnabled) {
+                    m_state->snapshot()->destroyApiCallInfoIfUnused(snapshotApiCallInfo);
+                }
+
                 m_pool.freeAll();
                 return ptr - (unsigned char*)buf;
             }
         }
+
+        if (m_snapshotsEnabled) {
+            m_state->snapshot()->destroyApiCallInfoIfUnused(snapshotApiCallInfo);
+        }
+
         ptr += packetLen;
         vkStream->clearPool();
     }
-    if (m_forSnapshotLoad) {
-        m_state->clearCreatedHandlesForSnapshotLoad();
-    }
     m_pool.freeAll();
     return ptr - (unsigned char*)buf;
     ;
diff --git a/host/vulkan/VkDecoderGlobalState.cpp b/host/vulkan/VkDecoderGlobalState.cpp
index 9a4c1a363..69ce78a2c 100644
--- a/host/vulkan/VkDecoderGlobalState.cpp
+++ b/host/vulkan/VkDecoderGlobalState.cpp
@@ -21,8 +21,10 @@
 #include <unordered_map>
 #include <vector>
 
-#include "ExternalObjectManager.h"
+#include "FrameBuffer.h"
+#include "GraphicsDriverLock.h"
 #include "RenderThreadInfoVk.h"
+#include "TrivialStream.h"
 #include "VkAndroidNativeBuffer.h"
 #include "VkCommonOperations.h"
 #include "VkDecoderContext.h"
@@ -30,16 +32,15 @@
 #include "VkDecoderSnapshot.h"
 #include "VkDecoderSnapshotUtils.h"
 #include "VkEmulatedPhysicalDeviceMemory.h"
+#include "VkEmulatedPhysicalDeviceQueue.h"
+#include "VulkanBoxedHandles.h"
 #include "VulkanDispatch.h"
 #include "VulkanStream.h"
-#include "aemu/base/ManagedDescriptor.hpp"
 #include "aemu/base/Optional.h"
-#include "aemu/base/containers/EntityManager.h"
-#include "aemu/base/containers/HybridEntityManager.h"
+#include "aemu/base/ThreadAnnotations.h"
 #include "aemu/base/containers/Lookup.h"
 #include "aemu/base/files/Stream.h"
 #include "aemu/base/memory/SharedMemory.h"
-#include "aemu/base/synchronization/ConditionVariable.h"
 #include "aemu/base/synchronization/Lock.h"
 #include "aemu/base/system/System.h"
 #include "common/goldfish_vk_deepcopy.h"
@@ -60,6 +61,7 @@
 #include "vulkan/emulated_textures/CompressedImageInfo.h"
 #include "vulkan/emulated_textures/GpuDecompressionPipeline.h"
 #include "vulkan/vk_enum_string_helper.h"
+#include "vulkan/vulkan_core.h"
 
 #ifndef _WIN32
 #include <unistd.h>
@@ -77,16 +79,20 @@
     }
 #endif
 
+// Verbose logging only when ANDROID_EMU_VK_LOG_CALLS is set
+#define LOG_CALLS_VERBOSE(fmt, ...)  \
+    if (mLogging) {                  \
+        VERBOSE(fmt, ##__VA_ARGS__); \
+    }
+
 #include <climits>
 
 namespace gfxstream {
 namespace vk {
 
 using android::base::AutoLock;
-using android::base::ConditionVariable;
 using android::base::DescriptorType;
 using android::base::Lock;
-using android::base::ManagedDescriptor;
 using android::base::MetricEventBadPacketLength;
 using android::base::MetricEventDuplicateSequenceNum;
 using android::base::MetricEventVulkanOutOfMemory;
@@ -193,193 +199,21 @@ static constexpr uint32_t kMinVersion = VK_MAKE_VERSION(1, 0, 0);
 static constexpr uint64_t kPageSizeforBlob = 4096;
 static constexpr uint64_t kPageMaskForBlob = ~(0xfff);
 
-static uint64_t hostBlobId = 0;
-
-// b/319729462
-// On snapshot load, thread local data is not available, thus we use a
-// fake context ID. We will eventually need to fix it once we start using
-// snapshot with virtio.
-static uint32_t kTemporaryContextIdForSnapshotLoading = 1;
-
-static std::unordered_set<std::string> kSnapshotAppAllowList = {"Chromium"};
-static std::unordered_set<std::string> kSnapshotEngineAllowList = {"ANGLE", "ace"};
-
-#define DEFINE_BOXED_HANDLE_TYPE_TAG(type) Tag_##type,
-
-enum BoxedHandleTypeTag {
-    Tag_Invalid = 0,
-    GOLDFISH_VK_LIST_HANDLE_TYPES_BY_STAGE(DEFINE_BOXED_HANDLE_TYPE_TAG)
-
-    // additional generic tag
-    Tag_VkGeneric = 1001,
-};
-
-template <class T>
-class BoxedHandleManager {
-   public:
-    // The hybrid entity manager uses a sequence lock to protect access to
-    // a working set of 16000 handles, allowing us to avoid using a regular
-    // lock for those. Performance is degraded when going over this number,
-    // as it will then fall back to a std::map.
-    //
-    // We use 16000 as the max number of live handles to track; we don't
-    // expect the system to go over 16000 total live handles, outside some
-    // dEQP object management tests.
-    using Store = android::base::HybridEntityManager<16000, uint64_t, T>;
-
-    Lock lock;
-    mutable Store store;
-    std::unordered_map<uint64_t, uint64_t> reverseMap;
-    struct DelayedRemove {
-        uint64_t handle;
-        std::function<void()> callback;
-    };
-    std::unordered_map<VkDevice, std::vector<DelayedRemove>> delayedRemoves;
-
-    void clear() {
-        reverseMap.clear();
-        store.clear();
-    }
-
-    uint64_t add(const T& item, BoxedHandleTypeTag tag) {
-        auto res = (uint64_t)store.add(item, (size_t)tag);
-        AutoLock l(lock);
-        reverseMap[(uint64_t)(item.underlying)] = res;
-        return res;
-    }
-
-    uint64_t addFixed(uint64_t handle, const T& item, BoxedHandleTypeTag tag) {
-        auto res = (uint64_t)store.addFixed(handle, item, (size_t)tag);
-        AutoLock l(lock);
-        reverseMap[(uint64_t)(item.underlying)] = res;
-        return res;
-    }
-
-    void update(uint64_t handle, const T& item, BoxedHandleTypeTag tag) {
-        auto storedItem = store.get(handle);
-        uint64_t oldHandle = (uint64_t)storedItem->underlying;
-        *storedItem = item;
-        AutoLock l(lock);
-        if (oldHandle) {
-            reverseMap.erase(oldHandle);
-        }
-        reverseMap[(uint64_t)(item.underlying)] = handle;
-    }
-
-    void remove(uint64_t h) {
-        auto item = get(h);
-        if (item) {
-            AutoLock l(lock);
-            reverseMap.erase((uint64_t)(item->underlying));
-        }
-        store.remove(h);
-    }
-
-    void removeDelayed(uint64_t h, VkDevice device, std::function<void()> callback) {
-        AutoLock l(lock);
-        delayedRemoves[device].push_back({h, callback});
-    }
-
-    void processDelayedRemovesGlobalStateLocked(VkDevice device) {
-        AutoLock l(lock);
-        auto it = delayedRemoves.find(device);
-        if (it == delayedRemoves.end()) return;
-        auto& delayedRemovesList = it->second;
-        for (const auto& r : delayedRemovesList) {
-            auto h = r.handle;
-            // VkDecoderGlobalState is already locked when callback is called.
-            if (r.callback) {
-                r.callback();
-            }
-            store.remove(h);
-        }
-        delayedRemovesList.clear();
-        delayedRemoves.erase(it);
-    }
-
-    T* get(uint64_t h) { return (T*)store.get_const(h); }
-
-    uint64_t getBoxedFromUnboxedLocked(uint64_t unboxed) {
-        auto* res = android::base::find(reverseMap, unboxed);
-        if (!res) return 0;
-        return *res;
-    }
-};
-
-struct OrderMaintenanceInfo {
-    uint32_t sequenceNumber = 0;
-    Lock lock;
-    ConditionVariable cv;
-
-    uint32_t refcount = 1;
-
-    void incRef() { __atomic_add_fetch(&refcount, 1, __ATOMIC_SEQ_CST); }
-
-    bool decRef() { return 0 == __atomic_sub_fetch(&refcount, 1, __ATOMIC_SEQ_CST); }
-};
-
-static void acquireOrderMaintInfo(OrderMaintenanceInfo* ord) {
-    if (!ord) return;
-    ord->incRef();
-}
-
-static void releaseOrderMaintInfo(OrderMaintenanceInfo* ord) {
-    if (!ord) return;
-    if (ord->decRef()) delete ord;
-}
-
-template <class T>
-class DispatchableHandleInfo {
-   public:
-    T underlying;
-    VulkanDispatch* dispatch = nullptr;
-    bool ownDispatch = false;
-    OrderMaintenanceInfo* ordMaintInfo = nullptr;
-    VulkanMemReadingStream* readStream = nullptr;
-};
-
-static BoxedHandleManager<DispatchableHandleInfo<uint64_t>> sBoxedHandleManager;
-
-struct ReadStreamRegistry {
-    Lock mLock;
-
-    std::vector<VulkanMemReadingStream*> freeStreams;
-
-    ReadStreamRegistry() { freeStreams.reserve(100); };
-
-    VulkanMemReadingStream* pop(const gfxstream::host::FeatureSet& features) {
-        AutoLock lock(mLock);
-        if (freeStreams.empty()) {
-            return new VulkanMemReadingStream(nullptr, features);
-        } else {
-            VulkanMemReadingStream* res = freeStreams.back();
-            freeStreams.pop_back();
-            return res;
-        }
-    }
-
-    void push(VulkanMemReadingStream* stream) {
-        AutoLock lock(mLock);
-        freeStreams.push_back(stream);
-    }
-};
-
-static ReadStreamRegistry sReadStreamRegistry;
+static std::atomic<uint64_t> sNextHostBlobId{1};
 
 class VkDecoderGlobalState::Impl {
    public:
-    Impl()
+    Impl(VkEmulation* emulation)
         : m_vk(vkDispatch()),
-          m_emu(getGlobalVkEmulation()),
-          mRenderDocWithMultipleVkInstances(m_emu->guestRenderDoc.get()) {
-        mSnapshotsEnabled = m_emu->features.VulkanSnapshots.enabled;
+          m_vkEmulation(emulation),
+          mRenderDocWithMultipleVkInstances(m_vkEmulation->getRenderDoc()) {
+        mSnapshotsEnabled = m_vkEmulation->getFeatures().VulkanSnapshots.enabled;
         mBatchedDescriptorSetUpdateEnabled =
-            m_emu->features.VulkanBatchedDescriptorSetUpdate.enabled;
+            m_vkEmulation->getFeatures().VulkanBatchedDescriptorSetUpdate.enabled;
         mVkCleanupEnabled =
             android::base::getEnvironmentVariable("ANDROID_EMU_VK_NO_CLEANUP") != "1";
         mLogging = android::base::getEnvironmentVariable("ANDROID_EMU_VK_LOG_CALLS") == "1";
         mVerbosePrints = android::base::getEnvironmentVariable("ANDROID_EMUGL_VERBOSE") == "1";
-        mEnableVirtualVkQueue = m_emu->features.VulkanVirtualQueue.enabled;
 
         if (get_emugl_address_space_device_control_ops().control_get_hw_funcs &&
             get_emugl_address_space_device_control_ops().control_get_hw_funcs()) {
@@ -392,9 +226,8 @@ class VkDecoderGlobalState::Impl {
     ~Impl() = default;
 
     // Resets all internal tracking info.
-    // Assumes that the heavyweight cleanup operations
-    // have already happened.
-    void clear() {
+    // Assumes that the heavyweight cleanup operations have already happened.
+    void clearLocked() REQUIRES(mMutex) {
         mInstanceInfo.clear();
         mPhysdevInfo.clear();
         mDeviceInfo.clear();
@@ -410,6 +243,7 @@ class VkDecoderGlobalState::Impl {
         mMemoryInfo.clear();
         mShaderModuleInfo.clear();
         mPipelineCacheInfo.clear();
+        mPipelineLayoutInfo.clear();
         mPipelineInfo.clear();
         mRenderPassInfo.clear();
         mFramebufferInfo.clear();
@@ -421,10 +255,9 @@ class VkDecoderGlobalState::Impl {
 #endif
         mDescriptorUpdateTemplateInfo.clear();
 
-        mCreatedHandlesForSnapshotLoad.clear();
-        mCreatedHandlesForSnapshotLoadIndex = 0;
-
         sBoxedHandleManager.clear();
+
+        mSnapshot.clear();
     }
 
     bool snapshotsEnabled() const { return mSnapshotsEnabled; }
@@ -433,52 +266,51 @@ class VkDecoderGlobalState::Impl {
 
     bool vkCleanupEnabled() const { return mVkCleanupEnabled; }
 
-    const gfxstream::host::FeatureSet& getFeatures() const { return m_emu->features; }
-
-    StateBlock createSnapshotStateBlock(VkDevice unboxed_device) {
-            const auto& device = unboxed_device;
-            const auto& deviceInfo = android::base::find(mDeviceInfo, device);
-            const auto physicalDevice = deviceInfo->physicalDevice;
-            const auto& physicalDeviceInfo = android::base::find(mPhysdevInfo, physicalDevice);
-            const auto& instanceInfo = android::base::find(mInstanceInfo, physicalDeviceInfo->instance);
-
-            VulkanDispatch* ivk = dispatch_VkInstance(instanceInfo->boxed);
-            VulkanDispatch* dvk = dispatch_VkDevice(deviceInfo->boxed);
-
-            StateBlock stateBlock{
-                .physicalDevice = physicalDevice,
-                .physicalDeviceInfo = physicalDeviceInfo,
-                .device = device,
-                .deviceDispatch = dvk,
-                .queue = VK_NULL_HANDLE,
-                .commandPool = VK_NULL_HANDLE,
-            };
+    const gfxstream::host::FeatureSet& getFeatures() const { return m_vkEmulation->getFeatures(); }
+
+    StateBlock createSnapshotStateBlock(VkDevice unboxed_device) REQUIRES(mMutex) {
+        const auto& device = unboxed_device;
+        const auto& deviceInfo = android::base::find(mDeviceInfo, device);
+        const auto physicalDevice = deviceInfo->physicalDevice;
+        const auto& physicalDeviceInfo = android::base::find(mPhysdevInfo, physicalDevice);
+        const auto& instanceInfo = android::base::find(mInstanceInfo, physicalDeviceInfo->instance);
+
+        VulkanDispatch* ivk = dispatch_VkInstance(instanceInfo->boxed);
+        VulkanDispatch* dvk = dispatch_VkDevice(deviceInfo->boxed);
+
+        StateBlock stateBlock{
+            .physicalDevice = physicalDevice,
+            .physicalDeviceInfo = physicalDeviceInfo,
+            .device = device,
+            .deviceDispatch = dvk,
+            .queue = VK_NULL_HANDLE,
+            .commandPool = VK_NULL_HANDLE,
+        };
 
-            uint32_t queueFamilyCount = 0;
-            ivk->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount,
-                                                          nullptr);
-            std::vector<VkQueueFamilyProperties> queueFamilyProps(queueFamilyCount);
-            ivk->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount,
-                                                          queueFamilyProps.data());
-            uint32_t queueFamilyIndex = 0;
-            for (auto queue : deviceInfo->queues) {
-                int idx = queue.first;
-                if ((queueFamilyProps[idx].queueFlags & VK_QUEUE_GRAPHICS_BIT) == 0) {
-                    continue;
-                }
-                stateBlock.queue = queue.second[0];
-                queueFamilyIndex = idx;
-                break;
+        uint32_t queueFamilyCount = 0;
+        ivk->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount, nullptr);
+        std::vector<VkQueueFamilyProperties> queueFamilyProps(queueFamilyCount);
+        ivk->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount,
+                                                      queueFamilyProps.data());
+        uint32_t queueFamilyIndex = 0;
+        for (auto queue : deviceInfo->queues) {
+            int idx = queue.first;
+            if ((queueFamilyProps[idx].queueFlags & VK_QUEUE_GRAPHICS_BIT) == 0) {
+                continue;
             }
+            stateBlock.queue = queue.second[0];
+            queueFamilyIndex = idx;
+            break;
+        }
 
-            VkCommandPoolCreateInfo commandPoolCi = {
-                VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
-                0,
-                VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
-                queueFamilyIndex,
-            };
-            dvk->vkCreateCommandPool(device, &commandPoolCi, nullptr, &stateBlock.commandPool);
-            return stateBlock;
+        VkCommandPoolCreateInfo commandPoolCi = {
+            VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
+            0,
+            VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
+            queueFamilyIndex,
+        };
+        dvk->vkCreateCommandPool(device, &commandPoolCi, nullptr, &stateBlock.commandPool);
+        return stateBlock;
     }
 
     void releaseSnapshotStateBlock(const StateBlock* stateBlock) {
@@ -486,14 +318,18 @@ class VkDecoderGlobalState::Impl {
     }
 
     void save(android::base::Stream* stream) {
+        VERBOSE("VulkanSnapshots save (begin)");
+        std::lock_guard<std::mutex> lock(mMutex);
+
         mSnapshotState = SnapshotState::Saving;
 
-#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
+#ifdef CONFIG_AEMU
         if (!mInstanceInfo.empty()) {
             get_emugl_vm_operations().setStatSnapshotUseVulkan();
         }
 #endif
 
+        VERBOSE("snapshot save: setup internal structures");
         {
             std::unordered_map<VkDevice, uint32_t> deviceToContextId;
             for (const auto& [device, deviceInfo] : mDeviceInfo) {
@@ -510,7 +346,8 @@ class VkDecoderGlobalState::Impl {
             }
         }
 
-        snapshot()->save(stream);
+        VERBOSE("snapshot save: replay command stream");
+        snapshot()->saveReplayBuffers(stream);
 
         // Save mapped memory
         uint32_t memoryCount = 0;
@@ -519,6 +356,7 @@ class VkDecoderGlobalState::Impl {
                 memoryCount++;
             }
         }
+        VERBOSE("snapshot save: mapped memory");
         stream->putBe32(memoryCount);
         for (const auto& it : mMemoryInfo) {
             if (!it.second.ptr) {
@@ -533,6 +371,7 @@ class VkDecoderGlobalState::Impl {
         // Set up VK structs to snapshot other Vulkan objects
         // TODO(b/323064243): group all images from the same device and reuse queue / command pool
 
+        VERBOSE("snapshot save: image content");
         std::vector<VkImage> sortedBoxedImages;
         for (const auto& imageIte : mImageInfo) {
             sortedBoxedImages.push_back(unboxed_to_boxed_non_dispatchable_VkImage(imageIte.first));
@@ -543,7 +382,7 @@ class VkDecoderGlobalState::Impl {
         for (const auto& boxedImage : sortedBoxedImages) {
             auto unboxedImage = try_unbox_VkImage(boxedImage);
             if (unboxedImage == VK_NULL_HANDLE) {
-                //TODO(b/294277842): should return an error here.
+                // TODO(b/294277842): should return an error here.
                 continue;
             }
             const ImageInfo& imageInfo = mImageInfo[unboxedImage];
@@ -560,6 +399,7 @@ class VkDecoderGlobalState::Impl {
         }
 
         // snapshot buffers
+        VERBOSE("snapshot save: buffers");
         std::vector<VkBuffer> sortedBoxedBuffers;
         for (const auto& bufferIte : mBufferInfo) {
             sortedBoxedBuffers.push_back(
@@ -569,7 +409,7 @@ class VkDecoderGlobalState::Impl {
         for (const auto& boxedBuffer : sortedBoxedBuffers) {
             auto unboxedBuffer = try_unbox_VkBuffer(boxedBuffer);
             if (unboxedBuffer == VK_NULL_HANDLE) {
-                //TODO(b/294277842): should return an error here.
+                // TODO(b/294277842): should return an error here.
                 continue;
             }
             const BufferInfo& bufferInfo = mBufferInfo[unboxedBuffer];
@@ -585,6 +425,7 @@ class VkDecoderGlobalState::Impl {
         }
 
         // snapshot descriptors
+        VERBOSE("snapshot save: descriptors");
         std::vector<VkDescriptorPool> sortedBoxedDescriptorPools;
         for (const auto& descriptorPoolIte : mDescriptorPoolInfo) {
             auto boxed =
@@ -597,7 +438,7 @@ class VkDecoderGlobalState::Impl {
             const DescriptorPoolInfo& poolInfo = mDescriptorPoolInfo[unboxedDescriptorPool];
 
             for (uint64_t poolId : poolInfo.poolIds) {
-                DispatchableHandleInfo<uint64_t>* setHandleInfo = sBoxedHandleManager.get(poolId);
+                BoxedHandleInfo* setHandleInfo = sBoxedHandleManager.get(poolId);
                 bool allocated = setHandleInfo->underlying != 0;
                 stream->putByte(allocated);
                 if (!allocated) {
@@ -642,10 +483,10 @@ class VkDecoderGlobalState::Impl {
                 // regardless, we might hit a Vulkan validation error because the new image might
                 // have the "usage" flag that is unsuitable to bind to descriptors.
                 std::vector<std::pair<int, int>> validWriteIndices;
-                for (int bindingIdx = 0; bindingIdx < descriptorSetInfo.allWrites.size();
+                for (int bindingIdx = 0; bindingIdx < (int)descriptorSetInfo.allWrites.size();
                      bindingIdx++) {
                     for (int bindingElemIdx = 0;
-                         bindingElemIdx < descriptorSetInfo.allWrites[bindingIdx].size();
+                         bindingElemIdx < (int)descriptorSetInfo.allWrites[bindingIdx].size();
                          bindingElemIdx++) {
                         const auto& entry = descriptorSetInfo.allWrites[bindingIdx][bindingElemIdx];
                         if (entry.writeType == DescriptorSetInfo::DescriptorWriteType::Empty) {
@@ -653,7 +494,7 @@ class VkDecoderGlobalState::Impl {
                         }
                         int dependencyObjCount =
                             descriptorDependencyObjectCount(entry.descriptorType);
-                        if (entry.alives.size() < dependencyObjCount) {
+                        if ((int)entry.alives.size() < dependencyObjCount) {
                             continue;
                         }
                         bool isValid = true;
@@ -721,6 +562,7 @@ class VkDecoderGlobalState::Impl {
         }
 
         // Fences
+        VERBOSE("snapshot save: fences");
         std::vector<VkFence> unsignaledFencesBoxed;
         for (const auto& fence : mFenceInfo) {
             if (!fence.second.boxed) {
@@ -736,20 +578,26 @@ class VkDecoderGlobalState::Impl {
         stream->putBe64(unsignaledFencesBoxed.size());
         stream->write(unsignaledFencesBoxed.data(), unsignaledFencesBoxed.size() * sizeof(VkFence));
         mSnapshotState = SnapshotState::Normal;
+        VERBOSE("VulkanSnapshots save (end)");
     }
 
     void load(android::base::Stream* stream, GfxApiLogger& gfxLogger,
               HealthMonitor<>* healthMonitor) {
         // assume that we already destroyed all instances
         // from FrameBuffer's onLoad method.
+        VERBOSE("VulkanSnapshots load (begin)");
 
         // destroy all current internal data structures
-        clear();
-        mSnapshotState = SnapshotState::Loading;
-
-        // This needs to happen before the replay in the decoder so that virtio gpu context ids
-        // are available for operations involving `ExternalObjectManager`.
+        VERBOSE("snapshot load: setup internal structures");
         {
+            std::lock_guard<std::mutex> lock(mMutex);
+
+            clearLocked();
+
+            mSnapshotState = SnapshotState::Loading;
+
+            // This needs to happen before the replay in the decoder so that virtio gpu context ids
+            // are available for operations involving `ExternalObjectManager`.
             mSnapshotLoadVkDeviceToVirtioCpuContextId.emplace();
             const uint64_t count = stream->getBe64();
             for (uint64_t i = 0; i < count; i++) {
@@ -760,237 +608,242 @@ class VkDecoderGlobalState::Impl {
             }
         }
 
-        android::base::BumpPool bumpPool;
-        // this part will replay in the decoder
-        snapshot()->load(stream, gfxLogger, healthMonitor);
-        // load mapped memory
-        uint32_t memoryCount = stream->getBe32();
-        for (uint32_t i = 0; i < memoryCount; i++) {
-            VkDeviceMemory boxedMemory = reinterpret_cast<VkDeviceMemory>(stream->getBe64());
-            VkDeviceMemory unboxedMemory = unbox_VkDeviceMemory(boxedMemory);
-            auto it = mMemoryInfo.find(unboxedMemory);
-            if (it == mMemoryInfo.end()) {
-                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-                    << "Snapshot load failure: cannot find memory handle for " << boxedMemory;
-            }
-            VkDeviceSize size = stream->getBe64();
-            if (size != it->second.size || !it->second.ptr) {
-                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-                    << "Snapshot load failure: memory size does not match for " << boxedMemory;
-            }
-            stream->read(it->second.ptr, size);
-        }
-        // Set up VK structs to snapshot other Vulkan objects
-        // TODO(b/323064243): group all images from the same device and reuse queue / command pool
-
-        std::vector<VkImage> sortedBoxedImages;
-        for (const auto& imageIte : mImageInfo) {
-            sortedBoxedImages.push_back(unboxed_to_boxed_non_dispatchable_VkImage(imageIte.first));
-        }
-        sort(sortedBoxedImages.begin(), sortedBoxedImages.end());
-        for (const auto& boxedImage : sortedBoxedImages) {
-            auto unboxedImage = unbox_VkImage(boxedImage);
-            ImageInfo& imageInfo = mImageInfo[unboxedImage];
-            if (imageInfo.memory == VK_NULL_HANDLE) {
-                continue;
-            }
-            // Playback doesn't recover image layout. We need to do it here.
-            //
-            // Layout transform was done by vkCmdPipelineBarrier but we don't record such command
-            // directly. Instead, we memorize the current layout and add our own
-            // vkCmdPipelineBarrier after load.
-            //
-            // We do the layout transform in loadImageContent. There are still use cases where it
-            // should recover the layout but does not.
-            //
-            // TODO(b/323059453): fix corner cases when image contents cannot be properly loaded.
-            imageInfo.layout = static_cast<VkImageLayout>(stream->getBe32());
-            StateBlock stateBlock = createSnapshotStateBlock(imageInfo.device);
-            // TODO(b/294277842): make sure the queue is empty before using.
-            loadImageContent(stream, &stateBlock, unboxedImage, &imageInfo);
-            releaseSnapshotStateBlock(&stateBlock);
-        }
-
-        // snapshot buffers
-        std::vector<VkBuffer> sortedBoxedBuffers;
-        for (const auto& bufferIte : mBufferInfo) {
-            sortedBoxedBuffers.push_back(
-                unboxed_to_boxed_non_dispatchable_VkBuffer(bufferIte.first));
-        }
-        sort(sortedBoxedBuffers.begin(), sortedBoxedBuffers.end());
-        for (const auto& boxedBuffer : sortedBoxedBuffers) {
-            auto unboxedBuffer = unbox_VkBuffer(boxedBuffer);
-            const BufferInfo& bufferInfo = mBufferInfo[unboxedBuffer];
-            if (bufferInfo.memory == VK_NULL_HANDLE) {
-                continue;
-            }
-            // TODO: add a special case for host mapped memory
-            StateBlock stateBlock = createSnapshotStateBlock(bufferInfo.device);
-            // TODO(b/294277842): make sure the queue is empty before using.
-            loadBufferContent(stream, &stateBlock, unboxedBuffer, &bufferInfo);
-            releaseSnapshotStateBlock(&stateBlock);
-        }
-
-        // snapshot descriptors
-        std::vector<VkDescriptorPool> sortedBoxedDescriptorPools;
-        for (const auto& descriptorPoolIte : mDescriptorPoolInfo) {
-            auto boxed =
-                unboxed_to_boxed_non_dispatchable_VkDescriptorPool(descriptorPoolIte.first);
-            sortedBoxedDescriptorPools.push_back(boxed);
+        // Replay command stream:
+        VERBOSE("snapshot load: replay command stream");
+        {
+            std::vector<uint64_t> handleReplayBuffer;
+            std::vector<uint8_t> decoderReplayBuffer;
+            VkDecoderSnapshot::loadReplayBuffers(stream, &handleReplayBuffer, &decoderReplayBuffer);
+
+            sBoxedHandleManager.replayHandles(handleReplayBuffer);
+
+            VkDecoder decoderForLoading;
+            // A decoder that is set for snapshot load will load up the created handles first,
+            // if any, allowing us to 'catch' the results as they are decoded.
+            decoderForLoading.setForSnapshotLoad(true);
+            TrivialStream trivialStream;
+
+            // TODO: This needs to be the puid seqno ptr
+            auto resources = ProcessResources::create();
+            VkDecoderContext context = {
+                .processName = nullptr,
+                .gfxApiLogger = &gfxLogger,
+                .healthMonitor = healthMonitor,
+            };
+            decoderForLoading.decode(decoderReplayBuffer.data(), decoderReplayBuffer.size(),
+                                     &trivialStream, resources.get(), context);
         }
-        sort(sortedBoxedDescriptorPools.begin(), sortedBoxedDescriptorPools.end());
-        for (const auto& boxedDescriptorPool : sortedBoxedDescriptorPools) {
-            auto unboxedDescriptorPool = unbox_VkDescriptorPool(boxedDescriptorPool);
-            const DescriptorPoolInfo& poolInfo = mDescriptorPoolInfo[unboxedDescriptorPool];
-
-            std::vector<VkDescriptorSetLayout> layouts;
-            std::vector<uint64_t> poolIds;
-            std::vector<VkWriteDescriptorSet> writeDescriptorSets;
-            std::vector<uint32_t> writeStartingIndices;
-
-            // Temporary structures for the pointers in VkWriteDescriptorSet.
-            // Use unique_ptr so that the pointers don't change when vector resizes.
-            std::vector<std::unique_ptr<VkDescriptorImageInfo>> tmpImageInfos;
-            std::vector<std::unique_ptr<VkDescriptorBufferInfo>> tmpBufferInfos;
-            std::vector<std::unique_ptr<VkBufferView>> tmpBufferViews;
 
-            for (uint64_t poolId : poolInfo.poolIds) {
-                bool allocated = stream->getByte();
-                if (!allocated) {
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+
+            // load mapped memory
+            VERBOSE("snapshot load: mapped memory");
+            uint32_t memoryCount = stream->getBe32();
+            for (uint32_t i = 0; i < memoryCount; i++) {
+                VkDeviceMemory boxedMemory = reinterpret_cast<VkDeviceMemory>(stream->getBe64());
+                VkDeviceMemory unboxedMemory = unbox_VkDeviceMemory(boxedMemory);
+                auto it = mMemoryInfo.find(unboxedMemory);
+                if (it == mMemoryInfo.end()) {
+                    GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                        << "Snapshot load failure: cannot find memory handle for " << boxedMemory;
+                }
+                VkDeviceSize size = stream->getBe64();
+                if (size != it->second.size || !it->second.ptr) {
+                    GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                        << "Snapshot load failure: memory size does not match for " << boxedMemory;
+                }
+                stream->read(it->second.ptr, size);
+            }
+            // Set up VK structs to snapshot other Vulkan objects
+            // TODO(b/323064243): group all images from the same device and reuse queue / command
+            // pool
+
+            VERBOSE("snapshot load: image content");
+            std::vector<VkImage> sortedBoxedImages;
+            for (const auto& imageIte : mImageInfo) {
+                sortedBoxedImages.push_back(
+                    unboxed_to_boxed_non_dispatchable_VkImage(imageIte.first));
+            }
+            sort(sortedBoxedImages.begin(), sortedBoxedImages.end());
+            for (const auto& boxedImage : sortedBoxedImages) {
+                auto unboxedImage = unbox_VkImage(boxedImage);
+                ImageInfo& imageInfo = mImageInfo[unboxedImage];
+                if (imageInfo.memory == VK_NULL_HANDLE) {
                     continue;
                 }
-                poolIds.push_back(poolId);
-                writeStartingIndices.push_back(writeDescriptorSets.size());
-                VkDescriptorSetLayout boxedLayout = (VkDescriptorSetLayout)stream->getBe64();
-                layouts.push_back(unbox_VkDescriptorSetLayout(boxedLayout));
-                uint64_t validWriteCount = stream->getBe64();
-                for (int write = 0; write < validWriteCount; write++) {
-                    uint32_t binding = stream->getBe32();
-                    uint32_t arrayElement = stream->getBe32();
-                    DescriptorSetInfo::DescriptorWriteType writeType =
-                        static_cast<DescriptorSetInfo::DescriptorWriteType>(stream->getBe32());
-                    VkDescriptorType descriptorType =
-                        static_cast<VkDescriptorType>(stream->getBe32());
-                    VkWriteDescriptorSet writeDescriptorSet = {
-                        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
-                        .dstSet = (VkDescriptorSet)poolId,
-                        .dstBinding = binding,
-                        .dstArrayElement = arrayElement,
-                        .descriptorCount = 1,
-                        .descriptorType = descriptorType,
-                    };
-                    switch (writeType) {
-                        case DescriptorSetInfo::DescriptorWriteType::ImageInfo: {
-                            tmpImageInfos.push_back(std::make_unique<VkDescriptorImageInfo>());
-                            writeDescriptorSet.pImageInfo = tmpImageInfos.back().get();
-                            VkDescriptorImageInfo& imageInfo = *tmpImageInfos.back();
-                            stream->read(&imageInfo, sizeof(imageInfo));
-                            imageInfo.imageView = descriptorTypeContainsImage(descriptorType)
-                                                      ? unbox_VkImageView(imageInfo.imageView)
-                                                      : 0;
-                            imageInfo.sampler = descriptorTypeContainsSampler(descriptorType)
-                                                    ? unbox_VkSampler(imageInfo.sampler)
-                                                    : 0;
-                        } break;
-                        case DescriptorSetInfo::DescriptorWriteType::BufferInfo: {
-                            tmpBufferInfos.push_back(std::make_unique<VkDescriptorBufferInfo>());
-                            writeDescriptorSet.pBufferInfo = tmpBufferInfos.back().get();
-                            VkDescriptorBufferInfo& bufferInfo = *tmpBufferInfos.back();
-                            stream->read(&bufferInfo, sizeof(bufferInfo));
-                            bufferInfo.buffer = unbox_VkBuffer(bufferInfo.buffer);
-                        } break;
-                        case DescriptorSetInfo::DescriptorWriteType::BufferView: {
-                            tmpBufferViews.push_back(std::make_unique<VkBufferView>());
-                            writeDescriptorSet.pTexelBufferView = tmpBufferViews.back().get();
-                            VkBufferView& bufferView = *tmpBufferViews.back();
-                            stream->read(&bufferView, sizeof(bufferView));
-                            bufferView = unbox_VkBufferView(bufferView);
-                        } break;
-                        case DescriptorSetInfo::DescriptorWriteType::InlineUniformBlock:
-                        case DescriptorSetInfo::DescriptorWriteType::AccelerationStructure:
-                            // TODO
-                            GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-                                << "Encountered pending inline uniform block or acceleration "
-                                   "structure "
-                                   "desc write, abort (NYI)";
-                        default:
-                            break;
+                // Playback doesn't recover image layout. We need to do it here.
+                //
+                // Layout transform was done by vkCmdPipelineBarrier but we don't record such
+                // command directly. Instead, we memorize the current layout and add our own
+                // vkCmdPipelineBarrier after load.
+                //
+                // We do the layout transform in loadImageContent. There are still use cases where
+                // it should recover the layout but does not.
+                //
+                // TODO(b/323059453): fix corner cases when image contents cannot be properly
+                // loaded.
+                imageInfo.layout = static_cast<VkImageLayout>(stream->getBe32());
+                StateBlock stateBlock = createSnapshotStateBlock(imageInfo.device);
+                // TODO(b/294277842): make sure the queue is empty before using.
+                loadImageContent(stream, &stateBlock, unboxedImage, &imageInfo);
+                releaseSnapshotStateBlock(&stateBlock);
+            }
+
+            // snapshot buffers
+            VERBOSE("snapshot load: buffers");
+            std::vector<VkBuffer> sortedBoxedBuffers;
+            for (const auto& bufferIte : mBufferInfo) {
+                sortedBoxedBuffers.push_back(
+                    unboxed_to_boxed_non_dispatchable_VkBuffer(bufferIte.first));
+            }
+            sort(sortedBoxedBuffers.begin(), sortedBoxedBuffers.end());
+            for (const auto& boxedBuffer : sortedBoxedBuffers) {
+                auto unboxedBuffer = unbox_VkBuffer(boxedBuffer);
+                const BufferInfo& bufferInfo = mBufferInfo[unboxedBuffer];
+                if (bufferInfo.memory == VK_NULL_HANDLE) {
+                    continue;
+                }
+                // TODO: add a special case for host mapped memory
+                StateBlock stateBlock = createSnapshotStateBlock(bufferInfo.device);
+                // TODO(b/294277842): make sure the queue is empty before using.
+                loadBufferContent(stream, &stateBlock, unboxedBuffer, &bufferInfo);
+                releaseSnapshotStateBlock(&stateBlock);
+            }
+
+            // snapshot descriptors
+            VERBOSE("snapshot load: descriptors");
+            android::base::BumpPool bumpPool;
+            std::vector<VkDescriptorPool> sortedBoxedDescriptorPools;
+            for (const auto& descriptorPoolIte : mDescriptorPoolInfo) {
+                auto boxed =
+                    unboxed_to_boxed_non_dispatchable_VkDescriptorPool(descriptorPoolIte.first);
+                sortedBoxedDescriptorPools.push_back(boxed);
+            }
+            sort(sortedBoxedDescriptorPools.begin(), sortedBoxedDescriptorPools.end());
+            for (const auto& boxedDescriptorPool : sortedBoxedDescriptorPools) {
+                auto unboxedDescriptorPool = unbox_VkDescriptorPool(boxedDescriptorPool);
+                const DescriptorPoolInfo& poolInfo = mDescriptorPoolInfo[unboxedDescriptorPool];
+
+                std::vector<VkDescriptorSetLayout> layouts;
+                std::vector<uint64_t> poolIds;
+                std::vector<VkWriteDescriptorSet> writeDescriptorSets;
+                std::vector<uint32_t> writeStartingIndices;
+
+                // Temporary structures for the pointers in VkWriteDescriptorSet.
+                // Use unique_ptr so that the pointers don't change when vector resizes.
+                std::vector<std::unique_ptr<VkDescriptorImageInfo>> tmpImageInfos;
+                std::vector<std::unique_ptr<VkDescriptorBufferInfo>> tmpBufferInfos;
+                std::vector<std::unique_ptr<VkBufferView>> tmpBufferViews;
+
+                for (uint64_t poolId : poolInfo.poolIds) {
+                    bool allocated = stream->getByte();
+                    if (!allocated) {
+                        continue;
+                    }
+                    poolIds.push_back(poolId);
+                    writeStartingIndices.push_back(writeDescriptorSets.size());
+                    VkDescriptorSetLayout boxedLayout = (VkDescriptorSetLayout)stream->getBe64();
+                    layouts.push_back(unbox_VkDescriptorSetLayout(boxedLayout));
+                    uint64_t validWriteCount = stream->getBe64();
+                    for (uint64_t write = 0; write < validWriteCount; write++) {
+                        uint32_t binding = stream->getBe32();
+                        uint32_t arrayElement = stream->getBe32();
+                        DescriptorSetInfo::DescriptorWriteType writeType =
+                            static_cast<DescriptorSetInfo::DescriptorWriteType>(stream->getBe32());
+                        VkDescriptorType descriptorType =
+                            static_cast<VkDescriptorType>(stream->getBe32());
+                        VkWriteDescriptorSet writeDescriptorSet = {
+                            .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
+                            .dstSet = (VkDescriptorSet)poolId,
+                            .dstBinding = binding,
+                            .dstArrayElement = arrayElement,
+                            .descriptorCount = 1,
+                            .descriptorType = descriptorType,
+                        };
+                        switch (writeType) {
+                            case DescriptorSetInfo::DescriptorWriteType::ImageInfo: {
+                                tmpImageInfos.push_back(std::make_unique<VkDescriptorImageInfo>());
+                                writeDescriptorSet.pImageInfo = tmpImageInfos.back().get();
+                                VkDescriptorImageInfo& imageInfo = *tmpImageInfos.back();
+                                stream->read(&imageInfo, sizeof(imageInfo));
+                                imageInfo.imageView = descriptorTypeContainsImage(descriptorType)
+                                                          ? unbox_VkImageView(imageInfo.imageView)
+                                                          : 0;
+                                imageInfo.sampler = descriptorTypeContainsSampler(descriptorType)
+                                                        ? unbox_VkSampler(imageInfo.sampler)
+                                                        : 0;
+                            } break;
+                            case DescriptorSetInfo::DescriptorWriteType::BufferInfo: {
+                                tmpBufferInfos.push_back(
+                                    std::make_unique<VkDescriptorBufferInfo>());
+                                writeDescriptorSet.pBufferInfo = tmpBufferInfos.back().get();
+                                VkDescriptorBufferInfo& bufferInfo = *tmpBufferInfos.back();
+                                stream->read(&bufferInfo, sizeof(bufferInfo));
+                                bufferInfo.buffer = unbox_VkBuffer(bufferInfo.buffer);
+                            } break;
+                            case DescriptorSetInfo::DescriptorWriteType::BufferView: {
+                                tmpBufferViews.push_back(std::make_unique<VkBufferView>());
+                                writeDescriptorSet.pTexelBufferView = tmpBufferViews.back().get();
+                                VkBufferView& bufferView = *tmpBufferViews.back();
+                                stream->read(&bufferView, sizeof(bufferView));
+                                bufferView = unbox_VkBufferView(bufferView);
+                            } break;
+                            case DescriptorSetInfo::DescriptorWriteType::InlineUniformBlock:
+                            case DescriptorSetInfo::DescriptorWriteType::AccelerationStructure:
+                                // TODO
+                                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                                    << "Encountered pending inline uniform block or acceleration "
+                                       "structure "
+                                       "desc write, abort (NYI)";
+                            default:
+                                break;
+                        }
+                        writeDescriptorSets.push_back(writeDescriptorSet);
                     }
-                    writeDescriptorSets.push_back(writeDescriptorSet);
                 }
+                std::vector<uint32_t> whichPool(poolIds.size(), 0);
+                std::vector<uint32_t> pendingAlloc(poolIds.size(), true);
+
+                const auto& device = poolInfo.device;
+                const auto& deviceInfo = android::base::find(mDeviceInfo, device);
+                VulkanDispatch* dvk = dispatch_VkDevice(deviceInfo->boxed);
+                on_vkQueueCommitDescriptorSetUpdatesGOOGLELocked(
+                    &bumpPool, nullptr, dvk, device, 1, &unboxedDescriptorPool, poolIds.size(),
+                    layouts.data(), poolIds.data(), whichPool.data(), pendingAlloc.data(),
+                    writeStartingIndices.data(), writeDescriptorSets.size(),
+                    writeDescriptorSets.data());
+            }
+
+            // Fences
+            VERBOSE("snapshot load: fences");
+            uint64_t fenceCount = stream->getBe64();
+            std::vector<VkFence> unsignaledFencesBoxed(fenceCount);
+            stream->read(unsignaledFencesBoxed.data(), fenceCount * sizeof(VkFence));
+            for (VkFence boxedFence : unsignaledFencesBoxed) {
+                VkFence unboxedFence = unbox_VkFence(boxedFence);
+                auto it = mFenceInfo.find(unboxedFence);
+                if (it == mFenceInfo.end()) {
+                    GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                        << "Snapshot load failure: unrecognized VkFence";
+                }
+                const auto& device = it->second.device;
+                const auto& deviceInfo = android::base::find(mDeviceInfo, device);
+                VulkanDispatch* dvk = dispatch_VkDevice(deviceInfo->boxed);
+                dvk->vkResetFences(device, 1, &unboxedFence);
             }
-            std::vector<uint32_t> whichPool(poolIds.size(), 0);
-            std::vector<uint32_t> pendingAlloc(poolIds.size(), true);
-
-            const auto& device = poolInfo.device;
-            const auto& deviceInfo = android::base::find(mDeviceInfo, device);
-            VulkanDispatch* dvk = dispatch_VkDevice(deviceInfo->boxed);
-            on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
-                &bumpPool, dvk, device, 1, &unboxedDescriptorPool, poolIds.size(), layouts.data(),
-                poolIds.data(), whichPool.data(), pendingAlloc.data(), writeStartingIndices.data(),
-                writeDescriptorSets.size(), writeDescriptorSets.data());
-        }
-        // Fences
-        uint64_t fenceCount = stream->getBe64();
-        std::vector<VkFence> unsignaledFencesBoxed(fenceCount);
-        stream->read(unsignaledFencesBoxed.data(), fenceCount * sizeof(VkFence));
-        for (VkFence boxedFence : unsignaledFencesBoxed) {
-            VkFence unboxedFence = unbox_VkFence(boxedFence);
-            auto it = mFenceInfo.find(unboxedFence);
-            if (it == mFenceInfo.end()) {
-                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-                    << "Snapshot load failure: unrecognized VkFence";
+#ifdef CONFIG_AEMU
+            if (!mInstanceInfo.empty()) {
+                get_emugl_vm_operations().setStatSnapshotUseVulkan();
             }
-            const auto& device = it->second.device;
-            const auto& deviceInfo = android::base::find(mDeviceInfo, device);
-            VulkanDispatch* dvk = dispatch_VkDevice(deviceInfo->boxed);
-            dvk->vkResetFences(device, 1, &unboxedFence);
-        }
-#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
-        if (!mInstanceInfo.empty()) {
-            get_emugl_vm_operations().setStatSnapshotUseVulkan();
-        }
 #endif
 
-        mSnapshotState = SnapshotState::Normal;
-    }
-
-    void lock() { mLock.lock(); }
-
-    void unlock() { mLock.unlock(); }
-
-    size_t setCreatedHandlesForSnapshotLoad(const unsigned char* buffer) {
-        size_t consumed = 0;
-
-        if (!buffer) return consumed;
-
-        uint32_t bufferSize = *(uint32_t*)buffer;
-
-        consumed += 4;
-
-        uint32_t handleCount = bufferSize / 8;
-        VKDGS_LOG("incoming handle count: %u", handleCount);
-
-        uint64_t* handles = (uint64_t*)(buffer + 4);
-
-        mCreatedHandlesForSnapshotLoad.clear();
-        mCreatedHandlesForSnapshotLoadIndex = 0;
-
-        for (uint32_t i = 0; i < handleCount; ++i) {
-            VKDGS_LOG("handle to load: 0x%llx", (unsigned long long)(uintptr_t)handles[i]);
-            mCreatedHandlesForSnapshotLoad.push_back(handles[i]);
-            consumed += 8;
+            mSnapshotState = SnapshotState::Normal;
         }
-
-        return consumed;
-    }
-
-    void clearCreatedHandlesForSnapshotLoad() {
-        mCreatedHandlesForSnapshotLoad.clear();
-        mCreatedHandlesForSnapshotLoadIndex = 0;
+        VERBOSE("VulkanSnapshots load (end)");
     }
 
-    std::optional<uint32_t> getContextIdForDeviceLocked(VkDevice device) {
+    std::optional<uint32_t> getContextIdForDeviceLocked(VkDevice device) REQUIRES(mMutex) {
         auto deviceInfoIt = mDeviceInfo.find(device);
         if (deviceInfoIt == mDeviceInfo.end()) {
             return std::nullopt;
@@ -1002,7 +855,8 @@ class VkDecoderGlobalState::Impl {
         return *deviceInfo.virtioGpuContextId;
     }
 
-    VkResult on_vkEnumerateInstanceVersion(android::base::BumpPool* pool, uint32_t* pApiVersion) {
+    VkResult on_vkEnumerateInstanceVersion(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                           uint32_t* pApiVersion) {
         if (m_vk->vkEnumerateInstanceVersion) {
             VkResult res = m_vk->vkEnumerateInstanceVersion(pApiVersion);
 
@@ -1016,7 +870,18 @@ class VkDecoderGlobalState::Impl {
         return VK_SUCCESS;
     }
 
-    VkResult on_vkCreateInstance(android::base::BumpPool* pool,
+    VkResult on_vkEnumerateInstanceExtensionProperties(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo*, const char* pLayerName,
+                                                   uint32_t* pPropertyCount,
+                                                   VkExtensionProperties* pProperties) {
+#if defined(__linux__)
+        // TODO(b/401005629) always lock before the call on linux
+        std::lock_guard<std::mutex> lock(mMutex);
+#endif
+        return m_vk->vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
+    }
+
+    VkResult on_vkCreateInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                  const VkInstanceCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator, VkInstance* pInstance) {
         std::vector<const char*> finalExts = filteredInstanceExtensionNames(
@@ -1061,35 +926,34 @@ class VkDecoderGlobalState::Impl {
         }
 
 #if defined(__APPLE__)
-        if (m_emu->instanceSupportsMoltenVK) {
+        if (m_vkEmulation->supportsMoltenVk()) {
             createInfoFiltered.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
         }
 #endif
 
-        // bug: 155795731
-        bool swiftshader =
+#if defined(__linux__)
+        // TODO(b/401005629) always lock before the call on linux
+        const bool doLockEarly = true;
+#else
+        const bool swiftshader =
             (android::base::getEnvironmentVariable("ANDROID_EMU_VK_ICD").compare("swiftshader") ==
              0);
-        std::unique_ptr<std::lock_guard<std::recursive_mutex>> lock = nullptr;
-
-        if (swiftshader) {
-            if (mLogging) {
-                INFO("%s: acquire lock", __func__);
-            }
-            lock = std::make_unique<std::lock_guard<std::recursive_mutex>>(mLock);
+        // b/155795731: swiftshader needs to lock early.
+        const bool doLockEarly = swiftshader;
+#endif
+        VkResult res = VK_SUCCESS;
+        if (!doLockEarly) {
+            res = m_vk->vkCreateInstance(&createInfoFiltered, pAllocator, pInstance);
+        }
+        std::lock_guard<std::mutex> lock(mMutex);
+        if (doLockEarly) {
+            res = m_vk->vkCreateInstance(&createInfoFiltered, pAllocator, pInstance);
         }
-
-        VkResult res = m_vk->vkCreateInstance(&createInfoFiltered, pAllocator, pInstance);
-
         if (res != VK_SUCCESS) {
             WARN("Failed to create Vulkan instance: %s.", string_VkResult(res));
             return res;
         }
 
-        if (!swiftshader) {
-            lock = std::make_unique<std::lock_guard<std::recursive_mutex>>(mLock);
-        }
-
         InstanceInfo info;
         info.apiVersion = apiVersion;
         if (pCreateInfo->pApplicationInfo) {
@@ -1107,14 +971,9 @@ class VkDecoderGlobalState::Impl {
         INFO("Created VkInstance:%p for application:%s engine:%s.", *pInstance,
              info.applicationName.c_str(), info.engineName.c_str());
 
-#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
-        // TODO: bug 129484301
-        if (!m_emu->features.VulkanSnapshots.enabled ||
-            (kSnapshotAppAllowList.find(info.applicationName) == kSnapshotAppAllowList.end() &&
-             kSnapshotEngineAllowList.find(info.engineName) == kSnapshotEngineAllowList.end())) {
-            get_emugl_vm_operations().setSkipSnapshotSave(true);
-            get_emugl_vm_operations().setSkipSnapshotSaveReason(SNAPSHOT_SKIP_UNSUPPORTED_VK_APP);
-        }
+#ifdef CONFIG_AEMU
+        m_vkEmulation->getCallbacks().registerVulkanInstance((uint64_t)*pInstance,
+                                                             info.applicationName.c_str());
 #endif
         // Box it up
         VkInstance boxed = new_boxed_VkInstance(*pInstance, nullptr, true /* own dispatch */);
@@ -1130,23 +989,28 @@ class VkDecoderGlobalState::Impl {
         *pInstance = (VkInstance)info.boxed;
 
         if (vkCleanupEnabled()) {
-            m_emu->callbacks.registerProcessCleanupCallback(unbox_VkInstance(boxed), [this, boxed] {
-                if (snapshotsEnabled()) {
-                    snapshot()->vkDestroyInstance(nullptr, 0, nullptr, boxed, nullptr);
-                }
-                vkDestroyInstanceImpl(unbox_VkInstance(boxed), nullptr);
-            });
+            m_vkEmulation->getCallbacks().registerProcessCleanupCallback(
+                unbox_VkInstance(boxed), [this, boxed] {
+                    if (snapshotsEnabled()) {
+                        snapshot()->vkDestroyInstance(nullptr, nullptr, nullptr, 0, boxed, nullptr);
+                    }
+                    vkDestroyInstanceImpl(unbox_VkInstance(boxed), nullptr);
+                });
         }
 
-        return res;
+        return VK_SUCCESS;
+    }
+
+    void processDelayedRemovesForDevice(VkDevice device) EXCLUDES(mMutex) {
+        sBoxedHandleManager.processDelayedRemoves(device);
     }
 
     void vkDestroyInstanceImpl(VkInstance instance, const VkAllocationCallbacks* pAllocator) {
-        // Do delayed removes out of the lock, but get the list of devices to destroy inside the
-        // lock.
+        std::vector<VkDevice> devicesToDestroy;
+
+        // Get the list of devices to destroy inside the lock ...
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-            std::vector<VkDevice> devicesToDestroy;
+            std::lock_guard<std::mutex> lock(mMutex);
 
             for (auto it : mDeviceToPhysicalDevice) {
                 auto* otherInstance = android::base::find(mPhysicalDeviceToInstance, it.second);
@@ -1155,16 +1019,18 @@ class VkDecoderGlobalState::Impl {
                     devicesToDestroy.push_back(it.first);
                 }
             }
+        }
 
-            for (auto device : devicesToDestroy) {
-                sBoxedHandleManager.processDelayedRemovesGlobalStateLocked(device);
-            }
+        // ... but process the delayed remove callbacks out of the lock as callbacks may
+        // call into `VkDecoderGlobalState` methods.
+        for (auto device : devicesToDestroy) {
+            processDelayedRemovesForDevice(device);
         }
 
         InstanceObjects instanceObjects;
 
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             extractInstanceAndDependenciesLocked(instance, instanceObjects);
         }
 
@@ -1175,16 +1041,17 @@ class VkDecoderGlobalState::Impl {
         destroyInstanceObjects(instanceObjects);
     }
 
-    void on_vkDestroyInstance(android::base::BumpPool* pool, VkInstance boxed_instance,
-                              const VkAllocationCallbacks* pAllocator) {
+    void on_vkDestroyInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                              VkInstance boxed_instance, const VkAllocationCallbacks* pAllocator) {
         auto instance = try_unbox_VkInstance(boxed_instance);
         if (instance == VK_NULL_HANDLE) {
             return;
         }
+        // The instance should not be used after vkDestroyInstanceImpl is called,
+        // remove it from the cleanup callback mapping.
+        m_vkEmulation->getCallbacks().unregisterProcessCleanupCallback(instance);
 
         vkDestroyInstanceImpl(instance, pAllocator);
-
-        m_emu->callbacks.unregisterProcessCleanupCallback(instance);
     }
 
     VkResult GetPhysicalDevices(VkInstance instance, VulkanDispatch* vk,
@@ -1211,7 +1078,9 @@ class VkDecoderGlobalState::Impl {
 
     void FilterPhysicalDevicesLocked(VkInstance instance, VulkanDispatch* vk,
                                      std::vector<VkPhysicalDevice>& toFilterPhysicalDevices) {
-        if (m_emu->instanceSupportsGetPhysicalDeviceProperties2) {
+        if (m_vkEmulation->supportsGetPhysicalDeviceProperties2()) {
+            const auto emulationPhysicalDeviceUuid = *m_vkEmulation->getDeviceUuid();
+
             PFN_vkGetPhysicalDeviceProperties2KHR getPhysdevProps2Func =
                 vk_util::getVkInstanceProcAddrWithFallback<
                     vk_util::vk_fn_info::GetPhysicalDeviceProperties2>(
@@ -1225,7 +1094,7 @@ class VkDecoderGlobalState::Impl {
                 // Remove those devices whose UUIDs don't match the one in VkCommonOperations.
                 toFilterPhysicalDevices.erase(
                     std::remove_if(toFilterPhysicalDevices.begin(), toFilterPhysicalDevices.end(),
-                                   [getPhysdevProps2Func, this](VkPhysicalDevice physicalDevice) {
+                                   [&](VkPhysicalDevice physicalDevice) {
                                        // We can get the device UUID.
                                        VkPhysicalDeviceIDPropertiesKHR idProps = {
                                            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR,
@@ -1237,7 +1106,7 @@ class VkDecoderGlobalState::Impl {
                                        };
                                        getPhysdevProps2Func(physicalDevice, &propsWithId);
 
-                                       return memcmp(m_emu->deviceInfo.idProps.deviceUUID,
+                                       return memcmp(emulationPhysicalDeviceUuid.data(),
                                                      idProps.deviceUUID, VK_UUID_SIZE) != 0;
                                    }),
                     toFilterPhysicalDevices.end());
@@ -1255,7 +1124,8 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    VkResult on_vkEnumeratePhysicalDevices(android::base::BumpPool* pool, VkInstance boxed_instance,
+    VkResult on_vkEnumeratePhysicalDevices(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                           VkInstance boxed_instance,
                                            uint32_t* pPhysicalDeviceCount,
                                            VkPhysicalDevice* pPhysicalDevices) {
         auto instance = unbox_VkInstance(boxed_instance);
@@ -1267,7 +1137,7 @@ class VkDecoderGlobalState::Impl {
             return res;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         FilterPhysicalDevicesLocked(instance, vk, physicalDevices);
 
@@ -1301,31 +1171,23 @@ class VkDecoderGlobalState::Impl {
                 physdevInfo.memoryPropertiesHelper =
                     std::make_unique<EmulatedPhysicalDeviceMemoryProperties>(
                         hostMemoryProperties,
-                        m_emu->representativeColorBufferMemoryTypeInfo->hostMemoryTypeIndex,
+                        m_vkEmulation->getRepresentativeColorBufferMemoryTypeInfo()
+                            .hostMemoryTypeIndex,
                         getFeatures());
 
+                std::vector<VkQueueFamilyProperties> queueFamilyProperties;
                 uint32_t queueFamilyPropCount = 0;
-
                 vk->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevices[i],
                                                              &queueFamilyPropCount, nullptr);
-
-                physdevInfo.queueFamilyProperties.resize((size_t)queueFamilyPropCount);
-
+                queueFamilyProperties.resize((size_t)queueFamilyPropCount);
                 vk->vkGetPhysicalDeviceQueueFamilyProperties(
                     physicalDevices[i], &queueFamilyPropCount,
-                    physdevInfo.queueFamilyProperties.data());
-
-                // Override queueCount for the virtual queue to be provided with device creations
-                if (mEnableVirtualVkQueue) {
-                    for (VkQueueFamilyProperties& qfp : physdevInfo.queueFamilyProperties) {
-                        // Check if the queue requires a virtualized version. For Android, we need
-                        // 2 graphics queues on the same queue family.
-                        if ( (qfp.queueFlags & VK_QUEUE_GRAPHICS_BIT) && qfp.queueCount == 1 ) {
-                            qfp.queueCount = 2;
-                            physdevInfo.hasVirtualGraphicsQueues = true;
-                        }
-                    }
-                }
+                    queueFamilyProperties.data());
+
+                physdevInfo.queuePropertiesHelper =
+                    std::make_unique<EmulatedPhysicalDeviceQueueProperties>(
+                        queueFamilyProperties,
+                        getFeatures());
 
                 pPhysicalDevices[i] = (VkPhysicalDevice)physdevInfo.boxed;
             }
@@ -1337,24 +1199,27 @@ class VkDecoderGlobalState::Impl {
         return res;
     }
 
-    void on_vkGetPhysicalDeviceFeatures(android::base::BumpPool* pool,
+    void on_vkGetPhysicalDeviceFeatures(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                         VkPhysicalDevice boxed_physicalDevice,
                                         VkPhysicalDeviceFeatures* pFeatures) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
         auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
 
         vk->vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures);
-        pFeatures->textureCompressionETC2 |= enableEmulatedEtc2(physicalDevice, vk);
-        pFeatures->textureCompressionASTC_LDR |= enableEmulatedAstc(physicalDevice, vk);
+
+        std::lock_guard<std::mutex> lock(mMutex);
+
+        pFeatures->textureCompressionETC2 |= enableEmulatedEtc2Locked(physicalDevice, vk);
+        pFeatures->textureCompressionASTC_LDR |= enableEmulatedAstcLocked(physicalDevice, vk);
     }
 
-    void on_vkGetPhysicalDeviceFeatures2(android::base::BumpPool* pool,
+    void on_vkGetPhysicalDeviceFeatures2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                          VkPhysicalDevice boxed_physicalDevice,
                                          VkPhysicalDeviceFeatures2* pFeatures) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
         auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* physdevInfo = android::base::find(mPhysdevInfo, physicalDevice);
         if (!physdevInfo) return;
@@ -1385,16 +1250,17 @@ class VkDecoderGlobalState::Impl {
             vk->vkGetPhysicalDeviceFeatures(physicalDevice, &pFeatures->features);
         }
 
-        pFeatures->features.textureCompressionETC2 |= enableEmulatedEtc2(physicalDevice, vk);
-        pFeatures->features.textureCompressionASTC_LDR |= enableEmulatedAstc(physicalDevice, vk);
+        pFeatures->features.textureCompressionETC2 |= enableEmulatedEtc2Locked(physicalDevice, vk);
+        pFeatures->features.textureCompressionASTC_LDR |=
+            enableEmulatedAstcLocked(physicalDevice, vk);
         VkPhysicalDeviceSamplerYcbcrConversionFeatures* ycbcrFeatures =
             vk_find_struct<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(pFeatures);
         if (ycbcrFeatures != nullptr) {
-            ycbcrFeatures->samplerYcbcrConversion |= m_emu->enableYcbcrEmulation;
+            ycbcrFeatures->samplerYcbcrConversion |= m_vkEmulation->isYcbcrEmulationEnabled();
         }
 
         // Disable a set of Vulkan features if BypassVulkanDeviceFeatureOverrides is NOT enabled.
-        if (!m_emu->features.BypassVulkanDeviceFeatureOverrides.enabled) {
+        if (!m_vkEmulation->getFeatures().BypassVulkanDeviceFeatureOverrides.enabled) {
             VkPhysicalDeviceProtectedMemoryFeatures* protectedMemoryFeatures =
                 vk_find_struct<VkPhysicalDeviceProtectedMemoryFeatures>(pFeatures);
             if (protectedMemoryFeatures != nullptr) {
@@ -1402,6 +1268,11 @@ class VkDecoderGlobalState::Impl {
                 // information to mark as unsupported (see b/329845987).
                 protectedMemoryFeatures->protectedMemory = VK_FALSE;
             }
+            VkPhysicalDeviceVulkan11Features* vk11Features =
+                vk_find_struct<VkPhysicalDeviceVulkan11Features>(pFeatures);
+            if (vk11Features != nullptr) {
+                vk11Features->protectedMemory = VK_FALSE;
+            }
 
             VkPhysicalDevicePrivateDataFeatures* privateDataFeatures =
                 vk_find_struct<VkPhysicalDevicePrivateDataFeatures>(pFeatures);
@@ -1417,7 +1288,7 @@ class VkDecoderGlobalState::Impl {
                 vulkan13Features->privateData = VK_FALSE;
             }
 
-            if (m_emu->features.VulkanBatchedDescriptorSetUpdate.enabled) {
+            if (m_vkEmulation->getFeatures().VulkanBatchedDescriptorSetUpdate.enabled) {
                 // Currently not supporting iub due to descriptor set optimization.
                 // TODO: fix the non-optimized descriptor set path and re-enable the features afterwads.
                 // b/372217918
@@ -1434,8 +1305,9 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkResult on_vkGetPhysicalDeviceImageFormatProperties(
-        android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice, VkFormat format,
-        VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+        VkPhysicalDevice boxed_physicalDevice, VkFormat format, VkImageType type,
+        VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags,
         VkImageFormatProperties* pImageFormatProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
         auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
@@ -1463,7 +1335,8 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkResult on_vkGetPhysicalDeviceImageFormatProperties2(
-        android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+        VkPhysicalDevice boxed_physicalDevice,
         const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
         VkImageFormatProperties2* pImageFormatProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
@@ -1486,7 +1359,17 @@ class VkDecoderGlobalState::Impl {
             imageFormatInfo.usage |= VK_IMAGE_USAGE_STORAGE_BIT;
             imageFormatInfo.format = CompressedImageInfo::getCompressedMipmapsFormat(format);
         }
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+
+        auto* extImageFormatInfo =
+            vk_find_struct<VkPhysicalDeviceExternalImageFormatInfo>(pImageFormatInfo);
+
+        if (extImageFormatInfo &&
+            extImageFormatInfo->handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT) {
+            const_cast<VkPhysicalDeviceExternalImageFormatInfo*>(extImageFormatInfo)->handleType =
+                m_vkEmulation->getDefaultExternalMemoryHandleType();
+        }
+
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* physdevInfo = android::base::find(mPhysdevInfo, physicalDevice);
         if (!physdevInfo) {
@@ -1531,8 +1414,6 @@ class VkDecoderGlobalState::Impl {
             return res;
         }
 
-        const VkPhysicalDeviceExternalImageFormatInfo* extImageFormatInfo =
-            vk_find_struct<VkPhysicalDeviceExternalImageFormatInfo>(pImageFormatInfo);
         VkExternalImageFormatProperties* extImageFormatProps =
             vk_find_struct<VkExternalImageFormatProperties>(pImageFormatProperties);
 
@@ -1551,6 +1432,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkGetPhysicalDeviceFormatProperties(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo*,
                                                 VkPhysicalDevice boxed_physicalDevice,
                                                 VkFormat format,
                                                 VkFormatProperties* pFormatProperties) {
@@ -1565,60 +1447,84 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkGetPhysicalDeviceFormatProperties2(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo*,
                                                  VkPhysicalDevice boxed_physicalDevice,
                                                  VkFormat format,
                                                  VkFormatProperties2* pFormatProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
         auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        enum class WhichFunc {
+            kGetPhysicalDeviceFormatProperties,
+            kGetPhysicalDeviceFormatProperties2,
+            kGetPhysicalDeviceFormatProperties2KHR,
+        };
 
-        auto* physdevInfo = android::base::find(mPhysdevInfo, physicalDevice);
-        if (!physdevInfo) return;
+        auto func = WhichFunc::kGetPhysicalDeviceFormatProperties2KHR;
 
-        auto instance = mPhysicalDeviceToInstance[physicalDevice];
-        auto* instanceInfo = android::base::find(mInstanceInfo, instance);
-        if (!instanceInfo) return;
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
 
-        if (instanceInfo->apiVersion >= VK_MAKE_VERSION(1, 1, 0) &&
-            physdevInfo->props.apiVersion >= VK_MAKE_VERSION(1, 1, 0)) {
-            getPhysicalDeviceFormatPropertiesCore<VkFormatProperties2>(
-                [vk](VkPhysicalDevice physicalDevice, VkFormat format,
-                     VkFormatProperties2* pFormatProperties) {
-                    vk->vkGetPhysicalDeviceFormatProperties2(physicalDevice, format,
-                                                             pFormatProperties);
-                },
-                vk, physicalDevice, format, pFormatProperties);
-        } else if (hasInstanceExtension(instance,
-                                        VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME)) {
-            getPhysicalDeviceFormatPropertiesCore<VkFormatProperties2>(
-                [vk](VkPhysicalDevice physicalDevice, VkFormat format,
-                     VkFormatProperties2* pFormatProperties) {
-                    vk->vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format,
+            auto* physdevInfo = android::base::find(mPhysdevInfo, physicalDevice);
+            if (!physdevInfo) return;
+
+            auto instance = mPhysicalDeviceToInstance[physicalDevice];
+            auto* instanceInfo = android::base::find(mInstanceInfo, instance);
+            if (!instanceInfo) return;
+
+            if (instanceInfo->apiVersion >= VK_MAKE_VERSION(1, 1, 0) &&
+                physdevInfo->props.apiVersion >= VK_MAKE_VERSION(1, 1, 0)) {
+                func = WhichFunc::kGetPhysicalDeviceFormatProperties2;
+            } else if (hasInstanceExtension(
+                           instance, VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME)) {
+                func = WhichFunc::kGetPhysicalDeviceFormatProperties2KHR;
+            }
+        }
+
+        switch (func) {
+            case WhichFunc::kGetPhysicalDeviceFormatProperties2: {
+                getPhysicalDeviceFormatPropertiesCore<VkFormatProperties2>(
+                    [vk](VkPhysicalDevice physicalDevice, VkFormat format,
+                         VkFormatProperties2* pFormatProperties) {
+                        vk->vkGetPhysicalDeviceFormatProperties2(physicalDevice, format,
+                                                                 pFormatProperties);
+                    },
+                    vk, physicalDevice, format, pFormatProperties);
+                break;
+            }
+            case WhichFunc::kGetPhysicalDeviceFormatProperties2KHR: {
+                getPhysicalDeviceFormatPropertiesCore<VkFormatProperties2>(
+                    [vk](VkPhysicalDevice physicalDevice, VkFormat format,
+                         VkFormatProperties2* pFormatProperties) {
+                        vk->vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format,
+                                                                    pFormatProperties);
+                    },
+                    vk, physicalDevice, format, pFormatProperties);
+                break;
+            }
+            case WhichFunc::kGetPhysicalDeviceFormatProperties: {
+                // No instance extension, fake it!!!!
+                if (pFormatProperties->pNext) {
+                    fprintf(stderr,
+                            "%s: Warning: Trying to use extension struct in "
+                            "vkGetPhysicalDeviceFormatProperties2 without having "
+                            "enabled the extension!!!!11111\n",
+                            __func__);
+                }
+                pFormatProperties->sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
+                getPhysicalDeviceFormatPropertiesCore<VkFormatProperties>(
+                    [vk](VkPhysicalDevice physicalDevice, VkFormat format,
+                         VkFormatProperties* pFormatProperties) {
+                        vk->vkGetPhysicalDeviceFormatProperties(physicalDevice, format,
                                                                 pFormatProperties);
-                },
-                vk, physicalDevice, format, pFormatProperties);
-        } else {
-            // No instance extension, fake it!!!!
-            if (pFormatProperties->pNext) {
-                fprintf(stderr,
-                        "%s: Warning: Trying to use extension struct in "
-                        "vkGetPhysicalDeviceFormatProperties2 without having "
-                        "enabled the extension!!!!11111\n",
-                        __func__);
+                    },
+                    vk, physicalDevice, format, &pFormatProperties->formatProperties);
+                break;
             }
-            pFormatProperties->sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
-            getPhysicalDeviceFormatPropertiesCore<VkFormatProperties>(
-                [vk](VkPhysicalDevice physicalDevice, VkFormat format,
-                     VkFormatProperties* pFormatProperties) {
-                    vk->vkGetPhysicalDeviceFormatProperties(physicalDevice, format,
-                                                            pFormatProperties);
-                },
-                vk, physicalDevice, format, &pFormatProperties->formatProperties);
         }
     }
 
-    void on_vkGetPhysicalDeviceProperties(android::base::BumpPool* pool,
+    void on_vkGetPhysicalDeviceProperties(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                           VkPhysicalDevice boxed_physicalDevice,
                                           VkPhysicalDeviceProperties* pProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
@@ -1631,13 +1537,13 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkGetPhysicalDeviceProperties2(android::base::BumpPool* pool,
+    void on_vkGetPhysicalDeviceProperties2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                            VkPhysicalDevice boxed_physicalDevice,
                                            VkPhysicalDeviceProperties2* pProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
         auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* physdevInfo = android::base::find(mPhysdevInfo, physicalDevice);
         if (!physdevInfo) return;
@@ -1674,78 +1580,79 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkGetPhysicalDeviceQueueFamilyProperties(
-        android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
-        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties) {
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+        VkPhysicalDevice boxed_physicalDevice, uint32_t* pQueueFamilyPropertyCount,
+        VkQueueFamilyProperties* pQueueFamilyProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
-        auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
 
-        const bool requiresPropertyOverrides = mEnableVirtualVkQueue && pQueueFamilyProperties;
-        if (!requiresPropertyOverrides) {
-            // Can just use results from the driver
-            return vk->vkGetPhysicalDeviceQueueFamilyProperties(
-                physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
-        }
+        std::lock_guard<std::mutex> lock(mMutex);
 
-        // Use cached queue family properties to accommodate for any property overrides/emulation
-        std::lock_guard<std::recursive_mutex> lock(mLock);
         const PhysicalDeviceInfo* physicalDeviceInfo =
             android::base::find(mPhysdevInfo, physicalDevice);
-        if (!physicalDeviceInfo) {
+        if (!physicalDeviceInfo || !physicalDeviceInfo->queuePropertiesHelper) {
             ERR("Failed to find physical device info.");
             return;
         }
 
-        const auto& properties = physicalDeviceInfo->queueFamilyProperties;
-        *pQueueFamilyPropertyCount =
-            std::min((uint32_t)properties.size(), *pQueueFamilyPropertyCount);
-        for (uint32_t i = 0; i < *pQueueFamilyPropertyCount; i++) {
-            pQueueFamilyProperties[i] = properties[i];
+        // Use queuePropertiesHelper to accommodate for any property overrides/emulation
+        const auto& properties =
+            physicalDeviceInfo->queuePropertiesHelper->getQueueFamilyProperties();
+        if (pQueueFamilyProperties) {
+            // Count is given by the client to define amount of space available
+            *pQueueFamilyPropertyCount =
+                std::min((uint32_t)properties.size(), *pQueueFamilyPropertyCount);
+            for (uint32_t i = 0; i < *pQueueFamilyPropertyCount; i++) {
+                pQueueFamilyProperties[i] = properties[i];
+            }
+        } else {
+            *pQueueFamilyPropertyCount = (uint32_t)properties.size();
         }
     }
 
     void on_vkGetPhysicalDeviceQueueFamilyProperties2(
-        android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
-        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+        VkPhysicalDevice boxed_physicalDevice, uint32_t* pQueueFamilyPropertyCount,
+        VkQueueFamilyProperties2* pQueueFamilyProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
         auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
 
-        const bool requiresPropertyOverrides = mEnableVirtualVkQueue && pQueueFamilyProperties;
-        if (!requiresPropertyOverrides) {
-            // Can just use results from the driver
-            return vk->vkGetPhysicalDeviceQueueFamilyProperties2(
-                physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
-        }
-
-        if (pQueueFamilyProperties->pNext) {
-            // We still need to call the driver version to fill in any pNext values
+        if (pQueueFamilyProperties && pQueueFamilyProperties->pNext) {
+            // We need to call the driver version to fill in any pNext values
             vk->vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount,
                                                           pQueueFamilyProperties);
         }
 
-        // Use cached queue family properties to accommodate for any property overrides/emulation
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
+
         const PhysicalDeviceInfo* physicalDeviceInfo =
             android::base::find(mPhysdevInfo, physicalDevice);
-        if (!physicalDeviceInfo) {
+        if (!physicalDeviceInfo || !physicalDeviceInfo->queuePropertiesHelper) {
             ERR("Failed to find physical device info.");
             return;
         }
 
-        const auto& properties = physicalDeviceInfo->queueFamilyProperties;
-        *pQueueFamilyPropertyCount =
-            std::min((uint32_t)properties.size(), *pQueueFamilyPropertyCount);
-        for (uint32_t i = 0; i < *pQueueFamilyPropertyCount; i++) {
-            pQueueFamilyProperties[i].queueFamilyProperties = properties[i];
+        // Use queuePropertiesHelper to accommodate for any property overrides/emulation
+        const auto& properties =
+            physicalDeviceInfo->queuePropertiesHelper->getQueueFamilyProperties();
+        if (pQueueFamilyProperties) {
+            // Count is given by the client to define amount of space available
+            *pQueueFamilyPropertyCount =
+                std::min((uint32_t)properties.size(), *pQueueFamilyPropertyCount);
+            for (uint32_t i = 0; i < *pQueueFamilyPropertyCount; i++) {
+                pQueueFamilyProperties[i].queueFamilyProperties = properties[i];
+            }
+        } else {
+            *pQueueFamilyPropertyCount = (uint32_t)properties.size();
         }
     }
 
     void on_vkGetPhysicalDeviceMemoryProperties(
-        android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+        VkPhysicalDevice boxed_physicalDevice,
         VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
-        auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* physicalDeviceInfo = android::base::find(mPhysdevInfo, physicalDevice);
         if (!physicalDeviceInfo) {
@@ -1758,11 +1665,14 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkGetPhysicalDeviceMemoryProperties2(
-        android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+        VkPhysicalDevice boxed_physicalDevice,
         VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
         auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
 
+        std::lock_guard<std::mutex> lock(mMutex);
+
         auto* physicalDeviceInfo = android::base::find(mPhysdevInfo, physicalDevice);
         if (!physicalDeviceInfo) return;
 
@@ -1797,6 +1707,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkResult on_vkEnumerateDeviceExtensionProperties(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo*,
                                                      VkPhysicalDevice boxed_physicalDevice,
                                                      const char* pLayerName,
                                                      uint32_t* pPropertyCount,
@@ -1804,9 +1715,9 @@ class VkDecoderGlobalState::Impl {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
         auto vk = dispatch_VkPhysicalDevice(boxed_physicalDevice);
 
-        bool shouldPassthrough = !m_emu->enableYcbcrEmulation;
+        bool shouldPassthrough = !m_vkEmulation->isYcbcrEmulationEnabled();
 #if defined(__APPLE__)
-        shouldPassthrough = shouldPassthrough && !m_emu->instanceSupportsMoltenVK;
+        shouldPassthrough = shouldPassthrough && !m_vkEmulation->supportsMoltenVk();
 #endif
         if (shouldPassthrough) {
             return vk->vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName,
@@ -1824,7 +1735,7 @@ class VkDecoderGlobalState::Impl {
 
 #if defined(__APPLE__) && defined(VK_MVK_moltenvk)
         // Guest will check for VK_MVK_moltenvk extension for enabling AHB support
-        if (m_emu->instanceSupportsMoltenVK &&
+        if (m_vkEmulation->supportsMoltenVk() &&
             !hasDeviceExtension(properties, VK_MVK_MOLTENVK_EXTENSION_NAME)) {
             VkExtensionProperties mvk_props;
             strncpy(mvk_props.extensionName, VK_MVK_MOLTENVK_EXTENSION_NAME,
@@ -1834,7 +1745,7 @@ class VkDecoderGlobalState::Impl {
         }
 #endif
 
-        if (m_emu->enableYcbcrEmulation &&
+        if (m_vkEmulation->isYcbcrEmulationEnabled() &&
             !hasDeviceExtension(properties, VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME)) {
             VkExtensionProperties ycbcr_props;
             strncpy(ycbcr_props.extensionName, VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME,
@@ -1852,7 +1763,8 @@ class VkDecoderGlobalState::Impl {
         return *pPropertyCount < properties.size() ? VK_INCOMPLETE : VK_SUCCESS;
     }
 
-    VkResult on_vkCreateDevice(android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
+    VkResult on_vkCreateDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                               VkPhysicalDevice boxed_physicalDevice,
                                const VkDeviceCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator, VkDevice* pDevice) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
@@ -1862,12 +1774,16 @@ class VkDecoderGlobalState::Impl {
             filteredDeviceExtensionNames(vk, physicalDevice, pCreateInfo->enabledExtensionCount,
                                          pCreateInfo->ppEnabledExtensionNames);
 
-        m_emu->deviceLostHelper.addNeededDeviceExtensions(&updatedDeviceExtensions);
+        m_vkEmulation->getDeviceLostHelper().addNeededDeviceExtensions(&updatedDeviceExtensions);
 
         uint32_t supportedFenceHandleTypes = 0;
         uint32_t supportedBinarySemaphoreHandleTypes = 0;
         // Run the underlying API call, filtering extensions.
-        VkDeviceCreateInfo createInfoFiltered = *pCreateInfo;
+
+        VkDeviceCreateInfo createInfoFiltered;
+        deepcopy_VkDeviceCreateInfo(pool, VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, pCreateInfo,
+                                      &createInfoFiltered);
+
         // According to the spec, it seems that the application can use compressed texture formats
         // without enabling the feature when creating the VkDevice, as long as
         // vkGetPhysicalDeviceFormatProperties and vkGetPhysicalDeviceImageFormatProperties reports
@@ -1893,7 +1809,7 @@ class VkDecoderGlobalState::Impl {
             nullptr,
             VK_TRUE,
         };
-        if (m_emu->deviceInfo.supportsPrivateData) {
+        if (m_vkEmulation->supportsPrivateData()) {
             VkPhysicalDevicePrivateDataFeatures* privateDataFeatures =
                 vk_find_struct<VkPhysicalDevicePrivateDataFeatures>(&createInfoFiltered);
             if (privateDataFeatures != nullptr) {
@@ -1906,16 +1822,48 @@ class VkDecoderGlobalState::Impl {
             }
         }
 
+        VkPhysicalDeviceRobustness2FeaturesEXT modifiedRobustness2features;
+        const auto r2features = m_vkEmulation->getRobustness2Features();
+        if (r2features && vk_find_struct<VkPhysicalDeviceRobustness2FeaturesEXT>(
+                                       &createInfoFiltered) == nullptr) {
+            VERBOSE("Force-enabling VK_EXT_robustness2 on device creation.");
+            updatedDeviceExtensions.push_back(VK_EXT_ROBUSTNESS_2_EXTENSION_NAME);
+            modifiedRobustness2features = *r2features;
+            modifiedRobustness2features.pNext = const_cast<void*>(createInfoFiltered.pNext);
+            createInfoFiltered.pNext = &modifiedRobustness2features;
+        }
+
         if (VkPhysicalDeviceFeatures2* features2 =
                 vk_find_struct<VkPhysicalDeviceFeatures2>(&createInfoFiltered)) {
             featuresToFilter.emplace_back(&features2->features);
         }
 
+        {
+            // Protected memory is not supported on emulators. Override feature
+            // information to mark as unsupported (see b/329845987).
+            VkPhysicalDeviceProtectedMemoryFeatures* protectedMemoryFeatures =
+                vk_find_struct<VkPhysicalDeviceProtectedMemoryFeatures>(&createInfoFiltered);
+            if (protectedMemoryFeatures != nullptr) {
+                protectedMemoryFeatures->protectedMemory = VK_FALSE;
+            }
+
+            VkPhysicalDeviceVulkan11Features* vk11Features =
+                vk_find_struct<VkPhysicalDeviceVulkan11Features>(&createInfoFiltered);
+            if (vk11Features != nullptr) {
+                vk11Features->protectedMemory = VK_FALSE;
+            }
+
+            for (uint32_t i = 0; i < createInfoFiltered.queueCreateInfoCount; i++) {
+                (const_cast<VkDeviceQueueCreateInfo*>(createInfoFiltered.pQueueCreateInfos))[i]
+                    .flags &= ~VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT;
+            }
+        }
+
         VkPhysicalDeviceDiagnosticsConfigFeaturesNV deviceDiagnosticsConfigFeatures = {
             .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
             .diagnosticsConfig = VK_TRUE,
         };
-        if (m_emu->commandBufferCheckpointsSupportedAndRequested) {
+        if (m_vkEmulation->commandBufferCheckpointsEnabled()) {
             deviceDiagnosticsConfigFeatures.pNext = const_cast<void*>(createInfoFiltered.pNext);
             createInfoFiltered.pNext = &deviceDiagnosticsConfigFeatures;
         }
@@ -1931,7 +1879,8 @@ class VkDecoderGlobalState::Impl {
 
         if (auto* ycbcrFeatures = vk_find_struct<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(
                 &createInfoFiltered)) {
-            if (m_emu->enableYcbcrEmulation && !m_emu->deviceInfo.supportsSamplerYcbcrConversion) {
+            if (m_vkEmulation->isYcbcrEmulationEnabled() &&
+                !m_vkEmulation->supportsSamplerYcbcrConversion()) {
                 ycbcrFeatures->samplerYcbcrConversion = VK_FALSE;
             }
         }
@@ -1944,6 +1893,18 @@ class VkDecoderGlobalState::Impl {
             }
         }
 
+        VkDeviceQueueCreateInfo filteredQueueCreateInfo = {};
+        // Use VulkanVirtualQueue directly to avoid locking for hasVirtualGraphicsQueue call.
+        if (m_vkEmulation->getFeatures().VulkanVirtualQueue.enabled &&
+            (createInfoFiltered.queueCreateInfoCount == 1) &&
+            (createInfoFiltered.pQueueCreateInfos[0].queueCount == 2)) {
+            // In virtual secondary queue mode, we should filter the queue count
+            // value inside the device create info before calling the underlying driver.
+            filteredQueueCreateInfo = createInfoFiltered.pQueueCreateInfos[0];
+            filteredQueueCreateInfo.queueCount = 1;
+            createInfoFiltered.pQueueCreateInfos = &filteredQueueCreateInfo;
+        }
+
 #ifdef __APPLE__
 #ifndef VK_ENABLE_BETA_EXTENSIONS
         // TODO(b/349066492): Update Vulkan headers, stringhelpers and compilation parameters
@@ -1954,7 +1915,7 @@ class VkDecoderGlobalState::Impl {
         // Enable all portability features supported on the device
         VkPhysicalDevicePortabilitySubsetFeaturesKHR supportedPortabilityFeatures = {
             VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR, nullptr};
-        if (m_emu->instanceSupportsMoltenVK) {
+        if (m_vkEmulation->supportsMoltenVk()) {
             VkPhysicalDeviceFeatures2 features2 = {
                 .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
                 .pNext = &supportedPortabilityFeatures,
@@ -2011,24 +1972,28 @@ class VkDecoderGlobalState::Impl {
         createInfoFiltered.enabledExtensionCount = (uint32_t)updatedDeviceExtensions.size();
         createInfoFiltered.ppEnabledExtensionNames = updatedDeviceExtensions.data();
 
-        // bug: 155795731
-        bool swiftshader =
+#if defined(__linux__)
+        // TODO(b/401005629) always lock before the call on linux
+        const bool doLockEarly = true;
+#else
+        const bool swiftshader =
             (android::base::getEnvironmentVariable("ANDROID_EMU_VK_ICD").compare("swiftshader") ==
              0);
-
-        std::unique_ptr<std::lock_guard<std::recursive_mutex>> lock = nullptr;
-
-        if (swiftshader) {
-            lock = std::make_unique<std::lock_guard<std::recursive_mutex>>(mLock);
+        // b/155795731: swiftshader needs to lock early.
+        const bool doLockEarly = swiftshader;
+#endif
+        VkResult result = VK_SUCCESS;
+        if (!doLockEarly) {
+            result = vk->vkCreateDevice(physicalDevice, &createInfoFiltered, pAllocator, pDevice);
+        }
+        std::lock_guard<std::mutex> lock(mMutex);
+        if (doLockEarly) {
+            result = vk->vkCreateDevice(physicalDevice, &createInfoFiltered, pAllocator, pDevice);
         }
 
-        VkResult result =
-            vk->vkCreateDevice(physicalDevice, &createInfoFiltered, pAllocator, pDevice);
-
-        if (result != VK_SUCCESS) return result;
-
-        if (!swiftshader) {
-            lock = std::make_unique<std::lock_guard<std::recursive_mutex>>(mLock);
+        if (result != VK_SUCCESS) {
+            WARN("Failed to create VkDevice: %s.", string_VkResult(result));
+            return result;
         }
 
         mDeviceToPhysicalDevice[*pDevice] = physicalDevice;
@@ -2048,7 +2013,7 @@ class VkDecoderGlobalState::Impl {
         deviceInfo.emulateTextureEtc2 = emulateTextureEtc2;
         deviceInfo.emulateTextureAstc = emulateTextureAstc;
         deviceInfo.useAstcCpuDecompression =
-            m_emu->astcLdrEmulationMode == AstcEmulationMode::Cpu &&
+            m_vkEmulation->getAstcLdrEmulationMode() == AstcEmulationMode::Cpu &&
             AstcCpuDecompressor::get().available();
         deviceInfo.decompPipelines =
             std::make_unique<GpuDecompressionPipelineManager>(m_vk, *pDevice);
@@ -2079,7 +2044,7 @@ class VkDecoderGlobalState::Impl {
 
         VulkanDispatch* dispatch = dispatch_VkDevice(boxedDevice);
         init_vulkan_dispatch_from_device(vk, *pDevice, dispatch);
-        if (m_emu->debugUtilsAvailableAndRequested) {
+        if (m_vkEmulation->debugUtilsEnabled()) {
             deviceInfo.debugUtilsHelper = DebugUtilsHelper::withUtilsEnabled(*pDevice, dispatch);
         }
 
@@ -2094,6 +2059,11 @@ class VkDecoderGlobalState::Impl {
 
         deviceInfo.boxed = boxedDevice;
 
+        DeviceLostHelper::DeviceWithQueues deviceWithQueues = {
+            .device = *pDevice,
+            .deviceDispatch = dispatch,
+        };
+
         if (mSnapshotState == SnapshotState::Loading) {
             if (!mSnapshotLoadVkDeviceToVirtioCpuContextId) {
                 GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
@@ -2126,7 +2096,8 @@ class VkDecoderGlobalState::Impl {
         for (auto it : queueFamilyIndexCounts) {
             auto index = it.first;
             auto count = it.second;
-            auto addVirtualQueue = (count == 2) && physicalDeviceInfo.hasVirtualGraphicsQueues;
+            auto addVirtualQueue =
+                (count == 2) && physicalDeviceInfo.queuePropertiesHelper->hasVirtualGraphicsQueue();
             auto& queues = deviceInfo.queues[index];
             for (uint32_t i = 0; i < count; ++i) {
                 VkQueue physicalQueue;
@@ -2135,7 +2106,7 @@ class VkDecoderGlobalState::Impl {
                     INFO("%s: get device queue (begin)", __func__);
                 }
 
-                assert(i == 0 || !physicalDeviceInfo.hasVirtualGraphicsQueues);
+                assert(i == 0 || !addVirtualQueue);
                 vk->vkGetDeviceQueue(*pDevice, index, i, &physicalQueue);
 
                 if (mLogging) {
@@ -2150,9 +2121,14 @@ class VkDecoderGlobalState::Impl {
                 physicalQueueInfo.device = *pDevice;
                 physicalQueueInfo.queueFamilyIndex = index;
                 physicalQueueInfo.boxed = boxedQueue;
-                physicalQueueInfo.physicalQueueLock = std::make_shared<android::base::Lock>();
+                physicalQueueInfo.queueMutex = std::make_shared<std::mutex>();
                 queues.push_back(physicalQueue);
 
+                deviceWithQueues.queues.push_back(DeviceLostHelper::QueueWithMutex{
+                    .queue = physicalQueue,
+                    .queueMutex = physicalQueueInfo.queueMutex,
+                });
+
                 if (addVirtualQueue) {
                     VERBOSE("Creating virtual device queue for physical VkQueue %p", physicalQueue);
                     const uint64_t physicalQueue64 = reinterpret_cast<uint64_t>(physicalQueue);
@@ -2162,10 +2138,11 @@ class VkDecoderGlobalState::Impl {
                         // values generated are not 2-byte aligned. This is very unusual, but the
                         // spec is not enforcing handle values to be aligned and the driver is free
                         // to use a similar logic to use the last bit for other purposes.
-                        // In this case, we disable the virtual queue support and unboxing will not
-                        // remove the last bit coming from the actual driver.
-                        ERR("Cannot create virtual queue for handle %p", physicalQueue);
-                        mEnableVirtualVkQueue = false;
+                        // In this case, we ask users to disable the virtual queue support as
+                        // handling the error dynamically is not feasible.
+                        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                            << "Cannot use `VulkanVirtualQueue` feature: Unexpected physical queue "
+                               "handle value.";
                     } else {
                         uint64_t virtualQueue64 = (physicalQueue64 | QueueInfo::kVirtualQueueBit);
                         VkQueue virtualQueue = reinterpret_cast<VkQueue>(virtualQueue64);
@@ -2179,18 +2156,20 @@ class VkDecoderGlobalState::Impl {
                         virtualQueueInfo.device = physicalQueueInfo.device;
                         virtualQueueInfo.queueFamilyIndex = physicalQueueInfo.queueFamilyIndex;
                         virtualQueueInfo.boxed = boxedVirtualQueue;
-                        virtualQueueInfo.physicalQueueLock =
-                            physicalQueueInfo.physicalQueueLock;  // Shares the same lock!
+                        virtualQueueInfo.queueMutex = physicalQueueInfo.queueMutex;  // Shares the same lock!
                         queues.push_back(virtualQueue);
                     }
                     i++;
                 }
             }
         }
-        if (snapshotsEnabled()) {
-            snapshot()->createExtraHandlesForNextApi(extraHandles.data(), extraHandles.size());
+        if (snapshotsEnabled() && snapshotInfo) {
+            snapshotInfo->addOrderedBoxedHandlesCreatedByCall(extraHandles.data(),
+                                                              extraHandles.size());
         }
 
+        m_vkEmulation->getDeviceLostHelper().onDeviceCreated(std::move(deviceWithQueues));
+
         // Box the device.
         *pDevice = (VkDevice)deviceInfo.boxed;
 
@@ -2201,11 +2180,12 @@ class VkDecoderGlobalState::Impl {
         return VK_SUCCESS;
     }
 
-    void on_vkGetDeviceQueue(android::base::BumpPool* pool, VkDevice boxed_device,
-                             uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue) {
+    void on_vkGetDeviceQueue(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                             VkDevice boxed_device, uint32_t queueFamilyIndex, uint32_t queueIndex,
+                             VkQueue* pQueue) {
         auto device = unbox_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         *pQueue = VK_NULL_HANDLE;
 
@@ -2229,31 +2209,34 @@ class VkDecoderGlobalState::Impl {
         *pQueue = queueInfo->boxed;
     }
 
-    void on_vkGetDeviceQueue2(android::base::BumpPool* pool, VkDevice boxed_device,
-                              const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue) {
+    void on_vkGetDeviceQueue2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                              VkDevice boxed_device, const VkDeviceQueueInfo2* pQueueInfo,
+                              VkQueue* pQueue) {
         // Protected memory is not supported on emulators. So we should
         // not return any queue if a client requests a protected device
         // queue. See b/328436383.
         if (pQueueInfo->flags & VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT) {
             *pQueue = VK_NULL_HANDLE;
-            INFO("%s: Cannot get protected Vulkan device queue", __func__);
+            WARN("%s: Cannot get protected Vulkan device queue", __func__);
             return;
         }
         uint32_t queueFamilyIndex = pQueueInfo->queueFamilyIndex;
         uint32_t queueIndex = pQueueInfo->queueIndex;
-        on_vkGetDeviceQueue(pool, boxed_device, queueFamilyIndex, queueIndex, pQueue);
+        on_vkGetDeviceQueue(pool, snapshotInfo, boxed_device, queueFamilyIndex, queueIndex, pQueue);
     }
 
     void destroyDeviceWithExclusiveInfo(VkDevice device, DeviceInfo& deviceInfo,
                                         std::unordered_map<VkFence, FenceInfo>& fenceInfos,
                                         std::unordered_map<VkQueue, QueueInfo>& queueInfos,
                                         const VkAllocationCallbacks* pAllocator) {
+        m_vkEmulation->getDeviceLostHelper().onDeviceDestroyed(device);
+
         deviceInfo.decompPipelines->clear();
 
         auto eraseIt = queueInfos.begin();
         for (; eraseIt != queueInfos.end();) {
             if (eraseIt->second.device == device) {
-                eraseIt->second.physicalQueueLock.reset();
+                eraseIt->second.queueMutex.reset();
                 delete_VkQueue(eraseIt->second.boxed);
                 eraseIt = queueInfos.erase(eraseIt);
             } else {
@@ -2284,37 +2267,44 @@ class VkDecoderGlobalState::Impl {
             deviceDispatch->vkDestroyFence(device, fence, pAllocator);
             fenceInfos.erase(fence);
         }
+        deviceInfo.externalFencePool.reset();
 
         // Run the underlying API call.
-        m_vk->vkDestroyDevice(device, pAllocator);
+        {
+            AutoLock lock(*graphicsDriverLock());
+            m_vk->vkDestroyDevice(device, pAllocator);
+        }
 
+        INFO("Destroyed VkDevice:%p", device);
         delete_VkDevice(deviceInfo.boxed);
     }
 
-    void destroyDeviceLocked(VkDevice device, const VkAllocationCallbacks* pAllocator) {
+    void destroyDeviceLocked(VkDevice device, const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto deviceInfoIt = mDeviceInfo.find(device);
         if (deviceInfoIt == mDeviceInfo.end()) return;
-        auto& deviceInfo = deviceInfoIt->second;
 
-        destroyDeviceWithExclusiveInfo(device, deviceInfo, mFenceInfo, mQueueInfo, pAllocator);
+        InstanceObjects::DeviceObjects deviceObjects;
+        deviceObjects.device = mDeviceInfo.extract(deviceInfoIt);
+        extractDeviceAndDependenciesLocked(device, deviceObjects);
+        destroyDeviceObjects(deviceObjects);
 
         mDeviceInfo.erase(device);
         mDeviceToPhysicalDevice.erase(device);
     }
 
-    void on_vkDestroyDevice(android::base::BumpPool* pool, VkDevice boxed_device,
-                            const VkAllocationCallbacks* pAllocator) {
+    void on_vkDestroyDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                            VkDevice boxed_device, const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        processDelayedRemovesForDevice(device);
 
-        sBoxedHandleManager.processDelayedRemovesGlobalStateLocked(device);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         destroyDeviceLocked(device, pAllocator);
     }
 
-    VkResult on_vkCreateBuffer(android::base::BumpPool* pool, VkDevice boxed_device,
-                               const VkBufferCreateInfo* pCreateInfo,
+    VkResult on_vkCreateBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                               VkDevice boxed_device, const VkBufferCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
@@ -2339,7 +2329,7 @@ class VkDecoderGlobalState::Impl {
 
         VkExternalMemoryBufferCreateInfo externalCI = {
             VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO};
-        if (m_emu->features.VulkanAllocateHostMemory.enabled) {
+        if (m_vkEmulation->getFeatures().VulkanAllocateHostMemory.enabled) {
             localCreateInfo = *pCreateInfo;
             // Hint that we 'may' use host allocation for this buffer. This will only be used for
             // host visible memory.
@@ -2355,7 +2345,7 @@ class VkDecoderGlobalState::Impl {
         VkResult result = vk->vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
 
         if (result == VK_SUCCESS) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             VALIDATE_NEW_HANDLE_INFO_ENTRY(mBufferInfo, *pBuffer);
             auto& bufInfo = mBufferInfo[*pBuffer];
             bufInfo.device = device;
@@ -2374,7 +2364,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     void destroyBufferLocked(VkDevice device, VulkanDispatch* deviceDispatch, VkBuffer buffer,
-                             const VkAllocationCallbacks* pAllocator) {
+                             const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto bufferInfoIt = mBufferInfo.find(buffer);
         if (bufferInfoIt == mBufferInfo.end()) return;
         auto& bufferInfo = bufferInfoIt->second;
@@ -2384,19 +2374,23 @@ class VkDecoderGlobalState::Impl {
         mBufferInfo.erase(buffer);
     }
 
-    void on_vkDestroyBuffer(android::base::BumpPool* pool, VkDevice boxed_device, VkBuffer buffer,
+    void on_vkDestroyBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                            VkDevice boxed_device, VkBuffer buffer,
                             const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyBufferLocked(device, deviceDispatch, buffer, pAllocator);
     }
 
-    void setBufferMemoryBindInfoLocked(VkDevice device, VkBuffer buffer, VkDeviceMemory memory,
-                                       VkDeviceSize memoryOffset) {
+    VkResult setBufferMemoryBindInfoLocked(VkDevice device, VkBuffer buffer, VkDeviceMemory memory,
+                                       VkDeviceSize memoryOffset) REQUIRES(mMutex) {
         auto* bufferInfo = android::base::find(mBufferInfo, buffer);
-        if (!bufferInfo) return;
+        if (!bufferInfo) {
+            WARN("%s: failed to find buffer info!", __func__);
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
         bufferInfo->memory = memory;
         bufferInfo->memoryOffset = memoryOffset;
 
@@ -2408,26 +2402,27 @@ class VkDecoderGlobalState::Impl {
                                                            *memoryInfo->boundBuffer);
             }
         }
+        return VK_SUCCESS;
     }
 
-    VkResult on_vkBindBufferMemory(android::base::BumpPool* pool, VkDevice boxed_device,
-                                   VkBuffer buffer, VkDeviceMemory memory,
+    VkResult on_vkBindBufferMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                   VkDevice boxed_device, VkBuffer buffer, VkDeviceMemory memory,
                                    VkDeviceSize memoryOffset) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
         VALIDATE_REQUIRED_HANDLE(memory);
         VkResult result = vk->vkBindBufferMemory(device, buffer, memory, memoryOffset);
-
-        if (result == VK_SUCCESS) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-            setBufferMemoryBindInfoLocked(device, buffer, memory, memoryOffset);
+        if (result != VK_SUCCESS) {
+            return result;
         }
-        return result;
+
+        std::lock_guard<std::mutex> lock(mMutex);
+        return setBufferMemoryBindInfoLocked(device, buffer, memory, memoryOffset);
     }
 
-    VkResult on_vkBindBufferMemory2(android::base::BumpPool* pool, VkDevice boxed_device,
-                                    uint32_t bindInfoCount,
+    VkResult on_vkBindBufferMemory2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                    VkDevice boxed_device, uint32_t bindInfoCount,
                                     const VkBindBufferMemoryInfo* pBindInfos) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
@@ -2436,20 +2431,24 @@ class VkDecoderGlobalState::Impl {
             VALIDATE_REQUIRED_HANDLE(pBindInfos[i].memory);
         }
         VkResult result = vk->vkBindBufferMemory2(device, bindInfoCount, pBindInfos);
+        if (result != VK_SUCCESS) {
+            return result;
+        }
 
-        if (result == VK_SUCCESS) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-            for (uint32_t i = 0; i < bindInfoCount; ++i) {
-                setBufferMemoryBindInfoLocked(device, pBindInfos[i].buffer, pBindInfos[i].memory,
-                                              pBindInfos[i].memoryOffset);
+        std::lock_guard<std::mutex> lock(mMutex);
+        for (uint32_t i = 0; i < bindInfoCount; ++i) {
+            result = setBufferMemoryBindInfoLocked(device, pBindInfos[i].buffer, pBindInfos[i].memory,
+                                            pBindInfos[i].memoryOffset);
+            if (result != VK_SUCCESS) {
+                return result;
             }
         }
 
-        return result;
+        return VK_SUCCESS;
     }
 
-    VkResult on_vkBindBufferMemory2KHR(android::base::BumpPool* pool, VkDevice boxed_device,
-                                       uint32_t bindInfoCount,
+    VkResult on_vkBindBufferMemory2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                       VkDevice boxed_device, uint32_t bindInfoCount,
                                        const VkBindBufferMemoryInfo* pBindInfos) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
@@ -2460,7 +2459,7 @@ class VkDecoderGlobalState::Impl {
         VkResult result = vk->vkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
 
         if (result == VK_SUCCESS) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             for (uint32_t i = 0; i < bindInfoCount; ++i) {
                 setBufferMemoryBindInfoLocked(device, pBindInfos[i].buffer, pBindInfos[i].memory,
                                               pBindInfos[i].memoryOffset);
@@ -2470,8 +2469,8 @@ class VkDecoderGlobalState::Impl {
         return result;
     }
 
-    VkResult on_vkCreateImage(android::base::BumpPool* pool, VkDevice boxed_device,
-                              const VkImageCreateInfo* pCreateInfo,
+    VkResult on_vkCreateImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                              VkDevice boxed_device, const VkImageCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator, VkImage* pImage,
                               bool boxImage = true) {
         auto device = unbox_VkDevice(boxed_device);
@@ -2491,7 +2490,7 @@ class VkDecoderGlobalState::Impl {
             return VK_ERROR_INITIALIZATION_FAILED;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
         if (!deviceInfo) {
@@ -2534,12 +2533,14 @@ class VkDecoderGlobalState::Impl {
             const VkPhysicalDeviceMemoryProperties& memoryProperties =
                 physicalDeviceInfo->memoryPropertiesHelper->getHostMemoryProperties();
 
-            anbInfo = std::make_unique<AndroidNativeBufferInfo>();
-            createRes =
-                prepareAndroidNativeBufferImage(vk, device, *pool, pCreateInfo, nativeBufferANDROID,
-                                                pAllocator, &memoryProperties, anbInfo.get());
+            anbInfo = AndroidNativeBufferInfo::create(
+                m_vkEmulation, vk, device, *pool, pCreateInfo, nativeBufferANDROID, pAllocator, &memoryProperties);
+            if (anbInfo == nullptr) {
+                createRes = VK_ERROR_OUT_OF_DEVICE_MEMORY;
+            }
+
             if (createRes == VK_SUCCESS) {
-                *pImage = anbInfo->image;
+                *pImage = anbInfo->getImage();
             }
         } else {
             createRes = vk->vkCreateImage(device, pCreateInfo, pAllocator, pImage);
@@ -2564,7 +2565,7 @@ class VkDecoderGlobalState::Impl {
         imageInfo.cmpInfo = std::move(cmpInfo);
         imageInfo.imageCreateInfoShallow = vk_make_orphan_copy(*pCreateInfo);
         imageInfo.layout = pCreateInfo->initialLayout;
-        if (nativeBufferANDROID) imageInfo.anbInfo = std::move(anbInfo);
+        imageInfo.anbInfo = std::move(anbInfo);
 
         if (boxImage) {
             *pImage = new_boxed_non_dispatchable_VkImage(*pImage);
@@ -2586,7 +2587,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     void destroyImageLocked(VkDevice device, VulkanDispatch* deviceDispatch, VkImage image,
-                            const VkAllocationCallbacks* pAllocator) {
+                            const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto imageInfoIt = mImageInfo.find(image);
         if (imageInfoIt == mImageInfo.end()) return;
         auto& imageInfo = imageInfoIt->second;
@@ -2596,27 +2597,26 @@ class VkDecoderGlobalState::Impl {
         mImageInfo.erase(image);
     }
 
-    void on_vkDestroyImage(android::base::BumpPool* pool, VkDevice boxed_device, VkImage image,
+    void on_vkDestroyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                           VkDevice boxed_device, VkImage image,
                            const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyImageLocked(device, deviceDispatch, image, pAllocator);
     }
 
     VkResult performBindImageMemoryDeferredAhb(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* snapshotInfo,
                                                VkDevice boxed_device,
                                                const VkBindImageMemoryInfo* bimi) {
-        auto device = unbox_VkDevice(boxed_device);
-        auto vk = dispatch_VkDevice(boxed_device);
-
         auto original_underlying_image = bimi->image;
         auto original_boxed_image = unboxed_to_boxed_non_dispatchable_VkImage(original_underlying_image);
 
         VkImageCreateInfo ici = {};
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
 
             auto* imageInfo = android::base::find(mImageInfo, original_underlying_image);
             if (!imageInfo) {
@@ -2634,17 +2634,17 @@ class VkDecoderGlobalState::Impl {
         }
 
         VkImage underlying_replacement_image = VK_NULL_HANDLE;
-        VkResult result = on_vkCreateImage(pool, boxed_device, &ici, nullptr,
+        VkResult result = on_vkCreateImage(pool, snapshotInfo, boxed_device, &ici, nullptr,
                                            &underlying_replacement_image, false);
         if (result != VK_SUCCESS) {
             ERR("Failed to create image for deferred AHB bind.");
             return VK_ERROR_OUT_OF_HOST_MEMORY;
         }
 
-        on_vkDestroyImage(pool, boxed_device, original_underlying_image, nullptr);
+        on_vkDestroyImage(pool, snapshotInfo, boxed_device, original_underlying_image, nullptr);
 
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
 
             set_boxed_non_dispatchable_VkImage(original_boxed_image, underlying_replacement_image);
             const_cast<VkBindImageMemoryInfo*>(bimi)->image = underlying_replacement_image;
@@ -2654,15 +2654,16 @@ class VkDecoderGlobalState::Impl {
         return VK_SUCCESS;
     }
 
-    VkResult performBindImageMemory(android::base::BumpPool* pool, VkDevice boxed_device,
-                                    const VkBindImageMemoryInfo* bimi) {
+    VkResult performBindImageMemory(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+                                    const VkBindImageMemoryInfo* bimi) EXCLUDES(mMutex) {
         auto image = bimi->image;
         auto memory = bimi->memory;
         auto memoryOffset = bimi->memoryOffset;
 
         const auto* anb = vk_find_struct<VkNativeBufferANDROID>(bimi);
         if (memory == VK_NULL_HANDLE && anb != nullptr) {
-            return performBindImageMemoryDeferredAhb(pool, boxed_device, bimi);
+            return performBindImageMemoryDeferredAhb(pool, snapshotInfo, boxed_device, bimi);
         }
 
         auto device = unbox_VkDevice(boxed_device);
@@ -2674,7 +2675,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
         if (!deviceInfo) return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -2702,8 +2703,10 @@ class VkDecoderGlobalState::Impl {
         return cmpInfo.bindCompressedMipmapsMemory(vk, memory, memoryOffset);
     }
 
-    VkResult on_vkBindImageMemory(android::base::BumpPool* pool, VkDevice boxed_device,
-                                  VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
+    VkResult on_vkBindImageMemory(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+                                  VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset)
+        EXCLUDES(mMutex) {
         const VkBindImageMemoryInfo bimi = {
             .sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
             .pNext = nullptr,
@@ -2711,13 +2714,14 @@ class VkDecoderGlobalState::Impl {
             .memory = memory,
             .memoryOffset = memoryOffset,
         };
-        return performBindImageMemory(pool, boxed_device, &bimi);
+        return performBindImageMemory(pool, snapshotInfo, boxed_device, &bimi);
     }
 
-    VkResult on_vkBindImageMemory2(android::base::BumpPool* pool, VkDevice boxed_device,
-                                   uint32_t bindInfoCount,
-                                   const VkBindImageMemoryInfo* pBindInfos) {
-#ifdef GFXSTREAM_BUILD_WITH_SNAPSHOT_SUPPORT
+    VkResult on_vkBindImageMemory2(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+                                   uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos)
+        EXCLUDES(mMutex) {
+#ifdef CONFIG_AEMU
         if (bindInfoCount > 1 && snapshotsEnabled()) {
             if (mVerbosePrints) {
                 fprintf(stderr,
@@ -2730,31 +2734,36 @@ class VkDecoderGlobalState::Impl {
 
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
+
         bool needEmulation = false;
 
-        auto* deviceInfo = android::base::find(mDeviceInfo, device);
-        if (!deviceInfo) return VK_ERROR_UNKNOWN;
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
 
-        for (uint32_t i = 0; i < bindInfoCount; i++) {
-            auto* imageInfo = android::base::find(mImageInfo, pBindInfos[i].image);
-            if (!imageInfo) return VK_ERROR_UNKNOWN;
+            auto* deviceInfo = android::base::find(mDeviceInfo, device);
+            if (!deviceInfo) return VK_ERROR_UNKNOWN;
 
-            const auto* anb = vk_find_struct<VkNativeBufferANDROID>(&pBindInfos[i]);
-            if (anb != nullptr) {
-                needEmulation = true;
-                break;
-            }
+            for (uint32_t i = 0; i < bindInfoCount; i++) {
+                auto* imageInfo = android::base::find(mImageInfo, pBindInfos[i].image);
+                if (!imageInfo) return VK_ERROR_UNKNOWN;
 
-            if (deviceInfo->needEmulatedDecompression(imageInfo->cmpInfo)) {
-                needEmulation = true;
-                break;
+                const auto* anb = vk_find_struct<VkNativeBufferANDROID>(&pBindInfos[i]);
+                if (anb != nullptr) {
+                    needEmulation = true;
+                    break;
+                }
+
+                if (deviceInfo->needEmulatedDecompression(imageInfo->cmpInfo)) {
+                    needEmulation = true;
+                    break;
+                }
             }
         }
 
         if (needEmulation) {
             VkResult result;
             for (uint32_t i = 0; i < bindInfoCount; i++) {
-                result = performBindImageMemory(pool, boxed_device, &pBindInfos[i]);
+                result = performBindImageMemory(pool, snapshotInfo, boxed_device, &pBindInfos[i]);
                 if (result != VK_SUCCESS) return result;
             }
 
@@ -2766,24 +2775,33 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        if (deviceInfo->debugUtilsHelper.isEnabled()) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+
+            auto* deviceInfo = android::base::find(mDeviceInfo, device);
+            if (!deviceInfo) return VK_ERROR_UNKNOWN;
+
             for (uint32_t i = 0; i < bindInfoCount; i++) {
                 auto* memoryInfo = android::base::find(mMemoryInfo, pBindInfos[i].memory);
                 if (!memoryInfo) return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-                if (memoryInfo->boundColorBuffer) {
+                auto* imageInfo = android::base::find(mImageInfo, pBindInfos[i].image);
+                if (!imageInfo) return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+                imageInfo->boundColorBuffer = memoryInfo->boundColorBuffer;
+                if (memoryInfo->boundColorBuffer && deviceInfo->debugUtilsHelper.isEnabled()) {
                     deviceInfo->debugUtilsHelper.addDebugLabel(
                         pBindInfos[i].image, "ColorBuffer:%d", *memoryInfo->boundColorBuffer);
                 }
+                imageInfo->memory = pBindInfos[i].memory;
             }
         }
 
         return result;
     }
 
-    VkResult on_vkCreateImageView(android::base::BumpPool* pool, VkDevice boxed_device,
-                                  const VkImageViewCreateInfo* pCreateInfo,
+    VkResult on_vkCreateImageView(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                  VkDevice boxed_device, const VkImageViewCreateInfo* pCreateInfo,
                                   const VkAllocationCallbacks* pAllocator, VkImageView* pView) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
@@ -2791,7 +2809,7 @@ class VkDecoderGlobalState::Impl {
             return VK_ERROR_OUT_OF_HOST_MEMORY;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
         auto* imageInfo = android::base::find(mImageInfo, pCreateInfo->image);
         if (!deviceInfo || !imageInfo) return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -2816,7 +2834,7 @@ class VkDecoderGlobalState::Impl {
             createInfo.subresourceRange.baseMipLevel = 0;
             pCreateInfo = &createInfo;
         }
-        if (imageInfo->anbInfo && imageInfo->anbInfo->externallyBacked) {
+        if (imageInfo->anbInfo && imageInfo->anbInfo->isExternallyBacked()) {
             createInfo = *pCreateInfo;
             pCreateInfo = &createInfo;
         }
@@ -2847,7 +2865,8 @@ class VkDecoderGlobalState::Impl {
     }
 
     void destroyImageViewLocked(VkDevice device, VulkanDispatch* deviceDispatch,
-                                VkImageView imageView, const VkAllocationCallbacks* pAllocator) {
+                                VkImageView imageView, const VkAllocationCallbacks* pAllocator)
+        REQUIRES(mMutex) {
         auto imageViewInfoIt = mImageViewInfo.find(imageView);
         if (imageViewInfoIt == mImageViewInfo.end()) return;
         auto& imageViewInfo = imageViewInfoIt->second;
@@ -2858,17 +2877,18 @@ class VkDecoderGlobalState::Impl {
         mImageViewInfo.erase(imageView);
     }
 
-    void on_vkDestroyImageView(android::base::BumpPool* pool, VkDevice boxed_device,
-                               VkImageView imageView, const VkAllocationCallbacks* pAllocator) {
+    void on_vkDestroyImageView(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                               VkDevice boxed_device, VkImageView imageView,
+                               const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyImageViewLocked(device, deviceDispatch, imageView, pAllocator);
     }
 
-    VkResult on_vkCreateSampler(android::base::BumpPool* pool, VkDevice boxed_device,
-                                const VkSamplerCreateInfo* pCreateInfo,
+    VkResult on_vkCreateSampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                VkDevice boxed_device, const VkSamplerCreateInfo* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator, VkSampler* pSampler) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
@@ -2876,7 +2896,7 @@ class VkDecoderGlobalState::Impl {
         if (result != VK_SUCCESS) {
             return result;
         }
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         VALIDATE_NEW_HANDLE_INFO_ENTRY(mSamplerInfo, *pSampler);
         auto& samplerInfo = mSamplerInfo[*pSampler];
         samplerInfo.device = device;
@@ -2909,7 +2929,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     void destroySamplerLocked(VkDevice device, VulkanDispatch* deviceDispatch, VkSampler sampler,
-                              const VkAllocationCallbacks* pAllocator) {
+                              const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto samplerInfoIt = mSamplerInfo.find(sampler);
         if (samplerInfoIt == mSamplerInfo.end()) return;
         auto& samplerInfo = samplerInfoIt->second;
@@ -2919,18 +2939,20 @@ class VkDecoderGlobalState::Impl {
         mSamplerInfo.erase(samplerInfoIt);
     }
 
-    void on_vkDestroySampler(android::base::BumpPool* pool, VkDevice boxed_device,
-                             VkSampler sampler, const VkAllocationCallbacks* pAllocator) {
+    void on_vkDestroySampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                             VkDevice boxed_device, VkSampler sampler,
+                             const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroySamplerLocked(device, deviceDispatch, sampler, pAllocator);
     }
 
     VkResult exportSemaphore(
         VulkanDispatch* vk, VkDevice device, VkSemaphore semaphore, VK_EXT_SYNC_HANDLE* outHandle,
-        std::optional<VkExternalSemaphoreHandleTypeFlagBits> handleType = std::nullopt) {
+        std::optional<VkExternalSemaphoreHandleTypeFlagBits> handleType = std::nullopt)
+        EXCLUDES(mMutex) {
 #if defined(_WIN32)
         VkSemaphoreGetWin32HandleInfoKHR getWin32 = {
             VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
@@ -2954,11 +2976,14 @@ class VkDecoderGlobalState::Impl {
             handleTypeBits,
         };
 
-        if (!hasDeviceExtension(device, VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME)) {
-            // Note: VK_KHR_external_semaphore_fd might be advertised in the guest,
-            // because SYNC_FD handling is performed guest-side only. But still need
-            // need to error out here when handling a non-sync, opaque FD.
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+            if (!hasDeviceExtension(device, VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME)) {
+                // Note: VK_KHR_external_semaphore_fd might be advertised in the guest,
+                // because SYNC_FD handling is performed guest-side only. But still need
+                // need to error out here when handling a non-sync, opaque FD.
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
         }
 
         return vk->vkGetSemaphoreFdKHR(device, &getFd, outHandle);
@@ -2967,8 +2992,8 @@ class VkDecoderGlobalState::Impl {
 #endif
     }
 
-    VkResult on_vkCreateSemaphore(android::base::BumpPool* pool, VkDevice boxed_device,
-                                  const VkSemaphoreCreateInfo* pCreateInfo,
+    VkResult on_vkCreateSemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                  VkDevice boxed_device, const VkSemaphoreCreateInfo* pCreateInfo,
                                   const VkAllocationCallbacks* pAllocator,
                                   VkSemaphore* pSemaphore) {
         auto device = unbox_VkDevice(boxed_device);
@@ -3004,12 +3029,12 @@ class VkDecoderGlobalState::Impl {
          *  We just don't support this here since neither Android or Zink use this feature
          *  with timeline semaphores yet.
          */
-        if (m_emu->features.VulkanExternalSync.enabled && !timelineSemaphore) {
+        if (m_vkEmulation->getFeatures().VulkanExternalSync.enabled && !timelineSemaphore) {
             localExportSemaphoreCi.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
             localExportSemaphoreCi.pNext = nullptr;
 
             {
-                std::lock_guard<std::recursive_mutex> lock(mLock);
+                std::lock_guard<std::mutex> lock(mMutex);
                 auto* deviceInfo = android::base::find(mDeviceInfo, device);
 
                 if (!deviceInfo) {
@@ -3038,7 +3063,7 @@ class VkDecoderGlobalState::Impl {
 
         if (res != VK_SUCCESS) return res;
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         VALIDATE_NEW_HANDLE_INFO_ENTRY(mSemaphoreInfo, *pSemaphore);
         auto& semaphoreInfo = mSemaphoreInfo[*pSemaphore];
@@ -3049,23 +3074,20 @@ class VkDecoderGlobalState::Impl {
         return res;
     }
 
-    VkResult on_vkCreateFence(android::base::BumpPool* pool, VkDevice boxed_device,
-                              const VkFenceCreateInfo* pCreateInfo,
+    VkResult on_vkCreateFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                              VkDevice boxed_device, const VkFenceCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
-        VkFenceCreateInfo localCreateInfo;
+        auto device = unbox_VkDevice(boxed_device);
+        auto vk = dispatch_VkDevice(boxed_device);
+
+        VkFenceCreateInfo localCreateInfo = *pCreateInfo;
         if (mSnapshotState == SnapshotState::Loading) {
             // On snapshot load we create all fences as signaled then reset those that are not.
-            localCreateInfo = *pCreateInfo;
-            pCreateInfo = &localCreateInfo;
             localCreateInfo.flags |= VK_FENCE_CREATE_SIGNALED_BIT;
         }
-        auto device = unbox_VkDevice(boxed_device);
-        auto vk = dispatch_VkDevice(boxed_device);
-
-        VkFenceCreateInfo& createInfo = const_cast<VkFenceCreateInfo&>(*pCreateInfo);
 
         const VkExportFenceCreateInfo* exportFenceInfoPtr =
-            vk_find_struct<VkExportFenceCreateInfo>(pCreateInfo);
+            vk_find_struct<VkExportFenceCreateInfo>(&localCreateInfo);
         bool exportSyncFd = exportFenceInfoPtr && (exportFenceInfoPtr->handleTypes &
                                                    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT);
         bool fenceReused = false;
@@ -3076,28 +3098,28 @@ class VkDecoderGlobalState::Impl {
             // Remove VkExportFenceCreateInfo, since host doesn't need to create
             // an exportable fence in this case
             ExternalFencePool<VulkanDispatch>* externalFencePool = nullptr;
-            vk_struct_chain_remove(exportFenceInfoPtr, &createInfo);
+            vk_struct_chain_remove(exportFenceInfoPtr, &localCreateInfo);
             {
-                std::lock_guard<std::recursive_mutex> lock(mLock);
+                std::lock_guard<std::mutex> lock(mMutex);
                 auto* deviceInfo = android::base::find(mDeviceInfo, device);
                 if (!deviceInfo) return VK_ERROR_OUT_OF_HOST_MEMORY;
                 externalFencePool = deviceInfo->externalFencePool.get();
             }
-            *pFence = externalFencePool->pop(pCreateInfo);
+            *pFence = externalFencePool->pop(&localCreateInfo);
             if (*pFence != VK_NULL_HANDLE) {
                 fenceReused = true;
             }
         }
 
         if (*pFence == VK_NULL_HANDLE) {
-            VkResult res = vk->vkCreateFence(device, &createInfo, pAllocator, pFence);
+            VkResult res = vk->vkCreateFence(device, &localCreateInfo, pAllocator, pFence);
             if (res != VK_SUCCESS) {
                 return res;
             }
         }
 
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
 
             // Create FenceInfo for *pFence.
             if (!fenceReused) {
@@ -3110,14 +3132,45 @@ class VkDecoderGlobalState::Impl {
             *pFence = new_boxed_non_dispatchable_VkFence(*pFence);
             fenceInfo.boxed = *pFence;
             fenceInfo.external = exportSyncFd;
-            fenceInfo.state = FenceInfo::State::kNotWaitable;
+
+            if (localCreateInfo.flags & VK_FENCE_CREATE_SIGNALED_BIT) {
+                fenceInfo.state = FenceInfo::State::kWaitable;
+            } else {
+                fenceInfo.state = FenceInfo::State::kNotWaitable;
+            }
         }
 
         return VK_SUCCESS;
     }
 
-    VkResult on_vkResetFences(android::base::BumpPool* pool, VkDevice boxed_device,
-                              uint32_t fenceCount, const VkFence* pFences) {
+    VkResult on_vkGetFenceStatus(android::base::BumpPool*, VkSnapshotApiCallInfo*,
+                                 VkDevice boxed_device, VkFence fence) {
+        auto device = unbox_VkDevice(boxed_device);
+        auto vk = dispatch_VkDevice(boxed_device);
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+            auto* fenceInfo = android::base::find(mFenceInfo, fence);
+            if (!fenceInfo) {
+                ERR("%s: Invalid fence %p", fence);
+                return VK_SUCCESS;
+            }
+        }
+
+        return vk->vkGetFenceStatus(device, fence);
+    }
+
+    VkResult on_vkWaitForFences(android::base::BumpPool*, VkSnapshotApiCallInfo*,
+                                VkDevice boxed_device, uint32_t fenceCount, const VkFence* pFences,
+                                VkBool32 waitAll, uint64_t timeout) {
+        auto device = unbox_VkDevice(boxed_device);
+        auto vk = dispatch_VkDevice(boxed_device);
+
+        // TODO(b/397501277): wait state checks cause test failures on old API levels
+        return waitForFences(device, vk, fenceCount, pFences, waitAll, timeout, false);
+    }
+
+    VkResult on_vkResetFences(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                              VkDevice boxed_device, uint32_t fenceCount, const VkFence* pFences) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
@@ -3125,7 +3178,7 @@ class VkDecoderGlobalState::Impl {
         std::vector<VkFence> externalFences;
 
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             for (uint32_t i = 0; i < fenceCount; i++) {
                 if (pFences[i] == VK_NULL_HANDLE) continue;
 
@@ -3151,7 +3204,13 @@ class VkDecoderGlobalState::Impl {
         // For external fences, we unilaterally put them in the pool to ensure they finish
         // TODO: should store creation info / pNext chain per fence and re-apply?
         VkFenceCreateInfo createInfo{
-            .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, .pNext = 0, .flags = 0};
+            .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
+            .pNext = 0,
+            .flags = 0,
+        };
+
+        std::lock_guard<std::mutex> lock(mMutex);
+
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
         if (!deviceInfo) return VK_ERROR_OUT_OF_DEVICE_MEMORY;
         for (auto fence : externalFences) {
@@ -3162,7 +3221,6 @@ class VkDecoderGlobalState::Impl {
             deviceInfo->externalFencePool->add(fence);
 
             {
-                std::lock_guard<std::recursive_mutex> lock(mLock);
                 auto boxed_fence = unboxed_to_boxed_non_dispatchable_VkFence(fence);
                 set_boxed_non_dispatchable_VkFence(boxed_fence, replacement);
 
@@ -3180,23 +3238,26 @@ class VkDecoderGlobalState::Impl {
         return VK_SUCCESS;
     }
 
-    VkResult on_vkImportSemaphoreFdKHR(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkImportSemaphoreFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                       VkDevice boxed_device,
                                        const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
 #ifdef _WIN32
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        VK_EXT_SYNC_HANDLE handle = VK_EXT_SYNC_HANDLE_INVALID;
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
 
-        auto* infoPtr = android::base::find(mSemaphoreInfo,
-                                            mExternalSemaphoresById[pImportSemaphoreFdInfo->fd]);
+            auto* infoPtr = android::base::find(
+                mSemaphoreInfo, mExternalSemaphoresById[pImportSemaphoreFdInfo->fd]);
+            if (!infoPtr) {
+                return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            }
 
-        if (!infoPtr) {
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            handle = dupExternalSync(infoPtr->externalHandle);
         }
 
-        VK_EXT_SYNC_HANDLE handle = dupExternalSync(infoPtr->externalHandle);
-
         VkImportSemaphoreWin32HandleInfoKHR win32ImportInfo = {
             VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
             0,
@@ -3209,11 +3270,15 @@ class VkDecoderGlobalState::Impl {
 
         return vk->vkImportSemaphoreWin32HandleKHR(device, &win32ImportInfo);
 #else
-        if (!hasDeviceExtension(device, VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME)) {
-            // Note: VK_KHR_external_semaphore_fd might be advertised in the guest,
-            // because SYNC_FD handling is performed guest-side only. But still need
-            // need to error out here when handling a non-sync, opaque FD.
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+
+            if (!hasDeviceExtension(device, VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME)) {
+                // Note: VK_KHR_external_semaphore_fd might be advertised in the guest,
+                // because SYNC_FD handling is performed guest-side only. But still need
+                // need to error out here when handling a non-sync, opaque FD.
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
         }
 
         VkImportSemaphoreFdInfoKHR importInfo = *pImportSemaphoreFdInfo;
@@ -3222,7 +3287,8 @@ class VkDecoderGlobalState::Impl {
 #endif
     }
 
-    VkResult on_vkGetSemaphoreFdKHR(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkGetSemaphoreFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                    VkDevice boxed_device,
                                     const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
@@ -3233,7 +3299,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         mSemaphoreInfo[pGetFdInfo->semaphore].externalHandle = handle;
 #ifdef _WIN32
         int nextId = genSemaphoreId();
@@ -3246,9 +3312,10 @@ class VkDecoderGlobalState::Impl {
         return result;
     }
 
-    VkResult on_vkGetSemaphoreGOOGLE(android::base::BumpPool* pool, VkDevice boxed_device,
-                                     VkSemaphore semaphore, uint64_t syncId) {
-        if (!m_emu->features.VulkanExternalSync.enabled) {
+    VkResult on_vkGetSemaphoreGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                     VkDevice boxed_device, VkSemaphore semaphore,
+                                     uint64_t syncId) {
+        if (!m_vkEmulation->getFeatures().VulkanExternalSync.enabled) {
             return VK_ERROR_FEATURE_NOT_PRESENT;
         }
 
@@ -3259,7 +3326,7 @@ class VkDecoderGlobalState::Impl {
         VkExternalSemaphoreHandleTypeFlagBits flagBits =
             static_cast<VkExternalSemaphoreHandleTypeFlagBits>(0);
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             auto* deviceInfo = android::base::find(mDeviceInfo, device);
 
             if (!deviceInfo) {
@@ -3299,7 +3366,8 @@ class VkDecoderGlobalState::Impl {
     }
 
     void destroySemaphoreWithExclusiveInfo(VkDevice device, VulkanDispatch* deviceDispatch,
-                                           VkSemaphore semaphore, SemaphoreInfo& semaphoreInfo,
+                                           VkSemaphore semaphore, DeviceInfo& deviceInfo,
+                                           SemaphoreInfo& semaphoreInfo,
                                            const VkAllocationCallbacks* pAllocator) {
 #ifndef _WIN32
         if (semaphoreInfo.externalHandle != VK_EXT_SYNC_HANDLE_INVALID) {
@@ -3308,38 +3376,57 @@ class VkDecoderGlobalState::Impl {
 #endif
 
         if (semaphoreInfo.latestUse && !IsDone(*semaphoreInfo.latestUse)) {
-            auto deviceInfoIt = mDeviceInfo.find(device);
-            if (deviceInfoIt != mDeviceInfo.end()) {
-                auto& deviceInfo = deviceInfoIt->second;
-                deviceInfo.deviceOpTracker->AddPendingGarbage(*semaphoreInfo.latestUse, semaphore);
-                deviceInfo.deviceOpTracker->PollAndProcessGarbage();
-            }
+            deviceInfo.deviceOpTracker->AddPendingGarbage(*semaphoreInfo.latestUse, semaphore);
+            deviceInfo.deviceOpTracker->PollAndProcessGarbage();
         } else {
             deviceDispatch->vkDestroySemaphore(device, semaphore, pAllocator);
         }
     }
 
     void destroySemaphoreLocked(VkDevice device, VulkanDispatch* deviceDispatch,
-                                VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator) {
+                                VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator)
+        REQUIRES(mMutex) {
+        auto deviceInfoIt = mDeviceInfo.find(device);
+        if (deviceInfoIt == mDeviceInfo.end()) return;
+        auto& deviceInfo = deviceInfoIt->second;
+
         auto semaphoreInfoIt = mSemaphoreInfo.find(semaphore);
         if (semaphoreInfoIt == mSemaphoreInfo.end()) return;
         auto& semaphoreInfo = semaphoreInfoIt->second;
 
-        destroySemaphoreWithExclusiveInfo(device, deviceDispatch, semaphore, semaphoreInfo,
-                                          pAllocator);
+        destroySemaphoreWithExclusiveInfo(device, deviceDispatch, semaphore, deviceInfo,
+                                          semaphoreInfo, pAllocator);
 
         mSemaphoreInfo.erase(semaphoreInfoIt);
     }
 
-    void on_vkDestroySemaphore(android::base::BumpPool* pool, VkDevice boxed_device,
-                               VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator) {
+    void on_vkDestroySemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                               VkDevice boxed_device, VkSemaphore semaphore,
+                               const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroySemaphoreLocked(device, deviceDispatch, semaphore, pAllocator);
     }
 
+    VkResult on_vkWaitSemaphores(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                             VkDevice boxed_device, const VkSemaphoreWaitInfo* pWaitInfo,
+                             uint64_t timeout) {
+        auto device = unbox_VkDevice(boxed_device);
+        auto deviceDispatch = dispatch_VkDevice(boxed_device);
+
+        return deviceDispatch->vkWaitSemaphores(device, pWaitInfo, timeout);
+    }
+
+    VkResult on_vkSignalSemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                  VkDevice boxed_device, const VkSemaphoreSignalInfo* pSignalInfo) {
+        auto device = unbox_VkDevice(boxed_device);
+        auto deviceDispatch = dispatch_VkDevice(boxed_device);
+
+        return deviceDispatch->vkSignalSemaphore(device, pSignalInfo);
+    }
+
     enum class DestroyFenceStatus { kDestroyed, kRecycled };
 
     DestroyFenceStatus destroyFenceWithExclusiveInfo(VkDevice device,
@@ -3371,7 +3458,7 @@ class VkDecoderGlobalState::Impl {
 
     void destroyFenceLocked(VkDevice device, VulkanDispatch* deviceDispatch, VkFence fence,
                             const VkAllocationCallbacks* pAllocator,
-                            bool allowExternalFenceRecycling) {
+                            bool allowExternalFenceRecycling) REQUIRES(mMutex) {
         auto fenceInfoIt = mFenceInfo.find(fence);
         if (fenceInfoIt == mFenceInfo.end()) {
             ERR("Failed to find fence info for VkFence:%p. Leaking fence!", fence);
@@ -3395,18 +3482,20 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkDestroyFence(android::base::BumpPool* pool, VkDevice boxed_device, VkFence fence,
+    void on_vkDestroyFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                           VkDevice boxed_device, VkFence fence,
                            const VkAllocationCallbacks* pAllocator) {
         if (fence == VK_NULL_HANDLE) return;
 
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyFenceLocked(device, deviceDispatch, fence, pAllocator, true);
     }
 
-    VkResult on_vkCreateDescriptorSetLayout(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkCreateDescriptorSetLayout(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                            VkDevice boxed_device,
                                             const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator,
                                             VkDescriptorSetLayout* pSetLayout) {
@@ -3416,7 +3505,7 @@ class VkDecoderGlobalState::Impl {
         auto res = vk->vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
 
         if (res == VK_SUCCESS) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             VALIDATE_NEW_HANDLE_INFO_ENTRY(mDescriptorSetLayoutInfo, *pSetLayout);
             auto& info = mDescriptorSetLayoutInfo[*pSetLayout];
             info.device = device;
@@ -3440,7 +3529,8 @@ class VkDecoderGlobalState::Impl {
 
     void destroyDescriptorSetLayoutLocked(VkDevice device, VulkanDispatch* deviceDispatch,
                                           VkDescriptorSetLayout descriptorSetLayout,
-                                          const VkAllocationCallbacks* pAllocator) {
+                                          const VkAllocationCallbacks* pAllocator)
+        REQUIRES(mMutex) {
         auto descriptorSetLayoutInfoIt = mDescriptorSetLayoutInfo.find(descriptorSetLayout);
         if (descriptorSetLayoutInfoIt == mDescriptorSetLayoutInfo.end()) return;
         auto& descriptorSetLayoutInfo = descriptorSetLayoutInfoIt->second;
@@ -3451,17 +3541,19 @@ class VkDecoderGlobalState::Impl {
         mDescriptorSetLayoutInfo.erase(descriptorSetLayoutInfoIt);
     }
 
-    void on_vkDestroyDescriptorSetLayout(android::base::BumpPool* pool, VkDevice boxed_device,
+    void on_vkDestroyDescriptorSetLayout(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                         VkDevice boxed_device,
                                          VkDescriptorSetLayout descriptorSetLayout,
                                          const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyDescriptorSetLayoutLocked(device, deviceDispatch, descriptorSetLayout, pAllocator);
     }
 
-    VkResult on_vkCreateDescriptorPool(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkCreateDescriptorPool(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
                                        const VkDescriptorPoolCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkDescriptorPool* pDescriptorPool) {
@@ -3471,7 +3563,7 @@ class VkDecoderGlobalState::Impl {
         auto res = vk->vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
 
         if (res == VK_SUCCESS) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             VALIDATE_NEW_HANDLE_INFO_ENTRY(mDescriptorPoolInfo, *pDescriptorPool);
             auto& info = mDescriptorPoolInfo[*pDescriptorPool];
             info.device = device;
@@ -3489,14 +3581,14 @@ class VkDecoderGlobalState::Impl {
                 info.pools.push_back(state);
             }
 
-            if (m_emu->features.VulkanBatchedDescriptorSetUpdate.enabled) {
+            if (m_vkEmulation->getFeatures().VulkanBatchedDescriptorSetUpdate.enabled) {
                 for (uint32_t i = 0; i < pCreateInfo->maxSets; ++i) {
                     info.poolIds.push_back(
                         (uint64_t)new_boxed_non_dispatchable_VkDescriptorSet(VK_NULL_HANDLE));
                 }
-                if (snapshotsEnabled()) {
-                    snapshot()->createExtraHandlesForNextApi(info.poolIds.data(),
-                                                             info.poolIds.size());
+                if (snapshotsEnabled() && snapshotInfo) {
+                    snapshotInfo->addOrderedBoxedHandlesCreatedByCall(info.poolIds.data(),
+                                                                      info.poolIds.size());
                 }
             }
         }
@@ -3511,13 +3603,13 @@ class VkDecoderGlobalState::Impl {
         for (auto it : descriptorPoolInfo.allocedSetsToBoxed) {
             auto unboxedSet = it.first;
             auto boxedSet = it.second;
-            mDescriptorSetInfo.erase(unboxedSet);
-            if (!m_emu->features.VulkanBatchedDescriptorSetUpdate.enabled) {
+            descriptorSetInfos.erase(unboxedSet);
+            if (!m_vkEmulation->getFeatures().VulkanBatchedDescriptorSetUpdate.enabled) {
                 delete_VkDescriptorSet(boxedSet);
             }
         }
 
-        if (m_emu->features.VulkanBatchedDescriptorSetUpdate.enabled) {
+        if (m_vkEmulation->getFeatures().VulkanBatchedDescriptorSetUpdate.enabled) {
             if (isDestroy) {
                 for (auto poolId : descriptorPoolInfo.poolIds) {
                     delete_VkDescriptorSet((VkDescriptorSet)poolId);
@@ -3552,7 +3644,7 @@ class VkDecoderGlobalState::Impl {
 
     void destroyDescriptorPoolLocked(VkDevice device, VulkanDispatch* deviceDispatch,
                                      VkDescriptorPool descriptorPool,
-                                     const VkAllocationCallbacks* pAllocator) {
+                                     const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto descriptorPoolInfoIt = mDescriptorPoolInfo.find(descriptorPool);
         if (descriptorPoolInfoIt == mDescriptorPoolInfo.end()) return;
         auto& descriptorPoolInfo = descriptorPoolInfoIt->second;
@@ -3563,17 +3655,17 @@ class VkDecoderGlobalState::Impl {
         mDescriptorPoolInfo.erase(descriptorPoolInfoIt);
     }
 
-    void on_vkDestroyDescriptorPool(android::base::BumpPool* pool, VkDevice boxed_device,
-                                    VkDescriptorPool descriptorPool,
+    void on_vkDestroyDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                    VkDevice boxed_device, VkDescriptorPool descriptorPool,
                                     const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyDescriptorPoolLocked(device, deviceDispatch, descriptorPool, pAllocator);
     }
 
-    void resetDescriptorPoolInfoLocked(VkDescriptorPool descriptorPool) {
+    void resetDescriptorPoolInfoLocked(VkDescriptorPool descriptorPool) REQUIRES(mMutex) {
         auto descriptorPoolInfoIt = mDescriptorPoolInfo.find(descriptorPool);
         if (descriptorPoolInfoIt == mDescriptorPoolInfo.end()) return;
         auto& descriptorPoolInfo = descriptorPoolInfoIt->second;
@@ -3582,8 +3674,8 @@ class VkDecoderGlobalState::Impl {
                                                /*isDestroy=*/false);
     }
 
-    VkResult on_vkResetDescriptorPool(android::base::BumpPool* pool, VkDevice boxed_device,
-                                      VkDescriptorPool descriptorPool,
+    VkResult on_vkResetDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                      VkDevice boxed_device, VkDescriptorPool descriptorPool,
                                       VkDescriptorPoolResetFlags flags) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
@@ -3591,14 +3683,15 @@ class VkDecoderGlobalState::Impl {
         auto result = deviceDispatch->vkResetDescriptorPool(device, descriptorPool, flags);
         if (result != VK_SUCCESS) return result;
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         resetDescriptorPoolInfoLocked(descriptorPool);
 
         return VK_SUCCESS;
     }
 
-    void initDescriptorSetInfoLocked(VkDescriptorPool pool, VkDescriptorSetLayout setLayout,
-                                     uint64_t boxedDescriptorSet, VkDescriptorSet descriptorSet) {
+    void initDescriptorSetInfoLocked(VkDevice device, VkDescriptorPool pool,
+                                     VkDescriptorSetLayout setLayout, uint64_t boxedDescriptorSet,
+                                     VkDescriptorSet descriptorSet) REQUIRES(mMutex) {
         auto* poolInfo = android::base::find(mDescriptorPoolInfo, pool);
         if (!poolInfo) {
             GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Cannot find poolInfo";
@@ -3612,13 +3705,14 @@ class VkDecoderGlobalState::Impl {
         VALIDATE_NEW_HANDLE_INFO_ENTRY(mDescriptorSetInfo, descriptorSet);
         auto& setInfo = mDescriptorSetInfo[descriptorSet];
 
+        setInfo.device = device;
         setInfo.pool = pool;
         setInfo.unboxedLayout = setLayout;
         setInfo.bindings = setLayoutInfo->bindings;
         for (size_t i = 0; i < setInfo.bindings.size(); i++) {
             VkDescriptorSetLayoutBinding dslBinding = setInfo.bindings[i];
             int bindingIdx = dslBinding.binding;
-            if (setInfo.allWrites.size() <= bindingIdx) {
+            if ((int)setInfo.allWrites.size() <= bindingIdx) {
                 setInfo.allWrites.resize(bindingIdx + 1);
             }
             setInfo.allWrites[bindingIdx].resize(dslBinding.descriptorCount);
@@ -3632,13 +3726,14 @@ class VkDecoderGlobalState::Impl {
         applyDescriptorSetAllocationLocked(*poolInfo, setInfo.bindings);
     }
 
-    VkResult on_vkAllocateDescriptorSets(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkAllocateDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                         VkDevice boxed_device,
                                          const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                          VkDescriptorSet* pDescriptorSets) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto allocValidationRes = validateDescriptorSetAllocLocked(pAllocateInfo);
         if (allocValidationRes != VK_SUCCESS) return allocValidationRes;
@@ -3653,7 +3748,7 @@ class VkDecoderGlobalState::Impl {
             for (uint32_t i = 0; i < pAllocateInfo->descriptorSetCount; ++i) {
                 auto unboxed = pDescriptorSets[i];
                 pDescriptorSets[i] = new_boxed_non_dispatchable_VkDescriptorSet(pDescriptorSets[i]);
-                initDescriptorSetInfoLocked(pAllocateInfo->descriptorPool,
+                initDescriptorSetInfoLocked(device, pAllocateInfo->descriptorPool,
                                             pAllocateInfo->pSetLayouts[i],
                                             (uint64_t)(pDescriptorSets[i]), unboxed);
             }
@@ -3662,8 +3757,9 @@ class VkDecoderGlobalState::Impl {
         return res;
     }
 
-    VkResult on_vkFreeDescriptorSets(android::base::BumpPool* pool, VkDevice boxed_device,
-                                     VkDescriptorPool descriptorPool, uint32_t descriptorSetCount,
+    VkResult on_vkFreeDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                     VkDevice boxed_device, VkDescriptorPool descriptorPool,
+                                     uint32_t descriptorSetCount,
                                      const VkDescriptorSet* pDescriptorSets) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
@@ -3672,7 +3768,7 @@ class VkDecoderGlobalState::Impl {
             vk->vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
 
         if (res == VK_SUCCESS) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
 
             for (uint32_t i = 0; i < descriptorSetCount; ++i) {
                 auto* setInfo = android::base::find(mDescriptorSetInfo, pDescriptorSets[i]);
@@ -3688,7 +3784,7 @@ class VkDecoderGlobalState::Impl {
 
                 auto handleInfo = sBoxedHandleManager.get((uint64_t)*descSetAllocedEntry);
                 if (handleInfo) {
-                    if (m_emu->features.VulkanBatchedDescriptorSetUpdate.enabled) {
+                    if (m_vkEmulation->getFeatures().VulkanBatchedDescriptorSetUpdate.enabled) {
                         handleInfo->underlying = reinterpret_cast<uint64_t>(VK_NULL_HANDLE);
                     } else {
                         delete_VkDescriptorSet(*descSetAllocedEntry);
@@ -3704,7 +3800,8 @@ class VkDecoderGlobalState::Impl {
         return res;
     }
 
-    void on_vkUpdateDescriptorSets(android::base::BumpPool* pool, VkDevice boxed_device,
+    void on_vkUpdateDescriptorSets(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
                                    uint32_t descriptorWriteCount,
                                    const VkWriteDescriptorSet* pDescriptorWrites,
                                    uint32_t descriptorCopyCount,
@@ -3712,16 +3809,17 @@ class VkDecoderGlobalState::Impl {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
-        on_vkUpdateDescriptorSetsImpl(pool, vk, device, descriptorWriteCount, pDescriptorWrites,
+        std::lock_guard<std::mutex> lock(mMutex);
+        on_vkUpdateDescriptorSetsImpl(pool, snapshotInfo, vk, device, descriptorWriteCount, pDescriptorWrites,
                                       descriptorCopyCount, pDescriptorCopies);
     }
 
-    void on_vkUpdateDescriptorSetsImpl(android::base::BumpPool* pool, VulkanDispatch* vk,
-                                       VkDevice device, uint32_t descriptorWriteCount,
+    void on_vkUpdateDescriptorSetsImpl(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                       VulkanDispatch* vk, VkDevice device,
+                                       uint32_t descriptorWriteCount,
                                        const VkWriteDescriptorSet* pDescriptorWrites,
                                        uint32_t descriptorCopyCount,
-                                       const VkCopyDescriptorSet* pDescriptorCopies) {
+                                       const VkCopyDescriptorSet* pDescriptorCopies) REQUIRES(mMutex) {
         for (uint32_t writeIdx = 0; writeIdx < descriptorWriteCount; writeIdx++) {
             const VkWriteDescriptorSet& descriptorWrite = pDescriptorWrites[writeIdx];
             auto ite = mDescriptorSetInfo.find(descriptorWrite.dstSet);
@@ -3847,8 +3945,6 @@ class VkDecoderGlobalState::Impl {
         std::unique_ptr<bool[]> descriptorWritesNeedDeepCopy(new bool[descriptorWriteCount]);
         for (uint32_t i = 0; i < descriptorWriteCount; i++) {
             const VkWriteDescriptorSet& descriptorWrite = pDescriptorWrites[i];
-            auto descriptorSetInfo =
-                android::base::find(mDescriptorSetInfo, descriptorWrite.dstSet);
             descriptorWritesNeedDeepCopy[i] = false;
             if (!vk_util::vk_descriptor_type_has_image_view(descriptorWrite.descriptorType)) {
                 continue;
@@ -3949,7 +4045,8 @@ class VkDecoderGlobalState::Impl {
                                    descriptorCopyCount, pDescriptorCopies);
     }
 
-    VkResult on_vkCreateShaderModule(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkCreateShaderModule(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                     VkDevice boxed_device,
                                      const VkShaderModuleCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator,
                                      VkShaderModule* pShaderModule) {
@@ -3962,7 +4059,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         VALIDATE_NEW_HANDLE_INFO_ENTRY(mShaderModuleInfo, *pShaderModule);
         auto& shaderModuleInfo = mShaderModuleInfo[*pShaderModule];
@@ -3981,7 +4078,7 @@ class VkDecoderGlobalState::Impl {
 
     void destroyShaderModuleLocked(VkDevice device, VulkanDispatch* deviceDispatch,
                                    VkShaderModule shaderModule,
-                                   const VkAllocationCallbacks* pAllocator) {
+                                   const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto shaderModuleInfoIt = mShaderModuleInfo.find(shaderModule);
         if (shaderModuleInfoIt == mShaderModuleInfo.end()) return;
         auto& shaderModuleInfo = shaderModuleInfoIt->second;
@@ -3992,17 +4089,18 @@ class VkDecoderGlobalState::Impl {
         mShaderModuleInfo.erase(shaderModuleInfoIt);
     }
 
-    void on_vkDestroyShaderModule(android::base::BumpPool* pool, VkDevice boxed_device,
-                                  VkShaderModule shaderModule,
+    void on_vkDestroyShaderModule(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                  VkDevice boxed_device, VkShaderModule shaderModule,
                                   const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyShaderModuleLocked(device, deviceDispatch, shaderModule, pAllocator);
     }
 
-    VkResult on_vkCreatePipelineCache(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkCreatePipelineCache(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                      VkDevice boxed_device,
                                       const VkPipelineCacheCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator,
                                       VkPipelineCache* pPipelineCache) {
@@ -4015,7 +4113,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         VALIDATE_NEW_HANDLE_INFO_ENTRY(mPipelineCacheInfo, *pPipelineCache);
         auto& pipelineCacheInfo = mPipelineCacheInfo[*pPipelineCache];
@@ -4035,7 +4133,7 @@ class VkDecoderGlobalState::Impl {
 
     void destroyPipelineCacheLocked(VkDevice device, VulkanDispatch* deviceDispatch,
                                     VkPipelineCache pipelineCache,
-                                    const VkAllocationCallbacks* pAllocator) {
+                                    const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto pipelineCacheInfoIt = mPipelineCacheInfo.find(pipelineCache);
         if (pipelineCacheInfoIt == mPipelineCacheInfo.end()) return;
         auto& pipelineCacheInfo = pipelineCacheInfoIt->second;
@@ -4046,18 +4144,76 @@ class VkDecoderGlobalState::Impl {
         mPipelineCacheInfo.erase(pipelineCache);
     }
 
-    void on_vkDestroyPipelineCache(android::base::BumpPool* pool, VkDevice boxed_device,
-                                   VkPipelineCache pipelineCache,
+    void on_vkDestroyPipelineCache(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                   VkDevice boxed_device, VkPipelineCache pipelineCache,
                                    const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyPipelineCacheLocked(device, deviceDispatch, pipelineCache, pAllocator);
     }
 
-    VkResult on_vkCreateGraphicsPipelines(android::base::BumpPool* pool, VkDevice boxed_device,
-                                          VkPipelineCache pipelineCache, uint32_t createInfoCount,
+    VkResult on_vkCreatePipelineLayout(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                      VkDevice boxed_device,
+                                      const VkPipelineLayoutCreateInfo* pCreateInfo,
+                                      const VkAllocationCallbacks* pAllocator,
+                                      VkPipelineLayout* pPipelineLayout) {
+        auto device = unbox_VkDevice(boxed_device);
+        auto deviceDispatch = dispatch_VkDevice(boxed_device);
+
+        VkResult result =
+            deviceDispatch->vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
+        if (result != VK_SUCCESS) {
+            return result;
+        }
+
+        std::lock_guard<std::mutex> lock(mMutex);
+
+        VALIDATE_NEW_HANDLE_INFO_ENTRY(mPipelineLayoutInfo, *pPipelineLayout);
+        auto& pipelineLayoutInfo = mPipelineLayoutInfo[*pPipelineLayout];
+        pipelineLayoutInfo.device = device;
+
+        *pPipelineLayout = new_boxed_non_dispatchable_VkPipelineLayout(*pPipelineLayout);
+
+        return result;
+    }
+
+    void destroyPipelineLayoutWithExclusiveInfo(VkDevice device, VulkanDispatch* deviceDispatch,
+                                                VkPipelineLayout pipelineLayout,
+                                                PipelineLayoutInfo& pipelineLayoutInfo,
+                                                const VkAllocationCallbacks* pAllocator) {
+        deviceDispatch->vkDestroyPipelineLayout(device, pipelineLayout, pAllocator);
+    }
+
+    void destroyPipelineLayoutLocked(VkDevice device, VulkanDispatch* deviceDispatch,
+                                     VkPipelineLayout pipelineLayout,
+                                     const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
+        auto pipelineLayoutInfoIt = mPipelineLayoutInfo.find(pipelineLayout);
+        if (pipelineLayoutInfoIt == mPipelineLayoutInfo.end()) return;
+        auto& pipelineLayoutInfo = pipelineLayoutInfoIt->second;
+
+        destroyPipelineLayoutWithExclusiveInfo(device, deviceDispatch, pipelineLayout,
+                                               pipelineLayoutInfo, pAllocator);
+
+        mPipelineLayoutInfo.erase(pipelineLayout);
+    }
+
+    // This call will be delayed as VulkanQueueSubmitWithCommands feature can change order
+    // of the commands and pipeline layouts need to stay valid during recording.
+    void on_vkDestroyPipelineLayout(android::base::BumpPool*, VkSnapshotApiCallInfo*,
+                                    VkDevice boxed_device, VkPipelineLayout pipelineLayout,
+                                    const VkAllocationCallbacks* pAllocator) {
+        auto device = unbox_VkDevice(boxed_device);
+        auto deviceDispatch = dispatch_VkDevice(boxed_device);
+
+        std::lock_guard<std::mutex> lock(mMutex);
+        destroyPipelineLayoutLocked(device, deviceDispatch, pipelineLayout, pAllocator);
+    }
+
+    VkResult on_vkCreateGraphicsPipelines(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                          VkDevice boxed_device, VkPipelineCache pipelineCache,
+                                          uint32_t createInfoCount,
                                           const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkPipeline* pPipelines) {
@@ -4070,7 +4226,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         for (uint32_t i = 0; i < createInfoCount; i++) {
             if (!pPipelines[i]) {
@@ -4086,11 +4242,12 @@ class VkDecoderGlobalState::Impl {
         return result;
     }
 
-    VkResult on_vkCreateComputePipelines(android::base::BumpPool* pool, VkDevice boxed_device,
-                                          VkPipelineCache pipelineCache, uint32_t createInfoCount,
-                                          const VkComputePipelineCreateInfo* pCreateInfos,
-                                          const VkAllocationCallbacks* pAllocator,
-                                          VkPipeline* pPipelines) {
+    VkResult on_vkCreateComputePipelines(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                         VkDevice boxed_device, VkPipelineCache pipelineCache,
+                                         uint32_t createInfoCount,
+                                         const VkComputePipelineCreateInfo* pCreateInfos,
+                                         const VkAllocationCallbacks* pAllocator,
+                                         VkPipeline* pPipelines) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
@@ -4100,7 +4257,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         for (uint32_t i = 0; i < createInfoCount; i++) {
             if (!pPipelines[i]) {
@@ -4123,7 +4280,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     void destroyPipelineLocked(VkDevice device, VulkanDispatch* deviceDispatch, VkPipeline pipeline,
-                               const VkAllocationCallbacks* pAllocator) {
+                               const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto pipelineInfoIt = mPipelineInfo.find(pipeline);
         if (pipelineInfoIt == mPipelineInfo.end()) return;
         auto& pipelineInfo = pipelineInfoIt->second;
@@ -4134,23 +4291,25 @@ class VkDecoderGlobalState::Impl {
         mPipelineInfo.erase(pipeline);
     }
 
-    void on_vkDestroyPipeline(android::base::BumpPool* pool, VkDevice boxed_device,
-                              VkPipeline pipeline, const VkAllocationCallbacks* pAllocator) {
+    void on_vkDestroyPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                              VkDevice boxed_device, VkPipeline pipeline,
+                              const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyPipelineLocked(device, deviceDispatch, pipeline, pAllocator);
     }
 
-    void on_vkCmdCopyImage(android::base::BumpPool* pool, VkCommandBuffer boxed_commandBuffer,
-                           VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage,
+    void on_vkCmdCopyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                           VkCommandBuffer boxed_commandBuffer, VkImage srcImage,
+                           VkImageLayout srcImageLayout, VkImage dstImage,
                            VkImageLayout dstImageLayout, uint32_t regionCount,
                            const VkImageCopy* pRegions) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* srcImg = android::base::find(mImageInfo, srcImage);
         auto* dstImg = android::base::find(mImageInfo, dstImage);
         if (!srcImg || !dstImg) return;
@@ -4182,14 +4341,14 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdCopyImageToBuffer(android::base::BumpPool* pool,
+    void on_vkCmdCopyImageToBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                    VkCommandBuffer boxed_commandBuffer, VkImage srcImage,
                                    VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                    uint32_t regionCount, const VkBufferImageCopy* pRegions) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* imageInfo = android::base::find(mImageInfo, srcImage);
         auto* bufferInfo = android::base::find(mBufferInfo, dstBuffer);
         if (!imageInfo || !bufferInfo) return;
@@ -4209,13 +4368,13 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdCopyImage2(android::base::BumpPool* pool,
-                           VkCommandBuffer boxed_commandBuffer,
-                           const VkCopyImageInfo2* pCopyImageInfo) {
+    void on_vkCmdCopyImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                            VkCommandBuffer boxed_commandBuffer,
+                            const VkCopyImageInfo2* pCopyImageInfo) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* srcImg = android::base::find(mImageInfo, pCopyImageInfo->srcImage);
         auto* dstImg = android::base::find(mImageInfo, pCopyImageInfo->dstImage);
         if (!srcImg || !dstImg) return;
@@ -4253,13 +4412,13 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdCopyImageToBuffer2(android::base::BumpPool* pool,
-                                   VkCommandBuffer boxed_commandBuffer,
-                                   const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
+    void on_vkCmdCopyImageToBuffer2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                    VkCommandBuffer boxed_commandBuffer,
+                                    const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* imageInfo = android::base::find(mImageInfo, pCopyImageToBufferInfo->srcImage);
         auto* bufferInfo = android::base::find(mBufferInfo, pCopyImageToBufferInfo->dstBuffer);
         if (!imageInfo || !bufferInfo) return;
@@ -4282,13 +4441,13 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdCopyImage2KHR(android::base::BumpPool* pool,
-                           VkCommandBuffer boxed_commandBuffer,
-                           const VkCopyImageInfo2KHR* pCopyImageInfo) {
+    void on_vkCmdCopyImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                               VkCommandBuffer boxed_commandBuffer,
+                               const VkCopyImageInfo2KHR* pCopyImageInfo) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* srcImg = android::base::find(mImageInfo, pCopyImageInfo->srcImage);
         auto* dstImg = android::base::find(mImageInfo, pCopyImageInfo->dstImage);
         if (!srcImg || !dstImg) return;
@@ -4326,13 +4485,13 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdCopyImageToBuffer2KHR(android::base::BumpPool* pool,
-                                   VkCommandBuffer boxed_commandBuffer,
-                                   const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo) {
+    void on_vkCmdCopyImageToBuffer2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                       VkCommandBuffer boxed_commandBuffer,
+                                       const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* imageInfo = android::base::find(mImageInfo, pCopyImageToBufferInfo->srcImage);
         auto* bufferInfo = android::base::find(mBufferInfo, pCopyImageToBufferInfo->dstBuffer);
         if (!imageInfo || !bufferInfo) return;
@@ -4355,12 +4514,13 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkGetImageMemoryRequirements(android::base::BumpPool* pool, VkDevice boxed_device,
-                                         VkImage image, VkMemoryRequirements* pMemoryRequirements) {
+    void on_vkGetImageMemoryRequirements(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                         VkDevice boxed_device, VkImage image,
+                                         VkMemoryRequirements* pMemoryRequirements) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
         vk->vkGetImageMemoryRequirements(device, image, pMemoryRequirements);
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         updateImageMemorySizeLocked(device, image, pMemoryRequirements);
 
         auto* physicalDevice = android::base::find(mDeviceToPhysicalDevice, device);
@@ -4379,13 +4539,14 @@ class VkDecoderGlobalState::Impl {
         physicalDeviceMemHelper->transformToGuestMemoryRequirements(pMemoryRequirements);
     }
 
-    void on_vkGetImageMemoryRequirements2(android::base::BumpPool* pool, VkDevice boxed_device,
+    void on_vkGetImageMemoryRequirements2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                          VkDevice boxed_device,
                                           const VkImageMemoryRequirementsInfo2* pInfo,
                                           VkMemoryRequirements2* pMemoryRequirements) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* physicalDevice = android::base::find(mDeviceToPhysicalDevice, device);
         if (!physicalDevice) {
@@ -4421,14 +4582,14 @@ class VkDecoderGlobalState::Impl {
             &pMemoryRequirements->memoryRequirements);
     }
 
-    void on_vkGetBufferMemoryRequirements(android::base::BumpPool* pool, VkDevice boxed_device,
-                                          VkBuffer buffer,
+    void on_vkGetBufferMemoryRequirements(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                          VkDevice boxed_device, VkBuffer buffer,
                                           VkMemoryRequirements* pMemoryRequirements) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
         vk->vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* physicalDevice = android::base::find(mDeviceToPhysicalDevice, device);
         if (!physicalDevice) {
@@ -4446,13 +4607,14 @@ class VkDecoderGlobalState::Impl {
         physicalDeviceMemHelper->transformToGuestMemoryRequirements(pMemoryRequirements);
     }
 
-    void on_vkGetBufferMemoryRequirements2(android::base::BumpPool* pool, VkDevice boxed_device,
+    void on_vkGetBufferMemoryRequirements2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                           VkDevice boxed_device,
                                            const VkBufferMemoryRequirementsInfo2* pInfo,
                                            VkMemoryRequirements2* pMemoryRequirements) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* physicalDevice = android::base::find(mDeviceToPhysicalDevice, device);
         if (!physicalDevice) {
@@ -4486,7 +4648,7 @@ class VkDecoderGlobalState::Impl {
             &pMemoryRequirements->memoryRequirements);
     }
 
-    void on_vkCmdCopyBufferToImage(android::base::BumpPool* pool,
+    void on_vkCmdCopyBufferToImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                    VkCommandBuffer boxed_commandBuffer, VkBuffer srcBuffer,
                                    VkImage dstImage, VkImageLayout dstImageLayout,
                                    uint32_t regionCount, const VkBufferImageCopy* pRegions,
@@ -4494,7 +4656,7 @@ class VkDecoderGlobalState::Impl {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* imageInfo = android::base::find(mImageInfo, dstImage);
         if (!imageInfo) return;
         auto* bufferInfo = android::base::find(mBufferInfo, srcBuffer);
@@ -4541,14 +4703,14 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdCopyBufferToImage2(android::base::BumpPool* pool,
+    void on_vkCmdCopyBufferToImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                     VkCommandBuffer boxed_commandBuffer,
                                     const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo,
                                     const VkDecoderContext& context) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* imageInfo = android::base::find(mImageInfo, pCopyBufferToImageInfo->dstImage);
         if (!imageInfo) return;
         auto* bufferInfo = android::base::find(mBufferInfo, pCopyBufferToImageInfo->srcBuffer);
@@ -4598,14 +4760,14 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdCopyBufferToImage2KHR(android::base::BumpPool* pool,
-                                    VkCommandBuffer boxed_commandBuffer,
-                                    const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo,
-                                    const VkDecoderContext& context) {
+    void on_vkCmdCopyBufferToImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                       VkCommandBuffer boxed_commandBuffer,
+                                       const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo,
+                                       const VkDecoderContext& context) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* imageInfo = android::base::find(mImageInfo, pCopyBufferToImageInfo->dstImage);
         if (!imageInfo) return;
         auto* bufferInfo = android::base::find(mBufferInfo, pCopyBufferToImageInfo->srcBuffer);
@@ -4693,9 +4855,10 @@ class VkDecoderGlobalState::Impl {
     }
 
     template <typename VkImageMemoryBarrierType>
-    void processImageMemoryBarrier(VkCommandBuffer commandBuffer, uint32_t imageMemoryBarrierCount,
-                                   const VkImageMemoryBarrierType* pImageMemoryBarriers) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+    void processImageMemoryBarrierLocked(VkCommandBuffer commandBuffer,
+                                         uint32_t imageMemoryBarrierCount,
+                                         const VkImageMemoryBarrierType* pImageMemoryBarriers)
+        REQUIRES(mMutex) {
         CommandBufferInfo* cmdBufferInfo = android::base::find(mCommandBufferInfo, commandBuffer);
         if (!cmdBufferInfo) return;
 
@@ -4718,21 +4881,16 @@ class VkDecoderGlobalState::Impl {
                 cmdBufferInfo->releasedColorBuffers.insert(cb);
             }
             cmdBufferInfo->cbLayouts[cb] = getIMBNewLayout(pImageMemoryBarriers[i]);
-            // Insert unconditionally to this list, regardless of whether or not
-            // there is a queue family ownership transfer
-            cmdBufferInfo->imageBarrierColorBuffers.insert(cb);
         }
     }
 
-    void on_vkCmdPipelineBarrier(android::base::BumpPool* pool, VkCommandBuffer boxed_commandBuffer,
-                                 VkPipelineStageFlags srcStageMask,
-                                 VkPipelineStageFlags dstStageMask,
-                                 VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount,
-                                 const VkMemoryBarrier* pMemoryBarriers,
-                                 uint32_t bufferMemoryBarrierCount,
-                                 const VkBufferMemoryBarrier* pBufferMemoryBarriers,
-                                 uint32_t imageMemoryBarrierCount,
-                                 const VkImageMemoryBarrier* pImageMemoryBarriers) {
+    void on_vkCmdPipelineBarrier(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkCommandBuffer boxed_commandBuffer,
+        VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
+        VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount,
+        const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount,
+        const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount,
+        const VkImageMemoryBarrier* pImageMemoryBarriers) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
@@ -4753,14 +4911,15 @@ class VkDecoderGlobalState::Impl {
                                      pImageMemoryBarriers);
             return;
         }
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         CommandBufferInfo* cmdBufferInfo = android::base::find(mCommandBufferInfo, commandBuffer);
         if (!cmdBufferInfo) return;
 
         DeviceInfo* deviceInfo = android::base::find(mDeviceInfo, cmdBufferInfo->device);
         if (!deviceInfo) return;
 
-        processImageMemoryBarrier(commandBuffer, imageMemoryBarrierCount, pImageMemoryBarriers);
+        processImageMemoryBarrierLocked(commandBuffer, imageMemoryBarrierCount,
+                                        pImageMemoryBarriers);
 
         if (!deviceInfo->emulateTextureEtc2 && !deviceInfo->emulateTextureAstc) {
             vk->vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags,
@@ -4814,7 +4973,7 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdPipelineBarrier2(android::base::BumpPool* pool,
+    void on_vkCmdPipelineBarrier2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                   VkCommandBuffer boxed_commandBuffer,
                                   const VkDependencyInfo* pDependencyInfo) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
@@ -4830,15 +4989,15 @@ class VkDecoderGlobalState::Impl {
                 ((VkImageMemoryBarrier*)pDependencyInfo->pImageMemoryBarriers) + i);
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         CommandBufferInfo* cmdBufferInfo = android::base::find(mCommandBufferInfo, commandBuffer);
         if (!cmdBufferInfo) return;
 
         DeviceInfo* deviceInfo = android::base::find(mDeviceInfo, cmdBufferInfo->device);
         if (!deviceInfo) return;
 
-        processImageMemoryBarrier(commandBuffer, pDependencyInfo->imageMemoryBarrierCount,
-                                  pDependencyInfo->pImageMemoryBarriers);
+        processImageMemoryBarrierLocked(commandBuffer, pDependencyInfo->imageMemoryBarrierCount,
+                                        pDependencyInfo->pImageMemoryBarriers);
 
         // TODO: If this is a decompressed image, handle decompression before calling
         // VkCmdvkCmdPipelineBarrier2 i.e. match on_vkCmdPipelineBarrier implementation
@@ -4846,10 +5005,10 @@ class VkDecoderGlobalState::Impl {
     }
 
     bool mapHostVisibleMemoryToGuestPhysicalAddressLocked(VulkanDispatch* vk, VkDevice device,
-                                                          VkDeviceMemory memory,
-                                                          uint64_t physAddr) {
-        if (!m_emu->features.GlDirectMem.enabled &&
-            !m_emu->features.VirtioGpuNext.enabled) {
+                                                          VkDeviceMemory memory, uint64_t physAddr)
+        REQUIRES(mMutex) {
+        if (!m_vkEmulation->getFeatures().GlDirectMem.enabled &&
+            !m_vkEmulation->getFeatures().VirtioGpuNext.enabled) {
             // INFO("%s: Tried to use direct mapping "
             // "while GlDirectMem is not enabled!");
         }
@@ -4880,35 +5039,19 @@ class VkDecoderGlobalState::Impl {
         void* hva = info->pageAlignedHva;
         size_t sizeToPage = info->sizeToPage;
 
-        AutoLock occupiedGpasLock(mOccupiedGpasLock);
-
-        auto* existingMemoryInfo = android::base::find(mOccupiedGpas, gpa);
-        if (existingMemoryInfo) {
-            INFO("%s: WARNING: already mapped gpa 0x%llx, replacing", __func__,
-                    (unsigned long long)gpa);
-
-            get_emugl_vm_operations().unmapUserBackedRam(existingMemoryInfo->gpa,
-                                                         existingMemoryInfo->sizeToPage);
-
-            mOccupiedGpas.erase(gpa);
-        }
-
         get_emugl_vm_operations().mapUserBackedRam(gpa, hva, sizeToPage);
 
         if (mVerbosePrints) {
-            INFO("VERBOSE:%s: registering gpa 0x%llx to mOccupiedGpas", __func__,
+            INFO("VERBOSE:%s: registering gpa 0x%llx", __func__,
                     (unsigned long long)gpa);
         }
 
-        mOccupiedGpas[gpa] = {
-            vk, device, memory, gpa, sizeToPage,
-        };
-
         if (!mUseOldMemoryCleanupPath) {
             get_emugl_address_space_device_control_ops().register_deallocation_callback(
-                this, gpa, [](void* thisPtr, uint64_t gpa) {
-                    Impl* implPtr = (Impl*)thisPtr;
-                    implPtr->unmapMemoryAtGpaIfExists(gpa);
+                (void*)(new uint64_t(sizeToPage)), gpa, [](void* thisPtr, uint64_t gpa) {
+                    uint64_t* sizePtr = (uint64_t*)thisPtr;
+                    get_emugl_vm_operations().unmapUserBackedRam(gpa, *sizePtr);
+                    delete sizePtr;
                 });
         }
 
@@ -4918,31 +5061,24 @@ class VkDecoderGlobalState::Impl {
     // Only call this from the address space device deallocation operation's
     // context, or it's possible that the guest/host view of which gpa's are
     // occupied goes out of sync.
-    void unmapMemoryAtGpaIfExists(uint64_t gpa) {
-        AutoLock lock(mOccupiedGpasLock);
-
+    void unmapMemoryAtGpa(uint64_t gpa, uint64_t size) {
+        // DO NOT place any additional locks in here, as it may cause a deadlock due to mismatched
+        // lock ordering, as VM operations will typically have its own mutex already.
         if (mVerbosePrints) {
             INFO("VERBOSE:%s: deallocation callback for gpa 0x%llx", __func__,
                     (unsigned long long)gpa);
         }
 
-        auto* existingMemoryInfo = android::base::find(mOccupiedGpas, gpa);
-        if (!existingMemoryInfo) return;
-
-        get_emugl_vm_operations().unmapUserBackedRam(existingMemoryInfo->gpa,
-                                                     existingMemoryInfo->sizeToPage);
-
-        mOccupiedGpas.erase(gpa);
+        // Just blindly unmap here. Let the VM implementation deal with invalid addresses.
+        get_emugl_vm_operations().unmapUserBackedRam(gpa, size);
     }
 
-    VkResult on_vkAllocateMemory(android::base::BumpPool* pool, VkDevice boxed_device,
-                                 const VkMemoryAllocateInfo* pAllocateInfo,
+    VkResult on_vkAllocateMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                 VkDevice boxed_device, const VkMemoryAllocateInfo* pAllocateInfo,
                                  const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory) {
+        if (!pAllocateInfo) return VK_ERROR_INITIALIZATION_FAILED;
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
-        auto* tInfo = RenderThreadInfoVk::get();
-
-        if (!pAllocateInfo) return VK_ERROR_INITIALIZATION_FAILED;
 
         VkMemoryAllocateInfo localAllocInfo = vk_make_orphan_copy(*pAllocateInfo);
         vk_struct_chain_iterator structChainIter = vk_make_chain_iterator(&localAllocInfo);
@@ -5009,28 +5145,22 @@ class VkDecoderGlobalState::Impl {
             vk_find_struct<VkCreateBlobGOOGLE>(pAllocateInfo);
 
 #ifdef _WIN32
-        VkImportMemoryWin32HandleInfoKHR importInfo{
+        VkImportMemoryWin32HandleInfoKHR importWin32HandleInfo{
             VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
             0,
-            VK_EXT_MEMORY_HANDLE_TYPE_BIT,
-            VK_EXT_MEMORY_HANDLE_INVALID,
+            VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
+            static_cast<HANDLE>(NULL),
             L"",
         };
-#elif defined(__QNX__)
-        VkImportScreenBufferInfoQNX importInfo{
-            VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
-            0,
-            VK_EXT_MEMORY_HANDLE_INVALID,
-        };
 #else
-        VkImportMemoryFdInfoKHR importInfo{
-            VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
+
+#if defined(__QNX__)
+        VkImportScreenBufferInfoQNX importScreenBufferInfo{
+            VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
             0,
-            VK_EXT_MEMORY_HANDLE_TYPE_BIT,
-            VK_EXT_MEMORY_HANDLE_INVALID,
+            static_cast<screen_buffer_t>(NULL),
         };
-
-#if defined(__APPLE__)
+#elif defined(__APPLE__)
         VkImportMemoryMetalHandleInfoEXT importInfoMetalHandle = {
             VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
             0,
@@ -5039,16 +5169,25 @@ class VkDecoderGlobalState::Impl {
         };
 #endif
 
+        VkImportMemoryFdInfoKHR importFdInfo{
+            VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
+            0,
+            VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
+            -1,
+        };
 #endif
 
         void* mappedPtr = nullptr;
-        ManagedDescriptor externalMemoryHandle;
+        // If required by the platform, wrap the descriptor received from VkEmulation for
+        // a ColorBuffer or Buffer import as a ManagedDescriptor, so it will be closed
+        // appropriately when it goes out of scope.
+        ManagedDescriptor managedHandle;
         if (importCbInfoPtr) {
             bool colorBufferMemoryUsesDedicatedAlloc = false;
-            if (!getColorBufferAllocationInfo(importCbInfoPtr->colorBuffer,
-                                              &localAllocInfo.allocationSize,
-                                              &localAllocInfo.memoryTypeIndex,
-                                              &colorBufferMemoryUsesDedicatedAlloc, &mappedPtr)) {
+            if (!m_vkEmulation->getColorBufferAllocationInfo(
+                    importCbInfoPtr->colorBuffer, &localAllocInfo.allocationSize,
+                    &localAllocInfo.memoryTypeIndex, &colorBufferMemoryUsesDedicatedAlloc,
+                    &mappedPtr)) {
                 if (mSnapshotState != SnapshotState::Loading) {
                     GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
                         << "Failed to get allocation info for ColorBuffer:"
@@ -5062,8 +5201,9 @@ class VkDecoderGlobalState::Impl {
             } else {
                 shouldUseDedicatedAllocInfo &= colorBufferMemoryUsesDedicatedAlloc;
 
-                if (!m_emu->features.GuestVulkanOnly.enabled) {
-                    m_emu->callbacks.invalidateColorBuffer(importCbInfoPtr->colorBuffer);
+                if (!m_vkEmulation->getFeatures().GuestVulkanOnly.enabled) {
+                    m_vkEmulation->getCallbacks().invalidateColorBuffer(
+                        importCbInfoPtr->colorBuffer);
                 }
 
                 bool opaqueFd = true;
@@ -5071,24 +5211,24 @@ class VkDecoderGlobalState::Impl {
 #if defined(__APPLE__)
                 // Use metal object extension on MoltenVK mode for color buffer import,
                 // non-moltenVK path on MacOS will use FD handles
-                if (m_emu->instanceSupportsMoltenVK) {
-
-                    extern VkImage getColorBufferVkImage(uint32_t colorBufferHandle);
+                if (m_vkEmulation->supportsMoltenVk()) {
                     if (dedicatedAllocInfoPtr == nullptr || localDedicatedAllocInfo.image == VK_NULL_HANDLE) {
                         // TODO(b/351765838): This should not happen, but somehow the guest
                         // is not providing us the necessary information for video rendering.
                         localDedicatedAllocInfo = {
-                        .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
-                        .pNext = nullptr,
-                        .image = getColorBufferVkImage(importCbInfoPtr->colorBuffer),
-                        .buffer = VK_NULL_HANDLE,
+                            .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
+                            .pNext = nullptr,
+                            .image =
+                                m_vkEmulation->getColorBufferVkImage(importCbInfoPtr->colorBuffer),
+                            .buffer = VK_NULL_HANDLE,
                         };
 
                         shouldUseDedicatedAllocInfo = true;
                     }
 
                     MTLResource_id cbExtMemoryHandle =
-                        getColorBufferMetalMemoryHandle(importCbInfoPtr->colorBuffer);
+                        m_vkEmulation->getColorBufferMetalMemoryHandle(
+                            importCbInfoPtr->colorBuffer);
 
                     if (cbExtMemoryHandle == nullptr) {
                         fprintf(stderr,
@@ -5105,36 +5245,51 @@ class VkDecoderGlobalState::Impl {
                 }
 #endif
 
-                if (opaqueFd && m_emu->deviceInfo.supportsExternalMemoryImport) {
-                    VK_EXT_MEMORY_HANDLE cbExtMemoryHandle =
-                        getColorBufferExtMemoryHandle(importCbInfoPtr->colorBuffer);
-
-                    if (cbExtMemoryHandle == VK_EXT_MEMORY_HANDLE_INVALID) {
-                        fprintf(stderr,
-                                "%s: VK_ERROR_OUT_OF_DEVICE_MEMORY: "
-                                "colorBuffer 0x%x does not have Vulkan external memory backing\n",
-                                __func__, importCbInfoPtr->colorBuffer);
+                if (opaqueFd && m_vkEmulation->supportsExternalMemoryImport()) {
+                    auto dupHandleInfo =
+                        m_vkEmulation->dupColorBufferExtMemoryHandle(importCbInfoPtr->colorBuffer);
+                    if (!dupHandleInfo) {
+                        ERR("Failed to duplicate external memory handle/descriptor for ColorBuffer "
+                            "object, with internal handle: %d",
+                            importCbInfoPtr->colorBuffer);
+                        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+                    }
+#if defined(_WIN32)
+                    // Wrap the dup'd handle in a ManagedDescriptor, and let it close the underlying
+                    // HANDLE when it goes out of scope. From the VkImportMemoryWin32HandleInfoKHR
+                    // spec: Importing memory object payloads from Windows handles does not transfer
+                    // ownership of the handle to the Vulkan implementation. For handle types
+                    // defined as NT handles, the application must release handle ownership using
+                    // the CloseHandle system call when the handle is no longer needed. For handle
+                    // types defined as NT handles, the imported memory object holds a reference to
+                    // its payload
+                    managedHandle = ManagedDescriptor(static_cast<DescriptorType>(
+                        reinterpret_cast<void*>(dupHandleInfo->handle)));
+                    importWin32HandleInfo.handle =
+                        managedHandle.get().value_or(static_cast<HANDLE>(NULL));
+                    vk_append_struct(&structChainIter, &importWin32HandleInfo);
+#elif defined(__QNX__)
+                    if (STREAM_HANDLE_TYPE_PLATFORM_SCREEN_BUFFER_QNX ==
+                        dupHandleInfo->streamHandleType) {
+                        importScreenBufferInfo.buffer = static_cast<screen_buffer_t>(
+                            reinterpret_cast<void*>(dupHandleInfo->handle));
+                        vk_append_struct(&structChainIter, &importScreenBufferInfo);
+                    } else {
+                        // TODO(aruby@blackberry.com): Fall through to the importFdInfo sequence
+                        // below to support non-screenbuffer external object imports on QNX?
+                        ERR("Stream mem handleType: 0x%x not support for ColorBuffer import",
+                            dupHandleInfo->streamHandleType);
                         return VK_ERROR_OUT_OF_DEVICE_MEMORY;
                     }
-
-#if defined(__QNX__)
-                    importInfo.buffer = cbExtMemoryHandle;
-#else
-                    externalMemoryHandle = ManagedDescriptor(dupExternalMemory(cbExtMemoryHandle));
-
-#ifdef _WIN32
-                    importInfo.handle =
-                        externalMemoryHandle.get().value_or(static_cast<HANDLE>(NULL));
 #else
-                    importInfo.fd = externalMemoryHandle.get().value_or(-1);
-#endif
+                    importFdInfo.fd = static_cast<int>(dupHandleInfo->handle);
+                    vk_append_struct(&structChainIter, &importFdInfo);
 #endif
-                    vk_append_struct(&structChainIter, &importInfo);
                 }
             }
         } else if (importBufferInfoPtr) {
             bool bufferMemoryUsesDedicatedAlloc = false;
-            if (!getBufferAllocationInfo(
+            if (!m_vkEmulation->getBufferAllocationInfo(
                     importBufferInfoPtr->buffer, &localAllocInfo.allocationSize,
                     &localAllocInfo.memoryTypeIndex, &bufferMemoryUsesDedicatedAlloc)) {
                 ERR("Failed to get Buffer:%d allocation info.", importBufferInfoPtr->buffer);
@@ -5145,9 +5300,9 @@ class VkDecoderGlobalState::Impl {
 
             bool opaqueFd = true;
 #ifdef __APPLE__
-            if (m_emu->instanceSupportsMoltenVK) {
+            if (m_vkEmulation->supportsMoltenVk()) {
                 MTLResource_id bufferMetalMemoryHandle =
-                    getBufferMetalMemoryHandle(importBufferInfoPtr->buffer);
+                    m_vkEmulation->getBufferMetalMemoryHandle(importBufferInfoPtr->buffer);
 
                 if (bufferMetalMemoryHandle == nullptr) {
                     fprintf(stderr,
@@ -5158,7 +5313,7 @@ class VkDecoderGlobalState::Impl {
                     return VK_ERROR_OUT_OF_DEVICE_MEMORY;
                 }
 
-                importInfoMetalHandle.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT;
+                importInfoMetalHandle.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
                 importInfoMetalHandle.handle = bufferMetalMemoryHandle;
 
                 vk_append_struct(&structChainIter, &importInfoMetalHandle);
@@ -5167,41 +5322,57 @@ class VkDecoderGlobalState::Impl {
             }
 #endif
 
-            if (opaqueFd && m_emu->deviceInfo.supportsExternalMemoryImport) {
-                uint32_t outStreamHandleType;
-                VK_EXT_MEMORY_HANDLE bufferExtMemoryHandle =
-                    getBufferExtMemoryHandle(importBufferInfoPtr->buffer, &outStreamHandleType);
-
-                if (bufferExtMemoryHandle == VK_EXT_MEMORY_HANDLE_INVALID) {
-                    fprintf(stderr,
-                            "%s: VK_ERROR_OUT_OF_DEVICE_MEMORY: "
-                            "buffer 0x%x does not have Vulkan external memory "
-                            "backing\n",
-                            __func__, importBufferInfoPtr->buffer);
+            if (opaqueFd && m_vkEmulation->supportsExternalMemoryImport()) {
+                auto dupHandleInfo =
+                    m_vkEmulation->dupBufferExtMemoryHandle(importBufferInfoPtr->buffer);
+                if (!dupHandleInfo) {
+                    ERR("Failed to duplicate external memory handle/descriptor for Buffer object, "
+                        "with internal handle: %d",
+                        importBufferInfoPtr->buffer);
                     return VK_ERROR_OUT_OF_DEVICE_MEMORY;
                 }
 
-#if defined(__QNX__)
-                importInfo.buffer = bufferExtMemoryHandle;
-#else
-                bufferExtMemoryHandle = dupExternalMemory(bufferExtMemoryHandle);
-
-#ifdef _WIN32
-                importInfo.handle = bufferExtMemoryHandle;
+#if defined(_WIN32)
+                // Wrap the dup'd handle in a ManagedDescriptor, and let it close the underlying
+                // HANDLE when it goes out of scope. From the VkImportMemoryWin32HandleInfoKHR
+                // spec: Importing memory object payloads from Windows handles does not transfer
+                // ownership of the handle to the Vulkan implementation. For handle types defined
+                // as NT handles, the application must release handle ownership using the
+                // CloseHandle system call when the handle is no longer needed. For handle types
+                // defined as NT handles, the imported memory object holds a reference to its
+                // payload
+                managedHandle = ManagedDescriptor(
+                    static_cast<DescriptorType>(reinterpret_cast<void*>(dupHandleInfo->handle)));
+                importWin32HandleInfo.handle =
+                    managedHandle.get().value_or(static_cast<HANDLE>(NULL));
+                vk_append_struct(&structChainIter, &importWin32HandleInfo);
+#elif defined(__QNX__)
+                if (STREAM_HANDLE_TYPE_PLATFORM_SCREEN_BUFFER_QNX == dupHandleInfo->streamHandleType) {
+                    importScreenBufferInfo.buffer = static_cast<screen_buffer_t>(
+                        reinterpret_cast<void*>(dupHandleInfo->handle));
+                    vk_append_struct(&structChainIter, &importScreenBufferInfo);
+                } else {
+                    // TODO(aruby@blackberry.com): Fall through to the importFdInfo sequence below
+                    // to support non-screenbuffer external object imports on QNX?
+                    ERR("Stream mem handleType: 0x%x not support for Buffer object import",
+                        dupHandleInfo->streamHandleType);
+                    return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+                }
 #else
-                importInfo.fd = bufferExtMemoryHandle;
-#endif
+                importFdInfo.fd = static_cast<int>(dupHandleInfo->handle);
+                vk_append_struct(&structChainIter, &importFdInfo);
 #endif
-                vk_append_struct(&structChainIter, &importInfo);
             }
         }
 
         uint32_t virtioGpuContextId = 0;
         VkMemoryPropertyFlags memoryPropertyFlags;
 
+        bool deviceHasDmabufExt = false;
+
         // Map guest memory index to host memory index and lookup memory properties:
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
 
             auto* physicalDevice = android::base::find(mDeviceToPhysicalDevice, device);
             if (!physicalDevice) {
@@ -5215,6 +5386,9 @@ class VkDecoderGlobalState::Impl {
                     << "No physical device info available for " << *physicalDevice;
             }
 
+            deviceHasDmabufExt =
+                hasDeviceExtension(device, VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME);
+
             const auto hostMemoryInfoOpt =
                 physicalDeviceInfo->memoryPropertiesHelper
                     ->getHostMemoryInfoFromGuestMemoryTypeIndex(localAllocInfo.memoryTypeIndex);
@@ -5246,7 +5420,7 @@ class VkDecoderGlobalState::Impl {
             auto descriptorInfoOpt = ExternalObjectManager::get()->removeBlobDescriptorInfo(
                 virtioGpuContextId, createBlobInfoPtr->blobId);
             if (descriptorInfoOpt) {
-                auto rawDescriptorOpt = (*descriptorInfoOpt).descriptor.release();
+                auto rawDescriptorOpt = (*descriptorInfoOpt).descriptorInfo.descriptor.release();
                 if (rawDescriptorOpt) {
                     rawDescriptor = *rawDescriptorOpt;
                 } else {
@@ -5257,17 +5431,17 @@ class VkDecoderGlobalState::Impl {
                 ERR("Failed vkAllocateMemory: missing descriptor info.");
                 return VK_ERROR_OUT_OF_DEVICE_MEMORY;
             }
-#if defined(__linux__)
-            importInfo.fd = rawDescriptor;
-#endif
 
-#ifdef __linux__
-            if (m_emu->deviceInfo.supportsDmaBuf &&
-                hasDeviceExtension(device, VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME)) {
-                importInfo.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+#if defined(_WIN32)
+            importWin32HandleInfo.handle = rawDescriptor;
+            vk_append_struct(&structChainIter, &importWin32HandleInfo);
+#else
+            importFdInfo.fd = rawDescriptor;
+            if (m_vkEmulation->supportsDmaBuf() && deviceHasDmabufExt) {
+                importFdInfo.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
             }
+            vk_append_struct(&structChainIter, &importFdInfo);
 #endif
-            vk_append_struct(&structChainIter, &importInfo);
         }
 
         const bool isImport = importCbInfoPtr || importBufferInfoPtr;
@@ -5280,7 +5454,7 @@ class VkDecoderGlobalState::Impl {
         std::shared_ptr<PrivateMemory> privateMemory = {};
 
         if (isExport && hostVisible) {
-            if (m_emu->features.SystemBlob.enabled) {
+            if (m_vkEmulation->getFeatures().SystemBlob.enabled) {
                 // Ensure size is page-aligned.
                 VkDeviceSize alignedSize = __ALIGN(localAllocInfo.allocationSize, kPageSizeforBlob);
                 if (alignedSize != localAllocInfo.allocationSize) {
@@ -5313,15 +5487,14 @@ class VkDecoderGlobalState::Impl {
                     .pHostPointer = mappedPtr,
                 };
                 vk_append_struct(&structChainIter, &*importHostInfo);
-            } else if (m_emu->features.ExternalBlob.enabled) {
+            } else if (m_vkEmulation->getFeatures().ExternalBlob.enabled) {
                 VkExternalMemoryHandleTypeFlags handleTypes;
 
 #if defined(__APPLE__)
-                if (m_emu->instanceSupportsMoltenVK) {
+                if (m_vkEmulation->supportsMoltenVk()) {
                     // Using a different handle type when in MoltenVK mode
-                    handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT|VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT;
-                }
-                else {
+                    handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT;
+                } else {
                     handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
                 }
 #elif defined(_WIN32)
@@ -5331,8 +5504,7 @@ class VkDecoderGlobalState::Impl {
 #endif
 
 #ifdef __linux__
-                if (m_emu->deviceInfo.supportsDmaBuf &&
-                    hasDeviceExtension(device, VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME)) {
+                if (m_vkEmulation->supportsDmaBuf() && deviceHasDmabufExt) {
                     handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
                 }
 #endif
@@ -5343,15 +5515,15 @@ class VkDecoderGlobalState::Impl {
                     .handleTypes = handleTypes,
                 };
                 vk_append_struct(&structChainIter, &*exportAllocateInfo);
-            } else if (m_emu->features.VulkanAllocateHostMemory.enabled &&
+            } else if (m_vkEmulation->getFeatures().VulkanAllocateHostMemory.enabled &&
                        localAllocInfo.pNext == nullptr) {
-                if (!m_emu || !m_emu->deviceInfo.supportsExternalMemoryHostProps) {
+                if (!m_vkEmulation || !m_vkEmulation->supportsExternalMemoryHostProperties()) {
                     ERR("VK_EXT_EXTERNAL_MEMORY_HOST is not supported, cannot use "
                         "VulkanAllocateHostMemory");
                     return VK_ERROR_INCOMPATIBLE_DRIVER;
                 }
                 VkDeviceSize alignmentSize =
-                    m_emu->deviceInfo.externalMemoryHostProps.minImportedHostPointerAlignment;
+                    m_vkEmulation->externalMemoryHostProperties().minImportedHostPointerAlignment;
                 VkDeviceSize alignedSize = __ALIGN(localAllocInfo.allocationSize, alignmentSize);
                 localAllocInfo.allocationSize = alignedSize;
                 privateMemory =
@@ -5408,24 +5580,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-#ifdef _WIN32
-        // Let ManagedDescriptor to close the underlying HANDLE when going out of scope. From the
-        // VkImportMemoryWin32HandleInfoKHR spec: Importing memory object payloads from Windows
-        // handles does not transfer ownership of the handle to the Vulkan implementation. For
-        // handle types defined as NT handles, the application must release handle ownership using
-        // the CloseHandle system call when the handle is no longer needed. For handle types defined
-        // as NT handles, the imported memory object holds a reference to its payload.
-#else
-        // Tell ManagedDescriptor not to close the underlying fd, because the ownership has already
-        // been transferred to the Vulkan implementation. From VkImportMemoryFdInfoKHR spec:
-        // Importing memory from a file descriptor transfers ownership of the file descriptor from
-        // the application to the Vulkan implementation. The application must not perform any
-        // operations on the file descriptor after a successful import. The imported memory object
-        // holds a reference to its payload.
-        externalMemoryHandle.release();
-#endif
-
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         VALIDATE_NEW_HANDLE_INFO_ENTRY(mMemoryInfo, *pMemory);
         mMemoryInfo[*pMemory] = MemoryInfo();
@@ -5460,7 +5615,7 @@ class VkDecoderGlobalState::Impl {
         // When external blobs are on, we want to map memory only if a workaround is using it in
         // the gfxstream process. This happens when ASTC CPU emulation is on.
         bool needToMap =
-            (!m_emu->features.ExternalBlob.enabled ||
+            (!m_vkEmulation->getFeatures().ExternalBlob.enabled ||
              (deviceInfo->useAstcCpuDecompression && deviceInfo->emulateTextureAstc)) &&
             !createBlobInfoPtr;
 
@@ -5509,7 +5664,7 @@ class VkDecoderGlobalState::Impl {
             // to unmap vs. address space allocate and mapMemory leading to
             // mapping the same gpa twice)
             if (mUseOldMemoryCleanupPath) {
-                unmapMemoryAtGpaIfExists(memoryInfo.guestPhysAddr);
+                unmapMemoryAtGpa(memoryInfo.guestPhysAddr, memoryInfo.sizeToPage);
             }
         }
 
@@ -5521,7 +5676,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     void freeMemoryLocked(VkDevice device, VulkanDispatch* deviceDispatch, VkDeviceMemory memory,
-                          const VkAllocationCallbacks* pAllocator) {
+                          const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto memoryInfoIt = mMemoryInfo.find(memory);
         if (memoryInfoIt == mMemoryInfo.end()) return;
         auto& memoryInfo = memoryInfoIt->second;
@@ -5531,24 +5686,26 @@ class VkDecoderGlobalState::Impl {
         mMemoryInfo.erase(memoryInfoIt);
     }
 
-    void on_vkFreeMemory(android::base::BumpPool* pool, VkDevice boxed_device,
-                         VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator) {
+    void on_vkFreeMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                         VkDevice boxed_device, VkDeviceMemory memory,
+                         const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
         if (!device || !deviceDispatch) return;
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         freeMemoryLocked(device, deviceDispatch, memory, pAllocator);
     }
 
-    VkResult on_vkMapMemory(android::base::BumpPool* pool, VkDevice, VkDeviceMemory memory,
-                            VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags,
-                            void** ppData) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+    VkResult on_vkMapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkDevice,
+                            VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size,
+                            VkMemoryMapFlags flags, void** ppData) {
+        std::lock_guard<std::mutex> lock(mMutex);
         return on_vkMapMemoryLocked(0, memory, offset, size, flags, ppData);
     }
     VkResult on_vkMapMemoryLocked(VkDevice, VkDeviceMemory memory, VkDeviceSize offset,
-                                  VkDeviceSize size, VkMemoryMapFlags flags, void** ppData) {
+                                  VkDeviceSize size, VkMemoryMapFlags flags, void** ppData)
+        REQUIRES(mMutex) {
         auto* info = android::base::find(mMemoryInfo, memory);
         if (!info || !info->ptr) return VK_ERROR_MEMORY_MAP_FAILED;  // Invalid usage.
 
@@ -5556,13 +5713,14 @@ class VkDecoderGlobalState::Impl {
         return VK_SUCCESS;
     }
 
-    void on_vkUnmapMemory(android::base::BumpPool* pool, VkDevice, VkDeviceMemory) {
+    void on_vkUnmapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkDevice,
+                          VkDeviceMemory) {
         // no-op; user-level mapping does not correspond
         // to any operation here.
     }
 
     uint8_t* getMappedHostPointer(VkDeviceMemory memory) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* info = android::base::find(mMemoryInfo, memory);
         if (!info) return nullptr;
@@ -5571,7 +5729,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkDeviceSize getDeviceMemorySize(VkDeviceMemory memory) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* info = android::base::find(mMemoryInfo, memory);
         if (!info) return 0;
@@ -5580,8 +5738,8 @@ class VkDecoderGlobalState::Impl {
     }
 
     bool usingDirectMapping() const {
-        return m_emu->features.GlDirectMem.enabled ||
-               m_emu->features.VirtioGpuNext.enabled;
+        return m_vkEmulation->getFeatures().GlDirectMem.enabled ||
+               m_vkEmulation->getFeatures().VirtioGpuNext.enabled;
     }
 
     HostFeatureSupport getHostFeatureSupport() const {
@@ -5589,17 +5747,16 @@ class VkDecoderGlobalState::Impl {
 
         if (!m_vk) return res;
 
-        auto emu = getGlobalVkEmulation();
-
-        res.supportsVulkan = emu && emu->live;
+        res.supportsVulkan = m_vkEmulation != nullptr;
 
         if (!res.supportsVulkan) return res;
 
-        const auto& props = emu->deviceInfo.physdevProps;
+        const auto& props = m_vkEmulation->getPhysicalDeviceProperties();
 
         res.supportsVulkan1_1 = props.apiVersion >= VK_API_VERSION_1_1;
-        res.useDeferredCommands = emu->useDeferredCommands;
-        res.useCreateResourcesWithRequirements = emu->useCreateResourcesWithRequirements;
+        res.useDeferredCommands = m_vkEmulation->deferredCommandsEnabled();
+        res.useCreateResourcesWithRequirements =
+            m_vkEmulation->createResourcesWithRequirementsEnabled();
 
         res.apiVersion = props.apiVersion;
         res.driverVersion = props.driverVersion;
@@ -5608,7 +5765,7 @@ class VkDecoderGlobalState::Impl {
         return res;
     }
 
-    bool hasInstanceExtension(VkInstance instance, const std::string& name) {
+    bool hasInstanceExtension(VkInstance instance, const std::string& name) REQUIRES(mMutex) {
         auto* info = android::base::find(mInstanceInfo, instance);
         if (!info) return false;
 
@@ -5619,7 +5776,7 @@ class VkDecoderGlobalState::Impl {
         return false;
     }
 
-    bool hasDeviceExtension(VkDevice device, const std::string& name) {
+    bool hasDeviceExtension(VkDevice device, const std::string& name) REQUIRES(mMutex) {
         auto* info = android::base::find(mDeviceInfo, device);
         if (!info) return false;
 
@@ -5655,29 +5812,29 @@ class VkDecoderGlobalState::Impl {
     }
 
     // VK_ANDROID_native_buffer
-    VkResult on_vkGetSwapchainGrallocUsageANDROID(android::base::BumpPool* pool, VkDevice,
-                                                  VkFormat format, VkImageUsageFlags imageUsage,
-                                                  int* grallocUsage) {
+    VkResult on_vkGetSwapchainGrallocUsageANDROID(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo*, VkDevice, VkFormat format,
+                                                  VkImageUsageFlags imageUsage, int* grallocUsage) {
         getGralloc0Usage(format, imageUsage, grallocUsage);
         return VK_SUCCESS;
     }
 
     VkResult on_vkGetSwapchainGrallocUsage2ANDROID(
-        android::base::BumpPool* pool, VkDevice, VkFormat format, VkImageUsageFlags imageUsage,
-        VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
-        uint64_t* grallocProducerUsage) {
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkDevice, VkFormat format,
+        VkImageUsageFlags imageUsage, VkSwapchainImageUsageFlagsANDROID swapchainImageUsage,
+        uint64_t* grallocConsumerUsage, uint64_t* grallocProducerUsage) {
         getGralloc1Usage(format, imageUsage, swapchainImageUsage, grallocConsumerUsage,
                          grallocProducerUsage);
         return VK_SUCCESS;
     }
 
-    VkResult on_vkAcquireImageANDROID(android::base::BumpPool* pool, VkDevice boxed_device,
-                                      VkImage image, int nativeFenceFd, VkSemaphore semaphore,
-                                      VkFence fence) {
+    VkResult on_vkAcquireImageANDROID(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                      VkDevice boxed_device, VkImage image, int nativeFenceFd,
+                                      VkSemaphore semaphore, VkFence fence) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
         if (!deviceInfo) return VK_ERROR_INITIALIZATION_FAILED;
@@ -5687,9 +5844,9 @@ class VkDecoderGlobalState::Impl {
 
         VkQueue defaultQueue;
         uint32_t defaultQueueFamilyIndex;
-        Lock* defaultQueueLock;
+        std::mutex* defaultQueueMutex;
         if (!getDefaultQueueForDeviceLocked(device, &defaultQueue, &defaultQueueFamilyIndex,
-                                            &defaultQueueLock)) {
+                                            &defaultQueueMutex)) {
             INFO("%s: can't get the default q", __func__);
             return VK_ERROR_INITIALIZATION_FAILED;
         }
@@ -5703,9 +5860,9 @@ class VkDecoderGlobalState::Impl {
 
         AndroidNativeBufferInfo* anbInfo = imageInfo->anbInfo.get();
 
-        VkResult result = setAndroidNativeImageSemaphoreSignaled(
-            vk, device, defaultQueue, defaultQueueFamilyIndex, defaultQueueLock, semaphore,
-            usedFence, anbInfo);
+        VkResult result =
+            anbInfo->on_vkAcquireImageANDROID(m_vkEmulation, vk, device, defaultQueue, defaultQueueFamilyIndex,
+                                              defaultQueueMutex, semaphore, usedFence);
         if (result != VK_SUCCESS) {
             return result;
         }
@@ -5730,14 +5887,15 @@ class VkDecoderGlobalState::Impl {
         return VK_SUCCESS;
     }
 
-    VkResult on_vkQueueSignalReleaseImageANDROID(android::base::BumpPool* pool, VkQueue boxed_queue,
+    VkResult on_vkQueueSignalReleaseImageANDROID(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo*, VkQueue boxed_queue,
                                                  uint32_t waitSemaphoreCount,
                                                  const VkSemaphore* pWaitSemaphores, VkImage image,
                                                  int* pNativeFenceFd) {
         auto queue = unbox_VkQueue(boxed_queue);
         auto vk = dispatch_VkQueue(boxed_queue);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* queueInfo = android::base::find(mQueueInfo, queue);
         if (!queueInfo) return VK_ERROR_INITIALIZATION_FAILED;
@@ -5752,35 +5910,35 @@ class VkDecoderGlobalState::Impl {
         if (!imageInfo) return VK_ERROR_INITIALIZATION_FAILED;
 
         auto* anbInfo = imageInfo->anbInfo.get();
-        if (anbInfo->useVulkanNativeImage) {
+        if (anbInfo->isUsingNativeImage()) {
             // vkQueueSignalReleaseImageANDROID() is only called by the Android framework's
             // implementation of vkQueuePresentKHR(). The guest application is responsible for
             // transitioning the image layout of the image passed to vkQueuePresentKHR() to
             // VK_IMAGE_LAYOUT_PRESENT_SRC_KHR before the call. If the host is using native
             // Vulkan images where `image` is backed with the same memory as its ColorBuffer,
             // then we need to update the tracked layout for that ColorBuffer.
-            setColorBufferCurrentLayout(anbInfo->colorBufferHandle,
+            m_vkEmulation->setColorBufferCurrentLayout(anbInfo->getColorBufferHandle(),
                                         VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);
         }
 
-        return syncImageToColorBuffer(m_emu->callbacks, vk, queueInfo->queueFamilyIndex, queue,
-                                      queueInfo->physicalQueueLock.get(), waitSemaphoreCount, pWaitSemaphores,
-                                      pNativeFenceFd, anbInfo);
+        return anbInfo->on_vkQueueSignalReleaseImageANDROID(
+            m_vkEmulation, vk, queueInfo->queueFamilyIndex, queue, queueInfo->queueMutex.get(),
+            waitSemaphoreCount, pWaitSemaphores, pNativeFenceFd);
     }
 
     VkResult on_vkMapMemoryIntoAddressSpaceGOOGLE(android::base::BumpPool* pool,
-                                                  VkDevice boxed_device, VkDeviceMemory memory,
-                                                  uint64_t* pAddress) {
+                                                  VkSnapshotApiCallInfo*, VkDevice boxed_device,
+                                                  VkDeviceMemory memory, uint64_t* pAddress) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
-        if (!m_emu->features.GlDirectMem.enabled) {
+        if (!m_vkEmulation->getFeatures().GlDirectMem.enabled) {
             fprintf(stderr,
                     "FATAL: Tried to use direct mapping "
                     "while GlDirectMem is not enabled!\n");
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         if (mLogging) {
             INFO("%s: deviceMemory: 0x%llx pAddress: 0x%llx", __func__,
@@ -5803,7 +5961,7 @@ class VkDecoderGlobalState::Impl {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto virtioGpuContextIdOpt = getContextIdForDeviceLocked(device);
         if (!virtioGpuContextIdOpt) {
@@ -5817,26 +5975,33 @@ class VkDecoderGlobalState::Impl {
 
         hostBlobId = (info->blobId && !hostBlobId) ? info->blobId : hostBlobId;
 
-        if (m_emu->features.SystemBlob.enabled && info->sharedMemory.has_value()) {
-            uint32_t handleType = STREAM_MEM_HANDLE_TYPE_SHM;
+        if (m_vkEmulation->getFeatures().SystemBlob.enabled && info->sharedMemory.has_value()) {
             // We transfer ownership of the shared memory handle to the descriptor info.
             // The memory itself is destroyed only when all processes unmap / release their
             // handles.
             ExternalObjectManager::get()->addBlobDescriptorInfo(
-                virtioGpuContextId, hostBlobId, info->sharedMemory->releaseHandle(), handleType,
-                info->caching, std::nullopt);
-        } else if (m_emu->features.ExternalBlob.enabled) {
-            VkResult result;
+                virtioGpuContextId, hostBlobId, info->sharedMemory->releaseHandle(),
+                STREAM_HANDLE_TYPE_MEM_SHM, info->caching, std::nullopt);
+        } else if (m_vkEmulation->getFeatures().ExternalBlob.enabled) {
+#ifdef __APPLE__
+            if (m_vkEmulation->supportsMoltenVk()) {
+                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                    << "ExternalBlob feature is not supported with MoltenVK";
+            }
+#endif
 
-            DescriptorType handle;
-            uint32_t handleType;
             struct VulkanInfo vulkanInfo = {
                 .memoryIndex = info->memoryIndex,
             };
-            memcpy(vulkanInfo.deviceUUID, m_emu->deviceInfo.idProps.deviceUUID,
-                   sizeof(vulkanInfo.deviceUUID));
-            memcpy(vulkanInfo.driverUUID, m_emu->deviceInfo.idProps.driverUUID,
-                   sizeof(vulkanInfo.driverUUID));
+
+            auto deviceUuidOpt = m_vkEmulation->getDeviceUuid();
+            if (deviceUuidOpt) {
+                memcpy(vulkanInfo.deviceUUID, deviceUuidOpt->data(), sizeof(vulkanInfo.deviceUUID));
+            }
+            auto driverUuidOpt = m_vkEmulation->getDriverUuid();
+            if (driverUuidOpt) {
+                memcpy(vulkanInfo.driverUUID, driverUuidOpt->data(), sizeof(vulkanInfo.driverUUID));
+            }
 
             if (snapshotsEnabled()) {
                 VkResult mapResult = vk->vkMapMemory(device, memory, 0, info->size, 0, &info->ptr);
@@ -5847,62 +6012,16 @@ class VkDecoderGlobalState::Impl {
                 info->needUnmap = true;
             }
 
-#ifdef __unix__
-            VkMemoryGetFdInfoKHR getFd = {
-                .sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
-                .pNext = nullptr,
-                .memory = memory,
-                .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
-            };
-
-            handleType = STREAM_MEM_HANDLE_TYPE_OPAQUE_FD;
-#endif
-
-#ifdef __linux__
-            if (m_emu->deviceInfo.supportsDmaBuf &&
-                hasDeviceExtension(device, VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME)) {
-                getFd.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
-                handleType = STREAM_MEM_HANDLE_TYPE_DMABUF;
-            }
-#endif
-
-#ifdef __unix__
-            result = m_emu->deviceInfo.getMemoryHandleFunc(device, &getFd, &handle);
-            if (result != VK_SUCCESS) {
-                return result;
-            }
-#endif
-
-#ifdef _WIN32
-            VkMemoryGetWin32HandleInfoKHR getHandle = {
-                .sType = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
-                .pNext = nullptr,
-                .memory = memory,
-                .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
-            };
-
-            handleType = STREAM_MEM_HANDLE_TYPE_OPAQUE_WIN32;
-
-            result = m_emu->deviceInfo.getMemoryHandleFunc(device, &getHandle, &handle);
-            if (result != VK_SUCCESS) {
-                return result;
-            }
-#endif
-
-#ifdef __APPLE__
-            if (m_emu->instanceSupportsMoltenVK) {
-                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-                    << "ExternalBlob feature is not supported with MoltenVK";
+            auto exportedMemoryOpt = m_vkEmulation->exportMemoryHandle(device, memory);
+            if (!exportedMemoryOpt) {
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
             }
-#endif
-
-            ManagedDescriptor managedHandle(handle);
+            auto& exportedMemory = *exportedMemoryOpt;
             ExternalObjectManager::get()->addBlobDescriptorInfo(
-                virtioGpuContextId, hostBlobId, std::move(managedHandle), handleType, info->caching,
+                virtioGpuContextId, hostBlobId, std::move(exportedMemory.descriptor),
+                exportedMemory.streamHandleType, info->caching,
                 std::optional<VulkanInfo>(vulkanInfo));
         } else if (!info->needUnmap) {
-            auto device = unbox_VkDevice(boxed_device);
-            auto vk = dispatch_VkDevice(boxed_device);
             VkResult mapResult = vk->vkMapMemory(device, memory, 0, info->size, 0, &info->ptr);
             if (mapResult != VK_SUCCESS) {
                 return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -5931,29 +6050,31 @@ class VkDecoderGlobalState::Impl {
         return VK_SUCCESS;
     }
 
-    VkResult on_vkGetBlobGOOGLE(android::base::BumpPool* pool, VkDevice boxed_device,
-                                VkDeviceMemory memory) {
+    VkResult on_vkGetBlobGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                VkDevice boxed_device, VkDeviceMemory memory) {
         return vkGetBlobInternal(boxed_device, memory, 0);
     }
 
     VkResult on_vkGetMemoryHostAddressInfoGOOGLE(android::base::BumpPool* pool,
-                                                 VkDevice boxed_device, VkDeviceMemory memory,
-                                                 uint64_t* pAddress, uint64_t* pSize,
-                                                 uint64_t* pHostmemId) {
-        hostBlobId++;
+                                                 VkSnapshotApiCallInfo*, VkDevice boxed_device,
+                                                 VkDeviceMemory memory, uint64_t* pAddress,
+                                                 uint64_t* pSize, uint64_t* pHostmemId) {
+        uint64_t hostBlobId = sNextHostBlobId++;
         *pHostmemId = hostBlobId;
         return vkGetBlobInternal(boxed_device, memory, hostBlobId);
     }
 
-    VkResult on_vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
                                        VkDeviceMemory memory,
                                        const VkAllocationCallbacks* pAllocator) {
-        on_vkFreeMemory(pool, boxed_device, memory, pAllocator);
+        on_vkFreeMemory(pool, snapshotInfo, boxed_device, memory, pAllocator);
 
         return VK_SUCCESS;
     }
 
-    VkResult on_vkAllocateCommandBuffers(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkAllocateCommandBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                         VkDevice boxed_device,
                                          const VkCommandBufferAllocateInfo* pAllocateInfo,
                                          VkCommandBuffer* pCommandBuffers) {
         auto device = unbox_VkDevice(boxed_device);
@@ -5965,7 +6086,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
         auto* commandPoolInfo = android::base::find(mCommandPoolInfo, pAllocateInfo->commandPool);
@@ -5992,18 +6113,31 @@ class VkDecoderGlobalState::Impl {
         return result;
     }
 
-    VkResult on_vkCreateCommandPool(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkCreateCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                    VkDevice boxed_device,
                                     const VkCommandPoolCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkCommandPool* pCommandPool) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
+        if (!pCreateInfo) {
+            WARN("%s: Invalid parameter.", __func__);
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+
+        VkCommandPoolCreateInfo localCI = *pCreateInfo;
+        if (localCI.flags & VK_COMMAND_POOL_CREATE_PROTECTED_BIT) {
+            // Protected memory is not supported on emulators. Override feature
+            // information to mark as unsupported (see b/329845987).
+            localCI.flags &= ~VK_COMMAND_POOL_CREATE_PROTECTED_BIT;
+            VERBOSE("Changed VK_COMMAND_POOL_CREATE_PROTECTED_BIT, new flags = %d", localCI.flags);
+        }
 
-        VkResult result = vk->vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
+        VkResult result = vk->vkCreateCommandPool(device, &localCI, pAllocator, pCommandPool);
         if (result != VK_SUCCESS) {
             return result;
         }
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         VALIDATE_NEW_HANDLE_INFO_ENTRY(mCommandPoolInfo, *pCommandPool);
         mCommandPoolInfo[*pCommandPool] = CommandPoolInfo();
         auto& cmdPoolInfo = mCommandPoolInfo[*pCommandPool];
@@ -6035,7 +6169,7 @@ class VkDecoderGlobalState::Impl {
 
     void destroyCommandPoolLocked(VkDevice device, VulkanDispatch* deviceDispatch,
                                   VkCommandPool commandPool,
-                                  const VkAllocationCallbacks* pAllocator) {
+                                  const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto commandPoolInfoIt = mCommandPoolInfo.find(commandPool);
         if (commandPoolInfoIt == mCommandPoolInfo.end()) return;
         auto& commandPoolInfo = commandPoolInfoIt->second;
@@ -6046,18 +6180,19 @@ class VkDecoderGlobalState::Impl {
         mCommandPoolInfo.erase(commandPoolInfoIt);
     }
 
-    void on_vkDestroyCommandPool(android::base::BumpPool* pool, VkDevice boxed_device,
-                                 VkCommandPool commandPool,
+    void on_vkDestroyCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                 VkDevice boxed_device, VkCommandPool commandPool,
                                  const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyCommandPoolLocked(device, deviceDispatch, commandPool, pAllocator);
     }
 
-    VkResult on_vkResetCommandPool(android::base::BumpPool* pool, VkDevice boxed_device,
-                                   VkCommandPool commandPool, VkCommandPoolResetFlags flags) {
+    VkResult on_vkResetCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                   VkDevice boxed_device, VkCommandPool commandPool,
+                                   VkCommandPoolResetFlags flags) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
@@ -6068,14 +6203,14 @@ class VkDecoderGlobalState::Impl {
         return result;
     }
 
-    void on_vkCmdExecuteCommands(android::base::BumpPool* pool, VkCommandBuffer boxed_commandBuffer,
-                                 uint32_t commandBufferCount,
+    void on_vkCmdExecuteCommands(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                 VkCommandBuffer boxed_commandBuffer, uint32_t commandBufferCount,
                                  const VkCommandBuffer* pCommandBuffers) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
         vk->vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         CommandBufferInfo& cmdBuffer = mCommandBufferInfo[commandBuffer];
         cmdBuffer.subCmds.insert(cmdBuffer.subCmds.end(), pCommandBuffers,
                                  pCommandBuffers + commandBufferCount);
@@ -6134,18 +6269,18 @@ class VkDecoderGlobalState::Impl {
     }
 
     template <typename VkSubmitInfoType>
-    VkResult on_vkQueueSubmit(android::base::BumpPool* pool, VkQueue boxed_queue,
-                              uint32_t submitCount, const VkSubmitInfoType* pSubmits,
-                              VkFence fence) {
+    VkResult on_vkQueueSubmit(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                              VkQueue boxed_queue, uint32_t submitCount,
+                              const VkSubmitInfoType* pSubmits, VkFence fence) {
         auto queue = unbox_VkQueue(boxed_queue);
         auto vk = dispatch_VkQueue(boxed_queue);
 
         std::unordered_set<HandleType> acquiredColorBuffers;
         std::unordered_set<HandleType> releasedColorBuffers;
-        if (!m_emu->features.GuestVulkanOnly.enabled) {
+        if (!m_vkEmulation->getFeatures().GuestVulkanOnly.enabled) {
             {
-                std::lock_guard<std::recursive_mutex> lock(mLock);
-                for (int i = 0; i < submitCount; i++) {
+                std::lock_guard<std::mutex> lock(mMutex);
+                for (uint32_t i = 0; i < submitCount; i++) {
                     for (int j = 0; j < getCommandBufferCount(pSubmits[i]); j++) {
                         VkCommandBuffer cmdBuffer = getCommandBuffer(pSubmits[i], j);
                         CommandBufferInfo* cmdBufferInfo =
@@ -6175,49 +6310,46 @@ class VkDecoderGlobalState::Impl {
                         acquiredColorBuffers.merge(cmdBufferInfo->acquiredColorBuffers);
                         releasedColorBuffers.merge(cmdBufferInfo->releasedColorBuffers);
                         for (const auto& ite : cmdBufferInfo->cbLayouts) {
-                            setColorBufferCurrentLayout(ite.first, ite.second);
+                            m_vkEmulation->setColorBufferCurrentLayout(ite.first, ite.second);
                         }
                     }
                 }
             }
 
             for (HandleType cb : acquiredColorBuffers) {
-                m_emu->callbacks.invalidateColorBuffer(cb);
+                m_vkEmulation->getCallbacks().invalidateColorBuffer(cb);
             }
         }
 
         VkDevice device = VK_NULL_HANDLE;
-        Lock* ql = nullptr;
-        DeviceOpTrackerPtr opTracker = nullptr;
-        VkFence usedFence = fence;
-        DeviceOpWaitable queueCompletedWaitable;
+        std::mutex* queueMutex = nullptr;
+
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             auto* queueInfo = android::base::find(mQueueInfo, queue);
             if (!queueInfo) {
                 ERR("vkQueueSubmit cannot find queue info for %p", queue);
                 return VK_ERROR_INITIALIZATION_FAILED;
             }
             device = queueInfo->device;
-            ql = queueInfo->physicalQueueLock.get();
+            queueMutex = queueInfo->queueMutex.get();
+        }
 
-            auto* deviceInfo = android::base::find(mDeviceInfo, device);
-            if (!deviceInfo) {
-                ERR("vkQueueSubmit cannot find device info for %p", device);
-                return VK_ERROR_INITIALIZATION_FAILED;
-            }
-            opTracker = deviceInfo->deviceOpTracker;
+        // Unsafe to release when snapshot enabled.
+        // Snapshot load might fail to find the shader modules if we release them here.
+        if (!snapshotsEnabled()) {
+            processDelayedRemovesForDevice(device);
+        }
 
-            // Unsafe to release when snapshot enabled.
-            // Snapshot load might fail to find the shader modules if we release them here.
-            if (!snapshotsEnabled()) {
-                sBoxedHandleManager.processDelayedRemovesGlobalStateLocked(device);
-            }
+        VkFence usedFence = fence;
+        DeviceOpWaitable queueCompletedWaitable;
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+
+            auto* deviceInfo = android::base::find(mDeviceInfo, device);
+            if (!deviceInfo) return VK_ERROR_INITIALIZATION_FAILED;
+            DeviceOpBuilder builder(*deviceInfo->deviceOpTracker);
 
-            for (uint32_t i = 0; i < submitCount; i++) {
-                executePreprocessRecursive(pSubmits[i]);
-            }
-            DeviceOpBuilder builder = DeviceOpBuilder(*opTracker);
             if (VK_NULL_HANDLE == usedFence) {
                 // Note: This fence will be managed by the DeviceOpTracker after the
                 // OnQueueSubmittedWithFence call, so it does not need to be destroyed in the scope
@@ -6225,62 +6357,55 @@ class VkDecoderGlobalState::Impl {
                 usedFence = builder.CreateFenceForOp();
             }
             queueCompletedWaitable = builder.OnQueueSubmittedWithFence(usedFence);
+
+            deviceInfo->deviceOpTracker->PollAndProcessGarbage();
         }
 
-        AutoLock qlock(*ql);
+        std::lock_guard<std::mutex> queueLock(*queueMutex);
         auto result = dispatchVkQueueSubmit(vk, queue, submitCount, pSubmits, usedFence);
 
         if (result != VK_SUCCESS) {
             WARN("dispatchVkQueueSubmit failed: %s [%d]", string_VkResult(result), result);
             return result;
         }
-
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-
-            std::unordered_set<HandleType> imageBarrierColorBuffers;
-            for (int i = 0; i < submitCount; i++) {
+            std::lock_guard<std::mutex> lock(mMutex);
+            // Update image layouts
+            for (uint32_t i = 0; i < submitCount; i++) {
                 for (int j = 0; j < getCommandBufferCount(pSubmits[i]); j++) {
                     VkCommandBuffer cmdBuffer = getCommandBuffer(pSubmits[i], j);
                     CommandBufferInfo* cmdBufferInfo =
                         android::base::find(mCommandBufferInfo, cmdBuffer);
-
-                    if (cmdBufferInfo) {
-                        imageBarrierColorBuffers.merge(cmdBufferInfo->imageBarrierColorBuffers);
-
-                        // Update image layouts
-                        for (const auto& ite : cmdBufferInfo->imageLayouts) {
-                            auto imageIte = mImageInfo.find(ite.first);
-                            if (imageIte == mImageInfo.end()) {
-                                continue;
-                            }
-                            imageIte->second.layout = ite.second;
-                        }
-                    }
-
-                    // Update latestUse for all wait/signal semaphores, to ensure that they
-                    // are never asynchronously destroyed before the queue submissions referencing
-                    // them have completed
-                    for (int j = 0; j < getWaitSemaphoreCount(pSubmits[i]); j++) {
-                        SemaphoreInfo* semaphoreInfo =
-                            android::base::find(mSemaphoreInfo, getWaitSemaphore(pSubmits[i], j));
-                        if (semaphoreInfo) {
-                            semaphoreInfo->latestUse = queueCompletedWaitable;
-                        }
+                    if (!cmdBufferInfo) {
+                        continue;
                     }
-                    for (int j = 0; j < getSignalSemaphoreCount(pSubmits[i]); j++) {
-                        SemaphoreInfo* semaphoreInfo =
-                            android::base::find(mSemaphoreInfo, getSignalSemaphore(pSubmits[i], j));
-                        if (semaphoreInfo) {
-                            semaphoreInfo->latestUse = queueCompletedWaitable;
+                    for (const auto& ite : cmdBufferInfo->imageLayouts) {
+                        auto imageIte = mImageInfo.find(ite.first);
+                        if (imageIte == mImageInfo.end()) {
+                            continue;
                         }
+                        imageIte->second.layout = ite.second;
                     }
                 }
             }
-
-            // Update latest use for color buffers
-            for (const auto& colorBuffer : imageBarrierColorBuffers) {
-                setColorBufferLatestUse(colorBuffer, queueCompletedWaitable, opTracker);
+            // Update latestUse for all wait/signal semaphores, to ensure that they
+            // are never asynchronously destroyed before the queue submissions referencing
+            // them have completed
+            for (uint32_t i = 0; i < submitCount; i++) {
+                for (uint32_t j = 0; j < getWaitSemaphoreCount(pSubmits[i]); j++) {
+                    SemaphoreInfo* semaphoreInfo =
+                        android::base::find(mSemaphoreInfo, getWaitSemaphore(pSubmits[i], j));
+                    if (semaphoreInfo) {
+                        semaphoreInfo->latestUse = queueCompletedWaitable;
+                    }
+                }
+                for (uint32_t j = 0; j < getSignalSemaphoreCount(pSubmits[i]); j++) {
+                    SemaphoreInfo* semaphoreInfo =
+                        android::base::find(mSemaphoreInfo, getSignalSemaphore(pSubmits[i], j));
+                    if (semaphoreInfo) {
+                        semaphoreInfo->latestUse = queueCompletedWaitable;
+                    }
+                }
             }
 
             // After vkQueueSubmit is called, we can signal the conditional variable
@@ -6288,18 +6413,17 @@ class VkDecoderGlobalState::Impl {
             // waitForFence() on this fence.
             auto* fenceInfo = android::base::find(mFenceInfo, fence);
             if (fenceInfo) {
-                fenceInfo->state = FenceInfo::State::kWaitable;
-                fenceInfo->lock.lock();
-                fenceInfo->cv.signalAndUnlock(&fenceInfo->lock);
+                {
+                    std::unique_lock<std::mutex> fenceLock(fenceInfo->mutex);
+                    fenceInfo->state = FenceInfo::State::kWaitable;
+                }
+                fenceInfo->cv.notify_all();
                 // Also update the latestUse waitable for this fence, to ensure
                 // it is not asynchronously destroyed before all the waitables
                 // referencing it
                 fenceInfo->latestUse = queueCompletedWaitable;
             }
-
-            opTracker->PollAndProcessGarbage();
         }
-
         if (!releasedColorBuffers.empty()) {
             result = vk->vkWaitForFences(device, 1, &usedFence, VK_TRUE, /* 1 sec */ 1000000000L);
             if (result != VK_SUCCESS) {
@@ -6308,48 +6432,48 @@ class VkDecoderGlobalState::Impl {
             }
 
             for (HandleType cb : releasedColorBuffers) {
-                m_emu->callbacks.flushColorBuffer(cb);
+                m_vkEmulation->getCallbacks().flushColorBuffer(cb);
             }
         }
 
         return result;
     }
 
-    VkResult on_vkQueueWaitIdle(android::base::BumpPool* pool, VkQueue boxed_queue) {
+    VkResult on_vkQueueWaitIdle(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                VkQueue boxed_queue) {
         auto queue = unbox_VkQueue(boxed_queue);
         auto vk = dispatch_VkQueue(boxed_queue);
 
         if (!queue) return VK_SUCCESS;
 
-        Lock* ql;
+        std::mutex* queueMutex;
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             auto* queueInfo = android::base::find(mQueueInfo, queue);
             if (!queueInfo) return VK_SUCCESS;
-            ql = queueInfo->physicalQueueLock.get();
+            queueMutex = queueInfo->queueMutex.get();
         }
 
-        if (mEnableVirtualVkQueue) {
-            // TODO(b/379862480): register and track gpu workload to wait only for them here, ie.
-            // not any other fences/work. It should not hold the queue lock/ql while waiting to
-            // allow submissions and other operations on the virtualized queue
-        }
+        // TODO(b/379862480): register and track gpu workload to wait only for the
+        // necessary work when the virtual graphics queue is enabled, ie. not any
+        // other fences/work. It should not hold the queue lock/ql while waiting to allow
+        // submissions and other operations on the virtualized queue
 
-        AutoLock qlock(*ql);
+        std::lock_guard<std::mutex> queueLock(*queueMutex);
         return vk->vkQueueWaitIdle(queue);
     }
 
-    VkResult on_vkResetCommandBuffer(android::base::BumpPool* pool,
+    VkResult on_vkResetCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                      VkCommandBuffer boxed_commandBuffer,
                                      VkCommandBufferResetFlags flags) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        m_emu->deviceLostHelper.onResetCommandBuffer(commandBuffer);
+        m_vkEmulation->getDeviceLostHelper().onResetCommandBuffer(commandBuffer);
 
         VkResult result = vk->vkResetCommandBuffer(commandBuffer, flags);
         if (VK_SUCCESS == result) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             auto& bufferInfo = mCommandBufferInfo[commandBuffer];
             bufferInfo.reset();
         }
@@ -6379,7 +6503,8 @@ class VkDecoderGlobalState::Impl {
     }
 
     void freeCommandBufferLocked(VkDevice device, VulkanDispatch* deviceDispatch,
-                                 VkCommandPool commandPool, VkCommandBuffer commandBuffer) {
+                                 VkCommandPool commandPool, VkCommandBuffer commandBuffer)
+        REQUIRES(mMutex) {
         auto commandBufferInfoIt = mCommandBufferInfo.find(commandBuffer);
         if (commandBufferInfoIt == mCommandBufferInfo.end()) {
             WARN("freeCommandBufferLocked cannot find %p", commandBuffer);
@@ -6393,25 +6518,27 @@ class VkDecoderGlobalState::Impl {
         mCommandBufferInfo.erase(commandBufferInfoIt);
     }
 
-    void on_vkFreeCommandBuffers(android::base::BumpPool* pool, VkDevice boxed_device,
-                                 VkCommandPool commandPool, uint32_t commandBufferCount,
+    void on_vkFreeCommandBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                 VkDevice boxed_device, VkCommandPool commandPool,
+                                 uint32_t commandBufferCount,
                                  const VkCommandBuffer* pCommandBuffers) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
         if (!device || !deviceDispatch) return;
 
         for (uint32_t i = 0; i < commandBufferCount; i++) {
-            m_emu->deviceLostHelper.onFreeCommandBuffer(pCommandBuffers[i]);
+            m_vkEmulation->getDeviceLostHelper().onFreeCommandBuffer(pCommandBuffers[i]);
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         for (uint32_t i = 0; i < commandBufferCount; i++) {
             freeCommandBufferLocked(device, deviceDispatch, commandPool, pCommandBuffers[i]);
         }
     }
 
     void on_vkGetPhysicalDeviceExternalSemaphoreProperties(
-        android::base::BumpPool* pool, VkPhysicalDevice boxed_physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+        VkPhysicalDevice boxed_physicalDevice,
         const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
         VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
         auto physicalDevice = unbox_VkPhysicalDevice(boxed_physicalDevice);
@@ -6420,7 +6547,7 @@ class VkDecoderGlobalState::Impl {
             return;
         }
 
-        if (m_emu->features.VulkanExternalSync.enabled) {
+        if (m_vkEmulation->getFeatures().VulkanExternalSync.enabled) {
             // Cannot forward this call to driver because nVidia linux driver crahses on it.
             switch (pExternalSemaphoreInfo->handleType) {
                 case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT:
@@ -6452,7 +6579,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkResult on_vkCreateDescriptorUpdateTemplate(
-        android::base::BumpPool* pool, VkDevice boxed_device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkDevice boxed_device,
         const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator,
         VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
@@ -6476,7 +6603,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkResult on_vkCreateDescriptorUpdateTemplateKHR(
-        android::base::BumpPool* pool, VkDevice boxed_device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkDevice boxed_device,
         const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator,
         VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
@@ -6499,7 +6626,8 @@ class VkDecoderGlobalState::Impl {
         return res;
     }
 
-    void on_vkDestroyDescriptorUpdateTemplate(android::base::BumpPool* pool, VkDevice boxed_device,
+    void on_vkDestroyDescriptorUpdateTemplate(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                              VkDevice boxed_device,
                                               VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                               const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
@@ -6511,7 +6639,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkDestroyDescriptorUpdateTemplateKHR(
-        android::base::BumpPool* pool, VkDevice boxed_device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkDevice boxed_device,
         VkDescriptorUpdateTemplate descriptorUpdateTemplate,
         const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
@@ -6523,16 +6651,16 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-        android::base::BumpPool* pool, VkDevice boxed_device, VkDescriptorSet descriptorSet,
-        VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-        uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
-        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
-        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
-        const VkBufferView* pBufferViews) {
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkDevice boxed_device,
+        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
+        const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
+        const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
+        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* info = android::base::find(mDescriptorUpdateTemplateInfo, descriptorUpdateTemplate);
         if (!info) return;
 
@@ -6548,17 +6676,17 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-        android::base::BumpPool* pool, VkDevice boxed_device, VkDescriptorSet descriptorSet,
-        VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-        uint32_t bufferInfoCount, uint32_t bufferViewCount, uint32_t inlineUniformBlockCount,
-        const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
-        const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
-        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews,
-        const uint8_t* pInlineUniformBlockData) {
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkDevice boxed_device,
+        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
+        uint32_t inlineUniformBlockCount, const uint32_t* pImageInfoEntryIndices,
+        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
+        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
+        const VkBufferView* pBufferViews, const uint8_t* pInlineUniformBlockData) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto* info = android::base::find(mDescriptorUpdateTemplateInfo, descriptorUpdateTemplate);
         if (!info) return;
 
@@ -6605,7 +6733,7 @@ class VkDecoderGlobalState::Impl {
         releaseOrderMaintInfo(order);
     }
 
-    void on_vkCommandBufferHostSyncGOOGLE(android::base::BumpPool* pool,
+    void on_vkCommandBufferHostSyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                           VkCommandBuffer commandBuffer, uint32_t needHostSync,
                                           uint32_t sequenceNumber) {
         this->hostSyncCommandBuffer("hostSync", commandBuffer, needHostSync, sequenceNumber);
@@ -6641,58 +6769,54 @@ class VkDecoderGlobalState::Impl {
         releaseOrderMaintInfo(order);
     }
 
-    void on_vkQueueHostSyncGOOGLE(android::base::BumpPool* pool, VkQueue queue,
-                                  uint32_t needHostSync, uint32_t sequenceNumber) {
+    void on_vkQueueHostSyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                  VkQueue queue, uint32_t needHostSync, uint32_t sequenceNumber) {
         this->hostSyncQueue("hostSyncQueue", queue, needHostSync, sequenceNumber);
     }
 
-    VkResult on_vkCreateImageWithRequirementsGOOGLE(android::base::BumpPool* pool,
-                                                    VkDevice boxed_device,
-                                                    const VkImageCreateInfo* pCreateInfo,
-                                                    const VkAllocationCallbacks* pAllocator,
-                                                    VkImage* pImage,
-                                                    VkMemoryRequirements* pMemoryRequirements) {
+    VkResult on_vkCreateImageWithRequirementsGOOGLE(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+        const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+        VkImage* pImage, VkMemoryRequirements* pMemoryRequirements) {
         if (pMemoryRequirements) {
             memset(pMemoryRequirements, 0, sizeof(*pMemoryRequirements));
         }
 
         VkResult imageCreateRes =
-            on_vkCreateImage(pool, boxed_device, pCreateInfo, pAllocator, pImage);
+            on_vkCreateImage(pool, snapshotInfo, boxed_device, pCreateInfo, pAllocator, pImage);
 
         if (imageCreateRes != VK_SUCCESS) {
             return imageCreateRes;
         }
 
-        on_vkGetImageMemoryRequirements(pool, boxed_device, unbox_VkImage(*pImage),
+        on_vkGetImageMemoryRequirements(pool, snapshotInfo, boxed_device, unbox_VkImage(*pImage),
                                         pMemoryRequirements);
 
         return imageCreateRes;
     }
 
-    VkResult on_vkCreateBufferWithRequirementsGOOGLE(android::base::BumpPool* pool,
-                                                     VkDevice boxed_device,
-                                                     const VkBufferCreateInfo* pCreateInfo,
-                                                     const VkAllocationCallbacks* pAllocator,
-                                                     VkBuffer* pBuffer,
-                                                     VkMemoryRequirements* pMemoryRequirements) {
+    VkResult on_vkCreateBufferWithRequirementsGOOGLE(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+        const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+        VkBuffer* pBuffer, VkMemoryRequirements* pMemoryRequirements) {
         if (pMemoryRequirements) {
             memset(pMemoryRequirements, 0, sizeof(*pMemoryRequirements));
         }
 
         VkResult bufferCreateRes =
-            on_vkCreateBuffer(pool, boxed_device, pCreateInfo, pAllocator, pBuffer);
+            on_vkCreateBuffer(pool, snapshotInfo, boxed_device, pCreateInfo, pAllocator, pBuffer);
 
         if (bufferCreateRes != VK_SUCCESS) {
             return bufferCreateRes;
         }
 
-        on_vkGetBufferMemoryRequirements(pool, boxed_device, unbox_VkBuffer(*pBuffer),
+        on_vkGetBufferMemoryRequirements(pool, snapshotInfo, boxed_device, unbox_VkBuffer(*pBuffer),
                                          pMemoryRequirements);
 
         return bufferCreateRes;
     }
 
-    VkResult on_vkBeginCommandBuffer(android::base::BumpPool* pool,
+    VkResult on_vkBeginCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                      VkCommandBuffer boxed_commandBuffer,
                                      const VkCommandBufferBeginInfo* pBeginInfo,
                                      const VkDecoderContext& context) {
@@ -6704,9 +6828,9 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        m_emu->deviceLostHelper.onBeginCommandBuffer(commandBuffer, vk);
+        m_vkEmulation->getDeviceLostHelper().onBeginCommandBuffer(commandBuffer, vk);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* commandBufferInfo = android::base::find(mCommandBufferInfo, commandBuffer);
         if (!commandBufferInfo) return VK_ERROR_UNKNOWN;
@@ -6721,21 +6845,23 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkResult on_vkBeginCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo,
                                                 VkCommandBuffer boxed_commandBuffer,
                                                 const VkCommandBufferBeginInfo* pBeginInfo,
                                                 const VkDecoderContext& context) {
-        return this->on_vkBeginCommandBuffer(pool, boxed_commandBuffer, pBeginInfo, context);
+        return this->on_vkBeginCommandBuffer(pool, snapshotInfo, boxed_commandBuffer, pBeginInfo,
+                                             context);
     }
 
-    VkResult on_vkEndCommandBuffer(android::base::BumpPool* pool,
+    VkResult on_vkEndCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                    VkCommandBuffer boxed_commandBuffer,
                                    const VkDecoderContext& context) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
 
-        m_emu->deviceLostHelper.onEndCommandBuffer(commandBuffer, vk);
+        m_vkEmulation->getDeviceLostHelper().onEndCommandBuffer(commandBuffer, vk);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* commandBufferInfo = android::base::find(mCommandBufferInfo, commandBuffer);
         if (!commandBufferInfo) return VK_ERROR_UNKNOWN;
@@ -6748,24 +6874,27 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkEndCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* snapshotInfo,
                                           VkCommandBuffer boxed_commandBuffer,
                                           const VkDecoderContext& context) {
-        on_vkEndCommandBuffer(pool, boxed_commandBuffer, context);
+        on_vkEndCommandBuffer(pool, snapshotInfo, boxed_commandBuffer, context);
     }
 
     void on_vkResetCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* snapshotInfo,
                                             VkCommandBuffer boxed_commandBuffer,
                                             VkCommandBufferResetFlags flags) {
-        on_vkResetCommandBuffer(pool, boxed_commandBuffer, flags);
+        on_vkResetCommandBuffer(pool, snapshotInfo, boxed_commandBuffer, flags);
     }
 
-    void on_vkCmdBindPipeline(android::base::BumpPool* pool, VkCommandBuffer boxed_commandBuffer,
+    void on_vkCmdBindPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                              VkCommandBuffer boxed_commandBuffer,
                               VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
         vk->vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
         if (pipelineBindPoint == VK_PIPELINE_BIND_POINT_COMPUTE) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             auto* cmdBufferInfo = android::base::find(mCommandBufferInfo, commandBuffer);
             if (cmdBufferInfo) {
                 cmdBufferInfo->computePipeline = pipeline;
@@ -6773,7 +6902,7 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdBindDescriptorSets(android::base::BumpPool* pool,
+    void on_vkCmdBindDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                     VkCommandBuffer boxed_commandBuffer,
                                     VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
                                     uint32_t firstSet, uint32_t descriptorSetCount,
@@ -6785,7 +6914,7 @@ class VkDecoderGlobalState::Impl {
                                     descriptorSetCount, pDescriptorSets, dynamicOffsetCount,
                                     pDynamicOffsets);
         if (descriptorSetCount) {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             auto* cmdBufferInfo = android::base::find(mCommandBufferInfo, commandBuffer);
             if (cmdBufferInfo) {
                 cmdBufferInfo->descriptorLayout = layout;
@@ -6801,15 +6930,15 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    VkResult on_vkCreateRenderPass(android::base::BumpPool* pool, VkDevice boxed_device,
-                                   const VkRenderPassCreateInfo* pCreateInfo,
+    VkResult on_vkCreateRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                   VkDevice boxed_device, const VkRenderPassCreateInfo* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator,
                                    VkRenderPass* pRenderPass) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
         VkRenderPassCreateInfo createInfo;
         bool needReformat = false;
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
         if (!deviceInfo) return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -6846,13 +6975,14 @@ class VkDecoderGlobalState::Impl {
         return res;
     }
 
-    VkResult on_vkCreateRenderPass2(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkCreateRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                    VkDevice boxed_device,
                                     const VkRenderPassCreateInfo2* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkRenderPass* pRenderPass) {
         auto device = unbox_VkDevice(boxed_device);
         auto vk = dispatch_VkDevice(boxed_device);
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         VkResult res = vk->vkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
         if (res != VK_SUCCESS) {
@@ -6875,7 +7005,8 @@ class VkDecoderGlobalState::Impl {
     }
 
     void destroyRenderPassLocked(VkDevice device, VulkanDispatch* deviceDispatch,
-                                 VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator) {
+                                 VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator)
+        REQUIRES(mMutex) {
         auto renderPassInfoIt = mRenderPassInfo.find(renderPass);
         if (renderPassInfoIt == mRenderPassInfo.end()) return;
         auto& renderPassInfo = renderPassInfoIt->second;
@@ -6886,12 +7017,13 @@ class VkDecoderGlobalState::Impl {
         mRenderPassInfo.erase(renderPass);
     }
 
-    void on_vkDestroyRenderPass(android::base::BumpPool* pool, VkDevice boxed_device,
-                                VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator) {
+    void on_vkDestroyRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                VkDevice boxed_device, VkRenderPass renderPass,
+                                const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyRenderPassLocked(device, deviceDispatch, renderPass, pAllocator);
     }
 
@@ -6902,7 +7034,7 @@ class VkDecoderGlobalState::Impl {
             return false;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         CommandBufferInfo* cmdBufferInfo = android::base::find(mCommandBufferInfo, commandBuffer);
         if (!cmdBufferInfo) {
             ERR("VkCommandBuffer=%p not found in mCommandBufferInfo", commandBuffer);
@@ -6922,7 +7054,8 @@ class VkDecoderGlobalState::Impl {
         return true;
     }
 
-    void on_vkCmdBeginRenderPass(android::base::BumpPool* pool, VkCommandBuffer boxed_commandBuffer,
+    void on_vkCmdBeginRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                 VkCommandBuffer boxed_commandBuffer,
                                  const VkRenderPassBeginInfo* pRenderPassBegin,
                                  VkSubpassContents contents) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
@@ -6932,7 +7065,7 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void on_vkCmdBeginRenderPass2(android::base::BumpPool* pool,
+    void on_vkCmdBeginRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                   VkCommandBuffer boxed_commandBuffer,
                                   const VkRenderPassBeginInfo* pRenderPassBegin,
                                   const VkSubpassBeginInfo* pSubpassBeginInfo) {
@@ -6944,30 +7077,39 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkCmdBeginRenderPass2KHR(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* snapshotInfo,
                                      VkCommandBuffer boxed_commandBuffer,
                                      const VkRenderPassBeginInfo* pRenderPassBegin,
                                      const VkSubpassBeginInfo* pSubpassBeginInfo) {
-        on_vkCmdBeginRenderPass2(pool, boxed_commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
+        on_vkCmdBeginRenderPass2(pool, snapshotInfo, boxed_commandBuffer, pRenderPassBegin,
+                                 pSubpassBeginInfo);
     }
 
-    void on_vkCmdCopyQueryPoolResults(android::base::BumpPool* pool,
+    void on_vkCmdCopyQueryPoolResults(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
                                       VkCommandBuffer boxed_commandBuffer, VkQueryPool queryPool,
                                       uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer,
                                       VkDeviceSize dstOffset, VkDeviceSize stride,
                                       VkQueryResultFlags flags) {
         auto commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
         auto vk = dispatch_VkCommandBuffer(boxed_commandBuffer);
-        if (queryCount == 1 && stride == 0) {
-            // Some drivers don't seem to handle stride==0 very well.
-            // In fact, the spec does not say what should happen with stride==0.
-            // So we just use the largest stride possible.
-            stride = mBufferInfo[dstBuffer].size - dstOffset;
+
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+
+            if (queryCount == 1 && stride == 0) {
+                // Some drivers don't seem to handle stride==0 very well.
+                // In fact, the spec does not say what should happen with stride==0.
+                // So we just use the largest stride possible.
+                stride = mBufferInfo[dstBuffer].size - dstOffset;
+            }
         }
+
         vk->vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer,
                                       dstOffset, stride, flags);
     }
 
-    VkResult on_vkCreateFramebuffer(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkCreateFramebuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                    VkDevice boxed_device,
                                     const VkFramebufferCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkFramebuffer* pFramebuffer) {
@@ -6980,7 +7122,7 @@ class VkDecoderGlobalState::Impl {
             return result;
         }
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         VALIDATE_NEW_HANDLE_INFO_ENTRY(mFramebufferInfo, *pFramebuffer);
         auto& framebufferInfo = mFramebufferInfo[*pFramebuffer];
@@ -6991,7 +7133,7 @@ class VkDecoderGlobalState::Impl {
             // Track the Colorbuffers that would be written to.
             // It might be better to check for VK_QUEUE_FAMILY_EXTERNAL in pipeline barrier.
             // But the guest does not always add it to pipeline barrier.
-            for (int i = 0; i < pCreateInfo->attachmentCount; i++) {
+            for (uint32_t i = 0; i < pCreateInfo->attachmentCount; i++) {
                 auto* imageViewInfo = android::base::find(mImageViewInfo, pCreateInfo->pAttachments[i]);
                 if (imageViewInfo->boundColorBuffer.has_value()) {
                     framebufferInfo.attachedColorBuffers.push_back(
@@ -7014,7 +7156,7 @@ class VkDecoderGlobalState::Impl {
 
     void destroyFramebufferLocked(VkDevice device, VulkanDispatch* deviceDispatch,
                                   VkFramebuffer framebuffer,
-                                  const VkAllocationCallbacks* pAllocator) {
+                                  const VkAllocationCallbacks* pAllocator) REQUIRES(mMutex) {
         auto framebufferInfoIt = mFramebufferInfo.find(framebuffer);
         if (framebufferInfoIt == mFramebufferInfo.end()) return;
         auto& framebufferInfo = framebufferInfoIt->second;
@@ -7025,19 +7167,19 @@ class VkDecoderGlobalState::Impl {
         mFramebufferInfo.erase(framebuffer);
     }
 
-    void on_vkDestroyFramebuffer(android::base::BumpPool* pool, VkDevice boxed_device,
-                                 VkFramebuffer framebuffer,
+    void on_vkDestroyFramebuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                 VkDevice boxed_device, VkFramebuffer framebuffer,
                                  const VkAllocationCallbacks* pAllocator) {
         auto device = unbox_VkDevice(boxed_device);
         auto deviceDispatch = dispatch_VkDevice(boxed_device);
 
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         destroyFramebufferLocked(device, deviceDispatch, framebuffer, pAllocator);
     }
 
-    VkResult on_vkQueueBindSparse(android::base::BumpPool* pool, VkQueue boxed_queue,
-                                  uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
-                                  VkFence fence) {
+    VkResult on_vkQueueBindSparse(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                  VkQueue boxed_queue, uint32_t bindInfoCount,
+                                  const VkBindSparseInfo* pBindInfo, VkFence fence) {
         // If pBindInfo contains VkTimelineSemaphoreSubmitInfo, then it's
         // possible the host driver isn't equipped to deal with them yet.  To
         // work around this, send empty vkQueueSubmits before and after the
@@ -7146,8 +7288,8 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    VkResult on_vkQueuePresentKHR(android::base::BumpPool* pool, VkQueue boxed_queue,
-                                  const VkPresentInfoKHR* pPresentInfo) {
+    VkResult on_vkQueuePresentKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                  VkQueue boxed_queue, const VkPresentInfoKHR* pPresentInfo) {
         // Note that on Android guests, this call will actually be handled
         // with vkQueueSignalReleaseImageANDROID
         auto queue = unbox_VkQueue(boxed_queue);
@@ -7156,13 +7298,28 @@ class VkDecoderGlobalState::Impl {
         return vk->vkQueuePresentKHR(queue, pPresentInfo);
     }
 
-    void on_vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool, VkDevice boxed_device,
+    void on_vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
                                          VkFormat format, VkDeviceSize* pOffset,
                                          VkDeviceSize* pRowPitchAlignment) {
-        if (mPerFormatLinearImageProperties.find(format) == mPerFormatLinearImageProperties.end()) {
-            VkDeviceSize offset = 0u;
-            VkDeviceSize rowPitchAlignment = UINT_MAX;
+        VkDeviceSize offset = 0u;
+        VkDeviceSize rowPitchAlignment = UINT_MAX;
+
+        bool needToPopulate = false;
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+
+            auto it = mPerFormatLinearImageProperties.find(format);
+            if (it == mPerFormatLinearImageProperties.end()) {
+                needToPopulate = true;
+            } else {
+                const auto& properties = it->second;
+                offset = properties.offset;
+                rowPitchAlignment = properties.rowPitchAlignment;
+            }
+        }
 
+        if (needToPopulate) {
             for (uint32_t width = 64; width <= 256; width++) {
                 LinearImageCreateInfo linearImageCreateInfo = {
                     .extent =
@@ -7179,12 +7336,16 @@ class VkDecoderGlobalState::Impl {
                 VkDeviceSize currRowPitchAlignment = UINT_MAX;
 
                 VkImageCreateInfo defaultVkImageCreateInfo = linearImageCreateInfo.toDefaultVk();
-                on_vkGetLinearImageLayout2GOOGLE(pool, boxed_device, &defaultVkImageCreateInfo,
-                                                 &currOffset, &currRowPitchAlignment);
+                on_vkGetLinearImageLayout2GOOGLE(pool, snapshotInfo, boxed_device,
+                                                 &defaultVkImageCreateInfo, &currOffset,
+                                                 &currRowPitchAlignment);
 
                 offset = currOffset;
                 rowPitchAlignment = std::min(currRowPitchAlignment, rowPitchAlignment);
             }
+
+            std::lock_guard<std::mutex> lock(mMutex);
+
             mPerFormatLinearImageProperties[format] = LinearImageProperties{
                 .offset = offset,
                 .rowPitchAlignment = rowPitchAlignment,
@@ -7192,22 +7353,42 @@ class VkDecoderGlobalState::Impl {
         }
 
         if (pOffset) {
-            *pOffset = mPerFormatLinearImageProperties[format].offset;
+            *pOffset = offset;
         }
         if (pRowPitchAlignment) {
-            *pRowPitchAlignment = mPerFormatLinearImageProperties[format].rowPitchAlignment;
+            *pRowPitchAlignment = rowPitchAlignment;
         }
     }
 
-    void on_vkGetLinearImageLayout2GOOGLE(android::base::BumpPool* pool, VkDevice boxed_device,
+    void on_vkGetLinearImageLayout2GOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                          VkDevice boxed_device,
                                           const VkImageCreateInfo* pCreateInfo,
-                                          VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment) {
+                                          VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment)
+        EXCLUDES(mMutex) {
+        VkDeviceSize offset = 0u;
+        VkDeviceSize rowPitchAlignment = UINT_MAX;
+
         LinearImageCreateInfo linearImageCreateInfo = {
             .extent = pCreateInfo->extent,
             .format = pCreateInfo->format,
             .usage = pCreateInfo->usage,
         };
-        if (mLinearImageProperties.find(linearImageCreateInfo) == mLinearImageProperties.end()) {
+
+        bool needToPopulate = false;
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+
+            auto it = mLinearImageProperties.find(linearImageCreateInfo);
+            if (it == mLinearImageProperties.end()) {
+                needToPopulate = true;
+            } else {
+                const auto& properties = it->second;
+                offset = properties.offset;
+                rowPitchAlignment = properties.rowPitchAlignment;
+            }
+        }
+
+        if (needToPopulate) {
             auto device = unbox_VkDevice(boxed_device);
             auto vk = dispatch_VkDevice(boxed_device);
 
@@ -7231,9 +7412,11 @@ class VkDecoderGlobalState::Impl {
             vk->vkGetImageSubresourceLayout(device, image, &subresource, &subresourceLayout);
             vk->vkDestroyImage(device, image, nullptr);
 
-            VkDeviceSize offset = subresourceLayout.offset;
+            offset = subresourceLayout.offset;
             uint64_t rowPitch = subresourceLayout.rowPitch;
-            VkDeviceSize rowPitchAlignment = rowPitch & (~rowPitch + 1);
+            rowPitchAlignment = rowPitch & (~rowPitch + 1);
+
+            std::lock_guard<std::mutex> lock(mMutex);
 
             mLinearImageProperties[linearImageCreateInfo] = {
                 .offset = offset,
@@ -7242,18 +7425,19 @@ class VkDecoderGlobalState::Impl {
         }
 
         if (pOffset != nullptr) {
-            *pOffset = mLinearImageProperties[linearImageCreateInfo].offset;
+            *pOffset = offset;
         }
         if (pRowPitchAlignment != nullptr) {
-            *pRowPitchAlignment = mLinearImageProperties[linearImageCreateInfo].rowPitchAlignment;
+            *pRowPitchAlignment = rowPitchAlignment;
         }
     }
 
 #include "VkSubDecoder.cpp"
 
-    void on_vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool, VkQueue queue,
-                                       VkCommandBuffer boxed_commandBuffer, VkDeviceSize dataSize,
-                                       const void* pData, const VkDecoderContext& context) {
+    void on_vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                       VkQueue queue, VkCommandBuffer boxed_commandBuffer,
+                                       VkDeviceSize dataSize, const void* pData,
+                                       const VkDecoderContext& context) {
         (void)queue;
 
         VkCommandBuffer commandBuffer = unbox_VkCommandBuffer(boxed_commandBuffer);
@@ -7262,25 +7446,24 @@ class VkDecoderGlobalState::Impl {
         subDecode(readStream, vk, boxed_commandBuffer, commandBuffer, dataSize, pData, context);
     }
 
-    void on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(android::base::BumpPool* pool, VkQueue queue,
+    void on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo*, VkQueue queue,
                                                     VkCommandBuffer commandBuffer,
                                                     VkDeviceMemory deviceMemory,
                                                     VkDeviceSize dataOffset, VkDeviceSize dataSize,
                                                     const VkDecoderContext& context) {
         // TODO : implement
     }
-    VkDescriptorSet getOrAllocateDescriptorSetFromPoolAndId(VulkanDispatch* vk, VkDevice device,
-                                                            VkDescriptorPool pool,
-                                                            VkDescriptorSetLayout setLayout,
-                                                            uint64_t poolId, uint32_t pendingAlloc,
-                                                            bool* didAlloc) {
+    VkDescriptorSet getOrAllocateDescriptorSetFromPoolAndIdLocked(
+        VulkanDispatch* vk, VkDevice device, VkDescriptorPool pool, VkDescriptorSetLayout setLayout,
+        uint64_t poolId, uint32_t pendingAlloc, bool* didAlloc) REQUIRES(mMutex) {
         auto* poolInfo = android::base::find(mDescriptorPoolInfo, pool);
         if (!poolInfo) {
             GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
                 << "descriptor pool " << pool << " not found ";
         }
 
-        DispatchableHandleInfo<uint64_t>* setHandleInfo = sBoxedHandleManager.get(poolId);
+        BoxedHandleInfo* setHandleInfo = sBoxedHandleManager.get(poolId);
 
         if (setHandleInfo->underlying) {
             if (pendingAlloc) {
@@ -7292,7 +7475,7 @@ class VkDecoderGlobalState::Impl {
                 };
                 vk->vkAllocateDescriptorSets(device, &dsAi, &allocedSet);
                 setHandleInfo->underlying = (uint64_t)allocedSet;
-                initDescriptorSetInfoLocked(pool, setLayout, poolId, allocedSet);
+                initDescriptorSetInfoLocked(device, pool, setLayout, poolId, allocedSet);
                 *didAlloc = true;
                 return allocedSet;
             } else {
@@ -7307,7 +7490,7 @@ class VkDecoderGlobalState::Impl {
                 };
                 vk->vkAllocateDescriptorSets(device, &dsAi, &allocedSet);
                 setHandleInfo->underlying = (uint64_t)allocedSet;
-                initDescriptorSetInfoLocked(pool, setLayout, poolId, allocedSet);
+                initDescriptorSetInfoLocked(device, pool, setLayout, poolId, allocedSet);
                 *didAlloc = true;
                 return allocedSet;
             } else {
@@ -7320,13 +7503,14 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
-        android::base::BumpPool* pool, VkQueue boxed_queue, uint32_t descriptorPoolCount,
-        const VkDescriptorPool* pDescriptorPools, uint32_t descriptorSetCount,
-        const VkDescriptorSetLayout* pDescriptorSetLayouts, const uint64_t* pDescriptorSetPoolIds,
-        const uint32_t* pDescriptorSetWhichPool, const uint32_t* pDescriptorSetPendingAllocation,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkQueue boxed_queue,
+        uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
+        uint32_t descriptorSetCount, const VkDescriptorSetLayout* pDescriptorSetLayouts,
+        const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
+        const uint32_t* pDescriptorSetPendingAllocation,
         const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
         const VkWriteDescriptorSet* pPendingDescriptorWrites) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         VkDevice device;
 
@@ -7340,21 +7524,21 @@ class VkDecoderGlobalState::Impl {
             GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
                 << "queue " << queue << "(boxed: " << boxed_queue << ") with no device registered";
         }
-        on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
-            pool, vk, device, descriptorPoolCount, pDescriptorPools, descriptorSetCount,
-            pDescriptorSetLayouts, pDescriptorSetPoolIds, pDescriptorSetWhichPool,
-            pDescriptorSetPendingAllocation, pDescriptorWriteStartingIndices,
-            pendingDescriptorWriteCount, pPendingDescriptorWrites);
+        on_vkQueueCommitDescriptorSetUpdatesGOOGLELocked(
+            pool, snapshotInfo, vk, device, descriptorPoolCount, pDescriptorPools,
+            descriptorSetCount, pDescriptorSetLayouts, pDescriptorSetPoolIds,
+            pDescriptorSetWhichPool, pDescriptorSetPendingAllocation,
+            pDescriptorWriteStartingIndices, pendingDescriptorWriteCount, pPendingDescriptorWrites);
     }
 
-    void on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
-        android::base::BumpPool* pool, VulkanDispatch* vk, VkDevice device,
-        uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
+    void on_vkQueueCommitDescriptorSetUpdatesGOOGLELocked(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VulkanDispatch* vk,
+        VkDevice device, uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
         uint32_t descriptorSetCount, const VkDescriptorSetLayout* pDescriptorSetLayouts,
         const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
         const uint32_t* pDescriptorSetPendingAllocation,
         const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
-        const VkWriteDescriptorSet* pPendingDescriptorWrites) {
+        const VkWriteDescriptorSet* pPendingDescriptorWrites) REQUIRES(mMutex) {
         std::vector<VkDescriptorSet> setsToUpdate(descriptorSetCount, nullptr);
 
         bool didAlloc = false;
@@ -7364,7 +7548,7 @@ class VkDecoderGlobalState::Impl {
             uint32_t whichPool = pDescriptorSetWhichPool[i];
             uint32_t pendingAlloc = pDescriptorSetPendingAllocation[i];
             bool didAllocThisTime;
-            setsToUpdate[i] = getOrAllocateDescriptorSetFromPoolAndId(
+            setsToUpdate[i] = getOrAllocateDescriptorSetFromPoolAndIdLocked(
                 vk, device, pDescriptorPools[whichPool], pDescriptorSetLayouts[i], poolId,
                 pendingAlloc, &didAllocThisTime);
 
@@ -7390,18 +7574,19 @@ class VkDecoderGlobalState::Impl {
                 }
             }
             this->on_vkUpdateDescriptorSetsImpl(
-                pool, vk, device, (uint32_t)writeDescriptorSetsForHostDriver.size(),
+                pool, snapshotInfo, vk, device, (uint32_t)writeDescriptorSetsForHostDriver.size(),
                 writeDescriptorSetsForHostDriver.data(), 0, nullptr);
         } else {
-            this->on_vkUpdateDescriptorSetsImpl(pool, vk, device, pendingDescriptorWriteCount,
+            this->on_vkUpdateDescriptorSetsImpl(pool, snapshotInfo, vk, device,
+                                                pendingDescriptorWriteCount,
                                                 pPendingDescriptorWrites, 0, nullptr);
         }
     }
 
-    void on_vkCollectDescriptorPoolIdsGOOGLE(android::base::BumpPool* pool, VkDevice device,
-                                             VkDescriptorPool descriptorPool,
+    void on_vkCollectDescriptorPoolIdsGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                             VkDevice device, VkDescriptorPool descriptorPool,
                                              uint32_t* pPoolIdCount, uint64_t* pPoolIds) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         auto& info = mDescriptorPoolInfo[descriptorPool];
         *pPoolIdCount = (uint32_t)info.poolIds.size();
 
@@ -7413,10 +7598,11 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkResult on_vkCreateSamplerYcbcrConversion(
-        android::base::BumpPool*, VkDevice boxed_device,
+        android::base::BumpPool*, VkSnapshotApiCallInfo* info, VkDevice boxed_device,
         const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
-        if (m_emu->enableYcbcrEmulation && !m_emu->deviceInfo.supportsSamplerYcbcrConversion) {
+        if (m_vkEmulation->isYcbcrEmulationEnabled() &&
+            !m_vkEmulation->supportsSamplerYcbcrConversion()) {
             *pYcbcrConversion = new_boxed_non_dispatchable_VkSamplerYcbcrConversion(
                 (VkSamplerYcbcrConversion)((uintptr_t)0xffff0000ull));
             return VK_SUCCESS;
@@ -7432,10 +7618,12 @@ class VkDecoderGlobalState::Impl {
         return VK_SUCCESS;
     }
 
-    void on_vkDestroySamplerYcbcrConversion(android::base::BumpPool* pool, VkDevice boxed_device,
+    void on_vkDestroySamplerYcbcrConversion(android::base::BumpPool* pool, VkSnapshotApiCallInfo*,
+                                            VkDevice boxed_device,
                                             VkSamplerYcbcrConversion ycbcrConversion,
                                             const VkAllocationCallbacks* pAllocator) {
-        if (m_emu->enableYcbcrEmulation && !m_emu->deviceInfo.supportsSamplerYcbcrConversion) {
+        if (m_vkEmulation->isYcbcrEmulationEnabled() &&
+            !m_vkEmulation->supportsSamplerYcbcrConversion()) {
             return;
         }
         auto device = unbox_VkDevice(boxed_device);
@@ -7445,7 +7633,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     VkResult on_vkEnumeratePhysicalDeviceGroups(
-        android::base::BumpPool* pool, VkInstance boxed_instance,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo*, VkInstance boxed_instance,
         uint32_t* pPhysicalDeviceGroupCount,
         VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
         auto instance = unbox_VkInstance(boxed_instance);
@@ -7458,7 +7646,7 @@ class VkDecoderGlobalState::Impl {
         }
 
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
             FilterPhysicalDevicesLocked(instance, vk, physicalDevices);
         }
 
@@ -7490,22 +7678,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     void on_DeviceLost() {
-        {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-
-            std::vector<DeviceLostHelper::DeviceWithQueues> devicesToQueues;
-            for (const auto& [device, deviceInfo] : mDeviceInfo) {
-                auto& deviceToQueues = devicesToQueues.emplace_back();
-                deviceToQueues.device = device;
-                deviceToQueues.deviceDispatch = dispatch_VkDevice(deviceInfo.boxed);
-                for (const auto& [queueIndex, queues] : deviceInfo.queues) {
-                    deviceToQueues.queues.insert(deviceToQueues.queues.end(), queues.begin(),
-                                                 queues.end());
-                }
-            }
-            m_emu->deviceLostHelper.onDeviceLost(devicesToQueues);
-        }
-
+        m_vkEmulation->getDeviceLostHelper().onDeviceLost();
         GFXSTREAM_ABORT(FatalError(VK_ERROR_DEVICE_LOST));
     }
 
@@ -7520,81 +7693,99 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    VkResult waitForFence(VkFence boxed_fence, uint64_t timeout) {
-        VkFence fence = unbox_VkFence(boxed_fence);
-        VkDevice device;
-        VulkanDispatch* vk;
-        StaticLock* fenceLock;
-        ConditionVariable* cv;
-        {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-            if (fence == VK_NULL_HANDLE || mFenceInfo.find(fence) == mFenceInfo.end()) {
-                // No fence, could be a semaphore.
-                // TODO: Async wait for semaphores
-                return VK_SUCCESS;
-            }
+    VkResult waitForFences(VkDevice unboxed_device, VulkanDispatch* vk, uint32_t fenceCount,
+                           const VkFence* pFences, VkBool32 waitAll, uint64_t timeout, bool checkWaitState) {
+        if (!fenceCount) {
+            return VK_SUCCESS;
+        }
 
-            // Vulkan specs require fences of vkQueueSubmit to be *externally
-            // synchronized*, i.e. we cannot submit a queue while waiting for the
-            // fence in another thread. For threads that call this function, they
-            // have to wait until a vkQueueSubmit() using this fence is called
-            // before calling vkWaitForFences(). So we use a conditional variable
-            // and mutex for thread synchronization.
-            //
-            // See:
-            // https://www.khronos.org/registry/vulkan/specs/1.2/html/vkspec.html#fundamentals-threadingbehavior
-            // https://github.com/KhronosGroup/Vulkan-LoaderAndValidationLayers/issues/519
+        const auto startTime = std::chrono::system_clock::now();
+        for (uint32_t i = 0; i < fenceCount; i++) {
+            VkFence fence = pFences[i];
+            {
+                std::mutex* fenceMutex = nullptr;
+                std::condition_variable* cv = nullptr;
+                {
+                    std::lock_guard<std::mutex> lock(mMutex);
+                    auto* fenceInfo = android::base::find(mFenceInfo, fence);
+                    if (!fenceInfo) {
+                        ERR("%s: Invalid fence information! (%p)", __func__, fence);
+                        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+                    }
 
-            device = mFenceInfo[fence].device;
-            vk = mFenceInfo[fence].vk;
-            fenceLock = &mFenceInfo[fence].lock;
-            cv = &mFenceInfo[fence].cv;
-        }
+                    if (unboxed_device != fenceInfo->device || vk != fenceInfo->vk) {
+                        ERR("%s: Invalid fence device! (%p, %p, %p)", __func__, fence,
+                            unboxed_device, fenceInfo->device);
+                        return VK_ERROR_OUT_OF_HOST_MEMORY;
+                    }
 
-        fenceLock->lock();
-        cv->wait(fenceLock, [this, fence] {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-            if (mFenceInfo[fence].state == FenceInfo::State::kWaitable) {
-                mFenceInfo[fence].state = FenceInfo::State::kWaiting;
-                return true;
-            }
-            return false;
-        });
-        fenceLock->unlock();
+                    fenceMutex = &fenceInfo->mutex;
+                    cv = &fenceInfo->cv;
+                }
 
-        {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-            if (mFenceInfo.find(fence) == mFenceInfo.end()) {
-                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
-                    << "Fence was destroyed before vkWaitForFences call.";
+                // Vulkan specs require fences of vkQueueSubmit to be *externally
+                // synchronized*, i.e. we cannot submit a queue while waiting for the
+                // fence in another thread. For threads that call this function, they
+                // have to wait until a vkQueueSubmit() using this fence is called
+                // before calling vkWaitForFences(). So we use a conditional variable
+                // and mutex for thread synchronization.
+                //
+                // See:
+                // https://www.khronos.org/registry/vulkan/specs/1.2/html/vkspec.html#fundamentals-threadingbehavior
+                // https://github.com/KhronosGroup/Vulkan-LoaderAndValidationLayers/issues/519
+
+                // Current implementation does not respect waitAll here.
+                if (checkWaitState) {
+                    std::unique_lock<std::mutex> lock(*fenceMutex);
+                    cv->wait(lock, [this, fence] {
+                        std::lock_guard<std::mutex> lock(mMutex);
+                        auto* fenceInfo = android::base::find(mFenceInfo, fence);
+                        if (!fenceInfo) {
+                            GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                                << "Fence was destroyed while waiting.";
+                        }
+
+                        // Block vkWaitForFences calls until the fence is waitable
+                        // Should also allow 'kWaiting' stage as the user can call
+                        // vkWaitForFences multiple times on the same fence.
+                        if (fenceInfo->state == FenceInfo::State::kNotWaitable) {
+                            return false;
+                        }
+                        fenceInfo->state = FenceInfo::State::kWaiting;
+                        return true;
+                    });
+                }
             }
         }
 
-        return vk->vkWaitForFences(device, /* fenceCount */ 1u, &fence,
-                                   /* waitAll */ false, timeout);
+        const auto endTime = std::chrono::system_clock::now();
+        const uint64_t timePassed = std::chrono::nanoseconds(endTime - startTime).count();
+        const uint64_t timeoutLeft = (timeout > timePassed) ? timeout - timePassed : 0;
+        return vk->vkWaitForFences(unboxed_device, fenceCount, pFences, waitAll, timeoutLeft);
     }
 
-    VkResult getFenceStatus(VkFence boxed_fence) {
-        VkFence fence = unbox_VkFence(boxed_fence);
+    VkResult waitForFence(VkFence fence, uint64_t timeout) {
         VkDevice device;
         VulkanDispatch* vk;
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
-            if (fence == VK_NULL_HANDLE || mFenceInfo.find(fence) == mFenceInfo.end()) {
+            std::lock_guard<std::mutex> lock(mMutex);
+            auto* fenceInfo = android::base::find(mFenceInfo, fence);
+            if (!fenceInfo) {
                 // No fence, could be a semaphore.
-                // TODO: Async get status for semaphores
+                // TODO: Async wait for semaphores
                 return VK_SUCCESS;
             }
 
-            device = mFenceInfo[fence].device;
-            vk = mFenceInfo[fence].vk;
+            device = fenceInfo->device;
+            vk = fenceInfo->vk;
         }
 
-        return vk->vkGetFenceStatus(device, fence);
+        return waitForFences(device, vk, 1, &fence, true, timeout, true);
     }
 
+
     AsyncResult registerQsriCallback(VkImage boxed_image, VkQsriTimeline::Callback callback) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
 
         VkImage image = try_unbox_VkImage(boxed_image);
         if (image == VK_NULL_HANDLE) return AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
@@ -7608,20 +7799,7 @@ class VkDecoderGlobalState::Impl {
             ERR("Attempted to register QSRI callback on VkImage:%p without ANB info.", image);
             return AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
         }
-        if (!anbInfo->vk) {
-            ERR("Attempted to register QSRI callback on VkImage:%p with uninitialized ANB info.",
-                image);
-            return AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
-        }
-        // Could be null or mismatched image, check later
-        if (image != anbInfo->image) {
-            ERR("Attempted on register QSRI callback on VkImage:%p with wrong image %p.", image,
-                anbInfo->image);
-            return AsyncResult::FAIL_AND_CALLBACK_NOT_SCHEDULED;
-        }
-
-        anbInfo->qsriTimeline->registerCallbackForNextPresentAndPoll(std::move(callback));
-        return AsyncResult::OK_AND_CALLBACK_SCHEDULED;
+        return anbInfo->registerQsriCallback(image, std::move(callback));
     }
 
 #define GUEST_EXTERNAL_MEMORY_HANDLE_TYPES                                \
@@ -7635,15 +7813,15 @@ class VkDecoderGlobalState::Impl {
                                                          uint32_t count) {
         VkExternalMemoryProperties* mut = (VkExternalMemoryProperties*)props;
         for (uint32_t i = 0; i < count; ++i) {
-            mut[i] = transformExternalMemoryProperties_tohost(mut[i]);
+            mut[i] = m_vkEmulation->transformExternalMemoryProperties_tohost(mut[i]);
         }
     }
     void transformImpl_VkExternalMemoryProperties_fromhost(const VkExternalMemoryProperties* props,
                                                            uint32_t count) {
         VkExternalMemoryProperties* mut = (VkExternalMemoryProperties*)props;
         for (uint32_t i = 0; i < count; ++i) {
-            mut[i] = transformExternalMemoryProperties_fromhost(mut[i],
-                                                                GUEST_EXTERNAL_MEMORY_HANDLE_TYPES);
+            mut[i] = m_vkEmulation->transformExternalMemoryProperties_fromhost(
+                mut[i], GUEST_EXTERNAL_MEMORY_HANDLE_TYPES);
         }
     }
 
@@ -7652,7 +7830,7 @@ class VkDecoderGlobalState::Impl {
         for (uint32_t i = 0; i < count; i++) {
             VkImageCreateInfo& imageCreateInfo =
                 const_cast<VkImageCreateInfo&>(pImageCreateInfos[i]);
-            const VkExternalMemoryImageCreateInfo* pExternalMemoryImageCi =
+            VkExternalMemoryImageCreateInfo* pExternalMemoryImageCi =
                 vk_find_struct<VkExternalMemoryImageCreateInfo>(&imageCreateInfo);
             bool importAndroidHardwareBuffer =
                 pExternalMemoryImageCi &&
@@ -7661,6 +7839,12 @@ class VkDecoderGlobalState::Impl {
             const VkNativeBufferANDROID* pNativeBufferANDROID =
                 vk_find_struct<VkNativeBufferANDROID>(&imageCreateInfo);
 
+            if (pExternalMemoryImageCi && pExternalMemoryImageCi->handleTypes &
+                                              VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT) {
+                pExternalMemoryImageCi->handleTypes |=
+                    m_vkEmulation->getDefaultExternalMemoryHandleType();
+            }
+
             // If the VkImage is going to bind to a ColorBuffer, we have to make sure the VkImage
             // that backs the ColorBuffer is created with identical parameters. From the spec: If
             // two aliases are both images that were created with identical creation parameters,
@@ -7697,15 +7881,17 @@ class VkDecoderGlobalState::Impl {
                 // For AHardwareBufferImage binding, we can't know which ColorBuffer this
                 // to-be-created VkImage will bind to, so we try our best to infer the creation
                 // parameters.
-                colorBufferVkImageCi = generateColorBufferVkImageCreateInfo(
+                colorBufferVkImageCi = m_vkEmulation->generateColorBufferVkImageCreateInfo(
                     resolvedFormat, imageCreateInfo.extent.width, imageCreateInfo.extent.height,
                     imageCreateInfo.tiling);
                 importSourceDebug = "AHardwareBuffer";
             } else if (pNativeBufferANDROID) {
                 // For native buffer binding, we can query the creation parameters from handle.
                 uint32_t cbHandle = *static_cast<const uint32_t*>(pNativeBufferANDROID->handle);
-                auto colorBufferInfo = getColorBufferInfo(cbHandle);
-                if (colorBufferInfo.handle == cbHandle) {
+
+                const auto colorBufferInfoOpt = m_vkEmulation->getColorBufferInfo(cbHandle);
+                if (colorBufferInfoOpt) {
+                    const auto& colorBufferInfo = *colorBufferInfoOpt;
                     colorBufferVkImageCi =
                         std::make_unique<VkImageCreateInfo>(colorBufferInfo.imageCreateInfoShallow);
                 } else {
@@ -7809,38 +7995,40 @@ class VkDecoderGlobalState::Impl {
         GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "Not yet implemented.";
     }
 
-#define DEFINE_EXTERNAL_HANDLE_TYPE_TRANSFORM(type, field)                                         \
-    void transformImpl_##type##_tohost(const type* props, uint32_t count) {                        \
-        type* mut = (type*)props;                                                                  \
-        for (uint32_t i = 0; i < count; ++i) {                                                     \
-            mut[i].field =                                                                         \
-                (VkExternalMemoryHandleTypeFlagBits)transformExternalMemoryHandleTypeFlags_tohost( \
-                    mut[i].field);                                                                 \
-        }                                                                                          \
-    }                                                                                              \
-    void transformImpl_##type##_fromhost(const type* props, uint32_t count) {                      \
-        type* mut = (type*)props;                                                                  \
-        for (uint32_t i = 0; i < count; ++i) {                                                     \
-            mut[i].field = (VkExternalMemoryHandleTypeFlagBits)                                    \
-                transformExternalMemoryHandleTypeFlags_fromhost(                                   \
-                    mut[i].field, GUEST_EXTERNAL_MEMORY_HANDLE_TYPES);                             \
-        }                                                                                          \
-    }
-
-#define DEFINE_EXTERNAL_MEMORY_PROPERTIES_TRANSFORM(type)                                  \
-    void transformImpl_##type##_tohost(const type* props, uint32_t count) {                \
-        type* mut = (type*)props;                                                          \
-        for (uint32_t i = 0; i < count; ++i) {                                             \
-            mut[i].externalMemoryProperties =                                              \
-                transformExternalMemoryProperties_tohost(mut[i].externalMemoryProperties); \
-        }                                                                                  \
-    }                                                                                      \
-    void transformImpl_##type##_fromhost(const type* props, uint32_t count) {              \
-        type* mut = (type*)props;                                                          \
-        for (uint32_t i = 0; i < count; ++i) {                                             \
-            mut[i].externalMemoryProperties = transformExternalMemoryProperties_fromhost(  \
-                mut[i].externalMemoryProperties, GUEST_EXTERNAL_MEMORY_HANDLE_TYPES);      \
-        }                                                                                  \
+#define DEFINE_EXTERNAL_HANDLE_TYPE_TRANSFORM(type, field)                                      \
+    void transformImpl_##type##_tohost(const type* props, uint32_t count) {                     \
+        type* mut = (type*)props;                                                               \
+        for (uint32_t i = 0; i < count; ++i) {                                                  \
+            mut[i].field =                                                                      \
+                (VkExternalMemoryHandleTypeFlagBits)                                            \
+                    m_vkEmulation->transformExternalMemoryHandleTypeFlags_tohost(mut[i].field); \
+        }                                                                                       \
+    }                                                                                           \
+    void transformImpl_##type##_fromhost(const type* props, uint32_t count) {                   \
+        type* mut = (type*)props;                                                               \
+        for (uint32_t i = 0; i < count; ++i) {                                                  \
+            mut[i].field = (VkExternalMemoryHandleTypeFlagBits)                                 \
+                               m_vkEmulation->transformExternalMemoryHandleTypeFlags_fromhost(  \
+                                   mut[i].field, GUEST_EXTERNAL_MEMORY_HANDLE_TYPES);           \
+        }                                                                                       \
+    }
+
+#define DEFINE_EXTERNAL_MEMORY_PROPERTIES_TRANSFORM(type)                                 \
+    void transformImpl_##type##_tohost(const type* props, uint32_t count) {               \
+        type* mut = (type*)props;                                                         \
+        for (uint32_t i = 0; i < count; ++i) {                                            \
+            mut[i].externalMemoryProperties =                                             \
+                m_vkEmulation->transformExternalMemoryProperties_tohost(                  \
+                    mut[i].externalMemoryProperties);                                     \
+        }                                                                                 \
+    }                                                                                     \
+    void transformImpl_##type##_fromhost(const type* props, uint32_t count) {             \
+        type* mut = (type*)props;                                                         \
+        for (uint32_t i = 0; i < count; ++i) {                                            \
+            mut[i].externalMemoryProperties =                                             \
+                m_vkEmulation->transformExternalMemoryProperties_fromhost(                \
+                    mut[i].externalMemoryProperties, GUEST_EXTERNAL_MEMORY_HANDLE_TYPES); \
+        }                                                                                 \
     }
 
     DEFINE_EXTERNAL_HANDLE_TYPE_TRANSFORM(VkPhysicalDeviceExternalImageFormatInfo, handleType)
@@ -7851,171 +8039,13 @@ class VkDecoderGlobalState::Impl {
     DEFINE_EXTERNAL_MEMORY_PROPERTIES_TRANSFORM(VkExternalImageFormatProperties)
     DEFINE_EXTERNAL_MEMORY_PROPERTIES_TRANSFORM(VkExternalBufferProperties)
 
-    uint64_t newGlobalHandle(const DispatchableHandleInfo<uint64_t>& item,
-                             BoxedHandleTypeTag typeTag) {
-        if (!mCreatedHandlesForSnapshotLoad.empty() &&
-            (mCreatedHandlesForSnapshotLoad.size() - mCreatedHandlesForSnapshotLoadIndex > 0)) {
-            auto handle = mCreatedHandlesForSnapshotLoad[mCreatedHandlesForSnapshotLoadIndex];
-            VKDGS_LOG("use handle: 0x%lx underlying 0x%lx", handle, item.underlying);
-            ++mCreatedHandlesForSnapshotLoadIndex;
-            auto res = sBoxedHandleManager.addFixed(handle, item, typeTag);
-
-            return res;
-        } else {
-            return sBoxedHandleManager.add(item, typeTag);
-        }
-    }
-
-#define DEFINE_BOXED_DISPATCHABLE_HANDLE_API_IMPL(type)                                           \
-    type new_boxed_##type(type underlying, VulkanDispatch* dispatch, bool ownDispatch) {          \
-        DispatchableHandleInfo<uint64_t> item;                                                    \
-        item.underlying = (uint64_t)underlying;                                                   \
-        item.dispatch = dispatch ? dispatch : new VulkanDispatch;                                 \
-        item.ownDispatch = ownDispatch;                                                           \
-        item.ordMaintInfo = new OrderMaintenanceInfo;                                             \
-        item.readStream = nullptr;                                                                \
-        auto res = (type)newGlobalHandle(item, Tag_##type);                                       \
-        return res;                                                                               \
-    }                                                                                             \
-    void delete_##type(type boxed) {                                                              \
-        if (!boxed) return;                                                                       \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) return;                                                                         \
-        releaseOrderMaintInfo(elt->ordMaintInfo);                                                 \
-        if (elt->readStream) {                                                                    \
-            sReadStreamRegistry.push(elt->readStream);                                            \
-            elt->readStream = nullptr;                                                            \
-        }                                                                                         \
-        sBoxedHandleManager.remove((uint64_t)boxed);                                              \
-    }                                                                                             \
-    OrderMaintenanceInfo* ordmaint_##type(type boxed) {                                           \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) return 0;                                                                       \
-        auto info = elt->ordMaintInfo;                                                            \
-        if (!info) return 0;                                                                      \
-        acquireOrderMaintInfo(info);                                                              \
-        return info;                                                                              \
-    }                                                                                             \
-    VulkanMemReadingStream* readstream_##type(type boxed) {                                       \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) return 0;                                                                       \
-        auto stream = elt->readStream;                                                            \
-        if (!stream) {                                                                            \
-            stream = sReadStreamRegistry.pop(getFeatures());                                      \
-            elt->readStream = stream;                                                             \
-        }                                                                                         \
-        return stream;                                                                            \
-    }                                                                                             \
-    VulkanDispatch* dispatch_##type(type boxed) {                                                 \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) {                                                                               \
-            ERR("%s: Failed to unbox %p", __func__, boxed);                                       \
-            return nullptr;                                                                       \
-        }                                                                                         \
-        return elt->dispatch;                                                                     \
-    }
-
-#define DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_IMPL(type)                                       \
-    type new_boxed_non_dispatchable_##type(type underlying) {                                     \
-        DispatchableHandleInfo<uint64_t> item;                                                    \
-        item.underlying = (uint64_t)underlying;                                                   \
-        auto res = (type)newGlobalHandle(item, Tag_##type);                                       \
-        return res;                                                                               \
-    }                                                                                             \
-    void delayed_delete_##type(type boxed, VkDevice device, std::function<void()> callback) {     \
-        sBoxedHandleManager.removeDelayed((uint64_t)boxed, device, callback);                     \
-    }                                                                                             \
-    void delete_##type(type boxed) { sBoxedHandleManager.remove((uint64_t)boxed); }               \
-    void set_boxed_non_dispatchable_##type(type boxed, type underlying) {                         \
-        DispatchableHandleInfo<uint64_t> item;                                                    \
-        item.underlying = (uint64_t)underlying;                                                   \
-        sBoxedHandleManager.update((uint64_t)boxed, item, Tag_##type);                            \
-    }                                                                                             \
-    type unboxed_to_boxed_non_dispatchable_##type(type unboxed) {                                 \
-        AutoLock lock(sBoxedHandleManager.lock);                                                  \
-        return (type)sBoxedHandleManager.getBoxedFromUnboxedLocked((uint64_t)(uintptr_t)unboxed); \
-    }                                                                                             \
-    type unbox_##type(type boxed) {                                                               \
-        AutoLock lock(sBoxedHandleManager.lock);                                                  \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) {                                                                               \
-            if constexpr (!std::is_same_v<type, VkFence>) {                                       \
-                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))                                   \
-                    << "Unbox " << boxed << " failed, not found.";                                \
-            }                                                                                     \
-            return VK_NULL_HANDLE;                                                                \
-        }                                                                                         \
-        return (type)elt->underlying;                                                             \
-    }                                                                                             \
-    type try_unbox_##type(type boxed) {                                                           \
-        AutoLock lock(sBoxedHandleManager.lock);                                                  \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) {                                                                               \
-            WARN("%s: Failed to unbox %p", __func__, boxed);                                      \
-            return VK_NULL_HANDLE;                                                                \
-        }                                                                                         \
-        return (type)elt->underlying;                                                             \
-    }
-
-    GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_API_IMPL)
-    GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_IMPL)
-
-#define DEFINE_BOXED_DISPATCHABLE_HANDLE_API_REGULAR_UNBOX_IMPL(type)                             \
-    type unbox_##type(type boxed) {                                                               \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt){                                                                                \
-            ERR("%s: Failed to unbox %p", __func__, boxed);                                       \
-            return VK_NULL_HANDLE;                                                                \
-        }                                                                                         \
-        return (type)elt->underlying;                                                             \
-    }                                                                                             \
-    type try_unbox_##type(type boxed) {                                                           \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt){                                                                                \
-            WARN("%s: Failed to unbox %p", __func__, boxed);                                      \
-            return VK_NULL_HANDLE;                                                                \
-        }                                                                                         \
-        return (type)elt->underlying;                                                             \
-    }                                                                                             \
-    type unboxed_to_boxed_##type(type unboxed) {                                                  \
-        AutoLock lock(sBoxedHandleManager.lock);                                                  \
-        return (type)sBoxedHandleManager.getBoxedFromUnboxedLocked((uint64_t)(uintptr_t)unboxed); \
-    }
-
-    GOLDFISH_VK_LIST_DISPATCHABLE_REGULAR_UNBOX_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_API_REGULAR_UNBOX_IMPL)
-
-    // Custom unbox_* functions or GOLDFISH_VK_LIST_DISPATCHABLE_CUSTOM_UNBOX_HANDLE_TYPES
-    // VkQueue objects can be virtual, meaning that multiple boxed queues can map into a single
-    // physical queue on the host GPU. Some conversion is needed for unboxing to physical.
-    VkQueue unbox_VkQueueImp(VkQueue boxed) {
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);
-        if (!elt) {
-            return VK_NULL_HANDLE;
-        }
-        const uint64_t unboxedQueue64 = elt->underlying;
-        if (mEnableVirtualVkQueue) {
-            // Clear virtual bit and unbox into the actual physical queue handle
-            return (VkQueue)(unboxedQueue64 & ~QueueInfo::kVirtualQueueBit);
-        }
-        return (VkQueue)(unboxedQueue64);
-    }
-    VkQueue unbox_VkQueue(VkQueue boxed) {
-        VkQueue unboxed = unbox_VkQueueImp(boxed);
-        if (unboxed == VK_NULL_HANDLE) {
-            ERR("%s: Failed to unbox %p", __func__, boxed);
-        }
-        return unboxed;
-    }
-    VkQueue try_unbox_VkQueue(VkQueue boxed) {
-        VkQueue unboxed = unbox_VkQueueImp(boxed);
-        if (unboxed == VK_NULL_HANDLE) {
-            WARN("%s: Failed to unbox %p", __func__, boxed);
-        }
-        return unboxed;
+    BoxedHandle newGlobalHandle(const BoxedHandleInfo& item, BoxedHandleTypeTag typeTag) {
+        return sBoxedHandleManager.add(item, typeTag);
     }
 
     VkDecoderSnapshot* snapshot() { return &mSnapshot; }
-    SnapshotState getSnapshotState() { return mSnapshotState; }
+
+    bool isSnapshotCurrentlyLoading() const { return mSnapshotState == SnapshotState::Loading; }
 
    private:
     bool isEmulatedInstanceExtension(const char* name) const {
@@ -8061,100 +8091,63 @@ class VkDecoderGlobalState::Impl {
             return res;
         }
 
-        if (hasDeviceExtension(properties, VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME)) {
-            res.push_back(VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME);
-        }
-
-        if (hasDeviceExtension(properties, VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME)) {
-            res.push_back(VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME);
-        }
-
-        if (hasDeviceExtension(properties, VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME)) {
-            res.push_back(VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME);
-        }
-
-        if (hasDeviceExtension(properties, VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME)) {
-            res.push_back(VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME);
-        }
-
-        if (hasDeviceExtension(properties, VK_KHR_SWAPCHAIN_EXTENSION_NAME)) {
-            res.push_back(VK_KHR_SWAPCHAIN_EXTENSION_NAME);
-        }
-
+        std::vector<const char*> hostAlwaysDeviceExtensions = {
+            VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME,
+            VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME,
+            VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME,
+            VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME,
+            VK_KHR_SWAPCHAIN_EXTENSION_NAME,
+            // TODO(b/378686769): Enable private data extension where available to
+            // mitigate the issues with duplicated vulkan handles. This should be
+            // removed once the issue is properly resolved.
+            VK_EXT_PRIVATE_DATA_EXTENSION_NAME,
+            // It is not uncommon for a guest app flow to expect to use
+            // VK_EXT_IMAGE_DRM_FORMAT_MODIFIER without actually enabling it in the
+            // ppEnabledExtensionNames. Mesa WSI (in Linux) does this, because it has certain
+            // assumptions about the Vulkan loader architecture it is using. However, depending on
+            // the host's Vulkan loader architecture, this could in NULL function pointer access
+            // (i.e. on vkGetImageDrmFormatModifierPropertiesEXT()). So just enable it if it's
+            // available.
+            VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME,
 #ifdef _WIN32
-        if (hasDeviceExtension(properties, VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME)) {
-            res.push_back(VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);
-        }
-
-        if (hasDeviceExtension(properties, VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME)) {
-            res.push_back(VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME);
-        }
+            VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME,
+            VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME,
 #elif defined(__QNX__)
-        // Note: VK_QNX_external_memory_screen_buffer is not supported in API translation,
-        // decoding, etc. However, push name to indicate external memory support to guest
-        if (hasDeviceExtension(properties, VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME)) {
-            res.push_back(VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME);
-            // EXT_queue_family_foreign is a pre-requisite for QNX_external_memory_screen_buffer
-            if (hasDeviceExtension(properties, VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME)) {
-                res.push_back(VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME);
-            }
-        }
-
-        if (hasDeviceExtension(properties, VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME)) {
-            res.push_back(VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME);
-        }
+            VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME,
+            // EXT_queue_family_foreign is an extension dependency of
+            // VK_QNX_external_memory_screen_buffer
+            VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME,
+            VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME,
 #elif __unix__
-        if (hasDeviceExtension(properties, VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME)) {
-            res.push_back(VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME);
-        }
+            VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME,
+            VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME,
+#endif
+        };
 
-        if (hasDeviceExtension(properties, VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME)) {
-            res.push_back(VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME);
-        }
-#elif defined(__APPLE__)
-        if (m_emu->instanceSupportsMoltenVK) {
-            if (hasDeviceExtension(properties, VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME)) {
-                res.push_back(VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME);
-            }
-            if (hasDeviceExtension(properties, VK_EXT_METAL_OBJECTS_EXTENSION_NAME)) {
-                res.push_back(VK_EXT_METAL_OBJECTS_EXTENSION_NAME);
-            }
-            if (hasDeviceExtension(properties, VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME)) {
-                res.push_back(VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME);
-            }
+#if defined(__APPLE__)
+        if (m_vkEmulation->supportsMoltenVk()) {
+            hostAlwaysDeviceExtensions.push_back(VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME);
+            hostAlwaysDeviceExtensions.push_back(VK_EXT_METAL_OBJECTS_EXTENSION_NAME);
+            hostAlwaysDeviceExtensions.push_back(VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME);
         } else {
             // Non-MoltenVK path, use memory_fd
-            if (hasDeviceExtension(properties, VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME)) {
-                res.push_back(VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME);
-            }
+            hostAlwaysDeviceExtensions.push_back(VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME);
         }
 #endif
 
-#ifdef __linux__
+#if defined(__linux__)
         // A dma-buf is a Linux kernel construct, commonly used with open-source DRM drivers.
         // See https://docs.kernel.org/driver-api/dma-buf.html for details.
-        if (m_emu->deviceInfo.supportsDmaBuf &&
-            hasDeviceExtension(properties, VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME)) {
-            res.push_back(VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME);
-        }
-
-        if (hasDeviceExtension(properties, VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME)) {
-            // Mesa Vulkan Wayland WSI needs vkGetImageDrmFormatModifierPropertiesEXT. On some Intel
-            // GPUs, this extension is exposed by the driver only if
-            // VK_EXT_image_drm_format_modifier extension is requested via
-            // VkDeviceCreateInfo::ppEnabledExtensionNames. vkcube-wayland does not request it,
-            // which makes the host attempt to call a null function pointer unless we force-enable
-            // it regardless of the client's wishes.
-            res.push_back(VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME);
+        if (m_vkEmulation->supportsDmaBuf()) {
+            hostAlwaysDeviceExtensions.push_back(VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME);
         }
-
 #endif
 
-        if (hasDeviceExtension(properties, VK_EXT_PRIVATE_DATA_EXTENSION_NAME)) {
-            //TODO(b/378686769): Enable private data extension where available to
-            // mitigate the issues with duplicated vulkan handles. This should be
-            // removed once the issue is properly resolved.
-            res.push_back(VK_EXT_PRIVATE_DATA_EXTENSION_NAME);
+        // Enable all the device extensions that should always be enabled on the host (if available)
+        for (auto extName : hostAlwaysDeviceExtensions) {
+            if (hasDeviceExtension(properties, extName)) {
+                res.push_back(extName);
+            }
         }
 
         return res;
@@ -8170,28 +8163,28 @@ class VkDecoderGlobalState::Impl {
             }
         }
 
-        if (m_emu->instanceSupportsExternalMemoryCapabilities) {
+        if (m_vkEmulation->supportsExternalMemoryCapabilities()) {
             res.push_back(VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME);
         }
 
-        if (m_emu->instanceSupportsExternalSemaphoreCapabilities) {
+        if (m_vkEmulation->supportsExternalSemaphoreCapabilities()) {
             res.push_back(VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME);
         }
 
-        if (m_emu->instanceSupportsExternalFenceCapabilities) {
+        if (m_vkEmulation->supportsExternalFenceCapabilities()) {
             res.push_back(VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME);
         }
 
-        if (m_emu->debugUtilsAvailableAndRequested) {
+        if (m_vkEmulation->debugUtilsEnabled()) {
             res.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
         }
 
-        if (m_emu->instanceSupportsSurface) {
+        if (m_vkEmulation->supportsSurfaces()) {
             res.push_back(VK_KHR_SURFACE_EXTENSION_NAME);
         }
 
 #if defined(__APPLE__)
-        if (m_emu->instanceSupportsMoltenVK) {
+        if (m_vkEmulation->supportsMoltenVk()) {
             res.push_back(VK_MVK_MACOS_SURFACE_EXTENSION_NAME);
             res.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
         }
@@ -8201,7 +8194,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     bool getDefaultQueueForDeviceLocked(VkDevice device, VkQueue* queue, uint32_t* queueFamilyIndex,
-                                        Lock** queueLock) {
+                                        std::mutex** queueMutex) REQUIRES(mMutex) {
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
         if (!deviceInfo) return false;
 
@@ -8214,7 +8207,7 @@ class VkDecoderGlobalState::Impl {
                 for (auto& deviceQueue : it.second) {
                     *queue = deviceQueue;
                     *queueFamilyIndex = index;
-                    *queueLock = mQueueInfo.at(deviceQueue).physicalQueueLock.get();
+                    *queueMutex = mQueueInfo.at(deviceQueue).queueMutex.get();
                     return true;
                 }
             }
@@ -8224,7 +8217,7 @@ class VkDecoderGlobalState::Impl {
             // Use queue family index 0.
             *queue = zeroIt->second[0];
             *queueFamilyIndex = 0;
-            *queueLock = mQueueInfo.at(zeroIt->second[0]).physicalQueueLock.get();
+            *queueMutex = mQueueInfo.at(zeroIt->second[0]).queueMutex.get();
             return true;
         }
 
@@ -8232,7 +8225,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     void updateImageMemorySizeLocked(VkDevice device, VkImage image,
-                                     VkMemoryRequirements* pMemoryRequirements) {
+                                     VkMemoryRequirements* pMemoryRequirements) REQUIRES(mMutex) {
         auto* deviceInfo = android::base::find(mDeviceInfo, device);
         if (!deviceInfo->emulateTextureEtc2 && !deviceInfo->emulateTextureAstc) {
             return;
@@ -8247,8 +8240,8 @@ class VkDecoderGlobalState::Impl {
     }
 
     // Whether the VkInstance associated with this physical device was created by ANGLE
-    bool isAngleInstance(VkPhysicalDevice physicalDevice, VulkanDispatch* vk) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+    bool isAngleInstanceLocked(VkPhysicalDevice physicalDevice, VulkanDispatch* vk)
+        REQUIRES(mMutex) {
         VkInstance* instance = android::base::find(mPhysicalDeviceToInstance, physicalDevice);
         if (!instance) return false;
         InstanceInfo* instanceInfo = android::base::find(mInstanceInfo, *instance);
@@ -8256,34 +8249,43 @@ class VkDecoderGlobalState::Impl {
         return instanceInfo->isAngle;
     }
 
-    bool enableEmulatedEtc2(VkPhysicalDevice physicalDevice, VulkanDispatch* vk) {
-        if (!m_emu->enableEtc2Emulation) return false;
+    bool enableEmulatedEtc2Locked(VkPhysicalDevice physicalDevice, VulkanDispatch* vk)
+        REQUIRES(mMutex) {
+        if (!m_vkEmulation->isEtc2EmulationEnabled()) return false;
 
         // Don't enable ETC2 emulation for ANGLE, let it do its own emulation.
-        return !isAngleInstance(physicalDevice, vk);
+        return !isAngleInstanceLocked(physicalDevice, vk);
     }
 
-    bool enableEmulatedAstc(VkPhysicalDevice physicalDevice, VulkanDispatch* vk) {
-        if (m_emu->astcLdrEmulationMode == AstcEmulationMode::Disabled) {
+    bool enableEmulatedAstcLocked(VkPhysicalDevice physicalDevice, VulkanDispatch* vk)
+        REQUIRES(mMutex) {
+        if (m_vkEmulation->getAstcLdrEmulationMode() == AstcEmulationMode::Disabled) {
             return false;
         }
 
         // Don't enable ASTC emulation for ANGLE, let it do its own emulation.
-        return !isAngleInstance(physicalDevice, vk);
+        return !isAngleInstanceLocked(physicalDevice, vk);
     }
 
-    bool needEmulatedEtc2(VkPhysicalDevice physicalDevice, VulkanDispatch* vk) {
-        if (!enableEmulatedEtc2(physicalDevice, vk)) {
-            return false;
+    bool needEmulatedEtc2(VkPhysicalDevice physicalDevice, VulkanDispatch* vk) EXCLUDES(mMutex) {
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+            if (!enableEmulatedEtc2Locked(physicalDevice, vk)) {
+                return false;
+            }
         }
+
         VkPhysicalDeviceFeatures feature;
         vk->vkGetPhysicalDeviceFeatures(physicalDevice, &feature);
         return !feature.textureCompressionETC2;
     }
 
-    bool needEmulatedAstc(VkPhysicalDevice physicalDevice, VulkanDispatch* vk) {
-        if (!enableEmulatedAstc(physicalDevice, vk)) {
-            return false;
+    bool needEmulatedAstc(VkPhysicalDevice physicalDevice, VulkanDispatch* vk) EXCLUDES(mMutex) {
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+            if (!enableEmulatedAstcLocked(physicalDevice, vk)) {
+                return false;
+            }
         }
         VkPhysicalDeviceFeatures feature;
         vk->vkGetPhysicalDeviceFeatures(physicalDevice, &feature);
@@ -8292,7 +8294,7 @@ class VkDecoderGlobalState::Impl {
 
     void getSupportedFenceHandleTypes(VulkanDispatch* vk, VkPhysicalDevice physicalDevice,
                                       uint32_t* supportedFenceHandleTypes) {
-        if (!m_emu->instanceSupportsExternalFenceCapabilities) {
+        if (!m_vkEmulation->supportsExternalFenceCapabilities()) {
             return;
         }
 
@@ -8329,7 +8331,7 @@ class VkDecoderGlobalState::Impl {
 
     void getSupportedSemaphoreHandleTypes(VulkanDispatch* vk, VkPhysicalDevice physicalDevice,
                                           uint32_t* supportedBinarySemaphoreHandleTypes) {
-        if (!m_emu->instanceSupportsExternalSemaphoreCapabilities) {
+        if (!m_vkEmulation->supportsExternalSemaphoreCapabilities()) {
             return;
         }
 
@@ -8369,7 +8371,7 @@ class VkDecoderGlobalState::Impl {
         bool hasGetPhysicalDeviceFeatures2KHR = false;
 
         {
-            std::lock_guard<std::recursive_mutex> lock(mLock);
+            std::lock_guard<std::mutex> lock(mMutex);
 
             auto* physdevInfo = android::base::find(mPhysdevInfo, physicalDevice);
             if (!physdevInfo) {
@@ -8414,7 +8416,7 @@ class VkDecoderGlobalState::Impl {
     }
 
     bool isEmulatedCompressedTexture(VkFormat format, VkPhysicalDevice physicalDevice,
-                                     VulkanDispatch* vk) {
+                                     VulkanDispatch* vk) EXCLUDES(mMutex) {
         return (gfxstream::vk::isEtc2(format) && needEmulatedEtc2(physicalDevice, vk)) ||
                (gfxstream::vk::isAstc(format) && needEmulatedAstc(physicalDevice, vk));
     }
@@ -8450,7 +8452,7 @@ class VkDecoderGlobalState::Impl {
         std::function<void(VkPhysicalDevice, VkFormat, VkFormatProperties1or2*)>
             getPhysicalDeviceFormatPropertiesFunc,
         VulkanDispatch* vk, VkPhysicalDevice physicalDevice, VkFormat format,
-        VkFormatProperties1or2* pFormatProperties) {
+        VkFormatProperties1or2* pFormatProperties) EXCLUDES(mMutex) {
         if (isEmulatedCompressedTexture(format, physicalDevice, vk)) {
             getPhysicalDeviceFormatPropertiesFunc(
                 physicalDevice, CompressedImageInfo::getOutputFormat(format),
@@ -8461,30 +8463,6 @@ class VkDecoderGlobalState::Impl {
         getPhysicalDeviceFormatPropertiesFunc(physicalDevice, format, pFormatProperties);
     }
 
-    void executePreprocessRecursive(int level, VkCommandBuffer cmdBuffer) {
-        auto* cmdBufferInfo = android::base::find(mCommandBufferInfo, cmdBuffer);
-        if (!cmdBufferInfo) return;
-        for (const auto& func : cmdBufferInfo->preprocessFuncs) {
-            func();
-        }
-        // TODO: fix
-        // for (const auto& subCmd : cmdBufferInfo->subCmds) {
-        // executePreprocessRecursive(level + 1, subCmd);
-        // }
-    }
-
-    void executePreprocessRecursive(const VkSubmitInfo& submit) {
-        for (uint32_t c = 0; c < submit.commandBufferCount; c++) {
-            executePreprocessRecursive(0, submit.pCommandBuffers[c]);
-        }
-    }
-
-    void executePreprocessRecursive(const VkSubmitInfo2& submit) {
-        for (uint32_t c = 0; c < submit.commandBufferInfoCount; c++) {
-            executePreprocessRecursive(0, submit.pCommandBufferInfos[c].commandBuffer);
-        }
-    }
-
     template <typename VkHandleToInfoMap,
               typename VkHandleType = typename std::decay_t<VkHandleToInfoMap>::key_type>
     void extractInfosWithDeviceInto(VkDevice device, VkHandleToInfoMap& inputMap,
@@ -8500,10 +8478,33 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void extractInstanceAndDependenciesLocked(VkInstance instance, InstanceObjects& objects) {
+    void extractDeviceAndDependenciesLocked(VkDevice device,
+                                            InstanceObjects::DeviceObjects& deviceObjects) REQUIRES(mMutex) {
+        extractInfosWithDeviceInto(device, mBufferInfo, deviceObjects.buffers);
+        extractInfosWithDeviceInto(device, mCommandBufferInfo, deviceObjects.commandBuffers);
+        extractInfosWithDeviceInto(device, mCommandPoolInfo, deviceObjects.commandPools);
+        extractInfosWithDeviceInto(device, mDescriptorPoolInfo, deviceObjects.descriptorPools);
+        extractInfosWithDeviceInto(device, mDescriptorSetInfo, deviceObjects.descriptorSets);
+        extractInfosWithDeviceInto(device, mDescriptorSetLayoutInfo,
+                                   deviceObjects.descriptorSetLayouts);
+        extractInfosWithDeviceInto(device, mMemoryInfo, deviceObjects.memories);
+        extractInfosWithDeviceInto(device, mFenceInfo, deviceObjects.fences);
+        extractInfosWithDeviceInto(device, mFramebufferInfo, deviceObjects.framebuffers);
+        extractInfosWithDeviceInto(device, mImageInfo, deviceObjects.images);
+        extractInfosWithDeviceInto(device, mImageViewInfo, deviceObjects.imageViews);
+        extractInfosWithDeviceInto(device, mPipelineCacheInfo, deviceObjects.pipelineCaches);
+        extractInfosWithDeviceInto(device, mPipelineLayoutInfo, deviceObjects.pipelineLayouts);
+        extractInfosWithDeviceInto(device, mPipelineInfo, deviceObjects.pipelines);
+        extractInfosWithDeviceInto(device, mQueueInfo, deviceObjects.queues);
+        extractInfosWithDeviceInto(device, mRenderPassInfo, deviceObjects.renderPasses);
+        extractInfosWithDeviceInto(device, mSamplerInfo, deviceObjects.samplers);
+        extractInfosWithDeviceInto(device, mSemaphoreInfo, deviceObjects.semaphores);
+        extractInfosWithDeviceInto(device, mShaderModuleInfo, deviceObjects.shaderModules);
+    }
+
+    void extractInstanceAndDependenciesLocked(VkInstance instance, InstanceObjects& objects) REQUIRES(mMutex) {
         auto instanceInfoIt = mInstanceInfo.find(instance);
         if (instanceInfoIt == mInstanceInfo.end()) return;
-        auto& instanceInfo = instanceInfoIt->second;
 
         objects.instance = mInstanceInfo.extract(instanceInfoIt);
 
@@ -8522,24 +8523,7 @@ class VkDecoderGlobalState::Impl {
 
             InstanceObjects::DeviceObjects& deviceObjects = objects.devices.emplace_back();
             deviceObjects.device = mDeviceInfo.extract(deviceInfoIt);
-
-            extractInfosWithDeviceInto(device, mBufferInfo, deviceObjects.buffers);
-            extractInfosWithDeviceInto(device, mCommandBufferInfo, deviceObjects.commandBuffers);
-            extractInfosWithDeviceInto(device, mCommandPoolInfo, deviceObjects.commandPools);
-            extractInfosWithDeviceInto(device, mDescriptorPoolInfo, deviceObjects.descriptorPools);
-            extractInfosWithDeviceInto(device, mDescriptorSetLayoutInfo,
-                                       deviceObjects.descriptorSetLayouts);
-            extractInfosWithDeviceInto(device, mFenceInfo, deviceObjects.fences);
-            extractInfosWithDeviceInto(device, mFramebufferInfo, deviceObjects.framebuffers);
-            extractInfosWithDeviceInto(device, mImageInfo, deviceObjects.images);
-            extractInfosWithDeviceInto(device, mImageViewInfo, deviceObjects.imageViews);
-            extractInfosWithDeviceInto(device, mMemoryInfo, deviceObjects.memories);
-            extractInfosWithDeviceInto(device, mPipelineCacheInfo, deviceObjects.pipelineCaches);
-            extractInfosWithDeviceInto(device, mQueueInfo, deviceObjects.queues);
-            extractInfosWithDeviceInto(device, mPipelineInfo, deviceObjects.pipelines);
-            extractInfosWithDeviceInto(device, mRenderPassInfo, deviceObjects.renderPasses);
-            extractInfosWithDeviceInto(device, mSemaphoreInfo, deviceObjects.semaphores);
-            extractInfosWithDeviceInto(device, mShaderModuleInfo, deviceObjects.shaderModules);
+            extractDeviceAndDependenciesLocked(device, deviceObjects);
         }
 
         for (InstanceObjects::DeviceObjects& deviceObjects : objects.devices) {
@@ -8556,90 +8540,115 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    void destroyInstanceObjects(InstanceObjects& objects) {
-        VkInstance instance = objects.instance.key();
-        InstanceInfo& instanceInfo = objects.instance.mapped();
-
-        for (InstanceObjects::DeviceObjects& deviceObjects : objects.devices) {
+    void destroyDeviceObjects(InstanceObjects::DeviceObjects& deviceObjects) {
             VkDevice device = deviceObjects.device.key();
             DeviceInfo& deviceInfo = deviceObjects.device.mapped();
             VulkanDispatch* deviceDispatch = dispatch_VkDevice(deviceInfo.boxed);
 
             // https://bugs.chromium.org/p/chromium/issues/detail?id=1074600
             // it's important to idle the device before destroying it!
-            deviceDispatch->vkDeviceWaitIdle(device);
+            VkResult res = deviceDispatch->vkDeviceWaitIdle(device);
+            if (res != VK_SUCCESS) {
+                // Something went wrong.. Skip destroying the vulkan objects of the device
+                // to avoid further issues.
+                ERR("Cannot destroy Vulkan device and objects. "
+                    "vkDeviceWaitIdle failed with %s [%d].", string_VkResult(res), res);
+                return;
+            }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu semaphores.", deviceObjects.semaphores.size());
             for (auto& [semaphore, semaphoreInfo] : deviceObjects.semaphores) {
-                destroySemaphoreWithExclusiveInfo(device, deviceDispatch, semaphore, semaphoreInfo,
+                destroySemaphoreWithExclusiveInfo(device, deviceDispatch, semaphore,
+                                                  deviceObjects.device.mapped(), semaphoreInfo,
                                                   nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu samplers.", deviceObjects.samplers.size());
             for (auto& [sampler, samplerInfo] : deviceObjects.samplers) {
                 destroySamplerWithExclusiveInfo(device, deviceDispatch, sampler, samplerInfo,
                                                 nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu buffers.", deviceObjects.buffers.size());
             for (auto& [buffer, bufferInfo] : deviceObjects.buffers) {
                 destroyBufferWithExclusiveInfo(device, deviceDispatch, buffer, bufferInfo, nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu imageViews.", deviceObjects.imageViews.size());
             for (auto& [imageView, imageViewInfo] : deviceObjects.imageViews) {
                 destroyImageViewWithExclusiveInfo(device, deviceDispatch, imageView, imageViewInfo,
                                                   nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu images.", deviceObjects.images.size());
             for (auto& [image, imageInfo] : deviceObjects.images) {
                 destroyImageWithExclusiveInfo(device, deviceDispatch, image, imageInfo, nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu memories.", deviceObjects.memories.size());
             for (auto& [memory, memoryInfo] : deviceObjects.memories) {
                 destroyMemoryWithExclusiveInfo(device, deviceDispatch, memory, memoryInfo, nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu commandBuffers.", deviceObjects.commandBuffers.size());
             for (auto& [commandBuffer, commandBufferInfo] : deviceObjects.commandBuffers) {
                 freeCommandBufferWithExclusiveInfos(device, deviceDispatch, commandBuffer,
                                                        commandBufferInfo,
                                                        deviceObjects.commandPools);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu commandPools.", deviceObjects.commandPools.size());
             for (auto& [commandPool, commandPoolInfo] : deviceObjects.commandPools) {
                 destroyCommandPoolWithExclusiveInfo(device, deviceDispatch, commandPool,
                                                     commandPoolInfo, deviceObjects.commandBuffers,
                                                     nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu descriptorPools.", deviceObjects.descriptorPools.size());
             for (auto& [descriptorPool, descriptorPoolInfo] : deviceObjects.descriptorPools) {
                 destroyDescriptorPoolWithExclusiveInfo(device, deviceDispatch, descriptorPool,
                                                        descriptorPoolInfo,
                                                        deviceObjects.descriptorSets, nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu descriptorSetLayouts.", deviceObjects.descriptorSetLayouts.size());
             for (auto& [descriptorSetLayout, descriptorSetLayoutInfo] :
                  deviceObjects.descriptorSetLayouts) {
                 destroyDescriptorSetLayoutWithExclusiveInfo(
                     device, deviceDispatch, descriptorSetLayout, descriptorSetLayoutInfo, nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu shaderModules.", deviceObjects.shaderModules.size());
             for (auto& [shaderModule, shaderModuleInfo] : deviceObjects.shaderModules) {
                 destroyShaderModuleWithExclusiveInfo(device, deviceDispatch, shaderModule,
                                                      shaderModuleInfo, nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu pipelines.", deviceObjects.pipelines.size());
             for (auto& [pipeline, pipelineInfo] : deviceObjects.pipelines) {
                 destroyPipelineWithExclusiveInfo(device, deviceDispatch, pipeline, pipelineInfo,
                                                  nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu pipelineCaches.", deviceObjects.pipelineCaches.size());
             for (auto& [pipelineCache, pipelineCacheInfo] : deviceObjects.pipelineCaches) {
                 destroyPipelineCacheWithExclusiveInfo(device, deviceDispatch, pipelineCache,
                                                       pipelineCacheInfo, nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu pipelineLayouts.", deviceObjects.pipelineLayouts.size());
+            for (auto& [pipelineLayout, pipelineLayoutInfo] : deviceObjects.pipelineLayouts) {
+                destroyPipelineLayoutWithExclusiveInfo(device, deviceDispatch, pipelineLayout,
+                                                      pipelineLayoutInfo, nullptr);
+            }
+
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu framebuffers.", deviceObjects.framebuffers.size());
             for (auto& [framebuffer, framebufferInfo] : deviceObjects.framebuffers) {
                 destroyFramebufferWithExclusiveInfo(device, deviceDispatch, framebuffer,
                                                     framebufferInfo, nullptr);
             }
 
+            LOG_CALLS_VERBOSE("destroyDeviceObjects: %zu renderPasses.", deviceObjects.renderPasses.size());
             for (auto& [renderPass, renderPassInfo] : deviceObjects.renderPasses) {
                 destroyRenderPassWithExclusiveInfo(device, deviceDispatch, renderPass,
                                                    renderPassInfo, nullptr);
@@ -8647,10 +8656,29 @@ class VkDecoderGlobalState::Impl {
 
             destroyDeviceWithExclusiveInfo(device, deviceObjects.device.mapped(),
                                            deviceObjects.fences, deviceObjects.queues, nullptr);
+    }
+
+    void destroyInstanceObjects(InstanceObjects& objects) {
+        VkInstance instance = objects.instance.key();
+        InstanceInfo& instanceInfo = objects.instance.mapped();
+        LOG_CALLS_VERBOSE(
+            "destroyInstanceObjects called for instance (app:%s, engine:%s) with %d devices.",
+            instanceInfo.applicationName.c_str(), instanceInfo.engineName.c_str(),
+            objects.devices.size());
+
+        for (InstanceObjects::DeviceObjects& deviceObjects : objects.devices) {
+            destroyDeviceObjects(deviceObjects);
         }
 
         m_vk->vkDestroyInstance(instance, nullptr);
+        INFO("Destroyed VkInstance:%p for application:%s engine:%s.", instance,
+             instanceInfo.applicationName.c_str(), instanceInfo.engineName.c_str());
+
+#ifdef CONFIG_AEMU
+        m_vkEmulation->getCallbacks().unregisterVulkanInstance((uint64_t)instance);
+#endif
         delete_VkInstance(instanceInfo.boxed);
+        LOG_CALLS_VERBOSE("destroyInstanceObjects: finished.");
     }
 
     bool isDescriptorTypeImageInfo(VkDescriptorType descType) {
@@ -8808,24 +8836,24 @@ class VkDecoderGlobalState::Impl {
 
     void registerDescriptorUpdateTemplate(VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                           const DescriptorUpdateTemplateInfo& info) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         mDescriptorUpdateTemplateInfo[descriptorUpdateTemplate] = info;
     }
 
     void unregisterDescriptorUpdateTemplate(VkDescriptorUpdateTemplate descriptorUpdateTemplate) {
-        std::lock_guard<std::recursive_mutex> lock(mLock);
+        std::lock_guard<std::mutex> lock(mMutex);
         mDescriptorUpdateTemplateInfo.erase(descriptorUpdateTemplate);
     }
 
     // Returns the VkInstance associated with a VkDevice, or null if it's not found
-    VkInstance* deviceToInstanceLocked(VkDevice device) {
+    VkInstance* deviceToInstanceLocked(VkDevice device) REQUIRES(mMutex) {
         auto* physicalDevice = android::base::find(mDeviceToPhysicalDevice, device);
         if (!physicalDevice) return nullptr;
         return android::base::find(mPhysicalDeviceToInstance, *physicalDevice);
     }
 
     VulkanDispatch* m_vk;
-    VkEmulation* m_emu;
+    VkEmulation* m_vkEmulation;
     emugl::RenderDocWithMultipleVkInstances* mRenderDocWithMultipleVkInstances = nullptr;
     bool mSnapshotsEnabled = false;
     bool mBatchedDescriptorSetUpdateEnabled = false;
@@ -8833,9 +8861,8 @@ class VkDecoderGlobalState::Impl {
     bool mLogging = false;
     bool mVerbosePrints = false;
     bool mUseOldMemoryCleanupPath = false;
-    bool mEnableVirtualVkQueue = false;
 
-    std::recursive_mutex mLock;
+    std::mutex mMutex;
 
     bool isBindingFeasibleForAlloc(const DescriptorPoolInfo::PoolState& poolState,
                                    const VkDescriptorSetLayoutBinding& binding) {
@@ -8869,7 +8896,8 @@ class VkDecoderGlobalState::Impl {
         poolState.used -= binding.descriptorCount;
     }
 
-    VkResult validateDescriptorSetAllocLocked(const VkDescriptorSetAllocateInfo* pAllocateInfo) {
+    VkResult validateDescriptorSetAllocLocked(const VkDescriptorSetAllocateInfo* pAllocateInfo)
+        REQUIRES(mMutex) {
         auto* poolInfo = android::base::find(mDescriptorPoolInfo, pAllocateInfo->descriptorPool);
         if (!poolInfo) return VK_ERROR_INITIALIZATION_FAILED;
 
@@ -8931,33 +8959,39 @@ class VkDecoderGlobalState::Impl {
         }
     }
 
-    std::unordered_map<VkInstance, InstanceInfo> mInstanceInfo;
-    std::unordered_map<VkPhysicalDevice, PhysicalDeviceInfo> mPhysdevInfo;
-    std::unordered_map<VkDevice, DeviceInfo> mDeviceInfo;
-    std::unordered_map<VkImage, ImageInfo> mImageInfo;
-    std::unordered_map<VkImageView, ImageViewInfo> mImageViewInfo;
-    std::unordered_map<VkSampler, SamplerInfo> mSamplerInfo;
-    std::unordered_map<VkCommandBuffer, CommandBufferInfo> mCommandBufferInfo;
-    std::unordered_map<VkCommandPool, CommandPoolInfo> mCommandPoolInfo;
-    // TODO: release CommandBufferInfo when a command pool is reset/released
-    std::unordered_map<VkQueue, QueueInfo> mQueueInfo;
-    std::unordered_map<VkBuffer, BufferInfo> mBufferInfo;
-    std::unordered_map<VkDeviceMemory, MemoryInfo> mMemoryInfo;
-    std::unordered_map<VkShaderModule, ShaderModuleInfo> mShaderModuleInfo;
-    std::unordered_map<VkPipelineCache, PipelineCacheInfo> mPipelineCacheInfo;
-    std::unordered_map<VkPipeline, PipelineInfo> mPipelineInfo;
-    std::unordered_map<VkRenderPass, RenderPassInfo> mRenderPassInfo;
-    std::unordered_map<VkFramebuffer, FramebufferInfo> mFramebufferInfo;
-    std::unordered_map<VkSemaphore, SemaphoreInfo> mSemaphoreInfo;
-    std::unordered_map<VkFence, FenceInfo> mFenceInfo;
-    std::unordered_map<VkDescriptorSetLayout, DescriptorSetLayoutInfo> mDescriptorSetLayoutInfo;
-    std::unordered_map<VkDescriptorPool, DescriptorPoolInfo> mDescriptorPoolInfo;
-    std::unordered_map<VkDescriptorSet, DescriptorSetInfo> mDescriptorSetInfo;
+    // Info tracking for vulkan objects
+    std::unordered_map<VkInstance, InstanceInfo> mInstanceInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkPhysicalDevice, PhysicalDeviceInfo> mPhysdevInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkDevice, DeviceInfo> mDeviceInfo GUARDED_BY(mMutex);
 
     // Back-reference to the physical device associated with a particular
     // VkDevice, and the VkDevice corresponding to a VkQueue.
-    std::unordered_map<VkDevice, VkPhysicalDevice> mDeviceToPhysicalDevice;
-    std::unordered_map<VkPhysicalDevice, VkInstance> mPhysicalDeviceToInstance;
+    std::unordered_map<VkDevice, VkPhysicalDevice> mDeviceToPhysicalDevice GUARDED_BY(mMutex);
+    std::unordered_map<VkPhysicalDevice, VkInstance> mPhysicalDeviceToInstance GUARDED_BY(mMutex);
+
+    // Device objects
+    std::unordered_map<VkBuffer, BufferInfo> mBufferInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkCommandBuffer, CommandBufferInfo> mCommandBufferInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkCommandPool, CommandPoolInfo> mCommandPoolInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkDescriptorPool, DescriptorPoolInfo> mDescriptorPoolInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkDescriptorSet, DescriptorSetInfo> mDescriptorSetInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkDescriptorSetLayout, DescriptorSetLayoutInfo> mDescriptorSetLayoutInfo
+        GUARDED_BY(mMutex);
+    std::unordered_map<VkDescriptorUpdateTemplate, DescriptorUpdateTemplateInfo>
+        mDescriptorUpdateTemplateInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkDeviceMemory, MemoryInfo> mMemoryInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkFence, FenceInfo> mFenceInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkFramebuffer, FramebufferInfo> mFramebufferInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkImage, ImageInfo> mImageInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkImageView, ImageViewInfo> mImageViewInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkPipeline, PipelineInfo> mPipelineInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkPipelineCache, PipelineCacheInfo> mPipelineCacheInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkPipelineLayout, PipelineLayoutInfo> mPipelineLayoutInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkQueue, QueueInfo> mQueueInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkRenderPass, RenderPassInfo> mRenderPassInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkSampler, SamplerInfo> mSamplerInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkSemaphore, SemaphoreInfo> mSemaphoreInfo GUARDED_BY(mMutex);
+    std::unordered_map<VkShaderModule, ShaderModuleInfo> mShaderModuleInfo GUARDED_BY(mMutex);
 
 #ifdef _WIN32
     int mSemaphoreId = 1;
@@ -8969,33 +9003,23 @@ class VkDecoderGlobalState::Impl {
         ++mSemaphoreId;
         return res;
     }
-    std::unordered_map<int, VkSemaphore> mExternalSemaphoresById;
+    std::unordered_map<int, VkSemaphore> mExternalSemaphoresById GUARDED_BY(mMutex);
 #endif
-    std::unordered_map<VkDescriptorUpdateTemplate, DescriptorUpdateTemplateInfo>
-        mDescriptorUpdateTemplateInfo;
 
     VkDecoderSnapshot mSnapshot;
-
-    std::vector<uint64_t> mCreatedHandlesForSnapshotLoad;
-    size_t mCreatedHandlesForSnapshotLoadIndex = 0;
+    enum class SnapshotState {
+        Normal,
+        Saving,
+        Loading,
+    };
+    SnapshotState mSnapshotState = SnapshotState::Normal;
 
     // NOTE: Only present during snapshot loading. This is needed to associate
     // `VkDevice`s with Virtio GPU context ids because API calls are not currently
     // replayed on the "same" RenderThread which originally made the API call so
     // RenderThreadInfoVk::ctx_id is not available.
-    std::optional<std::unordered_map<VkDevice, uint32_t>> mSnapshotLoadVkDeviceToVirtioCpuContextId;
-
-    Lock mOccupiedGpasLock;
-    // Back-reference to the VkDeviceMemory that is occupying a particular
-    // guest physical address
-    struct OccupiedGpaInfo {
-        VulkanDispatch* vk;
-        VkDevice device;
-        VkDeviceMemory memory;
-        uint64_t gpa;
-        size_t sizeToPage;
-    };
-    std::unordered_map<uint64_t, OccupiedGpaInfo> mOccupiedGpas;
+    std::optional<std::unordered_map<VkDevice, uint32_t>> mSnapshotLoadVkDeviceToVirtioCpuContextId
+        GUARDED_BY(mMutex);
 
     struct LinearImageCreateInfo {
         VkExtent3D extent;
@@ -9048,24 +9072,34 @@ class VkDecoderGlobalState::Impl {
     };
 
     // TODO(liyl): Remove after removing the old vkGetLinearImageLayoutGOOGLE.
-    std::unordered_map<VkFormat, LinearImageProperties> mPerFormatLinearImageProperties;
+    std::unordered_map<VkFormat, LinearImageProperties> mPerFormatLinearImageProperties
+        GUARDED_BY(mMutex);
 
     std::unordered_map<LinearImageCreateInfo, LinearImageProperties, LinearImageCreateInfo::Hash>
-        mLinearImageProperties;
-
-    SnapshotState mSnapshotState = SnapshotState::Normal;
+        mLinearImageProperties GUARDED_BY(mMutex);
 };
 
-VkDecoderGlobalState::VkDecoderGlobalState() : mImpl(new VkDecoderGlobalState::Impl()) {}
+VkDecoderGlobalState::VkDecoderGlobalState(VkEmulation* emulation)
+    : mImpl(new VkDecoderGlobalState::Impl(emulation)) {}
 
 VkDecoderGlobalState::~VkDecoderGlobalState() = default;
 
 static VkDecoderGlobalState* sGlobalDecoderState = nullptr;
 
+// static
+void VkDecoderGlobalState::initialize(VkEmulation* emulation) {
+    if (sGlobalDecoderState) {
+        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+            << "Attempted to re-initialize VkDecoderGlobalState.";
+    }
+    sGlobalDecoderState = new VkDecoderGlobalState(emulation);
+}
+
 // static
 VkDecoderGlobalState* VkDecoderGlobalState::get() {
-    if (sGlobalDecoderState) return sGlobalDecoderState;
-    sGlobalDecoderState = new VkDecoderGlobalState;
+    if (!sGlobalDecoderState) {
+        GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER)) << "VkDecoderGlobalState not initialized.";
+    }
     return sGlobalDecoderState;
 }
 
@@ -9080,12 +9114,12 @@ bool VkDecoderGlobalState::snapshotsEnabled() const { return mImpl->snapshotsEna
 bool VkDecoderGlobalState::batchedDescriptorSetUpdateEnabled() const { return mImpl->batchedDescriptorSetUpdateEnabled(); }
 
 uint64_t VkDecoderGlobalState::newGlobalVkGenericHandle() {
-    DispatchableHandleInfo<uint64_t> item;                                                    \
+    BoxedHandleInfo item;                                                    \
     return mImpl->newGlobalHandle(item, Tag_VkGeneric);
 }
 
-VkDecoderGlobalState::SnapshotState VkDecoderGlobalState::getSnapshotState() const {
-    return mImpl->getSnapshotState();
+bool VkDecoderGlobalState::isSnapshotCurrentlyLoading() const {
+    return mImpl->isSnapshotCurrentlyLoading();
 }
 
 const gfxstream::host::FeatureSet& VkDecoderGlobalState::getFeatures() const { return mImpl->getFeatures(); }
@@ -9099,576 +9133,709 @@ void VkDecoderGlobalState::load(android::base::Stream* stream, GfxApiLogger& gfx
     mImpl->load(stream, gfxLogger, healthMonitor);
 }
 
-void VkDecoderGlobalState::lock() { mImpl->lock(); }
-
-void VkDecoderGlobalState::unlock() { mImpl->unlock(); }
-
-size_t VkDecoderGlobalState::setCreatedHandlesForSnapshotLoad(const unsigned char* buffer) {
-    return mImpl->setCreatedHandlesForSnapshotLoad(buffer);
-}
-
-void VkDecoderGlobalState::clearCreatedHandlesForSnapshotLoad() {
-    mImpl->clearCreatedHandlesForSnapshotLoad();
-}
-
 VkResult VkDecoderGlobalState::on_vkEnumerateInstanceVersion(android::base::BumpPool* pool,
+                                                             VkSnapshotApiCallInfo* snapshotInfo,
                                                              uint32_t* pApiVersion) {
-    return mImpl->on_vkEnumerateInstanceVersion(pool, pApiVersion);
+    return mImpl->on_vkEnumerateInstanceVersion(pool, snapshotInfo, pApiVersion);
+}
+
+VkResult VkDecoderGlobalState::on_vkEnumerateInstanceExtensionProperties(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, const char* pLayerName,
+    uint32_t* pPropertyCount, VkExtensionProperties* pProperties) {
+    return mImpl->on_vkEnumerateInstanceExtensionProperties(pool, snapshotInfo, pLayerName,
+                                                            pPropertyCount, pProperties);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateInstance(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
                                                    const VkInstanceCreateInfo* pCreateInfo,
                                                    const VkAllocationCallbacks* pAllocator,
                                                    VkInstance* pInstance) {
-    return mImpl->on_vkCreateInstance(pool, pCreateInfo, pAllocator, pInstance);
+    return mImpl->on_vkCreateInstance(pool, snapshotInfo, pCreateInfo, pAllocator, pInstance);
 }
 
-void VkDecoderGlobalState::on_vkDestroyInstance(android::base::BumpPool* pool, VkInstance instance,
+void VkDecoderGlobalState::on_vkDestroyInstance(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo,
+                                                VkInstance instance,
                                                 const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyInstance(pool, instance, pAllocator);
+    mImpl->on_vkDestroyInstance(pool, snapshotInfo, instance, pAllocator);
 }
 
 VkResult VkDecoderGlobalState::on_vkEnumeratePhysicalDevices(android::base::BumpPool* pool,
+                                                             VkSnapshotApiCallInfo* snapshotInfo,
                                                              VkInstance instance,
                                                              uint32_t* physicalDeviceCount,
                                                              VkPhysicalDevice* physicalDevices) {
-    return mImpl->on_vkEnumeratePhysicalDevices(pool, instance, physicalDeviceCount,
+    return mImpl->on_vkEnumeratePhysicalDevices(pool, snapshotInfo, instance, physicalDeviceCount,
                                                 physicalDevices);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceFeatures(android::base::BumpPool* pool,
+                                                          VkSnapshotApiCallInfo* snapshotInfo,
                                                           VkPhysicalDevice physicalDevice,
                                                           VkPhysicalDeviceFeatures* pFeatures) {
-    mImpl->on_vkGetPhysicalDeviceFeatures(pool, physicalDevice, pFeatures);
+    mImpl->on_vkGetPhysicalDeviceFeatures(pool, snapshotInfo, physicalDevice, pFeatures);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceFeatures2(android::base::BumpPool* pool,
+                                                           VkSnapshotApiCallInfo* snapshotInfo,
                                                            VkPhysicalDevice physicalDevice,
                                                            VkPhysicalDeviceFeatures2* pFeatures) {
-    mImpl->on_vkGetPhysicalDeviceFeatures2(pool, physicalDevice, pFeatures);
+    mImpl->on_vkGetPhysicalDeviceFeatures2(pool, snapshotInfo, physicalDevice, pFeatures);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceFeatures2KHR(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    VkPhysicalDeviceFeatures2KHR* pFeatures) {
-    mImpl->on_vkGetPhysicalDeviceFeatures2(pool, physicalDevice, pFeatures);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2KHR* pFeatures) {
+    mImpl->on_vkGetPhysicalDeviceFeatures2(pool, snapshotInfo, physicalDevice, pFeatures);
 }
 
 VkResult VkDecoderGlobalState::on_vkGetPhysicalDeviceImageFormatProperties(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice, VkFormat format,
-    VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling,
+    VkImageUsageFlags usage, VkImageCreateFlags flags,
     VkImageFormatProperties* pImageFormatProperties) {
-    return mImpl->on_vkGetPhysicalDeviceImageFormatProperties(
-        pool, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
+    return mImpl->on_vkGetPhysicalDeviceImageFormatProperties(pool, snapshotInfo, physicalDevice,
+                                                              format, type, tiling, usage, flags,
+                                                              pImageFormatProperties);
 }
 VkResult VkDecoderGlobalState::on_vkGetPhysicalDeviceImageFormatProperties2(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
     VkImageFormatProperties2* pImageFormatProperties) {
     return mImpl->on_vkGetPhysicalDeviceImageFormatProperties2(
-        pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
+        pool, snapshotInfo, physicalDevice, pImageFormatInfo, pImageFormatProperties);
 }
 VkResult VkDecoderGlobalState::on_vkGetPhysicalDeviceImageFormatProperties2KHR(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
     VkImageFormatProperties2* pImageFormatProperties) {
     return mImpl->on_vkGetPhysicalDeviceImageFormatProperties2(
-        pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
+        pool, snapshotInfo, physicalDevice, pImageFormatInfo, pImageFormatProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceFormatProperties(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice, VkFormat format,
-    VkFormatProperties* pFormatProperties) {
-    mImpl->on_vkGetPhysicalDeviceFormatProperties(pool, physicalDevice, format, pFormatProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties) {
+    mImpl->on_vkGetPhysicalDeviceFormatProperties(pool, snapshotInfo, physicalDevice, format,
+                                                  pFormatProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceFormatProperties2(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice, VkFormat format,
-    VkFormatProperties2* pFormatProperties) {
-    mImpl->on_vkGetPhysicalDeviceFormatProperties2(pool, physicalDevice, format, pFormatProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties) {
+    mImpl->on_vkGetPhysicalDeviceFormatProperties2(pool, snapshotInfo, physicalDevice, format,
+                                                   pFormatProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceFormatProperties2KHR(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice, VkFormat format,
-    VkFormatProperties2* pFormatProperties) {
-    mImpl->on_vkGetPhysicalDeviceFormatProperties2(pool, physicalDevice, format, pFormatProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties) {
+    mImpl->on_vkGetPhysicalDeviceFormatProperties2(pool, snapshotInfo, physicalDevice, format,
+                                                   pFormatProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceProperties(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    VkPhysicalDeviceProperties* pProperties) {
-    mImpl->on_vkGetPhysicalDeviceProperties(pool, physicalDevice, pProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties) {
+    mImpl->on_vkGetPhysicalDeviceProperties(pool, snapshotInfo, physicalDevice, pProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceProperties2(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    VkPhysicalDeviceProperties2* pProperties) {
-    mImpl->on_vkGetPhysicalDeviceProperties2(pool, physicalDevice, pProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties) {
+    mImpl->on_vkGetPhysicalDeviceProperties2(pool, snapshotInfo, physicalDevice, pProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceQueueFamilyProperties(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties) {
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
+    VkQueueFamilyProperties* pQueueFamilyProperties) {
     mImpl->on_vkGetPhysicalDeviceQueueFamilyProperties(
-        pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+        pool, snapshotInfo, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceQueueFamilyProperties2(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
+    VkQueueFamilyProperties2* pQueueFamilyProperties) {
     mImpl->on_vkGetPhysicalDeviceQueueFamilyProperties2(
-        pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
+        pool, snapshotInfo, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
 }
 
-VkResult VkDecoderGlobalState::on_vkQueuePresentKHR(android::base::BumpPool* pool, VkQueue queue,
-                                                 const VkPresentInfoKHR* pPresentInfo) {
-    return mImpl->on_vkQueuePresentKHR(pool, queue, pPresentInfo);
+VkResult VkDecoderGlobalState::on_vkQueuePresentKHR(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
+                                                    VkQueue queue,
+                                                    const VkPresentInfoKHR* pPresentInfo) {
+    return mImpl->on_vkQueuePresentKHR(pool, snapshotInfo, queue, pPresentInfo);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceProperties2KHR(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    VkPhysicalDeviceProperties2* pProperties) {
-    mImpl->on_vkGetPhysicalDeviceProperties2(pool, physicalDevice, pProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties) {
+    mImpl->on_vkGetPhysicalDeviceProperties2(pool, snapshotInfo, physicalDevice, pProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceMemoryProperties(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
-    mImpl->on_vkGetPhysicalDeviceMemoryProperties(pool, physicalDevice, pMemoryProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
+    mImpl->on_vkGetPhysicalDeviceMemoryProperties(pool, snapshotInfo, physicalDevice,
+                                                  pMemoryProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceMemoryProperties2(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
-    mImpl->on_vkGetPhysicalDeviceMemoryProperties2(pool, physicalDevice, pMemoryProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
+    mImpl->on_vkGetPhysicalDeviceMemoryProperties2(pool, snapshotInfo, physicalDevice,
+                                                   pMemoryProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceMemoryProperties2KHR(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-    VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
-    mImpl->on_vkGetPhysicalDeviceMemoryProperties2(pool, physicalDevice, pMemoryProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
+    mImpl->on_vkGetPhysicalDeviceMemoryProperties2(pool, snapshotInfo, physicalDevice,
+                                                   pMemoryProperties);
 }
 
 VkResult VkDecoderGlobalState::on_vkEnumerateDeviceExtensionProperties(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice, const char* pLayerName,
-    uint32_t* pPropertyCount, VkExtensionProperties* pProperties) {
-    return mImpl->on_vkEnumerateDeviceExtensionProperties(pool, physicalDevice, pLayerName,
-                                                          pPropertyCount, pProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount,
+    VkExtensionProperties* pProperties) {
+    return mImpl->on_vkEnumerateDeviceExtensionProperties(pool, snapshotInfo, physicalDevice,
+                                                          pLayerName, pPropertyCount, pProperties);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateDevice(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* snapshotInfo,
                                                  VkPhysicalDevice physicalDevice,
                                                  const VkDeviceCreateInfo* pCreateInfo,
                                                  const VkAllocationCallbacks* pAllocator,
                                                  VkDevice* pDevice) {
-    return mImpl->on_vkCreateDevice(pool, physicalDevice, pCreateInfo, pAllocator, pDevice);
+    return mImpl->on_vkCreateDevice(pool, snapshotInfo, physicalDevice, pCreateInfo, pAllocator,
+                                    pDevice);
 }
 
-void VkDecoderGlobalState::on_vkGetDeviceQueue(android::base::BumpPool* pool, VkDevice device,
+void VkDecoderGlobalState::on_vkGetDeviceQueue(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                                uint32_t queueFamilyIndex, uint32_t queueIndex,
                                                VkQueue* pQueue) {
-    mImpl->on_vkGetDeviceQueue(pool, device, queueFamilyIndex, queueIndex, pQueue);
+    mImpl->on_vkGetDeviceQueue(pool, snapshotInfo, device, queueFamilyIndex, queueIndex, pQueue);
 }
 
-void VkDecoderGlobalState::on_vkGetDeviceQueue2(android::base::BumpPool* pool, VkDevice device,
+void VkDecoderGlobalState::on_vkGetDeviceQueue2(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo,
+                                                VkDevice device,
                                                 const VkDeviceQueueInfo2* pQueueInfo,
                                                 VkQueue* pQueue) {
-    mImpl->on_vkGetDeviceQueue2(pool, device, pQueueInfo, pQueue);
+    mImpl->on_vkGetDeviceQueue2(pool, snapshotInfo, device, pQueueInfo, pQueue);
 }
 
-void VkDecoderGlobalState::on_vkDestroyDevice(android::base::BumpPool* pool, VkDevice device,
+void VkDecoderGlobalState::on_vkDestroyDevice(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                               const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyDevice(pool, device, pAllocator);
+    mImpl->on_vkDestroyDevice(pool, snapshotInfo, device, pAllocator);
 }
 
-VkResult VkDecoderGlobalState::on_vkCreateBuffer(android::base::BumpPool* pool, VkDevice device,
+VkResult VkDecoderGlobalState::on_vkCreateBuffer(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* snapshotInfo,
+                                                 VkDevice device,
                                                  const VkBufferCreateInfo* pCreateInfo,
                                                  const VkAllocationCallbacks* pAllocator,
                                                  VkBuffer* pBuffer) {
-    return mImpl->on_vkCreateBuffer(pool, device, pCreateInfo, pAllocator, pBuffer);
+    return mImpl->on_vkCreateBuffer(pool, snapshotInfo, device, pCreateInfo, pAllocator, pBuffer);
 }
 
-void VkDecoderGlobalState::on_vkDestroyBuffer(android::base::BumpPool* pool, VkDevice device,
+void VkDecoderGlobalState::on_vkDestroyBuffer(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                               VkBuffer buffer,
                                               const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyBuffer(pool, device, buffer, pAllocator);
+    mImpl->on_vkDestroyBuffer(pool, snapshotInfo, device, buffer, pAllocator);
 }
 
-VkResult VkDecoderGlobalState::on_vkBindBufferMemory(android::base::BumpPool* pool, VkDevice device,
-                                                     VkBuffer buffer, VkDeviceMemory memory,
+VkResult VkDecoderGlobalState::on_vkBindBufferMemory(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
+                                                     VkDevice device, VkBuffer buffer,
+                                                     VkDeviceMemory memory,
                                                      VkDeviceSize memoryOffset) {
-    return mImpl->on_vkBindBufferMemory(pool, device, buffer, memory, memoryOffset);
+    return mImpl->on_vkBindBufferMemory(pool, snapshotInfo, device, buffer, memory, memoryOffset);
 }
 
 VkResult VkDecoderGlobalState::on_vkBindBufferMemory2(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* snapshotInfo,
                                                       VkDevice device, uint32_t bindInfoCount,
                                                       const VkBindBufferMemoryInfo* pBindInfos) {
-    return mImpl->on_vkBindBufferMemory2(pool, device, bindInfoCount, pBindInfos);
+    return mImpl->on_vkBindBufferMemory2(pool, snapshotInfo, device, bindInfoCount, pBindInfos);
 }
 
 VkResult VkDecoderGlobalState::on_vkBindBufferMemory2KHR(android::base::BumpPool* pool,
+                                                         VkSnapshotApiCallInfo* snapshotInfo,
                                                          VkDevice device, uint32_t bindInfoCount,
                                                          const VkBindBufferMemoryInfo* pBindInfos) {
-    return mImpl->on_vkBindBufferMemory2KHR(pool, device, bindInfoCount, pBindInfos);
+    return mImpl->on_vkBindBufferMemory2KHR(pool, snapshotInfo, device, bindInfoCount, pBindInfos);
 }
 
-VkResult VkDecoderGlobalState::on_vkCreateImage(android::base::BumpPool* pool, VkDevice device,
+VkResult VkDecoderGlobalState::on_vkCreateImage(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo,
+                                                VkDevice device,
                                                 const VkImageCreateInfo* pCreateInfo,
                                                 const VkAllocationCallbacks* pAllocator,
                                                 VkImage* pImage) {
-    return mImpl->on_vkCreateImage(pool, device, pCreateInfo, pAllocator, pImage);
+    return mImpl->on_vkCreateImage(pool, snapshotInfo, device, pCreateInfo, pAllocator, pImage);
 }
 
-void VkDecoderGlobalState::on_vkDestroyImage(android::base::BumpPool* pool, VkDevice device,
+void VkDecoderGlobalState::on_vkDestroyImage(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                              VkImage image,
                                              const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyImage(pool, device, image, pAllocator);
+    mImpl->on_vkDestroyImage(pool, snapshotInfo, device, image, pAllocator);
 }
 
-VkResult VkDecoderGlobalState::on_vkBindImageMemory(android::base::BumpPool* pool, VkDevice device,
-                                                    VkImage image, VkDeviceMemory memory,
+VkResult VkDecoderGlobalState::on_vkBindImageMemory(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
+                                                    VkDevice device, VkImage image,
+                                                    VkDeviceMemory memory,
                                                     VkDeviceSize memoryOffset) {
-    return mImpl->on_vkBindImageMemory(pool, device, image, memory, memoryOffset);
+    return mImpl->on_vkBindImageMemory(pool, snapshotInfo, device, image, memory, memoryOffset);
 }
 
-VkResult VkDecoderGlobalState::on_vkBindImageMemory2(android::base::BumpPool* pool, VkDevice device,
-                                                     uint32_t bindInfoCount,
+VkResult VkDecoderGlobalState::on_vkBindImageMemory2(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
+                                                     VkDevice device, uint32_t bindInfoCount,
                                                      const VkBindImageMemoryInfo* pBindInfos) {
-    return mImpl->on_vkBindImageMemory2(pool, device, bindInfoCount, pBindInfos);
+    return mImpl->on_vkBindImageMemory2(pool, snapshotInfo, device, bindInfoCount, pBindInfos);
 }
 
 VkResult VkDecoderGlobalState::on_vkBindImageMemory2KHR(android::base::BumpPool* pool,
+                                                        VkSnapshotApiCallInfo* snapshotInfo,
                                                         VkDevice device, uint32_t bindInfoCount,
                                                         const VkBindImageMemoryInfo* pBindInfos) {
-    return mImpl->on_vkBindImageMemory2(pool, device, bindInfoCount, pBindInfos);
+    return mImpl->on_vkBindImageMemory2(pool, snapshotInfo, device, bindInfoCount, pBindInfos);
 }
 
-VkResult VkDecoderGlobalState::on_vkCreateImageView(android::base::BumpPool* pool, VkDevice device,
+VkResult VkDecoderGlobalState::on_vkCreateImageView(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
+                                                    VkDevice device,
                                                     const VkImageViewCreateInfo* pCreateInfo,
                                                     const VkAllocationCallbacks* pAllocator,
                                                     VkImageView* pView) {
-    return mImpl->on_vkCreateImageView(pool, device, pCreateInfo, pAllocator, pView);
+    return mImpl->on_vkCreateImageView(pool, snapshotInfo, device, pCreateInfo, pAllocator, pView);
 }
 
-void VkDecoderGlobalState::on_vkDestroyImageView(android::base::BumpPool* pool, VkDevice device,
-                                                 VkImageView imageView,
+void VkDecoderGlobalState::on_vkDestroyImageView(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* snapshotInfo,
+                                                 VkDevice device, VkImageView imageView,
                                                  const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyImageView(pool, device, imageView, pAllocator);
+    mImpl->on_vkDestroyImageView(pool, snapshotInfo, device, imageView, pAllocator);
 }
 
-VkResult VkDecoderGlobalState::on_vkCreateSampler(android::base::BumpPool* pool, VkDevice device,
+VkResult VkDecoderGlobalState::on_vkCreateSampler(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* snapshotInfo,
+                                                  VkDevice device,
                                                   const VkSamplerCreateInfo* pCreateInfo,
                                                   const VkAllocationCallbacks* pAllocator,
                                                   VkSampler* pSampler) {
-    return mImpl->on_vkCreateSampler(pool, device, pCreateInfo, pAllocator, pSampler);
+    return mImpl->on_vkCreateSampler(pool, snapshotInfo, device, pCreateInfo, pAllocator, pSampler);
 }
 
-void VkDecoderGlobalState::on_vkDestroySampler(android::base::BumpPool* pool, VkDevice device,
+void VkDecoderGlobalState::on_vkDestroySampler(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                                VkSampler sampler,
                                                const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroySampler(pool, device, sampler, pAllocator);
+    mImpl->on_vkDestroySampler(pool, snapshotInfo, device, sampler, pAllocator);
 }
 
-VkResult VkDecoderGlobalState::on_vkCreateSemaphore(android::base::BumpPool* pool, VkDevice device,
+VkResult VkDecoderGlobalState::on_vkCreateSemaphore(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
+                                                    VkDevice device,
                                                     const VkSemaphoreCreateInfo* pCreateInfo,
                                                     const VkAllocationCallbacks* pAllocator,
                                                     VkSemaphore* pSemaphore) {
-    return mImpl->on_vkCreateSemaphore(pool, device, pCreateInfo, pAllocator, pSemaphore);
+    return mImpl->on_vkCreateSemaphore(pool, snapshotInfo, device, pCreateInfo, pAllocator,
+                                       pSemaphore);
 }
 
 VkResult VkDecoderGlobalState::on_vkImportSemaphoreFdKHR(
-    android::base::BumpPool* pool, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
     const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {
-    return mImpl->on_vkImportSemaphoreFdKHR(pool, device, pImportSemaphoreFdInfo);
+    return mImpl->on_vkImportSemaphoreFdKHR(pool, snapshotInfo, device, pImportSemaphoreFdInfo);
 }
 
 VkResult VkDecoderGlobalState::on_vkGetSemaphoreFdKHR(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* snapshotInfo,
                                                       VkDevice device,
                                                       const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
                                                       int* pFd) {
-    return mImpl->on_vkGetSemaphoreFdKHR(pool, device, pGetFdInfo, pFd);
+    return mImpl->on_vkGetSemaphoreFdKHR(pool, snapshotInfo, device, pGetFdInfo, pFd);
 }
 
 VkResult VkDecoderGlobalState::on_vkGetSemaphoreGOOGLE(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* snapshotInfo,
                                                        VkDevice device, VkSemaphore semaphore,
                                                        uint64_t syncId) {
-    return mImpl->on_vkGetSemaphoreGOOGLE(pool, device, semaphore, syncId);
+    return mImpl->on_vkGetSemaphoreGOOGLE(pool, snapshotInfo, device, semaphore, syncId);
 }
 
-void VkDecoderGlobalState::on_vkDestroySemaphore(android::base::BumpPool* pool, VkDevice device,
-                                                 VkSemaphore semaphore,
+void VkDecoderGlobalState::on_vkDestroySemaphore(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* snapshotInfo,
+                                                 VkDevice device, VkSemaphore semaphore,
                                                  const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroySemaphore(pool, device, semaphore, pAllocator);
+    mImpl->on_vkDestroySemaphore(pool, snapshotInfo, device, semaphore, pAllocator);
+}
+
+VkResult VkDecoderGlobalState::on_vkWaitSemaphores(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
+                                                   VkDevice device,
+                                                   const VkSemaphoreWaitInfo* pWaitInfo,
+                                                   uint64_t timeout) {
+    return mImpl->on_vkWaitSemaphores(pool, snapshotInfo, device, pWaitInfo, timeout);
+}
+
+VkResult VkDecoderGlobalState::on_vkSignalSemaphore(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
+                                                   VkDevice device,
+                                                   const VkSemaphoreSignalInfo* pSignalInfo) {
+    return mImpl->on_vkSignalSemaphore(pool, snapshotInfo, device, pSignalInfo);
 }
 
-VkResult VkDecoderGlobalState::on_vkCreateFence(android::base::BumpPool* pool, VkDevice device,
+VkResult VkDecoderGlobalState::on_vkCreateFence(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo,
+                                                VkDevice device,
                                                 const VkFenceCreateInfo* pCreateInfo,
                                                 const VkAllocationCallbacks* pAllocator,
                                                 VkFence* pFence) {
-    return mImpl->on_vkCreateFence(pool, device, pCreateInfo, pAllocator, pFence);
+    return mImpl->on_vkCreateFence(pool, snapshotInfo, device, pCreateInfo, pAllocator, pFence);
+}
+
+VkResult VkDecoderGlobalState::on_vkGetFenceStatus(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
+                                                   VkDevice device, VkFence fence) {
+    return mImpl->on_vkGetFenceStatus(pool, snapshotInfo, device, fence);
+}
+
+VkResult VkDecoderGlobalState::on_vkWaitForFences(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* snapshotInfo,
+                                                  VkDevice device, uint32_t fenceCount,
+                                                  const VkFence* pFences, VkBool32 waitAll,
+                                                  uint64_t timeout) {
+    return mImpl->on_vkWaitForFences(pool, snapshotInfo, device, fenceCount, pFences, waitAll,
+                                     timeout);
 }
 
-VkResult VkDecoderGlobalState::on_vkResetFences(android::base::BumpPool* pool, VkDevice device,
-                                                uint32_t fenceCount, const VkFence* pFences) {
-    return mImpl->on_vkResetFences(pool, device, fenceCount, pFences);
+VkResult VkDecoderGlobalState::on_vkResetFences(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo,
+                                                VkDevice device, uint32_t fenceCount,
+                                                const VkFence* pFences) {
+    return mImpl->on_vkResetFences(pool, snapshotInfo, device, fenceCount, pFences);
 }
 
-void VkDecoderGlobalState::on_vkDestroyFence(android::base::BumpPool* pool, VkDevice device,
+void VkDecoderGlobalState::on_vkDestroyFence(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                              VkFence fence,
                                              const VkAllocationCallbacks* pAllocator) {
-    return mImpl->on_vkDestroyFence(pool, device, fence, pAllocator);
+    return mImpl->on_vkDestroyFence(pool, snapshotInfo, device, fence, pAllocator);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateDescriptorSetLayout(
-    android::base::BumpPool* pool, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
     const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
     VkDescriptorSetLayout* pSetLayout) {
-    return mImpl->on_vkCreateDescriptorSetLayout(pool, device, pCreateInfo, pAllocator, pSetLayout);
+    return mImpl->on_vkCreateDescriptorSetLayout(pool, snapshotInfo, device, pCreateInfo,
+                                                 pAllocator, pSetLayout);
 }
 
 void VkDecoderGlobalState::on_vkDestroyDescriptorSetLayout(
-    android::base::BumpPool* pool, VkDevice device, VkDescriptorSetLayout descriptorSetLayout,
-    const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyDescriptorSetLayout(pool, device, descriptorSetLayout, pAllocator);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator) {
+    mImpl->on_vkDestroyDescriptorSetLayout(pool, snapshotInfo, device, descriptorSetLayout,
+                                           pAllocator);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateDescriptorPool(
-    android::base::BumpPool* pool, VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool) {
-    return mImpl->on_vkCreateDescriptorPool(pool, device, pCreateInfo, pAllocator, pDescriptorPool);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkDescriptorPool* pDescriptorPool) {
+    return mImpl->on_vkCreateDescriptorPool(pool, snapshotInfo, device, pCreateInfo, pAllocator,
+                                            pDescriptorPool);
 }
 
 void VkDecoderGlobalState::on_vkDestroyDescriptorPool(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* snapshotInfo,
                                                       VkDevice device,
                                                       VkDescriptorPool descriptorPool,
                                                       const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyDescriptorPool(pool, device, descriptorPool, pAllocator);
+    mImpl->on_vkDestroyDescriptorPool(pool, snapshotInfo, device, descriptorPool, pAllocator);
 }
 
 VkResult VkDecoderGlobalState::on_vkResetDescriptorPool(android::base::BumpPool* pool,
+                                                        VkSnapshotApiCallInfo* snapshotInfo,
                                                         VkDevice device,
                                                         VkDescriptorPool descriptorPool,
                                                         VkDescriptorPoolResetFlags flags) {
-    return mImpl->on_vkResetDescriptorPool(pool, device, descriptorPool, flags);
+    return mImpl->on_vkResetDescriptorPool(pool, snapshotInfo, device, descriptorPool, flags);
 }
 
 VkResult VkDecoderGlobalState::on_vkAllocateDescriptorSets(
-    android::base::BumpPool* pool, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
     const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets) {
-    return mImpl->on_vkAllocateDescriptorSets(pool, device, pAllocateInfo, pDescriptorSets);
+    return mImpl->on_vkAllocateDescriptorSets(pool, snapshotInfo, device, pAllocateInfo,
+                                              pDescriptorSets);
 }
 
 VkResult VkDecoderGlobalState::on_vkFreeDescriptorSets(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* snapshotInfo,
                                                        VkDevice device,
                                                        VkDescriptorPool descriptorPool,
                                                        uint32_t descriptorSetCount,
                                                        const VkDescriptorSet* pDescriptorSets) {
-    return mImpl->on_vkFreeDescriptorSets(pool, device, descriptorPool, descriptorSetCount,
-                                          pDescriptorSets);
+    return mImpl->on_vkFreeDescriptorSets(pool, snapshotInfo, device, descriptorPool,
+                                          descriptorSetCount, pDescriptorSets);
 }
 
-void VkDecoderGlobalState::on_vkUpdateDescriptorSets(android::base::BumpPool* pool, VkDevice device,
-                                                     uint32_t descriptorWriteCount,
+void VkDecoderGlobalState::on_vkUpdateDescriptorSets(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
+                                                     VkDevice device, uint32_t descriptorWriteCount,
                                                      const VkWriteDescriptorSet* pDescriptorWrites,
                                                      uint32_t descriptorCopyCount,
                                                      const VkCopyDescriptorSet* pDescriptorCopies) {
-    mImpl->on_vkUpdateDescriptorSets(pool, device, descriptorWriteCount, pDescriptorWrites,
-                                     descriptorCopyCount, pDescriptorCopies);
+    mImpl->on_vkUpdateDescriptorSets(pool, snapshotInfo, device, descriptorWriteCount,
+                                     pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateShaderModule(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* snapshotInfo,
                                                        VkDevice boxed_device,
                                                        const VkShaderModuleCreateInfo* pCreateInfo,
                                                        const VkAllocationCallbacks* pAllocator,
                                                        VkShaderModule* pShaderModule) {
-    return mImpl->on_vkCreateShaderModule(pool, boxed_device, pCreateInfo, pAllocator,
+    return mImpl->on_vkCreateShaderModule(pool, snapshotInfo, boxed_device, pCreateInfo, pAllocator,
                                           pShaderModule);
 }
 
 void VkDecoderGlobalState::on_vkDestroyShaderModule(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
                                                     VkDevice boxed_device,
                                                     VkShaderModule shaderModule,
                                                     const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyShaderModule(pool, boxed_device, shaderModule, pAllocator);
+    mImpl->on_vkDestroyShaderModule(pool, snapshotInfo, boxed_device, shaderModule, pAllocator);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreatePipelineCache(
-    android::base::BumpPool* pool, VkDevice boxed_device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
     const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
     VkPipelineCache* pPipelineCache) {
-    return mImpl->on_vkCreatePipelineCache(pool, boxed_device, pCreateInfo, pAllocator,
-                                           pPipelineCache);
+    return mImpl->on_vkCreatePipelineCache(pool, snapshotInfo, boxed_device, pCreateInfo,
+                                           pAllocator, pPipelineCache);
 }
 
 void VkDecoderGlobalState::on_vkDestroyPipelineCache(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
                                                      VkDevice boxed_device,
                                                      VkPipelineCache pipelineCache,
                                                      const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyPipelineCache(pool, boxed_device, pipelineCache, pAllocator);
+    mImpl->on_vkDestroyPipelineCache(pool, snapshotInfo, boxed_device, pipelineCache, pAllocator);
+}
+
+VkResult VkDecoderGlobalState::on_vkCreatePipelineLayout(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+    const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkPipelineLayout* pPipelineLayout) {
+    return mImpl->on_vkCreatePipelineLayout(pool, snapshotInfo, boxed_device, pCreateInfo,
+                                           pAllocator, pPipelineLayout);
+}
+
+void VkDecoderGlobalState::on_vkDestroyPipelineLayout(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
+                                                     VkDevice boxed_device,
+                                                     VkPipelineLayout pipelineLayout,
+                                                     const VkAllocationCallbacks* pAllocator) {
+    mImpl->on_vkDestroyPipelineLayout(pool, snapshotInfo, boxed_device, pipelineLayout, pAllocator);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateGraphicsPipelines(
-    android::base::BumpPool* pool, VkDevice boxed_device, VkPipelineCache pipelineCache,
-    uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos,
-    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
-    return mImpl->on_vkCreateGraphicsPipelines(pool, boxed_device, pipelineCache, createInfoCount,
-                                               pCreateInfos, pAllocator, pPipelines);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+    VkPipelineCache pipelineCache, uint32_t createInfoCount,
+    const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator,
+    VkPipeline* pPipelines) {
+    return mImpl->on_vkCreateGraphicsPipelines(pool, snapshotInfo, boxed_device, pipelineCache,
+                                               createInfoCount, pCreateInfos, pAllocator,
+                                               pPipelines);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateComputePipelines(
-    android::base::BumpPool* pool, VkDevice boxed_device, VkPipelineCache pipelineCache,
-    uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos,
-    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
-    return mImpl->on_vkCreateComputePipelines(pool, boxed_device, pipelineCache, createInfoCount,
-                                               pCreateInfos, pAllocator, pPipelines);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+    VkPipelineCache pipelineCache, uint32_t createInfoCount,
+    const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator,
+    VkPipeline* pPipelines) {
+    return mImpl->on_vkCreateComputePipelines(pool, snapshotInfo, boxed_device, pipelineCache,
+                                              createInfoCount, pCreateInfos, pAllocator,
+                                              pPipelines);
 }
 
 void VkDecoderGlobalState::on_vkDestroyPipeline(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo,
                                                 VkDevice boxed_device, VkPipeline pipeline,
                                                 const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyPipeline(pool, boxed_device, pipeline, pAllocator);
+    mImpl->on_vkDestroyPipeline(pool, snapshotInfo, boxed_device, pipeline, pAllocator);
 }
 
 void VkDecoderGlobalState::on_vkCmdCopyBufferToImage(
-    android::base::BumpPool* pool, VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
-    VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount,
-    const VkBufferImageCopy* pRegions, const VkDecoderContext& context) {
-    mImpl->on_vkCmdCopyBufferToImage(pool, commandBuffer, srcBuffer, dstImage, dstImageLayout,
-                                     regionCount, pRegions, context);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
+    VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions,
+    const VkDecoderContext& context) {
+    mImpl->on_vkCmdCopyBufferToImage(pool, snapshotInfo, commandBuffer, srcBuffer, dstImage,
+                                     dstImageLayout, regionCount, pRegions, context);
 }
 
 void VkDecoderGlobalState::on_vkCmdCopyImage(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* snapshotInfo,
                                              VkCommandBuffer commandBuffer, VkImage srcImage,
                                              VkImageLayout srcImageLayout, VkImage dstImage,
                                              VkImageLayout dstImageLayout, uint32_t regionCount,
                                              const VkImageCopy* pRegions) {
-    mImpl->on_vkCmdCopyImage(pool, commandBuffer, srcImage, srcImageLayout, dstImage,
+    mImpl->on_vkCmdCopyImage(pool, snapshotInfo, commandBuffer, srcImage, srcImageLayout, dstImage,
                              dstImageLayout, regionCount, pRegions);
 }
 void VkDecoderGlobalState::on_vkCmdCopyImageToBuffer(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
                                                      VkCommandBuffer commandBuffer,
                                                      VkImage srcImage, VkImageLayout srcImageLayout,
                                                      VkBuffer dstBuffer, uint32_t regionCount,
                                                      const VkBufferImageCopy* pRegions) {
-    mImpl->on_vkCmdCopyImageToBuffer(pool, commandBuffer, srcImage, srcImageLayout, dstBuffer,
-                                     regionCount, pRegions);
+    mImpl->on_vkCmdCopyImageToBuffer(pool, snapshotInfo, commandBuffer, srcImage, srcImageLayout,
+                                     dstBuffer, regionCount, pRegions);
 }
 
-void VkDecoderGlobalState::on_vkCmdCopyBufferToImage2(android::base::BumpPool* pool,
-                                VkCommandBuffer commandBuffer,
-                                const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo,
-                                const VkDecoderContext& context) {
-    mImpl->on_vkCmdCopyBufferToImage2(pool, commandBuffer, pCopyBufferToImageInfo, context);
+void VkDecoderGlobalState::on_vkCmdCopyBufferToImage2(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo,
+    const VkDecoderContext& context) {
+    mImpl->on_vkCmdCopyBufferToImage2(pool, snapshotInfo, commandBuffer, pCopyBufferToImageInfo,
+                                      context);
 }
 
 void VkDecoderGlobalState::on_vkCmdCopyImage2(android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer,
-    const VkCopyImageInfo2* pCopyImageInfo) {
-    mImpl->on_vkCmdCopyImage2(pool, commandBuffer, pCopyImageInfo);
+                                              VkSnapshotApiCallInfo* snapshotInfo,
+                                              VkCommandBuffer commandBuffer,
+                                              const VkCopyImageInfo2* pCopyImageInfo) {
+    mImpl->on_vkCmdCopyImage2(pool, snapshotInfo, commandBuffer, pCopyImageInfo);
 }
 
-void VkDecoderGlobalState::on_vkCmdCopyImageToBuffer2(android::base::BumpPool* pool,
-                                VkCommandBuffer commandBuffer,
-                                const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
-    mImpl->on_vkCmdCopyImageToBuffer2(pool, commandBuffer, pCopyImageToBufferInfo);
+void VkDecoderGlobalState::on_vkCmdCopyImageToBuffer2(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
+    mImpl->on_vkCmdCopyImageToBuffer2(pool, snapshotInfo, commandBuffer, pCopyImageToBufferInfo);
 }
 
-void VkDecoderGlobalState::on_vkCmdCopyBufferToImage2KHR(android::base::BumpPool* pool,
-                                VkCommandBuffer commandBuffer,
-                                const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo,
-                                const VkDecoderContext& context) {
-    mImpl->on_vkCmdCopyBufferToImage2KHR(pool, commandBuffer, pCopyBufferToImageInfo, context);
+void VkDecoderGlobalState::on_vkCmdCopyBufferToImage2KHR(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo,
+    const VkDecoderContext& context) {
+    mImpl->on_vkCmdCopyBufferToImage2KHR(pool, snapshotInfo, commandBuffer, pCopyBufferToImageInfo,
+                                         context);
 }
 
 void VkDecoderGlobalState::on_vkCmdCopyImage2KHR(android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer,
-    const VkCopyImageInfo2KHR* pCopyImageInfo) {
-    mImpl->on_vkCmdCopyImage2KHR(pool, commandBuffer, pCopyImageInfo);
+                                                 VkSnapshotApiCallInfo* snapshotInfo,
+                                                 VkCommandBuffer commandBuffer,
+                                                 const VkCopyImageInfo2KHR* pCopyImageInfo) {
+    mImpl->on_vkCmdCopyImage2KHR(pool, snapshotInfo, commandBuffer, pCopyImageInfo);
 }
 
-void VkDecoderGlobalState::on_vkCmdCopyImageToBuffer2KHR(android::base::BumpPool* pool,
-                                VkCommandBuffer commandBuffer,
-                                const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo) {
-    mImpl->on_vkCmdCopyImageToBuffer2KHR(pool, commandBuffer, pCopyImageToBufferInfo);
+void VkDecoderGlobalState::on_vkCmdCopyImageToBuffer2KHR(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo) {
+    mImpl->on_vkCmdCopyImageToBuffer2KHR(pool, snapshotInfo, commandBuffer, pCopyImageToBufferInfo);
 }
 
 void VkDecoderGlobalState::on_vkGetImageMemoryRequirements(
-    android::base::BumpPool* pool, VkDevice device, VkImage image,
-    VkMemoryRequirements* pMemoryRequirements) {
-    mImpl->on_vkGetImageMemoryRequirements(pool, device, image, pMemoryRequirements);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkImage image, VkMemoryRequirements* pMemoryRequirements) {
+    mImpl->on_vkGetImageMemoryRequirements(pool, snapshotInfo, device, image, pMemoryRequirements);
 }
 
 void VkDecoderGlobalState::on_vkGetImageMemoryRequirements2(
-    android::base::BumpPool* pool, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
-    VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->on_vkGetImageMemoryRequirements2(pool, device, pInfo, pMemoryRequirements);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
+    mImpl->on_vkGetImageMemoryRequirements2(pool, snapshotInfo, device, pInfo, pMemoryRequirements);
 }
 
 void VkDecoderGlobalState::on_vkGetImageMemoryRequirements2KHR(
-    android::base::BumpPool* pool, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
-    VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->on_vkGetImageMemoryRequirements2(pool, device, pInfo, pMemoryRequirements);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
+    mImpl->on_vkGetImageMemoryRequirements2(pool, snapshotInfo, device, pInfo, pMemoryRequirements);
 }
 
 void VkDecoderGlobalState::on_vkGetBufferMemoryRequirements(
-    android::base::BumpPool* pool, VkDevice device, VkBuffer buffer,
-    VkMemoryRequirements* pMemoryRequirements) {
-    mImpl->on_vkGetBufferMemoryRequirements(pool, device, buffer, pMemoryRequirements);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements) {
+    mImpl->on_vkGetBufferMemoryRequirements(pool, snapshotInfo, device, buffer,
+                                            pMemoryRequirements);
 }
 
 void VkDecoderGlobalState::on_vkGetBufferMemoryRequirements2(
-    android::base::BumpPool* pool, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
-    VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->on_vkGetBufferMemoryRequirements2(pool, device, pInfo, pMemoryRequirements);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
+    mImpl->on_vkGetBufferMemoryRequirements2(pool, snapshotInfo, device, pInfo,
+                                             pMemoryRequirements);
 }
 
 void VkDecoderGlobalState::on_vkGetBufferMemoryRequirements2KHR(
-    android::base::BumpPool* pool, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
-    VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->on_vkGetBufferMemoryRequirements2(pool, device, pInfo, pMemoryRequirements);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
+    mImpl->on_vkGetBufferMemoryRequirements2(pool, snapshotInfo, device, pInfo,
+                                             pMemoryRequirements);
 }
 
 void VkDecoderGlobalState::on_vkCmdPipelineBarrier(
-    android::base::BumpPool* pool, VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
     VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
     uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
     uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
     uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
-    mImpl->on_vkCmdPipelineBarrier(pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags,
-                                   memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount,
-                                   pBufferMemoryBarriers, imageMemoryBarrierCount,
-                                   pImageMemoryBarriers);
+    mImpl->on_vkCmdPipelineBarrier(pool, snapshotInfo, commandBuffer, srcStageMask, dstStageMask,
+                                   dependencyFlags, memoryBarrierCount, pMemoryBarriers,
+                                   bufferMemoryBarrierCount, pBufferMemoryBarriers,
+                                   imageMemoryBarrierCount, pImageMemoryBarriers);
 }
 
 void VkDecoderGlobalState::on_vkCmdPipelineBarrier2(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
                                                     VkCommandBuffer commandBuffer,
                                                     const VkDependencyInfo* pDependencyInfo) {
-    mImpl->on_vkCmdPipelineBarrier2(pool, commandBuffer, pDependencyInfo);
+    mImpl->on_vkCmdPipelineBarrier2(pool, snapshotInfo, commandBuffer, pDependencyInfo);
 }
 
-VkResult VkDecoderGlobalState::on_vkAllocateMemory(android::base::BumpPool* pool, VkDevice device,
+VkResult VkDecoderGlobalState::on_vkAllocateMemory(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
+                                                   VkDevice device,
                                                    const VkMemoryAllocateInfo* pAllocateInfo,
                                                    const VkAllocationCallbacks* pAllocator,
                                                    VkDeviceMemory* pMemory) {
-    return mImpl->on_vkAllocateMemory(pool, device, pAllocateInfo, pAllocator, pMemory);
+    return mImpl->on_vkAllocateMemory(pool, snapshotInfo, device, pAllocateInfo, pAllocator,
+                                      pMemory);
 }
 
-void VkDecoderGlobalState::on_vkFreeMemory(android::base::BumpPool* pool, VkDevice device,
+void VkDecoderGlobalState::on_vkFreeMemory(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                            VkDeviceMemory memory,
                                            const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkFreeMemory(pool, device, memory, pAllocator);
+    mImpl->on_vkFreeMemory(pool, snapshotInfo, device, memory, pAllocator);
 }
 
-VkResult VkDecoderGlobalState::on_vkMapMemory(android::base::BumpPool* pool, VkDevice device,
+VkResult VkDecoderGlobalState::on_vkMapMemory(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                               VkDeviceMemory memory, VkDeviceSize offset,
                                               VkDeviceSize size, VkMemoryMapFlags flags,
                                               void** ppData) {
-    return mImpl->on_vkMapMemory(pool, device, memory, offset, size, flags, ppData);
+    return mImpl->on_vkMapMemory(pool, snapshotInfo, device, memory, offset, size, flags, ppData);
 }
 
-void VkDecoderGlobalState::on_vkUnmapMemory(android::base::BumpPool* pool, VkDevice device,
+void VkDecoderGlobalState::on_vkUnmapMemory(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                             VkDeviceMemory memory) {
-    mImpl->on_vkUnmapMemory(pool, device, memory);
+    mImpl->on_vkUnmapMemory(pool, snapshotInfo, device, memory);
 }
 
 uint8_t* VkDecoderGlobalState::getMappedHostPointer(VkDeviceMemory memory) {
@@ -9686,236 +9853,261 @@ VkDecoderGlobalState::HostFeatureSupport VkDecoderGlobalState::getHostFeatureSup
 }
 
 // VK_ANDROID_native_buffer
-VkResult VkDecoderGlobalState::on_vkGetSwapchainGrallocUsageANDROID(android::base::BumpPool* pool,
-                                                                    VkDevice device,
-                                                                    VkFormat format,
-                                                                    VkImageUsageFlags imageUsage,
-                                                                    int* grallocUsage) {
-    return mImpl->on_vkGetSwapchainGrallocUsageANDROID(pool, device, format, imageUsage,
-                                                       grallocUsage);
+VkResult VkDecoderGlobalState::on_vkGetSwapchainGrallocUsageANDROID(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkFormat format, VkImageUsageFlags imageUsage, int* grallocUsage) {
+    return mImpl->on_vkGetSwapchainGrallocUsageANDROID(pool, snapshotInfo, device, format,
+                                                       imageUsage, grallocUsage);
 }
 
 VkResult VkDecoderGlobalState::on_vkGetSwapchainGrallocUsage2ANDROID(
-    android::base::BumpPool* pool, VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkFormat format, VkImageUsageFlags imageUsage,
     VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
     uint64_t* grallocProducerUsage) {
-    return mImpl->on_vkGetSwapchainGrallocUsage2ANDROID(pool, device, format, imageUsage,
-                                                        swapchainImageUsage, grallocConsumerUsage,
-                                                        grallocProducerUsage);
+    return mImpl->on_vkGetSwapchainGrallocUsage2ANDROID(pool, snapshotInfo, device, format,
+                                                        imageUsage, swapchainImageUsage,
+                                                        grallocConsumerUsage, grallocProducerUsage);
 }
 
 VkResult VkDecoderGlobalState::on_vkAcquireImageANDROID(android::base::BumpPool* pool,
+                                                        VkSnapshotApiCallInfo* snapshotInfo,
                                                         VkDevice device, VkImage image,
                                                         int nativeFenceFd, VkSemaphore semaphore,
                                                         VkFence fence) {
-    return mImpl->on_vkAcquireImageANDROID(pool, device, image, nativeFenceFd, semaphore, fence);
+    return mImpl->on_vkAcquireImageANDROID(pool, snapshotInfo, device, image, nativeFenceFd,
+                                           semaphore, fence);
 }
 
 VkResult VkDecoderGlobalState::on_vkQueueSignalReleaseImageANDROID(
-    android::base::BumpPool* pool, VkQueue queue, uint32_t waitSemaphoreCount,
-    const VkSemaphore* pWaitSemaphores, VkImage image, int* pNativeFenceFd) {
-    return mImpl->on_vkQueueSignalReleaseImageANDROID(pool, queue, waitSemaphoreCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
+    uint32_t waitSemaphoreCount, const VkSemaphore* pWaitSemaphores, VkImage image,
+    int* pNativeFenceFd) {
+    return mImpl->on_vkQueueSignalReleaseImageANDROID(pool, snapshotInfo, queue, waitSemaphoreCount,
                                                       pWaitSemaphores, image, pNativeFenceFd);
 }
 
 // VK_GOOGLE_gfxstream
-VkResult VkDecoderGlobalState::on_vkMapMemoryIntoAddressSpaceGOOGLE(android::base::BumpPool* pool,
-                                                                    VkDevice device,
-                                                                    VkDeviceMemory memory,
-                                                                    uint64_t* pAddress) {
-    return mImpl->on_vkMapMemoryIntoAddressSpaceGOOGLE(pool, device, memory, pAddress);
+VkResult VkDecoderGlobalState::on_vkMapMemoryIntoAddressSpaceGOOGLE(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkDeviceMemory memory, uint64_t* pAddress) {
+    return mImpl->on_vkMapMemoryIntoAddressSpaceGOOGLE(pool, snapshotInfo, device, memory,
+                                                       pAddress);
 }
 
 VkResult VkDecoderGlobalState::on_vkGetMemoryHostAddressInfoGOOGLE(
-    android::base::BumpPool* pool, VkDevice device, VkDeviceMemory memory, uint64_t* pAddress,
-    uint64_t* pSize, uint64_t* pHostmemId) {
-    return mImpl->on_vkGetMemoryHostAddressInfoGOOGLE(pool, device, memory, pAddress, pSize,
-                                                      pHostmemId);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkDeviceMemory memory, uint64_t* pAddress, uint64_t* pSize, uint64_t* pHostmemId) {
+    return mImpl->on_vkGetMemoryHostAddressInfoGOOGLE(pool, snapshotInfo, device, memory, pAddress,
+                                                      pSize, pHostmemId);
 }
 
-VkResult VkDecoderGlobalState::on_vkGetBlobGOOGLE(android::base::BumpPool* pool, VkDevice device,
-                                                  VkDeviceMemory memory) {
-    return mImpl->on_vkGetBlobGOOGLE(pool, device, memory);
+VkResult VkDecoderGlobalState::on_vkGetBlobGOOGLE(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* snapshotInfo,
+                                                  VkDevice device, VkDeviceMemory memory) {
+    return mImpl->on_vkGetBlobGOOGLE(pool, snapshotInfo, device, memory);
 }
 
 VkResult VkDecoderGlobalState::on_vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool,
+                                                         VkSnapshotApiCallInfo* snapshotInfo,
                                                          VkDevice device, VkDeviceMemory memory,
                                                          const VkAllocationCallbacks* pAllocator) {
-    return mImpl->on_vkFreeMemorySyncGOOGLE(pool, device, memory, pAllocator);
+    return mImpl->on_vkFreeMemorySyncGOOGLE(pool, snapshotInfo, device, memory, pAllocator);
 }
 
 VkResult VkDecoderGlobalState::on_vkAllocateCommandBuffers(
-    android::base::BumpPool* pool, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
     const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers) {
-    return mImpl->on_vkAllocateCommandBuffers(pool, device, pAllocateInfo, pCommandBuffers);
+    return mImpl->on_vkAllocateCommandBuffers(pool, snapshotInfo, device, pAllocateInfo,
+                                              pCommandBuffers);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateCommandPool(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* snapshotInfo,
                                                       VkDevice device,
                                                       const VkCommandPoolCreateInfo* pCreateInfo,
                                                       const VkAllocationCallbacks* pAllocator,
                                                       VkCommandPool* pCommandPool) {
-    return mImpl->on_vkCreateCommandPool(pool, device, pCreateInfo, pAllocator, pCommandPool);
+    return mImpl->on_vkCreateCommandPool(pool, snapshotInfo, device, pCreateInfo, pAllocator,
+                                         pCommandPool);
 }
 
-void VkDecoderGlobalState::on_vkDestroyCommandPool(android::base::BumpPool* pool, VkDevice device,
-                                                   VkCommandPool commandPool,
+void VkDecoderGlobalState::on_vkDestroyCommandPool(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
+                                                   VkDevice device, VkCommandPool commandPool,
                                                    const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyCommandPool(pool, device, commandPool, pAllocator);
+    mImpl->on_vkDestroyCommandPool(pool, snapshotInfo, device, commandPool, pAllocator);
 }
 
-VkResult VkDecoderGlobalState::on_vkResetCommandPool(android::base::BumpPool* pool, VkDevice device,
-                                                     VkCommandPool commandPool,
+VkResult VkDecoderGlobalState::on_vkResetCommandPool(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
+                                                     VkDevice device, VkCommandPool commandPool,
                                                      VkCommandPoolResetFlags flags) {
-    return mImpl->on_vkResetCommandPool(pool, device, commandPool, flags);
+    return mImpl->on_vkResetCommandPool(pool, snapshotInfo, device, commandPool, flags);
 }
 
 void VkDecoderGlobalState::on_vkCmdExecuteCommands(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
                                                    VkCommandBuffer commandBuffer,
                                                    uint32_t commandBufferCount,
                                                    const VkCommandBuffer* pCommandBuffers) {
-    return mImpl->on_vkCmdExecuteCommands(pool, commandBuffer, commandBufferCount, pCommandBuffers);
+    return mImpl->on_vkCmdExecuteCommands(pool, snapshotInfo, commandBuffer, commandBufferCount,
+                                          pCommandBuffers);
 }
 
-VkResult VkDecoderGlobalState::on_vkQueueSubmit(android::base::BumpPool* pool, VkQueue queue,
+VkResult VkDecoderGlobalState::on_vkQueueSubmit(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                                 uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                                 VkFence fence) {
-    return mImpl->on_vkQueueSubmit(pool, queue, submitCount, pSubmits, fence);
+    return mImpl->on_vkQueueSubmit(pool, snapshotInfo, queue, submitCount, pSubmits, fence);
 }
 
-VkResult VkDecoderGlobalState::on_vkQueueSubmit2(android::base::BumpPool* pool, VkQueue queue,
+VkResult VkDecoderGlobalState::on_vkQueueSubmit2(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                                  uint32_t submitCount,
                                                  const VkSubmitInfo2* pSubmits, VkFence fence) {
-    return mImpl->on_vkQueueSubmit(pool, queue, submitCount, pSubmits, fence);
+    return mImpl->on_vkQueueSubmit(pool, snapshotInfo, queue, submitCount, pSubmits, fence);
 }
 
-VkResult VkDecoderGlobalState::on_vkQueueWaitIdle(android::base::BumpPool* pool, VkQueue queue) {
-    return mImpl->on_vkQueueWaitIdle(pool, queue);
+VkResult VkDecoderGlobalState::on_vkQueueWaitIdle(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* snapshotInfo,
+                                                  VkQueue queue) {
+    return mImpl->on_vkQueueWaitIdle(pool, snapshotInfo, queue);
 }
 
 VkResult VkDecoderGlobalState::on_vkResetCommandBuffer(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* snapshotInfo,
                                                        VkCommandBuffer commandBuffer,
                                                        VkCommandBufferResetFlags flags) {
-    return mImpl->on_vkResetCommandBuffer(pool, commandBuffer, flags);
+    return mImpl->on_vkResetCommandBuffer(pool, snapshotInfo, commandBuffer, flags);
 }
 
-void VkDecoderGlobalState::on_vkFreeCommandBuffers(android::base::BumpPool* pool, VkDevice device,
-                                                   VkCommandPool commandPool,
+void VkDecoderGlobalState::on_vkFreeCommandBuffers(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
+                                                   VkDevice device, VkCommandPool commandPool,
                                                    uint32_t commandBufferCount,
                                                    const VkCommandBuffer* pCommandBuffers) {
-    return mImpl->on_vkFreeCommandBuffers(pool, device, commandPool, commandBufferCount,
-                                          pCommandBuffers);
+    return mImpl->on_vkFreeCommandBuffers(pool, snapshotInfo, device, commandPool,
+                                          commandBufferCount, pCommandBuffers);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceExternalSemaphoreProperties(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice,
     const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
     VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
     return mImpl->on_vkGetPhysicalDeviceExternalSemaphoreProperties(
-        pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
+        pool, snapshotInfo, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
 }
 
 void VkDecoderGlobalState::on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
-    android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkPhysicalDevice physicalDevice,
     const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
     VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
     return mImpl->on_vkGetPhysicalDeviceExternalSemaphoreProperties(
-        pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
+        pool, snapshotInfo, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
 }
 
 // Descriptor update templates
 VkResult VkDecoderGlobalState::on_vkCreateDescriptorUpdateTemplate(
-    android::base::BumpPool* pool, VkDevice boxed_device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
     const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
     const VkAllocationCallbacks* pAllocator,
     VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
-    return mImpl->on_vkCreateDescriptorUpdateTemplate(pool, boxed_device, pCreateInfo, pAllocator,
-                                                      pDescriptorUpdateTemplate);
+    return mImpl->on_vkCreateDescriptorUpdateTemplate(pool, snapshotInfo, boxed_device, pCreateInfo,
+                                                      pAllocator, pDescriptorUpdateTemplate);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateDescriptorUpdateTemplateKHR(
-    android::base::BumpPool* pool, VkDevice boxed_device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
     const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
     const VkAllocationCallbacks* pAllocator,
     VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
-    return mImpl->on_vkCreateDescriptorUpdateTemplateKHR(pool, boxed_device, pCreateInfo,
-                                                         pAllocator, pDescriptorUpdateTemplate);
+    return mImpl->on_vkCreateDescriptorUpdateTemplateKHR(
+        pool, snapshotInfo, boxed_device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
 }
 
 void VkDecoderGlobalState::on_vkDestroyDescriptorUpdateTemplate(
-    android::base::BumpPool* pool, VkDevice boxed_device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
     VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyDescriptorUpdateTemplate(pool, boxed_device, descriptorUpdateTemplate,
-                                                pAllocator);
+    mImpl->on_vkDestroyDescriptorUpdateTemplate(pool, snapshotInfo, boxed_device,
+                                                descriptorUpdateTemplate, pAllocator);
 }
 
 void VkDecoderGlobalState::on_vkDestroyDescriptorUpdateTemplateKHR(
-    android::base::BumpPool* pool, VkDevice boxed_device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
     VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyDescriptorUpdateTemplateKHR(pool, boxed_device, descriptorUpdateTemplate,
-                                                   pAllocator);
+    mImpl->on_vkDestroyDescriptorUpdateTemplateKHR(pool, snapshotInfo, boxed_device,
+                                                   descriptorUpdateTemplate, pAllocator);
 }
 
 void VkDecoderGlobalState::on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-    android::base::BumpPool* pool, VkDevice boxed_device, VkDescriptorSet descriptorSet,
-    VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-    uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
-    const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
-    const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
-    const VkBufferView* pBufferViews) {
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+    VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+    uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
+    const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
+    const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
+    const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews) {
     mImpl->on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-        pool, boxed_device, descriptorSet, descriptorUpdateTemplate, imageInfoCount,
+        pool, snapshotInfo, boxed_device, descriptorSet, descriptorUpdateTemplate, imageInfoCount,
         bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices,
         pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews);
 }
 
 void VkDecoderGlobalState::on_vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-    android::base::BumpPool* pool, VkDevice boxed_device, VkDescriptorSet descriptorSet,
-    VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-    uint32_t bufferInfoCount, uint32_t bufferViewCount, uint32_t inlineUniformBlockCount,
-    const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
-    const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
-    const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews,
-    const uint8_t* pInlineUniformBlockData) {
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+    VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+    uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
+    uint32_t inlineUniformBlockCount, const uint32_t* pImageInfoEntryIndices,
+    const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
+    const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
+    const VkBufferView* pBufferViews, const uint8_t* pInlineUniformBlockData) {
     mImpl->on_vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-        pool, boxed_device, descriptorSet, descriptorUpdateTemplate, imageInfoCount,
+        pool, snapshotInfo, boxed_device, descriptorSet, descriptorUpdateTemplate, imageInfoCount,
         bufferInfoCount, bufferViewCount, inlineUniformBlockCount, pImageInfoEntryIndices,
         pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews,
         pInlineUniformBlockData);
 }
 
 VkResult VkDecoderGlobalState::on_vkBeginCommandBuffer(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* snapshotInfo,
                                                        VkCommandBuffer commandBuffer,
                                                        const VkCommandBufferBeginInfo* pBeginInfo,
                                                        const VkDecoderContext& context) {
-    return mImpl->on_vkBeginCommandBuffer(pool, commandBuffer, pBeginInfo, context);
+    return mImpl->on_vkBeginCommandBuffer(pool, snapshotInfo, commandBuffer, pBeginInfo, context);
 }
 
 void VkDecoderGlobalState::on_vkBeginCommandBufferAsyncGOOGLE(
-    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-    const VkCommandBufferBeginInfo* pBeginInfo, const VkDecoderContext& context) {
-    mImpl->on_vkBeginCommandBuffer(pool, commandBuffer, pBeginInfo, context);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo,
+    const VkDecoderContext& context) {
+    mImpl->on_vkBeginCommandBuffer(pool, snapshotInfo, commandBuffer, pBeginInfo, context);
 }
 
 VkResult VkDecoderGlobalState::on_vkEndCommandBuffer(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
                                                      VkCommandBuffer commandBuffer,
                                                      const VkDecoderContext& context) {
-    return mImpl->on_vkEndCommandBuffer(pool, commandBuffer, context);
+    return mImpl->on_vkEndCommandBuffer(pool, snapshotInfo, commandBuffer, context);
 }
 
 void VkDecoderGlobalState::on_vkEndCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                                            VkSnapshotApiCallInfo* snapshotInfo,
                                                             VkCommandBuffer commandBuffer,
                                                             const VkDecoderContext& context) {
-    mImpl->on_vkEndCommandBufferAsyncGOOGLE(pool, commandBuffer, context);
+    mImpl->on_vkEndCommandBufferAsyncGOOGLE(pool, snapshotInfo, commandBuffer, context);
 }
 
 void VkDecoderGlobalState::on_vkResetCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                                              VkSnapshotApiCallInfo* snapshotInfo,
                                                               VkCommandBuffer commandBuffer,
                                                               VkCommandBufferResetFlags flags) {
-    mImpl->on_vkResetCommandBufferAsyncGOOGLE(pool, commandBuffer, flags);
+    mImpl->on_vkResetCommandBufferAsyncGOOGLE(pool, snapshotInfo, commandBuffer, flags);
 }
 
 void VkDecoderGlobalState::on_vkCommandBufferHostSyncGOOGLE(android::base::BumpPool* pool,
+                                                            VkSnapshotApiCallInfo* snapshotInfo,
                                                             VkCommandBuffer commandBuffer,
                                                             uint32_t needHostSync,
                                                             uint32_t sequenceNumber) {
@@ -9923,143 +10115,161 @@ void VkDecoderGlobalState::on_vkCommandBufferHostSyncGOOGLE(android::base::BumpP
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateImageWithRequirementsGOOGLE(
-    android::base::BumpPool* pool, VkDevice device, const VkImageCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkImage* pImage,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage,
     VkMemoryRequirements* pMemoryRequirements) {
-    return mImpl->on_vkCreateImageWithRequirementsGOOGLE(pool, device, pCreateInfo, pAllocator,
-                                                         pImage, pMemoryRequirements);
+    return mImpl->on_vkCreateImageWithRequirementsGOOGLE(pool, snapshotInfo, device, pCreateInfo,
+                                                         pAllocator, pImage, pMemoryRequirements);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateBufferWithRequirementsGOOGLE(
-    android::base::BumpPool* pool, VkDevice device, const VkBufferCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer,
-    VkMemoryRequirements* pMemoryRequirements) {
-    return mImpl->on_vkCreateBufferWithRequirementsGOOGLE(pool, device, pCreateInfo, pAllocator,
-                                                          pBuffer, pMemoryRequirements);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkBuffer* pBuffer, VkMemoryRequirements* pMemoryRequirements) {
+    return mImpl->on_vkCreateBufferWithRequirementsGOOGLE(pool, snapshotInfo, device, pCreateInfo,
+                                                          pAllocator, pBuffer, pMemoryRequirements);
 }
 
 void VkDecoderGlobalState::on_vkCmdBindPipeline(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo,
                                                 VkCommandBuffer commandBuffer,
                                                 VkPipelineBindPoint pipelineBindPoint,
                                                 VkPipeline pipeline) {
-    mImpl->on_vkCmdBindPipeline(pool, commandBuffer, pipelineBindPoint, pipeline);
+    mImpl->on_vkCmdBindPipeline(pool, snapshotInfo, commandBuffer, pipelineBindPoint, pipeline);
 }
 
 void VkDecoderGlobalState::on_vkCmdBindDescriptorSets(
-    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-    VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet,
-    uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
+    uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets,
     uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets) {
-    mImpl->on_vkCmdBindDescriptorSets(pool, commandBuffer, pipelineBindPoint, layout, firstSet,
-                                      descriptorSetCount, pDescriptorSets, dynamicOffsetCount,
-                                      pDynamicOffsets);
+    mImpl->on_vkCmdBindDescriptorSets(pool, snapshotInfo, commandBuffer, pipelineBindPoint, layout,
+                                      firstSet, descriptorSetCount, pDescriptorSets,
+                                      dynamicOffsetCount, pDynamicOffsets);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateRenderPass(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
                                                      VkDevice boxed_device,
                                                      const VkRenderPassCreateInfo* pCreateInfo,
                                                      const VkAllocationCallbacks* pAllocator,
                                                      VkRenderPass* pRenderPass) {
-    return mImpl->on_vkCreateRenderPass(pool, boxed_device, pCreateInfo, pAllocator, pRenderPass);
+    return mImpl->on_vkCreateRenderPass(pool, snapshotInfo, boxed_device, pCreateInfo, pAllocator,
+                                        pRenderPass);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateRenderPass2(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* snapshotInfo,
                                                       VkDevice boxed_device,
                                                       const VkRenderPassCreateInfo2* pCreateInfo,
                                                       const VkAllocationCallbacks* pAllocator,
                                                       VkRenderPass* pRenderPass) {
-    return mImpl->on_vkCreateRenderPass2(pool, boxed_device, pCreateInfo, pAllocator, pRenderPass);
+    return mImpl->on_vkCreateRenderPass2(pool, snapshotInfo, boxed_device, pCreateInfo, pAllocator,
+                                         pRenderPass);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateRenderPass2KHR(
-    android::base::BumpPool* pool, VkDevice boxed_device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
     const VkRenderPassCreateInfo2KHR* pCreateInfo, const VkAllocationCallbacks* pAllocator,
     VkRenderPass* pRenderPass) {
-    return mImpl->on_vkCreateRenderPass2(pool, boxed_device, pCreateInfo, pAllocator, pRenderPass);
+    return mImpl->on_vkCreateRenderPass2(pool, snapshotInfo, boxed_device, pCreateInfo, pAllocator,
+                                         pRenderPass);
 }
 
 void VkDecoderGlobalState::on_vkDestroyRenderPass(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* snapshotInfo,
                                                   VkDevice boxed_device, VkRenderPass renderPass,
                                                   const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyRenderPass(pool, boxed_device, renderPass, pAllocator);
+    mImpl->on_vkDestroyRenderPass(pool, snapshotInfo, boxed_device, renderPass, pAllocator);
 }
 
 void VkDecoderGlobalState::on_vkCmdBeginRenderPass(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
                                                    VkCommandBuffer commandBuffer,
                                                    const VkRenderPassBeginInfo* pRenderPassBegin,
                                                    VkSubpassContents contents) {
-    return mImpl->on_vkCmdBeginRenderPass(pool, commandBuffer, pRenderPassBegin, contents);
+    return mImpl->on_vkCmdBeginRenderPass(pool, snapshotInfo, commandBuffer, pRenderPassBegin,
+                                          contents);
 }
 
 void VkDecoderGlobalState::on_vkCmdBeginRenderPass2(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
                                                     VkCommandBuffer commandBuffer,
                                                     const VkRenderPassBeginInfo* pRenderPassBegin,
                                                     const VkSubpassBeginInfo* pSubpassBeginInfo) {
-    return mImpl->on_vkCmdBeginRenderPass2(pool, commandBuffer, pRenderPassBegin,
+    return mImpl->on_vkCmdBeginRenderPass2(pool, snapshotInfo, commandBuffer, pRenderPassBegin,
                                            pSubpassBeginInfo);
 }
 
 void VkDecoderGlobalState::on_vkCmdBeginRenderPass2KHR(
-    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-    const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo) {
-    return mImpl->on_vkCmdBeginRenderPass2(pool, commandBuffer, pRenderPassBegin,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin,
+    const VkSubpassBeginInfo* pSubpassBeginInfo) {
+    return mImpl->on_vkCmdBeginRenderPass2(pool, snapshotInfo, commandBuffer, pRenderPassBegin,
                                            pSubpassBeginInfo);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateFramebuffer(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* snapshotInfo,
                                                       VkDevice boxed_device,
                                                       const VkFramebufferCreateInfo* pCreateInfo,
                                                       const VkAllocationCallbacks* pAllocator,
                                                       VkFramebuffer* pFramebuffer) {
-    return mImpl->on_vkCreateFramebuffer(pool, boxed_device, pCreateInfo, pAllocator, pFramebuffer);
+    return mImpl->on_vkCreateFramebuffer(pool, snapshotInfo, boxed_device, pCreateInfo, pAllocator,
+                                         pFramebuffer);
 }
 
 void VkDecoderGlobalState::on_vkDestroyFramebuffer(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* snapshotInfo,
                                                    VkDevice boxed_device, VkFramebuffer framebuffer,
                                                    const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroyFramebuffer(pool, boxed_device, framebuffer, pAllocator);
+    mImpl->on_vkDestroyFramebuffer(pool, snapshotInfo, boxed_device, framebuffer, pAllocator);
 }
 
-void VkDecoderGlobalState::on_vkQueueHostSyncGOOGLE(android::base::BumpPool* pool, VkQueue queue,
-                                                    uint32_t needHostSync,
+void VkDecoderGlobalState::on_vkQueueHostSyncGOOGLE(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
+                                                    VkQueue queue, uint32_t needHostSync,
                                                     uint32_t sequenceNumber) {
     mImpl->hostSyncQueue("hostSyncQueue", queue, needHostSync, sequenceNumber);
 }
 
-void VkDecoderGlobalState::on_vkCmdCopyQueryPoolResults(android::base::BumpPool* pool,
-                                                        VkCommandBuffer commandBuffer,
-                                                        VkQueryPool queryPool, uint32_t firstQuery,
-                                                        uint32_t queryCount, VkBuffer dstBuffer,
-                                                        VkDeviceSize dstOffset, VkDeviceSize stride,
-                                                        VkQueryResultFlags flags) {
-    mImpl->on_vkCmdCopyQueryPoolResults(pool, commandBuffer, queryPool, firstQuery, queryCount,
-                                        dstBuffer, dstOffset, stride, flags);
+void VkDecoderGlobalState::on_vkCmdCopyQueryPoolResults(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+    VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount,
+    VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) {
+    mImpl->on_vkCmdCopyQueryPoolResults(pool, snapshotInfo, commandBuffer, queryPool, firstQuery,
+                                        queryCount, dstBuffer, dstOffset, stride, flags);
 }
 
-void VkDecoderGlobalState::on_vkQueueSubmitAsyncGOOGLE(android::base::BumpPool* pool, VkQueue queue,
-                                                       uint32_t submitCount,
+void VkDecoderGlobalState::on_vkQueueSubmitAsyncGOOGLE(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* snapshotInfo,
+                                                       VkQueue queue, uint32_t submitCount,
                                                        const VkSubmitInfo* pSubmits,
                                                        VkFence fence) {
-    mImpl->on_vkQueueSubmit(pool, queue, submitCount, pSubmits, fence);
+    mImpl->on_vkQueueSubmit(pool, snapshotInfo, queue, submitCount, pSubmits, fence);
 }
 
 void VkDecoderGlobalState::on_vkQueueSubmitAsync2GOOGLE(android::base::BumpPool* pool,
+                                                        VkSnapshotApiCallInfo* snapshotInfo,
                                                         VkQueue queue, uint32_t submitCount,
                                                         const VkSubmitInfo2* pSubmits,
                                                         VkFence fence) {
-    mImpl->on_vkQueueSubmit(pool, queue, submitCount, pSubmits, fence);
+    mImpl->on_vkQueueSubmit(pool, snapshotInfo, queue, submitCount, pSubmits, fence);
 }
 
 void VkDecoderGlobalState::on_vkQueueWaitIdleAsyncGOOGLE(android::base::BumpPool* pool,
+                                                         VkSnapshotApiCallInfo* snapshotInfo,
                                                          VkQueue queue) {
-    mImpl->on_vkQueueWaitIdle(pool, queue);
+    mImpl->on_vkQueueWaitIdle(pool, snapshotInfo, queue);
 }
 
 void VkDecoderGlobalState::on_vkQueueBindSparseAsyncGOOGLE(android::base::BumpPool* pool,
+                                                           VkSnapshotApiCallInfo* snapshotInfo,
                                                            VkQueue queue, uint32_t bindInfoCount,
                                                            const VkBindSparseInfo* pBindInfo,
                                                            VkFence fence) {
-    VkResult res = mImpl->on_vkQueueBindSparse(pool, queue, bindInfoCount, pBindInfo, fence);
+    VkResult res =
+        mImpl->on_vkQueueBindSparse(pool, snapshotInfo, queue, bindInfoCount, pBindInfo, fence);
     if (res != VK_SUCCESS) {
         // Report an error here as we don't use the result after this call
         ERR("vkQueueBindSparse failed with: %s [%d], bindInfoCount=%d, fence=%p",
@@ -10068,114 +10278,121 @@ void VkDecoderGlobalState::on_vkQueueBindSparseAsyncGOOGLE(android::base::BumpPo
 }
 
 void VkDecoderGlobalState::on_vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool,
+                                                           VkSnapshotApiCallInfo* snapshotInfo,
                                                            VkDevice device, VkFormat format,
                                                            VkDeviceSize* pOffset,
                                                            VkDeviceSize* pRowPitchAlignment) {
-    mImpl->on_vkGetLinearImageLayoutGOOGLE(pool, device, format, pOffset, pRowPitchAlignment);
+    mImpl->on_vkGetLinearImageLayoutGOOGLE(pool, snapshotInfo, device, format, pOffset,
+                                           pRowPitchAlignment);
 }
 
-void VkDecoderGlobalState::on_vkGetLinearImageLayout2GOOGLE(android::base::BumpPool* pool,
-                                                            VkDevice device,
-                                                            const VkImageCreateInfo* pCreateInfo,
-                                                            VkDeviceSize* pOffset,
-                                                            VkDeviceSize* pRowPitchAlignment) {
-    mImpl->on_vkGetLinearImageLayout2GOOGLE(pool, device, pCreateInfo, pOffset, pRowPitchAlignment);
+void VkDecoderGlobalState::on_vkGetLinearImageLayout2GOOGLE(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    const VkImageCreateInfo* pCreateInfo, VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment) {
+    mImpl->on_vkGetLinearImageLayout2GOOGLE(pool, snapshotInfo, device, pCreateInfo, pOffset,
+                                            pRowPitchAlignment);
 }
 
 void VkDecoderGlobalState::on_vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool,
+                                                         VkSnapshotApiCallInfo* snapshotInfo,
                                                          VkQueue queue,
                                                          VkCommandBuffer commandBuffer,
                                                          VkDeviceSize dataSize, const void* pData,
                                                          const VkDecoderContext& context) {
-    mImpl->on_vkQueueFlushCommandsGOOGLE(pool, queue, commandBuffer, dataSize, pData, context);
+    mImpl->on_vkQueueFlushCommandsGOOGLE(pool, snapshotInfo, queue, commandBuffer, dataSize, pData,
+                                         context);
 }
 
 void VkDecoderGlobalState::on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(
-    android::base::BumpPool* pool, VkQueue queue, VkCommandBuffer commandBuffer,
-    VkDeviceMemory deviceMemory, VkDeviceSize dataOffset, VkDeviceSize dataSize,
-    const VkDecoderContext& context) {
-    mImpl->on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(pool, queue, commandBuffer, deviceMemory,
-                                                      dataOffset, dataSize, context);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
+    VkCommandBuffer commandBuffer, VkDeviceMemory deviceMemory, VkDeviceSize dataOffset,
+    VkDeviceSize dataSize, const VkDecoderContext& context) {
+    mImpl->on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(pool, snapshotInfo, queue, commandBuffer,
+                                                      deviceMemory, dataOffset, dataSize, context);
 }
 
 void VkDecoderGlobalState::on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
-    android::base::BumpPool* pool, VkQueue queue, uint32_t descriptorPoolCount,
-    const VkDescriptorPool* pDescriptorPools, uint32_t descriptorSetCount,
-    const VkDescriptorSetLayout* pDescriptorSetLayouts, const uint64_t* pDescriptorSetPoolIds,
-    const uint32_t* pDescriptorSetWhichPool, const uint32_t* pDescriptorSetPendingAllocation,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
+    uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
+    uint32_t descriptorSetCount, const VkDescriptorSetLayout* pDescriptorSetLayouts,
+    const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
+    const uint32_t* pDescriptorSetPendingAllocation,
     const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
     const VkWriteDescriptorSet* pPendingDescriptorWrites) {
     mImpl->on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
-        pool, queue, descriptorPoolCount, pDescriptorPools, descriptorSetCount,
+        pool, snapshotInfo, queue, descriptorPoolCount, pDescriptorPools, descriptorSetCount,
         pDescriptorSetLayouts, pDescriptorSetPoolIds, pDescriptorSetWhichPool,
         pDescriptorSetPendingAllocation, pDescriptorWriteStartingIndices,
         pendingDescriptorWriteCount, pPendingDescriptorWrites);
 }
 
-void VkDecoderGlobalState::on_vkCollectDescriptorPoolIdsGOOGLE(android::base::BumpPool* pool,
-                                                               VkDevice device,
-                                                               VkDescriptorPool descriptorPool,
-                                                               uint32_t* pPoolIdCount,
-                                                               uint64_t* pPoolIds) {
-    mImpl->on_vkCollectDescriptorPoolIdsGOOGLE(pool, device, descriptorPool, pPoolIdCount,
-                                               pPoolIds);
+void VkDecoderGlobalState::on_vkCollectDescriptorPoolIdsGOOGLE(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkDescriptorPool descriptorPool, uint32_t* pPoolIdCount, uint64_t* pPoolIds) {
+    mImpl->on_vkCollectDescriptorPoolIdsGOOGLE(pool, snapshotInfo, device, descriptorPool,
+                                               pPoolIdCount, pPoolIds);
 }
 
-VkResult VkDecoderGlobalState::on_vkQueueBindSparse(android::base::BumpPool* pool, VkQueue queue,
-                                                    uint32_t bindInfoCount,
+VkResult VkDecoderGlobalState::on_vkQueueBindSparse(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
+                                                    VkQueue queue, uint32_t bindInfoCount,
                                                     const VkBindSparseInfo* pBindInfo,
                                                     VkFence fence) {
-    return mImpl->on_vkQueueBindSparse(pool, queue, bindInfoCount, pBindInfo, fence);
+    return mImpl->on_vkQueueBindSparse(pool, snapshotInfo, queue, bindInfoCount, pBindInfo, fence);
 }
 
 void VkDecoderGlobalState::on_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
-    android::base::BumpPool* pool, VkQueue queue, uint32_t waitSemaphoreCount,
-    const VkSemaphore* pWaitSemaphores, VkImage image) {
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
+    uint32_t waitSemaphoreCount, const VkSemaphore* pWaitSemaphores, VkImage image) {
     int fenceFd;
-    mImpl->on_vkQueueSignalReleaseImageANDROID(pool, queue, waitSemaphoreCount, pWaitSemaphores,
-                                               image, &fenceFd);
+    mImpl->on_vkQueueSignalReleaseImageANDROID(pool, snapshotInfo, queue, waitSemaphoreCount,
+                                               pWaitSemaphores, image, &fenceFd);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateSamplerYcbcrConversion(
-    android::base::BumpPool* pool, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
     const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
     VkSamplerYcbcrConversion* pYcbcrConversion) {
-    return mImpl->on_vkCreateSamplerYcbcrConversion(pool, device, pCreateInfo, pAllocator,
-                                                    pYcbcrConversion);
+    return mImpl->on_vkCreateSamplerYcbcrConversion(pool, snapshotInfo, device, pCreateInfo,
+                                                    pAllocator, pYcbcrConversion);
 }
 
 VkResult VkDecoderGlobalState::on_vkCreateSamplerYcbcrConversionKHR(
-    android::base::BumpPool* pool, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
     const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
     VkSamplerYcbcrConversion* pYcbcrConversion) {
-    return mImpl->on_vkCreateSamplerYcbcrConversion(pool, device, pCreateInfo, pAllocator,
-                                                    pYcbcrConversion);
+    return mImpl->on_vkCreateSamplerYcbcrConversion(pool, snapshotInfo, device, pCreateInfo,
+                                                    pAllocator, pYcbcrConversion);
 }
 
 void VkDecoderGlobalState::on_vkDestroySamplerYcbcrConversion(
-    android::base::BumpPool* pool, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
-    const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroySamplerYcbcrConversion(pool, device, ycbcrConversion, pAllocator);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator) {
+    mImpl->on_vkDestroySamplerYcbcrConversion(pool, snapshotInfo, device, ycbcrConversion,
+                                              pAllocator);
 }
 
 void VkDecoderGlobalState::on_vkDestroySamplerYcbcrConversionKHR(
-    android::base::BumpPool* pool, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
-    const VkAllocationCallbacks* pAllocator) {
-    mImpl->on_vkDestroySamplerYcbcrConversion(pool, device, ycbcrConversion, pAllocator);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+    VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator) {
+    mImpl->on_vkDestroySamplerYcbcrConversion(pool, snapshotInfo, device, ycbcrConversion,
+                                              pAllocator);
 }
 
 VkResult VkDecoderGlobalState::on_vkEnumeratePhysicalDeviceGroups(
-    android::base::BumpPool* pool, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkInstance instance,
+    uint32_t* pPhysicalDeviceGroupCount,
     VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
-    return mImpl->on_vkEnumeratePhysicalDeviceGroups(pool, instance, pPhysicalDeviceGroupCount,
-                                                     pPhysicalDeviceGroupProperties);
+    return mImpl->on_vkEnumeratePhysicalDeviceGroups(
+        pool, snapshotInfo, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
 }
 
 VkResult VkDecoderGlobalState::on_vkEnumeratePhysicalDeviceGroupsKHR(
-    android::base::BumpPool* pool, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkInstance instance,
+    uint32_t* pPhysicalDeviceGroupCount,
     VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
-    return mImpl->on_vkEnumeratePhysicalDeviceGroups(pool, instance, pPhysicalDeviceGroupCount,
-                                                     pPhysicalDeviceGroupProperties);
+    return mImpl->on_vkEnumeratePhysicalDeviceGroups(
+        pool, snapshotInfo, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
 }
 
 void VkDecoderGlobalState::on_DeviceLost() { mImpl->on_DeviceLost(); }
@@ -10187,11 +10404,8 @@ void VkDecoderGlobalState::on_CheckOutOfMemory(VkResult result, uint32_t opCode,
 }
 
 VkResult VkDecoderGlobalState::waitForFence(VkFence boxed_fence, uint64_t timeout) {
-    return mImpl->waitForFence(boxed_fence, timeout);
-}
-
-VkResult VkDecoderGlobalState::getFenceStatus(VkFence boxed_fence) {
-    return mImpl->getFenceStatus(boxed_fence);
+    VkFence fence = unbox_VkFence(boxed_fence);
+    return mImpl->waitForFence(fence, timeout);
 }
 
 AsyncResult VkDecoderGlobalState::registerQsriCallback(VkImage image,
@@ -10247,222 +10461,5 @@ VkDecoderSnapshot* VkDecoderGlobalState::snapshot() { return mImpl->snapshot();
 
 LIST_TRANSFORMED_TYPES(DEFINE_TRANSFORMED_TYPE_IMPL)
 
-#define DEFINE_BOXED_DISPATCHABLE_HANDLE_API_DEF(type)                                         \
-    type VkDecoderGlobalState::new_boxed_##type(type underlying, VulkanDispatch* dispatch,     \
-                                                bool ownDispatch) {                            \
-        return mImpl->new_boxed_##type(underlying, dispatch, ownDispatch);                     \
-    }                                                                                          \
-    void VkDecoderGlobalState::delete_##type(type boxed) { mImpl->delete_##type(boxed); }      \
-    type VkDecoderGlobalState::unbox_##type(type boxed) { return mImpl->unbox_##type(boxed); } \
-    type VkDecoderGlobalState::try_unbox_##type(type boxed) {                                  \
-        return mImpl->try_unbox_##type(boxed);                                                 \
-    }                                                                                          \
-    VulkanDispatch* VkDecoderGlobalState::dispatch_##type(type boxed) {                        \
-        return mImpl->dispatch_##type(boxed);                                                  \
-    }
-
-#define DEFINE_UNBOXED_TO_BOXED_DISPATCHABLE_HANDLE_API_DEF(type)                              \
-    type VkDecoderGlobalState::unboxed_to_boxed_##type(type unboxed) {                         \
-        return mImpl->unboxed_to_boxed_##type(unboxed);                                        \
-    }
-
-#define DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_DEF(type)                                     \
-    type VkDecoderGlobalState::new_boxed_non_dispatchable_##type(type underlying) {            \
-        return mImpl->new_boxed_non_dispatchable_##type(underlying);                           \
-    }                                                                                          \
-    void VkDecoderGlobalState::delete_##type(type boxed) { mImpl->delete_##type(boxed); }      \
-    type VkDecoderGlobalState::unbox_##type(type boxed) { return mImpl->unbox_##type(boxed); } \
-    type VkDecoderGlobalState::try_unbox_##type(type boxed) {                                  \
-        return mImpl->try_unbox_##type(boxed);                                                 \
-    }
-
-GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_API_DEF)
-GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_DEF)
-
-// Custom unbox and non dispatchable handles should not use unboxed_to_boxed as there is no 1-1
-// mapping
-GOLDFISH_VK_LIST_DISPATCHABLE_REGULAR_UNBOX_HANDLE_TYPES(
-    DEFINE_UNBOXED_TO_BOXED_DISPATCHABLE_HANDLE_API_DEF)
-
-#define DEFINE_BOXED_DISPATCHABLE_HANDLE_GLOBAL_API_DEF(type)                                     \
-    type unbox_##type(type boxed) {                                                               \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) return VK_NULL_HANDLE;                                                          \
-        return (type)elt->underlying;                                                             \
-    }                                                                                             \
-    type try_unbox_##type(type boxed) {                                                           \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) {                                                                               \
-            WARN("%s: Failed to unbox %p", __func__, boxed);                                      \
-            return VK_NULL_HANDLE;                                                                \
-        }                                                                                         \
-        return (type)elt->underlying;                                                             \
-    }                                                                                             \
-    VulkanDispatch* dispatch_##type(type boxed) {                                                 \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) {                                                                               \
-            ERR("%s: Failed to unbox %p", __func__, boxed);                                       \
-            return nullptr;                                                                       \
-        }                                                                                         \
-        return elt->dispatch;                                                                     \
-    }                                                                                             \
-    void delete_##type(type boxed) {                                                              \
-        if (!boxed) return;                                                                       \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) return;                                                                         \
-        releaseOrderMaintInfo(elt->ordMaintInfo);                                                 \
-        if (elt->readStream) {                                                                    \
-            sReadStreamRegistry.push(elt->readStream);                                            \
-            elt->readStream = nullptr;                                                            \
-        }                                                                                         \
-        sBoxedHandleManager.remove((uint64_t)boxed);                                              \
-    }                                                                                             \
-    type unboxed_to_boxed_##type(type unboxed) {                                                  \
-        AutoLock lock(sBoxedHandleManager.lock);                                                  \
-        return (type)sBoxedHandleManager.getBoxedFromUnboxedLocked((uint64_t)(uintptr_t)unboxed); \
-    }
-
-#define DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_GLOBAL_API_DEF(type)                                 \
-    type new_boxed_non_dispatchable_##type(type underlying) {                                     \
-        return VkDecoderGlobalState::get()->new_boxed_non_dispatchable_##type(underlying);        \
-    }                                                                                             \
-    void delete_##type(type boxed) {                                                              \
-        if (!boxed) return;                                                                       \
-        sBoxedHandleManager.remove((uint64_t)boxed);                                              \
-    }                                                                                             \
-    void delayed_delete_##type(type boxed, VkDevice device, std::function<void()> callback) {     \
-        sBoxedHandleManager.removeDelayed((uint64_t)boxed, device, callback);                     \
-    }                                                                                             \
-    type unbox_##type(type boxed) {                                                               \
-        if (!boxed) return boxed;                                                                 \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) {                                                                               \
-            GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))                                       \
-                << "Unbox " << boxed << " failed, not found.";                                    \
-            return VK_NULL_HANDLE;                                                                \
-        }                                                                                         \
-        return (type)elt->underlying;                                                             \
-    }                                                                                             \
-    type try_unbox_##type(type boxed) {                                                           \
-        if (!boxed) return boxed;                                                                 \
-        auto elt = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);                           \
-        if (!elt) {                                                                               \
-            WARN("%s: Failed to unbox %p", __func__, boxed);                                      \
-            return VK_NULL_HANDLE;                                                                \
-        }                                                                                         \
-        return (type)elt->underlying;                                                             \
-    }                                                                                             \
-    type unboxed_to_boxed_non_dispatchable_##type(type unboxed) {                                 \
-        if (!unboxed) {                                                                           \
-            return nullptr;                                                                       \
-        }                                                                                         \
-        AutoLock lock(sBoxedHandleManager.lock);                                                  \
-        return (type)sBoxedHandleManager.getBoxedFromUnboxedLocked((uint64_t)(uintptr_t)unboxed); \
-    }
-
-GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_GLOBAL_API_DEF)
-GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_GLOBAL_API_DEF)
-
-void BoxedHandleUnwrapAndDeletePreserveBoxedMapping::setup(android::base::BumpPool* pool,
-                                                           uint64_t** bufPtr) {
-    mPool = pool;
-    mPreserveBufPtr = bufPtr;
-}
-
-void BoxedHandleUnwrapAndDeletePreserveBoxedMapping::allocPreserve(size_t count) {
-    *mPreserveBufPtr = (uint64_t*)mPool->alloc(count * sizeof(uint64_t));
-}
-
-#define BOXED_DISPATCHABLE_HANDLE_UNWRAP_AND_DELETE_PRESERVE_BOXED_IMPL(type_name)        \
-    void BoxedHandleUnwrapAndDeletePreserveBoxedMapping::mapHandles_##type_name(          \
-        type_name* handles, size_t count) {                                               \
-        allocPreserve(count);                                                             \
-        for (size_t i = 0; i < count; ++i) {                                              \
-            (*mPreserveBufPtr)[i] = (uint64_t)(handles[i]);                               \
-            if (handles[i]) {                                                             \
-                handles[i] = VkDecoderGlobalState::get()->unbox_##type_name(handles[i]);  \
-            } else {                                                                      \
-                handles[i] = (type_name) nullptr;                                         \
-            };                                                                            \
-        }                                                                                 \
-    }                                                                                     \
-    void BoxedHandleUnwrapAndDeletePreserveBoxedMapping::mapHandles_##type_name##_u64(    \
-        const type_name* handles, uint64_t* handle_u64s, size_t count) {                  \
-        allocPreserve(count);                                                             \
-        for (size_t i = 0; i < count; ++i) {                                              \
-            (*mPreserveBufPtr)[i] = (uint64_t)(handle_u64s[i]);                           \
-            if (handles[i]) {                                                             \
-                handle_u64s[i] =                                                          \
-                    (uint64_t)VkDecoderGlobalState::get()->unbox_##type_name(handles[i]); \
-            } else {                                                                      \
-                handle_u64s[i] = 0;                                                       \
-            }                                                                             \
-        }                                                                                 \
-    }                                                                                     \
-    void BoxedHandleUnwrapAndDeletePreserveBoxedMapping::mapHandles_u64_##type_name(      \
-        const uint64_t* handle_u64s, type_name* handles, size_t count) {                  \
-        allocPreserve(count);                                                             \
-        for (size_t i = 0; i < count; ++i) {                                              \
-            (*mPreserveBufPtr)[i] = (uint64_t)(handle_u64s[i]);                           \
-            if (handle_u64s[i]) {                                                         \
-                handles[i] = VkDecoderGlobalState::get()->unbox_##type_name(              \
-                    (type_name)(uintptr_t)handle_u64s[i]);                                \
-            } else {                                                                      \
-                handles[i] = (type_name) nullptr;                                         \
-            }                                                                             \
-        }                                                                                 \
-    }
-
-#define BOXED_NON_DISPATCHABLE_HANDLE_UNWRAP_AND_DELETE_PRESERVE_BOXED_IMPL(type_name)    \
-    void BoxedHandleUnwrapAndDeletePreserveBoxedMapping::mapHandles_##type_name(          \
-        type_name* handles, size_t count) {                                               \
-        allocPreserve(count);                                                             \
-        for (size_t i = 0; i < count; ++i) {                                              \
-            (*mPreserveBufPtr)[i] = (uint64_t)(handles[i]);                               \
-            if (handles[i]) {                                                             \
-                auto boxed = handles[i];                                                  \
-                handles[i] = VkDecoderGlobalState::get()->unbox_##type_name(handles[i]);  \
-                delete_##type_name(boxed);                                                \
-            } else {                                                                      \
-                handles[i] = (type_name) nullptr;                                         \
-            };                                                                            \
-        }                                                                                 \
-    }                                                                                     \
-    void BoxedHandleUnwrapAndDeletePreserveBoxedMapping::mapHandles_##type_name##_u64(    \
-        const type_name* handles, uint64_t* handle_u64s, size_t count) {                  \
-        allocPreserve(count);                                                             \
-        for (size_t i = 0; i < count; ++i) {                                              \
-            (*mPreserveBufPtr)[i] = (uint64_t)(handle_u64s[i]);                           \
-            if (handles[i]) {                                                             \
-                auto boxed = handles[i];                                                  \
-                handle_u64s[i] =                                                          \
-                    (uint64_t)VkDecoderGlobalState::get()->unbox_##type_name(handles[i]); \
-                delete_##type_name(boxed);                                                \
-            } else {                                                                      \
-                handle_u64s[i] = 0;                                                       \
-            }                                                                             \
-        }                                                                                 \
-    }                                                                                     \
-    void BoxedHandleUnwrapAndDeletePreserveBoxedMapping::mapHandles_u64_##type_name(      \
-        const uint64_t* handle_u64s, type_name* handles, size_t count) {                  \
-        allocPreserve(count);                                                             \
-        for (size_t i = 0; i < count; ++i) {                                              \
-            (*mPreserveBufPtr)[i] = (uint64_t)(handle_u64s[i]);                           \
-            if (handle_u64s[i]) {                                                         \
-                auto boxed = (type_name)(uintptr_t)handle_u64s[i];                        \
-                handles[i] = VkDecoderGlobalState::get()->unbox_##type_name(              \
-                    (type_name)(uintptr_t)handle_u64s[i]);                                \
-                delete_##type_name(boxed);                                                \
-            } else {                                                                      \
-                handles[i] = (type_name) nullptr;                                         \
-            }                                                                             \
-        }                                                                                 \
-    }
-
-GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(
-    BOXED_DISPATCHABLE_HANDLE_UNWRAP_AND_DELETE_PRESERVE_BOXED_IMPL)
-GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(
-    BOXED_NON_DISPATCHABLE_HANDLE_UNWRAP_AND_DELETE_PRESERVE_BOXED_IMPL)
-
 }  // namespace vk
 }  // namespace gfxstream
diff --git a/host/vulkan/VkDecoderGlobalState.h b/host/vulkan/VkDecoderGlobalState.h
index eb455a399..6f6646b59 100644
--- a/host/vulkan/VkDecoderGlobalState.h
+++ b/host/vulkan/VkDecoderGlobalState.h
@@ -23,14 +23,15 @@
 
 #include "VkDecoderContext.h"
 #include "VkQsriTimeline.h"
+#include "VkSnapshotApiCall.h"
 #include "VulkanDispatch.h"
 #include "VulkanHandleMapping.h"
 #include "aemu/base/AsyncResult.h"
 #include "aemu/base/HealthMonitor.h"
 #include "aemu/base/synchronization/Lock.h"
+#include "cereal/common/goldfish_vk_transform.h"
 #include "gfxstream/host/Features.h"
 #include "goldfish_vk_private_defs.h"
-#include "cereal/common/goldfish_vk_transform.h"
 #include "host-common/GfxstreamFatalError.h"
 #include "utils/GfxApiLogger.h"
 #include "vk_util.h"
@@ -41,8 +42,6 @@ using emugl::ABORT_REASON_OTHER;
 using emugl::FatalError;
 using emugl::HealthMonitor;
 
-class VkDecoderSnapshot;
-
 namespace android {
 namespace base {
 class BumpPool;
@@ -53,6 +52,9 @@ class Stream;
 namespace gfxstream {
 namespace vk {
 
+class VkDecoderSnapshot;
+class VkEmulation;
+
 // Class for tracking host-side state. Currently we only care about
 // tracking VkDeviceMemory to make it easier to pass the right data
 // from mapped pointers to the guest, but this could get more stuff
@@ -64,9 +66,11 @@ namespace vk {
 // functions.
 class VkDecoderGlobalState {
    public:
-    VkDecoderGlobalState();
+    VkDecoderGlobalState(VkEmulation* emulation);
     ~VkDecoderGlobalState();
 
+    static void initialize(VkEmulation* emulation);
+
     // There should only be one instance of VkDecoderGlobalState per process
     // Note: currently not thread-safe
     static VkDecoderGlobalState* get();
@@ -74,19 +78,12 @@ class VkDecoderGlobalState {
     // For testing only - destroys the global instance of VkDecoderGlobalState.
     static void reset();
 
-    enum SnapshotState {
-        Normal,
-        Saving,
-        Loading,
-    };
-
     // Snapshot save/load
     bool snapshotsEnabled() const;
+    bool isSnapshotCurrentlyLoading() const;
 
     bool batchedDescriptorSetUpdateEnabled() const;
 
-    SnapshotState getSnapshotState() const;
-
     const gfxstream::host::FeatureSet& getFeatures() const;
 
     // Whether to clean up VK instance.
@@ -97,19 +94,14 @@ class VkDecoderGlobalState {
     void load(android::base::Stream* stream, emugl::GfxApiLogger& gfxLogger,
               emugl::HealthMonitor<>* healthMonitor);
 
-    // Lock/unlock of global state to serve as a global lock
-    void lock();
-    void unlock();
-
-    // Sets the current created handles for snapshot load
-    // which will override the effect of any new_boxed_*** calls.
-    // They are consumed in sequence.
-    // Returns number of bytes of |buffer|
-    // that have been consumed for this purpose.
-    size_t setCreatedHandlesForSnapshotLoad(const unsigned char* buffer);
-    void clearCreatedHandlesForSnapshotLoad();
-
-    VkResult on_vkEnumerateInstanceVersion(android::base::BumpPool* pool, uint32_t* pApiVersion);
+    VkResult on_vkEnumerateInstanceVersion(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* snapshotInfo,
+                                           uint32_t* pApiVersion);
+    VkResult on_vkEnumerateInstanceExtensionProperties(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* snapshotInfo,
+                                                       const char* pLayerName,
+                                                       uint32_t* pPropertyCount,
+                                                       VkExtensionProperties* pProperties);
 
     // Fast way to get dispatch tables associated with a Vulkan object.
     // VkInstance
@@ -118,285 +110,351 @@ class VkDecoderGlobalState {
     // VkQueue
     // VkCommandBuffer
 
-    VkResult on_vkCreateInstance(android::base::BumpPool* pool,
+    VkResult on_vkCreateInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                  const VkInstanceCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
 
-    void on_vkDestroyInstance(android::base::BumpPool* pool, VkInstance instance,
-                              const VkAllocationCallbacks* pAllocator);
+    void on_vkDestroyInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                              VkInstance instance, const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkEnumeratePhysicalDevices(android::base::BumpPool* pool, VkInstance instance,
+    VkResult on_vkEnumeratePhysicalDevices(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* snapshotInfo, VkInstance instance,
                                            uint32_t* physicalDeviceCount,
                                            VkPhysicalDevice* physicalDevices);
 
     // Override features
     void on_vkGetPhysicalDeviceFeatures(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* snapshotInfo,
                                         VkPhysicalDevice physicalDevice,
                                         VkPhysicalDeviceFeatures* pFeatures);
     void on_vkGetPhysicalDeviceFeatures2(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* snapshotInfo,
                                          VkPhysicalDevice physicalDevice,
                                          VkPhysicalDeviceFeatures2* pFeatures);
     void on_vkGetPhysicalDeviceFeatures2KHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* snapshotInfo,
                                             VkPhysicalDevice physicalDevice,
                                             VkPhysicalDeviceFeatures2* pFeatures);
 
     // Override image format properties
     VkResult on_vkGetPhysicalDeviceImageFormatProperties(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice, VkFormat format,
-        VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling,
+        VkImageUsageFlags usage, VkImageCreateFlags flags,
         VkImageFormatProperties* pImageFormatProperties);
     VkResult on_vkGetPhysicalDeviceImageFormatProperties2(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-        const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
         VkImageFormatProperties2* pImageFormatProperties);
     VkResult on_vkGetPhysicalDeviceImageFormatProperties2KHR(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-        const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
         VkImageFormatProperties2* pImageFormatProperties);
 
     // Override format features
     void on_vkGetPhysicalDeviceFormatProperties(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* snapshotInfo,
                                                 VkPhysicalDevice physicalDevice, VkFormat format,
                                                 VkFormatProperties* pFormatProperties);
     void on_vkGetPhysicalDeviceFormatProperties2(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* snapshotInfo,
                                                  VkPhysicalDevice physicalDevice, VkFormat format,
                                                  VkFormatProperties2* pFormatProperties);
     void on_vkGetPhysicalDeviceFormatProperties2KHR(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
                                                     VkPhysicalDevice physicalDevice,
                                                     VkFormat format,
                                                     VkFormatProperties2* pFormatProperties);
 
     // Override API version
     void on_vkGetPhysicalDeviceProperties(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* snapshotInfo,
                                           VkPhysicalDevice physicalDevice,
                                           VkPhysicalDeviceProperties* pProperties);
     void on_vkGetPhysicalDeviceProperties2(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* snapshotInfo,
                                            VkPhysicalDevice physicalDevice,
                                            VkPhysicalDeviceProperties2* pProperties);
     void on_vkGetPhysicalDeviceProperties2KHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* snapshotInfo,
                                               VkPhysicalDevice physicalDevice,
                                               VkPhysicalDeviceProperties2* pProperties);
 
     // Override queue properties
     void on_vkGetPhysicalDeviceQueueFamilyProperties(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
+        VkQueueFamilyProperties* pQueueFamilyProperties);
     void on_vkGetPhysicalDeviceQueueFamilyProperties2(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
+        VkQueueFamilyProperties2* pQueueFamilyProperties);
 
     // Override memory types advertised from host
     //
     void on_vkGetPhysicalDeviceMemoryProperties(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-        VkPhysicalDeviceMemoryProperties* pMemoryProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
     void on_vkGetPhysicalDeviceMemoryProperties2(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-        VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
     void on_vkGetPhysicalDeviceMemoryProperties2KHR(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
-        VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
 
     // Override supported device extension lists
     VkResult on_vkEnumerateDeviceExtensionProperties(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* snapshotInfo,
                                                      VkPhysicalDevice physicalDevice,
                                                      const char* pLayerName,
                                                      uint32_t* pPropertyCount,
                                                      VkExtensionProperties* pProperties);
 
-    VkResult on_vkCreateDevice(android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+    VkResult on_vkCreateDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                               VkPhysicalDevice physicalDevice,
                                const VkDeviceCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
 
-    void on_vkGetDeviceQueue(android::base::BumpPool* pool, VkDevice device,
-                             uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
+    void on_vkGetDeviceQueue(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                             VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex,
+                             VkQueue* pQueue);
 
-    void on_vkGetDeviceQueue2(android::base::BumpPool* pool, VkDevice device,
-                              const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue);
+    void on_vkGetDeviceQueue2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                              VkDevice device, const VkDeviceQueueInfo2* pQueueInfo,
+                              VkQueue* pQueue);
 
-    void on_vkDestroyDevice(android::base::BumpPool* pool, VkDevice device,
-                            const VkAllocationCallbacks* pAllocator);
+    void on_vkDestroyDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                            VkDevice device, const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkCreateBuffer(android::base::BumpPool* pool, VkDevice device,
-                               const VkBufferCreateInfo* pCreateInfo,
+    VkResult on_vkCreateBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                               VkDevice device, const VkBufferCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
 
-    void on_vkDestroyBuffer(android::base::BumpPool* pool, VkDevice device, VkBuffer buffer,
+    void on_vkDestroyBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                            VkDevice device, VkBuffer buffer,
                             const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkBindBufferMemory(android::base::BumpPool* pool, VkDevice device, VkBuffer buffer,
-                                   VkDeviceMemory memory, VkDeviceSize memoryOffset);
-    VkResult on_vkBindBufferMemory2(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkBindBufferMemory(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+                                   VkBuffer buffer, VkDeviceMemory memory,
+                                   VkDeviceSize memoryOffset);
+    VkResult on_vkBindBufferMemory2(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                     uint32_t bindInfoCount,
                                     const VkBindBufferMemoryInfo* pBindInfos);
-    VkResult on_vkBindBufferMemory2KHR(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkBindBufferMemory2KHR(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                        uint32_t bindInfoCount,
                                        const VkBindBufferMemoryInfo* pBindInfos);
 
-    VkResult on_vkCreateImage(android::base::BumpPool* pool, VkDevice device,
-                              const VkImageCreateInfo* pCreateInfo,
+    VkResult on_vkCreateImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                              VkDevice device, const VkImageCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator, VkImage* pImage);
 
-    void on_vkDestroyImage(android::base::BumpPool* pool, VkDevice device, VkImage image,
-                           const VkAllocationCallbacks* pAllocator);
+    void on_vkDestroyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                           VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkBindImageMemory(android::base::BumpPool* pool, VkDevice device, VkImage image,
-                                  VkDeviceMemory memory, VkDeviceSize memoryOffset);
+    VkResult on_vkBindImageMemory(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+                                  VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
     // It might modify pBindInfos to support snapshot.
-    VkResult on_vkBindImageMemory2(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkBindImageMemory2(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos);
     // It might modify pBindInfos to support snapshot.
-    VkResult on_vkBindImageMemory2KHR(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkBindImageMemory2KHR(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                       uint32_t bindInfoCount,
                                       const VkBindImageMemoryInfo* pBindInfos);
 
-    VkResult on_vkCreateImageView(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateImageView(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   const VkImageViewCreateInfo* pCreateInfo,
                                   const VkAllocationCallbacks* pAllocator, VkImageView* pView);
 
-    void on_vkDestroyImageView(android::base::BumpPool* pool, VkDevice device,
-                               VkImageView imageView, const VkAllocationCallbacks* pAllocator);
+    void on_vkDestroyImageView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                               VkDevice device, VkImageView imageView,
+                               const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkCreateSampler(android::base::BumpPool* pool, VkDevice device,
-                                const VkSamplerCreateInfo* pCreateInfo,
+    VkResult on_vkCreateSampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                VkDevice device, const VkSamplerCreateInfo* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
 
-    void on_vkDestroySampler(android::base::BumpPool* pool, VkDevice device, VkSampler sampler,
+    void on_vkDestroySampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                             VkDevice device, VkSampler sampler,
                              const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkCreateDescriptorSetLayout(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateDescriptorSetLayout(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                             const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator,
                                             VkDescriptorSetLayout* pSetLayout);
 
-    void on_vkDestroyDescriptorSetLayout(android::base::BumpPool* pool, VkDevice device,
+    void on_vkDestroyDescriptorSetLayout(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                          VkDescriptorSetLayout descriptorSetLayout,
                                          const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkCreateDescriptorPool(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateDescriptorPool(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                        const VkDescriptorPoolCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkDescriptorPool* pDescriptorPool);
 
-    void on_vkDestroyDescriptorPool(android::base::BumpPool* pool, VkDevice device,
+    void on_vkDestroyDescriptorPool(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                     VkDescriptorPool descriptorPool,
                                     const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkResetDescriptorPool(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkResetDescriptorPool(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                       VkDescriptorPool descriptorPool,
                                       VkDescriptorPoolResetFlags flags);
 
-    VkResult on_vkAllocateDescriptorSets(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkAllocateDescriptorSets(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                          const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                          VkDescriptorSet* pDescriptorSets);
 
-    VkResult on_vkFreeDescriptorSets(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkFreeDescriptorSets(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                      VkDescriptorPool descriptorPool, uint32_t descriptorSetCount,
                                      const VkDescriptorSet* pDescriptorSets);
 
-    void on_vkUpdateDescriptorSets(android::base::BumpPool* pool, VkDevice device,
+    void on_vkUpdateDescriptorSets(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    uint32_t descriptorWriteCount,
                                    const VkWriteDescriptorSet* pDescriptorWrites,
                                    uint32_t descriptorCopyCount,
                                    const VkCopyDescriptorSet* pDescriptorCopies);
 
-    VkResult on_vkCreateShaderModule(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateShaderModule(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                      const VkShaderModuleCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator,
                                      VkShaderModule* pShaderModule);
 
-    void on_vkDestroyShaderModule(android::base::BumpPool* pool, VkDevice device,
+    void on_vkDestroyShaderModule(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   VkShaderModule shaderModule,
                                   const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkCreatePipelineCache(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreatePipelineCache(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                       const VkPipelineCacheCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator,
                                       VkPipelineCache* pPipelineCache);
 
-    void on_vkDestroyPipelineCache(android::base::BumpPool* pool, VkDevice device,
+    void on_vkDestroyPipelineCache(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    VkPipelineCache pipelineCache,
                                    const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkCreateGraphicsPipelines(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreatePipelineLayout(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+                                      const VkPipelineLayoutCreateInfo* pCreateInfo,
+                                      const VkAllocationCallbacks* pAllocator,
+                                      VkPipelineLayout* pPipelineLayout);
+
+    void on_vkDestroyPipelineLayout(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+                                   VkPipelineLayout pipelineLayout,
+                                   const VkAllocationCallbacks* pAllocator);
+
+    VkResult on_vkCreateGraphicsPipelines(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                           VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                           const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkPipeline* pPipelines);
 
-    VkResult on_vkCreateComputePipelines(android::base::BumpPool* pool, VkDevice device,
-                                          VkPipelineCache pipelineCache, uint32_t createInfoCount,
-                                          const VkComputePipelineCreateInfo* pCreateInfos,
-                                          const VkAllocationCallbacks* pAllocator,
-                                          VkPipeline* pPipelines);
+    VkResult on_vkCreateComputePipelines(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+                                         VkPipelineCache pipelineCache, uint32_t createInfoCount,
+                                         const VkComputePipelineCreateInfo* pCreateInfos,
+                                         const VkAllocationCallbacks* pAllocator,
+                                         VkPipeline* pPipelines);
 
-    void on_vkDestroyPipeline(android::base::BumpPool* pool, VkDevice device, VkPipeline pipeline,
+    void on_vkDestroyPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                              VkDevice device, VkPipeline pipeline,
                               const VkAllocationCallbacks* pAllocator);
 
-    void on_vkCmdCopyBufferToImage(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                   VkBuffer srcBuffer, VkImage dstImage,
-                                   VkImageLayout dstImageLayout, uint32_t regionCount,
-                                   const VkBufferImageCopy* pRegions,
+    void on_vkCmdCopyBufferToImage(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo,
+                                   VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
+                                   VkImage dstImage, VkImageLayout dstImageLayout,
+                                   uint32_t regionCount, const VkBufferImageCopy* pRegions,
                                    const VkDecoderContext& context);
 
-    void on_vkCmdCopyImage(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage,
+    void on_vkCmdCopyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                           VkCommandBuffer commandBuffer, VkImage srcImage,
+                           VkImageLayout srcImageLayout, VkImage dstImage,
                            VkImageLayout dstImageLayout, uint32_t regionCount,
                            const VkImageCopy* pRegions);
-    void on_vkCmdCopyImageToBuffer(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                   VkImage srcImage, VkImageLayout srcImageLayout,
-                                   VkBuffer dstBuffer, uint32_t regionCount,
-                                   const VkBufferImageCopy* pRegions);
+    void on_vkCmdCopyImageToBuffer(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo,
+                                   VkCommandBuffer commandBuffer, VkImage srcImage,
+                                   VkImageLayout srcImageLayout, VkBuffer dstBuffer,
+                                   uint32_t regionCount, const VkBufferImageCopy* pRegions);
 
     void on_vkCmdCopyBufferToImage2(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo,
                                     VkCommandBuffer commandBuffer,
                                     const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo,
                                     const VkDecoderContext& context);
 
-    void on_vkCmdCopyImage2(android::base::BumpPool* pool,
-                           VkCommandBuffer commandBuffer,
-                           const VkCopyImageInfo2* pCopyImageInfo);
+    void on_vkCmdCopyImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                            VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo);
     void on_vkCmdCopyImageToBuffer2(android::base::BumpPool* pool,
-                                   VkCommandBuffer commandBuffer,
-                                   const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo);
-
-    void on_vkCmdCopyBufferToImage2KHR(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo,
                                     VkCommandBuffer commandBuffer,
-                                    const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo,
-                                    const VkDecoderContext& context);
+                                    const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo);
 
-    void on_vkCmdCopyImage2KHR(android::base::BumpPool* pool,
-                           VkCommandBuffer commandBuffer,
-                           const VkCopyImageInfo2KHR* pCopyImageInfo);
+    void on_vkCmdCopyBufferToImage2KHR(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo,
+                                       VkCommandBuffer commandBuffer,
+                                       const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo,
+                                       const VkDecoderContext& context);
+
+    void on_vkCmdCopyImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                               VkCommandBuffer commandBuffer,
+                               const VkCopyImageInfo2KHR* pCopyImageInfo);
     void on_vkCmdCopyImageToBuffer2KHR(android::base::BumpPool* pool,
-                                   VkCommandBuffer commandBuffer,
-                                   const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo);
+                                       VkSnapshotApiCallInfo* snapshotInfo,
+                                       VkCommandBuffer commandBuffer,
+                                       const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo);
 
-    void on_vkGetImageMemoryRequirements(android::base::BumpPool* pool, VkDevice device,
+    void on_vkGetImageMemoryRequirements(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                          VkImage image, VkMemoryRequirements* pMemoryRequirements);
 
-    void on_vkGetImageMemoryRequirements2(android::base::BumpPool* pool, VkDevice device,
+    void on_vkGetImageMemoryRequirements2(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                           const VkImageMemoryRequirementsInfo2* pInfo,
                                           VkMemoryRequirements2* pMemoryRequirements);
 
-    void on_vkGetImageMemoryRequirements2KHR(android::base::BumpPool* pool, VkDevice device,
+    void on_vkGetImageMemoryRequirements2KHR(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                              const VkImageMemoryRequirementsInfo2* pInfo,
                                              VkMemoryRequirements2* pMemoryRequirements);
 
-    void on_vkGetBufferMemoryRequirements(android::base::BumpPool* pool, VkDevice device,
+    void on_vkGetBufferMemoryRequirements(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                           VkBuffer buffer,
                                           VkMemoryRequirements* pMemoryRequirements);
 
-    void on_vkGetBufferMemoryRequirements2(android::base::BumpPool* pool, VkDevice device,
+    void on_vkGetBufferMemoryRequirements2(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                            const VkBufferMemoryRequirementsInfo2* pInfo,
                                            VkMemoryRequirements2* pMemoryRequirements);
 
-    void on_vkGetBufferMemoryRequirements2KHR(android::base::BumpPool* pool, VkDevice device,
+    void on_vkGetBufferMemoryRequirements2KHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                               const VkBufferMemoryRequirementsInfo2* pInfo,
                                               VkMemoryRequirements2* pMemoryRequirements);
 
-    void on_vkCmdPipelineBarrier(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 VkPipelineStageFlags srcStageMask,
+    void on_vkCmdPipelineBarrier(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                 VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
                                  VkPipelineStageFlags dstStageMask,
                                  VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount,
                                  const VkMemoryBarrier* pMemoryBarriers,
@@ -405,7 +463,9 @@ class VkDecoderGlobalState {
                                  uint32_t imageMemoryBarrierCount,
                                  const VkImageMemoryBarrier* pImageMemoryBarriers);
 
-    void on_vkCmdPipelineBarrier2(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void on_vkCmdPipelineBarrier2(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo,
+                                  VkCommandBuffer commandBuffer,
                                   const VkDependencyInfo* pDependencyInfo);
 
     // Do we need to wrap vk(Create|Destroy)Instance to
@@ -418,18 +478,20 @@ class VkDecoderGlobalState {
     // This suggests that we should emulate the invalid behavior by
     // not destroying our own VkDevice maps on instance destruction.
 
-    VkResult on_vkAllocateMemory(android::base::BumpPool* pool, VkDevice device,
-                                 const VkMemoryAllocateInfo* pAllocateInfo,
+    VkResult on_vkAllocateMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                 VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo,
                                  const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
 
-    void on_vkFreeMemory(android::base::BumpPool* pool, VkDevice device, VkDeviceMemory memory,
+    void on_vkFreeMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                         VkDevice device, VkDeviceMemory memory,
                          const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkMapMemory(android::base::BumpPool* pool, VkDevice device, VkDeviceMemory memory,
-                            VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags,
-                            void** ppData);
+    VkResult on_vkMapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                            VkDevice device, VkDeviceMemory memory, VkDeviceSize offset,
+                            VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);
 
-    void on_vkUnmapMemory(android::base::BumpPool* pool, VkDevice device, VkDeviceMemory memory);
+    void on_vkUnmapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                          VkDevice device, VkDeviceMemory memory);
 
     uint8_t* getMappedHostPointer(VkDeviceMemory memory);
     VkDeviceSize getDeviceMemorySize(VkDeviceMemory memory);
@@ -449,285 +511,359 @@ class VkDecoderGlobalState {
     HostFeatureSupport getHostFeatureSupport() const;
 
     // VK_ANDROID_native_buffer
-    VkResult on_vkGetSwapchainGrallocUsageANDROID(android::base::BumpPool* pool, VkDevice device,
-                                                  VkFormat format, VkImageUsageFlags imageUsage,
-                                                  int* grallocUsage);
+    VkResult on_vkGetSwapchainGrallocUsageANDROID(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* snapshotInfo,
+                                                  VkDevice device, VkFormat format,
+                                                  VkImageUsageFlags imageUsage, int* grallocUsage);
     VkResult on_vkGetSwapchainGrallocUsage2ANDROID(
-        android::base::BumpPool* pool, VkDevice device, VkFormat format,
-        VkImageUsageFlags imageUsage, VkSwapchainImageUsageFlagsANDROID swapchainImageUsage,
-        uint64_t* grallocConsumerUsage, uint64_t* grallocProducerUsage);
-    VkResult on_vkAcquireImageANDROID(android::base::BumpPool* pool, VkDevice device, VkImage image,
-                                      int nativeFenceFd, VkSemaphore semaphore, VkFence fence);
-    VkResult on_vkQueueSignalReleaseImageANDROID(android::base::BumpPool* pool, VkQueue queue,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+        VkFormat format, VkImageUsageFlags imageUsage,
+        VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
+        uint64_t* grallocProducerUsage);
+    VkResult on_vkAcquireImageANDROID(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+                                      VkImage image, int nativeFenceFd, VkSemaphore semaphore,
+                                      VkFence fence);
+    VkResult on_vkQueueSignalReleaseImageANDROID(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                                  uint32_t waitSemaphoreCount,
                                                  const VkSemaphore* pWaitSemaphores, VkImage image,
                                                  int* pNativeFenceFd);
 
     // VK_GOOGLE_gfxstream
-    VkResult on_vkMapMemoryIntoAddressSpaceGOOGLE(android::base::BumpPool* pool, VkDevice device,
-                                                  VkDeviceMemory memory, uint64_t* pAddress);
-    VkResult on_vkGetMemoryHostAddressInfoGOOGLE(android::base::BumpPool* pool, VkDevice device,
-                                                 VkDeviceMemory memory, uint64_t* pAddress,
-                                                 uint64_t* pSize, uint64_t* pHostmemId);
-    VkResult on_vkGetBlobGOOGLE(android::base::BumpPool* pool, VkDevice device,
-                                VkDeviceMemory memory);
-
-    VkResult on_vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkMapMemoryIntoAddressSpaceGOOGLE(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* snapshotInfo,
+                                                  VkDevice device, VkDeviceMemory memory,
+                                                  uint64_t* pAddress);
+    VkResult on_vkGetMemoryHostAddressInfoGOOGLE(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* snapshotInfo,
+                                                 VkDevice device, VkDeviceMemory memory,
+                                                 uint64_t* pAddress, uint64_t* pSize,
+                                                 uint64_t* pHostmemId);
+    VkResult on_vkGetBlobGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                VkDevice device, VkDeviceMemory memory);
+
+    VkResult on_vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                        VkDeviceMemory memory,
                                        const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkAllocateCommandBuffers(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkAllocateCommandBuffers(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                          const VkCommandBufferAllocateInfo* pAllocateInfo,
                                          VkCommandBuffer* pCommandBuffers);
 
-    void on_vkCmdExecuteCommands(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 uint32_t commandBufferCount,
+    void on_vkCmdExecuteCommands(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                 VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                                  const VkCommandBuffer* pCommandBuffers);
 
-    VkResult on_vkQueueSubmit(android::base::BumpPool* pool, VkQueue queue, uint32_t submitCount,
-                              const VkSubmitInfo* pSubmits, VkFence fence);
+    VkResult on_vkQueueSubmit(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                              VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits,
+                              VkFence fence);
 
-    VkResult on_vkQueueSubmit2(android::base::BumpPool* pool, VkQueue queue, uint32_t submitCount,
-                               const VkSubmitInfo2* pSubmits, VkFence fence);
+    VkResult on_vkQueueSubmit2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                               VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits,
+                               VkFence fence);
 
-    VkResult on_vkQueueWaitIdle(android::base::BumpPool* pool, VkQueue queue);
+    VkResult on_vkQueueWaitIdle(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                VkQueue queue);
 
-    VkResult on_vkResetCommandBuffer(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    VkResult on_vkResetCommandBuffer(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* snapshotInfo,
+                                     VkCommandBuffer commandBuffer,
                                      VkCommandBufferResetFlags flags);
 
-    void on_vkFreeCommandBuffers(android::base::BumpPool* pool, VkDevice device,
-                                 VkCommandPool commandPool, uint32_t commandBufferCount,
+    void on_vkFreeCommandBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                 VkDevice device, VkCommandPool commandPool,
+                                 uint32_t commandBufferCount,
                                  const VkCommandBuffer* pCommandBuffers);
 
-    VkResult on_vkCreateCommandPool(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateCommandPool(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                     const VkCommandPoolCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkCommandPool* pCommandPool);
 
-    void on_vkDestroyCommandPool(android::base::BumpPool* pool, VkDevice device,
-                                 VkCommandPool commandPool,
+    void on_vkDestroyCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                 VkDevice device, VkCommandPool commandPool,
                                  const VkAllocationCallbacks* pAllocator);
 
-    VkResult on_vkResetCommandPool(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkResetCommandPool(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    VkCommandPool commandPool, VkCommandPoolResetFlags flags);
 
     void on_vkGetPhysicalDeviceExternalSemaphoreProperties(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
         VkExternalSemaphoreProperties* pExternalSemaphoreProperties);
 
     void on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
-        android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
         VkExternalSemaphoreProperties* pExternalSemaphoreProperties);
 
-    VkResult on_vkCreateSemaphore(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateSemaphore(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   const VkSemaphoreCreateInfo* pCreateInfo,
                                   const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
-    VkResult on_vkImportSemaphoreFdKHR(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkImportSemaphoreFdKHR(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                        const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo);
-    VkResult on_vkGetSemaphoreFdKHR(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkGetSemaphoreFdKHR(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
                                     const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd);
-    VkResult on_vkGetSemaphoreGOOGLE(android::base::BumpPool* pool, VkDevice boxed_device,
+    VkResult on_vkGetSemaphoreGOOGLE(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
                                      VkSemaphore semaphore, uint64_t syncId);
-    void on_vkDestroySemaphore(android::base::BumpPool* pool, VkDevice boxed_device,
-                               VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator);
-
-    VkResult on_vkCreateFence(android::base::BumpPool* pool, VkDevice device,
-                              const VkFenceCreateInfo* pCreateInfo,
+    void on_vkDestroySemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                               VkDevice boxed_device, VkSemaphore semaphore,
+                               const VkAllocationCallbacks* pAllocator);
+    VkResult on_vkWaitSemaphores(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkDevice boxed_device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout);
+    VkResult on_vkSignalSemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+        VkDevice boxed_device, const VkSemaphoreSignalInfo* pSignalInfo);
+
+    VkResult on_vkCreateFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                              VkDevice device, const VkFenceCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator, VkFence* pFence);
-    VkResult on_vkResetFences(android::base::BumpPool* pool, VkDevice device, uint32_t fenceCount,
-                              const VkFence* pFences);
-    void on_vkDestroyFence(android::base::BumpPool* pool, VkDevice device, VkFence fence,
-                           const VkAllocationCallbacks* pAllocator);
+    VkResult on_vkGetFenceStatus(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                 VkDevice device, VkFence pFence);
+    VkResult on_vkWaitForFences(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                VkDevice device, uint32_t fenceCount, const VkFence* pFences,
+                                VkBool32 waitAll, uint64_t timeout);
+    VkResult on_vkResetFences(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                              VkDevice device, uint32_t fenceCount, const VkFence* pFences);
+    void on_vkDestroyFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                           VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator);
 
     // Descriptor update templates
     VkResult on_vkCreateDescriptorUpdateTemplate(
-        android::base::BumpPool* pool, VkDevice boxed_device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
         const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator,
         VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);
 
     VkResult on_vkCreateDescriptorUpdateTemplateKHR(
-        android::base::BumpPool* pool, VkDevice boxed_device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
         const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator,
         VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);
 
-    void on_vkDestroyDescriptorUpdateTemplate(android::base::BumpPool* pool, VkDevice boxed_device,
+    void on_vkDestroyDescriptorUpdateTemplate(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* snapshotInfo,
+                                              VkDevice boxed_device,
                                               VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                               const VkAllocationCallbacks* pAllocator);
 
     void on_vkDestroyDescriptorUpdateTemplateKHR(
-        android::base::BumpPool* pool, VkDevice boxed_device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
         VkDescriptorUpdateTemplate descriptorUpdateTemplate,
         const VkAllocationCallbacks* pAllocator);
 
     void on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-        android::base::BumpPool* pool, VkDevice boxed_device, VkDescriptorSet descriptorSet,
-        VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-        uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
-        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
-        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
-        const VkBufferView* pBufferViews);
-
-    void on_vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-        android::base::BumpPool* pool, VkDevice boxed_device, VkDescriptorSet descriptorSet,
-        VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-        uint32_t bufferInfoCount, uint32_t bufferViewCount, uint32_t inlineUniformBlockCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
         const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
         const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
-        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews,
-        const uint8_t* pInlineUniformBlockData);
+        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews);
+
+    void on_vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
+        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
+        uint32_t inlineUniformBlockCount, const uint32_t* pImageInfoEntryIndices,
+        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
+        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
+        const VkBufferView* pBufferViews, const uint8_t* pInlineUniformBlockData);
 
-    VkResult on_vkBeginCommandBuffer(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    VkResult on_vkBeginCommandBuffer(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* snapshotInfo,
+                                     VkCommandBuffer commandBuffer,
                                      const VkCommandBufferBeginInfo* pBeginInfo,
                                      const VkDecoderContext& context);
     void on_vkBeginCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* snapshotInfo,
                                             VkCommandBuffer commandBuffer,
                                             const VkCommandBufferBeginInfo* pBeginInfo,
                                             const VkDecoderContext& context);
-    VkResult on_vkEndCommandBuffer(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                   const VkDecoderContext& context);
+    VkResult on_vkEndCommandBuffer(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo,
+                                   VkCommandBuffer commandBuffer, const VkDecoderContext& context);
     void on_vkEndCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* snapshotInfo,
                                           VkCommandBuffer commandBuffer,
                                           const VkDecoderContext& context);
     void on_vkResetCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* snapshotInfo,
                                             VkCommandBuffer commandBuffer,
                                             VkCommandBufferResetFlags flags);
     void on_vkCommandBufferHostSyncGOOGLE(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* snapshotInfo,
                                           VkCommandBuffer commandBuffer, uint32_t needHostSync,
                                           uint32_t sequenceNumber);
 
-    VkResult on_vkCreateImageWithRequirementsGOOGLE(android::base::BumpPool* pool, VkDevice device,
-                                                    const VkImageCreateInfo* pCreateInfo,
-                                                    const VkAllocationCallbacks* pAllocator,
-                                                    VkImage* pImage,
-                                                    VkMemoryRequirements* pMemoryRequirements);
-    VkResult on_vkCreateBufferWithRequirementsGOOGLE(android::base::BumpPool* pool, VkDevice device,
-                                                     const VkBufferCreateInfo* pCreateInfo,
-                                                     const VkAllocationCallbacks* pAllocator,
-                                                     VkBuffer* pBuffer,
-                                                     VkMemoryRequirements* pMemoryRequirements);
-
-    void on_vkCmdBindPipeline(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
-
-    void on_vkCmdBindDescriptorSets(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    VkResult on_vkCreateImageWithRequirementsGOOGLE(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+        const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+        VkImage* pImage, VkMemoryRequirements* pMemoryRequirements);
+    VkResult on_vkCreateBufferWithRequirementsGOOGLE(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
+        const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+        VkBuffer* pBuffer, VkMemoryRequirements* pMemoryRequirements);
+
+    void on_vkCmdBindPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                              VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
+                              VkPipeline pipeline);
+
+    void on_vkCmdBindDescriptorSets(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo,
+                                    VkCommandBuffer commandBuffer,
                                     VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
                                     uint32_t firstSet, uint32_t descriptorSetCount,
                                     const VkDescriptorSet* pDescriptorSets,
                                     uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets);
 
-    VkResult on_vkCreateRenderPass(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateRenderPass(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    const VkRenderPassCreateInfo* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator,
                                    VkRenderPass* pRenderPass);
-    VkResult on_vkCreateRenderPass2(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateRenderPass2(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                     const VkRenderPassCreateInfo2* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkRenderPass* pRenderPass);
-    VkResult on_vkCreateRenderPass2KHR(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateRenderPass2KHR(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                        const VkRenderPassCreateInfo2KHR* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkRenderPass* pRenderPass);
-    void on_vkDestroyRenderPass(android::base::BumpPool* pool, VkDevice device,
-                                VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator);
-    void on_vkCmdBeginRenderPass(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void on_vkDestroyRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                VkDevice device, VkRenderPass renderPass,
+                                const VkAllocationCallbacks* pAllocator);
+    void on_vkCmdBeginRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                 VkCommandBuffer commandBuffer,
                                  const VkRenderPassBeginInfo* pRenderPassBegin,
                                  VkSubpassContents contents);
-    void on_vkCmdBeginRenderPass2(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void on_vkCmdBeginRenderPass2(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo,
+                                  VkCommandBuffer commandBuffer,
                                   const VkRenderPassBeginInfo* pRenderPassBegin,
                                   const VkSubpassBeginInfo* pSubpassBeginInfo);
-    void on_vkCmdBeginRenderPass2KHR(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void on_vkCmdBeginRenderPass2KHR(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* snapshotInfo,
+                                     VkCommandBuffer commandBuffer,
                                      const VkRenderPassBeginInfo* pRenderPassBegin,
                                      const VkSubpassBeginInfo* pSubpassBeginInfo);
 
-    VkResult on_vkCreateFramebuffer(android::base::BumpPool* pool, VkDevice device,
+    VkResult on_vkCreateFramebuffer(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                     const VkFramebufferCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkFramebuffer* pFramebuffer);
-    void on_vkDestroyFramebuffer(android::base::BumpPool* pool, VkDevice device,
-                                 VkFramebuffer framebuffer,
+    void on_vkDestroyFramebuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
+                                 VkDevice device, VkFramebuffer framebuffer,
                                  const VkAllocationCallbacks* pAllocator);
 
-    void on_vkCmdCopyQueryPoolResults(android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      VkQueryPool queryPool, uint32_t firstQuery,
-                                      uint32_t queryCount, VkBuffer dstBuffer,
+    void on_vkCmdCopyQueryPoolResults(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* snapshotInfo,
+                                      VkCommandBuffer commandBuffer, VkQueryPool queryPool,
+                                      uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer,
                                       VkDeviceSize dstOffset, VkDeviceSize stride,
                                       VkQueryResultFlags flags);
 
     // VK_GOOGLE_gfxstream
-    void on_vkQueueHostSyncGOOGLE(android::base::BumpPool* pool, VkQueue queue,
+    void on_vkQueueHostSyncGOOGLE(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                   uint32_t needHostSync, uint32_t sequenceNumber);
-    void on_vkQueueSubmitAsyncGOOGLE(android::base::BumpPool* pool, VkQueue queue,
+    void on_vkQueueSubmitAsyncGOOGLE(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                      uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                      VkFence fence);
-    void on_vkQueueSubmitAsync2GOOGLE(android::base::BumpPool* pool, VkQueue queue,
+    void on_vkQueueSubmitAsync2GOOGLE(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                       uint32_t submitCount, const VkSubmitInfo2* pSubmits,
                                       VkFence fence);
-    void on_vkQueueWaitIdleAsyncGOOGLE(android::base::BumpPool* pool, VkQueue queue);
-    void on_vkQueueBindSparseAsyncGOOGLE(android::base::BumpPool* pool, VkQueue queue,
+    void on_vkQueueWaitIdleAsyncGOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue);
+    void on_vkQueueBindSparseAsyncGOOGLE(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                          uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
                                          VkFence fence);
 
     // VK_GOOGLE_gfxstream
-    void on_vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool, VkDevice device,
+    void on_vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                          VkFormat format, VkDeviceSize* pOffset,
                                          VkDeviceSize* pRowPitchAlignment);
-    void on_vkGetLinearImageLayout2GOOGLE(android::base::BumpPool* pool, VkDevice device,
+    void on_vkGetLinearImageLayout2GOOGLE(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                           const VkImageCreateInfo* pCreateInfo,
                                           VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment);
 
     // VK_GOOGLE_gfxstream
-    void on_vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool, VkQueue queue,
+    void on_vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                        VkCommandBuffer commandBuffer, VkDeviceSize dataSize,
                                        const void* pData, const VkDecoderContext& context);
-    void on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(android::base::BumpPool* pool, VkQueue queue,
-                                                    VkCommandBuffer commandBuffer,
+    void on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* snapshotInfo,
+                                                    VkQueue queue, VkCommandBuffer commandBuffer,
                                                     VkDeviceMemory deviceMemory,
                                                     VkDeviceSize dataOffset, VkDeviceSize dataSize,
                                                     const VkDecoderContext& context);
     void on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
-        android::base::BumpPool* pool, VkQueue queue, uint32_t descriptorPoolCount,
-        const VkDescriptorPool* pDescriptorPools, uint32_t descriptorSetCount,
-        const VkDescriptorSetLayout* pDescriptorSetLayouts, const uint64_t* pDescriptorSetPoolIds,
-        const uint32_t* pDescriptorSetWhichPool, const uint32_t* pDescriptorSetPendingAllocation,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
+        uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
+        uint32_t descriptorSetCount, const VkDescriptorSetLayout* pDescriptorSetLayouts,
+        const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
+        const uint32_t* pDescriptorSetPendingAllocation,
         const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
         const VkWriteDescriptorSet* pPendingDescriptorWrites);
-    void on_vkCollectDescriptorPoolIdsGOOGLE(android::base::BumpPool* pool, VkDevice device,
+    void on_vkCollectDescriptorPoolIdsGOOGLE(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                              VkDescriptorPool descriptorPool,
                                              uint32_t* pPoolIdCount, uint64_t* pPoolIds);
-    VkResult on_vkQueueBindSparse(android::base::BumpPool* pool, VkQueue queue,
+    VkResult on_vkQueueBindSparse(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                   uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
                                   VkFence fence);
     void on_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(android::base::BumpPool* pool,
+                                                        VkSnapshotApiCallInfo* snapshotInfo,
                                                         VkQueue queue, uint32_t waitSemaphoreCount,
                                                         const VkSemaphore* pWaitSemaphores,
                                                         VkImage image);
-    VkResult on_vkQueuePresentKHR(android::base::BumpPool* pool, VkQueue queue,
+    VkResult on_vkQueuePresentKHR(android::base::BumpPool* pool,
+                                  VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                   const VkPresentInfoKHR* pPresentInfo);
 
     VkResult on_vkCreateSamplerYcbcrConversion(
-        android::base::BumpPool* pool, VkDevice device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
         const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion);
     VkResult on_vkCreateSamplerYcbcrConversionKHR(
-        android::base::BumpPool* pool, VkDevice device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
         const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion);
-    void on_vkDestroySamplerYcbcrConversion(android::base::BumpPool* pool, VkDevice device,
+    void on_vkDestroySamplerYcbcrConversion(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                             VkSamplerYcbcrConversion ycbcrConversion,
                                             const VkAllocationCallbacks* pAllocator);
-    void on_vkDestroySamplerYcbcrConversionKHR(android::base::BumpPool* pool, VkDevice device,
+    void on_vkDestroySamplerYcbcrConversionKHR(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                                VkSamplerYcbcrConversion ycbcrConversion,
                                                const VkAllocationCallbacks* pAllocator);
 
     VkResult on_vkEnumeratePhysicalDeviceGroups(
-        android::base::BumpPool* pool, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkInstance instance,
+        uint32_t* pPhysicalDeviceGroupCount,
         VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);
     VkResult on_vkEnumeratePhysicalDeviceGroupsKHR(
-        android::base::BumpPool* pool, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkInstance instance,
+        uint32_t* pPhysicalDeviceGroupCount,
         VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);
 
     void on_DeviceLost();
@@ -738,8 +874,6 @@ class VkDecoderGlobalState {
     // Fence waits
     VkResult waitForFence(VkFence boxed_fence, uint64_t timeout);
 
-    VkResult getFenceStatus(VkFence boxed_fence);
-
     // Wait for present (vkQueueSignalReleaseImageANDROID). This explicitly
     // requires the image to be presented again versus how many times it's been
     // presented so far, so it ends up incrementing a "target present count"
@@ -788,212 +922,10 @@ class VkDecoderGlobalState {
 
     LIST_TRANSFORMED_TYPES(DEFINE_TRANSFORMED_TYPE_PROTOTYPE)
 
-    // boxed handles
-#define DEFINE_BOXED_DISPATCHABLE_HANDLE_API_DECL(type)                                 \
-    type new_boxed_##type(type underlying, VulkanDispatch* dispatch, bool ownDispatch); \
-    void delete_##type(type boxed);                                                     \
-    type unbox_##type(type boxed);                                                      \
-    type try_unbox_##type(type boxed);                                                  \
-    type unboxed_to_boxed_##type(type boxed);                                           \
-    VulkanDispatch* dispatch_##type(type boxed);
-
-#define DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_DECL(type)  \
-    type new_boxed_non_dispatchable_##type(type underlying); \
-    void delete_##type(type boxed);                          \
-    type unbox_##type(type boxed);                           \
-    type try_unbox_##type(type boxed);                       \
-    type unboxed_to_boxed_non_dispatchable_##type(type boxed);
-
-    GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_API_DECL)
-    GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_DECL)
-
    private:
     class Impl;
     std::unique_ptr<Impl> mImpl;
 };
 
-#define MAKE_HANDLE_MAPPING_FOREACH(type_name, map_impl, map_to_u64_impl, map_from_u64_impl)       \
-    void mapHandles_##type_name(type_name* handles, size_t count) override {                       \
-        for (size_t i = 0; i < count; ++i) {                                                       \
-            map_impl;                                                                              \
-        }                                                                                          \
-    }                                                                                              \
-    void mapHandles_##type_name##_u64(const type_name* handles, uint64_t* handle_u64s,             \
-                                      size_t count) override {                                     \
-        for (size_t i = 0; i < count; ++i) {                                                       \
-            map_to_u64_impl;                                                                       \
-        }                                                                                          \
-    }                                                                                              \
-    void mapHandles_u64_##type_name(const uint64_t* handle_u64s, type_name* handles, size_t count) \
-        override {                                                                                 \
-        for (size_t i = 0; i < count; ++i) {                                                       \
-            map_from_u64_impl;                                                                     \
-        }                                                                                          \
-    }
-
-#define BOXED_DISPATCHABLE_UNWRAP_IMPL(type_name)                                                  \
-    MAKE_HANDLE_MAPPING_FOREACH(                                                                   \
-        type_name, if (handles[i]) { handles[i] = m_state->unbox_##type_name(handles[i]); } else { \
-            handles[i] = (type_name) nullptr;                                                      \
-        };                                                                                         \
-        ,                                                                                          \
-        if (handles[i]) {                                                                          \
-            handle_u64s[i] = (uint64_t)m_state->unbox_##type_name(handles[i]);                     \
-        } else { handle_u64s[i] = 0; },                                                            \
-        if (handle_u64s[i]) {                                                                      \
-            handles[i] = m_state->unbox_##type_name((type_name)(uintptr_t)handle_u64s[i]);         \
-        } else { handles[i] = (type_name) nullptr; })
-
-#define BOXED_NON_DISPATCHABLE_UNWRAP_IMPL(type_name)                                              \
-    MAKE_HANDLE_MAPPING_FOREACH(                                                                   \
-        type_name, if (handles[i]) { handles[i] = m_state->unbox_##type_name(handles[i]); } else { \
-            handles[i] = (type_name) nullptr;                                                      \
-        };                                                                                         \
-        ,                                                                                          \
-        if (handles[i]) {                                                                          \
-            handle_u64s[i] = (uint64_t)m_state->unbox_##type_name(handles[i]);                     \
-        } else { handle_u64s[i] = 0; },                                                            \
-        if (handle_u64s[i]) {                                                                      \
-            handles[i] = m_state->unbox_##type_name((type_name)(uintptr_t)handle_u64s[i]);         \
-        } else { handles[i] = (type_name) nullptr; })
-
-class BoxedHandleUnwrapMapping : public VulkanHandleMapping {
-   public:
-    BoxedHandleUnwrapMapping(VkDecoderGlobalState* state) : VulkanHandleMapping(state) {}
-    virtual ~BoxedHandleUnwrapMapping() {}
-    GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(BOXED_DISPATCHABLE_UNWRAP_IMPL)
-    GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(BOXED_NON_DISPATCHABLE_UNWRAP_IMPL)
-};
-
-#define BOXED_DISPATCHABLE_WRAP_IMPL(type_name)                                                    \
-    MAKE_HANDLE_MAPPING_FOREACH(                                                                   \
-        type_name,                                                                                 \
-        if (handles[i]) { handles[i] = m_state->unboxed_to_boxed_##type_name(handles[i]); } else { \
-            handles[i] = (type_name) nullptr;                                                      \
-        };                                                                                         \
-        ,                                                                                          \
-        if (handles[i]) {                                                                          \
-            handle_u64s[i] = (uint64_t)m_state->unboxed_to_boxed_##type_name(handles[i]);          \
-        } else { handle_u64s[i] = 0; },                                                            \
-        if (handle_u64s[i]) {                                                                      \
-            handles[i] =                                                                           \
-                m_state->unboxed_to_boxed_##type_name((type_name)(uintptr_t)handle_u64s[i]);       \
-        } else { handles[i] = (type_name) nullptr; })
-
-#define BOXED_NON_DISPATCHABLE_WRAP_IMPL(type_name)                                           \
-    MAKE_HANDLE_MAPPING_FOREACH(                                                              \
-        type_name,                                                                            \
-        if (handles[i]) {                                                                     \
-            handles[i] = m_state->unboxed_to_boxed_non_dispatchable_##type_name(handles[i]);  \
-        } else { handles[i] = (type_name) nullptr; };                                         \
-        ,                                                                                     \
-        if (handles[i]) {                                                                     \
-            handle_u64s[i] =                                                                  \
-                (uint64_t)m_state->unboxed_to_boxed_non_dispatchable_##type_name(handles[i]); \
-        } else { handle_u64s[i] = 0; },                                                       \
-        if (handle_u64s[i]) {                                                                 \
-            handles[i] = m_state->unboxed_to_boxed_non_dispatchable_##type_name(              \
-                (type_name)(uintptr_t)handle_u64s[i]);                                        \
-        } else { handles[i] = (type_name) nullptr; })
-
-class BoxedHandleWrapMapping : public VulkanHandleMapping {
-   public:
-    BoxedHandleWrapMapping(VkDecoderGlobalState* state) : VulkanHandleMapping(state) {}
-    virtual ~BoxedHandleWrapMapping() {}
-    GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(BOXED_DISPATCHABLE_WRAP_IMPL)
-    GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(BOXED_NON_DISPATCHABLE_WRAP_IMPL)
-};
-
-// Not used, so we do not define.
-#define BOXED_DISPATCHABLE_CREATE_IMPL(type_name)                                  \
-    MAKE_HANDLE_MAPPING_FOREACH(type_name, (void)handles[i], (void)handle_u64s[i], \
-                                (void)handles[i];)
-
-// Not used, so we do not define.
-#define BOXED_DISPATCHABLE_DESTROY_IMPL(type_name)                                 \
-    MAKE_HANDLE_MAPPING_FOREACH(type_name, (void)handles[i], (void)handle_u64s[i], \
-                                (void)handles[i];)
-
-// We only use the create/destroy mappings for non dispatchable handles.
-#define BOXED_NON_DISPATCHABLE_CREATE_IMPL(type_name)                                    \
-    MAKE_HANDLE_MAPPING_FOREACH(                                                         \
-        type_name, handles[i] = new_boxed_non_dispatchable_##type_name(handles[i]);      \
-        , handle_u64s[i] = (uint64_t)new_boxed_non_dispatchable_##type_name(handles[i]), \
-        handles[i] = (type_name)new_boxed_non_dispatchable_##type_name(                  \
-            (type_name)(uintptr_t)handle_u64s[i]);)
-
-#define BOXED_NON_DISPATCHABLE_DESTROY_IMPL(type_name)                                           \
-    MAKE_HANDLE_MAPPING_FOREACH(type_name, delete_##type_name(handles[i]), (void)handle_u64s[i]; \
-                                delete_##type_name(handles[i]), (void)handles[i];                \
-                                delete_##type_name((type_name)handle_u64s[i]))
-
-#define BOXED_NON_DISPATCHABLE_UNWRAP_AND_DELETE_IMPL(type_name)                           \
-    MAKE_HANDLE_MAPPING_FOREACH(                                                           \
-        type_name,                                                                         \
-        if (handles[i]) {                                                                  \
-            auto boxed = handles[i];                                                       \
-            handles[i] = m_state->unbox_##type_name(handles[i]);                           \
-            delete_##type_name(boxed);                                                     \
-        } else { handles[i] = (type_name) nullptr; };                                      \
-        ,                                                                                  \
-        if (handles[i]) {                                                                  \
-            auto boxed = handles[i];                                                       \
-            handle_u64s[i] = (uint64_t)m_state->unbox_##type_name(handles[i]);             \
-            delete_##type_name(boxed);                                                     \
-        } else { handle_u64s[i] = 0; },                                                    \
-        if (handle_u64s[i]) {                                                              \
-            auto boxed = (type_name)(uintptr_t)handle_u64s[i];                             \
-            handles[i] = m_state->unbox_##type_name((type_name)(uintptr_t)handle_u64s[i]); \
-            delete_##type_name(boxed);                                                     \
-        } else { handles[i] = (type_name) nullptr; })
-
-class BoxedHandleCreateMapping : public VulkanHandleMapping {
-   public:
-    BoxedHandleCreateMapping(VkDecoderGlobalState* state) : VulkanHandleMapping(state) {}
-    virtual ~BoxedHandleCreateMapping() {}
-    GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(BOXED_DISPATCHABLE_CREATE_IMPL)
-    GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(BOXED_NON_DISPATCHABLE_CREATE_IMPL)
-};
-
-class BoxedHandleDestroyMapping : public VulkanHandleMapping {
-   public:
-    BoxedHandleDestroyMapping(VkDecoderGlobalState* state) : VulkanHandleMapping(state) {}
-    virtual ~BoxedHandleDestroyMapping() {}
-    GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(BOXED_DISPATCHABLE_DESTROY_IMPL)
-    GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(BOXED_NON_DISPATCHABLE_DESTROY_IMPL)
-};
-
-class BoxedHandleUnwrapAndDeleteMapping : public VulkanHandleMapping {
-   public:
-    BoxedHandleUnwrapAndDeleteMapping(VkDecoderGlobalState* state) : VulkanHandleMapping(state) {}
-    virtual ~BoxedHandleUnwrapAndDeleteMapping() {}
-    GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(BOXED_DISPATCHABLE_DESTROY_IMPL)
-    GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(BOXED_NON_DISPATCHABLE_UNWRAP_AND_DELETE_IMPL)
-};
-
-#define HANDLE_MAPPING_DECLS(type_name)                                                            \
-    void mapHandles_##type_name(type_name* handles, size_t count) override;                        \
-    void mapHandles_##type_name##_u64(const type_name* handles, uint64_t* handle_u64s,             \
-                                      size_t count) override;                                      \
-    void mapHandles_u64_##type_name(const uint64_t* handle_u64s, type_name* handles, size_t count) \
-        override;
-
-class BoxedHandleUnwrapAndDeletePreserveBoxedMapping : public VulkanHandleMapping {
-   public:
-    BoxedHandleUnwrapAndDeletePreserveBoxedMapping(VkDecoderGlobalState* state)
-        : VulkanHandleMapping(state) {}
-    void setup(android::base::BumpPool* pool, uint64_t** bufPtr);
-    virtual ~BoxedHandleUnwrapAndDeletePreserveBoxedMapping() {}
-
-    GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(HANDLE_MAPPING_DECLS)
-    GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(HANDLE_MAPPING_DECLS)
-
-   private:
-    void allocPreserve(size_t count);
-
-    android::base::BumpPool* mPool = nullptr;
-    uint64_t** mPreserveBufPtr = nullptr;
-};
-
 }  // namespace vk
 }  // namespace gfxstream
diff --git a/host/vulkan/VkDecoderInternalStructs.h b/host/vulkan/VkDecoderInternalStructs.h
index 0b90d6d5d..83bb8cb75 100644
--- a/host/vulkan/VkDecoderInternalStructs.h
+++ b/host/vulkan/VkDecoderInternalStructs.h
@@ -22,6 +22,8 @@
 
 #include <stdlib.h>
 
+#include <condition_variable>
+#include <mutex>
 #include <optional>
 #include <set>
 #include <string>
@@ -31,6 +33,7 @@
 #include "DeviceOpTracker.h"
 #include "Handle.h"
 #include "VkEmulatedPhysicalDeviceMemory.h"
+#include "VkEmulatedPhysicalDeviceQueue.h"
 #include "aemu/base/files/Stream.h"
 #include "aemu/base/memory/SharedMemory.h"
 #include "aemu/base/synchronization/ConditionVariable.h"
@@ -109,7 +112,7 @@ class ExternalFencePool {
     VkDevice mDevice;
     android::base::Lock mLock;
     std::vector<VkFence> mPool;
-    int mMaxSize;
+    size_t mMaxSize;
 };
 
 class PrivateMemory {
@@ -186,12 +189,8 @@ struct PhysicalDeviceInfo {
     VkInstance instance = VK_NULL_HANDLE;
     VkPhysicalDeviceProperties props;
     std::unique_ptr<EmulatedPhysicalDeviceMemoryProperties> memoryPropertiesHelper;
-    std::vector<VkQueueFamilyProperties> queueFamilyProperties;
+    std::unique_ptr<EmulatedPhysicalDeviceQueueProperties> queuePropertiesHelper;
     VkPhysicalDevice boxed = nullptr;
-
-    // Indicates that if the graphics queue family properties are overridden for
-    // this physical device to include a virtual queue.
-    bool hasVirtualGraphicsQueues = false;
 };
 
 struct ExternalFenceInfo {
@@ -233,7 +232,7 @@ struct DeviceInfo {
 };
 
 struct QueueInfo {
-    std::shared_ptr<android::base::Lock> physicalQueueLock;
+    std::shared_ptr<std::mutex> queueMutex;
     VkDevice device;
     uint32_t queueFamilyIndex;
     VkQueue boxed = nullptr;
@@ -304,13 +303,13 @@ struct FenceInfo {
     VkFence boxed = VK_NULL_HANDLE;
     VulkanDispatch* vk = nullptr;
 
-    android::base::StaticLock lock;
-    android::base::ConditionVariable cv;
+    std::mutex mutex;
+    std::condition_variable cv;
 
     enum class State {
-        kWaitable,
-        kNotWaitable,
-        kWaiting,
+        kNotWaitable,   // Newly created or reset
+        kWaitable,      // A submission is made, or created as signaled
+        kWaiting,       // Fence waitable status is acknowledged
     };
     State state = State::kNotWaitable;
 
@@ -385,6 +384,7 @@ struct DescriptorSetInfo {
         std::optional<HandleType> boundColorBuffer;
     };
 
+    VkDevice device;
     VkDescriptorPool pool;
     VkDescriptorSetLayout unboxedLayout = 0;
     std::vector<std::vector<DescriptorWrite>> allWrites;
@@ -399,6 +399,10 @@ struct PipelineCacheInfo {
     VkDevice device;
 };
 
+struct PipelineLayoutInfo {
+    VkDevice device;
+};
+
 struct PipelineInfo {
     VkDevice device;
 };
@@ -433,10 +437,8 @@ struct CommandBufferInfo {
     std::unordered_set<HandleType> releasedColorBuffers;
     std::unordered_map<HandleType, VkImageLayout> cbLayouts;
     std::unordered_map<VkImage, VkImageLayout> imageLayouts;
-    std::unordered_set<HandleType> imageBarrierColorBuffers;
 
     void reset() {
-        preprocessFuncs.clear();
         subCmds.clear();
         computePipeline = VK_NULL_HANDLE;
         firstSet = 0;
@@ -476,6 +478,7 @@ struct InstanceObjects {
         std::unordered_map<VkImageView, ImageViewInfo> imageViews;
         std::unordered_map<VkPipeline, PipelineInfo> pipelines;
         std::unordered_map<VkPipelineCache, PipelineCacheInfo> pipelineCaches;
+        std::unordered_map<VkPipelineLayout, PipelineLayoutInfo> pipelineLayouts;
         std::unordered_map<VkQueue, QueueInfo> queues;
         std::unordered_map<VkRenderPass, RenderPassInfo> renderPasses;
         std::unordered_map<VkSampler, SamplerInfo> samplers;
diff --git a/host/vulkan/VkDecoderSnapshot.cpp b/host/vulkan/VkDecoderSnapshot.cpp
index 490501230..31ff1c423 100644
--- a/host/vulkan/VkDecoderSnapshot.cpp
+++ b/host/vulkan/VkDecoderSnapshot.cpp
@@ -33,176 +33,202 @@
 
 #include "VkDecoderSnapshot.h"
 
+#include <mutex>
+
 #include "VkDecoderGlobalState.h"
 #include "VkReconstruction.h"
+#include "VulkanBoxedHandles.h"
 #include "VulkanHandleMapping.h"
-#include "aemu/base/synchronization/Lock.h"
+#include "aemu/base/ThreadAnnotations.h"
 
-using namespace gfxstream::vk;
 using emugl::GfxApiLogger;
 using emugl::HealthMonitor;
 
+namespace gfxstream {
+namespace vk {
+
 class VkDecoderSnapshot::Impl {
    public:
     Impl() {}
 
-    void save(android::base::Stream* stream) { mReconstruction.save(stream); }
+    void clear() {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
+        mReconstruction.clear();
+    }
+
+    void saveReplayBuffers(android::base::Stream* stream) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
+        mReconstruction.saveReplayBuffers(stream);
+    }
+
+    static void loadReplayBuffers(android::base::Stream* stream,
+                                  std::vector<uint64_t>* outHandleBuffer,
+                                  std::vector<uint8_t>* outDecoderBuffer) {
+        VkReconstruction::loadReplayBuffers(stream, outHandleBuffer, outDecoderBuffer);
+    }
 
-    void load(android::base::Stream* stream, GfxApiLogger& gfx_logger,
-              HealthMonitor<>* healthMonitor) {
-        mReconstruction.load(stream, gfx_logger, healthMonitor);
+    VkSnapshotApiCallInfo* createApiCallInfo() {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
+        return mReconstruction.createApiCallInfo();
     }
 
-    void createExtraHandlesForNextApi(const uint64_t* created, uint32_t count) {
-        mLock.lock();
-        mReconstruction.createExtraHandlesForNextApi(created, count);
+    void destroyApiCallInfoIfUnused(VkSnapshotApiCallInfo* info) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
+        return mReconstruction.destroyApiCallInfoIfUnused(info);
     }
 #ifdef VK_VERSION_1_0
-    void vkCreateInstance(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result,
-                          const VkInstanceCreateInfo* pCreateInfo,
+    void vkCreateInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, const VkInstanceCreateInfo* pCreateInfo,
                           const VkAllocationCallbacks* pAllocator, VkInstance* pInstance) {
         if (!pInstance) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pInstance create
         mReconstruction.addHandles((const uint64_t*)pInstance, 1);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateInstance, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pInstance, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pInstance, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pInstance, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pInstance, 1);
     }
-    void vkDestroyInstance(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkInstance instance,
-                           const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkInstance instance, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // instance destroy
         mReconstruction.removeHandles((const uint64_t*)(&instance), 1, true);
     }
-    void vkEnumeratePhysicalDevices(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    VkInstance instance, uint32_t* pPhysicalDeviceCount,
+    void vkEnumeratePhysicalDevices(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, VkInstance instance,
+                                    uint32_t* pPhysicalDeviceCount,
                                     VkPhysicalDevice* pPhysicalDevices) {
         if (!pPhysicalDevices) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pPhysicalDevices create
         mReconstruction.addHandles((const uint64_t*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
         mReconstruction.addHandleDependency((const uint64_t*)pPhysicalDevices,
                                             (*(pPhysicalDeviceCount)),
                                             (uint64_t)(uintptr_t)instance);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkEnumeratePhysicalDevices, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         if (pPhysicalDeviceCount) {
             mReconstruction.forEachHandleAddApi((const uint64_t*)pPhysicalDevices,
-                                                (*(pPhysicalDeviceCount)), apiHandle,
+                                                (*(pPhysicalDeviceCount)), apiCallHandle,
                                                 VkReconstruction::CREATED);
-            mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pPhysicalDevices,
-                                                    (*(pPhysicalDeviceCount)));
+            mReconstruction.setCreatedHandlesForApi(
+                apiCallHandle, (const uint64_t*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
         }
     }
-    void vkGetPhysicalDeviceFeatures(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+    void vkGetPhysicalDeviceFeatures(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkPhysicalDevice physicalDevice,
                                      VkPhysicalDeviceFeatures* pFeatures) {}
-    void vkGetPhysicalDeviceFormatProperties(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFormatProperties(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkPhysicalDevice physicalDevice, VkFormat format,
                                              VkFormatProperties* pFormatProperties) {}
-    void vkGetPhysicalDeviceImageFormatProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
-        VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags,
-        VkImageFormatProperties* pImageFormatProperties) {}
-    void vkGetPhysicalDeviceProperties(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceImageFormatProperties(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* apiCallInfo,
+                                                  const uint8_t* apiCallPacket,
+                                                  size_t apiCallPacketSize, VkResult input_result,
+                                                  VkPhysicalDevice physicalDevice, VkFormat format,
+                                                  VkImageType type, VkImageTiling tiling,
+                                                  VkImageUsageFlags usage, VkImageCreateFlags flags,
+                                                  VkImageFormatProperties* pImageFormatProperties) {
+    }
+    void vkGetPhysicalDeviceProperties(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkPhysicalDevice physicalDevice,
                                        VkPhysicalDeviceProperties* pProperties) {}
-    void vkGetPhysicalDeviceQueueFamilyProperties(const uint8_t* snapshotTraceBegin,
-                                                  size_t snapshotTraceBytes,
-                                                  android::base::BumpPool* pool,
-                                                  VkPhysicalDevice physicalDevice,
-                                                  uint32_t* pQueueFamilyPropertyCount,
-                                                  VkQueueFamilyProperties* pQueueFamilyProperties) {
-    }
-    void vkGetPhysicalDeviceMemoryProperties(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceQueueFamilyProperties(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties) {}
+    void vkGetPhysicalDeviceMemoryProperties(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkPhysicalDevice physicalDevice,
                                              VkPhysicalDeviceMemoryProperties* pMemoryProperties) {}
-    void vkGetInstanceProcAddr(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, PFN_vkVoidFunction input_result,
-                               VkInstance instance, const char* pName) {}
-    void vkGetDeviceProcAddr(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, PFN_vkVoidFunction input_result,
-                             VkDevice device, const char* pName) {}
-    void vkCreateDevice(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkResult input_result,
-                        VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo,
+    void vkGetInstanceProcAddr(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               PFN_vkVoidFunction input_result, VkInstance instance,
+                               const char* pName) {}
+    void vkGetDeviceProcAddr(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             PFN_vkVoidFunction input_result, VkDevice device, const char* pName) {}
+    void vkCreateDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkResult input_result, VkPhysicalDevice physicalDevice,
+                        const VkDeviceCreateInfo* pCreateInfo,
                         const VkAllocationCallbacks* pAllocator, VkDevice* pDevice) {
         if (!pDevice) return;
-        mLock.tryLock();
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pDevice create
         mReconstruction.addHandles((const uint64_t*)pDevice, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pDevice, 1,
                                             (uint64_t)(uintptr_t)physicalDevice);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateDevice, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pDevice, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pDevice, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pDevice, 1);
-        mLock.unlock();
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pDevice, 1);
     }
-    void vkDestroyDevice(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkDevice device,
+    void vkDestroyDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                          const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // device destroy
         mReconstruction.removeHandles((const uint64_t*)(&device), 1, true);
     }
-    void vkEnumerateInstanceExtensionProperties(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
-                                                VkResult input_result, const char* pLayerName,
-                                                uint32_t* pPropertyCount,
+    void vkEnumerateInstanceExtensionProperties(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize, VkResult input_result,
+                                                const char* pLayerName, uint32_t* pPropertyCount,
                                                 VkExtensionProperties* pProperties) {}
-    void vkEnumerateDeviceExtensionProperties(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
+    void vkEnumerateDeviceExtensionProperties(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkResult input_result,
                                               VkPhysicalDevice physicalDevice,
                                               const char* pLayerName, uint32_t* pPropertyCount,
                                               VkExtensionProperties* pProperties) {}
-    void vkEnumerateInstanceLayerProperties(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkResult input_result,
-                                            uint32_t* pPropertyCount,
+    void vkEnumerateInstanceLayerProperties(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, uint32_t* pPropertyCount,
                                             VkLayerProperties* pProperties) {}
-    void vkEnumerateDeviceLayerProperties(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkEnumerateDeviceLayerProperties(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkPhysicalDevice physicalDevice,
                                           uint32_t* pPropertyCount,
                                           VkLayerProperties* pProperties) {}
-    void vkGetDeviceQueue(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkDevice device, uint32_t queueFamilyIndex,
-                          uint32_t queueIndex, VkQueue* pQueue) {}
-    void vkQueueSubmit(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
-                       uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence) {}
-    void vkQueueWaitIdle(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkQueue queue) {}
-    void vkDeviceWaitIdle(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device) {}
-    void vkAllocateMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkGetDeviceQueue(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                          uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue) {}
+    void vkQueueSubmit(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkQueue queue, uint32_t submitCount,
+                       const VkSubmitInfo* pSubmits, VkFence fence) {}
+    void vkQueueWaitIdle(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkQueue queue) {}
+    void vkDeviceWaitIdle(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device) {}
+    void vkAllocateMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device,
                           const VkMemoryAllocateInfo* pAllocateInfo,
                           const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory) {
         if (!pMemory) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pMemory create
         mReconstruction.addHandles((const uint64_t*)pMemory, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pMemory, 1,
@@ -223,45 +249,48 @@ class VkDecoderSnapshot::Impl {
                         dedicatedAllocateInfo->buffer));
             }
         }
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkAllocateMemory, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pMemory, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pMemory, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pMemory, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pMemory, 1);
     }
-    void vkFreeMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                      android::base::BumpPool* pool, VkDevice device, VkDeviceMemory memory,
-                      const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkFreeMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                      const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                      VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // memory destroy
         mReconstruction.removeHandles((const uint64_t*)(&memory), 1, true);
     }
-    void vkMapMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                     android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                     VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size,
+    void vkMapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                     const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+                     VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size,
                      VkMemoryMapFlags flags, void** ppData) {}
-    void vkUnmapMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkDevice device, VkDeviceMemory memory) {}
-    void vkFlushMappedMemoryRanges(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkResult input_result,
-                                   VkDevice device, uint32_t memoryRangeCount,
+    void vkUnmapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                       VkDeviceMemory memory) {}
+    void vkFlushMappedMemoryRanges(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+                                   uint32_t memoryRangeCount,
                                    const VkMappedMemoryRange* pMemoryRanges) {}
-    void vkInvalidateMappedMemoryRanges(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkInvalidateMappedMemoryRanges(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         uint32_t memoryRangeCount,
                                         const VkMappedMemoryRange* pMemoryRanges) {}
-    void vkGetDeviceMemoryCommitment(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkDevice device,
-                                     VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes) {
-    }
-    void vkBindBufferMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                            VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
+    void vkGetDeviceMemoryCommitment(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkDevice device, VkDeviceMemory memory,
+                                     VkDeviceSize* pCommittedMemoryInBytes) {}
+    void vkBindBufferMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device, VkBuffer buffer,
+                            VkDeviceMemory memory, VkDeviceSize memoryOffset) {
         VkBuffer boxed_VkBuffer = unboxed_to_boxed_non_dispatchable_VkBuffer((&buffer)[0]);
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // buffer create
         mReconstruction.addHandleDependency(
             (const uint64_t*)&boxed_VkBuffer, 1,
@@ -270,18 +299,17 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.addHandleDependency((const uint64_t*)&boxed_VkBuffer, 1,
                                             (uint64_t)(uintptr_t)((&boxed_VkBuffer)[0]),
                                             VkReconstruction::BOUND_MEMORY);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkBindBufferMemory, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkBuffer, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkBuffer, 1, apiCallHandle,
                                             VkReconstruction::BOUND_MEMORY);
     }
-    void vkBindImageMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                           VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
+    void vkBindImageMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device, VkImage image,
+                           VkDeviceMemory memory, VkDeviceSize memoryOffset) {
         VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage((&image)[0]);
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // image create
         mReconstruction.addHandleDependency(
             (const uint64_t*)&boxed_VkImage, 1,
@@ -290,241 +318,239 @@ class VkDecoderSnapshot::Impl {
         mReconstruction.addHandleDependency((const uint64_t*)&boxed_VkImage, 1,
                                             (uint64_t)(uintptr_t)((&boxed_VkImage)[0]),
                                             VkReconstruction::BOUND_MEMORY);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkBindImageMemory, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkImage, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkImage, 1, apiCallHandle,
                                             VkReconstruction::BOUND_MEMORY);
     }
-    void vkGetBufferMemoryRequirements(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkDevice device,
-                                       VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements) {
-    }
-    void vkGetImageMemoryRequirements(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkDevice device, VkImage image,
+    void vkGetBufferMemoryRequirements(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkDevice device, VkBuffer buffer,
+                                       VkMemoryRequirements* pMemoryRequirements) {}
+    void vkGetImageMemoryRequirements(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkDevice device, VkImage image,
                                       VkMemoryRequirements* pMemoryRequirements) {}
     void vkGetImageSparseMemoryRequirements(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device, VkImage image,
+        uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {}
     void vkGetPhysicalDeviceSparseImageFormatProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
-        VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling,
-        uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties) {}
-    void vkQueueBindSparse(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
-                           uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
-                           VkFence fence) {}
-    void vkCreateFence(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                       const VkFenceCreateInfo* pCreateInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage,
+        VkImageTiling tiling, uint32_t* pPropertyCount,
+        VkSparseImageFormatProperties* pProperties) {}
+    void vkQueueBindSparse(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkQueue queue, uint32_t bindInfoCount,
+                           const VkBindSparseInfo* pBindInfo, VkFence fence) {}
+    void vkCreateFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkDevice device, const VkFenceCreateInfo* pCreateInfo,
                        const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
         if (!pFence) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pFence create
         mReconstruction.addHandles((const uint64_t*)pFence, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pFence, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateFence, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pFence, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pFence, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pFence, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pFence, 1);
     }
-    void vkDestroyFence(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkDevice device, VkFence fence,
-                        const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                        VkFence fence, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // fence destroy
         mReconstruction.removeHandles((const uint64_t*)(&fence), 1, true);
     }
-    void vkResetFences(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                       uint32_t fenceCount, const VkFence* pFences) {}
-    void vkGetFenceStatus(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                          VkFence fence) {}
-    void vkWaitForFences(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                         uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll,
-                         uint64_t timeout) {}
-    void vkCreateSemaphore(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkResetFences(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkDevice device, uint32_t fenceCount,
+                       const VkFence* pFences) {}
+    void vkGetFenceStatus(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device, VkFence fence) {}
+    void vkWaitForFences(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkDevice device, uint32_t fenceCount,
+                         const VkFence* pFences, VkBool32 waitAll, uint64_t timeout) {}
+    void vkCreateSemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device,
                            const VkSemaphoreCreateInfo* pCreateInfo,
                            const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore) {
         if (!pSemaphore) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pSemaphore create
         mReconstruction.addHandles((const uint64_t*)pSemaphore, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pSemaphore, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateSemaphore, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pSemaphore, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pSemaphore, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pSemaphore, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pSemaphore, 1);
     }
-    void vkDestroySemaphore(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkDevice device, VkSemaphore semaphore,
-                            const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroySemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                            VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // semaphore destroy
         mReconstruction.removeHandles((const uint64_t*)(&semaphore), 1, true);
     }
-    void vkCreateEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                       const VkEventCreateInfo* pCreateInfo,
+    void vkCreateEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkDevice device, const VkEventCreateInfo* pCreateInfo,
                        const VkAllocationCallbacks* pAllocator, VkEvent* pEvent) {
         if (!pEvent) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pEvent create
         mReconstruction.addHandles((const uint64_t*)pEvent, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pEvent, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateEvent, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pEvent, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pEvent, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pEvent, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pEvent, 1);
     }
-    void vkDestroyEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkDevice device, VkEvent event,
-                        const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                        VkEvent event, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // event destroy
         mReconstruction.removeHandles((const uint64_t*)(&event), 1, true);
     }
-    void vkGetEventStatus(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                          VkEvent event) {}
-    void vkSetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                    android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                    VkEvent event) {}
-    void vkResetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                      android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                      VkEvent event) {}
-    void vkCreateQueryPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkGetEventStatus(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device, VkEvent event) {}
+    void vkSetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                    const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+                    VkDevice device, VkEvent event) {}
+    void vkResetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                      const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+                      VkDevice device, VkEvent event) {}
+    void vkCreateQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device,
                            const VkQueryPoolCreateInfo* pCreateInfo,
                            const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool) {
         if (!pQueryPool) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pQueryPool create
         mReconstruction.addHandles((const uint64_t*)pQueryPool, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pQueryPool, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateQueryPool, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pQueryPool, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pQueryPool, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pQueryPool, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pQueryPool, 1);
     }
-    void vkDestroyQueryPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkDevice device, VkQueryPool queryPool,
-                            const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                            VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // queryPool destroy
         mReconstruction.removeHandles((const uint64_t*)(&queryPool), 1, true);
     }
-    void vkGetQueryPoolResults(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkQueryPool queryPool, uint32_t firstQuery,
-                               uint32_t queryCount, size_t dataSize, void* pData,
-                               VkDeviceSize stride, VkQueryResultFlags flags) {}
-    void vkCreateBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkGetQueryPoolResults(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, VkQueryPool queryPool,
+                               uint32_t firstQuery, uint32_t queryCount, size_t dataSize,
+                               void* pData, VkDeviceSize stride, VkQueryResultFlags flags) {}
+    void vkCreateBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkResult input_result, VkDevice device,
                         const VkBufferCreateInfo* pCreateInfo,
                         const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
         if (!pBuffer) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pBuffer create
         mReconstruction.addHandles((const uint64_t*)pBuffer, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pBuffer, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateBuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pBuffer, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pBuffer, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pBuffer, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pBuffer, 1);
     }
-    void vkDestroyBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkDevice device, VkBuffer buffer,
-                         const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                         VkBuffer buffer, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // buffer destroy
         mReconstruction.removeHandles((const uint64_t*)(&buffer), 1, true);
     }
-    void vkCreateBufferView(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateBufferView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device,
                             const VkBufferViewCreateInfo* pCreateInfo,
                             const VkAllocationCallbacks* pAllocator, VkBufferView* pView) {
         if (!pView) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pView create
         mReconstruction.addHandles((const uint64_t*)pView, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pView, 1, (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateBufferView, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pView, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pView, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pView, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pView, 1);
     }
-    void vkDestroyBufferView(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkDevice device,
-                             VkBufferView bufferView, const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyBufferView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkDevice device, VkBufferView bufferView,
+                             const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // bufferView destroy
         mReconstruction.removeHandles((const uint64_t*)(&bufferView), 1, true);
     }
-    void vkCreateImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                       const VkImageCreateInfo* pCreateInfo,
+    void vkCreateImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkDevice device, const VkImageCreateInfo* pCreateInfo,
                        const VkAllocationCallbacks* pAllocator, VkImage* pImage) {
         if (!pImage) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pImage create
         mReconstruction.addHandles((const uint64_t*)pImage, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pImage, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateImage, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pImage, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pImage, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pImage, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pImage, 1);
     }
-    void vkDestroyImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkDevice device, VkImage image,
-                        const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                        VkImage image, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // image destroy
         mReconstruction.removeHandles((const uint64_t*)(&image), 1, true);
     }
-    void vkGetImageSubresourceLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkDevice device, VkImage image,
+    void vkGetImageSubresourceLayout(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkDevice device, VkImage image,
                                      const VkImageSubresource* pSubresource,
                                      VkSubresourceLayout* pLayout) {}
-    void vkCreateImageView(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateImageView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device,
                            const VkImageViewCreateInfo* pCreateInfo,
                            const VkAllocationCallbacks* pAllocator, VkImageView* pView) {
         if (!pView) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pView create
         mReconstruction.addHandles((const uint64_t*)pView, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pView, 1, (uint64_t)(uintptr_t)device);
@@ -532,92 +558,88 @@ class VkDecoderSnapshot::Impl {
             (const uint64_t*)pView, 1,
             (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkImage(pCreateInfo->image),
             VkReconstruction::CREATED, VkReconstruction::BOUND_MEMORY);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateImageView, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pView, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pView, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pView, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pView, 1);
     }
-    void vkDestroyImageView(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkDevice device, VkImageView imageView,
-                            const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyImageView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                            VkImageView imageView, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // imageView destroy
         mReconstruction.removeHandles((const uint64_t*)(&imageView), 1, true);
     }
-    void vkCreateShaderModule(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateShaderModule(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkDevice device,
                               const VkShaderModuleCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator,
                               VkShaderModule* pShaderModule) {
         if (!pShaderModule) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pShaderModule create
         mReconstruction.addHandles((const uint64_t*)pShaderModule, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pShaderModule, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateShaderModule, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pShaderModule, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pShaderModule, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pShaderModule, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pShaderModule, 1);
     }
-    void vkDestroyShaderModule(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkDevice device,
-                               VkShaderModule shaderModule,
+    void vkDestroyShaderModule(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkDevice device, VkShaderModule shaderModule,
                                const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // shaderModule destroy
         mReconstruction.removeHandles((const uint64_t*)(&shaderModule), 1, false);
     }
-    void vkCreatePipelineCache(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo,
+    void vkCreatePipelineCache(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device,
+                               const VkPipelineCacheCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator,
                                VkPipelineCache* pPipelineCache) {
         if (!pPipelineCache) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pPipelineCache create
         mReconstruction.addHandles((const uint64_t*)pPipelineCache, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pPipelineCache, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreatePipelineCache, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelineCache, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelineCache, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pPipelineCache, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPipelineCache, 1);
     }
-    void vkDestroyPipelineCache(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkDevice device,
-                                VkPipelineCache pipelineCache,
+    void vkDestroyPipelineCache(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkDevice device, VkPipelineCache pipelineCache,
                                 const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pipelineCache destroy
         mReconstruction.removeHandles((const uint64_t*)(&pipelineCache), 1, true);
     }
-    void vkGetPipelineCacheData(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize,
-                                void* pData) {}
-    void vkMergePipelineCaches(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount,
-                               const VkPipelineCache* pSrcCaches) {}
-    void vkCreateGraphicsPipelines(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkResult input_result,
-                                   VkDevice device, VkPipelineCache pipelineCache,
-                                   uint32_t createInfoCount,
+    void vkGetPipelineCacheData(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                VkPipelineCache pipelineCache, size_t* pDataSize, void* pData) {}
+    void vkMergePipelineCaches(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, VkPipelineCache dstCache,
+                               uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches) {}
+    void vkCreateGraphicsPipelines(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+                                   VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                    const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                    const VkAllocationCallbacks* pAllocator,
                                    VkPipeline* pPipelines) {
         if (!pPipelines) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pPipelines create
         mReconstruction.addHandles((const uint64_t*)pPipelines, ((createInfoCount)));
         mReconstruction.addHandleDependency((const uint64_t*)pPipelines, ((createInfoCount)),
@@ -634,161 +656,154 @@ class VkDecoderSnapshot::Impl {
                 (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkRenderPass(
                     pCreateInfos[i].renderPass));
         }
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateGraphicsPipelines, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelines, ((createInfoCount)),
-                                            apiHandle, VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pPipelines,
+                                            apiCallHandle, VkReconstruction::CREATED);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPipelines,
                                                 ((createInfoCount)));
     }
-    void vkCreateComputePipelines(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkResult input_result,
-                                  VkDevice device, VkPipelineCache pipelineCache,
-                                  uint32_t createInfoCount,
+    void vkCreateComputePipelines(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkResult input_result, VkDevice device,
+                                  VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                   const VkComputePipelineCreateInfo* pCreateInfos,
                                   const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
         if (!pPipelines) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pPipelines create
         mReconstruction.addHandles((const uint64_t*)pPipelines, ((createInfoCount)));
         mReconstruction.addHandleDependency((const uint64_t*)pPipelines, ((createInfoCount)),
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateComputePipelines, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelines, ((createInfoCount)),
-                                            apiHandle, VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pPipelines,
+                                            apiCallHandle, VkReconstruction::CREATED);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPipelines,
                                                 ((createInfoCount)));
     }
-    void vkDestroyPipeline(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkDevice device, VkPipeline pipeline,
-                           const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                           VkPipeline pipeline, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pipeline destroy
         mReconstruction.removeHandles((const uint64_t*)(&pipeline), 1, true);
     }
-    void vkCreatePipelineLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo,
+    void vkCreatePipelineLayout(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                const VkPipelineLayoutCreateInfo* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator,
                                 VkPipelineLayout* pPipelineLayout) {
         if (!pPipelineLayout) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pPipelineLayout create
         mReconstruction.addHandles((const uint64_t*)pPipelineLayout, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pPipelineLayout, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreatePipelineLayout, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelineLayout, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelineLayout, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pPipelineLayout, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPipelineLayout, 1);
     }
-    void vkDestroyPipelineLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkDevice device,
-                                 VkPipelineLayout pipelineLayout,
+    void vkDestroyPipelineLayout(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkDevice device, VkPipelineLayout pipelineLayout,
                                  const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pipelineLayout destroy
         mReconstruction.removeHandles((const uint64_t*)(&pipelineLayout), 1, true);
     }
-    void vkCreateSampler(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateSampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkDevice device,
                          const VkSamplerCreateInfo* pCreateInfo,
                          const VkAllocationCallbacks* pAllocator, VkSampler* pSampler) {
         if (!pSampler) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pSampler create
         mReconstruction.addHandles((const uint64_t*)pSampler, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pSampler, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateSampler, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pSampler, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pSampler, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pSampler, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pSampler, 1);
     }
-    void vkDestroySampler(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkDevice device, VkSampler sampler,
-                          const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroySampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                          VkSampler sampler, const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // sampler destroy
         mReconstruction.removeHandles((const uint64_t*)(&sampler), 1, true);
     }
-    void vkCreateDescriptorSetLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkResult input_result,
-                                     VkDevice device,
+    void vkCreateDescriptorSetLayout(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkResult input_result, VkDevice device,
                                      const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator,
                                      VkDescriptorSetLayout* pSetLayout) {
         if (!pSetLayout) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pSetLayout create
         mReconstruction.addHandles((const uint64_t*)pSetLayout, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pSetLayout, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateDescriptorSetLayout, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pSetLayout, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pSetLayout, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pSetLayout, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pSetLayout, 1);
     }
-    void vkDestroyDescriptorSetLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkDevice device,
-                                      VkDescriptorSetLayout descriptorSetLayout,
+    void vkDestroyDescriptorSetLayout(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkDevice device, VkDescriptorSetLayout descriptorSetLayout,
                                       const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // descriptorSetLayout destroy
         mReconstruction.removeHandles((const uint64_t*)(&descriptorSetLayout), 1, true);
     }
-    void vkCreateDescriptorPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo,
+    void vkCreateDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                const VkDescriptorPoolCreateInfo* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator,
                                 VkDescriptorPool* pDescriptorPool) {
         if (!pDescriptorPool) return;
-        mLock.tryLock();
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pDescriptorPool create
         mReconstruction.addHandles((const uint64_t*)pDescriptorPool, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pDescriptorPool, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateDescriptorPool, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorPool, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorPool, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pDescriptorPool, 1);
-        mLock.unlock();
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pDescriptorPool, 1);
     }
-    void vkDestroyDescriptorPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkDevice device,
-                                 VkDescriptorPool descriptorPool,
+    void vkDestroyDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkDevice device, VkDescriptorPool descriptorPool,
                                  const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // descriptorPool destroy
         mReconstruction.removeHandles((const uint64_t*)(&descriptorPool), 1, true);
     }
-    void vkResetDescriptorPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkDescriptorPool descriptorPool,
-                               VkDescriptorPoolResetFlags flags) {}
-    void vkAllocateDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkResult input_result,
-                                  VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo,
+    void vkResetDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device,
+                               VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) {}
+    void vkAllocateDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkResult input_result, VkDevice device,
+                                  const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                   VkDescriptorSet* pDescriptorSets) {
         if (!pDescriptorSets) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pDescriptorSets create
         mReconstruction.addHandles((const uint64_t*)pDescriptorSets,
                                    pAllocateInfo->descriptorSetCount);
@@ -799,32 +814,31 @@ class VkDecoderSnapshot::Impl {
             (const uint64_t*)pDescriptorSets, pAllocateInfo->descriptorSetCount,
             (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkDescriptorPool(
                 pAllocateInfo->descriptorPool));
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkAllocateDescriptorSets, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorSets,
-                                            pAllocateInfo->descriptorSetCount, apiHandle,
+                                            pAllocateInfo->descriptorSetCount, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pDescriptorSets,
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pDescriptorSets,
                                                 pAllocateInfo->descriptorSetCount);
     }
-    void vkFreeDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkFreeDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkDevice device,
                               VkDescriptorPool descriptorPool, uint32_t descriptorSetCount,
                               const VkDescriptorSet* pDescriptorSets) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pDescriptorSets destroy
         mReconstruction.removeHandles((const uint64_t*)pDescriptorSets, ((descriptorSetCount)),
                                       true);
     }
-    void vkUpdateDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkDevice device,
-                                uint32_t descriptorWriteCount,
+    void vkUpdateDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkDevice device, uint32_t descriptorWriteCount,
                                 const VkWriteDescriptorSet* pDescriptorWrites,
                                 uint32_t descriptorCopyCount,
                                 const VkCopyDescriptorSet* pDescriptorCopies) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pDescriptorWrites action
         VkDecoderGlobalState* m_state = VkDecoderGlobalState::get();
         if (m_state->batchedDescriptorSetUpdateEnabled()) {
@@ -832,10 +846,8 @@ class VkDecoderSnapshot::Impl {
         }
         uint64_t handle = m_state->newGlobalVkGenericHandle();
         mReconstruction.addHandles((const uint64_t*)(&handle), 1);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkUpdateDescriptorSets, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < descriptorWriteCount; ++i) {
             mReconstruction.addHandleDependency(
                 (const uint64_t*)(&handle), 1,
@@ -871,16 +883,17 @@ class VkDecoderSnapshot::Impl {
                 }
             }
         }
-        mReconstruction.forEachHandleAddApi((const uint64_t*)(&handle), 1, apiHandle,
+        mReconstruction.forEachHandleAddApi((const uint64_t*)(&handle), 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)(&handle), 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)(&handle), 1);
     }
-    void vkCreateFramebuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateFramebuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device,
                              const VkFramebufferCreateInfo* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer) {
         if (!pFramebuffer) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pFramebuffer create
         mReconstruction.addHandles((const uint64_t*)pFramebuffer, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pFramebuffer, 1,
@@ -895,83 +908,86 @@ class VkDecoderSnapshot::Impl {
                 (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkImageView(
                     pCreateInfo->pAttachments[i]));
         }
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateFramebuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pFramebuffer, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pFramebuffer, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pFramebuffer, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pFramebuffer, 1);
     }
-    void vkDestroyFramebuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkDevice device,
-                              VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyFramebuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkDevice device, VkFramebuffer framebuffer,
+                              const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // framebuffer destroy
         mReconstruction.removeHandles((const uint64_t*)(&framebuffer), 1, true);
     }
-    void vkCreateRenderPass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device,
                             const VkRenderPassCreateInfo* pCreateInfo,
                             const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
         if (!pRenderPass) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pRenderPass create
         mReconstruction.addHandles((const uint64_t*)pRenderPass, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pRenderPass, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateRenderPass, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pRenderPass, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pRenderPass, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pRenderPass, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pRenderPass, 1);
     }
-    void vkDestroyRenderPass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkDevice device,
-                             VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkDevice device, VkRenderPass renderPass,
+                             const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // renderPass destroy
         mReconstruction.removeHandles((const uint64_t*)(&renderPass), 1, true);
     }
-    void vkGetRenderAreaGranularity(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkDevice device,
-                                    VkRenderPass renderPass, VkExtent2D* pGranularity) {}
-    void vkCreateCommandPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkGetRenderAreaGranularity(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkDevice device, VkRenderPass renderPass,
+                                    VkExtent2D* pGranularity) {}
+    void vkCreateCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device,
                              const VkCommandPoolCreateInfo* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool) {
         if (!pCommandPool) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pCommandPool create
         mReconstruction.addHandles((const uint64_t*)pCommandPool, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pCommandPool, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateCommandPool, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pCommandPool, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pCommandPool, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pCommandPool, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pCommandPool, 1);
     }
-    void vkDestroyCommandPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkDevice device,
-                              VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroyCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkDevice device, VkCommandPool commandPool,
+                              const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandPool destroy
         mReconstruction.removeHandles((const uint64_t*)(&commandPool), 1, true);
     }
-    void vkResetCommandPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                            VkCommandPool commandPool, VkCommandPoolResetFlags flags) {}
-    void vkAllocateCommandBuffers(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkResult input_result,
-                                  VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo,
+    void vkResetCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device, VkCommandPool commandPool,
+                            VkCommandPoolResetFlags flags) {}
+    void vkAllocateCommandBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkResult input_result, VkDevice device,
+                                  const VkCommandBufferAllocateInfo* pAllocateInfo,
                                   VkCommandBuffer* pCommandBuffers) {
         if (!pCommandBuffers) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pCommandBuffers create
         mReconstruction.addHandles((const uint64_t*)pCommandBuffers,
                                    pAllocateInfo->commandBufferCount);
@@ -979,784 +995,723 @@ class VkDecoderSnapshot::Impl {
             (const uint64_t*)pCommandBuffers, pAllocateInfo->commandBufferCount,
             (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkCommandPool(
                 pAllocateInfo->commandPool));
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkAllocateCommandBuffers, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         mReconstruction.forEachHandleAddApi((const uint64_t*)pCommandBuffers,
-                                            pAllocateInfo->commandBufferCount, apiHandle,
+                                            pAllocateInfo->commandBufferCount, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pCommandBuffers,
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pCommandBuffers,
                                                 pAllocateInfo->commandBufferCount);
     }
-    void vkFreeCommandBuffers(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkDevice device,
-                              VkCommandPool commandPool, uint32_t commandBufferCount,
-                              const VkCommandBuffer* pCommandBuffers) {
-        android::base::AutoLock lock(mLock);
+    void vkFreeCommandBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkDevice device, VkCommandPool commandPool,
+                              uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pCommandBuffers destroy
         mReconstruction.removeHandles((const uint64_t*)pCommandBuffers, ((commandBufferCount)),
                                       true);
     }
-    void vkBeginCommandBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result,
-                              VkCommandBuffer commandBuffer,
+    void vkBeginCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkCommandBuffer commandBuffer,
                               const VkCommandBufferBeginInfo* pBeginInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkBeginCommandBuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkEndCommandBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result,
-                            VkCommandBuffer commandBuffer) {
-        android::base::AutoLock lock(mLock);
+    void vkEndCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkCommandBuffer commandBuffer) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkEndCommandBuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkResetCommandBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result,
-                              VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) {
-        android::base::AutoLock lock(mLock);
+    void vkResetCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkCommandBuffer commandBuffer,
+                              VkCommandBufferResetFlags flags) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkResetCommandBuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
             mReconstruction.forEachHandleClearModifyApi((const uint64_t*)(&boxed), 1);
         }
     }
-    void vkCmdBindPipeline(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBindPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
+                           VkPipeline pipeline) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindPipeline, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetViewport(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          uint32_t firstViewport, uint32_t viewportCount,
-                          const VkViewport* pViewports) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetViewport(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, uint32_t firstViewport,
+                          uint32_t viewportCount, const VkViewport* pViewports) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetViewport, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetScissor(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetScissor(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, uint32_t firstScissor,
+                         uint32_t scissorCount, const VkRect2D* pScissors) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetScissor, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetLineWidth(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           float lineWidth) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetLineWidth(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, float lineWidth) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetLineWidth, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthBias(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           float depthBiasConstantFactor, float depthBiasClamp,
-                           float depthBiasSlopeFactor) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDepthBias(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, float depthBiasConstantFactor,
+                           float depthBiasClamp, float depthBiasSlopeFactor) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBias, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetBlendConstants(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                const float blendConstants[4]) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetBlendConstants(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, const float blendConstants[4]) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetBlendConstants, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthBounds(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             float minDepthBounds, float maxDepthBounds) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDepthBounds(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, float minDepthBounds,
+                             float maxDepthBounds) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBounds, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetStencilCompareMask(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    VkStencilFaceFlags faceMask, uint32_t compareMask) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetStencilCompareMask(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                                    uint32_t compareMask) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilCompareMask, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetStencilWriteMask(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkStencilFaceFlags faceMask, uint32_t writeMask) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetStencilWriteMask(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                                  uint32_t writeMask) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilWriteMask, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetStencilReference(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkStencilFaceFlags faceMask, uint32_t reference) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetStencilReference(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                                  uint32_t reference) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilReference, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBindDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBindDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer,
                                  VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
                                  uint32_t firstSet, uint32_t descriptorSetCount,
                                  const VkDescriptorSet* pDescriptorSets,
                                  uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindDescriptorSets, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBindIndexBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBindIndexBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+                              VkIndexType indexType) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindIndexBuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBindVertexBuffers(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                uint32_t firstBinding, uint32_t bindingCount,
-                                const VkBuffer* pBuffers, const VkDeviceSize* pOffsets) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBindVertexBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, uint32_t firstBinding,
+                                uint32_t bindingCount, const VkBuffer* pBuffers,
+                                const VkDeviceSize* pOffsets) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindVertexBuffers, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdDraw(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                   uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex,
-                   uint32_t firstInstance) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdDraw(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                   const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                   VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount,
+                   uint32_t firstVertex, uint32_t firstInstance) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDraw, snapshotTraceBegin, snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdDrawIndexed(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex,
-                          int32_t vertexOffset, uint32_t firstInstance) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdDrawIndexed(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, uint32_t indexCount,
+                          uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset,
+                          uint32_t firstInstance) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndexed, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdDrawIndirect(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount,
-                           uint32_t stride) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdDrawIndirect(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+                           uint32_t drawCount, uint32_t stride) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndirect, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdDrawIndexedIndirect(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount,
-                                  uint32_t stride) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdDrawIndexedIndirect(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkBuffer buffer,
+                                  VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndexedIndirect, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdDispatch(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                       uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdDispatch(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
+                       uint32_t groupCountZ) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDispatch, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdDispatchIndirect(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                               VkBuffer buffer, VkDeviceSize offset) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdDispatchIndirect(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer, VkBuffer buffer,
+                               VkDeviceSize offset) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDispatchIndirect, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount,
-                         const VkBufferCopy* pRegions) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdCopyBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer,
+                         uint32_t regionCount, const VkBufferCopy* pRegions) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                        VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage,
+    void vkCmdCopyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkCommandBuffer commandBuffer, VkImage srcImage,
+                        VkImageLayout srcImageLayout, VkImage dstImage,
                         VkImageLayout dstImageLayout, uint32_t regionCount,
                         const VkImageCopy* pRegions) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImage, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBlitImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                        VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage,
+    void vkCmdBlitImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkCommandBuffer commandBuffer, VkImage srcImage,
+                        VkImageLayout srcImageLayout, VkImage dstImage,
                         VkImageLayout dstImageLayout, uint32_t regionCount,
                         const VkImageBlit* pRegions, VkFilter filter) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBlitImage, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyBufferToImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout,
-                                uint32_t regionCount, const VkBufferImageCopy* pRegions) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdCopyBufferToImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
+                                VkImageLayout dstImageLayout, uint32_t regionCount,
+                                const VkBufferImageCopy* pRegions) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBufferToImage, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyImageToBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer,
+    void vkCmdCopyImageToBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, VkImage srcImage,
+                                VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                 uint32_t regionCount, const VkBufferImageCopy* pRegions) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImageToBuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdUpdateBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize,
-                           const void* pData) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdUpdateBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
+                           VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdUpdateBuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdFillBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size,
-                         uint32_t data) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdFillBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset,
+                         VkDeviceSize size, uint32_t data) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdFillBuffer, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdClearColorImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkImage image, VkImageLayout imageLayout,
-                              const VkClearColorValue* pColor, uint32_t rangeCount,
-                              const VkImageSubresourceRange* pRanges) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdClearColorImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkImage image,
+                              VkImageLayout imageLayout, const VkClearColorValue* pColor,
+                              uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdClearColorImage, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdClearDepthStencilImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                     VkImage image, VkImageLayout imageLayout,
+    void vkCmdClearDepthStencilImage(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkCommandBuffer commandBuffer, VkImage image,
+                                     VkImageLayout imageLayout,
                                      const VkClearDepthStencilValue* pDepthStencil,
                                      uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdClearDepthStencilImage, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdClearAttachments(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                               uint32_t attachmentCount, const VkClearAttachment* pAttachments,
-                               uint32_t rectCount, const VkClearRect* pRects) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdClearAttachments(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer, uint32_t attachmentCount,
+                               const VkClearAttachment* pAttachments, uint32_t rectCount,
+                               const VkClearRect* pRects) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdClearAttachments, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdResolveImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage,
+    void vkCmdResolveImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkImage srcImage,
+                           VkImageLayout srcImageLayout, VkImage dstImage,
                            VkImageLayout dstImageLayout, uint32_t regionCount,
                            const VkImageResolve* pRegions) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdResolveImage, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer, VkEvent event,
+    void vkCmdSetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkCommandBuffer commandBuffer, VkEvent event,
                        VkPipelineStageFlags stageMask) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetEvent, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdResetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         VkEvent event, VkPipelineStageFlags stageMask) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdResetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, VkEvent event,
+                         VkPipelineStageFlags stageMask) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdResetEvent, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdWaitEvents(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         uint32_t eventCount, const VkEvent* pEvents,
+    void vkCmdWaitEvents(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents,
                          VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
                          uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
                          uint32_t bufferMemoryBarrierCount,
                          const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                          uint32_t imageMemoryBarrierCount,
                          const VkImageMemoryBarrier* pImageMemoryBarriers) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdWaitEvents, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdPipelineBarrier(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
-                              VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount,
-                              const VkMemoryBarrier* pMemoryBarriers,
+    void vkCmdPipelineBarrier(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
+                              VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
+                              uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
                               uint32_t bufferMemoryBarrierCount,
                               const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                               uint32_t imageMemoryBarrierCount,
                               const VkImageMemoryBarrier* pImageMemoryBarriers) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdPipelineBarrier, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBeginQuery(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBeginQuery(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
+                         VkQueryControlFlags flags) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginQuery, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdEndQuery(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                       VkQueryPool queryPool, uint32_t query) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdEndQuery(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndQuery, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdResetQueryPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdResetQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, VkQueryPool queryPool,
+                             uint32_t firstQuery, uint32_t queryCount) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdResetQueryPool, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdWriteTimestamp(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool,
-                             uint32_t query) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdWriteTimestamp(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage,
+                             VkQueryPool queryPool, uint32_t query) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdWriteTimestamp, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyQueryPoolResults(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyQueryPoolResults(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount,
                                    VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride,
                                    VkQueryResultFlags flags) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyQueryPoolResults, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdPushConstants(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset,
-                            uint32_t size, const void* pValues) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdPushConstants(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, VkPipelineLayout layout,
+                            VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size,
+                            const void* pValues) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdPushConstants, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBeginRenderPass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer,
                               const VkRenderPassBeginInfo* pRenderPassBegin,
                               VkSubpassContents contents) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRenderPass, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdNextSubpass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          VkSubpassContents contents) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdNextSubpass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, VkSubpassContents contents) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdNextSubpass, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdEndRenderPass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdEndRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRenderPass, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdExecuteCommands(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdExecuteCommands(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
+                              const VkCommandBuffer* pCommandBuffers) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdExecuteCommands, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_VERSION_1_1
-    void vkEnumerateInstanceVersion(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    uint32_t* pApiVersion) {}
-    void vkBindBufferMemory2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                             uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos) {}
-    void vkBindImageMemory2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                            uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos) {
-        android::base::AutoLock lock(mLock);
+    void vkEnumerateInstanceVersion(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, uint32_t* pApiVersion) {}
+    void vkBindBufferMemory2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device, uint32_t bindInfoCount,
+                             const VkBindBufferMemoryInfo* pBindInfos) {}
+    void vkBindImageMemory2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device, uint32_t bindInfoCount,
+                            const VkBindImageMemoryInfo* pBindInfos) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         for (uint32_t i = 0; i < bindInfoCount; ++i) {
             VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage(pBindInfos[i].image);
             VkDeviceMemory boxed_VkDeviceMemory =
@@ -1768,1125 +1723,1110 @@ class VkDecoderSnapshot::Impl {
                                                 (uint64_t)(uintptr_t)boxed_VkImage,
                                                 VkReconstruction::BOUND_MEMORY);
         }
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkBindImageMemory2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         // Note: the implementation does not work with bindInfoCount > 1
         for (uint32_t i = 0; i < bindInfoCount; ++i) {
             VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage(pBindInfos[i].image);
-            mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkImage, 1, apiHandle,
+            mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkImage, 1, apiCallHandle,
                                                 VkReconstruction::BOUND_MEMORY);
         }
     }
-    void vkGetDeviceGroupPeerMemoryFeatures(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
-                                            uint32_t heapIndex, uint32_t localDeviceIndex,
-                                            uint32_t remoteDeviceIndex,
+    void vkGetDeviceGroupPeerMemoryFeatures(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device, uint32_t heapIndex,
+                                            uint32_t localDeviceIndex, uint32_t remoteDeviceIndex,
                                             VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {}
-    void vkCmdSetDeviceMask(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            uint32_t deviceMask) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDeviceMask(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, uint32_t deviceMask) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDeviceMask, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdDispatchBase(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ,
-                           uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdDispatchBase(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY,
+                           uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY,
+                           uint32_t groupCountZ) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDispatchBase, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
     void vkEnumeratePhysicalDeviceGroups(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
         VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {}
-    void vkGetImageMemoryRequirements2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkDevice device,
-                                       const VkImageMemoryRequirementsInfo2* pInfo,
+    void vkGetImageMemoryRequirements2(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
                                        VkMemoryRequirements2* pMemoryRequirements) {}
-    void vkGetBufferMemoryRequirements2(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetBufferMemoryRequirements2(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device,
                                         const VkBufferMemoryRequirementsInfo2* pInfo,
                                         VkMemoryRequirements2* pMemoryRequirements) {}
     void vkGetImageSparseMemoryRequirements2(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
-        uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {}
-    void vkGetPhysicalDeviceFeatures2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFeatures2(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkPhysicalDevice physicalDevice,
                                       VkPhysicalDeviceFeatures2* pFeatures) {}
-    void vkGetPhysicalDeviceProperties2(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceProperties2(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkPhysicalDevice physicalDevice,
                                         VkPhysicalDeviceProperties2* pProperties) {}
-    void vkGetPhysicalDeviceFormatProperties2(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFormatProperties2(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize,
                                               VkPhysicalDevice physicalDevice, VkFormat format,
                                               VkFormatProperties2* pFormatProperties) {}
     void vkGetPhysicalDeviceImageFormatProperties2(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkPhysicalDevice physicalDevice,
-        const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
         VkImageFormatProperties2* pImageFormatProperties) {}
     void vkGetPhysicalDeviceQueueFamilyProperties2(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
-        VkQueueFamilyProperties2* pQueueFamilyProperties) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {}
     void vkGetPhysicalDeviceMemoryProperties2(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {}
     void vkGetPhysicalDeviceSparseImageFormatProperties2(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
-        uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {}
-    void vkTrimCommandPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkDevice device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
+        VkSparseImageFormatProperties2* pProperties) {}
+    void vkTrimCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                            VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {}
-    void vkGetDeviceQueue2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceQueue2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                            const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue) {}
-    void vkCreateSamplerYcbcrConversion(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateSamplerYcbcrConversion(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkSamplerYcbcrConversion* pYcbcrConversion) {
         if (!pYcbcrConversion) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pYcbcrConversion create
         mReconstruction.addHandles((const uint64_t*)pYcbcrConversion, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pYcbcrConversion, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateSamplerYcbcrConversion, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pYcbcrConversion, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pYcbcrConversion, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pYcbcrConversion, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pYcbcrConversion,
+                                                1);
     }
-    void vkDestroySamplerYcbcrConversion(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkDestroySamplerYcbcrConversion(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
                                          const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // ycbcrConversion destroy
         mReconstruction.removeHandles((const uint64_t*)(&ycbcrConversion), 1, true);
     }
-    void vkCreateDescriptorUpdateTemplate(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateDescriptorUpdateTemplate(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
         if (!pDescriptorUpdateTemplate) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pDescriptorUpdateTemplate create
         mReconstruction.addHandles((const uint64_t*)pDescriptorUpdateTemplate, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pDescriptorUpdateTemplate, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateDescriptorUpdateTemplate,
-                                    snapshotTraceBegin, snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorUpdateTemplate, 1,
-                                            apiHandle, VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle,
+                                            apiCallHandle, VkReconstruction::CREATED);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle,
                                                 (const uint64_t*)pDescriptorUpdateTemplate, 1);
     }
-    void vkDestroyDescriptorUpdateTemplate(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkDestroyDescriptorUpdateTemplate(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device,
                                            VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                            const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // descriptorUpdateTemplate destroy
         mReconstruction.removeHandles((const uint64_t*)(&descriptorUpdateTemplate), 1, true);
     }
-    void vkUpdateDescriptorSetWithTemplate(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkUpdateDescriptorSetWithTemplate(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device, VkDescriptorSet descriptorSet,
                                            VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                            const void* pData) {}
     void vkGetPhysicalDeviceExternalBufferProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
         VkExternalBufferProperties* pExternalBufferProperties) {}
     void vkGetPhysicalDeviceExternalFenceProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
         VkExternalFenceProperties* pExternalFenceProperties) {}
     void vkGetPhysicalDeviceExternalSemaphoreProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
         VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {}
-    void vkGetDescriptorSetLayoutSupport(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetDescriptorSetLayoutSupport(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device,
                                          const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                          VkDescriptorSetLayoutSupport* pSupport) {}
 #endif
 #ifdef VK_VERSION_1_2
-    void vkCmdDrawIndirectCount(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
-                                VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
-                                uint32_t stride) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdDrawIndirectCount(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+                                VkBuffer countBuffer, VkDeviceSize countBufferOffset,
+                                uint32_t maxDrawCount, uint32_t stride) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndirectCount, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdDrawIndexedIndirectCount(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
+    void vkCmdDrawIndexedIndirectCount(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, VkBuffer buffer,
+                                       VkDeviceSize offset, VkBuffer countBuffer,
                                        VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                        uint32_t stride) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndexedIndirectCount, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCreateRenderPass2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device,
                              const VkRenderPassCreateInfo2* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
         if (!pRenderPass) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pRenderPass create
         mReconstruction.addHandles((const uint64_t*)pRenderPass, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pRenderPass, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateRenderPass2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pRenderPass, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pRenderPass, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pRenderPass, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pRenderPass, 1);
     }
-    void vkCmdBeginRenderPass2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer,
                                const VkRenderPassBeginInfo* pRenderPassBegin,
                                const VkSubpassBeginInfo* pSubpassBeginInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRenderPass2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdNextSubpass2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdNextSubpass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer,
                            const VkSubpassBeginInfo* pSubpassBeginInfo,
                            const VkSubpassEndInfo* pSubpassEndInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdNextSubpass2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdEndRenderPass2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdEndRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer,
                              const VkSubpassEndInfo* pSubpassEndInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRenderPass2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkResetQueryPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkDevice device, VkQueryPool queryPool,
-                          uint32_t firstQuery, uint32_t queryCount) {}
-    void vkGetSemaphoreCounterValue(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    VkDevice device, VkSemaphore semaphore, uint64_t* pValue) {}
-    void vkWaitSemaphores(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkResetQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                          VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {}
+    void vkGetSemaphoreCounterValue(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, VkDevice device, VkSemaphore semaphore,
+                                    uint64_t* pValue) {}
+    void vkWaitSemaphores(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device,
                           const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout) {}
-    void vkSignalSemaphore(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkSignalSemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device,
                            const VkSemaphoreSignalInfo* pSignalInfo) {}
-    void vkGetBufferDeviceAddress(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkDeviceAddress input_result,
-                                  VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {}
-    void vkGetBufferOpaqueCaptureAddress(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetBufferDeviceAddress(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkDeviceAddress input_result, VkDevice device,
+                                  const VkBufferDeviceAddressInfo* pInfo) {}
+    void vkGetBufferOpaqueCaptureAddress(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          uint64_t input_result, VkDevice device,
                                          const VkBufferDeviceAddressInfo* pInfo) {}
     void vkGetDeviceMemoryOpaqueCaptureAddress(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        uint64_t input_result, VkDevice device,
-        const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, uint64_t input_result,
+        VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {}
 #endif
 #ifdef VK_VERSION_1_3
-    void vkGetPhysicalDeviceToolProperties(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceToolProperties(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkPhysicalDevice physicalDevice,
                                            uint32_t* pToolCount,
                                            VkPhysicalDeviceToolProperties* pToolProperties) {}
-    void vkCreatePrivateDataSlot(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkResult input_result,
-                                 VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
+    void vkCreatePrivateDataSlot(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkResult input_result, VkDevice device,
+                                 const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator,
                                  VkPrivateDataSlot* pPrivateDataSlot) {
         if (!pPrivateDataSlot) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pPrivateDataSlot create
         mReconstruction.addHandles((const uint64_t*)pPrivateDataSlot, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pPrivateDataSlot, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreatePrivateDataSlot, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pPrivateDataSlot, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pPrivateDataSlot, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pPrivateDataSlot, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPrivateDataSlot,
+                                                1);
     }
-    void vkDestroyPrivateDataSlot(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkDevice device,
-                                  VkPrivateDataSlot privateDataSlot,
+    void vkDestroyPrivateDataSlot(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkDevice device, VkPrivateDataSlot privateDataSlot,
                                   const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // privateDataSlot destroy
         mReconstruction.removeHandles((const uint64_t*)(&privateDataSlot), 1, true);
     }
-    void vkSetPrivateData(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkSetPrivateData(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device, VkObjectType objectType,
+                          uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
+    }
+    void vkGetPrivateData(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                           VkObjectType objectType, uint64_t objectHandle,
-                          VkPrivateDataSlot privateDataSlot, uint64_t data) {}
-    void vkGetPrivateData(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkDevice device, VkObjectType objectType,
-                          uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
-                          uint64_t* pData) {}
-    void vkCmdSetEvent2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkCommandBuffer commandBuffer, VkEvent event,
+                          VkPrivateDataSlot privateDataSlot, uint64_t* pData) {}
+    void vkCmdSetEvent2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkCommandBuffer commandBuffer, VkEvent event,
                         const VkDependencyInfo* pDependencyInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetEvent2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdResetEvent2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          VkEvent event, VkPipelineStageFlags2 stageMask) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdResetEvent2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, VkEvent event,
+                          VkPipelineStageFlags2 stageMask) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdResetEvent2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdWaitEvents2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          uint32_t eventCount, const VkEvent* pEvents,
-                          const VkDependencyInfo* pDependencyInfos) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdWaitEvents2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, uint32_t eventCount,
+                          const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdWaitEvents2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdPipelineBarrier2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdPipelineBarrier2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer,
                                const VkDependencyInfo* pDependencyInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdPipelineBarrier2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdWriteTimestamp2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdWriteTimestamp2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
+                              VkQueryPool queryPool, uint32_t query) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdWriteTimestamp2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkQueueSubmit2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
-                        uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence) {}
-    void vkCmdCopyBuffer2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          const VkCopyBufferInfo2* pCopyBufferInfo) {
-        android::base::AutoLock lock(mLock);
+    void vkQueueSubmit2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkResult input_result, VkQueue queue, uint32_t submitCount,
+                        const VkSubmitInfo2* pSubmits, VkFence fence) {}
+    void vkCmdCopyBuffer2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBuffer2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyImage2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         const VkCopyImageInfo2* pCopyImageInfo) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdCopyImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImage2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyBufferToImage2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyBufferToImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer,
                                  const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBufferToImage2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyImageToBuffer2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyImageToBuffer2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer,
                                  const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImageToBuffer2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBlitImage2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         const VkBlitImageInfo2* pBlitImageInfo) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBlitImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBlitImage2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdResolveImage2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdResolveImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer,
                             const VkResolveImageInfo2* pResolveImageInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdResolveImage2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBeginRendering(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             const VkRenderingInfo* pRenderingInfo) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBeginRendering(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRendering, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdEndRendering(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdEndRendering(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRendering, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetCullMode(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          VkCullModeFlags cullMode) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetCullMode(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetCullMode, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetFrontFace(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkFrontFace frontFace) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetFrontFace(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetFrontFace, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetPrimitiveTopology(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetPrimitiveTopology(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkPrimitiveTopology primitiveTopology) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPrimitiveTopology, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetViewportWithCount(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetViewportWithCount(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    uint32_t viewportCount, const VkViewport* pViewports) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetViewportWithCount, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetScissorWithCount(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  uint32_t scissorCount, const VkRect2D* pScissors) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetScissorWithCount(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, uint32_t scissorCount,
+                                  const VkRect2D* pScissors) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetScissorWithCount, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBindVertexBuffers2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 uint32_t firstBinding, uint32_t bindingCount,
-                                 const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
-                                 const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBindVertexBuffers2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, uint32_t firstBinding,
+                                 uint32_t bindingCount, const VkBuffer* pBuffers,
+                                 const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
+                                 const VkDeviceSize* pStrides) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindVertexBuffers2, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthTestEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 VkBool32 depthTestEnable) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDepthTestEnable(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthTestEnable, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthWriteEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkBool32 depthWriteEnable) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDepthWriteEnable(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthWriteEnable, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthCompareOp(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                VkCompareOp depthCompareOp) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDepthCompareOp(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthCompareOp, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthBoundsTestEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetDepthBoundsTestEnable(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer,
                                        VkBool32 depthBoundsTestEnable) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBoundsTestEnable, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetStencilTestEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetStencilTestEnable(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkBool32 stencilTestEnable) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilTestEnable, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetStencilOp(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp,
-                           VkStencilOp depthFailOp, VkCompareOp compareOp) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetStencilOp(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                           VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
+                           VkCompareOp compareOp) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilOp, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetRasterizerDiscardEnable(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdSetRasterizerDiscardEnable(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          VkBool32 rasterizerDiscardEnable) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetRasterizerDiscardEnable, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthBiasEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 VkBool32 depthBiasEnable) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDepthBiasEnable(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBiasEnable, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetPrimitiveRestartEnable(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdSetPrimitiveRestartEnable(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer,
                                         VkBool32 primitiveRestartEnable) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPrimitiveRestartEnable, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkGetDeviceBufferMemoryRequirements(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceBufferMemoryRequirements(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkDevice device,
                                              const VkDeviceBufferMemoryRequirements* pInfo,
                                              VkMemoryRequirements2* pMemoryRequirements) {}
-    void vkGetDeviceImageMemoryRequirements(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceImageMemoryRequirements(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device,
                                             const VkDeviceImageMemoryRequirements* pInfo,
                                             VkMemoryRequirements2* pMemoryRequirements) {}
     void vkGetDeviceImageSparseMemoryRequirements(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
-        uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {}
 #endif
 #ifdef VK_KHR_swapchain
-    void vkCreateSwapchainKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateSwapchainKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkDevice device,
                               const VkSwapchainCreateInfoKHR* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain) {
         if (!pSwapchain) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pSwapchain create
         mReconstruction.addHandles((const uint64_t*)pSwapchain, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pSwapchain, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateSwapchainKHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pSwapchain, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pSwapchain, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pSwapchain, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pSwapchain, 1);
     }
-    void vkDestroySwapchainKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkDevice device,
-                               VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+    void vkDestroySwapchainKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkDevice device, VkSwapchainKHR swapchain,
+                               const VkAllocationCallbacks* pAllocator) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // swapchain destroy
         mReconstruction.removeHandles((const uint64_t*)(&swapchain), 1, true);
     }
-    void vkGetSwapchainImagesKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkResult input_result,
-                                 VkDevice device, VkSwapchainKHR swapchain,
+    void vkGetSwapchainImagesKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
                                  uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages) {}
-    void vkAcquireNextImageKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout,
-                               VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex) {}
-    void vkQueuePresentKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
+    void vkAcquireNextImageKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
+                               uint64_t timeout, VkSemaphore semaphore, VkFence fence,
+                               uint32_t* pImageIndex) {}
+    void vkQueuePresentKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkQueue queue,
                            const VkPresentInfoKHR* pPresentInfo) {}
     void vkGetDeviceGroupPresentCapabilitiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device,
-        VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities) {}
-    void vkGetDeviceGroupSurfacePresentModesKHR(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
-                                                VkResult input_result, VkDevice device,
-                                                VkSurfaceKHR surface,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities) {}
+    void vkGetDeviceGroupSurfacePresentModesKHR(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize, VkResult input_result,
+                                                VkDevice device, VkSurfaceKHR surface,
                                                 VkDeviceGroupPresentModeFlagsKHR* pModes) {}
-    void vkGetPhysicalDevicePresentRectanglesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
-        uint32_t* pRectCount, VkRect2D* pRects) {}
-    void vkAcquireNextImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo,
+    void vkGetPhysicalDevicePresentRectanglesKHR(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize, VkResult input_result,
+                                                 VkPhysicalDevice physicalDevice,
+                                                 VkSurfaceKHR surface, uint32_t* pRectCount,
+                                                 VkRect2D* pRects) {}
+    void vkAcquireNextImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                const VkAcquireNextImageInfoKHR* pAcquireInfo,
                                 uint32_t* pImageIndex) {}
 #endif
 #ifdef VK_KHR_dynamic_rendering
-    void vkCmdBeginRenderingKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginRenderingKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer,
                                 const VkRenderingInfo* pRenderingInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRenderingKHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdEndRenderingKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdEndRenderingKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRenderingKHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
-    void vkGetPhysicalDeviceFeatures2KHR(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFeatures2KHR(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkPhysicalDevice physicalDevice,
                                          VkPhysicalDeviceFeatures2* pFeatures) {}
-    void vkGetPhysicalDeviceProperties2KHR(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceProperties2KHR(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkPhysicalDevice physicalDevice,
                                            VkPhysicalDeviceProperties2* pProperties) {}
-    void vkGetPhysicalDeviceFormatProperties2KHR(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFormatProperties2KHR(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize,
                                                  VkPhysicalDevice physicalDevice, VkFormat format,
                                                  VkFormatProperties2* pFormatProperties) {}
     void vkGetPhysicalDeviceImageFormatProperties2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkPhysicalDevice physicalDevice,
-        const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
         VkImageFormatProperties2* pImageFormatProperties) {}
     void vkGetPhysicalDeviceQueueFamilyProperties2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
-        VkQueueFamilyProperties2* pQueueFamilyProperties) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {}
     void vkGetPhysicalDeviceMemoryProperties2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {}
     void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
-        uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
+        VkSparseImageFormatProperties2* pProperties) {}
 #endif
 #ifdef VK_KHR_maintenance1
-    void vkTrimCommandPoolKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkDevice device,
-                              VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {}
+    void vkTrimCommandPoolKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkDevice device, VkCommandPool commandPool,
+                              VkCommandPoolTrimFlags flags) {}
 #endif
 #ifdef VK_KHR_external_memory_capabilities
     void vkGetPhysicalDeviceExternalBufferPropertiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
         VkExternalBufferProperties* pExternalBufferProperties) {}
 #endif
 #ifdef VK_KHR_external_semaphore_capabilities
     void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
         VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {}
 #endif
 #ifdef VK_KHR_external_semaphore_fd
-    void vkImportSemaphoreFdKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device,
+    void vkImportSemaphoreFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
                                 const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {}
-    void vkGetSemaphoreFdKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkGetSemaphoreFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device,
                              const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd) {}
 #endif
 #ifdef VK_KHR_descriptor_update_template
     void vkCreateDescriptorUpdateTemplateKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device,
-        const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator,
         VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
         if (!pDescriptorUpdateTemplate) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pDescriptorUpdateTemplate create
         mReconstruction.addHandles((const uint64_t*)pDescriptorUpdateTemplate, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pDescriptorUpdateTemplate, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateDescriptorUpdateTemplateKHR,
-                                    snapshotTraceBegin, snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorUpdateTemplate, 1,
-                                            apiHandle, VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle,
+                                            apiCallHandle, VkReconstruction::CREATED);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle,
                                                 (const uint64_t*)pDescriptorUpdateTemplate, 1);
     }
-    void vkDestroyDescriptorUpdateTemplateKHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkDevice device,
+    void vkDestroyDescriptorUpdateTemplateKHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkDevice device,
                                               VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                               const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // descriptorUpdateTemplate destroy
         mReconstruction.removeHandles((const uint64_t*)(&descriptorUpdateTemplate), 1, true);
     }
-    void vkUpdateDescriptorSetWithTemplateKHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkDevice device,
+    void vkUpdateDescriptorSetWithTemplateKHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkDevice device,
                                               VkDescriptorSet descriptorSet,
                                               VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                               const void* pData) {}
 #endif
 #ifdef VK_KHR_create_renderpass2
-    void vkCreateRenderPass2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo,
+    void vkCreateRenderPass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                const VkRenderPassCreateInfo2* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator,
                                 VkRenderPass* pRenderPass) {
         if (!pRenderPass) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pRenderPass create
         mReconstruction.addHandles((const uint64_t*)pRenderPass, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pRenderPass, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateRenderPass2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pRenderPass, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pRenderPass, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pRenderPass, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pRenderPass, 1);
     }
-    void vkCmdBeginRenderPass2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginRenderPass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer,
                                   const VkRenderPassBeginInfo* pRenderPassBegin,
                                   const VkSubpassBeginInfo* pSubpassBeginInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginRenderPass2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdNextSubpass2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdNextSubpass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer,
                               const VkSubpassBeginInfo* pSubpassBeginInfo,
                               const VkSubpassEndInfo* pSubpassEndInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdNextSubpass2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdEndRenderPass2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdEndRenderPass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer,
                                 const VkSubpassEndInfo* pSubpassEndInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndRenderPass2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_KHR_external_fence_capabilities
     void vkGetPhysicalDeviceExternalFencePropertiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
         VkExternalFenceProperties* pExternalFenceProperties) {}
 #endif
 #ifdef VK_KHR_external_fence_fd
-    void vkImportFenceFdKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkImportFenceFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device,
                             const VkImportFenceFdInfoKHR* pImportFenceFdInfo) {}
-    void vkGetFenceFdKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkGetFenceFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkDevice device,
                          const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd) {}
 #endif
 #ifdef VK_KHR_get_memory_requirements2
-    void vkGetImageMemoryRequirements2KHR(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetImageMemoryRequirements2KHR(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device,
                                           const VkImageMemoryRequirementsInfo2* pInfo,
                                           VkMemoryRequirements2* pMemoryRequirements) {}
-    void vkGetBufferMemoryRequirements2KHR(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetBufferMemoryRequirements2KHR(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device,
                                            const VkBufferMemoryRequirementsInfo2* pInfo,
                                            VkMemoryRequirements2* pMemoryRequirements) {}
     void vkGetImageSparseMemoryRequirements2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
-        uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {}
 #endif
 #ifdef VK_KHR_sampler_ycbcr_conversion
-    void vkCreateSamplerYcbcrConversionKHR(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateSamplerYcbcrConversionKHR(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkSamplerYcbcrConversion* pYcbcrConversion) {
         if (!pYcbcrConversion) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pYcbcrConversion create
         mReconstruction.addHandles((const uint64_t*)pYcbcrConversion, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pYcbcrConversion, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateSamplerYcbcrConversionKHR,
-                                    snapshotTraceBegin, snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pYcbcrConversion, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pYcbcrConversion, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pYcbcrConversion, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pYcbcrConversion,
+                                                1);
     }
-    void vkDestroySamplerYcbcrConversionKHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
+    void vkDestroySamplerYcbcrConversionKHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device,
                                             VkSamplerYcbcrConversion ycbcrConversion,
                                             const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // ycbcrConversion destroy
         mReconstruction.removeHandles((const uint64_t*)(&ycbcrConversion), 1, true);
     }
 #endif
 #ifdef VK_KHR_bind_memory2
-    void vkBindBufferMemory2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, uint32_t bindInfoCount,
+    void vkBindBufferMemory2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device, uint32_t bindInfoCount,
                                 const VkBindBufferMemoryInfo* pBindInfos) {}
-    void vkBindImageMemory2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, uint32_t bindInfoCount,
+    void vkBindImageMemory2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, uint32_t bindInfoCount,
                                const VkBindImageMemoryInfo* pBindInfos) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         for (uint32_t i = 0; i < bindInfoCount; ++i) {
             VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage(pBindInfos[i].image);
             VkDeviceMemory boxed_VkDeviceMemory =
@@ -2898,4492 +2838,4665 @@ class VkDecoderSnapshot::Impl {
                                                 (uint64_t)(uintptr_t)boxed_VkImage,
                                                 VkReconstruction::BOUND_MEMORY);
         }
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkBindImageMemory2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         // Note: the implementation does not work with bindInfoCount > 1
         for (uint32_t i = 0; i < bindInfoCount; ++i) {
             VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage(pBindInfos[i].image);
-            mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkImage, 1, apiHandle,
+            mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkImage, 1, apiCallHandle,
                                                 VkReconstruction::BOUND_MEMORY);
         }
     }
 #endif
 #ifdef VK_KHR_maintenance3
-    void vkGetDescriptorSetLayoutSupportKHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
+    void vkGetDescriptorSetLayoutSupportKHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device,
                                             const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                             VkDescriptorSetLayoutSupport* pSupport) {}
 #endif
 #ifdef VK_KHR_buffer_device_address
-    void vkGetBufferDeviceAddressKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkDeviceAddress input_result,
-                                     VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {}
-    void vkGetBufferOpaqueCaptureAddressKHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, uint64_t input_result,
-                                            VkDevice device,
+    void vkGetBufferDeviceAddressKHR(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkDeviceAddress input_result, VkDevice device,
+                                     const VkBufferDeviceAddressInfo* pInfo) {}
+    void vkGetBufferOpaqueCaptureAddressKHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            uint64_t input_result, VkDevice device,
                                             const VkBufferDeviceAddressInfo* pInfo) {}
     void vkGetDeviceMemoryOpaqueCaptureAddressKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        uint64_t input_result, VkDevice device,
-        const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, uint64_t input_result,
+        VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {}
 #endif
 #ifdef VK_KHR_pipeline_executable_properties
     void vkGetPipelineExecutablePropertiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, const VkPipelineInfoKHR* pPipelineInfo,
-        uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount,
+        VkPipelineExecutablePropertiesKHR* pProperties) {}
     void vkGetPipelineExecutableStatisticsKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
         uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics) {}
     void vkGetPipelineExecutableInternalRepresentationsKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
         uint32_t* pInternalRepresentationCount,
         VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) {}
 #endif
 #ifdef VK_KHR_synchronization2
-    void vkCmdSetEvent2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkEvent event, const VkDependencyInfo* pDependencyInfo) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetEvent2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkEvent event,
+                           const VkDependencyInfo* pDependencyInfo) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetEvent2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdResetEvent2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             VkEvent event, VkPipelineStageFlags2 stageMask) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdResetEvent2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, VkEvent event,
+                             VkPipelineStageFlags2 stageMask) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdResetEvent2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdWaitEvents2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             uint32_t eventCount, const VkEvent* pEvents,
-                             const VkDependencyInfo* pDependencyInfos) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdWaitEvents2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, uint32_t eventCount,
+                             const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdWaitEvents2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdPipelineBarrier2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdPipelineBarrier2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer,
                                   const VkDependencyInfo* pDependencyInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdPipelineBarrier2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdWriteTimestamp2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 VkPipelineStageFlags2 stage, VkQueryPool queryPool,
-                                 uint32_t query) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdWriteTimestamp2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
+                                 VkQueryPool queryPool, uint32_t query) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdWriteTimestamp2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkQueueSubmit2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
-                           uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence) {}
-    void vkCmdWriteBufferMarker2AMD(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    VkPipelineStageFlags2 stage, VkBuffer dstBuffer,
-                                    VkDeviceSize dstOffset, uint32_t marker) {
-        android::base::AutoLock lock(mLock);
+    void vkQueueSubmit2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkQueue queue, uint32_t submitCount,
+                           const VkSubmitInfo2* pSubmits, VkFence fence) {}
+    void vkCmdWriteBufferMarker2AMD(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
+                                    VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdWriteBufferMarker2AMD, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkGetQueueCheckpointData2NV(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkQueue queue,
-                                     uint32_t* pCheckpointDataCount,
+    void vkGetQueueCheckpointData2NV(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkQueue queue, uint32_t* pCheckpointDataCount,
                                      VkCheckpointData2NV* pCheckpointData) {}
 #endif
 #ifdef VK_KHR_copy_commands2
-    void vkCmdCopyBuffer2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyBuffer2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer,
                              const VkCopyBufferInfo2* pCopyBufferInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBuffer2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            const VkCopyImageInfo2* pCopyImageInfo) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdCopyImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImage2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyBufferToImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyBufferToImage2KHR(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer,
                                     const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyBufferToImage2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdCopyImageToBuffer2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyImageToBuffer2KHR(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer,
                                     const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdCopyImageToBuffer2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBlitImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            const VkBlitImageInfo2* pBlitImageInfo) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBlitImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBlitImage2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdResolveImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdResolveImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer,
                                const VkResolveImageInfo2* pResolveImageInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdResolveImage2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_KHR_maintenance4
-    void vkGetDeviceBufferMemoryRequirementsKHR(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceBufferMemoryRequirementsKHR(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize, VkDevice device,
                                                 const VkDeviceBufferMemoryRequirements* pInfo,
                                                 VkMemoryRequirements2* pMemoryRequirements) {}
-    void vkGetDeviceImageMemoryRequirementsKHR(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceImageMemoryRequirementsKHR(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* apiCallInfo,
+                                               const uint8_t* apiCallPacket,
+                                               size_t apiCallPacketSize, VkDevice device,
                                                const VkDeviceImageMemoryRequirements* pInfo,
                                                VkMemoryRequirements2* pMemoryRequirements) {}
     void vkGetDeviceImageSparseMemoryRequirementsKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
-        uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {}
 #endif
 #ifdef VK_KHR_maintenance5
-    void vkCmdBindIndexBuffer2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size,
-                                  VkIndexType indexType) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBindIndexBuffer2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkBuffer buffer,
+                                  VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindIndexBuffer2KHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkGetRenderingAreaGranularityKHR(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetRenderingAreaGranularityKHR(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device,
                                           const VkRenderingAreaInfoKHR* pRenderingAreaInfo,
                                           VkExtent2D* pGranularity) {}
-    void vkGetDeviceImageSubresourceLayoutKHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceImageSubresourceLayoutKHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkDevice device,
                                               const VkDeviceImageSubresourceInfoKHR* pInfo,
                                               VkSubresourceLayout2KHR* pLayout) {}
-    void vkGetImageSubresourceLayout2KHR(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetImageSubresourceLayout2KHR(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkImage image,
                                          const VkImageSubresource2KHR* pSubresource,
                                          VkSubresourceLayout2KHR* pLayout) {}
 #endif
 #ifdef VK_KHR_line_rasterization
-    void vkCmdSetLineStippleKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetLineStippleKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
+                                uint16_t lineStipplePattern) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetLineStippleKHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_ANDROID_native_buffer
-    void vkGetSwapchainGrallocUsageANDROID(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetSwapchainGrallocUsageANDROID(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device, VkFormat format,
                                            VkImageUsageFlags imageUsage, int* grallocUsage) {}
-    void vkAcquireImageANDROID(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkImage image, int nativeFenceFd,
-                               VkSemaphore semaphore, VkFence fence) {}
-    void vkQueueSignalReleaseImageANDROID(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkAcquireImageANDROID(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, VkImage image,
+                               int nativeFenceFd, VkSemaphore semaphore, VkFence fence) {}
+    void vkQueueSignalReleaseImageANDROID(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkQueue queue,
                                           uint32_t waitSemaphoreCount,
                                           const VkSemaphore* pWaitSemaphores, VkImage image,
                                           int* pNativeFenceFd) {}
-    void vkGetSwapchainGrallocUsage2ANDROID(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
-        VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
-        uint64_t* grallocProducerUsage) {}
+    void vkGetSwapchainGrallocUsage2ANDROID(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, VkDevice device, VkFormat format,
+                                            VkImageUsageFlags imageUsage,
+                                            VkSwapchainImageUsageFlagsANDROID swapchainImageUsage,
+                                            uint64_t* grallocConsumerUsage,
+                                            uint64_t* grallocProducerUsage) {}
 #endif
 #ifdef VK_EXT_debug_report
-    void vkCreateDebugReportCallbackEXT(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateDebugReportCallbackEXT(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkInstance instance,
                                         const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkDebugReportCallbackEXT* pCallback) {
         if (!pCallback) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pCallback create
         mReconstruction.addHandles((const uint64_t*)pCallback, 1);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateDebugReportCallbackEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pCallback, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pCallback, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pCallback, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pCallback, 1);
     }
-    void vkDestroyDebugReportCallbackEXT(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkDestroyDebugReportCallbackEXT(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkInstance instance, VkDebugReportCallbackEXT callback,
                                          const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // callback destroy
         mReconstruction.removeHandles((const uint64_t*)(&callback), 1, true);
     }
-    void vkDebugReportMessageEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkInstance instance,
-                                 VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType,
-                                 uint64_t object, size_t location, int32_t messageCode,
-                                 const char* pLayerPrefix, const char* pMessage) {}
+    void vkDebugReportMessageEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkInstance instance, VkDebugReportFlagsEXT flags,
+                                 VkDebugReportObjectTypeEXT objectType, uint64_t object,
+                                 size_t location, int32_t messageCode, const char* pLayerPrefix,
+                                 const char* pMessage) {}
 #endif
 #ifdef VK_EXT_transform_feedback
     void vkCmdBindTransformFeedbackBuffersEXT(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
-        const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes) {
-        android::base::AutoLock lock(mLock);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+        uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers,
+        const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindTransformFeedbackBuffersEXT,
-                                    snapshotTraceBegin, snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBeginTransformFeedbackEXT(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdBeginTransformFeedbackEXT(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                         uint32_t counterBufferCount,
                                         const VkBuffer* pCounterBuffers,
                                         const VkDeviceSize* pCounterBufferOffsets) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginTransformFeedbackEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdEndTransformFeedbackEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      uint32_t firstCounterBuffer, uint32_t counterBufferCount,
-                                      const VkBuffer* pCounterBuffers,
+    void vkCmdEndTransformFeedbackEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
+                                      uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
                                       const VkDeviceSize* pCounterBufferOffsets) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndTransformFeedbackEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBeginQueryIndexedEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginQueryIndexedEXT(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags,
                                    uint32_t index) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginQueryIndexedEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdEndQueryIndexedEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 VkQueryPool queryPool, uint32_t query, uint32_t index) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdEndQueryIndexedEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, VkQueryPool queryPool,
+                                 uint32_t query, uint32_t index) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndQueryIndexedEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdDrawIndirectByteCountEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       uint32_t instanceCount, uint32_t firstInstance,
-                                       VkBuffer counterBuffer, VkDeviceSize counterBufferOffset,
-                                       uint32_t counterOffset, uint32_t vertexStride) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdDrawIndirectByteCountEXT(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, uint32_t instanceCount,
+                                       uint32_t firstInstance, VkBuffer counterBuffer,
+                                       VkDeviceSize counterBufferOffset, uint32_t counterOffset,
+                                       uint32_t vertexStride) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdDrawIndirectByteCountEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_EXT_debug_utils
-    void vkSetDebugUtilsObjectNameEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkResult input_result,
-                                      VkDevice device,
+    void vkSetDebugUtilsObjectNameEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkResult input_result, VkDevice device,
                                       const VkDebugUtilsObjectNameInfoEXT* pNameInfo) {}
-    void vkSetDebugUtilsObjectTagEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkResult input_result,
-                                     VkDevice device,
+    void vkSetDebugUtilsObjectTagEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkResult input_result, VkDevice device,
                                      const VkDebugUtilsObjectTagInfoEXT* pTagInfo) {}
-    void vkQueueBeginDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkQueueBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo) {}
-    void vkQueueEndDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkQueue queue) {}
-    void vkQueueInsertDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkQueueEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkQueue queue) {}
+    void vkQueueInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo) {}
-    void vkCmdBeginDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer,
                                       const VkDebugUtilsLabelEXT* pLabelInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBeginDebugUtilsLabelEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdEndDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdEndDebugUtilsLabelEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdInsertDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer,
                                        const VkDebugUtilsLabelEXT* pLabelInfo) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdInsertDebugUtilsLabelEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCreateDebugUtilsMessengerEXT(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateDebugUtilsMessengerEXT(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkInstance instance,
                                         const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkDebugUtilsMessengerEXT* pMessenger) {
         if (!pMessenger) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pMessenger create
         mReconstruction.addHandles((const uint64_t*)pMessenger, 1);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateDebugUtilsMessengerEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pMessenger, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pMessenger, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pMessenger, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pMessenger, 1);
     }
-    void vkDestroyDebugUtilsMessengerEXT(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkDestroyDebugUtilsMessengerEXT(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkInstance instance, VkDebugUtilsMessengerEXT messenger,
                                          const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // messenger destroy
         mReconstruction.removeHandles((const uint64_t*)(&messenger), 1, true);
     }
-    void vkSubmitDebugUtilsMessageEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkInstance instance,
+    void vkSubmitDebugUtilsMessageEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkInstance instance,
                                       VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                       VkDebugUtilsMessageTypeFlagsEXT messageTypes,
                                       const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData) {}
 #endif
 #ifdef VK_EXT_image_drm_format_modifier
     void vkGetImageDrmFormatModifierPropertiesEXT(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, VkImage image,
-        VkImageDrmFormatModifierPropertiesEXT* pProperties) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties) {}
 #endif
 #ifdef VK_EXT_external_memory_host
     void vkGetMemoryHostPointerPropertiesEXT(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType,
-        const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer,
+        VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {}
 #endif
 #ifdef VK_EXT_tooling_info
-    void vkGetPhysicalDeviceToolPropertiesEXT(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
+    void vkGetPhysicalDeviceToolPropertiesEXT(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkResult input_result,
                                               VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
                                               VkPhysicalDeviceToolProperties* pToolProperties) {}
 #endif
 #ifdef VK_EXT_line_rasterization
-    void vkCmdSetLineStippleEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetLineStippleEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
+                                uint16_t lineStipplePattern) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetLineStippleEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-    void vkCmdSetCullModeEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             VkCullModeFlags cullMode) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetCullModeEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetCullModeEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetFrontFaceEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkFrontFace frontFace) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetFrontFaceEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetFrontFaceEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetPrimitiveTopologyEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetPrimitiveTopologyEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer,
                                       VkPrimitiveTopology primitiveTopology) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPrimitiveTopologyEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetViewportWithCountEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      uint32_t viewportCount, const VkViewport* pViewports) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetViewportWithCountEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer, uint32_t viewportCount,
+                                      const VkViewport* pViewports) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetViewportWithCountEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetScissorWithCountEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                     uint32_t scissorCount, const VkRect2D* pScissors) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetScissorWithCountEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkCommandBuffer commandBuffer, uint32_t scissorCount,
+                                     const VkRect2D* pScissors) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetScissorWithCountEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdBindVertexBuffers2EXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    uint32_t firstBinding, uint32_t bindingCount,
-                                    const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
-                                    const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdBindVertexBuffers2EXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, uint32_t firstBinding,
+                                    uint32_t bindingCount, const VkBuffer* pBuffers,
+                                    const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
+                                    const VkDeviceSize* pStrides) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdBindVertexBuffers2EXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthTestEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    VkBool32 depthTestEnable) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDepthTestEnableEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthTestEnableEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthWriteEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                     VkBool32 depthWriteEnable) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDepthWriteEnableEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthWriteEnableEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthCompareOpEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetDepthCompareOpEXT(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkCompareOp depthCompareOp) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthCompareOpEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthBoundsTestEnableEXT(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdSetDepthBoundsTestEnableEXT(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer,
                                           VkBool32 depthBoundsTestEnable) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBoundsTestEnableEXT,
-                                    snapshotTraceBegin, snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetStencilTestEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      VkBool32 stencilTestEnable) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetStencilTestEnableEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilTestEnableEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetStencilOpEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp,
-                              VkStencilOp depthFailOp, VkCompareOp compareOp) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetStencilOpEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                              VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
+                              VkCompareOp compareOp) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetStencilOpEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_EXT_host_image_copy
-    void vkCopyMemoryToImageEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device,
+    void vkCopyMemoryToImageEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
                                 const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo) {}
-    void vkCopyImageToMemoryEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device,
+    void vkCopyImageToMemoryEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
                                 const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo) {}
-    void vkCopyImageToImageEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device,
+    void vkCopyImageToImageEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device,
                                const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo) {}
-    void vkTransitionImageLayoutEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    VkDevice device, uint32_t transitionCount,
+    void vkTransitionImageLayoutEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, VkDevice device,
+                                    uint32_t transitionCount,
                                     const VkHostImageLayoutTransitionInfoEXT* pTransitions) {}
-    void vkGetImageSubresourceLayout2EXT(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetImageSubresourceLayout2EXT(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkImage image,
                                          const VkImageSubresource2KHR* pSubresource,
                                          VkSubresourceLayout2KHR* pLayout) {}
 #endif
 #ifdef VK_EXT_swapchain_maintenance1
-    void vkReleaseSwapchainImagesEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkResult input_result,
-                                     VkDevice device,
+    void vkReleaseSwapchainImagesEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkResult input_result, VkDevice device,
                                      const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo) {}
 #endif
 #ifdef VK_EXT_private_data
-    void vkCreatePrivateDataSlotEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
+    void vkCreatePrivateDataSlotEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, VkDevice device,
+                                    const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkPrivateDataSlot* pPrivateDataSlot) {}
-    void vkDestroyPrivateDataSlotEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkDevice device,
-                                     VkPrivateDataSlot privateDataSlot,
+    void vkDestroyPrivateDataSlotEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkDevice device, VkPrivateDataSlot privateDataSlot,
                                      const VkAllocationCallbacks* pAllocator) {}
-    void vkSetPrivateDataEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                             VkObjectType objectType, uint64_t objectHandle,
-                             VkPrivateDataSlot privateDataSlot, uint64_t data) {}
-    void vkGetPrivateDataEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkDevice device,
-                             VkObjectType objectType, uint64_t objectHandle,
+    void vkSetPrivateDataEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device, VkObjectType objectType,
+                             uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
+                             uint64_t data) {}
+    void vkGetPrivateDataEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                              VkPrivateDataSlot privateDataSlot, uint64_t* pData) {}
 #endif
 #ifdef VK_EXT_extended_dynamic_state2
-    void vkCmdSetPatchControlPointsEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       uint32_t patchControlPoints) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetPatchControlPointsEXT(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, uint32_t patchControlPoints) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPatchControlPointsEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetRasterizerDiscardEnableEXT(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+    void vkCmdSetRasterizerDiscardEnableEXT(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             VkBool32 rasterizerDiscardEnable) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetRasterizerDiscardEnableEXT,
-                                    snapshotTraceBegin, snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetDepthBiasEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    VkBool32 depthBiasEnable) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetDepthBiasEnableEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetDepthBiasEnableEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetLogicOpEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            VkLogicOp logicOp) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetLogicOpEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetLogicOpEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCmdSetPrimitiveRestartEnableEXT(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdSetPrimitiveRestartEnableEXT(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            VkBool32 primitiveRestartEnable) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetPrimitiveRestartEnableEXT,
-                                    snapshotTraceBegin, snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_EXT_color_write_enable
-    void vkCmdSetColorWriteEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                     uint32_t attachmentCount, const VkBool32* pColorWriteEnables) {
-        android::base::AutoLock lock(mLock);
+    void vkCmdSetColorWriteEnableEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkCommandBuffer commandBuffer, uint32_t attachmentCount,
+                                     const VkBool32* pColorWriteEnables) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetColorWriteEnableEXT, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-    void vkMapMemoryIntoAddressSpaceGOOGLE(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkMapMemoryIntoAddressSpaceGOOGLE(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            VkDeviceMemory memory, uint64_t* pAddress) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // memory modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkMapMemoryIntoAddressSpaceGOOGLE,
-                                    snapshotTraceBegin, snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             VkDeviceMemory boxed = unboxed_to_boxed_non_dispatchable_VkDeviceMemory((&memory)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
     void vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, VkDescriptorSet descriptorSet,
-        VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-        uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
-        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
-        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
-        const VkBufferView* pBufferViews) {}
-    void vkBeginCommandBufferAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
+        const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
+        const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
+        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews) {}
+    void vkBeginCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          const VkCommandBufferBeginInfo* pBeginInfo) {}
-    void vkEndCommandBufferAsyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool,
+    void vkEndCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer) {}
-    void vkResetCommandBufferAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkResetCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          VkCommandBufferResetFlags flags) {}
-    void vkCommandBufferHostSyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       uint32_t needHostSync, uint32_t sequenceNumber) {}
-    void vkCreateImageWithRequirementsGOOGLE(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkResult input_result,
-                                             VkDevice device, const VkImageCreateInfo* pCreateInfo,
+    void vkCommandBufferHostSyncGOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, uint32_t needHostSync,
+                                       uint32_t sequenceNumber) {}
+    void vkCreateImageWithRequirementsGOOGLE(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkResult input_result, VkDevice device,
+                                             const VkImageCreateInfo* pCreateInfo,
                                              const VkAllocationCallbacks* pAllocator,
                                              VkImage* pImage,
                                              VkMemoryRequirements* pMemoryRequirements) {
         if (!pImage) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pImage create
         mReconstruction.addHandles((const uint64_t*)pImage, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pImage, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateImageWithRequirementsGOOGLE,
-                                    snapshotTraceBegin, snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pImage, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pImage, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pImage, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pImage, 1);
     }
     void vkCreateBufferWithRequirementsGOOGLE(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, const VkBufferCreateInfo* pCreateInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkBufferCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer,
         VkMemoryRequirements* pMemoryRequirements) {
         if (!pBuffer) return;
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // pBuffer create
         mReconstruction.addHandles((const uint64_t*)pBuffer, 1);
         mReconstruction.addHandleDependency((const uint64_t*)pBuffer, 1,
                                             (uint64_t)(uintptr_t)device);
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCreateBufferWithRequirementsGOOGLE,
-                                    snapshotTraceBegin, snapshotTraceBytes);
-        mReconstruction.forEachHandleAddApi((const uint64_t*)pBuffer, 1, apiHandle,
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
+        mReconstruction.forEachHandleAddApi((const uint64_t*)pBuffer, 1, apiCallHandle,
                                             VkReconstruction::CREATED);
-        mReconstruction.setCreatedHandlesForApi(apiHandle, (const uint64_t*)pBuffer, 1);
+        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pBuffer, 1);
     }
-    void vkGetMemoryHostAddressInfoGOOGLE(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetMemoryHostAddressInfoGOOGLE(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           VkDeviceMemory memory, uint64_t* pAddress,
                                           uint64_t* pSize, uint64_t* pHostmemId) {}
-    void vkFreeMemorySyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, VkDeviceMemory memory,
+    void vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device, VkDeviceMemory memory,
                                 const VkAllocationCallbacks* pAllocator) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // memory destroy
         mReconstruction.removeHandles((const uint64_t*)(&memory), 1, true);
     }
-    void vkQueueHostSyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkQueue queue, uint32_t needHostSync,
-                               uint32_t sequenceNumber) {}
-    void vkQueueSubmitAsyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkQueue queue,
-                                  uint32_t submitCount, const VkSubmitInfo* pSubmits,
+    void vkQueueHostSyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkQueue queue, uint32_t needHostSync, uint32_t sequenceNumber) {}
+    void vkQueueSubmitAsyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                   VkFence fence) {}
-    void vkQueueWaitIdleAsyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkQueue queue) {}
-    void vkQueueBindSparseAsyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkQueue queue,
-                                      uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
-                                      VkFence fence) {}
-    void vkGetLinearImageLayoutGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkDevice device,
-                                      VkFormat format, VkDeviceSize* pOffset,
+    void vkQueueWaitIdleAsyncGOOGLE(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkQueue queue) {}
+    void vkQueueBindSparseAsyncGOOGLE(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkQueue queue, uint32_t bindInfoCount,
+                                      const VkBindSparseInfo* pBindInfo, VkFence fence) {}
+    void vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkDevice device, VkFormat format, VkDeviceSize* pOffset,
                                       VkDeviceSize* pRowPitchAlignment) {}
-    void vkGetLinearImageLayout2GOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkDevice device,
-                                       const VkImageCreateInfo* pCreateInfo, VkDeviceSize* pOffset,
-                                       VkDeviceSize* pRowPitchAlignment) {}
-    void vkQueueFlushCommandsGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkQueue queue,
-                                    VkCommandBuffer commandBuffer, VkDeviceSize dataSize,
-                                    const void* pData) {}
+    void vkGetLinearImageLayout2GOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkDevice device, const VkImageCreateInfo* pCreateInfo,
+                                       VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment) {}
+    void vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkQueue queue, VkCommandBuffer commandBuffer,
+                                    VkDeviceSize dataSize, const void* pData) {}
     void vkQueueCommitDescriptorSetUpdatesGOOGLE(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkQueue queue, uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkQueue queue,
+        uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
         uint32_t descriptorSetCount, const VkDescriptorSetLayout* pSetLayouts,
         const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
         const uint32_t* pDescriptorSetPendingAllocation,
         const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
         const VkWriteDescriptorSet* pPendingDescriptorWrites) {}
-    void vkCollectDescriptorPoolIdsGOOGLE(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCollectDescriptorPoolIdsGOOGLE(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device, VkDescriptorPool descriptorPool,
                                           uint32_t* pPoolIdCount, uint64_t* pPoolIds) {}
-    void vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool, VkQueue queue,
-                                                     uint32_t waitSemaphoreCount,
-                                                     const VkSemaphore* pWaitSemaphores,
-                                                     VkImage image) {}
-    void vkQueueFlushCommandsFromAuxMemoryGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool, VkQueue queue,
+    void vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkQueue queue,
+        uint32_t waitSemaphoreCount, const VkSemaphore* pWaitSemaphores, VkImage image) {}
+    void vkQueueFlushCommandsFromAuxMemoryGOOGLE(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize, VkQueue queue,
                                                  VkCommandBuffer commandBuffer,
                                                  VkDeviceMemory deviceMemory,
                                                  VkDeviceSize dataOffset, VkDeviceSize dataSize) {}
-    void vkGetBlobGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                         VkDeviceMemory memory) {
-        android::base::AutoLock lock(mLock);
+    void vkGetBlobGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkDevice device, VkDeviceMemory memory) {
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // memory modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkGetBlobGOOGLE, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             VkDeviceMemory boxed = unboxed_to_boxed_non_dispatchable_VkDeviceMemory((&memory)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
     void vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, VkDescriptorSet descriptorSet,
-        VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-        uint32_t bufferInfoCount, uint32_t bufferViewCount, uint32_t inlineUniformBlockCount,
-        const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
-        const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
-        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews,
-        const uint8_t* pInlineUniformBlockData) {}
-    void vkQueueSubmitAsync2GOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkQueue queue,
-                                   uint32_t submitCount, const VkSubmitInfo2* pSubmits,
-                                   VkFence fence) {}
-    void vkGetSemaphoreGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                              VkSemaphore semaphore, uint64_t syncId) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
+        uint32_t inlineUniformBlockCount, const uint32_t* pImageInfoEntryIndices,
+        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
+        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
+        const VkBufferView* pBufferViews, const uint8_t* pInlineUniformBlockData) {}
+    void vkQueueSubmitAsync2GOOGLE(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkQueue queue, uint32_t submitCount,
+                                   const VkSubmitInfo2* pSubmits, VkFence fence) {}
+    void vkGetSemaphoreGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkDevice device, VkSemaphore semaphore,
+                              uint64_t syncId) {}
 #endif
 #ifdef VK_KHR_ray_tracing_pipeline
-    void vkCmdTraceRaysKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdTraceRaysKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer,
                            const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
                            const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
                            const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
                            const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
                            uint32_t width, uint32_t height, uint32_t depth) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdTraceRaysKHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkCreateRayTracingPipelinesKHR(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
-                                        VkResult input_result, VkDevice device,
-                                        VkDeferredOperationKHR deferredOperation,
-                                        VkPipelineCache pipelineCache, uint32_t createInfoCount,
-                                        const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
-                                        const VkAllocationCallbacks* pAllocator,
-                                        VkPipeline* pPipelines) {}
+    void vkCreateRayTracingPipelinesKHR(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache,
+        uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
+        const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {}
     void vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, VkPipeline pipeline, uint32_t firstGroup,
-        uint32_t groupCount, size_t dataSize, void* pData) {}
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount,
+        size_t dataSize, void* pData) {}
     void vkCmdTraceRaysIndirectKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkCommandBuffer commandBuffer,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
         const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
         const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
         const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
         const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
         VkDeviceAddress indirectDeviceAddress) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdTraceRaysIndirectKHR, snapshotTraceBegin,
-                                    snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
-    void vkGetRayTracingShaderGroupStackSizeKHR(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
-                                                VkDeviceSize input_result, VkDevice device,
-                                                VkPipeline pipeline, uint32_t group,
-                                                VkShaderGroupShaderKHR groupShader) {}
-    void vkCmdSetRayTracingPipelineStackSizeKHR(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
+    void vkGetRayTracingShaderGroupStackSizeKHR(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDeviceSize input_result,
+        VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) {}
+    void vkCmdSetRayTracingPipelineStackSizeKHR(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize,
                                                 VkCommandBuffer commandBuffer,
                                                 uint32_t pipelineStackSize) {
-        android::base::AutoLock lock(mLock);
+        std::lock_guard<std::mutex> lock(mReconstructionMutex);
         // commandBuffer modify
-        auto apiHandle = mReconstruction.createApiInfo();
-        auto apiInfo = mReconstruction.getApiInfo(apiHandle);
-        mReconstruction.setApiTrace(apiInfo, OP_vkCmdSetRayTracingPipelineStackSizeKHR,
-                                    snapshotTraceBegin, snapshotTraceBytes);
+        auto apiCallHandle = apiCallInfo->handle;
+        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
         for (uint32_t i = 0; i < 1; ++i) {
             // commandBuffer is already boxed, no need to box again
             VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
-            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiHandle);
+            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
         }
     }
 #endif
    private:
-    android::base::Lock mLock;
-    VkReconstruction mReconstruction;
+    std::mutex mReconstructionMutex;
+    VkReconstruction mReconstruction GUARDED_BY(mReconstructionMutex);
 };
 
 VkDecoderSnapshot::VkDecoderSnapshot() : mImpl(new VkDecoderSnapshot::Impl()) {}
 
-void VkDecoderSnapshot::save(android::base::Stream* stream) { mImpl->save(stream); }
+void VkDecoderSnapshot::clear() { mImpl->clear(); }
 
-void VkDecoderSnapshot::load(android::base::Stream* stream, GfxApiLogger& gfx_logger,
-                             HealthMonitor<>* healthMonitor) {
-    mImpl->load(stream, gfx_logger, healthMonitor);
+void VkDecoderSnapshot::saveReplayBuffers(android::base::Stream* stream) {
+    mImpl->saveReplayBuffers(stream);
 }
 
-void VkDecoderSnapshot::createExtraHandlesForNextApi(const uint64_t* created, uint32_t count) {
-    mImpl->createExtraHandlesForNextApi(created, count);
+/*static*/
+void VkDecoderSnapshot::loadReplayBuffers(android::base::Stream* stream,
+                                          std::vector<uint64_t>* outHandleBuffer,
+                                          std::vector<uint8_t>* outDecoderBuffer) {
+    VkDecoderSnapshot::Impl::loadReplayBuffers(stream, outHandleBuffer, outDecoderBuffer);
+}
+
+VkSnapshotApiCallInfo* VkDecoderSnapshot::createApiCallInfo() { return mImpl->createApiCallInfo(); }
+
+void VkDecoderSnapshot::destroyApiCallInfoIfUnused(VkSnapshotApiCallInfo* info) {
+    mImpl->destroyApiCallInfoIfUnused(info);
 }
 
 VkDecoderSnapshot::~VkDecoderSnapshot() = default;
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateInstance(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
-                                         VkResult input_result,
-                                         const VkInstanceCreateInfo* pCreateInfo,
-                                         const VkAllocationCallbacks* pAllocator,
-                                         VkInstance* pInstance) {
-    mImpl->vkCreateInstance(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, pCreateInfo,
-                            pAllocator, pInstance);
+void VkDecoderSnapshot::vkCreateInstance(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, const VkInstanceCreateInfo* pCreateInfo,
+    const VkAllocationCallbacks* pAllocator, VkInstance* pInstance) {
+    mImpl->vkCreateInstance(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                            pCreateInfo, pAllocator, pInstance);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyInstance(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkDestroyInstance(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkInstance instance,
                                           const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyInstance(snapshotTraceBegin, snapshotTraceBytes, pool, instance, pAllocator);
+    mImpl->vkDestroyInstance(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, instance,
+                             pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkEnumeratePhysicalDevices(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool,
-                                                   VkResult input_result, VkInstance instance,
-                                                   uint32_t* pPhysicalDeviceCount,
-                                                   VkPhysicalDevice* pPhysicalDevices) {
-    mImpl->vkEnumeratePhysicalDevices(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                      instance, pPhysicalDeviceCount, pPhysicalDevices);
+void VkDecoderSnapshot::vkEnumeratePhysicalDevices(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkInstance instance,
+    uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices) {
+    mImpl->vkEnumeratePhysicalDevices(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      input_result, instance, pPhysicalDeviceCount,
+                                      pPhysicalDevices);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetPhysicalDeviceFeatures(const uint8_t* snapshotTraceBegin,
-                                                    size_t snapshotTraceBytes,
-                                                    android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetPhysicalDeviceFeatures(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                                    const uint8_t* apiCallPacket,
+                                                    size_t apiCallPacketSize,
                                                     VkPhysicalDevice physicalDevice,
                                                     VkPhysicalDeviceFeatures* pFeatures) {
-    mImpl->vkGetPhysicalDeviceFeatures(snapshotTraceBegin, snapshotTraceBytes, pool, physicalDevice,
-                                       pFeatures);
+    mImpl->vkGetPhysicalDeviceFeatures(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                       physicalDevice, pFeatures);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkGetPhysicalDeviceFormatProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties) {
-    mImpl->vkGetPhysicalDeviceFormatProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, VkFormat format,
+    VkFormatProperties* pFormatProperties) {
+    mImpl->vkGetPhysicalDeviceFormatProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                physicalDevice, format, pFormatProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkGetPhysicalDeviceImageFormatProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
-    VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags,
-    VkImageFormatProperties* pImageFormatProperties) {
-    mImpl->vkGetPhysicalDeviceImageFormatProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                    input_result, physicalDevice, format, type,
-                                                    tiling, usage, flags, pImageFormatProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
+    VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage,
+    VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties) {
+    mImpl->vkGetPhysicalDeviceImageFormatProperties(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, physicalDevice, format,
+        type, tiling, usage, flags, pImageFormatProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetPhysicalDeviceProperties(const uint8_t* snapshotTraceBegin,
-                                                      size_t snapshotTraceBytes,
-                                                      android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetPhysicalDeviceProperties(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                                      const uint8_t* apiCallPacket,
+                                                      size_t apiCallPacketSize,
                                                       VkPhysicalDevice physicalDevice,
                                                       VkPhysicalDeviceProperties* pProperties) {
-    mImpl->vkGetPhysicalDeviceProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkGetPhysicalDeviceProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          physicalDevice, pProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkGetPhysicalDeviceQueueFamilyProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
     VkQueueFamilyProperties* pQueueFamilyProperties) {
-    mImpl->vkGetPhysicalDeviceQueueFamilyProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                    physicalDevice, pQueueFamilyPropertyCount,
-                                                    pQueueFamilyProperties);
+    mImpl->vkGetPhysicalDeviceQueueFamilyProperties(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice,
+        pQueueFamilyPropertyCount, pQueueFamilyProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkGetPhysicalDeviceMemoryProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
-    mImpl->vkGetPhysicalDeviceMemoryProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
+    mImpl->vkGetPhysicalDeviceMemoryProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                physicalDevice, pMemoryProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetInstanceProcAddr(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetInstanceProcAddr(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize,
                                               PFN_vkVoidFunction input_result, VkInstance instance,
                                               const char* pName) {
-    mImpl->vkGetInstanceProcAddr(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkGetInstanceProcAddr(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  instance, pName);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetDeviceProcAddr(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetDeviceProcAddr(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             PFN_vkVoidFunction input_result, VkDevice device,
                                             const char* pName) {
-    mImpl->vkGetDeviceProcAddr(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                               pName);
+    mImpl->vkGetDeviceProcAddr(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                               device, pName);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateDevice(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkResult input_result,
-                                       VkPhysicalDevice physicalDevice,
+void VkDecoderSnapshot::vkCreateDevice(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkResult input_result, VkPhysicalDevice physicalDevice,
                                        const VkDeviceCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator, VkDevice* pDevice) {
-    mImpl->vkCreateDevice(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkCreateDevice(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                           physicalDevice, pCreateInfo, pAllocator, pDevice);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyDevice(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkDestroyDevice(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device, const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyDevice(snapshotTraceBegin, snapshotTraceBytes, pool, device, pAllocator);
+    mImpl->vkDestroyDevice(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkEnumerateInstanceExtensionProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, const char* pLayerName, uint32_t* pPropertyCount,
-    VkExtensionProperties* pProperties) {
-    mImpl->vkEnumerateInstanceExtensionProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                  input_result, pLayerName, pPropertyCount,
-                                                  pProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, const char* pLayerName,
+    uint32_t* pPropertyCount, VkExtensionProperties* pProperties) {
+    mImpl->vkEnumerateInstanceExtensionProperties(pool, apiCallInfo, apiCallPacket,
+                                                  apiCallPacketSize, input_result, pLayerName,
+                                                  pPropertyCount, pProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkEnumerateDeviceExtensionProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkPhysicalDevice physicalDevice, const char* pLayerName,
-    uint32_t* pPropertyCount, VkExtensionProperties* pProperties) {
-    mImpl->vkEnumerateDeviceExtensionProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
+    const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties) {
+    mImpl->vkEnumerateDeviceExtensionProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 input_result, physicalDevice, pLayerName,
                                                 pPropertyCount, pProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkEnumerateInstanceLayerProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, uint32_t* pPropertyCount, VkLayerProperties* pProperties) {
-    mImpl->vkEnumerateInstanceLayerProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, uint32_t* pPropertyCount,
+    VkLayerProperties* pProperties) {
+    mImpl->vkEnumerateInstanceLayerProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               input_result, pPropertyCount, pProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkEnumerateDeviceLayerProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount,
-    VkLayerProperties* pProperties) {
-    mImpl->vkEnumerateDeviceLayerProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
+    uint32_t* pPropertyCount, VkLayerProperties* pProperties) {
+    mImpl->vkEnumerateDeviceLayerProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             input_result, physicalDevice, pPropertyCount,
                                             pProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetDeviceQueue(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetDeviceQueue(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, uint32_t queueFamilyIndex,
                                          uint32_t queueIndex, VkQueue* pQueue) {
-    mImpl->vkGetDeviceQueue(snapshotTraceBegin, snapshotTraceBytes, pool, device, queueFamilyIndex,
-                            queueIndex, pQueue);
+    mImpl->vkGetDeviceQueue(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                            queueFamilyIndex, queueIndex, pQueue);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkQueueSubmit(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkResult input_result,
-                                      VkQueue queue, uint32_t submitCount,
+void VkDecoderSnapshot::vkQueueSubmit(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkResult input_result, VkQueue queue, uint32_t submitCount,
                                       const VkSubmitInfo* pSubmits, VkFence fence) {
-    mImpl->vkQueueSubmit(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, queue,
+    mImpl->vkQueueSubmit(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, queue,
                          submitCount, pSubmits, fence);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkQueueWaitIdle(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkQueueWaitIdle(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkQueue queue) {
-    mImpl->vkQueueWaitIdle(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, queue);
+    mImpl->vkQueueWaitIdle(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                           queue);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDeviceWaitIdle(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkDeviceWaitIdle(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device) {
-    mImpl->vkDeviceWaitIdle(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device);
+    mImpl->vkDeviceWaitIdle(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                            device);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkAllocateMemory(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkAllocateMemory(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device,
                                          const VkMemoryAllocateInfo* pAllocateInfo,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkDeviceMemory* pMemory) {
-    mImpl->vkAllocateMemory(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                            pAllocateInfo, pAllocator, pMemory);
+    mImpl->vkAllocateMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                            device, pAllocateInfo, pAllocator, pMemory);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkFreeMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkDevice device,
-                                     VkDeviceMemory memory,
+void VkDecoderSnapshot::vkFreeMemory(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkDevice device, VkDeviceMemory memory,
                                      const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkFreeMemory(snapshotTraceBegin, snapshotTraceBytes, pool, device, memory, pAllocator);
+    mImpl->vkFreeMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, memory,
+                        pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkMapMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    VkDevice device, VkDeviceMemory memory, VkDeviceSize offset,
-                                    VkDeviceSize size, VkMemoryMapFlags flags, void** ppData) {
-    mImpl->vkMapMemory(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device, memory,
-                       offset, size, flags, ppData);
+void VkDecoderSnapshot::vkMapMemory(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, VkDevice device, VkDeviceMemory memory,
+                                    VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags,
+                                    void** ppData) {
+    mImpl->vkMapMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
+                       memory, offset, size, flags, ppData);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkUnmapMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkDevice device,
-                                      VkDeviceMemory memory) {
-    mImpl->vkUnmapMemory(snapshotTraceBegin, snapshotTraceBytes, pool, device, memory);
+void VkDecoderSnapshot::vkUnmapMemory(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkDevice device, VkDeviceMemory memory) {
+    mImpl->vkUnmapMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, memory);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkFlushMappedMemoryRanges(const uint8_t* snapshotTraceBegin,
-                                                  size_t snapshotTraceBytes,
-                                                  android::base::BumpPool* pool,
-                                                  VkResult input_result, VkDevice device,
-                                                  uint32_t memoryRangeCount,
+void VkDecoderSnapshot::vkFlushMappedMemoryRanges(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* apiCallInfo,
+                                                  const uint8_t* apiCallPacket,
+                                                  size_t apiCallPacketSize, VkResult input_result,
+                                                  VkDevice device, uint32_t memoryRangeCount,
                                                   const VkMappedMemoryRange* pMemoryRanges) {
-    mImpl->vkFlushMappedMemoryRanges(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                     device, memoryRangeCount, pMemoryRanges);
+    mImpl->vkFlushMappedMemoryRanges(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                     input_result, device, memoryRangeCount, pMemoryRanges);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkInvalidateMappedMemoryRanges(const uint8_t* snapshotTraceBegin,
-                                                       size_t snapshotTraceBytes,
-                                                       android::base::BumpPool* pool,
-                                                       VkResult input_result, VkDevice device,
-                                                       uint32_t memoryRangeCount,
-                                                       const VkMappedMemoryRange* pMemoryRanges) {
-    mImpl->vkInvalidateMappedMemoryRanges(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkInvalidateMappedMemoryRanges(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, uint32_t memoryRangeCount,
+    const VkMappedMemoryRange* pMemoryRanges) {
+    mImpl->vkInvalidateMappedMemoryRanges(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           input_result, device, memoryRangeCount, pMemoryRanges);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetDeviceMemoryCommitment(const uint8_t* snapshotTraceBegin,
-                                                    size_t snapshotTraceBytes,
-                                                    android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkGetDeviceMemoryCommitment(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                                    const uint8_t* apiCallPacket,
+                                                    size_t apiCallPacketSize, VkDevice device,
                                                     VkDeviceMemory memory,
                                                     VkDeviceSize* pCommittedMemoryInBytes) {
-    mImpl->vkGetDeviceMemoryCommitment(snapshotTraceBegin, snapshotTraceBytes, pool, device, memory,
-                                       pCommittedMemoryInBytes);
+    mImpl->vkGetDeviceMemoryCommitment(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                                       memory, pCommittedMemoryInBytes);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkBindBufferMemory(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkBindBufferMemory(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device, VkBuffer buffer,
                                            VkDeviceMemory memory, VkDeviceSize memoryOffset) {
-    mImpl->vkBindBufferMemory(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                              buffer, memory, memoryOffset);
+    mImpl->vkBindBufferMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                              device, buffer, memory, memoryOffset);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkBindImageMemory(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkBindImageMemory(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device, VkImage image,
                                           VkDeviceMemory memory, VkDeviceSize memoryOffset) {
-    mImpl->vkBindImageMemory(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                             image, memory, memoryOffset);
+    mImpl->vkBindImageMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                             device, image, memory, memoryOffset);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetBufferMemoryRequirements(const uint8_t* snapshotTraceBegin,
-                                                      size_t snapshotTraceBytes,
-                                                      android::base::BumpPool* pool,
-                                                      VkDevice device, VkBuffer buffer,
+void VkDecoderSnapshot::vkGetBufferMemoryRequirements(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                                      const uint8_t* apiCallPacket,
+                                                      size_t apiCallPacketSize, VkDevice device,
+                                                      VkBuffer buffer,
                                                       VkMemoryRequirements* pMemoryRequirements) {
-    mImpl->vkGetBufferMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                         buffer, pMemoryRequirements);
+    mImpl->vkGetBufferMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                         device, buffer, pMemoryRequirements);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetImageMemoryRequirements(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkGetImageMemoryRequirements(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                                     const uint8_t* apiCallPacket,
+                                                     size_t apiCallPacketSize, VkDevice device,
                                                      VkImage image,
                                                      VkMemoryRequirements* pMemoryRequirements) {
-    mImpl->vkGetImageMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, pool, device, image,
-                                        pMemoryRequirements);
+    mImpl->vkGetImageMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                                        image, pMemoryRequirements);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkGetImageSparseMemoryRequirements(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkImage image,
+    uint32_t* pSparseMemoryRequirementCount,
     VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
-    mImpl->vkGetImageSparseMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                              image, pSparseMemoryRequirementCount,
+    mImpl->vkGetImageSparseMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                              device, image, pSparseMemoryRequirementCount,
                                               pSparseMemoryRequirements);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkGetPhysicalDeviceSparseImageFormatProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
     VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling,
     uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties) {
     mImpl->vkGetPhysicalDeviceSparseImageFormatProperties(
-        snapshotTraceBegin, snapshotTraceBytes, pool, physicalDevice, format, type, samples, usage,
-        tiling, pPropertyCount, pProperties);
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, format, type, samples,
+        usage, tiling, pPropertyCount, pProperties);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkQueueBindSparse(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkQueueBindSparse(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkQueue queue,
                                           uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
                                           VkFence fence) {
-    mImpl->vkQueueBindSparse(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, queue,
-                             bindInfoCount, pBindInfo, fence);
+    mImpl->vkQueueBindSparse(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                             queue, bindInfoCount, pBindInfo, fence);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateFence(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkResult input_result,
-                                      VkDevice device, const VkFenceCreateInfo* pCreateInfo,
+void VkDecoderSnapshot::vkCreateFence(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkResult input_result, VkDevice device,
+                                      const VkFenceCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
-    mImpl->vkCreateFence(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
+    mImpl->vkCreateFence(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                          pCreateInfo, pAllocator, pFence);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyFence(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkDevice device,
-                                       VkFence fence, const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyFence(snapshotTraceBegin, snapshotTraceBytes, pool, device, fence, pAllocator);
+void VkDecoderSnapshot::vkDestroyFence(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkDevice device, VkFence fence,
+                                       const VkAllocationCallbacks* pAllocator) {
+    mImpl->vkDestroyFence(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, fence,
+                          pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkResetFences(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkResult input_result,
-                                      VkDevice device, uint32_t fenceCount,
+void VkDecoderSnapshot::vkResetFences(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkResult input_result, VkDevice device, uint32_t fenceCount,
                                       const VkFence* pFences) {
-    mImpl->vkResetFences(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
+    mImpl->vkResetFences(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                          fenceCount, pFences);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetFenceStatus(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetFenceStatus(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device, VkFence fence) {
-    mImpl->vkGetFenceStatus(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                            fence);
+    mImpl->vkGetFenceStatus(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                            device, fence);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkWaitForFences(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkWaitForFences(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device, uint32_t fenceCount,
                                         const VkFence* pFences, VkBool32 waitAll,
                                         uint64_t timeout) {
-    mImpl->vkWaitForFences(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                           fenceCount, pFences, waitAll, timeout);
+    mImpl->vkWaitForFences(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                           device, fenceCount, pFences, waitAll, timeout);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateSemaphore(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCreateSemaphore(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkSemaphoreCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkSemaphore* pSemaphore) {
-    mImpl->vkCreateSemaphore(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                             pCreateInfo, pAllocator, pSemaphore);
+    mImpl->vkCreateSemaphore(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                             device, pCreateInfo, pAllocator, pSemaphore);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroySemaphore(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkDestroySemaphore(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device, VkSemaphore semaphore,
                                            const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroySemaphore(snapshotTraceBegin, snapshotTraceBytes, pool, device, semaphore,
-                              pAllocator);
+    mImpl->vkDestroySemaphore(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                              semaphore, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkResult input_result,
-                                      VkDevice device, const VkEventCreateInfo* pCreateInfo,
+void VkDecoderSnapshot::vkCreateEvent(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkResult input_result, VkDevice device,
+                                      const VkEventCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator, VkEvent* pEvent) {
-    mImpl->vkCreateEvent(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
+    mImpl->vkCreateEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                          pCreateInfo, pAllocator, pEvent);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkDevice device,
-                                       VkEvent event, const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyEvent(snapshotTraceBegin, snapshotTraceBytes, pool, device, event, pAllocator);
+void VkDecoderSnapshot::vkDestroyEvent(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkDevice device, VkEvent event,
+                                       const VkAllocationCallbacks* pAllocator) {
+    mImpl->vkDestroyEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, event,
+                          pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetEventStatus(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetEventStatus(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device, VkEvent event) {
-    mImpl->vkGetEventStatus(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                            event);
+    mImpl->vkGetEventStatus(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                            device, event);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkSetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkResult input_result,
-                                   VkDevice device, VkEvent event) {
-    mImpl->vkSetEvent(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device, event);
+void VkDecoderSnapshot::vkSetEvent(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+                                   VkEvent event) {
+    mImpl->vkSetEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
+                      event);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkResetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkResult input_result,
-                                     VkDevice device, VkEvent event) {
-    mImpl->vkResetEvent(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device, event);
+void VkDecoderSnapshot::vkResetEvent(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkResult input_result, VkDevice device, VkEvent event) {
+    mImpl->vkResetEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
+                        event);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateQueryPool(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCreateQueryPool(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkQueryPoolCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkQueryPool* pQueryPool) {
-    mImpl->vkCreateQueryPool(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                             pCreateInfo, pAllocator, pQueryPool);
+    mImpl->vkCreateQueryPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                             device, pCreateInfo, pAllocator, pQueryPool);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyQueryPool(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkDestroyQueryPool(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device, VkQueryPool queryPool,
                                            const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyQueryPool(snapshotTraceBegin, snapshotTraceBytes, pool, device, queryPool,
-                              pAllocator);
+    mImpl->vkDestroyQueryPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                              queryPool, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetQueryPoolResults(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
-                                              VkDevice device, VkQueryPool queryPool,
-                                              uint32_t firstQuery, uint32_t queryCount,
-                                              size_t dataSize, void* pData, VkDeviceSize stride,
-                                              VkQueryResultFlags flags) {
-    mImpl->vkGetQueryPoolResults(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                 queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
+void VkDecoderSnapshot::vkGetQueryPoolResults(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkQueryPool queryPool,
+    uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride,
+    VkQueryResultFlags flags) {
+    mImpl->vkGetQueryPoolResults(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                 device, queryPool, firstQuery, queryCount, dataSize, pData, stride,
+                                 flags);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkResult input_result,
-                                       VkDevice device, const VkBufferCreateInfo* pCreateInfo,
+void VkDecoderSnapshot::vkCreateBuffer(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkResult input_result, VkDevice device,
+                                       const VkBufferCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
-    mImpl->vkCreateBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
+    mImpl->vkCreateBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                           pCreateInfo, pAllocator, pBuffer);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyBuffer(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkDestroyBuffer(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device, VkBuffer buffer,
                                         const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, device, buffer,
+    mImpl->vkDestroyBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, buffer,
                            pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateBufferView(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCreateBufferView(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            const VkBufferViewCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkBufferView* pView) {
-    mImpl->vkCreateBufferView(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                              pCreateInfo, pAllocator, pView);
+    mImpl->vkCreateBufferView(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                              device, pCreateInfo, pAllocator, pView);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyBufferView(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
-                                            VkBufferView bufferView,
+void VkDecoderSnapshot::vkDestroyBufferView(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device, VkBufferView bufferView,
                                             const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyBufferView(snapshotTraceBegin, snapshotTraceBytes, pool, device, bufferView,
-                               pAllocator);
+    mImpl->vkDestroyBufferView(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                               bufferView, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkResult input_result,
-                                      VkDevice device, const VkImageCreateInfo* pCreateInfo,
+void VkDecoderSnapshot::vkCreateImage(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkResult input_result, VkDevice device,
+                                      const VkImageCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator, VkImage* pImage) {
-    mImpl->vkCreateImage(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
+    mImpl->vkCreateImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                          pCreateInfo, pAllocator, pImage);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkDevice device,
-                                       VkImage image, const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyImage(snapshotTraceBegin, snapshotTraceBytes, pool, device, image, pAllocator);
+void VkDecoderSnapshot::vkDestroyImage(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkDevice device, VkImage image,
+                                       const VkAllocationCallbacks* pAllocator) {
+    mImpl->vkDestroyImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, image,
+                          pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetImageSubresourceLayout(const uint8_t* snapshotTraceBegin,
-                                                    size_t snapshotTraceBytes,
-                                                    android::base::BumpPool* pool, VkDevice device,
-                                                    VkImage image,
-                                                    const VkImageSubresource* pSubresource,
-                                                    VkSubresourceLayout* pLayout) {
-    mImpl->vkGetImageSubresourceLayout(snapshotTraceBegin, snapshotTraceBytes, pool, device, image,
-                                       pSubresource, pLayout);
+void VkDecoderSnapshot::vkGetImageSubresourceLayout(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkImage image,
+    const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout) {
+    mImpl->vkGetImageSubresourceLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                                       image, pSubresource, pLayout);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateImageView(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCreateImageView(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkImageViewCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkImageView* pView) {
-    mImpl->vkCreateImageView(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                             pCreateInfo, pAllocator, pView);
+    mImpl->vkCreateImageView(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                             device, pCreateInfo, pAllocator, pView);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyImageView(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkDestroyImageView(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device, VkImageView imageView,
                                            const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyImageView(snapshotTraceBegin, snapshotTraceBytes, pool, device, imageView,
-                              pAllocator);
+    mImpl->vkDestroyImageView(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                              imageView, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateShaderModule(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule) {
-    mImpl->vkCreateShaderModule(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                pCreateInfo, pAllocator, pShaderModule);
+void VkDecoderSnapshot::vkCreateShaderModule(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkResult input_result, VkDevice device,
+                                             const VkShaderModuleCreateInfo* pCreateInfo,
+                                             const VkAllocationCallbacks* pAllocator,
+                                             VkShaderModule* pShaderModule) {
+    mImpl->vkCreateShaderModule(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                device, pCreateInfo, pAllocator, pShaderModule);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyShaderModule(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkDestroyShaderModule(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkDevice device,
                                               VkShaderModule shaderModule,
                                               const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyShaderModule(snapshotTraceBegin, snapshotTraceBytes, pool, device, shaderModule,
-                                 pAllocator);
+    mImpl->vkDestroyShaderModule(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                                 shaderModule, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCreatePipelineCache(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache) {
-    mImpl->vkCreatePipelineCache(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                 pCreateInfo, pAllocator, pPipelineCache);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkPipelineCache* pPipelineCache) {
+    mImpl->vkCreatePipelineCache(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                 device, pCreateInfo, pAllocator, pPipelineCache);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyPipelineCache(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkDestroyPipelineCache(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* apiCallInfo,
+                                               const uint8_t* apiCallPacket,
+                                               size_t apiCallPacketSize, VkDevice device,
                                                VkPipelineCache pipelineCache,
                                                const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyPipelineCache(snapshotTraceBegin, snapshotTraceBytes, pool, device,
+    mImpl->vkDestroyPipelineCache(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                   pipelineCache, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetPipelineCacheData(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool, VkResult input_result,
+void VkDecoderSnapshot::vkGetPipelineCacheData(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* apiCallInfo,
+                                               const uint8_t* apiCallPacket,
+                                               size_t apiCallPacketSize, VkResult input_result,
                                                VkDevice device, VkPipelineCache pipelineCache,
                                                size_t* pDataSize, void* pData) {
-    mImpl->vkGetPipelineCacheData(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkGetPipelineCacheData(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, pipelineCache, pDataSize, pData);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkMergePipelineCaches(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
-                                              VkDevice device, VkPipelineCache dstCache,
-                                              uint32_t srcCacheCount,
-                                              const VkPipelineCache* pSrcCaches) {
-    mImpl->vkMergePipelineCaches(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                 dstCache, srcCacheCount, pSrcCaches);
+void VkDecoderSnapshot::vkMergePipelineCaches(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkPipelineCache dstCache,
+    uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches) {
+    mImpl->vkMergePipelineCaches(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                 device, dstCache, srcCacheCount, pSrcCaches);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCreateGraphicsPipelines(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount,
-    const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator,
-    VkPipeline* pPipelines) {
-    mImpl->vkCreateGraphicsPipelines(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                     device, pipelineCache, createInfoCount, pCreateInfos,
-                                     pAllocator, pPipelines);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkPipelineCache pipelineCache,
+    uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos,
+    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
+    mImpl->vkCreateGraphicsPipelines(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                     input_result, device, pipelineCache, createInfoCount,
+                                     pCreateInfos, pAllocator, pPipelines);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCreateComputePipelines(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount,
-    const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator,
-    VkPipeline* pPipelines) {
-    mImpl->vkCreateComputePipelines(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                    device, pipelineCache, createInfoCount, pCreateInfos,
-                                    pAllocator, pPipelines);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkPipelineCache pipelineCache,
+    uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos,
+    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
+    mImpl->vkCreateComputePipelines(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    input_result, device, pipelineCache, createInfoCount,
+                                    pCreateInfos, pAllocator, pPipelines);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyPipeline(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkDestroyPipeline(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device, VkPipeline pipeline,
                                           const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyPipeline(snapshotTraceBegin, snapshotTraceBytes, pool, device, pipeline,
+    mImpl->vkDestroyPipeline(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pipeline,
                              pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCreatePipelineLayout(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout) {
-    mImpl->vkCreatePipelineLayout(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkPipelineLayout* pPipelineLayout) {
+    mImpl->vkCreatePipelineLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, pCreateInfo, pAllocator, pPipelineLayout);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyPipelineLayout(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkDestroyPipelineLayout(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize, VkDevice device,
                                                 VkPipelineLayout pipelineLayout,
                                                 const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyPipelineLayout(snapshotTraceBegin, snapshotTraceBytes, pool, device,
+    mImpl->vkDestroyPipelineLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                    pipelineLayout, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateSampler(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCreateSampler(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         const VkSamplerCreateInfo* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkSampler* pSampler) {
-    mImpl->vkCreateSampler(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                           pCreateInfo, pAllocator, pSampler);
+    mImpl->vkCreateSampler(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                           device, pCreateInfo, pAllocator, pSampler);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroySampler(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkDestroySampler(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkSampler sampler,
                                          const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroySampler(snapshotTraceBegin, snapshotTraceBytes, pool, device, sampler,
+    mImpl->vkDestroySampler(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, sampler,
                             pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCreateDescriptorSetLayout(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout) {
-    mImpl->vkCreateDescriptorSetLayout(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                       device, pCreateInfo, pAllocator, pSetLayout);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkDescriptorSetLayout* pSetLayout) {
+    mImpl->vkCreateDescriptorSetLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                       input_result, device, pCreateInfo, pAllocator, pSetLayout);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyDescriptorSetLayout(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkDestroyDescriptorSetLayout(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                                     const uint8_t* apiCallPacket,
+                                                     size_t apiCallPacketSize, VkDevice device,
                                                      VkDescriptorSetLayout descriptorSetLayout,
                                                      const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyDescriptorSetLayout(snapshotTraceBegin, snapshotTraceBytes, pool, device,
+    mImpl->vkDestroyDescriptorSetLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                         descriptorSetLayout, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCreateDescriptorPool(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool) {
-    mImpl->vkCreateDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkDescriptorPool* pDescriptorPool) {
+    mImpl->vkCreateDescriptorPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, pCreateInfo, pAllocator, pDescriptorPool);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyDescriptorPool(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkDestroyDescriptorPool(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize, VkDevice device,
                                                 VkDescriptorPool descriptorPool,
                                                 const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, pool, device,
+    mImpl->vkDestroyDescriptorPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                    descriptorPool, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkResetDescriptorPool(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
+void VkDecoderSnapshot::vkResetDescriptorPool(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkResult input_result,
                                               VkDevice device, VkDescriptorPool descriptorPool,
                                               VkDescriptorPoolResetFlags flags) {
-    mImpl->vkResetDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                 descriptorPool, flags);
+    mImpl->vkResetDescriptorPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                 device, descriptorPool, flags);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkAllocateDescriptorSets(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
-                                                 VkResult input_result, VkDevice device,
-                                                 const VkDescriptorSetAllocateInfo* pAllocateInfo,
-                                                 VkDescriptorSet* pDescriptorSets) {
-    mImpl->vkAllocateDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                    device, pAllocateInfo, pDescriptorSets);
+void VkDecoderSnapshot::vkAllocateDescriptorSets(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets) {
+    mImpl->vkAllocateDescriptorSets(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    input_result, device, pAllocateInfo, pDescriptorSets);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkFreeDescriptorSets(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkResult input_result,
-                                             VkDevice device, VkDescriptorPool descriptorPool,
+void VkDecoderSnapshot::vkFreeDescriptorSets(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkResult input_result, VkDevice device,
+                                             VkDescriptorPool descriptorPool,
                                              uint32_t descriptorSetCount,
                                              const VkDescriptorSet* pDescriptorSets) {
-    mImpl->vkFreeDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                descriptorPool, descriptorSetCount, pDescriptorSets);
+    mImpl->vkFreeDescriptorSets(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                device, descriptorPool, descriptorSetCount, pDescriptorSets);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkUpdateDescriptorSets(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites,
-    uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies) {
-    mImpl->vkUpdateDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, pool, device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, uint32_t descriptorWriteCount,
+    const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount,
+    const VkCopyDescriptorSet* pDescriptorCopies) {
+    mImpl->vkUpdateDescriptorSets(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                   descriptorWriteCount, pDescriptorWrites, descriptorCopyCount,
                                   pDescriptorCopies);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateFramebuffer(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkFramebufferCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer) {
-    mImpl->vkCreateFramebuffer(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                               pCreateInfo, pAllocator, pFramebuffer);
+void VkDecoderSnapshot::vkCreateFramebuffer(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, VkDevice device,
+                                            const VkFramebufferCreateInfo* pCreateInfo,
+                                            const VkAllocationCallbacks* pAllocator,
+                                            VkFramebuffer* pFramebuffer) {
+    mImpl->vkCreateFramebuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                               device, pCreateInfo, pAllocator, pFramebuffer);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyFramebuffer(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkDevice device,
-                                             VkFramebuffer framebuffer,
+void VkDecoderSnapshot::vkDestroyFramebuffer(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkDevice device, VkFramebuffer framebuffer,
                                              const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyFramebuffer(snapshotTraceBegin, snapshotTraceBytes, pool, device, framebuffer,
-                                pAllocator);
+    mImpl->vkDestroyFramebuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                                framebuffer, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateRenderPass(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCreateRenderPass(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            const VkRenderPassCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkRenderPass* pRenderPass) {
-    mImpl->vkCreateRenderPass(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                              pCreateInfo, pAllocator, pRenderPass);
+    mImpl->vkCreateRenderPass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                              device, pCreateInfo, pAllocator, pRenderPass);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyRenderPass(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
-                                            VkRenderPass renderPass,
+void VkDecoderSnapshot::vkDestroyRenderPass(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device, VkRenderPass renderPass,
                                             const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyRenderPass(snapshotTraceBegin, snapshotTraceBytes, pool, device, renderPass,
-                               pAllocator);
+    mImpl->vkDestroyRenderPass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                               renderPass, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkGetRenderAreaGranularity(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool, VkDevice device,
-                                                   VkRenderPass renderPass,
-                                                   VkExtent2D* pGranularity) {
-    mImpl->vkGetRenderAreaGranularity(snapshotTraceBegin, snapshotTraceBytes, pool, device,
+void VkDecoderSnapshot::vkGetRenderAreaGranularity(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity) {
+    mImpl->vkGetRenderAreaGranularity(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                       renderPass, pGranularity);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCreateCommandPool(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool) {
-    mImpl->vkCreateCommandPool(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                               pCreateInfo, pAllocator, pCommandPool);
+void VkDecoderSnapshot::vkCreateCommandPool(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, VkDevice device,
+                                            const VkCommandPoolCreateInfo* pCreateInfo,
+                                            const VkAllocationCallbacks* pAllocator,
+                                            VkCommandPool* pCommandPool) {
+    mImpl->vkCreateCommandPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                               device, pCreateInfo, pAllocator, pCommandPool);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkDestroyCommandPool(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkDevice device,
-                                             VkCommandPool commandPool,
+void VkDecoderSnapshot::vkDestroyCommandPool(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkDevice device, VkCommandPool commandPool,
                                              const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyCommandPool(snapshotTraceBegin, snapshotTraceBytes, pool, device, commandPool,
-                                pAllocator);
+    mImpl->vkDestroyCommandPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                                commandPool, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkResetCommandPool(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkResetCommandPool(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            VkCommandPool commandPool,
                                            VkCommandPoolResetFlags flags) {
-    mImpl->vkResetCommandPool(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                              commandPool, flags);
+    mImpl->vkResetCommandPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                              device, commandPool, flags);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkAllocateCommandBuffers(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
-                                                 VkResult input_result, VkDevice device,
-                                                 const VkCommandBufferAllocateInfo* pAllocateInfo,
-                                                 VkCommandBuffer* pCommandBuffers) {
-    mImpl->vkAllocateCommandBuffers(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                    device, pAllocateInfo, pCommandBuffers);
+void VkDecoderSnapshot::vkAllocateCommandBuffers(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers) {
+    mImpl->vkAllocateCommandBuffers(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    input_result, device, pAllocateInfo, pCommandBuffers);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkFreeCommandBuffers(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkDevice device,
-                                             VkCommandPool commandPool, uint32_t commandBufferCount,
+void VkDecoderSnapshot::vkFreeCommandBuffers(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkDevice device, VkCommandPool commandPool,
+                                             uint32_t commandBufferCount,
                                              const VkCommandBuffer* pCommandBuffers) {
-    mImpl->vkFreeCommandBuffers(snapshotTraceBegin, snapshotTraceBytes, pool, device, commandPool,
-                                commandBufferCount, pCommandBuffers);
+    mImpl->vkFreeCommandBuffers(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                                commandPool, commandBufferCount, pCommandBuffers);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkBeginCommandBuffer(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkResult input_result,
-                                             VkCommandBuffer commandBuffer,
+void VkDecoderSnapshot::vkBeginCommandBuffer(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkResult input_result, VkCommandBuffer commandBuffer,
                                              const VkCommandBufferBeginInfo* pBeginInfo) {
-    mImpl->vkBeginCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkBeginCommandBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 commandBuffer, pBeginInfo);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkEndCommandBuffer(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkEndCommandBuffer(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkCommandBuffer commandBuffer) {
-    mImpl->vkEndCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkEndCommandBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                               commandBuffer);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkResetCommandBuffer(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkResult input_result,
-                                             VkCommandBuffer commandBuffer,
+void VkDecoderSnapshot::vkResetCommandBuffer(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkResult input_result, VkCommandBuffer commandBuffer,
                                              VkCommandBufferResetFlags flags) {
-    mImpl->vkResetCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkResetCommandBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 commandBuffer, flags);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdBindPipeline(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdBindPipeline(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer,
                                           VkPipelineBindPoint pipelineBindPoint,
                                           VkPipeline pipeline) {
-    mImpl->vkCmdBindPipeline(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdBindPipeline(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              pipelineBindPoint, pipeline);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdSetViewport(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetViewport(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                          uint32_t viewportCount, const VkViewport* pViewports) {
-    mImpl->vkCmdSetViewport(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdSetViewport(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             firstViewport, viewportCount, pViewports);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdSetScissor(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetScissor(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, uint32_t firstScissor,
                                         uint32_t scissorCount, const VkRect2D* pScissors) {
-    mImpl->vkCmdSetScissor(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdSetScissor(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            firstScissor, scissorCount, pScissors);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdSetLineWidth(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetLineWidth(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, float lineWidth) {
-    mImpl->vkCmdSetLineWidth(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdSetLineWidth(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              lineWidth);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdSetDepthBias(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetDepthBias(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer,
                                           float depthBiasConstantFactor, float depthBiasClamp,
                                           float depthBiasSlopeFactor) {
-    mImpl->vkCmdSetDepthBias(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdSetDepthBias(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdSetBlendConstants(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool,
-                                               VkCommandBuffer commandBuffer,
-                                               const float blendConstants[4]) {
-    mImpl->vkCmdSetBlendConstants(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  blendConstants);
+void VkDecoderSnapshot::vkCmdSetBlendConstants(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, const float blendConstants[4]) {
+    mImpl->vkCmdSetBlendConstants(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, blendConstants);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdSetDepthBounds(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetDepthBounds(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer, float minDepthBounds,
                                             float maxDepthBounds) {
-    mImpl->vkCmdSetDepthBounds(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdSetDepthBounds(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                minDepthBounds, maxDepthBounds);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCmdSetStencilCompareMask(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) {
-    mImpl->vkCmdSetStencilCompareMask(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                      faceMask, compareMask);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+    uint32_t compareMask) {
+    mImpl->vkCmdSetStencilCompareMask(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      commandBuffer, faceMask, compareMask);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdSetStencilWriteMask(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetStencilWriteMask(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize,
                                                  VkCommandBuffer commandBuffer,
                                                  VkStencilFaceFlags faceMask, uint32_t writeMask) {
-    mImpl->vkCmdSetStencilWriteMask(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                    faceMask, writeMask);
+    mImpl->vkCmdSetStencilWriteMask(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    commandBuffer, faceMask, writeMask);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdSetStencilReference(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetStencilReference(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize,
                                                  VkCommandBuffer commandBuffer,
                                                  VkStencilFaceFlags faceMask, uint32_t reference) {
-    mImpl->vkCmdSetStencilReference(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                    faceMask, reference);
+    mImpl->vkCmdSetStencilReference(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    commandBuffer, faceMask, reference);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCmdBindDescriptorSets(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
-    uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets,
-    uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets) {
-    mImpl->vkCmdBindDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                   pipelineBindPoint, layout, firstSet, descriptorSetCount,
-                                   pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
+    VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount,
+    const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount,
+    const uint32_t* pDynamicOffsets) {
+    mImpl->vkCmdBindDescriptorSets(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer, pipelineBindPoint,
+        layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdBindIndexBuffer(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdBindIndexBuffer(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkCommandBuffer commandBuffer, VkBuffer buffer,
                                              VkDeviceSize offset, VkIndexType indexType) {
-    mImpl->vkCmdBindIndexBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, buffer,
-                                offset, indexType);
+    mImpl->vkCmdBindIndexBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                                buffer, offset, indexType);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdBindVertexBuffers(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool,
-                                               VkCommandBuffer commandBuffer, uint32_t firstBinding,
-                                               uint32_t bindingCount, const VkBuffer* pBuffers,
-                                               const VkDeviceSize* pOffsets) {
-    mImpl->vkCmdBindVertexBuffers(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  firstBinding, bindingCount, pBuffers, pOffsets);
+void VkDecoderSnapshot::vkCmdBindVertexBuffers(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstBinding,
+    uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets) {
+    mImpl->vkCmdBindVertexBuffers(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdDraw(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  uint32_t vertexCount, uint32_t instanceCount,
-                                  uint32_t firstVertex, uint32_t firstInstance) {
-    mImpl->vkCmdDraw(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, vertexCount,
-                     instanceCount, firstVertex, firstInstance);
+void VkDecoderSnapshot::vkCmdDraw(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, uint32_t vertexCount,
+                                  uint32_t instanceCount, uint32_t firstVertex,
+                                  uint32_t firstInstance) {
+    mImpl->vkCmdDraw(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                     vertexCount, instanceCount, firstVertex, firstInstance);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdDrawIndexed(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdDrawIndexed(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, uint32_t indexCount,
                                          uint32_t instanceCount, uint32_t firstIndex,
                                          int32_t vertexOffset, uint32_t firstInstance) {
-    mImpl->vkCmdDrawIndexed(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, indexCount,
-                            instanceCount, firstIndex, vertexOffset, firstInstance);
+    mImpl->vkCmdDrawIndexed(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                            indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdDrawIndirect(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdDrawIndirect(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, VkBuffer buffer,
                                           VkDeviceSize offset, uint32_t drawCount,
                                           uint32_t stride) {
-    mImpl->vkCmdDrawIndirect(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, buffer,
-                             offset, drawCount, stride);
+    mImpl->vkCmdDrawIndirect(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                             buffer, offset, drawCount, stride);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdDrawIndexedIndirect(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
-                                                 VkCommandBuffer commandBuffer, VkBuffer buffer,
-                                                 VkDeviceSize offset, uint32_t drawCount,
-                                                 uint32_t stride) {
-    mImpl->vkCmdDrawIndexedIndirect(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                    buffer, offset, drawCount, stride);
+void VkDecoderSnapshot::vkCmdDrawIndexedIndirect(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+    uint32_t drawCount, uint32_t stride) {
+    mImpl->vkCmdDrawIndexedIndirect(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    commandBuffer, buffer, offset, drawCount, stride);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdDispatch(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      uint32_t groupCountX, uint32_t groupCountY,
-                                      uint32_t groupCountZ) {
-    mImpl->vkCmdDispatch(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, groupCountX,
-                         groupCountY, groupCountZ);
+void VkDecoderSnapshot::vkCmdDispatch(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer, uint32_t groupCountX,
+                                      uint32_t groupCountY, uint32_t groupCountZ) {
+    mImpl->vkCmdDispatch(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                         groupCountX, groupCountY, groupCountZ);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdDispatchIndirect(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool,
-                                              VkCommandBuffer commandBuffer, VkBuffer buffer,
-                                              VkDeviceSize offset) {
-    mImpl->vkCmdDispatchIndirect(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+void VkDecoderSnapshot::vkCmdDispatchIndirect(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
+    mImpl->vkCmdDispatchIndirect(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                  buffer, offset);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdCopyBuffer(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdCopyBuffer(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
                                         VkBuffer dstBuffer, uint32_t regionCount,
                                         const VkBufferCopy* pRegions) {
-    mImpl->vkCmdCopyBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, srcBuffer,
-                           dstBuffer, regionCount, pRegions);
+    mImpl->vkCmdCopyBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                           srcBuffer, dstBuffer, regionCount, pRegions);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdCopyImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       VkImage srcImage, VkImageLayout srcImageLayout,
-                                       VkImage dstImage, VkImageLayout dstImageLayout,
-                                       uint32_t regionCount, const VkImageCopy* pRegions) {
-    mImpl->vkCmdCopyImage(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, srcImage,
-                          srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
+void VkDecoderSnapshot::vkCmdCopyImage(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, VkImage srcImage,
+                                       VkImageLayout srcImageLayout, VkImage dstImage,
+                                       VkImageLayout dstImageLayout, uint32_t regionCount,
+                                       const VkImageCopy* pRegions) {
+    mImpl->vkCmdCopyImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                          srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount,
+                          pRegions);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdBlitImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       VkImage srcImage, VkImageLayout srcImageLayout,
-                                       VkImage dstImage, VkImageLayout dstImageLayout,
-                                       uint32_t regionCount, const VkImageBlit* pRegions,
-                                       VkFilter filter) {
-    mImpl->vkCmdBlitImage(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, srcImage,
-                          srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
+void VkDecoderSnapshot::vkCmdBlitImage(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, VkImage srcImage,
+                                       VkImageLayout srcImageLayout, VkImage dstImage,
+                                       VkImageLayout dstImageLayout, uint32_t regionCount,
+                                       const VkImageBlit* pRegions, VkFilter filter) {
+    mImpl->vkCmdBlitImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                          srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions,
+                          filter);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCmdCopyBufferToImage(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
     VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions) {
-    mImpl->vkCmdCopyBufferToImage(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
+    mImpl->vkCmdCopyBufferToImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount,
+                                  pRegions);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCmdCopyImageToBuffer(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
-    VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions) {
-    mImpl->vkCmdCopyImageToBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkImage srcImage,
+    VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount,
+    const VkBufferImageCopy* pRegions) {
+    mImpl->vkCmdCopyImageToBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount,
+                                  pRegions);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdUpdateBuffer(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdUpdateBuffer(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                           VkDeviceSize dstOffset, VkDeviceSize dataSize,
                                           const void* pData) {
-    mImpl->vkCmdUpdateBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, dstBuffer,
-                             dstOffset, dataSize, pData);
+    mImpl->vkCmdUpdateBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                             dstBuffer, dstOffset, dataSize, pData);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdFillBuffer(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdFillBuffer(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                         VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
-    mImpl->vkCmdFillBuffer(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, dstBuffer,
-                           dstOffset, size, data);
+    mImpl->vkCmdFillBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                           dstBuffer, dstOffset, size, data);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdClearColorImage(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout,
-    const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
-    mImpl->vkCmdClearColorImage(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, image,
-                                imageLayout, pColor, rangeCount, pRanges);
+void VkDecoderSnapshot::vkCmdClearColorImage(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkCommandBuffer commandBuffer, VkImage image,
+                                             VkImageLayout imageLayout,
+                                             const VkClearColorValue* pColor, uint32_t rangeCount,
+                                             const VkImageSubresourceRange* pRanges) {
+    mImpl->vkCmdClearColorImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                                image, imageLayout, pColor, rangeCount, pRanges);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCmdClearDepthStencilImage(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout,
-    const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkImage image,
+    VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount,
     const VkImageSubresourceRange* pRanges) {
-    mImpl->vkCmdClearDepthStencilImage(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                       image, imageLayout, pDepthStencil, rangeCount, pRanges);
+    mImpl->vkCmdClearDepthStencilImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                       commandBuffer, image, imageLayout, pDepthStencil, rangeCount,
+                                       pRanges);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCmdClearAttachments(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments,
-    uint32_t rectCount, const VkClearRect* pRects) {
-    mImpl->vkCmdClearAttachments(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t attachmentCount,
+    const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects) {
+    mImpl->vkCmdClearAttachments(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                  attachmentCount, pAttachments, rectCount, pRects);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdResolveImage(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdResolveImage(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, VkImage srcImage,
                                           VkImageLayout srcImageLayout, VkImage dstImage,
                                           VkImageLayout dstImageLayout, uint32_t regionCount,
                                           const VkImageResolve* pRegions) {
-    mImpl->vkCmdResolveImage(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, srcImage,
-                             srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
+    mImpl->vkCmdResolveImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                             srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount,
+                             pRegions);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdSetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      VkEvent event, VkPipelineStageFlags stageMask) {
-    mImpl->vkCmdSetEvent(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, event,
+void VkDecoderSnapshot::vkCmdSetEvent(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer, VkEvent event,
+                                      VkPipelineStageFlags stageMask) {
+    mImpl->vkCmdSetEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer, event,
                          stageMask);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdResetEvent(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdResetEvent(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, VkEvent event,
                                         VkPipelineStageFlags stageMask) {
-    mImpl->vkCmdResetEvent(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, event,
-                           stageMask);
+    mImpl->vkCmdResetEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                           event, stageMask);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCmdWaitEvents(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents,
-    VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t eventCount,
+    const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
     uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
     uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
     uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
-    mImpl->vkCmdWaitEvents(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, eventCount,
-                           pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers,
-                           bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount,
-                           pImageMemoryBarriers);
+    mImpl->vkCmdWaitEvents(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                           eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount,
+                           pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers,
+                           imageMemoryBarrierCount, pImageMemoryBarriers);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCmdPipelineBarrier(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
     VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
     uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
     uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
     uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
-    mImpl->vkCmdPipelineBarrier(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdPipelineBarrier(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount,
                                 pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers,
                                 imageMemoryBarrierCount, pImageMemoryBarriers);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdBeginQuery(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdBeginQuery(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                         uint32_t query, VkQueryControlFlags flags) {
-    mImpl->vkCmdBeginQuery(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, queryPool,
-                           query, flags);
+    mImpl->vkCmdBeginQuery(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                           queryPool, query, flags);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdEndQuery(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      VkQueryPool queryPool, uint32_t query) {
-    mImpl->vkCmdEndQuery(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, queryPool,
-                         query);
+void VkDecoderSnapshot::vkCmdEndQuery(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer, VkQueryPool queryPool,
+                                      uint32_t query) {
+    mImpl->vkCmdEndQuery(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                         queryPool, query);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdResetQueryPool(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdResetQueryPool(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                             uint32_t firstQuery, uint32_t queryCount) {
-    mImpl->vkCmdResetQueryPool(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdResetQueryPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                queryPool, firstQuery, queryCount);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdWriteTimestamp(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdWriteTimestamp(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             VkPipelineStageFlagBits pipelineStage,
                                             VkQueryPool queryPool, uint32_t query) {
-    mImpl->vkCmdWriteTimestamp(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdWriteTimestamp(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                pipelineStage, queryPool, query);
 }
 #endif
 #ifdef VK_VERSION_1_0
 void VkDecoderSnapshot::vkCmdCopyQueryPoolResults(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount,
-    VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) {
-    mImpl->vkCmdCopyQueryPoolResults(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                     queryPool, firstQuery, queryCount, dstBuffer, dstOffset,
-                                     stride, flags);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkQueryPool queryPool,
+    uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset,
+    VkDeviceSize stride, VkQueryResultFlags flags) {
+    mImpl->vkCmdCopyQueryPoolResults(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                     commandBuffer, queryPool, firstQuery, queryCount, dstBuffer,
+                                     dstOffset, stride, flags);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdPushConstants(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdPushConstants(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer, VkPipelineLayout layout,
                                            VkShaderStageFlags stageFlags, uint32_t offset,
                                            uint32_t size, const void* pValues) {
-    mImpl->vkCmdPushConstants(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, layout,
-                              stageFlags, offset, size, pValues);
+    mImpl->vkCmdPushConstants(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                              layout, stageFlags, offset, size, pValues);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdBeginRenderPass(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdBeginRenderPass(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkCommandBuffer commandBuffer,
                                              const VkRenderPassBeginInfo* pRenderPassBegin,
                                              VkSubpassContents contents) {
-    mImpl->vkCmdBeginRenderPass(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdBeginRenderPass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 pRenderPassBegin, contents);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdNextSubpass(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdNextSubpass(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          VkSubpassContents contents) {
-    mImpl->vkCmdNextSubpass(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, contents);
+    mImpl->vkCmdNextSubpass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                            contents);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdEndRenderPass(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdEndRenderPass(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer) {
-    mImpl->vkCmdEndRenderPass(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer);
+    mImpl->vkCmdEndRenderPass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer);
 }
 #endif
 #ifdef VK_VERSION_1_0
-void VkDecoderSnapshot::vkCmdExecuteCommands(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdExecuteCommands(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkCommandBuffer commandBuffer,
                                              uint32_t commandBufferCount,
                                              const VkCommandBuffer* pCommandBuffers) {
-    mImpl->vkCmdExecuteCommands(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdExecuteCommands(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 commandBufferCount, pCommandBuffers);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkEnumerateInstanceVersion(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool,
-                                                   VkResult input_result, uint32_t* pApiVersion) {
-    mImpl->vkEnumerateInstanceVersion(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                      pApiVersion);
+void VkDecoderSnapshot::vkEnumerateInstanceVersion(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* apiCallInfo,
+                                                   const uint8_t* apiCallPacket,
+                                                   size_t apiCallPacketSize, VkResult input_result,
+                                                   uint32_t* pApiVersion) {
+    mImpl->vkEnumerateInstanceVersion(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      input_result, pApiVersion);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkBindBufferMemory2(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkResult input_result,
-                                            VkDevice device, uint32_t bindInfoCount,
+void VkDecoderSnapshot::vkBindBufferMemory2(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, VkDevice device,
+                                            uint32_t bindInfoCount,
                                             const VkBindBufferMemoryInfo* pBindInfos) {
-    mImpl->vkBindBufferMemory2(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                               bindInfoCount, pBindInfos);
+    mImpl->vkBindBufferMemory2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                               device, bindInfoCount, pBindInfos);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkBindImageMemory2(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkBindImageMemory2(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            uint32_t bindInfoCount,
                                            const VkBindImageMemoryInfo* pBindInfos) {
-    mImpl->vkBindImageMemory2(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                              bindInfoCount, pBindInfos);
+    mImpl->vkBindImageMemory2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                              device, bindInfoCount, pBindInfos);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetDeviceGroupPeerMemoryFeatures(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex,
-    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
-    mImpl->vkGetDeviceGroupPeerMemoryFeatures(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                              heapIndex, localDeviceIndex, remoteDeviceIndex,
-                                              pPeerMemoryFeatures);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex,
+    uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
+    mImpl->vkGetDeviceGroupPeerMemoryFeatures(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                              device, heapIndex, localDeviceIndex,
+                                              remoteDeviceIndex, pPeerMemoryFeatures);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkCmdSetDeviceMask(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetDeviceMask(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer, uint32_t deviceMask) {
-    mImpl->vkCmdSetDeviceMask(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdSetDeviceMask(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               deviceMask);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkCmdDispatchBase(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdDispatchBase(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, uint32_t baseGroupX,
                                           uint32_t baseGroupY, uint32_t baseGroupZ,
                                           uint32_t groupCountX, uint32_t groupCountY,
                                           uint32_t groupCountZ) {
-    mImpl->vkCmdDispatchBase(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdDispatchBase(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY,
                              groupCountZ);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkEnumeratePhysicalDeviceGroups(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkInstance instance,
+    uint32_t* pPhysicalDeviceGroupCount,
     VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
-    mImpl->vkEnumeratePhysicalDeviceGroups(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkEnumeratePhysicalDeviceGroups(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            input_result, instance, pPhysicalDeviceGroupCount,
                                            pPhysicalDeviceGroupProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkGetImageMemoryRequirements2(const uint8_t* snapshotTraceBegin,
-                                                      size_t snapshotTraceBytes,
-                                                      android::base::BumpPool* pool,
-                                                      VkDevice device,
+void VkDecoderSnapshot::vkGetImageMemoryRequirements2(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                                      const uint8_t* apiCallPacket,
+                                                      size_t apiCallPacketSize, VkDevice device,
                                                       const VkImageMemoryRequirementsInfo2* pInfo,
                                                       VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->vkGetImageMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                         pInfo, pMemoryRequirements);
+    mImpl->vkGetImageMemoryRequirements2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                         device, pInfo, pMemoryRequirements);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkGetBufferMemoryRequirements2(const uint8_t* snapshotTraceBegin,
-                                                       size_t snapshotTraceBytes,
-                                                       android::base::BumpPool* pool,
-                                                       VkDevice device,
+void VkDecoderSnapshot::vkGetBufferMemoryRequirements2(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                                       const uint8_t* apiCallPacket,
+                                                       size_t apiCallPacketSize, VkDevice device,
                                                        const VkBufferMemoryRequirementsInfo2* pInfo,
                                                        VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->vkGetBufferMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                          pInfo, pMemoryRequirements);
+    mImpl->vkGetBufferMemoryRequirements2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                          device, pInfo, pMemoryRequirements);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetImageSparseMemoryRequirements2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
     uint32_t* pSparseMemoryRequirementCount,
     VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
-    mImpl->vkGetImageSparseMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                               pInfo, pSparseMemoryRequirementCount,
+    mImpl->vkGetImageSparseMemoryRequirements2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                               device, pInfo, pSparseMemoryRequirementCount,
                                                pSparseMemoryRequirements);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkGetPhysicalDeviceFeatures2(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetPhysicalDeviceFeatures2(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                                     const uint8_t* apiCallPacket,
+                                                     size_t apiCallPacketSize,
                                                      VkPhysicalDevice physicalDevice,
                                                      VkPhysicalDeviceFeatures2* pFeatures) {
-    mImpl->vkGetPhysicalDeviceFeatures2(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkGetPhysicalDeviceFeatures2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         physicalDevice, pFeatures);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkGetPhysicalDeviceProperties2(const uint8_t* snapshotTraceBegin,
-                                                       size_t snapshotTraceBytes,
-                                                       android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetPhysicalDeviceProperties2(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                                       const uint8_t* apiCallPacket,
+                                                       size_t apiCallPacketSize,
                                                        VkPhysicalDevice physicalDevice,
                                                        VkPhysicalDeviceProperties2* pProperties) {
-    mImpl->vkGetPhysicalDeviceProperties2(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkGetPhysicalDeviceProperties2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           physicalDevice, pProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetPhysicalDeviceFormatProperties2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties) {
-    mImpl->vkGetPhysicalDeviceFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, VkFormat format,
+    VkFormatProperties2* pFormatProperties) {
+    mImpl->vkGetPhysicalDeviceFormatProperties2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 physicalDevice, format, pFormatProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetPhysicalDeviceImageFormatProperties2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkPhysicalDevice physicalDevice,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
     const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
     VkImageFormatProperties2* pImageFormatProperties) {
-    mImpl->vkGetPhysicalDeviceImageFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                     input_result, physicalDevice, pImageFormatInfo,
-                                                     pImageFormatProperties);
+    mImpl->vkGetPhysicalDeviceImageFormatProperties2(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, physicalDevice,
+        pImageFormatInfo, pImageFormatProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetPhysicalDeviceQueueFamilyProperties2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
     VkQueueFamilyProperties2* pQueueFamilyProperties) {
-    mImpl->vkGetPhysicalDeviceQueueFamilyProperties2(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                     physicalDevice, pQueueFamilyPropertyCount,
-                                                     pQueueFamilyProperties);
+    mImpl->vkGetPhysicalDeviceQueueFamilyProperties2(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice,
+        pQueueFamilyPropertyCount, pQueueFamilyProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetPhysicalDeviceMemoryProperties2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
-    mImpl->vkGetPhysicalDeviceMemoryProperties2(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
+    mImpl->vkGetPhysicalDeviceMemoryProperties2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 physicalDevice, pMemoryProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetPhysicalDeviceSparseImageFormatProperties2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
-    uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
-    mImpl->vkGetPhysicalDeviceSparseImageFormatProperties2(snapshotTraceBegin, snapshotTraceBytes,
-                                                           pool, physicalDevice, pFormatInfo,
-                                                           pPropertyCount, pProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
+    VkSparseImageFormatProperties2* pProperties) {
+    mImpl->vkGetPhysicalDeviceSparseImageFormatProperties2(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pFormatInfo,
+        pPropertyCount, pProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkTrimCommandPool(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkTrimCommandPool(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device, VkCommandPool commandPool,
                                           VkCommandPoolTrimFlags flags) {
-    mImpl->vkTrimCommandPool(snapshotTraceBegin, snapshotTraceBytes, pool, device, commandPool,
-                             flags);
+    mImpl->vkTrimCommandPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                             commandPool, flags);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkGetDeviceQueue2(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetDeviceQueue2(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device, const VkDeviceQueueInfo2* pQueueInfo,
                                           VkQueue* pQueue) {
-    mImpl->vkGetDeviceQueue2(snapshotTraceBegin, snapshotTraceBytes, pool, device, pQueueInfo,
-                             pQueue);
+    mImpl->vkGetDeviceQueue2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                             pQueueInfo, pQueue);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkCreateSamplerYcbcrConversion(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
-    mImpl->vkCreateSamplerYcbcrConversion(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkSamplerYcbcrConversion* pYcbcrConversion) {
+    mImpl->vkCreateSamplerYcbcrConversion(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           input_result, device, pCreateInfo, pAllocator,
                                           pYcbcrConversion);
 }
 #endif
 #ifdef VK_VERSION_1_1
-void VkDecoderSnapshot::vkDestroySamplerYcbcrConversion(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
-                                                        VkDevice device,
+void VkDecoderSnapshot::vkDestroySamplerYcbcrConversion(android::base::BumpPool* pool,
+                                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                                        const uint8_t* apiCallPacket,
+                                                        size_t apiCallPacketSize, VkDevice device,
                                                         VkSamplerYcbcrConversion ycbcrConversion,
                                                         const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroySamplerYcbcrConversion(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                           ycbcrConversion, pAllocator);
+    mImpl->vkDestroySamplerYcbcrConversion(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                           device, ycbcrConversion, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkCreateDescriptorUpdateTemplate(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
     const VkAllocationCallbacks* pAllocator,
     VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
-    mImpl->vkCreateDescriptorUpdateTemplate(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkCreateDescriptorUpdateTemplate(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             input_result, device, pCreateInfo, pAllocator,
                                             pDescriptorUpdateTemplate);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkDestroyDescriptorUpdateTemplate(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
     const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyDescriptorUpdateTemplate(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                             descriptorUpdateTemplate, pAllocator);
+    mImpl->vkDestroyDescriptorUpdateTemplate(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                             device, descriptorUpdateTemplate, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplate(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, VkDescriptorSet descriptorSet,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkDescriptorSet descriptorSet,
     VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
-    mImpl->vkUpdateDescriptorSetWithTemplate(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                             descriptorSet, descriptorUpdateTemplate, pData);
+    mImpl->vkUpdateDescriptorSetWithTemplate(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                             device, descriptorSet, descriptorUpdateTemplate,
+                                             pData);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetPhysicalDeviceExternalBufferProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
     VkExternalBufferProperties* pExternalBufferProperties) {
-    mImpl->vkGetPhysicalDeviceExternalBufferProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                       physicalDevice, pExternalBufferInfo,
-                                                       pExternalBufferProperties);
+    mImpl->vkGetPhysicalDeviceExternalBufferProperties(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalBufferInfo,
+        pExternalBufferProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetPhysicalDeviceExternalFenceProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
     VkExternalFenceProperties* pExternalFenceProperties) {
-    mImpl->vkGetPhysicalDeviceExternalFenceProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                      physicalDevice, pExternalFenceInfo,
-                                                      pExternalFenceProperties);
+    mImpl->vkGetPhysicalDeviceExternalFenceProperties(pool, apiCallInfo, apiCallPacket,
+                                                      apiCallPacketSize, physicalDevice,
+                                                      pExternalFenceInfo, pExternalFenceProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetPhysicalDeviceExternalSemaphoreProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
     const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
     VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
     mImpl->vkGetPhysicalDeviceExternalSemaphoreProperties(
-        snapshotTraceBegin, snapshotTraceBytes, pool, physicalDevice, pExternalSemaphoreInfo,
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalSemaphoreInfo,
         pExternalSemaphoreProperties);
 }
 #endif
 #ifdef VK_VERSION_1_1
 void VkDecoderSnapshot::vkGetDescriptorSetLayoutSupport(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
     VkDescriptorSetLayoutSupport* pSupport) {
-    mImpl->vkGetDescriptorSetLayoutSupport(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                           pCreateInfo, pSupport);
+    mImpl->vkGetDescriptorSetLayoutSupport(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                           device, pCreateInfo, pSupport);
 }
 #endif
 #ifdef VK_VERSION_1_2
 void VkDecoderSnapshot::vkCmdDrawIndirectCount(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
-    VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
-    mImpl->vkCmdDrawIndirectCount(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
-                                  stride);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+    VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
+    mImpl->vkCmdDrawIndirectCount(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, buffer, offset, countBuffer, countBufferOffset,
+                                  maxDrawCount, stride);
 }
 #endif
 #ifdef VK_VERSION_1_2
 void VkDecoderSnapshot::vkCmdDrawIndexedIndirectCount(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
-    VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
-    mImpl->vkCmdDrawIndexedIndirectCount(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+    VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
+    mImpl->vkCmdDrawIndexedIndirectCount(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          commandBuffer, buffer, offset, countBuffer,
                                          countBufferOffset, maxDrawCount, stride);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkCreateRenderPass2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
-    mImpl->vkCreateRenderPass2(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                               pCreateInfo, pAllocator, pRenderPass);
+void VkDecoderSnapshot::vkCreateRenderPass2(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, VkDevice device,
+                                            const VkRenderPassCreateInfo2* pCreateInfo,
+                                            const VkAllocationCallbacks* pAllocator,
+                                            VkRenderPass* pRenderPass) {
+    mImpl->vkCreateRenderPass2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                               device, pCreateInfo, pAllocator, pRenderPass);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkCmdBeginRenderPass2(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool,
-                                              VkCommandBuffer commandBuffer,
-                                              const VkRenderPassBeginInfo* pRenderPassBegin,
-                                              const VkSubpassBeginInfo* pSubpassBeginInfo) {
-    mImpl->vkCmdBeginRenderPass2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+void VkDecoderSnapshot::vkCmdBeginRenderPass2(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+    const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo) {
+    mImpl->vkCmdBeginRenderPass2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                  pRenderPassBegin, pSubpassBeginInfo);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkCmdNextSubpass2(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdNextSubpass2(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer,
                                           const VkSubpassBeginInfo* pSubpassBeginInfo,
                                           const VkSubpassEndInfo* pSubpassEndInfo) {
-    mImpl->vkCmdNextSubpass2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdNextSubpass2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              pSubpassBeginInfo, pSubpassEndInfo);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkCmdEndRenderPass2(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdEndRenderPass2(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             const VkSubpassEndInfo* pSubpassEndInfo) {
-    mImpl->vkCmdEndRenderPass2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdEndRenderPass2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                pSubpassEndInfo);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkResetQueryPool(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkResetQueryPool(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkQueryPool queryPool,
                                          uint32_t firstQuery, uint32_t queryCount) {
-    mImpl->vkResetQueryPool(snapshotTraceBegin, snapshotTraceBytes, pool, device, queryPool,
+    mImpl->vkResetQueryPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, queryPool,
                             firstQuery, queryCount);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkGetSemaphoreCounterValue(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool,
-                                                   VkResult input_result, VkDevice device,
-                                                   VkSemaphore semaphore, uint64_t* pValue) {
-    mImpl->vkGetSemaphoreCounterValue(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                      device, semaphore, pValue);
+void VkDecoderSnapshot::vkGetSemaphoreCounterValue(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* apiCallInfo,
+                                                   const uint8_t* apiCallPacket,
+                                                   size_t apiCallPacketSize, VkResult input_result,
+                                                   VkDevice device, VkSemaphore semaphore,
+                                                   uint64_t* pValue) {
+    mImpl->vkGetSemaphoreCounterValue(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      input_result, device, semaphore, pValue);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkWaitSemaphores(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkWaitSemaphores(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device,
                                          const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout) {
-    mImpl->vkWaitSemaphores(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                            pWaitInfo, timeout);
+    mImpl->vkWaitSemaphores(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                            device, pWaitInfo, timeout);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkSignalSemaphore(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkSignalSemaphore(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkSemaphoreSignalInfo* pSignalInfo) {
-    mImpl->vkSignalSemaphore(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                             pSignalInfo);
+    mImpl->vkSignalSemaphore(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                             device, pSignalInfo);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkGetBufferDeviceAddress(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetBufferDeviceAddress(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize,
                                                  VkDeviceAddress input_result, VkDevice device,
                                                  const VkBufferDeviceAddressInfo* pInfo) {
-    mImpl->vkGetBufferDeviceAddress(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                    device, pInfo);
+    mImpl->vkGetBufferDeviceAddress(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    input_result, device, pInfo);
 }
 #endif
 #ifdef VK_VERSION_1_2
-void VkDecoderSnapshot::vkGetBufferOpaqueCaptureAddress(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetBufferOpaqueCaptureAddress(android::base::BumpPool* pool,
+                                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                                        const uint8_t* apiCallPacket,
+                                                        size_t apiCallPacketSize,
                                                         uint64_t input_result, VkDevice device,
                                                         const VkBufferDeviceAddressInfo* pInfo) {
-    mImpl->vkGetBufferOpaqueCaptureAddress(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkGetBufferOpaqueCaptureAddress(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            input_result, device, pInfo);
 }
 #endif
 #ifdef VK_VERSION_1_2
 void VkDecoderSnapshot::vkGetDeviceMemoryOpaqueCaptureAddress(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    uint64_t input_result, VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
-    mImpl->vkGetDeviceMemoryOpaqueCaptureAddress(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                 input_result, device, pInfo);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, uint64_t input_result, VkDevice device,
+    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
+    mImpl->vkGetDeviceMemoryOpaqueCaptureAddress(pool, apiCallInfo, apiCallPacket,
+                                                 apiCallPacketSize, input_result, device, pInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
 void VkDecoderSnapshot::vkGetPhysicalDeviceToolProperties(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
-    VkPhysicalDeviceToolProperties* pToolProperties) {
-    mImpl->vkGetPhysicalDeviceToolProperties(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
+    uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) {
+    mImpl->vkGetPhysicalDeviceToolProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              input_result, physicalDevice, pToolCount,
                                              pToolProperties);
 }
 #endif
 #ifdef VK_VERSION_1_3
 void VkDecoderSnapshot::vkCreatePrivateDataSlot(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot) {
-    mImpl->vkCreatePrivateDataSlot(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                   device, pCreateInfo, pAllocator, pPrivateDataSlot);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkPrivateDataSlot* pPrivateDataSlot) {
+    mImpl->vkCreatePrivateDataSlot(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                   input_result, device, pCreateInfo, pAllocator, pPrivateDataSlot);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkDestroyPrivateDataSlot(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkDestroyPrivateDataSlot(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize, VkDevice device,
                                                  VkPrivateDataSlot privateDataSlot,
                                                  const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyPrivateDataSlot(snapshotTraceBegin, snapshotTraceBytes, pool, device,
+    mImpl->vkDestroyPrivateDataSlot(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                     privateDataSlot, pAllocator);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkSetPrivateData(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkSetPrivateData(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device,
                                          VkObjectType objectType, uint64_t objectHandle,
                                          VkPrivateDataSlot privateDataSlot, uint64_t data) {
-    mImpl->vkSetPrivateData(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                            objectType, objectHandle, privateDataSlot, data);
+    mImpl->vkSetPrivateData(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                            device, objectType, objectHandle, privateDataSlot, data);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkGetPrivateData(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetPrivateData(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkObjectType objectType,
                                          uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
                                          uint64_t* pData) {
-    mImpl->vkGetPrivateData(snapshotTraceBegin, snapshotTraceBytes, pool, device, objectType,
+    mImpl->vkGetPrivateData(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, objectType,
                             objectHandle, privateDataSlot, pData);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetEvent2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       VkEvent event, const VkDependencyInfo* pDependencyInfo) {
-    mImpl->vkCmdSetEvent2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, event,
+void VkDecoderSnapshot::vkCmdSetEvent2(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, VkEvent event,
+                                       const VkDependencyInfo* pDependencyInfo) {
+    mImpl->vkCmdSetEvent2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer, event,
                           pDependencyInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdResetEvent2(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdResetEvent2(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, VkEvent event,
                                          VkPipelineStageFlags2 stageMask) {
-    mImpl->vkCmdResetEvent2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, event,
-                            stageMask);
+    mImpl->vkCmdResetEvent2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                            event, stageMask);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdWaitEvents2(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdWaitEvents2(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, uint32_t eventCount,
                                          const VkEvent* pEvents,
                                          const VkDependencyInfo* pDependencyInfos) {
-    mImpl->vkCmdWaitEvents2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, eventCount,
-                            pEvents, pDependencyInfos);
+    mImpl->vkCmdWaitEvents2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                            eventCount, pEvents, pDependencyInfos);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdPipelineBarrier2(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdPipelineBarrier2(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize,
                                               VkCommandBuffer commandBuffer,
                                               const VkDependencyInfo* pDependencyInfo) {
-    mImpl->vkCmdPipelineBarrier2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdPipelineBarrier2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                  pDependencyInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdWriteTimestamp2(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdWriteTimestamp2(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkCommandBuffer commandBuffer,
                                              VkPipelineStageFlags2 stage, VkQueryPool queryPool,
                                              uint32_t query) {
-    mImpl->vkCmdWriteTimestamp2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, stage,
-                                queryPool, query);
+    mImpl->vkCmdWriteTimestamp2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                                stage, queryPool, query);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkQueueSubmit2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkResult input_result,
-                                       VkQueue queue, uint32_t submitCount,
+void VkDecoderSnapshot::vkQueueSubmit2(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkResult input_result, VkQueue queue, uint32_t submitCount,
                                        const VkSubmitInfo2* pSubmits, VkFence fence) {
-    mImpl->vkQueueSubmit2(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, queue,
+    mImpl->vkQueueSubmit2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, queue,
                           submitCount, pSubmits, fence);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdCopyBuffer2(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdCopyBuffer2(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          const VkCopyBufferInfo2* pCopyBufferInfo) {
-    mImpl->vkCmdCopyBuffer2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdCopyBuffer2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             pCopyBufferInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdCopyImage2(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdCopyImage2(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer,
                                         const VkCopyImageInfo2* pCopyImageInfo) {
-    mImpl->vkCmdCopyImage2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdCopyImage2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            pCopyImageInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
 void VkDecoderSnapshot::vkCmdCopyBufferToImage2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
-    mImpl->vkCmdCopyBufferToImage2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                   pCopyBufferToImageInfo);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+    const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
+    mImpl->vkCmdCopyBufferToImage2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                   commandBuffer, pCopyBufferToImageInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
 void VkDecoderSnapshot::vkCmdCopyImageToBuffer2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
-    mImpl->vkCmdCopyImageToBuffer2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                   pCopyImageToBufferInfo);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+    const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
+    mImpl->vkCmdCopyImageToBuffer2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                   commandBuffer, pCopyImageToBufferInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdBlitImage2(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdBlitImage2(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer,
                                         const VkBlitImageInfo2* pBlitImageInfo) {
-    mImpl->vkCmdBlitImage2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdBlitImage2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            pBlitImageInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdResolveImage2(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdResolveImage2(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            const VkResolveImageInfo2* pResolveImageInfo) {
-    mImpl->vkCmdResolveImage2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdResolveImage2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               pResolveImageInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdBeginRendering(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdBeginRendering(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             const VkRenderingInfo* pRenderingInfo) {
-    mImpl->vkCmdBeginRendering(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdBeginRendering(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                pRenderingInfo);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdEndRendering(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdEndRendering(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer) {
-    mImpl->vkCmdEndRendering(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer);
+    mImpl->vkCmdEndRendering(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetCullMode(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetCullMode(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
-    mImpl->vkCmdSetCullMode(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, cullMode);
+    mImpl->vkCmdSetCullMode(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                            cullMode);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetFrontFace(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetFrontFace(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
-    mImpl->vkCmdSetFrontFace(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdSetFrontFace(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              frontFace);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetPrimitiveTopology(const uint8_t* snapshotTraceBegin,
-                                                  size_t snapshotTraceBytes,
-                                                  android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetPrimitiveTopology(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* apiCallInfo,
+                                                  const uint8_t* apiCallPacket,
+                                                  size_t apiCallPacketSize,
                                                   VkCommandBuffer commandBuffer,
                                                   VkPrimitiveTopology primitiveTopology) {
-    mImpl->vkCmdSetPrimitiveTopology(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                     primitiveTopology);
+    mImpl->vkCmdSetPrimitiveTopology(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                     commandBuffer, primitiveTopology);
 }
 #endif
 #ifdef VK_VERSION_1_3
 void VkDecoderSnapshot::vkCmdSetViewportWithCount(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports) {
-    mImpl->vkCmdSetViewportWithCount(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                     viewportCount, pViewports);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t viewportCount,
+    const VkViewport* pViewports) {
+    mImpl->vkCmdSetViewportWithCount(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                     commandBuffer, viewportCount, pViewports);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetScissorWithCount(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetScissorWithCount(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize,
                                                  VkCommandBuffer commandBuffer,
                                                  uint32_t scissorCount, const VkRect2D* pScissors) {
-    mImpl->vkCmdSetScissorWithCount(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                    scissorCount, pScissors);
+    mImpl->vkCmdSetScissorWithCount(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    commandBuffer, scissorCount, pScissors);
 }
 #endif
 #ifdef VK_VERSION_1_3
 void VkDecoderSnapshot::vkCmdBindVertexBuffers2(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
-    const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
-    const VkDeviceSize* pStrides) {
-    mImpl->vkCmdBindVertexBuffers2(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                   firstBinding, bindingCount, pBuffers, pOffsets, pSizes,
-                                   pStrides);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstBinding,
+    uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
+    const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
+    mImpl->vkCmdBindVertexBuffers2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                   commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets,
+                                   pSizes, pStrides);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetDepthTestEnable(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
-                                                VkCommandBuffer commandBuffer,
-                                                VkBool32 depthTestEnable) {
-    mImpl->vkCmdSetDepthTestEnable(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                   depthTestEnable);
+void VkDecoderSnapshot::vkCmdSetDepthTestEnable(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
+    mImpl->vkCmdSetDepthTestEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                   commandBuffer, depthTestEnable);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetDepthWriteEnable(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
-                                                 VkCommandBuffer commandBuffer,
-                                                 VkBool32 depthWriteEnable) {
-    mImpl->vkCmdSetDepthWriteEnable(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                    depthWriteEnable);
+void VkDecoderSnapshot::vkCmdSetDepthWriteEnable(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
+    mImpl->vkCmdSetDepthWriteEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    commandBuffer, depthWriteEnable);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetDepthCompareOp(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool,
-                                               VkCommandBuffer commandBuffer,
-                                               VkCompareOp depthCompareOp) {
-    mImpl->vkCmdSetDepthCompareOp(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  depthCompareOp);
+void VkDecoderSnapshot::vkCmdSetDepthCompareOp(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
+    mImpl->vkCmdSetDepthCompareOp(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, depthCompareOp);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetDepthBoundsTestEnable(const uint8_t* snapshotTraceBegin,
-                                                      size_t snapshotTraceBytes,
-                                                      android::base::BumpPool* pool,
-                                                      VkCommandBuffer commandBuffer,
-                                                      VkBool32 depthBoundsTestEnable) {
-    mImpl->vkCmdSetDepthBoundsTestEnable(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkCmdSetDepthBoundsTestEnable(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
+    mImpl->vkCmdSetDepthBoundsTestEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          commandBuffer, depthBoundsTestEnable);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetStencilTestEnable(const uint8_t* snapshotTraceBegin,
-                                                  size_t snapshotTraceBytes,
-                                                  android::base::BumpPool* pool,
-                                                  VkCommandBuffer commandBuffer,
-                                                  VkBool32 stencilTestEnable) {
-    mImpl->vkCmdSetStencilTestEnable(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                     stencilTestEnable);
+void VkDecoderSnapshot::vkCmdSetStencilTestEnable(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
+    mImpl->vkCmdSetStencilTestEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                     commandBuffer, stencilTestEnable);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetStencilOp(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
-                                          VkCommandBuffer commandBuffer,
-                                          VkStencilFaceFlags faceMask, VkStencilOp failOp,
-                                          VkStencilOp passOp, VkStencilOp depthFailOp,
-                                          VkCompareOp compareOp) {
-    mImpl->vkCmdSetStencilOp(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, faceMask,
-                             failOp, passOp, depthFailOp, compareOp);
+void VkDecoderSnapshot::vkCmdSetStencilOp(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+    VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
+    mImpl->vkCmdSetStencilOp(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                             faceMask, failOp, passOp, depthFailOp, compareOp);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetRasterizerDiscardEnable(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
-                                                        VkCommandBuffer commandBuffer,
-                                                        VkBool32 rasterizerDiscardEnable) {
-    mImpl->vkCmdSetRasterizerDiscardEnable(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkCmdSetRasterizerDiscardEnable(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
+    mImpl->vkCmdSetRasterizerDiscardEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            commandBuffer, rasterizerDiscardEnable);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetDepthBiasEnable(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
-                                                VkCommandBuffer commandBuffer,
-                                                VkBool32 depthBiasEnable) {
-    mImpl->vkCmdSetDepthBiasEnable(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                   depthBiasEnable);
+void VkDecoderSnapshot::vkCmdSetDepthBiasEnable(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
+    mImpl->vkCmdSetDepthBiasEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                   commandBuffer, depthBiasEnable);
 }
 #endif
 #ifdef VK_VERSION_1_3
-void VkDecoderSnapshot::vkCmdSetPrimitiveRestartEnable(const uint8_t* snapshotTraceBegin,
-                                                       size_t snapshotTraceBytes,
-                                                       android::base::BumpPool* pool,
-                                                       VkCommandBuffer commandBuffer,
-                                                       VkBool32 primitiveRestartEnable) {
-    mImpl->vkCmdSetPrimitiveRestartEnable(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkCmdSetPrimitiveRestartEnable(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
+    mImpl->vkCmdSetPrimitiveRestartEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           commandBuffer, primitiveRestartEnable);
 }
 #endif
 #ifdef VK_VERSION_1_3
 void VkDecoderSnapshot::vkGetDeviceBufferMemoryRequirements(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
     VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->vkGetDeviceBufferMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                               pInfo, pMemoryRequirements);
+    mImpl->vkGetDeviceBufferMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                               device, pInfo, pMemoryRequirements);
 }
 #endif
 #ifdef VK_VERSION_1_3
 void VkDecoderSnapshot::vkGetDeviceImageMemoryRequirements(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
     VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->vkGetDeviceImageMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                              pInfo, pMemoryRequirements);
+    mImpl->vkGetDeviceImageMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                              device, pInfo, pMemoryRequirements);
 }
 #endif
 #ifdef VK_VERSION_1_3
 void VkDecoderSnapshot::vkGetDeviceImageSparseMemoryRequirements(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
     uint32_t* pSparseMemoryRequirementCount,
     VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
-    mImpl->vkGetDeviceImageSparseMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                    device, pInfo, pSparseMemoryRequirementCount,
-                                                    pSparseMemoryRequirements);
+    mImpl->vkGetDeviceImageSparseMemoryRequirements(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo,
+        pSparseMemoryRequirementCount, pSparseMemoryRequirements);
 }
 #endif
 #ifdef VK_KHR_swapchain
-void VkDecoderSnapshot::vkCreateSwapchainKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain) {
-    mImpl->vkCreateSwapchainKHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                pCreateInfo, pAllocator, pSwapchain);
+void VkDecoderSnapshot::vkCreateSwapchainKHR(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkResult input_result, VkDevice device,
+                                             const VkSwapchainCreateInfoKHR* pCreateInfo,
+                                             const VkAllocationCallbacks* pAllocator,
+                                             VkSwapchainKHR* pSwapchain) {
+    mImpl->vkCreateSwapchainKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                device, pCreateInfo, pAllocator, pSwapchain);
 }
 #endif
 #ifdef VK_KHR_swapchain
-void VkDecoderSnapshot::vkDestroySwapchainKHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkDestroySwapchainKHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkDevice device,
                                               VkSwapchainKHR swapchain,
                                               const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroySwapchainKHR(snapshotTraceBegin, snapshotTraceBytes, pool, device, swapchain,
-                                 pAllocator);
+    mImpl->vkDestroySwapchainKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                                 swapchain, pAllocator);
 }
 #endif
 #ifdef VK_KHR_swapchain
 void VkDecoderSnapshot::vkGetSwapchainImagesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
     uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages) {
-    mImpl->vkGetSwapchainImagesKHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                   device, swapchain, pSwapchainImageCount, pSwapchainImages);
+    mImpl->vkGetSwapchainImagesKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                   input_result, device, swapchain, pSwapchainImageCount,
+                                   pSwapchainImages);
 }
 #endif
 #ifdef VK_KHR_swapchain
-void VkDecoderSnapshot::vkAcquireNextImageKHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
-                                              VkDevice device, VkSwapchainKHR swapchain,
-                                              uint64_t timeout, VkSemaphore semaphore,
-                                              VkFence fence, uint32_t* pImageIndex) {
-    mImpl->vkAcquireNextImageKHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                 swapchain, timeout, semaphore, fence, pImageIndex);
+void VkDecoderSnapshot::vkAcquireNextImageKHR(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
+    uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex) {
+    mImpl->vkAcquireNextImageKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                 device, swapchain, timeout, semaphore, fence, pImageIndex);
 }
 #endif
 #ifdef VK_KHR_swapchain
-void VkDecoderSnapshot::vkQueuePresentKHR(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkQueuePresentKHR(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkQueue queue,
                                           const VkPresentInfoKHR* pPresentInfo) {
-    mImpl->vkQueuePresentKHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, queue,
-                             pPresentInfo);
+    mImpl->vkQueuePresentKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                             queue, pPresentInfo);
 }
 #endif
 #ifdef VK_KHR_swapchain
 void VkDecoderSnapshot::vkGetDeviceGroupPresentCapabilitiesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
     VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities) {
-    mImpl->vkGetDeviceGroupPresentCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                  input_result, device,
+    mImpl->vkGetDeviceGroupPresentCapabilitiesKHR(pool, apiCallInfo, apiCallPacket,
+                                                  apiCallPacketSize, input_result, device,
                                                   pDeviceGroupPresentCapabilities);
 }
 #endif
 #ifdef VK_KHR_swapchain
 void VkDecoderSnapshot::vkGetDeviceGroupSurfacePresentModesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkSurfaceKHR surface,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkSurfaceKHR surface,
     VkDeviceGroupPresentModeFlagsKHR* pModes) {
-    mImpl->vkGetDeviceGroupSurfacePresentModesKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                  input_result, device, surface, pModes);
+    mImpl->vkGetDeviceGroupSurfacePresentModesKHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device, surface, pModes);
 }
 #endif
 #ifdef VK_KHR_swapchain
 void VkDecoderSnapshot::vkGetPhysicalDevicePresentRectanglesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
-    uint32_t* pRectCount, VkRect2D* pRects) {
-    mImpl->vkGetPhysicalDevicePresentRectanglesKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                   input_result, physicalDevice, surface,
-                                                   pRectCount, pRects);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
+    VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects) {
+    mImpl->vkGetPhysicalDevicePresentRectanglesKHR(pool, apiCallInfo, apiCallPacket,
+                                                   apiCallPacketSize, input_result, physicalDevice,
+                                                   surface, pRectCount, pRects);
 }
 #endif
 #ifdef VK_KHR_swapchain
-void VkDecoderSnapshot::vkAcquireNextImage2KHR(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool, VkResult input_result,
-                                               VkDevice device,
-                                               const VkAcquireNextImageInfoKHR* pAcquireInfo,
-                                               uint32_t* pImageIndex) {
-    mImpl->vkAcquireNextImage2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+void VkDecoderSnapshot::vkAcquireNextImage2KHR(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex) {
+    mImpl->vkAcquireNextImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, pAcquireInfo, pImageIndex);
 }
 #endif
 #ifdef VK_KHR_dynamic_rendering
-void VkDecoderSnapshot::vkCmdBeginRenderingKHR(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdBeginRenderingKHR(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* apiCallInfo,
+                                               const uint8_t* apiCallPacket,
+                                               size_t apiCallPacketSize,
                                                VkCommandBuffer commandBuffer,
                                                const VkRenderingInfo* pRenderingInfo) {
-    mImpl->vkCmdBeginRenderingKHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  pRenderingInfo);
+    mImpl->vkCmdBeginRenderingKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, pRenderingInfo);
 }
 #endif
 #ifdef VK_KHR_dynamic_rendering
-void VkDecoderSnapshot::vkCmdEndRenderingKHR(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdEndRenderingKHR(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkCommandBuffer commandBuffer) {
-    mImpl->vkCmdEndRenderingKHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer);
+    mImpl->vkCmdEndRenderingKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer);
 }
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
-void VkDecoderSnapshot::vkGetPhysicalDeviceFeatures2KHR(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetPhysicalDeviceFeatures2KHR(android::base::BumpPool* pool,
+                                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                                        const uint8_t* apiCallPacket,
+                                                        size_t apiCallPacketSize,
                                                         VkPhysicalDevice physicalDevice,
                                                         VkPhysicalDeviceFeatures2* pFeatures) {
-    mImpl->vkGetPhysicalDeviceFeatures2KHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkGetPhysicalDeviceFeatures2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            physicalDevice, pFeatures);
 }
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 void VkDecoderSnapshot::vkGetPhysicalDeviceProperties2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties) {
-    mImpl->vkGetPhysicalDeviceProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    VkPhysicalDeviceProperties2* pProperties) {
+    mImpl->vkGetPhysicalDeviceProperties2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              physicalDevice, pProperties);
 }
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 void VkDecoderSnapshot::vkGetPhysicalDeviceFormatProperties2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties) {
-    mImpl->vkGetPhysicalDeviceFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                   physicalDevice, format, pFormatProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, VkFormat format,
+    VkFormatProperties2* pFormatProperties) {
+    mImpl->vkGetPhysicalDeviceFormatProperties2KHR(pool, apiCallInfo, apiCallPacket,
+                                                   apiCallPacketSize, physicalDevice, format,
+                                                   pFormatProperties);
 }
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 void VkDecoderSnapshot::vkGetPhysicalDeviceImageFormatProperties2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkPhysicalDevice physicalDevice,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
     const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
     VkImageFormatProperties2* pImageFormatProperties) {
-    mImpl->vkGetPhysicalDeviceImageFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                        pool, input_result, physicalDevice,
-                                                        pImageFormatInfo, pImageFormatProperties);
+    mImpl->vkGetPhysicalDeviceImageFormatProperties2KHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, physicalDevice,
+        pImageFormatInfo, pImageFormatProperties);
 }
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 void VkDecoderSnapshot::vkGetPhysicalDeviceQueueFamilyProperties2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
     VkQueueFamilyProperties2* pQueueFamilyProperties) {
     mImpl->vkGetPhysicalDeviceQueueFamilyProperties2KHR(
-        snapshotTraceBegin, snapshotTraceBytes, pool, physicalDevice, pQueueFamilyPropertyCount,
-        pQueueFamilyProperties);
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice,
+        pQueueFamilyPropertyCount, pQueueFamilyProperties);
 }
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 void VkDecoderSnapshot::vkGetPhysicalDeviceMemoryProperties2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
-    mImpl->vkGetPhysicalDeviceMemoryProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                   physicalDevice, pMemoryProperties);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
+    mImpl->vkGetPhysicalDeviceMemoryProperties2KHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pMemoryProperties);
 }
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 void VkDecoderSnapshot::vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
-    uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
+    VkSparseImageFormatProperties2* pProperties) {
     mImpl->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
-        snapshotTraceBegin, snapshotTraceBytes, pool, physicalDevice, pFormatInfo, pPropertyCount,
-        pProperties);
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pFormatInfo,
+        pPropertyCount, pProperties);
 }
 #endif
 #ifdef VK_KHR_maintenance1
-void VkDecoderSnapshot::vkTrimCommandPoolKHR(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkDevice device,
-                                             VkCommandPool commandPool,
+void VkDecoderSnapshot::vkTrimCommandPoolKHR(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkDevice device, VkCommandPool commandPool,
                                              VkCommandPoolTrimFlags flags) {
-    mImpl->vkTrimCommandPoolKHR(snapshotTraceBegin, snapshotTraceBytes, pool, device, commandPool,
-                                flags);
+    mImpl->vkTrimCommandPoolKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                                commandPool, flags);
 }
 #endif
 #ifdef VK_KHR_external_memory_capabilities
 void VkDecoderSnapshot::vkGetPhysicalDeviceExternalBufferPropertiesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
     VkExternalBufferProperties* pExternalBufferProperties) {
-    mImpl->vkGetPhysicalDeviceExternalBufferPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                          pool, physicalDevice, pExternalBufferInfo,
-                                                          pExternalBufferProperties);
+    mImpl->vkGetPhysicalDeviceExternalBufferPropertiesKHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalBufferInfo,
+        pExternalBufferProperties);
 }
 #endif
 #ifdef VK_KHR_external_semaphore_capabilities
 void VkDecoderSnapshot::vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
     const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
     VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
     mImpl->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
-        snapshotTraceBegin, snapshotTraceBytes, pool, physicalDevice, pExternalSemaphoreInfo,
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalSemaphoreInfo,
         pExternalSemaphoreProperties);
 }
 #endif
 #ifdef VK_KHR_external_semaphore_fd
 void VkDecoderSnapshot::vkImportSemaphoreFdKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
     const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {
-    mImpl->vkImportSemaphoreFdKHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkImportSemaphoreFdKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, pImportSemaphoreFdInfo);
 }
 #endif
 #ifdef VK_KHR_external_semaphore_fd
-void VkDecoderSnapshot::vkGetSemaphoreFdKHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkResult input_result,
-                                            VkDevice device,
+void VkDecoderSnapshot::vkGetSemaphoreFdKHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, VkDevice device,
                                             const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd) {
-    mImpl->vkGetSemaphoreFdKHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                               pGetFdInfo, pFd);
+    mImpl->vkGetSemaphoreFdKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                               device, pGetFdInfo, pFd);
 }
 #endif
 #ifdef VK_KHR_descriptor_update_template
 void VkDecoderSnapshot::vkCreateDescriptorUpdateTemplateKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
     const VkAllocationCallbacks* pAllocator,
     VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
-    mImpl->vkCreateDescriptorUpdateTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkCreateDescriptorUpdateTemplateKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                input_result, device, pCreateInfo, pAllocator,
                                                pDescriptorUpdateTemplate);
 }
 #endif
 #ifdef VK_KHR_descriptor_update_template
 void VkDecoderSnapshot::vkDestroyDescriptorUpdateTemplateKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
     const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyDescriptorUpdateTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkDestroyDescriptorUpdateTemplateKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 device, descriptorUpdateTemplate, pAllocator);
 }
 #endif
 #ifdef VK_KHR_descriptor_update_template
 void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplateKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, VkDescriptorSet descriptorSet,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkDescriptorSet descriptorSet,
     VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
-    mImpl->vkUpdateDescriptorSetWithTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkUpdateDescriptorSetWithTemplateKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 device, descriptorSet, descriptorUpdateTemplate,
                                                 pData);
 }
 #endif
 #ifdef VK_KHR_create_renderpass2
 void VkDecoderSnapshot::vkCreateRenderPass2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
-    mImpl->vkCreateRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkRenderPass* pRenderPass) {
+    mImpl->vkCreateRenderPass2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, pCreateInfo, pAllocator, pRenderPass);
 }
 #endif
 #ifdef VK_KHR_create_renderpass2
-void VkDecoderSnapshot::vkCmdBeginRenderPass2KHR(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
-                                                 VkCommandBuffer commandBuffer,
-                                                 const VkRenderPassBeginInfo* pRenderPassBegin,
-                                                 const VkSubpassBeginInfo* pSubpassBeginInfo) {
-    mImpl->vkCmdBeginRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                    pRenderPassBegin, pSubpassBeginInfo);
+void VkDecoderSnapshot::vkCmdBeginRenderPass2KHR(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+    const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo) {
+    mImpl->vkCmdBeginRenderPass2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
 }
 #endif
 #ifdef VK_KHR_create_renderpass2
-void VkDecoderSnapshot::vkCmdNextSubpass2KHR(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdNextSubpass2KHR(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkCommandBuffer commandBuffer,
                                              const VkSubpassBeginInfo* pSubpassBeginInfo,
                                              const VkSubpassEndInfo* pSubpassEndInfo) {
-    mImpl->vkCmdNextSubpass2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdNextSubpass2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 pSubpassBeginInfo, pSubpassEndInfo);
 }
 #endif
 #ifdef VK_KHR_create_renderpass2
-void VkDecoderSnapshot::vkCmdEndRenderPass2KHR(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdEndRenderPass2KHR(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* apiCallInfo,
+                                               const uint8_t* apiCallPacket,
+                                               size_t apiCallPacketSize,
                                                VkCommandBuffer commandBuffer,
                                                const VkSubpassEndInfo* pSubpassEndInfo) {
-    mImpl->vkCmdEndRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  pSubpassEndInfo);
+    mImpl->vkCmdEndRenderPass2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, pSubpassEndInfo);
 }
 #endif
 #ifdef VK_KHR_external_fence_capabilities
 void VkDecoderSnapshot::vkGetPhysicalDeviceExternalFencePropertiesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
     VkExternalFenceProperties* pExternalFenceProperties) {
-    mImpl->vkGetPhysicalDeviceExternalFencePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes,
-                                                         pool, physicalDevice, pExternalFenceInfo,
-                                                         pExternalFenceProperties);
+    mImpl->vkGetPhysicalDeviceExternalFencePropertiesKHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalFenceInfo,
+        pExternalFenceProperties);
 }
 #endif
 #ifdef VK_KHR_external_fence_fd
-void VkDecoderSnapshot::vkImportFenceFdKHR(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkImportFenceFdKHR(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            const VkImportFenceFdInfoKHR* pImportFenceFdInfo) {
-    mImpl->vkImportFenceFdKHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                              pImportFenceFdInfo);
+    mImpl->vkImportFenceFdKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                              device, pImportFenceFdInfo);
 }
 #endif
 #ifdef VK_KHR_external_fence_fd
-void VkDecoderSnapshot::vkGetFenceFdKHR(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetFenceFdKHR(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd) {
-    mImpl->vkGetFenceFdKHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                           pGetFdInfo, pFd);
+    mImpl->vkGetFenceFdKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                           device, pGetFdInfo, pFd);
 }
 #endif
 #ifdef VK_KHR_get_memory_requirements2
 void VkDecoderSnapshot::vkGetImageMemoryRequirements2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
     VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->vkGetImageMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                            pInfo, pMemoryRequirements);
+    mImpl->vkGetImageMemoryRequirements2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                            device, pInfo, pMemoryRequirements);
 }
 #endif
 #ifdef VK_KHR_get_memory_requirements2
 void VkDecoderSnapshot::vkGetBufferMemoryRequirements2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
     VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->vkGetBufferMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                             pInfo, pMemoryRequirements);
+    mImpl->vkGetBufferMemoryRequirements2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                             device, pInfo, pMemoryRequirements);
 }
 #endif
 #ifdef VK_KHR_get_memory_requirements2
 void VkDecoderSnapshot::vkGetImageSparseMemoryRequirements2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
     uint32_t* pSparseMemoryRequirementCount,
     VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
-    mImpl->vkGetImageSparseMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                  device, pInfo, pSparseMemoryRequirementCount,
-                                                  pSparseMemoryRequirements);
+    mImpl->vkGetImageSparseMemoryRequirements2KHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo,
+        pSparseMemoryRequirementCount, pSparseMemoryRequirements);
 }
 #endif
 #ifdef VK_KHR_sampler_ycbcr_conversion
 void VkDecoderSnapshot::vkCreateSamplerYcbcrConversionKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
-    mImpl->vkCreateSamplerYcbcrConversionKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkSamplerYcbcrConversion* pYcbcrConversion) {
+    mImpl->vkCreateSamplerYcbcrConversionKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              input_result, device, pCreateInfo, pAllocator,
                                              pYcbcrConversion);
 }
 #endif
 #ifdef VK_KHR_sampler_ycbcr_conversion
 void VkDecoderSnapshot::vkDestroySamplerYcbcrConversionKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
     const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroySamplerYcbcrConversionKHR(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                              ycbcrConversion, pAllocator);
+    mImpl->vkDestroySamplerYcbcrConversionKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                              device, ycbcrConversion, pAllocator);
 }
 #endif
 #ifdef VK_KHR_bind_memory2
-void VkDecoderSnapshot::vkBindBufferMemory2KHR(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool, VkResult input_result,
+void VkDecoderSnapshot::vkBindBufferMemory2KHR(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* apiCallInfo,
+                                               const uint8_t* apiCallPacket,
+                                               size_t apiCallPacketSize, VkResult input_result,
                                                VkDevice device, uint32_t bindInfoCount,
                                                const VkBindBufferMemoryInfo* pBindInfos) {
-    mImpl->vkBindBufferMemory2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkBindBufferMemory2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, bindInfoCount, pBindInfos);
 }
 #endif
 #ifdef VK_KHR_bind_memory2
-void VkDecoderSnapshot::vkBindImageMemory2KHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
+void VkDecoderSnapshot::vkBindImageMemory2KHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkResult input_result,
                                               VkDevice device, uint32_t bindInfoCount,
                                               const VkBindImageMemoryInfo* pBindInfos) {
-    mImpl->vkBindImageMemory2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                 bindInfoCount, pBindInfos);
+    mImpl->vkBindImageMemory2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                 device, bindInfoCount, pBindInfos);
 }
 #endif
 #ifdef VK_KHR_maintenance3
 void VkDecoderSnapshot::vkGetDescriptorSetLayoutSupportKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
     VkDescriptorSetLayoutSupport* pSupport) {
-    mImpl->vkGetDescriptorSetLayoutSupportKHR(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                              pCreateInfo, pSupport);
+    mImpl->vkGetDescriptorSetLayoutSupportKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                              device, pCreateInfo, pSupport);
 }
 #endif
 #ifdef VK_KHR_buffer_device_address
-void VkDecoderSnapshot::vkGetBufferDeviceAddressKHR(const uint8_t* snapshotTraceBegin,
-                                                    size_t snapshotTraceBytes,
-                                                    android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetBufferDeviceAddressKHR(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                                    const uint8_t* apiCallPacket,
+                                                    size_t apiCallPacketSize,
                                                     VkDeviceAddress input_result, VkDevice device,
                                                     const VkBufferDeviceAddressInfo* pInfo) {
-    mImpl->vkGetBufferDeviceAddressKHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                       device, pInfo);
+    mImpl->vkGetBufferDeviceAddressKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                       input_result, device, pInfo);
 }
 #endif
 #ifdef VK_KHR_buffer_device_address
-void VkDecoderSnapshot::vkGetBufferOpaqueCaptureAddressKHR(const uint8_t* snapshotTraceBegin,
-                                                           size_t snapshotTraceBytes,
-                                                           android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetBufferOpaqueCaptureAddressKHR(android::base::BumpPool* pool,
+                                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                                           const uint8_t* apiCallPacket,
+                                                           size_t apiCallPacketSize,
                                                            uint64_t input_result, VkDevice device,
                                                            const VkBufferDeviceAddressInfo* pInfo) {
-    mImpl->vkGetBufferOpaqueCaptureAddressKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkGetBufferOpaqueCaptureAddressKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               input_result, device, pInfo);
 }
 #endif
 #ifdef VK_KHR_buffer_device_address
 void VkDecoderSnapshot::vkGetDeviceMemoryOpaqueCaptureAddressKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    uint64_t input_result, VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
-    mImpl->vkGetDeviceMemoryOpaqueCaptureAddressKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                    input_result, device, pInfo);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, uint64_t input_result, VkDevice device,
+    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
+    mImpl->vkGetDeviceMemoryOpaqueCaptureAddressKHR(pool, apiCallInfo, apiCallPacket,
+                                                    apiCallPacketSize, input_result, device, pInfo);
 }
 #endif
 #ifdef VK_KHR_pipeline_executable_properties
 void VkDecoderSnapshot::vkGetPipelineExecutablePropertiesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkPipelineInfoKHR* pPipelineInfo,
-    uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties) {
-    mImpl->vkGetPipelineExecutablePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount,
+    VkPipelineExecutablePropertiesKHR* pProperties) {
+    mImpl->vkGetPipelineExecutablePropertiesKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 input_result, device, pPipelineInfo,
                                                 pExecutableCount, pProperties);
 }
 #endif
 #ifdef VK_KHR_pipeline_executable_properties
 void VkDecoderSnapshot::vkGetPipelineExecutableStatisticsKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
-    uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics) {
-    mImpl->vkGetPipelineExecutableStatisticsKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount,
+    VkPipelineExecutableStatisticKHR* pStatistics) {
+    mImpl->vkGetPipelineExecutableStatisticsKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 input_result, device, pExecutableInfo,
                                                 pStatisticCount, pStatistics);
 }
 #endif
 #ifdef VK_KHR_pipeline_executable_properties
 void VkDecoderSnapshot::vkGetPipelineExecutableInternalRepresentationsKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
-    uint32_t* pInternalRepresentationCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount,
     VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) {
     mImpl->vkGetPipelineExecutableInternalRepresentationsKHR(
-        snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device, pExecutableInfo,
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device, pExecutableInfo,
         pInternalRepresentationCount, pInternalRepresentations);
 }
 #endif
 #ifdef VK_KHR_synchronization2
-void VkDecoderSnapshot::vkCmdSetEvent2KHR(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetEvent2KHR(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, VkEvent event,
                                           const VkDependencyInfo* pDependencyInfo) {
-    mImpl->vkCmdSetEvent2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, event,
-                             pDependencyInfo);
+    mImpl->vkCmdSetEvent2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                             event, pDependencyInfo);
 }
 #endif
 #ifdef VK_KHR_synchronization2
-void VkDecoderSnapshot::vkCmdResetEvent2KHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdResetEvent2KHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer, VkEvent event,
                                             VkPipelineStageFlags2 stageMask) {
-    mImpl->vkCmdResetEvent2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, event,
-                               stageMask);
+    mImpl->vkCmdResetEvent2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                               event, stageMask);
 }
 #endif
 #ifdef VK_KHR_synchronization2
-void VkDecoderSnapshot::vkCmdWaitEvents2KHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdWaitEvents2KHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer, uint32_t eventCount,
                                             const VkEvent* pEvents,
                                             const VkDependencyInfo* pDependencyInfos) {
-    mImpl->vkCmdWaitEvents2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdWaitEvents2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                eventCount, pEvents, pDependencyInfos);
 }
 #endif
 #ifdef VK_KHR_synchronization2
-void VkDecoderSnapshot::vkCmdPipelineBarrier2KHR(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdPipelineBarrier2KHR(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize,
                                                  VkCommandBuffer commandBuffer,
                                                  const VkDependencyInfo* pDependencyInfo) {
-    mImpl->vkCmdPipelineBarrier2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                    pDependencyInfo);
+    mImpl->vkCmdPipelineBarrier2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    commandBuffer, pDependencyInfo);
 }
 #endif
 #ifdef VK_KHR_synchronization2
-void VkDecoderSnapshot::vkCmdWriteTimestamp2KHR(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
-                                                VkCommandBuffer commandBuffer,
-                                                VkPipelineStageFlags2 stage, VkQueryPool queryPool,
-                                                uint32_t query) {
-    mImpl->vkCmdWriteTimestamp2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                   stage, queryPool, query);
+void VkDecoderSnapshot::vkCmdWriteTimestamp2KHR(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
+    VkQueryPool queryPool, uint32_t query) {
+    mImpl->vkCmdWriteTimestamp2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                   commandBuffer, stage, queryPool, query);
 }
 #endif
 #ifdef VK_KHR_synchronization2
-void VkDecoderSnapshot::vkQueueSubmit2KHR(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkQueueSubmit2KHR(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkQueue queue,
                                           uint32_t submitCount, const VkSubmitInfo2* pSubmits,
                                           VkFence fence) {
-    mImpl->vkQueueSubmit2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, queue,
-                             submitCount, pSubmits, fence);
+    mImpl->vkQueueSubmit2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                             queue, submitCount, pSubmits, fence);
 }
 #endif
 #ifdef VK_KHR_synchronization2
-void VkDecoderSnapshot::vkCmdWriteBufferMarker2AMD(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool,
-                                                   VkCommandBuffer commandBuffer,
-                                                   VkPipelineStageFlags2 stage, VkBuffer dstBuffer,
-                                                   VkDeviceSize dstOffset, uint32_t marker) {
-    mImpl->vkCmdWriteBufferMarker2AMD(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                      stage, dstBuffer, dstOffset, marker);
+void VkDecoderSnapshot::vkCmdWriteBufferMarker2AMD(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
+    VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
+    mImpl->vkCmdWriteBufferMarker2AMD(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      commandBuffer, stage, dstBuffer, dstOffset, marker);
 }
 #endif
 #ifdef VK_KHR_synchronization2
-void VkDecoderSnapshot::vkGetQueueCheckpointData2NV(const uint8_t* snapshotTraceBegin,
-                                                    size_t snapshotTraceBytes,
-                                                    android::base::BumpPool* pool, VkQueue queue,
+void VkDecoderSnapshot::vkGetQueueCheckpointData2NV(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                                    const uint8_t* apiCallPacket,
+                                                    size_t apiCallPacketSize, VkQueue queue,
                                                     uint32_t* pCheckpointDataCount,
                                                     VkCheckpointData2NV* pCheckpointData) {
-    mImpl->vkGetQueueCheckpointData2NV(snapshotTraceBegin, snapshotTraceBytes, pool, queue,
+    mImpl->vkGetQueueCheckpointData2NV(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                        pCheckpointDataCount, pCheckpointData);
 }
 #endif
 #ifdef VK_KHR_copy_commands2
-void VkDecoderSnapshot::vkCmdCopyBuffer2KHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdCopyBuffer2KHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             const VkCopyBufferInfo2* pCopyBufferInfo) {
-    mImpl->vkCmdCopyBuffer2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdCopyBuffer2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                pCopyBufferInfo);
 }
 #endif
 #ifdef VK_KHR_copy_commands2
-void VkDecoderSnapshot::vkCmdCopyImage2KHR(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdCopyImage2KHR(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            const VkCopyImageInfo2* pCopyImageInfo) {
-    mImpl->vkCmdCopyImage2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdCopyImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               pCopyImageInfo);
 }
 #endif
 #ifdef VK_KHR_copy_commands2
 void VkDecoderSnapshot::vkCmdCopyBufferToImage2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
-    mImpl->vkCmdCopyBufferToImage2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                      pCopyBufferToImageInfo);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+    const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
+    mImpl->vkCmdCopyBufferToImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      commandBuffer, pCopyBufferToImageInfo);
 }
 #endif
 #ifdef VK_KHR_copy_commands2
 void VkDecoderSnapshot::vkCmdCopyImageToBuffer2KHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
-    mImpl->vkCmdCopyImageToBuffer2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                      pCopyImageToBufferInfo);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+    const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
+    mImpl->vkCmdCopyImageToBuffer2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      commandBuffer, pCopyImageToBufferInfo);
 }
 #endif
 #ifdef VK_KHR_copy_commands2
-void VkDecoderSnapshot::vkCmdBlitImage2KHR(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdBlitImage2KHR(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            const VkBlitImageInfo2* pBlitImageInfo) {
-    mImpl->vkCmdBlitImage2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdBlitImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               pBlitImageInfo);
 }
 #endif
 #ifdef VK_KHR_copy_commands2
-void VkDecoderSnapshot::vkCmdResolveImage2KHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdResolveImage2KHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize,
                                               VkCommandBuffer commandBuffer,
                                               const VkResolveImageInfo2* pResolveImageInfo) {
-    mImpl->vkCmdResolveImage2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdResolveImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                  pResolveImageInfo);
 }
 #endif
 #ifdef VK_KHR_maintenance4
 void VkDecoderSnapshot::vkGetDeviceBufferMemoryRequirementsKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
     VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->vkGetDeviceBufferMemoryRequirementsKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                  device, pInfo, pMemoryRequirements);
+    mImpl->vkGetDeviceBufferMemoryRequirementsKHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo, pMemoryRequirements);
 }
 #endif
 #ifdef VK_KHR_maintenance4
 void VkDecoderSnapshot::vkGetDeviceImageMemoryRequirementsKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
     VkMemoryRequirements2* pMemoryRequirements) {
-    mImpl->vkGetDeviceImageMemoryRequirementsKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                 device, pInfo, pMemoryRequirements);
+    mImpl->vkGetDeviceImageMemoryRequirementsKHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo, pMemoryRequirements);
 }
 #endif
 #ifdef VK_KHR_maintenance4
 void VkDecoderSnapshot::vkGetDeviceImageSparseMemoryRequirementsKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
     uint32_t* pSparseMemoryRequirementCount,
     VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
-    mImpl->vkGetDeviceImageSparseMemoryRequirementsKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                       device, pInfo, pSparseMemoryRequirementCount,
-                                                       pSparseMemoryRequirements);
+    mImpl->vkGetDeviceImageSparseMemoryRequirementsKHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo,
+        pSparseMemoryRequirementCount, pSparseMemoryRequirements);
 }
 #endif
 #ifdef VK_KHR_maintenance5
-void VkDecoderSnapshot::vkCmdBindIndexBuffer2KHR(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
-                                                 VkCommandBuffer commandBuffer, VkBuffer buffer,
-                                                 VkDeviceSize offset, VkDeviceSize size,
-                                                 VkIndexType indexType) {
-    mImpl->vkCmdBindIndexBuffer2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                    buffer, offset, size, indexType);
+void VkDecoderSnapshot::vkCmdBindIndexBuffer2KHR(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+    VkDeviceSize size, VkIndexType indexType) {
+    mImpl->vkCmdBindIndexBuffer2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                    commandBuffer, buffer, offset, size, indexType);
 }
 #endif
 #ifdef VK_KHR_maintenance5
 void VkDecoderSnapshot::vkGetRenderingAreaGranularityKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkRenderingAreaInfoKHR* pRenderingAreaInfo, VkExtent2D* pGranularity) {
-    mImpl->vkGetRenderingAreaGranularityKHR(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                            pRenderingAreaInfo, pGranularity);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkRenderingAreaInfoKHR* pRenderingAreaInfo,
+    VkExtent2D* pGranularity) {
+    mImpl->vkGetRenderingAreaGranularityKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                            device, pRenderingAreaInfo, pGranularity);
 }
 #endif
 #ifdef VK_KHR_maintenance5
 void VkDecoderSnapshot::vkGetDeviceImageSubresourceLayoutKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkDeviceImageSubresourceInfoKHR* pInfo,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageSubresourceInfoKHR* pInfo,
     VkSubresourceLayout2KHR* pLayout) {
-    mImpl->vkGetDeviceImageSubresourceLayoutKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkGetDeviceImageSubresourceLayoutKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 device, pInfo, pLayout);
 }
 #endif
 #ifdef VK_KHR_maintenance5
-void VkDecoderSnapshot::vkGetImageSubresourceLayout2KHR(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
-                                                        VkDevice device, VkImage image,
-                                                        const VkImageSubresource2KHR* pSubresource,
-                                                        VkSubresourceLayout2KHR* pLayout) {
-    mImpl->vkGetImageSubresourceLayout2KHR(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                           image, pSubresource, pLayout);
+void VkDecoderSnapshot::vkGetImageSubresourceLayout2KHR(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkImage image,
+    const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout) {
+    mImpl->vkGetImageSubresourceLayout2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                           device, image, pSubresource, pLayout);
 }
 #endif
 #ifdef VK_KHR_line_rasterization
 void VkDecoderSnapshot::vkCmdSetLineStippleKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
-    mImpl->vkCmdSetLineStippleKHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  lineStippleFactor, lineStipplePattern);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
+    uint16_t lineStipplePattern) {
+    mImpl->vkCmdSetLineStippleKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, lineStippleFactor, lineStipplePattern);
 }
 #endif
 #ifdef VK_ANDROID_native_buffer
 void VkDecoderSnapshot::vkGetSwapchainGrallocUsageANDROID(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
-    int* grallocUsage) {
-    mImpl->vkGetSwapchainGrallocUsageANDROID(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkFormat format,
+    VkImageUsageFlags imageUsage, int* grallocUsage) {
+    mImpl->vkGetSwapchainGrallocUsageANDROID(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              input_result, device, format, imageUsage,
                                              grallocUsage);
 }
 #endif
 #ifdef VK_ANDROID_native_buffer
-void VkDecoderSnapshot::vkAcquireImageANDROID(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
+void VkDecoderSnapshot::vkAcquireImageANDROID(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkResult input_result,
                                               VkDevice device, VkImage image, int nativeFenceFd,
                                               VkSemaphore semaphore, VkFence fence) {
-    mImpl->vkAcquireImageANDROID(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                 image, nativeFenceFd, semaphore, fence);
+    mImpl->vkAcquireImageANDROID(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                 device, image, nativeFenceFd, semaphore, fence);
 }
 #endif
 #ifdef VK_ANDROID_native_buffer
 void VkDecoderSnapshot::vkQueueSignalReleaseImageANDROID(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkQueue queue, uint32_t waitSemaphoreCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkQueue queue, uint32_t waitSemaphoreCount,
     const VkSemaphore* pWaitSemaphores, VkImage image, int* pNativeFenceFd) {
-    mImpl->vkQueueSignalReleaseImageANDROID(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkQueueSignalReleaseImageANDROID(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             input_result, queue, waitSemaphoreCount,
                                             pWaitSemaphores, image, pNativeFenceFd);
 }
 #endif
 #ifdef VK_ANDROID_native_buffer
 void VkDecoderSnapshot::vkGetSwapchainGrallocUsage2ANDROID(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
-    VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
-    uint64_t* grallocProducerUsage) {
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkFormat format,
+    VkImageUsageFlags imageUsage, VkSwapchainImageUsageFlagsANDROID swapchainImageUsage,
+    uint64_t* grallocConsumerUsage, uint64_t* grallocProducerUsage) {
     mImpl->vkGetSwapchainGrallocUsage2ANDROID(
-        snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device, format, imageUsage,
-        swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage);
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device, format,
+        imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage);
 }
 #endif
 #ifdef VK_EXT_debug_report
 void VkDecoderSnapshot::vkCreateDebugReportCallbackEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkInstance instance,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkInstance instance,
     const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator,
     VkDebugReportCallbackEXT* pCallback) {
-    mImpl->vkCreateDebugReportCallbackEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkCreateDebugReportCallbackEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           input_result, instance, pCreateInfo, pAllocator,
                                           pCallback);
 }
 #endif
 #ifdef VK_EXT_debug_report
-void VkDecoderSnapshot::vkDestroyDebugReportCallbackEXT(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
-                                                        VkInstance instance,
-                                                        VkDebugReportCallbackEXT callback,
-                                                        const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyDebugReportCallbackEXT(snapshotTraceBegin, snapshotTraceBytes, pool, instance,
-                                           callback, pAllocator);
+void VkDecoderSnapshot::vkDestroyDebugReportCallbackEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkInstance instance, VkDebugReportCallbackEXT callback,
+    const VkAllocationCallbacks* pAllocator) {
+    mImpl->vkDestroyDebugReportCallbackEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                           instance, callback, pAllocator);
 }
 #endif
 #ifdef VK_EXT_debug_report
 void VkDecoderSnapshot::vkDebugReportMessageEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType,
-    uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix,
-    const char* pMessage) {
-    mImpl->vkDebugReportMessageEXT(snapshotTraceBegin, snapshotTraceBytes, pool, instance, flags,
-                                   objectType, object, location, messageCode, pLayerPrefix,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkInstance instance, VkDebugReportFlagsEXT flags,
+    VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode,
+    const char* pLayerPrefix, const char* pMessage) {
+    mImpl->vkDebugReportMessageEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, instance,
+                                   flags, objectType, object, location, messageCode, pLayerPrefix,
                                    pMessage);
 }
 #endif
 #ifdef VK_EXT_transform_feedback
 void VkDecoderSnapshot::vkCmdBindTransformFeedbackBuffersEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
-    const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes) {
-    mImpl->vkCmdBindTransformFeedbackBuffersEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstBinding,
+    uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
+    const VkDeviceSize* pSizes) {
+    mImpl->vkCmdBindTransformFeedbackBuffersEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 commandBuffer, firstBinding, bindingCount, pBuffers,
                                                 pOffsets, pSizes);
 }
 #endif
 #ifdef VK_EXT_transform_feedback
 void VkDecoderSnapshot::vkCmdBeginTransformFeedbackEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount,
-    const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets) {
-    mImpl->vkCmdBeginTransformFeedbackEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
+    uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
+    const VkDeviceSize* pCounterBufferOffsets) {
+    mImpl->vkCmdBeginTransformFeedbackEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           commandBuffer, firstCounterBuffer, counterBufferCount,
                                           pCounterBuffers, pCounterBufferOffsets);
 }
 #endif
 #ifdef VK_EXT_transform_feedback
 void VkDecoderSnapshot::vkCmdEndTransformFeedbackEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount,
-    const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets) {
-    mImpl->vkCmdEndTransformFeedbackEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                        firstCounterBuffer, counterBufferCount, pCounterBuffers,
-                                        pCounterBufferOffsets);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
+    uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
+    const VkDeviceSize* pCounterBufferOffsets) {
+    mImpl->vkCmdEndTransformFeedbackEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                        commandBuffer, firstCounterBuffer, counterBufferCount,
+                                        pCounterBuffers, pCounterBufferOffsets);
 }
 #endif
 #ifdef VK_EXT_transform_feedback
-void VkDecoderSnapshot::vkCmdBeginQueryIndexedEXT(const uint8_t* snapshotTraceBegin,
-                                                  size_t snapshotTraceBytes,
-                                                  android::base::BumpPool* pool,
-                                                  VkCommandBuffer commandBuffer,
-                                                  VkQueryPool queryPool, uint32_t query,
-                                                  VkQueryControlFlags flags, uint32_t index) {
-    mImpl->vkCmdBeginQueryIndexedEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                     queryPool, query, flags, index);
+void VkDecoderSnapshot::vkCmdBeginQueryIndexedEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
+    VkQueryControlFlags flags, uint32_t index) {
+    mImpl->vkCmdBeginQueryIndexedEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                     commandBuffer, queryPool, query, flags, index);
 }
 #endif
 #ifdef VK_EXT_transform_feedback
 void VkDecoderSnapshot::vkCmdEndQueryIndexedEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) {
-    mImpl->vkCmdEndQueryIndexedEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                   queryPool, query, index);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
+    uint32_t index) {
+    mImpl->vkCmdEndQueryIndexedEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                   commandBuffer, queryPool, query, index);
 }
 #endif
 #ifdef VK_EXT_transform_feedback
 void VkDecoderSnapshot::vkCmdDrawIndirectByteCountEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance,
-    VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset,
-    uint32_t vertexStride) {
-    mImpl->vkCmdDrawIndirectByteCountEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t instanceCount,
+    uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset,
+    uint32_t counterOffset, uint32_t vertexStride) {
+    mImpl->vkCmdDrawIndirectByteCountEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          commandBuffer, instanceCount, firstInstance, counterBuffer,
                                          counterBufferOffset, counterOffset, vertexStride);
 }
 #endif
 #ifdef VK_EXT_debug_utils
 void VkDecoderSnapshot::vkSetDebugUtilsObjectNameEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo) {
-    mImpl->vkSetDebugUtilsObjectNameEXT(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                        device, pNameInfo);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkDebugUtilsObjectNameInfoEXT* pNameInfo) {
+    mImpl->vkSetDebugUtilsObjectNameEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                        input_result, device, pNameInfo);
 }
 #endif
 #ifdef VK_EXT_debug_utils
-void VkDecoderSnapshot::vkSetDebugUtilsObjectTagEXT(const uint8_t* snapshotTraceBegin,
-                                                    size_t snapshotTraceBytes,
-                                                    android::base::BumpPool* pool,
-                                                    VkResult input_result, VkDevice device,
+void VkDecoderSnapshot::vkSetDebugUtilsObjectTagEXT(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                                    const uint8_t* apiCallPacket,
+                                                    size_t apiCallPacketSize, VkResult input_result,
+                                                    VkDevice device,
                                                     const VkDebugUtilsObjectTagInfoEXT* pTagInfo) {
-    mImpl->vkSetDebugUtilsObjectTagEXT(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                       device, pTagInfo);
+    mImpl->vkSetDebugUtilsObjectTagEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                       input_result, device, pTagInfo);
 }
 #endif
 #ifdef VK_EXT_debug_utils
-void VkDecoderSnapshot::vkQueueBeginDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                                       size_t snapshotTraceBytes,
-                                                       android::base::BumpPool* pool, VkQueue queue,
+void VkDecoderSnapshot::vkQueueBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                                       const uint8_t* apiCallPacket,
+                                                       size_t apiCallPacketSize, VkQueue queue,
                                                        const VkDebugUtilsLabelEXT* pLabelInfo) {
-    mImpl->vkQueueBeginDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, pool, queue,
-                                          pLabelInfo);
+    mImpl->vkQueueBeginDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                          queue, pLabelInfo);
 }
 #endif
 #ifdef VK_EXT_debug_utils
-void VkDecoderSnapshot::vkQueueEndDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool, VkQueue queue) {
-    mImpl->vkQueueEndDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, pool, queue);
+void VkDecoderSnapshot::vkQueueEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                                     const uint8_t* apiCallPacket,
+                                                     size_t apiCallPacketSize, VkQueue queue) {
+    mImpl->vkQueueEndDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue);
 }
 #endif
 #ifdef VK_EXT_debug_utils
-void VkDecoderSnapshot::vkQueueInsertDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
-                                                        VkQueue queue,
+void VkDecoderSnapshot::vkQueueInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                                        const uint8_t* apiCallPacket,
+                                                        size_t apiCallPacketSize, VkQueue queue,
                                                         const VkDebugUtilsLabelEXT* pLabelInfo) {
-    mImpl->vkQueueInsertDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, pool, queue,
-                                           pLabelInfo);
+    mImpl->vkQueueInsertDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                           queue, pLabelInfo);
 }
 #endif
 #ifdef VK_EXT_debug_utils
-void VkDecoderSnapshot::vkCmdBeginDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                                     const uint8_t* apiCallPacket,
+                                                     size_t apiCallPacketSize,
                                                      VkCommandBuffer commandBuffer,
                                                      const VkDebugUtilsLabelEXT* pLabelInfo) {
-    mImpl->vkCmdBeginDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                        pLabelInfo);
+    mImpl->vkCmdBeginDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                        commandBuffer, pLabelInfo);
 }
 #endif
 #ifdef VK_EXT_debug_utils
-void VkDecoderSnapshot::vkCmdEndDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* apiCallInfo,
+                                                   const uint8_t* apiCallPacket,
+                                                   size_t apiCallPacketSize,
                                                    VkCommandBuffer commandBuffer) {
-    mImpl->vkCmdEndDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer);
+    mImpl->vkCmdEndDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      commandBuffer);
 }
 #endif
 #ifdef VK_EXT_debug_utils
-void VkDecoderSnapshot::vkCmdInsertDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                                      size_t snapshotTraceBytes,
-                                                      android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                                      const uint8_t* apiCallPacket,
+                                                      size_t apiCallPacketSize,
                                                       VkCommandBuffer commandBuffer,
                                                       const VkDebugUtilsLabelEXT* pLabelInfo) {
-    mImpl->vkCmdInsertDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkCmdInsertDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          commandBuffer, pLabelInfo);
 }
 #endif
 #ifdef VK_EXT_debug_utils
 void VkDecoderSnapshot::vkCreateDebugUtilsMessengerEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkInstance instance,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkInstance instance,
     const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator,
     VkDebugUtilsMessengerEXT* pMessenger) {
-    mImpl->vkCreateDebugUtilsMessengerEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkCreateDebugUtilsMessengerEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           input_result, instance, pCreateInfo, pAllocator,
                                           pMessenger);
 }
 #endif
 #ifdef VK_EXT_debug_utils
-void VkDecoderSnapshot::vkDestroyDebugUtilsMessengerEXT(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
-                                                        VkInstance instance,
-                                                        VkDebugUtilsMessengerEXT messenger,
-                                                        const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyDebugUtilsMessengerEXT(snapshotTraceBegin, snapshotTraceBytes, pool, instance,
-                                           messenger, pAllocator);
+void VkDecoderSnapshot::vkDestroyDebugUtilsMessengerEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkInstance instance, VkDebugUtilsMessengerEXT messenger,
+    const VkAllocationCallbacks* pAllocator) {
+    mImpl->vkDestroyDebugUtilsMessengerEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                           instance, messenger, pAllocator);
 }
 #endif
 #ifdef VK_EXT_debug_utils
 void VkDecoderSnapshot::vkSubmitDebugUtilsMessageEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkInstance instance,
+    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
     VkDebugUtilsMessageTypeFlagsEXT messageTypes,
     const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData) {
-    mImpl->vkSubmitDebugUtilsMessageEXT(snapshotTraceBegin, snapshotTraceBytes, pool, instance,
-                                        messageSeverity, messageTypes, pCallbackData);
+    mImpl->vkSubmitDebugUtilsMessageEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                        instance, messageSeverity, messageTypes, pCallbackData);
 }
 #endif
 #ifdef VK_EXT_image_drm_format_modifier
 void VkDecoderSnapshot::vkGetImageDrmFormatModifierPropertiesEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkImage image,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkImage image,
     VkImageDrmFormatModifierPropertiesEXT* pProperties) {
-    mImpl->vkGetImageDrmFormatModifierPropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                    input_result, device, image, pProperties);
+    mImpl->vkGetImageDrmFormatModifierPropertiesEXT(pool, apiCallInfo, apiCallPacket,
+                                                    apiCallPacketSize, input_result, device, image,
+                                                    pProperties);
 }
 #endif
 #ifdef VK_EXT_external_memory_host
 void VkDecoderSnapshot::vkGetMemoryHostPointerPropertiesEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType,
-    const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {
-    mImpl->vkGetMemoryHostPointerPropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer,
+    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {
+    mImpl->vkGetMemoryHostPointerPropertiesEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                input_result, device, handleType, pHostPointer,
                                                pMemoryHostPointerProperties);
 }
 #endif
 #ifdef VK_EXT_tooling_info
 void VkDecoderSnapshot::vkGetPhysicalDeviceToolPropertiesEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
-    VkPhysicalDeviceToolProperties* pToolProperties) {
-    mImpl->vkGetPhysicalDeviceToolPropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
+    uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) {
+    mImpl->vkGetPhysicalDeviceToolPropertiesEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 input_result, physicalDevice, pToolCount,
                                                 pToolProperties);
 }
 #endif
 #ifdef VK_EXT_line_rasterization
 void VkDecoderSnapshot::vkCmdSetLineStippleEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
-    mImpl->vkCmdSetLineStippleEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                  lineStippleFactor, lineStipplePattern);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
+    uint16_t lineStipplePattern) {
+    mImpl->vkCmdSetLineStippleEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                  commandBuffer, lineStippleFactor, lineStipplePattern);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-void VkDecoderSnapshot::vkCmdSetCullModeEXT(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetCullModeEXT(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             VkCullModeFlags cullMode) {
-    mImpl->vkCmdSetCullModeEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdSetCullModeEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                cullMode);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-void VkDecoderSnapshot::vkCmdSetFrontFaceEXT(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetFrontFaceEXT(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
-    mImpl->vkCmdSetFrontFaceEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdSetFrontFaceEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 frontFace);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-void VkDecoderSnapshot::vkCmdSetPrimitiveTopologyEXT(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetPrimitiveTopologyEXT(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                                     const uint8_t* apiCallPacket,
+                                                     size_t apiCallPacketSize,
                                                      VkCommandBuffer commandBuffer,
                                                      VkPrimitiveTopology primitiveTopology) {
-    mImpl->vkCmdSetPrimitiveTopologyEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                        primitiveTopology);
+    mImpl->vkCmdSetPrimitiveTopologyEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                        commandBuffer, primitiveTopology);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
 void VkDecoderSnapshot::vkCmdSetViewportWithCountEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports) {
-    mImpl->vkCmdSetViewportWithCountEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                        viewportCount, pViewports);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t viewportCount,
+    const VkViewport* pViewports) {
+    mImpl->vkCmdSetViewportWithCountEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                        commandBuffer, viewportCount, pViewports);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
 void VkDecoderSnapshot::vkCmdSetScissorWithCountEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors) {
-    mImpl->vkCmdSetScissorWithCountEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                       scissorCount, pScissors);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t scissorCount,
+    const VkRect2D* pScissors) {
+    mImpl->vkCmdSetScissorWithCountEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                       commandBuffer, scissorCount, pScissors);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
 void VkDecoderSnapshot::vkCmdBindVertexBuffers2EXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
-    const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
-    const VkDeviceSize* pStrides) {
-    mImpl->vkCmdBindVertexBuffers2EXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                      firstBinding, bindingCount, pBuffers, pOffsets, pSizes,
-                                      pStrides);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstBinding,
+    uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
+    const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
+    mImpl->vkCmdBindVertexBuffers2EXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets,
+                                      pSizes, pStrides);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-void VkDecoderSnapshot::vkCmdSetDepthTestEnableEXT(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool,
-                                                   VkCommandBuffer commandBuffer,
-                                                   VkBool32 depthTestEnable) {
-    mImpl->vkCmdSetDepthTestEnableEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                      depthTestEnable);
+void VkDecoderSnapshot::vkCmdSetDepthTestEnableEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
+    mImpl->vkCmdSetDepthTestEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      commandBuffer, depthTestEnable);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-void VkDecoderSnapshot::vkCmdSetDepthWriteEnableEXT(const uint8_t* snapshotTraceBegin,
-                                                    size_t snapshotTraceBytes,
-                                                    android::base::BumpPool* pool,
-                                                    VkCommandBuffer commandBuffer,
-                                                    VkBool32 depthWriteEnable) {
-    mImpl->vkCmdSetDepthWriteEnableEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                       depthWriteEnable);
+void VkDecoderSnapshot::vkCmdSetDepthWriteEnableEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
+    mImpl->vkCmdSetDepthWriteEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                       commandBuffer, depthWriteEnable);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-void VkDecoderSnapshot::vkCmdSetDepthCompareOpEXT(const uint8_t* snapshotTraceBegin,
-                                                  size_t snapshotTraceBytes,
-                                                  android::base::BumpPool* pool,
-                                                  VkCommandBuffer commandBuffer,
-                                                  VkCompareOp depthCompareOp) {
-    mImpl->vkCmdSetDepthCompareOpEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                     depthCompareOp);
+void VkDecoderSnapshot::vkCmdSetDepthCompareOpEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
+    mImpl->vkCmdSetDepthCompareOpEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                     commandBuffer, depthCompareOp);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-void VkDecoderSnapshot::vkCmdSetDepthBoundsTestEnableEXT(const uint8_t* snapshotTraceBegin,
-                                                         size_t snapshotTraceBytes,
-                                                         android::base::BumpPool* pool,
-                                                         VkCommandBuffer commandBuffer,
-                                                         VkBool32 depthBoundsTestEnable) {
-    mImpl->vkCmdSetDepthBoundsTestEnableEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkCmdSetDepthBoundsTestEnableEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
+    mImpl->vkCmdSetDepthBoundsTestEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             commandBuffer, depthBoundsTestEnable);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-void VkDecoderSnapshot::vkCmdSetStencilTestEnableEXT(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool,
-                                                     VkCommandBuffer commandBuffer,
-                                                     VkBool32 stencilTestEnable) {
-    mImpl->vkCmdSetStencilTestEnableEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                        stencilTestEnable);
+void VkDecoderSnapshot::vkCmdSetStencilTestEnableEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
+    mImpl->vkCmdSetStencilTestEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                        commandBuffer, stencilTestEnable);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state
 void VkDecoderSnapshot::vkCmdSetStencilOpEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp,
-    VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
-    mImpl->vkCmdSetStencilOpEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+    VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
+    mImpl->vkCmdSetStencilOpEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 faceMask, failOp, passOp, depthFailOp, compareOp);
 }
 #endif
 #ifdef VK_EXT_host_image_copy
 void VkDecoderSnapshot::vkCopyMemoryToImageEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
     const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo) {
-    mImpl->vkCopyMemoryToImageEXT(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkCopyMemoryToImageEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, pCopyMemoryToImageInfo);
 }
 #endif
 #ifdef VK_EXT_host_image_copy
 void VkDecoderSnapshot::vkCopyImageToMemoryEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
     const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo) {
-    mImpl->vkCopyImageToMemoryEXT(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkCopyImageToMemoryEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, pCopyImageToMemoryInfo);
 }
 #endif
 #ifdef VK_EXT_host_image_copy
 void VkDecoderSnapshot::vkCopyImageToImageEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
     const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo) {
-    mImpl->vkCopyImageToImageEXT(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                 pCopyImageToImageInfo);
+    mImpl->vkCopyImageToImageEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                 device, pCopyImageToImageInfo);
 }
 #endif
 #ifdef VK_EXT_host_image_copy
 void VkDecoderSnapshot::vkTransitionImageLayoutEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, uint32_t transitionCount,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, uint32_t transitionCount,
     const VkHostImageLayoutTransitionInfoEXT* pTransitions) {
-    mImpl->vkTransitionImageLayoutEXT(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                      device, transitionCount, pTransitions);
+    mImpl->vkTransitionImageLayoutEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      input_result, device, transitionCount, pTransitions);
 }
 #endif
 #ifdef VK_EXT_host_image_copy
-void VkDecoderSnapshot::vkGetImageSubresourceLayout2EXT(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
-                                                        VkDevice device, VkImage image,
-                                                        const VkImageSubresource2KHR* pSubresource,
-                                                        VkSubresourceLayout2KHR* pLayout) {
-    mImpl->vkGetImageSubresourceLayout2EXT(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                           image, pSubresource, pLayout);
+void VkDecoderSnapshot::vkGetImageSubresourceLayout2EXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkImage image,
+    const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout) {
+    mImpl->vkGetImageSubresourceLayout2EXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                           device, image, pSubresource, pLayout);
 }
 #endif
 #ifdef VK_EXT_swapchain_maintenance1
 void VkDecoderSnapshot::vkReleaseSwapchainImagesEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo) {
-    mImpl->vkReleaseSwapchainImagesEXT(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                       device, pReleaseInfo);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo) {
+    mImpl->vkReleaseSwapchainImagesEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                       input_result, device, pReleaseInfo);
 }
 #endif
 #ifdef VK_EXT_private_data
 void VkDecoderSnapshot::vkCreatePrivateDataSlotEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot) {
-    mImpl->vkCreatePrivateDataSlotEXT(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
-                                      device, pCreateInfo, pAllocator, pPrivateDataSlot);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkPrivateDataSlot* pPrivateDataSlot) {
+    mImpl->vkCreatePrivateDataSlotEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      input_result, device, pCreateInfo, pAllocator,
+                                      pPrivateDataSlot);
 }
 #endif
 #ifdef VK_EXT_private_data
-void VkDecoderSnapshot::vkDestroyPrivateDataSlotEXT(const uint8_t* snapshotTraceBegin,
-                                                    size_t snapshotTraceBytes,
-                                                    android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkDestroyPrivateDataSlotEXT(android::base::BumpPool* pool,
+                                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                                    const uint8_t* apiCallPacket,
+                                                    size_t apiCallPacketSize, VkDevice device,
                                                     VkPrivateDataSlot privateDataSlot,
                                                     const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkDestroyPrivateDataSlotEXT(snapshotTraceBegin, snapshotTraceBytes, pool, device,
+    mImpl->vkDestroyPrivateDataSlotEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                        privateDataSlot, pAllocator);
 }
 #endif
 #ifdef VK_EXT_private_data
-void VkDecoderSnapshot::vkSetPrivateDataEXT(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkResult input_result,
-                                            VkDevice device, VkObjectType objectType,
-                                            uint64_t objectHandle,
+void VkDecoderSnapshot::vkSetPrivateDataEXT(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, VkDevice device,
+                                            VkObjectType objectType, uint64_t objectHandle,
                                             VkPrivateDataSlot privateDataSlot, uint64_t data) {
-    mImpl->vkSetPrivateDataEXT(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                               objectType, objectHandle, privateDataSlot, data);
+    mImpl->vkSetPrivateDataEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                               device, objectType, objectHandle, privateDataSlot, data);
 }
 #endif
 #ifdef VK_EXT_private_data
-void VkDecoderSnapshot::vkGetPrivateDataEXT(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
-                                            VkObjectType objectType, uint64_t objectHandle,
+void VkDecoderSnapshot::vkGetPrivateDataEXT(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device, VkObjectType objectType,
+                                            uint64_t objectHandle,
                                             VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
-    mImpl->vkGetPrivateDataEXT(snapshotTraceBegin, snapshotTraceBytes, pool, device, objectType,
-                               objectHandle, privateDataSlot, pData);
+    mImpl->vkGetPrivateDataEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
+                               objectType, objectHandle, privateDataSlot, pData);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state2
-void VkDecoderSnapshot::vkCmdSetPatchControlPointsEXT(const uint8_t* snapshotTraceBegin,
-                                                      size_t snapshotTraceBytes,
-                                                      android::base::BumpPool* pool,
-                                                      VkCommandBuffer commandBuffer,
-                                                      uint32_t patchControlPoints) {
-    mImpl->vkCmdSetPatchControlPointsEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkCmdSetPatchControlPointsEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t patchControlPoints) {
+    mImpl->vkCmdSetPatchControlPointsEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          commandBuffer, patchControlPoints);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state2
-void VkDecoderSnapshot::vkCmdSetRasterizerDiscardEnableEXT(const uint8_t* snapshotTraceBegin,
-                                                           size_t snapshotTraceBytes,
-                                                           android::base::BumpPool* pool,
-                                                           VkCommandBuffer commandBuffer,
-                                                           VkBool32 rasterizerDiscardEnable) {
-    mImpl->vkCmdSetRasterizerDiscardEnableEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkCmdSetRasterizerDiscardEnableEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
+    mImpl->vkCmdSetRasterizerDiscardEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               commandBuffer, rasterizerDiscardEnable);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state2
-void VkDecoderSnapshot::vkCmdSetDepthBiasEnableEXT(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool,
-                                                   VkCommandBuffer commandBuffer,
-                                                   VkBool32 depthBiasEnable) {
-    mImpl->vkCmdSetDepthBiasEnableEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                      depthBiasEnable);
+void VkDecoderSnapshot::vkCmdSetDepthBiasEnableEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
+    mImpl->vkCmdSetDepthBiasEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                      commandBuffer, depthBiasEnable);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state2
-void VkDecoderSnapshot::vkCmdSetLogicOpEXT(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkCmdSetLogicOpEXT(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
-    mImpl->vkCmdSetLogicOpEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer, logicOp);
+    mImpl->vkCmdSetLogicOpEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
+                              logicOp);
 }
 #endif
 #ifdef VK_EXT_extended_dynamic_state2
-void VkDecoderSnapshot::vkCmdSetPrimitiveRestartEnableEXT(const uint8_t* snapshotTraceBegin,
-                                                          size_t snapshotTraceBytes,
-                                                          android::base::BumpPool* pool,
-                                                          VkCommandBuffer commandBuffer,
-                                                          VkBool32 primitiveRestartEnable) {
-    mImpl->vkCmdSetPrimitiveRestartEnableEXT(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkCmdSetPrimitiveRestartEnableEXT(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
+    mImpl->vkCmdSetPrimitiveRestartEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              commandBuffer, primitiveRestartEnable);
 }
 #endif
 #ifdef VK_EXT_color_write_enable
 void VkDecoderSnapshot::vkCmdSetColorWriteEnableEXT(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32* pColorWriteEnables) {
-    mImpl->vkCmdSetColorWriteEnableEXT(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                       attachmentCount, pColorWriteEnables);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t attachmentCount,
+    const VkBool32* pColorWriteEnables) {
+    mImpl->vkCmdSetColorWriteEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                       commandBuffer, attachmentCount, pColorWriteEnables);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkMapMemoryIntoAddressSpaceGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkDeviceMemory memory, uint64_t* pAddress) {
-    mImpl->vkMapMemoryIntoAddressSpaceGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkDeviceMemory memory,
+    uint64_t* pAddress) {
+    mImpl->vkMapMemoryIntoAddressSpaceGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              input_result, device, memory, pAddress);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, VkDescriptorSet descriptorSet,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkDescriptorSet descriptorSet,
     VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
     uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
     const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
     const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
     const VkBufferView* pBufferViews) {
     mImpl->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-        snapshotTraceBegin, snapshotTraceBytes, pool, device, descriptorSet,
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, descriptorSet,
         descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount,
         pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos,
         pBufferInfos, pBufferViews);
@@ -7391,202 +7504,211 @@ void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkBeginCommandBufferAsyncGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo) {
-    mImpl->vkBeginCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+    const VkCommandBufferBeginInfo* pBeginInfo) {
+    mImpl->vkBeginCommandBufferAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            commandBuffer, pBeginInfo);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkEndCommandBufferAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                      size_t snapshotTraceBytes,
-                                                      android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkEndCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                                      const uint8_t* apiCallPacket,
+                                                      size_t apiCallPacketSize,
                                                       VkCommandBuffer commandBuffer) {
-    mImpl->vkEndCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkEndCommandBufferAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          commandBuffer);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkResetCommandBufferAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                        size_t snapshotTraceBytes,
-                                                        android::base::BumpPool* pool,
-                                                        VkCommandBuffer commandBuffer,
-                                                        VkCommandBufferResetFlags flags) {
-    mImpl->vkResetCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkResetCommandBufferAsyncGOOGLE(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) {
+    mImpl->vkResetCommandBufferAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            commandBuffer, flags);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkCommandBufferHostSyncGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, uint32_t needHostSync, uint32_t sequenceNumber) {
-    mImpl->vkCommandBufferHostSyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t needHostSync,
+    uint32_t sequenceNumber) {
+    mImpl->vkCommandBufferHostSyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          commandBuffer, needHostSync, sequenceNumber);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkCreateImageWithRequirementsGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkImageCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkImage* pImage,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage,
     VkMemoryRequirements* pMemoryRequirements) {
-    mImpl->vkCreateImageWithRequirementsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
+    mImpl->vkCreateImageWithRequirementsGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                input_result, device, pCreateInfo, pAllocator,
                                                pImage, pMemoryRequirements);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkCreateBufferWithRequirementsGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, const VkBufferCreateInfo* pCreateInfo,
-    const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer,
-    VkMemoryRequirements* pMemoryRequirements) {
-    mImpl->vkCreateBufferWithRequirementsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
+    VkBuffer* pBuffer, VkMemoryRequirements* pMemoryRequirements) {
+    mImpl->vkCreateBufferWithRequirementsGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                 input_result, device, pCreateInfo, pAllocator,
                                                 pBuffer, pMemoryRequirements);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkGetMemoryHostAddressInfoGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                         size_t snapshotTraceBytes,
-                                                         android::base::BumpPool* pool,
-                                                         VkResult input_result, VkDevice device,
-                                                         VkDeviceMemory memory, uint64_t* pAddress,
-                                                         uint64_t* pSize, uint64_t* pHostmemId) {
-    mImpl->vkGetMemoryHostAddressInfoGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
+void VkDecoderSnapshot::vkGetMemoryHostAddressInfoGOOGLE(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkDeviceMemory memory,
+    uint64_t* pAddress, uint64_t* pSize, uint64_t* pHostmemId) {
+    mImpl->vkGetMemoryHostAddressInfoGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             input_result, device, memory, pAddress, pSize,
                                             pHostmemId);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkFreeMemorySyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool, VkResult input_result,
+void VkDecoderSnapshot::vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* apiCallInfo,
+                                               const uint8_t* apiCallPacket,
+                                               size_t apiCallPacketSize, VkResult input_result,
                                                VkDevice device, VkDeviceMemory memory,
                                                const VkAllocationCallbacks* pAllocator) {
-    mImpl->vkFreeMemorySyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, input_result,
+    mImpl->vkFreeMemorySyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                   device, memory, pAllocator);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkQueueHostSyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkQueue queue,
+void VkDecoderSnapshot::vkQueueHostSyncGOOGLE(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkQueue queue,
                                               uint32_t needHostSync, uint32_t sequenceNumber) {
-    mImpl->vkQueueHostSyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, queue, needHostSync,
-                                 sequenceNumber);
+    mImpl->vkQueueHostSyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
+                                 needHostSync, sequenceNumber);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkQueueSubmitAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool, VkQueue queue,
+void VkDecoderSnapshot::vkQueueSubmitAsyncGOOGLE(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize, VkQueue queue,
                                                  uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                                  VkFence fence) {
-    mImpl->vkQueueSubmitAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, queue,
+    mImpl->vkQueueSubmitAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                     submitCount, pSubmits, fence);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkQueueWaitIdleAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool, VkQueue queue) {
-    mImpl->vkQueueWaitIdleAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, queue);
+void VkDecoderSnapshot::vkQueueWaitIdleAsyncGOOGLE(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* apiCallInfo,
+                                                   const uint8_t* apiCallPacket,
+                                                   size_t apiCallPacketSize, VkQueue queue) {
+    mImpl->vkQueueWaitIdleAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkQueueBindSparseAsyncGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence) {
-    mImpl->vkQueueBindSparseAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, queue,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkQueue queue, uint32_t bindInfoCount,
+    const VkBindSparseInfo* pBindInfo, VkFence fence) {
+    mImpl->vkQueueBindSparseAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                         bindInfoCount, pBindInfo, fence);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkGetLinearImageLayoutGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool, VkDevice device,
+void VkDecoderSnapshot::vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool,
+                                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                                     const uint8_t* apiCallPacket,
+                                                     size_t apiCallPacketSize, VkDevice device,
                                                      VkFormat format, VkDeviceSize* pOffset,
                                                      VkDeviceSize* pRowPitchAlignment) {
-    mImpl->vkGetLinearImageLayoutGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, device,
+    mImpl->vkGetLinearImageLayoutGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                         format, pOffset, pRowPitchAlignment);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkGetLinearImageLayout2GOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, const VkImageCreateInfo* pCreateInfo, VkDeviceSize* pOffset,
-    VkDeviceSize* pRowPitchAlignment) {
-    mImpl->vkGetLinearImageLayout2GOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                         pCreateInfo, pOffset, pRowPitchAlignment);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, const VkImageCreateInfo* pCreateInfo,
+    VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment) {
+    mImpl->vkGetLinearImageLayout2GOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                         device, pCreateInfo, pOffset, pRowPitchAlignment);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkQueueFlushCommandsGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                   size_t snapshotTraceBytes,
-                                                   android::base::BumpPool* pool, VkQueue queue,
+void VkDecoderSnapshot::vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool,
+                                                   VkSnapshotApiCallInfo* apiCallInfo,
+                                                   const uint8_t* apiCallPacket,
+                                                   size_t apiCallPacketSize, VkQueue queue,
                                                    VkCommandBuffer commandBuffer,
                                                    VkDeviceSize dataSize, const void* pData) {
-    mImpl->vkQueueFlushCommandsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, queue,
+    mImpl->vkQueueFlushCommandsGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                       commandBuffer, dataSize, pData);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkQueueCommitDescriptorSetUpdatesGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkQueue queue, uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
-    uint32_t descriptorSetCount, const VkDescriptorSetLayout* pSetLayouts,
-    const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
-    const uint32_t* pDescriptorSetPendingAllocation,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkQueue queue, uint32_t descriptorPoolCount,
+    const VkDescriptorPool* pDescriptorPools, uint32_t descriptorSetCount,
+    const VkDescriptorSetLayout* pSetLayouts, const uint64_t* pDescriptorSetPoolIds,
+    const uint32_t* pDescriptorSetWhichPool, const uint32_t* pDescriptorSetPendingAllocation,
     const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
     const VkWriteDescriptorSet* pPendingDescriptorWrites) {
     mImpl->vkQueueCommitDescriptorSetUpdatesGOOGLE(
-        snapshotTraceBegin, snapshotTraceBytes, pool, queue, descriptorPoolCount, pDescriptorPools,
-        descriptorSetCount, pSetLayouts, pDescriptorSetPoolIds, pDescriptorSetWhichPool,
-        pDescriptorSetPendingAllocation, pDescriptorWriteStartingIndices,
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue, descriptorPoolCount,
+        pDescriptorPools, descriptorSetCount, pSetLayouts, pDescriptorSetPoolIds,
+        pDescriptorSetWhichPool, pDescriptorSetPendingAllocation, pDescriptorWriteStartingIndices,
         pendingDescriptorWriteCount, pPendingDescriptorWrites);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkCollectDescriptorPoolIdsGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, VkDescriptorPool descriptorPool, uint32_t* pPoolIdCount, uint64_t* pPoolIds) {
-    mImpl->vkCollectDescriptorPoolIdsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, device,
-                                            descriptorPool, pPoolIdCount, pPoolIds);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkDescriptorPool descriptorPool,
+    uint32_t* pPoolIdCount, uint64_t* pPoolIds) {
+    mImpl->vkCollectDescriptorPoolIdsGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                            device, descriptorPool, pPoolIdCount, pPoolIds);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkQueue queue, uint32_t waitSemaphoreCount, const VkSemaphore* pWaitSemaphores, VkImage image) {
-    mImpl->vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                       queue, waitSemaphoreCount, pWaitSemaphores,
-                                                       image);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkQueue queue, uint32_t waitSemaphoreCount,
+    const VkSemaphore* pWaitSemaphores, VkImage image) {
+    mImpl->vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(pool, apiCallInfo, apiCallPacket,
+                                                       apiCallPacketSize, queue, waitSemaphoreCount,
+                                                       pWaitSemaphores, image);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkQueueFlushCommandsFromAuxMemoryGOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkQueue queue, VkCommandBuffer commandBuffer, VkDeviceMemory deviceMemory,
-    VkDeviceSize dataOffset, VkDeviceSize dataSize) {
-    mImpl->vkQueueFlushCommandsFromAuxMemoryGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                   queue, commandBuffer, deviceMemory, dataOffset,
-                                                   dataSize);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkQueue queue, VkCommandBuffer commandBuffer,
+    VkDeviceMemory deviceMemory, VkDeviceSize dataOffset, VkDeviceSize dataSize) {
+    mImpl->vkQueueFlushCommandsFromAuxMemoryGOOGLE(pool, apiCallInfo, apiCallPacket,
+                                                   apiCallPacketSize, queue, commandBuffer,
+                                                   deviceMemory, dataOffset, dataSize);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkGetBlobGOOGLE(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+void VkDecoderSnapshot::vkGetBlobGOOGLE(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         VkDeviceMemory memory) {
-    mImpl->vkGetBlobGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                           memory);
+    mImpl->vkGetBlobGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                           device, memory);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
 void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDevice device, VkDescriptorSet descriptorSet,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDevice device, VkDescriptorSet descriptorSet,
     VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
     uint32_t bufferInfoCount, uint32_t bufferViewCount, uint32_t inlineUniformBlockCount,
     const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
@@ -7594,41 +7716,43 @@ void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
     const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews,
     const uint8_t* pInlineUniformBlockData) {
     mImpl->vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-        snapshotTraceBegin, snapshotTraceBytes, pool, device, descriptorSet,
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, descriptorSet,
         descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount,
         inlineUniformBlockCount, pImageInfoEntryIndices, pBufferInfoEntryIndices,
         pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews, pInlineUniformBlockData);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkQueueSubmitAsync2GOOGLE(const uint8_t* snapshotTraceBegin,
-                                                  size_t snapshotTraceBytes,
-                                                  android::base::BumpPool* pool, VkQueue queue,
+void VkDecoderSnapshot::vkQueueSubmitAsync2GOOGLE(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* apiCallInfo,
+                                                  const uint8_t* apiCallPacket,
+                                                  size_t apiCallPacketSize, VkQueue queue,
                                                   uint32_t submitCount,
                                                   const VkSubmitInfo2* pSubmits, VkFence fence) {
-    mImpl->vkQueueSubmitAsync2GOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, queue,
+    mImpl->vkQueueSubmitAsync2GOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                      submitCount, pSubmits, fence);
 }
 #endif
 #ifdef VK_GOOGLE_gfxstream
-void VkDecoderSnapshot::vkGetSemaphoreGOOGLE(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkResult input_result,
-                                             VkDevice device, VkSemaphore semaphore,
-                                             uint64_t syncId) {
-    mImpl->vkGetSemaphoreGOOGLE(snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device,
-                                semaphore, syncId);
+void VkDecoderSnapshot::vkGetSemaphoreGOOGLE(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkResult input_result, VkDevice device,
+                                             VkSemaphore semaphore, uint64_t syncId) {
+    mImpl->vkGetSemaphoreGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
+                                device, semaphore, syncId);
 }
 #endif
 #ifdef VK_KHR_ray_tracing_pipeline
 void VkDecoderSnapshot::vkCmdTraceRaysKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+    const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
     const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
     const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
     const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width,
     uint32_t height, uint32_t depth) {
-    mImpl->vkCmdTraceRaysKHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
+    mImpl->vkCmdTraceRaysKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              pRaygenShaderBindingTable, pMissShaderBindingTable,
                              pHitShaderBindingTable, pCallableShaderBindingTable, width, height,
                              depth);
@@ -7636,57 +7760,59 @@ void VkDecoderSnapshot::vkCmdTraceRaysKHR(
 #endif
 #ifdef VK_KHR_ray_tracing_pipeline
 void VkDecoderSnapshot::vkCreateRayTracingPipelinesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkDeferredOperationKHR deferredOperation,
-    VkPipelineCache pipelineCache, uint32_t createInfoCount,
-    const VkRayTracingPipelineCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator,
-    VkPipeline* pPipelines) {
-    mImpl->vkCreateRayTracingPipelinesKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+    VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache,
+    uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
+    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
+    mImpl->vkCreateRayTracingPipelinesKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           input_result, device, deferredOperation, pipelineCache,
                                           createInfoCount, pCreateInfos, pAllocator, pPipelines);
 }
 #endif
 #ifdef VK_KHR_ray_tracing_pipeline
 void VkDecoderSnapshot::vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkResult input_result, VkDevice device, VkPipeline pipeline, uint32_t firstGroup,
-    uint32_t groupCount, size_t dataSize, void* pData) {
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkPipeline pipeline,
+    uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) {
     mImpl->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
-        snapshotTraceBegin, snapshotTraceBytes, pool, input_result, device, pipeline, firstGroup,
-        groupCount, dataSize, pData);
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device, pipeline,
+        firstGroup, groupCount, dataSize, pData);
 }
 #endif
 #ifdef VK_KHR_ray_tracing_pipeline
 void VkDecoderSnapshot::vkCmdTraceRaysIndirectKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+    const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
     const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
     const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
     const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
     VkDeviceAddress indirectDeviceAddress) {
-    mImpl->vkCmdTraceRaysIndirectKHR(snapshotTraceBegin, snapshotTraceBytes, pool, commandBuffer,
-                                     pRaygenShaderBindingTable, pMissShaderBindingTable,
-                                     pHitShaderBindingTable, pCallableShaderBindingTable,
-                                     indirectDeviceAddress);
+    mImpl->vkCmdTraceRaysIndirectKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
+                                     commandBuffer, pRaygenShaderBindingTable,
+                                     pMissShaderBindingTable, pHitShaderBindingTable,
+                                     pCallableShaderBindingTable, indirectDeviceAddress);
 }
 #endif
 #ifdef VK_KHR_ray_tracing_pipeline
 void VkDecoderSnapshot::vkGetRayTracingShaderGroupStackSizeKHR(
-    const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-    VkDeviceSize input_result, VkDevice device, VkPipeline pipeline, uint32_t group,
-    VkShaderGroupShaderKHR groupShader) {
-    mImpl->vkGetRayTracingShaderGroupStackSizeKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                  input_result, device, pipeline, group,
-                                                  groupShader);
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkDeviceSize input_result, VkDevice device, VkPipeline pipeline,
+    uint32_t group, VkShaderGroupShaderKHR groupShader) {
+    mImpl->vkGetRayTracingShaderGroupStackSizeKHR(pool, apiCallInfo, apiCallPacket,
+                                                  apiCallPacketSize, input_result, device, pipeline,
+                                                  group, groupShader);
 }
 #endif
 #ifdef VK_KHR_ray_tracing_pipeline
-void VkDecoderSnapshot::vkCmdSetRayTracingPipelineStackSizeKHR(const uint8_t* snapshotTraceBegin,
-                                                               size_t snapshotTraceBytes,
-                                                               android::base::BumpPool* pool,
-                                                               VkCommandBuffer commandBuffer,
-                                                               uint32_t pipelineStackSize) {
-    mImpl->vkCmdSetRayTracingPipelineStackSizeKHR(snapshotTraceBegin, snapshotTraceBytes, pool,
-                                                  commandBuffer, pipelineStackSize);
+void VkDecoderSnapshot::vkCmdSetRayTracingPipelineStackSizeKHR(
+    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) {
+    mImpl->vkCmdSetRayTracingPipelineStackSizeKHR(
+        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer, pipelineStackSize);
 }
 #endif
+
+}  // namespace vk
+}  // namespace gfxstream
diff --git a/host/vulkan/VkDecoderSnapshot.h b/host/vulkan/VkDecoderSnapshot.h
index 2018b1093..78dd99254 100644
--- a/host/vulkan/VkDecoderSnapshot.h
+++ b/host/vulkan/VkDecoderSnapshot.h
@@ -35,6 +35,7 @@
 
 #include <memory>
 
+#include "VkSnapshotApiCall.h"
 #include "aemu/base/HealthMonitor.h"
 #include "goldfish_vk_private_defs.h"
 #include "utils/GfxApiLogger.h"
@@ -48,1578 +49,1857 @@ class Stream;
 }  // namespace base
 }  // namespace android
 
+namespace gfxstream {
+namespace vk {
+
 class VkDecoderSnapshot {
    public:
     VkDecoderSnapshot();
     ~VkDecoderSnapshot();
 
-    void save(android::base::Stream* stream);
-    void load(android::base::Stream* stream, emugl::GfxApiLogger& gfx_logger,
-              emugl::HealthMonitor<>* healthMonitor);
-    void createExtraHandlesForNextApi(const uint64_t* created, uint32_t count);
+    void clear();
+
+    void saveReplayBuffers(android::base::Stream* stream);
+    static void loadReplayBuffers(android::base::Stream* stream,
+                                  std::vector<uint64_t>* outHandleBuffer,
+                                  std::vector<uint8_t>* outDecoderBuffer);
+
+    VkSnapshotApiCallInfo* createApiCallInfo();
+    void destroyApiCallInfoIfUnused(VkSnapshotApiCallInfo* info);
 #ifdef VK_VERSION_1_0
-    void vkCreateInstance(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result,
-                          const VkInstanceCreateInfo* pCreateInfo,
+    void vkCreateInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, const VkInstanceCreateInfo* pCreateInfo,
                           const VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
-    void vkDestroyInstance(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkInstance instance,
-                           const VkAllocationCallbacks* pAllocator);
-    void vkEnumeratePhysicalDevices(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    VkInstance instance, uint32_t* pPhysicalDeviceCount,
+    void vkDestroyInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkInstance instance, const VkAllocationCallbacks* pAllocator);
+    void vkEnumeratePhysicalDevices(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, VkInstance instance,
+                                    uint32_t* pPhysicalDeviceCount,
                                     VkPhysicalDevice* pPhysicalDevices);
-    void vkGetPhysicalDeviceFeatures(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkPhysicalDevice physicalDevice,
+    void vkGetPhysicalDeviceFeatures(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkPhysicalDevice physicalDevice,
                                      VkPhysicalDeviceFeatures* pFeatures);
-    void vkGetPhysicalDeviceFormatProperties(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFormatProperties(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkPhysicalDevice physicalDevice, VkFormat format,
                                              VkFormatProperties* pFormatProperties);
-    void vkGetPhysicalDeviceImageFormatProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
-        VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags,
-        VkImageFormatProperties* pImageFormatProperties);
-    void vkGetPhysicalDeviceProperties(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceImageFormatProperties(android::base::BumpPool* pool,
+                                                  VkSnapshotApiCallInfo* apiCallInfo,
+                                                  const uint8_t* apiCallPacket,
+                                                  size_t apiCallPacketSize, VkResult input_result,
+                                                  VkPhysicalDevice physicalDevice, VkFormat format,
+                                                  VkImageType type, VkImageTiling tiling,
+                                                  VkImageUsageFlags usage, VkImageCreateFlags flags,
+                                                  VkImageFormatProperties* pImageFormatProperties);
+    void vkGetPhysicalDeviceProperties(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkPhysicalDevice physicalDevice,
                                        VkPhysicalDeviceProperties* pProperties);
-    void vkGetPhysicalDeviceQueueFamilyProperties(const uint8_t* snapshotTraceBegin,
-                                                  size_t snapshotTraceBytes,
-                                                  android::base::BumpPool* pool,
-                                                  VkPhysicalDevice physicalDevice,
-                                                  uint32_t* pQueueFamilyPropertyCount,
-                                                  VkQueueFamilyProperties* pQueueFamilyProperties);
-    void vkGetPhysicalDeviceMemoryProperties(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceQueueFamilyProperties(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
+    void vkGetPhysicalDeviceMemoryProperties(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                              VkPhysicalDevice physicalDevice,
                                              VkPhysicalDeviceMemoryProperties* pMemoryProperties);
-    void vkGetInstanceProcAddr(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, PFN_vkVoidFunction input_result,
-                               VkInstance instance, const char* pName);
-    void vkGetDeviceProcAddr(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, PFN_vkVoidFunction input_result,
-                             VkDevice device, const char* pName);
-    void vkCreateDevice(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkResult input_result,
-                        VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo,
+    void vkGetInstanceProcAddr(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               PFN_vkVoidFunction input_result, VkInstance instance,
+                               const char* pName);
+    void vkGetDeviceProcAddr(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             PFN_vkVoidFunction input_result, VkDevice device, const char* pName);
+    void vkCreateDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkResult input_result, VkPhysicalDevice physicalDevice,
+                        const VkDeviceCreateInfo* pCreateInfo,
                         const VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
-    void vkDestroyDevice(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkDevice device,
+    void vkDestroyDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                          const VkAllocationCallbacks* pAllocator);
-    void vkEnumerateInstanceExtensionProperties(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
-                                                VkResult input_result, const char* pLayerName,
-                                                uint32_t* pPropertyCount,
+    void vkEnumerateInstanceExtensionProperties(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize, VkResult input_result,
+                                                const char* pLayerName, uint32_t* pPropertyCount,
                                                 VkExtensionProperties* pProperties);
-    void vkEnumerateDeviceExtensionProperties(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
+    void vkEnumerateDeviceExtensionProperties(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkResult input_result,
                                               VkPhysicalDevice physicalDevice,
                                               const char* pLayerName, uint32_t* pPropertyCount,
                                               VkExtensionProperties* pProperties);
-    void vkEnumerateInstanceLayerProperties(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkResult input_result,
-                                            uint32_t* pPropertyCount,
+    void vkEnumerateInstanceLayerProperties(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, uint32_t* pPropertyCount,
                                             VkLayerProperties* pProperties);
-    void vkEnumerateDeviceLayerProperties(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkEnumerateDeviceLayerProperties(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkPhysicalDevice physicalDevice,
                                           uint32_t* pPropertyCount, VkLayerProperties* pProperties);
-    void vkGetDeviceQueue(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkDevice device, uint32_t queueFamilyIndex,
-                          uint32_t queueIndex, VkQueue* pQueue);
-    void vkQueueSubmit(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
-                       uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence);
-    void vkQueueWaitIdle(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkQueue queue);
-    void vkDeviceWaitIdle(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device);
-    void vkAllocateMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkGetDeviceQueue(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                          uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
+    void vkQueueSubmit(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkQueue queue, uint32_t submitCount,
+                       const VkSubmitInfo* pSubmits, VkFence fence);
+    void vkQueueWaitIdle(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkQueue queue);
+    void vkDeviceWaitIdle(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device);
+    void vkAllocateMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device,
                           const VkMemoryAllocateInfo* pAllocateInfo,
                           const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
-    void vkFreeMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                      android::base::BumpPool* pool, VkDevice device, VkDeviceMemory memory,
-                      const VkAllocationCallbacks* pAllocator);
-    void vkMapMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                     android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                     VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size,
+    void vkFreeMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                      const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                      VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator);
+    void vkMapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                     const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+                     VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size,
                      VkMemoryMapFlags flags, void** ppData);
-    void vkUnmapMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkDevice device, VkDeviceMemory memory);
-    void vkFlushMappedMemoryRanges(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkResult input_result,
-                                   VkDevice device, uint32_t memoryRangeCount,
+    void vkUnmapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                       VkDeviceMemory memory);
+    void vkFlushMappedMemoryRanges(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+                                   uint32_t memoryRangeCount,
                                    const VkMappedMemoryRange* pMemoryRanges);
-    void vkInvalidateMappedMemoryRanges(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkInvalidateMappedMemoryRanges(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         uint32_t memoryRangeCount,
                                         const VkMappedMemoryRange* pMemoryRanges);
-    void vkGetDeviceMemoryCommitment(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkDevice device,
-                                     VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
-    void vkBindBufferMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                            VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
-    void vkBindImageMemory(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                           VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
-    void vkGetBufferMemoryRequirements(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkDevice device,
-                                       VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
-    void vkGetImageMemoryRequirements(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkDevice device, VkImage image,
+    void vkGetDeviceMemoryCommitment(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkDevice device, VkDeviceMemory memory,
+                                     VkDeviceSize* pCommittedMemoryInBytes);
+    void vkBindBufferMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device, VkBuffer buffer,
+                            VkDeviceMemory memory, VkDeviceSize memoryOffset);
+    void vkBindImageMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device, VkImage image,
+                           VkDeviceMemory memory, VkDeviceSize memoryOffset);
+    void vkGetBufferMemoryRequirements(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkDevice device, VkBuffer buffer,
+                                       VkMemoryRequirements* pMemoryRequirements);
+    void vkGetImageMemoryRequirements(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkDevice device, VkImage image,
                                       VkMemoryRequirements* pMemoryRequirements);
     void vkGetImageSparseMemoryRequirements(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device, VkImage image,
+        uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
     void vkGetPhysicalDeviceSparseImageFormatProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
-        VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling,
-        uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
-    void vkQueueBindSparse(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
-                           uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
-                           VkFence fence);
-    void vkCreateFence(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                       const VkFenceCreateInfo* pCreateInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage,
+        VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
+    void vkQueueBindSparse(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkQueue queue, uint32_t bindInfoCount,
+                           const VkBindSparseInfo* pBindInfo, VkFence fence);
+    void vkCreateFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkDevice device, const VkFenceCreateInfo* pCreateInfo,
                        const VkAllocationCallbacks* pAllocator, VkFence* pFence);
-    void vkDestroyFence(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkDevice device, VkFence fence,
-                        const VkAllocationCallbacks* pAllocator);
-    void vkResetFences(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                       uint32_t fenceCount, const VkFence* pFences);
-    void vkGetFenceStatus(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                          VkFence fence);
-    void vkWaitForFences(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                         uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll,
-                         uint64_t timeout);
-    void vkCreateSemaphore(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkDestroyFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                        VkFence fence, const VkAllocationCallbacks* pAllocator);
+    void vkResetFences(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkDevice device, uint32_t fenceCount,
+                       const VkFence* pFences);
+    void vkGetFenceStatus(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device, VkFence fence);
+    void vkWaitForFences(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkDevice device, uint32_t fenceCount,
+                         const VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
+    void vkCreateSemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device,
                            const VkSemaphoreCreateInfo* pCreateInfo,
                            const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
-    void vkDestroySemaphore(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkDevice device, VkSemaphore semaphore,
-                            const VkAllocationCallbacks* pAllocator);
-    void vkCreateEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                       const VkEventCreateInfo* pCreateInfo,
+    void vkDestroySemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                            VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator);
+    void vkCreateEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkDevice device, const VkEventCreateInfo* pCreateInfo,
                        const VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
-    void vkDestroyEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkDevice device, VkEvent event,
-                        const VkAllocationCallbacks* pAllocator);
-    void vkGetEventStatus(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                          VkEvent event);
-    void vkSetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                    android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                    VkEvent event);
-    void vkResetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                      android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                      VkEvent event);
-    void vkCreateQueryPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkDestroyEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                        VkEvent event, const VkAllocationCallbacks* pAllocator);
+    void vkGetEventStatus(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device, VkEvent event);
+    void vkSetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                    const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+                    VkDevice device, VkEvent event);
+    void vkResetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                      const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+                      VkDevice device, VkEvent event);
+    void vkCreateQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device,
                            const VkQueryPoolCreateInfo* pCreateInfo,
                            const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool);
-    void vkDestroyQueryPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkDevice device, VkQueryPool queryPool,
-                            const VkAllocationCallbacks* pAllocator);
-    void vkGetQueryPoolResults(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkQueryPool queryPool, uint32_t firstQuery,
-                               uint32_t queryCount, size_t dataSize, void* pData,
-                               VkDeviceSize stride, VkQueryResultFlags flags);
-    void vkCreateBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkDestroyQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                            VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator);
+    void vkGetQueryPoolResults(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, VkQueryPool queryPool,
+                               uint32_t firstQuery, uint32_t queryCount, size_t dataSize,
+                               void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
+    void vkCreateBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkResult input_result, VkDevice device,
                         const VkBufferCreateInfo* pCreateInfo,
                         const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
-    void vkDestroyBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkDevice device, VkBuffer buffer,
-                         const VkAllocationCallbacks* pAllocator);
-    void vkCreateBufferView(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkDestroyBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                         VkBuffer buffer, const VkAllocationCallbacks* pAllocator);
+    void vkCreateBufferView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device,
                             const VkBufferViewCreateInfo* pCreateInfo,
                             const VkAllocationCallbacks* pAllocator, VkBufferView* pView);
-    void vkDestroyBufferView(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkDevice device,
-                             VkBufferView bufferView, const VkAllocationCallbacks* pAllocator);
-    void vkCreateImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                       const VkImageCreateInfo* pCreateInfo,
+    void vkDestroyBufferView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkDevice device, VkBufferView bufferView,
+                             const VkAllocationCallbacks* pAllocator);
+    void vkCreateImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkResult input_result, VkDevice device, const VkImageCreateInfo* pCreateInfo,
                        const VkAllocationCallbacks* pAllocator, VkImage* pImage);
-    void vkDestroyImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkDevice device, VkImage image,
-                        const VkAllocationCallbacks* pAllocator);
-    void vkGetImageSubresourceLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkDevice device, VkImage image,
+    void vkDestroyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                        VkImage image, const VkAllocationCallbacks* pAllocator);
+    void vkGetImageSubresourceLayout(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkDevice device, VkImage image,
                                      const VkImageSubresource* pSubresource,
                                      VkSubresourceLayout* pLayout);
-    void vkCreateImageView(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateImageView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device,
                            const VkImageViewCreateInfo* pCreateInfo,
                            const VkAllocationCallbacks* pAllocator, VkImageView* pView);
-    void vkDestroyImageView(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkDevice device, VkImageView imageView,
-                            const VkAllocationCallbacks* pAllocator);
-    void vkCreateShaderModule(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkDestroyImageView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                            VkImageView imageView, const VkAllocationCallbacks* pAllocator);
+    void vkCreateShaderModule(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkDevice device,
                               const VkShaderModuleCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator,
                               VkShaderModule* pShaderModule);
-    void vkDestroyShaderModule(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkDevice device,
-                               VkShaderModule shaderModule,
+    void vkDestroyShaderModule(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkDevice device, VkShaderModule shaderModule,
                                const VkAllocationCallbacks* pAllocator);
-    void vkCreatePipelineCache(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo,
+    void vkCreatePipelineCache(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device,
+                               const VkPipelineCacheCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator,
                                VkPipelineCache* pPipelineCache);
-    void vkDestroyPipelineCache(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkDevice device,
-                                VkPipelineCache pipelineCache,
+    void vkDestroyPipelineCache(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkDevice device, VkPipelineCache pipelineCache,
                                 const VkAllocationCallbacks* pAllocator);
-    void vkGetPipelineCacheData(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize,
-                                void* pData);
-    void vkMergePipelineCaches(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount,
-                               const VkPipelineCache* pSrcCaches);
-    void vkCreateGraphicsPipelines(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkResult input_result,
-                                   VkDevice device, VkPipelineCache pipelineCache,
-                                   uint32_t createInfoCount,
+    void vkGetPipelineCacheData(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
+    void vkMergePipelineCaches(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, VkPipelineCache dstCache,
+                               uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches);
+    void vkCreateGraphicsPipelines(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkResult input_result, VkDevice device,
+                                   VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                    const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
-    void vkCreateComputePipelines(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkResult input_result,
-                                  VkDevice device, VkPipelineCache pipelineCache,
-                                  uint32_t createInfoCount,
+    void vkCreateComputePipelines(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkResult input_result, VkDevice device,
+                                  VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                   const VkComputePipelineCreateInfo* pCreateInfos,
                                   const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
-    void vkDestroyPipeline(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkDevice device, VkPipeline pipeline,
-                           const VkAllocationCallbacks* pAllocator);
-    void vkCreatePipelineLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo,
+    void vkDestroyPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                           VkPipeline pipeline, const VkAllocationCallbacks* pAllocator);
+    void vkCreatePipelineLayout(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                const VkPipelineLayoutCreateInfo* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator,
                                 VkPipelineLayout* pPipelineLayout);
-    void vkDestroyPipelineLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkDevice device,
-                                 VkPipelineLayout pipelineLayout,
+    void vkDestroyPipelineLayout(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkDevice device, VkPipelineLayout pipelineLayout,
                                  const VkAllocationCallbacks* pAllocator);
-    void vkCreateSampler(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateSampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkDevice device,
                          const VkSamplerCreateInfo* pCreateInfo,
                          const VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
-    void vkDestroySampler(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkDevice device, VkSampler sampler,
-                          const VkAllocationCallbacks* pAllocator);
-    void vkCreateDescriptorSetLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkResult input_result,
-                                     VkDevice device,
+    void vkDestroySampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                          VkSampler sampler, const VkAllocationCallbacks* pAllocator);
+    void vkCreateDescriptorSetLayout(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkResult input_result, VkDevice device,
                                      const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator,
                                      VkDescriptorSetLayout* pSetLayout);
-    void vkDestroyDescriptorSetLayout(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkDevice device,
-                                      VkDescriptorSetLayout descriptorSetLayout,
+    void vkDestroyDescriptorSetLayout(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkDevice device, VkDescriptorSetLayout descriptorSetLayout,
                                       const VkAllocationCallbacks* pAllocator);
-    void vkCreateDescriptorPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo,
+    void vkCreateDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                const VkDescriptorPoolCreateInfo* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator,
                                 VkDescriptorPool* pDescriptorPool);
-    void vkDestroyDescriptorPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkDevice device,
-                                 VkDescriptorPool descriptorPool,
+    void vkDestroyDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkDevice device, VkDescriptorPool descriptorPool,
                                  const VkAllocationCallbacks* pAllocator);
-    void vkResetDescriptorPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkDescriptorPool descriptorPool,
-                               VkDescriptorPoolResetFlags flags);
-    void vkAllocateDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkResult input_result,
-                                  VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo,
+    void vkResetDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device,
+                               VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
+    void vkAllocateDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkResult input_result, VkDevice device,
+                                  const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                   VkDescriptorSet* pDescriptorSets);
-    void vkFreeDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkFreeDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkDevice device,
                               VkDescriptorPool descriptorPool, uint32_t descriptorSetCount,
                               const VkDescriptorSet* pDescriptorSets);
-    void vkUpdateDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkDevice device,
-                                uint32_t descriptorWriteCount,
+    void vkUpdateDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkDevice device, uint32_t descriptorWriteCount,
                                 const VkWriteDescriptorSet* pDescriptorWrites,
                                 uint32_t descriptorCopyCount,
                                 const VkCopyDescriptorSet* pDescriptorCopies);
-    void vkCreateFramebuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateFramebuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device,
                              const VkFramebufferCreateInfo* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
-    void vkDestroyFramebuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkDevice device,
-                              VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator);
-    void vkCreateRenderPass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkDestroyFramebuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkDevice device, VkFramebuffer framebuffer,
+                              const VkAllocationCallbacks* pAllocator);
+    void vkCreateRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device,
                             const VkRenderPassCreateInfo* pCreateInfo,
                             const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
-    void vkDestroyRenderPass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkDevice device,
-                             VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator);
-    void vkGetRenderAreaGranularity(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkDevice device,
-                                    VkRenderPass renderPass, VkExtent2D* pGranularity);
-    void vkCreateCommandPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkDestroyRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkDevice device, VkRenderPass renderPass,
+                             const VkAllocationCallbacks* pAllocator);
+    void vkGetRenderAreaGranularity(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkDevice device, VkRenderPass renderPass,
+                                    VkExtent2D* pGranularity);
+    void vkCreateCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device,
                              const VkCommandPoolCreateInfo* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool);
-    void vkDestroyCommandPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkDevice device,
-                              VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator);
-    void vkResetCommandPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                            VkCommandPool commandPool, VkCommandPoolResetFlags flags);
-    void vkAllocateCommandBuffers(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkResult input_result,
-                                  VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo,
+    void vkDestroyCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkDevice device, VkCommandPool commandPool,
+                              const VkAllocationCallbacks* pAllocator);
+    void vkResetCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device, VkCommandPool commandPool,
+                            VkCommandPoolResetFlags flags);
+    void vkAllocateCommandBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkResult input_result, VkDevice device,
+                                  const VkCommandBufferAllocateInfo* pAllocateInfo,
                                   VkCommandBuffer* pCommandBuffers);
-    void vkFreeCommandBuffers(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkDevice device,
-                              VkCommandPool commandPool, uint32_t commandBufferCount,
-                              const VkCommandBuffer* pCommandBuffers);
-    void vkBeginCommandBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result,
-                              VkCommandBuffer commandBuffer,
+    void vkFreeCommandBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkDevice device, VkCommandPool commandPool,
+                              uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);
+    void vkBeginCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkCommandBuffer commandBuffer,
                               const VkCommandBufferBeginInfo* pBeginInfo);
-    void vkEndCommandBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result,
-                            VkCommandBuffer commandBuffer);
-    void vkResetCommandBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result,
-                              VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
-    void vkCmdBindPipeline(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
-    void vkCmdSetViewport(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          uint32_t firstViewport, uint32_t viewportCount,
-                          const VkViewport* pViewports);
-    void vkCmdSetScissor(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors);
-    void vkCmdSetLineWidth(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           float lineWidth);
-    void vkCmdSetDepthBias(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           float depthBiasConstantFactor, float depthBiasClamp,
-                           float depthBiasSlopeFactor);
-    void vkCmdSetBlendConstants(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                const float blendConstants[4]);
-    void vkCmdSetDepthBounds(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             float minDepthBounds, float maxDepthBounds);
-    void vkCmdSetStencilCompareMask(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    VkStencilFaceFlags faceMask, uint32_t compareMask);
-    void vkCmdSetStencilWriteMask(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkStencilFaceFlags faceMask, uint32_t writeMask);
-    void vkCmdSetStencilReference(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkStencilFaceFlags faceMask, uint32_t reference);
-    void vkCmdBindDescriptorSets(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkEndCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkCommandBuffer commandBuffer);
+    void vkResetCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkCommandBuffer commandBuffer,
+                              VkCommandBufferResetFlags flags);
+    void vkCmdBindPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
+                           VkPipeline pipeline);
+    void vkCmdSetViewport(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, uint32_t firstViewport,
+                          uint32_t viewportCount, const VkViewport* pViewports);
+    void vkCmdSetScissor(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, uint32_t firstScissor,
+                         uint32_t scissorCount, const VkRect2D* pScissors);
+    void vkCmdSetLineWidth(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, float lineWidth);
+    void vkCmdSetDepthBias(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, float depthBiasConstantFactor,
+                           float depthBiasClamp, float depthBiasSlopeFactor);
+    void vkCmdSetBlendConstants(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, const float blendConstants[4]);
+    void vkCmdSetDepthBounds(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, float minDepthBounds,
+                             float maxDepthBounds);
+    void vkCmdSetStencilCompareMask(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                                    uint32_t compareMask);
+    void vkCmdSetStencilWriteMask(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                                  uint32_t writeMask);
+    void vkCmdSetStencilReference(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                                  uint32_t reference);
+    void vkCmdBindDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer,
                                  VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
                                  uint32_t firstSet, uint32_t descriptorSetCount,
                                  const VkDescriptorSet* pDescriptorSets,
                                  uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets);
-    void vkCmdBindIndexBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
-    void vkCmdBindVertexBuffers(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                uint32_t firstBinding, uint32_t bindingCount,
-                                const VkBuffer* pBuffers, const VkDeviceSize* pOffsets);
-    void vkCmdDraw(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                   uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex,
-                   uint32_t firstInstance);
-    void vkCmdDrawIndexed(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex,
-                          int32_t vertexOffset, uint32_t firstInstance);
-    void vkCmdDrawIndirect(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount,
-                           uint32_t stride);
-    void vkCmdDrawIndexedIndirect(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount,
-                                  uint32_t stride);
-    void vkCmdDispatch(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                       uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
-    void vkCmdDispatchIndirect(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                               VkBuffer buffer, VkDeviceSize offset);
-    void vkCmdCopyBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount,
-                         const VkBufferCopy* pRegions);
-    void vkCmdCopyImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                        VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage,
+    void vkCmdBindIndexBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+                              VkIndexType indexType);
+    void vkCmdBindVertexBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, uint32_t firstBinding,
+                                uint32_t bindingCount, const VkBuffer* pBuffers,
+                                const VkDeviceSize* pOffsets);
+    void vkCmdDraw(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                   const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                   VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount,
+                   uint32_t firstVertex, uint32_t firstInstance);
+    void vkCmdDrawIndexed(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, uint32_t indexCount,
+                          uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset,
+                          uint32_t firstInstance);
+    void vkCmdDrawIndirect(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+                           uint32_t drawCount, uint32_t stride);
+    void vkCmdDrawIndexedIndirect(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkBuffer buffer,
+                                  VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
+    void vkCmdDispatch(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
+                       uint32_t groupCountZ);
+    void vkCmdDispatchIndirect(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
+    void vkCmdCopyBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer,
+                         uint32_t regionCount, const VkBufferCopy* pRegions);
+    void vkCmdCopyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkCommandBuffer commandBuffer, VkImage srcImage,
+                        VkImageLayout srcImageLayout, VkImage dstImage,
                         VkImageLayout dstImageLayout, uint32_t regionCount,
                         const VkImageCopy* pRegions);
-    void vkCmdBlitImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                        VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage,
+    void vkCmdBlitImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkCommandBuffer commandBuffer, VkImage srcImage,
+                        VkImageLayout srcImageLayout, VkImage dstImage,
                         VkImageLayout dstImageLayout, uint32_t regionCount,
                         const VkImageBlit* pRegions, VkFilter filter);
-    void vkCmdCopyBufferToImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout,
+    void vkCmdCopyBufferToImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
+                                VkImageLayout dstImageLayout, uint32_t regionCount,
+                                const VkBufferImageCopy* pRegions);
+    void vkCmdCopyImageToBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, VkImage srcImage,
+                                VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                 uint32_t regionCount, const VkBufferImageCopy* pRegions);
-    void vkCmdCopyImageToBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer,
-                                uint32_t regionCount, const VkBufferImageCopy* pRegions);
-    void vkCmdUpdateBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize,
-                           const void* pData);
-    void vkCmdFillBuffer(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size,
-                         uint32_t data);
-    void vkCmdClearColorImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkImage image, VkImageLayout imageLayout,
-                              const VkClearColorValue* pColor, uint32_t rangeCount,
-                              const VkImageSubresourceRange* pRanges);
-    void vkCmdClearDepthStencilImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                     VkImage image, VkImageLayout imageLayout,
+    void vkCmdUpdateBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
+                           VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData);
+    void vkCmdFillBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset,
+                         VkDeviceSize size, uint32_t data);
+    void vkCmdClearColorImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkImage image,
+                              VkImageLayout imageLayout, const VkClearColorValue* pColor,
+                              uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
+    void vkCmdClearDepthStencilImage(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkCommandBuffer commandBuffer, VkImage image,
+                                     VkImageLayout imageLayout,
                                      const VkClearDepthStencilValue* pDepthStencil,
                                      uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
-    void vkCmdClearAttachments(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                               uint32_t attachmentCount, const VkClearAttachment* pAttachments,
-                               uint32_t rectCount, const VkClearRect* pRects);
-    void vkCmdResolveImage(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage,
+    void vkCmdClearAttachments(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer, uint32_t attachmentCount,
+                               const VkClearAttachment* pAttachments, uint32_t rectCount,
+                               const VkClearRect* pRects);
+    void vkCmdResolveImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkImage srcImage,
+                           VkImageLayout srcImageLayout, VkImage dstImage,
                            VkImageLayout dstImageLayout, uint32_t regionCount,
                            const VkImageResolve* pRegions);
-    void vkCmdSetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer, VkEvent event,
+    void vkCmdSetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkCommandBuffer commandBuffer, VkEvent event,
                        VkPipelineStageFlags stageMask);
-    void vkCmdResetEvent(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         VkEvent event, VkPipelineStageFlags stageMask);
-    void vkCmdWaitEvents(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         uint32_t eventCount, const VkEvent* pEvents,
+    void vkCmdResetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, VkEvent event,
+                         VkPipelineStageFlags stageMask);
+    void vkCmdWaitEvents(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents,
                          VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
                          uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
                          uint32_t bufferMemoryBarrierCount,
                          const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                          uint32_t imageMemoryBarrierCount,
                          const VkImageMemoryBarrier* pImageMemoryBarriers);
-    void vkCmdPipelineBarrier(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
-                              VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount,
-                              const VkMemoryBarrier* pMemoryBarriers,
+    void vkCmdPipelineBarrier(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
+                              VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
+                              uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
                               uint32_t bufferMemoryBarrierCount,
                               const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                               uint32_t imageMemoryBarrierCount,
                               const VkImageMemoryBarrier* pImageMemoryBarriers);
-    void vkCmdBeginQuery(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
-    void vkCmdEndQuery(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                       VkQueryPool queryPool, uint32_t query);
-    void vkCmdResetQueryPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
-    void vkCmdWriteTimestamp(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool,
-                             uint32_t query);
-    void vkCmdCopyQueryPoolResults(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginQuery(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
+                         VkQueryControlFlags flags);
+    void vkCmdEndQuery(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                       VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
+    void vkCmdResetQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, VkQueryPool queryPool,
+                             uint32_t firstQuery, uint32_t queryCount);
+    void vkCmdWriteTimestamp(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage,
+                             VkQueryPool queryPool, uint32_t query);
+    void vkCmdCopyQueryPoolResults(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount,
                                    VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride,
                                    VkQueryResultFlags flags);
-    void vkCmdPushConstants(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset,
-                            uint32_t size, const void* pValues);
-    void vkCmdBeginRenderPass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdPushConstants(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, VkPipelineLayout layout,
+                            VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size,
+                            const void* pValues);
+    void vkCmdBeginRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer,
                               const VkRenderPassBeginInfo* pRenderPassBegin,
                               VkSubpassContents contents);
-    void vkCmdNextSubpass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          VkSubpassContents contents);
-    void vkCmdEndRenderPass(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer);
-    void vkCmdExecuteCommands(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);
+    void vkCmdNextSubpass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, VkSubpassContents contents);
+    void vkCmdEndRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer);
+    void vkCmdExecuteCommands(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
+                              const VkCommandBuffer* pCommandBuffers);
 #endif
 #ifdef VK_VERSION_1_1
-    void vkEnumerateInstanceVersion(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    uint32_t* pApiVersion);
-    void vkBindBufferMemory2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                             uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos);
-    void vkBindImageMemory2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                            uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos);
-    void vkGetDeviceGroupPeerMemoryFeatures(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
-                                            uint32_t heapIndex, uint32_t localDeviceIndex,
-                                            uint32_t remoteDeviceIndex,
+    void vkEnumerateInstanceVersion(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, uint32_t* pApiVersion);
+    void vkBindBufferMemory2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device, uint32_t bindInfoCount,
+                             const VkBindBufferMemoryInfo* pBindInfos);
+    void vkBindImageMemory2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device, uint32_t bindInfoCount,
+                            const VkBindImageMemoryInfo* pBindInfos);
+    void vkGetDeviceGroupPeerMemoryFeatures(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device, uint32_t heapIndex,
+                                            uint32_t localDeviceIndex, uint32_t remoteDeviceIndex,
                                             VkPeerMemoryFeatureFlags* pPeerMemoryFeatures);
-    void vkCmdSetDeviceMask(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            uint32_t deviceMask);
-    void vkCmdDispatchBase(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ,
-                           uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
+    void vkCmdSetDeviceMask(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, uint32_t deviceMask);
+    void vkCmdDispatchBase(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY,
+                           uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY,
+                           uint32_t groupCountZ);
     void vkEnumeratePhysicalDeviceGroups(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
         VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);
-    void vkGetImageMemoryRequirements2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkDevice device,
-                                       const VkImageMemoryRequirementsInfo2* pInfo,
+    void vkGetImageMemoryRequirements2(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
                                        VkMemoryRequirements2* pMemoryRequirements);
-    void vkGetBufferMemoryRequirements2(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetBufferMemoryRequirements2(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device,
                                         const VkBufferMemoryRequirementsInfo2* pInfo,
                                         VkMemoryRequirements2* pMemoryRequirements);
     void vkGetImageSparseMemoryRequirements2(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
-        uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);
-    void vkGetPhysicalDeviceFeatures2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFeatures2(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkPhysicalDevice physicalDevice,
                                       VkPhysicalDeviceFeatures2* pFeatures);
-    void vkGetPhysicalDeviceProperties2(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceProperties2(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkPhysicalDevice physicalDevice,
                                         VkPhysicalDeviceProperties2* pProperties);
-    void vkGetPhysicalDeviceFormatProperties2(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFormatProperties2(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize,
                                               VkPhysicalDevice physicalDevice, VkFormat format,
                                               VkFormatProperties2* pFormatProperties);
     void vkGetPhysicalDeviceImageFormatProperties2(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkPhysicalDevice physicalDevice,
-        const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
         VkImageFormatProperties2* pImageFormatProperties);
     void vkGetPhysicalDeviceQueueFamilyProperties2(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
-        VkQueueFamilyProperties2* pQueueFamilyProperties);
-    void vkGetPhysicalDeviceMemoryProperties2(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties);
+    void vkGetPhysicalDeviceMemoryProperties2(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize,
                                               VkPhysicalDevice physicalDevice,
                                               VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
     void vkGetPhysicalDeviceSparseImageFormatProperties2(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
-        uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties);
-    void vkTrimCommandPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkDevice device,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
+        VkSparseImageFormatProperties2* pProperties);
+    void vkTrimCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                            VkCommandPool commandPool, VkCommandPoolTrimFlags flags);
-    void vkGetDeviceQueue2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceQueue2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                            const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue);
-    void vkCreateSamplerYcbcrConversion(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateSamplerYcbcrConversion(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkSamplerYcbcrConversion* pYcbcrConversion);
-    void vkDestroySamplerYcbcrConversion(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkDestroySamplerYcbcrConversion(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
                                          const VkAllocationCallbacks* pAllocator);
-    void vkCreateDescriptorUpdateTemplate(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateDescriptorUpdateTemplate(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);
-    void vkDestroyDescriptorUpdateTemplate(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkDestroyDescriptorUpdateTemplate(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device,
                                            VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                            const VkAllocationCallbacks* pAllocator);
-    void vkUpdateDescriptorSetWithTemplate(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkUpdateDescriptorSetWithTemplate(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device, VkDescriptorSet descriptorSet,
                                            VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                            const void* pData);
     void vkGetPhysicalDeviceExternalBufferProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
         VkExternalBufferProperties* pExternalBufferProperties);
     void vkGetPhysicalDeviceExternalFenceProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
         VkExternalFenceProperties* pExternalFenceProperties);
     void vkGetPhysicalDeviceExternalSemaphoreProperties(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
         VkExternalSemaphoreProperties* pExternalSemaphoreProperties);
-    void vkGetDescriptorSetLayoutSupport(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetDescriptorSetLayoutSupport(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device,
                                          const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                          VkDescriptorSetLayoutSupport* pSupport);
 #endif
 #ifdef VK_VERSION_1_2
-    void vkCmdDrawIndirectCount(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
-                                VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
-                                uint32_t stride);
-    void vkCmdDrawIndexedIndirectCount(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
+    void vkCmdDrawIndirectCount(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
+                                VkBuffer countBuffer, VkDeviceSize countBufferOffset,
+                                uint32_t maxDrawCount, uint32_t stride);
+    void vkCmdDrawIndexedIndirectCount(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, VkBuffer buffer,
+                                       VkDeviceSize offset, VkBuffer countBuffer,
                                        VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                        uint32_t stride);
-    void vkCreateRenderPass2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device,
                              const VkRenderPassCreateInfo2* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
-    void vkCmdBeginRenderPass2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer,
                                const VkRenderPassBeginInfo* pRenderPassBegin,
                                const VkSubpassBeginInfo* pSubpassBeginInfo);
-    void vkCmdNextSubpass2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdNextSubpass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer,
                            const VkSubpassBeginInfo* pSubpassBeginInfo,
                            const VkSubpassEndInfo* pSubpassEndInfo);
-    void vkCmdEndRenderPass2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdEndRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer,
                              const VkSubpassEndInfo* pSubpassEndInfo);
-    void vkResetQueryPool(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkDevice device, VkQueryPool queryPool,
-                          uint32_t firstQuery, uint32_t queryCount);
-    void vkGetSemaphoreCounterValue(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    VkDevice device, VkSemaphore semaphore, uint64_t* pValue);
-    void vkWaitSemaphores(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkResetQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+                          VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
+    void vkGetSemaphoreCounterValue(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, VkDevice device, VkSemaphore semaphore,
+                                    uint64_t* pValue);
+    void vkWaitSemaphores(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device,
                           const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout);
-    void vkSignalSemaphore(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkSignalSemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkDevice device,
                            const VkSemaphoreSignalInfo* pSignalInfo);
-    void vkGetBufferDeviceAddress(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkDeviceAddress input_result,
-                                  VkDevice device, const VkBufferDeviceAddressInfo* pInfo);
-    void vkGetBufferOpaqueCaptureAddress(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetBufferDeviceAddress(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkDeviceAddress input_result, VkDevice device,
+                                  const VkBufferDeviceAddressInfo* pInfo);
+    void vkGetBufferOpaqueCaptureAddress(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          uint64_t input_result, VkDevice device,
                                          const VkBufferDeviceAddressInfo* pInfo);
-    void vkGetDeviceMemoryOpaqueCaptureAddress(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool, uint64_t input_result,
+    void vkGetDeviceMemoryOpaqueCaptureAddress(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* apiCallInfo,
+                                               const uint8_t* apiCallPacket,
+                                               size_t apiCallPacketSize, uint64_t input_result,
                                                VkDevice device,
                                                const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo);
 #endif
 #ifdef VK_VERSION_1_3
-    void vkGetPhysicalDeviceToolProperties(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceToolProperties(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkPhysicalDevice physicalDevice,
                                            uint32_t* pToolCount,
                                            VkPhysicalDeviceToolProperties* pToolProperties);
-    void vkCreatePrivateDataSlot(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkResult input_result,
-                                 VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
+    void vkCreatePrivateDataSlot(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkResult input_result, VkDevice device,
+                                 const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator,
                                  VkPrivateDataSlot* pPrivateDataSlot);
-    void vkDestroyPrivateDataSlot(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkDevice device,
-                                  VkPrivateDataSlot privateDataSlot,
+    void vkDestroyPrivateDataSlot(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkDevice device, VkPrivateDataSlot privateDataSlot,
                                   const VkAllocationCallbacks* pAllocator);
-    void vkSetPrivateData(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkSetPrivateData(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkResult input_result, VkDevice device, VkObjectType objectType,
+                          uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data);
+    void vkGetPrivateData(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                           VkObjectType objectType, uint64_t objectHandle,
-                          VkPrivateDataSlot privateDataSlot, uint64_t data);
-    void vkGetPrivateData(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkDevice device, VkObjectType objectType,
-                          uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
-                          uint64_t* pData);
-    void vkCmdSetEvent2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkCommandBuffer commandBuffer, VkEvent event,
+                          VkPrivateDataSlot privateDataSlot, uint64_t* pData);
+    void vkCmdSetEvent2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkCommandBuffer commandBuffer, VkEvent event,
                         const VkDependencyInfo* pDependencyInfo);
-    void vkCmdResetEvent2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          VkEvent event, VkPipelineStageFlags2 stageMask);
-    void vkCmdWaitEvents2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          uint32_t eventCount, const VkEvent* pEvents,
-                          const VkDependencyInfo* pDependencyInfos);
-    void vkCmdPipelineBarrier2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdResetEvent2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, VkEvent event,
+                          VkPipelineStageFlags2 stageMask);
+    void vkCmdWaitEvents2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, uint32_t eventCount,
+                          const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos);
+    void vkCmdPipelineBarrier2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer,
                                const VkDependencyInfo* pDependencyInfo);
-    void vkCmdWriteTimestamp2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query);
-    void vkQueueSubmit2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                        android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
-                        uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence);
-    void vkCmdCopyBuffer2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          const VkCopyBufferInfo2* pCopyBufferInfo);
-    void vkCmdCopyImage2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         const VkCopyImageInfo2* pCopyImageInfo);
-    void vkCmdCopyBufferToImage2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdWriteTimestamp2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
+                              VkQueryPool queryPool, uint32_t query);
+    void vkQueueSubmit2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                        VkResult input_result, VkQueue queue, uint32_t submitCount,
+                        const VkSubmitInfo2* pSubmits, VkFence fence);
+    void vkCmdCopyBuffer2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo);
+    void vkCmdCopyImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo);
+    void vkCmdCopyBufferToImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer,
                                  const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo);
-    void vkCmdCopyImageToBuffer2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyImageToBuffer2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer,
                                  const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo);
-    void vkCmdBlitImage2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                         const VkBlitImageInfo2* pBlitImageInfo);
-    void vkCmdResolveImage2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBlitImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo);
+    void vkCmdResolveImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer,
                             const VkResolveImageInfo2* pResolveImageInfo);
-    void vkCmdBeginRendering(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             const VkRenderingInfo* pRenderingInfo);
-    void vkCmdEndRendering(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer);
-    void vkCmdSetCullMode(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                          android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                          VkCullModeFlags cullMode);
-    void vkCmdSetFrontFace(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkFrontFace frontFace);
-    void vkCmdSetPrimitiveTopology(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginRendering(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo);
+    void vkCmdEndRendering(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer);
+    void vkCmdSetCullMode(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                          VkCommandBuffer commandBuffer, VkCullModeFlags cullMode);
+    void vkCmdSetFrontFace(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkFrontFace frontFace);
+    void vkCmdSetPrimitiveTopology(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkPrimitiveTopology primitiveTopology);
-    void vkCmdSetViewportWithCount(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetViewportWithCount(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    uint32_t viewportCount, const VkViewport* pViewports);
-    void vkCmdSetScissorWithCount(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  uint32_t scissorCount, const VkRect2D* pScissors);
-    void vkCmdBindVertexBuffers2(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 uint32_t firstBinding, uint32_t bindingCount,
-                                 const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
-                                 const VkDeviceSize* pSizes, const VkDeviceSize* pStrides);
-    void vkCmdSetDepthTestEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 VkBool32 depthTestEnable);
-    void vkCmdSetDepthWriteEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkBool32 depthWriteEnable);
-    void vkCmdSetDepthCompareOp(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                VkCompareOp depthCompareOp);
-    void vkCmdSetDepthBoundsTestEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetScissorWithCount(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, uint32_t scissorCount,
+                                  const VkRect2D* pScissors);
+    void vkCmdBindVertexBuffers2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, uint32_t firstBinding,
+                                 uint32_t bindingCount, const VkBuffer* pBuffers,
+                                 const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
+                                 const VkDeviceSize* pStrides);
+    void vkCmdSetDepthTestEnable(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, VkBool32 depthTestEnable);
+    void vkCmdSetDepthWriteEnable(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable);
+    void vkCmdSetDepthCompareOp(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp);
+    void vkCmdSetDepthBoundsTestEnable(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer,
                                        VkBool32 depthBoundsTestEnable);
-    void vkCmdSetStencilTestEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetStencilTestEnable(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkBool32 stencilTestEnable);
-    void vkCmdSetStencilOp(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp,
-                           VkStencilOp depthFailOp, VkCompareOp compareOp);
-    void vkCmdSetRasterizerDiscardEnable(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdSetStencilOp(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                           VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
+                           VkCompareOp compareOp);
+    void vkCmdSetRasterizerDiscardEnable(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          VkBool32 rasterizerDiscardEnable);
-    void vkCmdSetDepthBiasEnable(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 VkBool32 depthBiasEnable);
-    void vkCmdSetPrimitiveRestartEnable(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdSetDepthBiasEnable(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable);
+    void vkCmdSetPrimitiveRestartEnable(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer,
                                         VkBool32 primitiveRestartEnable);
-    void vkGetDeviceBufferMemoryRequirements(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceBufferMemoryRequirements(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkDevice device,
                                              const VkDeviceBufferMemoryRequirements* pInfo,
                                              VkMemoryRequirements2* pMemoryRequirements);
-    void vkGetDeviceImageMemoryRequirements(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceImageMemoryRequirements(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device,
                                             const VkDeviceImageMemoryRequirements* pInfo,
                                             VkMemoryRequirements2* pMemoryRequirements);
     void vkGetDeviceImageSparseMemoryRequirements(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
-        uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);
 #endif
 #ifdef VK_KHR_swapchain
-    void vkCreateSwapchainKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkCreateSwapchainKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkDevice device,
                               const VkSwapchainCreateInfoKHR* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
-    void vkDestroySwapchainKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkDevice device,
-                               VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator);
-    void vkGetSwapchainImagesKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkResult input_result,
-                                 VkDevice device, VkSwapchainKHR swapchain,
+    void vkDestroySwapchainKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkDevice device, VkSwapchainKHR swapchain,
+                               const VkAllocationCallbacks* pAllocator);
+    void vkGetSwapchainImagesKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
                                  uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
-    void vkAcquireNextImageKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout,
-                               VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
-    void vkQueuePresentKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
+    void vkAcquireNextImageKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
+                               uint64_t timeout, VkSemaphore semaphore, VkFence fence,
+                               uint32_t* pImageIndex);
+    void vkQueuePresentKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkQueue queue,
                            const VkPresentInfoKHR* pPresentInfo);
     void vkGetDeviceGroupPresentCapabilitiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device,
-        VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities);
-    void vkGetDeviceGroupSurfacePresentModesKHR(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
-                                                VkResult input_result, VkDevice device,
-                                                VkSurfaceKHR surface,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities);
+    void vkGetDeviceGroupSurfacePresentModesKHR(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize, VkResult input_result,
+                                                VkDevice device, VkSurfaceKHR surface,
                                                 VkDeviceGroupPresentModeFlagsKHR* pModes);
-    void vkGetPhysicalDevicePresentRectanglesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
-        uint32_t* pRectCount, VkRect2D* pRects);
-    void vkAcquireNextImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo,
+    void vkGetPhysicalDevicePresentRectanglesKHR(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize, VkResult input_result,
+                                                 VkPhysicalDevice physicalDevice,
+                                                 VkSurfaceKHR surface, uint32_t* pRectCount,
+                                                 VkRect2D* pRects);
+    void vkAcquireNextImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                const VkAcquireNextImageInfoKHR* pAcquireInfo,
                                 uint32_t* pImageIndex);
 #endif
 #ifdef VK_KHR_dynamic_rendering
-    void vkCmdBeginRenderingKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginRenderingKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer,
                                 const VkRenderingInfo* pRenderingInfo);
-    void vkCmdEndRenderingKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer);
+    void vkCmdEndRenderingKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer);
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
-    void vkGetPhysicalDeviceFeatures2KHR(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFeatures2KHR(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkPhysicalDevice physicalDevice,
                                          VkPhysicalDeviceFeatures2* pFeatures);
-    void vkGetPhysicalDeviceProperties2KHR(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceProperties2KHR(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkPhysicalDevice physicalDevice,
                                            VkPhysicalDeviceProperties2* pProperties);
-    void vkGetPhysicalDeviceFormatProperties2KHR(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool,
+    void vkGetPhysicalDeviceFormatProperties2KHR(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize,
                                                  VkPhysicalDevice physicalDevice, VkFormat format,
                                                  VkFormatProperties2* pFormatProperties);
     void vkGetPhysicalDeviceImageFormatProperties2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkPhysicalDevice physicalDevice,
-        const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
         VkImageFormatProperties2* pImageFormatProperties);
     void vkGetPhysicalDeviceQueueFamilyProperties2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
-        VkQueueFamilyProperties2* pQueueFamilyProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties);
     void vkGetPhysicalDeviceMemoryProperties2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
     void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
-        uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
+        const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
+        VkSparseImageFormatProperties2* pProperties);
 #endif
 #ifdef VK_KHR_maintenance1
-    void vkTrimCommandPoolKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkDevice device,
-                              VkCommandPool commandPool, VkCommandPoolTrimFlags flags);
+    void vkTrimCommandPoolKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkDevice device, VkCommandPool commandPool,
+                              VkCommandPoolTrimFlags flags);
 #endif
 #ifdef VK_KHR_external_memory_capabilities
     void vkGetPhysicalDeviceExternalBufferPropertiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
         VkExternalBufferProperties* pExternalBufferProperties);
 #endif
 #ifdef VK_KHR_external_semaphore_capabilities
     void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
         VkExternalSemaphoreProperties* pExternalSemaphoreProperties);
 #endif
 #ifdef VK_KHR_external_semaphore_fd
-    void vkImportSemaphoreFdKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device,
+    void vkImportSemaphoreFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
                                 const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo);
-    void vkGetSemaphoreFdKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkGetSemaphoreFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device,
                              const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd);
 #endif
 #ifdef VK_KHR_descriptor_update_template
     void vkCreateDescriptorUpdateTemplateKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device,
-        const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator,
         VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);
-    void vkDestroyDescriptorUpdateTemplateKHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkDevice device,
+    void vkDestroyDescriptorUpdateTemplateKHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkDevice device,
                                               VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                               const VkAllocationCallbacks* pAllocator);
-    void vkUpdateDescriptorSetWithTemplateKHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkDevice device,
+    void vkUpdateDescriptorSetWithTemplateKHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkDevice device,
                                               VkDescriptorSet descriptorSet,
                                               VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                               const void* pData);
 #endif
 #ifdef VK_KHR_create_renderpass2
-    void vkCreateRenderPass2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo,
+    void vkCreateRenderPass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
+                                const VkRenderPassCreateInfo2* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
-    void vkCmdBeginRenderPass2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginRenderPass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer,
                                   const VkRenderPassBeginInfo* pRenderPassBegin,
                                   const VkSubpassBeginInfo* pSubpassBeginInfo);
-    void vkCmdNextSubpass2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdNextSubpass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer,
                               const VkSubpassBeginInfo* pSubpassBeginInfo,
                               const VkSubpassEndInfo* pSubpassEndInfo);
-    void vkCmdEndRenderPass2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdEndRenderPass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer,
                                 const VkSubpassEndInfo* pSubpassEndInfo);
 #endif
 #ifdef VK_KHR_external_fence_capabilities
     void vkGetPhysicalDeviceExternalFencePropertiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkPhysicalDevice physicalDevice,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
         const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
         VkExternalFenceProperties* pExternalFenceProperties);
 #endif
 #ifdef VK_KHR_external_fence_fd
-    void vkImportFenceFdKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkImportFenceFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkResult input_result, VkDevice device,
                             const VkImportFenceFdInfoKHR* pImportFenceFdInfo);
-    void vkGetFenceFdKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkDevice device,
+    void vkGetFenceFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkDevice device,
                          const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd);
 #endif
 #ifdef VK_KHR_get_memory_requirements2
-    void vkGetImageMemoryRequirements2KHR(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetImageMemoryRequirements2KHR(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device,
                                           const VkImageMemoryRequirementsInfo2* pInfo,
                                           VkMemoryRequirements2* pMemoryRequirements);
-    void vkGetBufferMemoryRequirements2KHR(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetBufferMemoryRequirements2KHR(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device,
                                            const VkBufferMemoryRequirementsInfo2* pInfo,
                                            VkMemoryRequirements2* pMemoryRequirements);
     void vkGetImageSparseMemoryRequirements2KHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
-        uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);
 #endif
 #ifdef VK_KHR_sampler_ycbcr_conversion
-    void vkCreateSamplerYcbcrConversionKHR(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateSamplerYcbcrConversionKHR(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkSamplerYcbcrConversion* pYcbcrConversion);
-    void vkDestroySamplerYcbcrConversionKHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
+    void vkDestroySamplerYcbcrConversionKHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device,
                                             VkSamplerYcbcrConversion ycbcrConversion,
                                             const VkAllocationCallbacks* pAllocator);
 #endif
 #ifdef VK_KHR_bind_memory2
-    void vkBindBufferMemory2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, uint32_t bindInfoCount,
+    void vkBindBufferMemory2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device, uint32_t bindInfoCount,
                                 const VkBindBufferMemoryInfo* pBindInfos);
-    void vkBindImageMemory2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, uint32_t bindInfoCount,
+    void vkBindImageMemory2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, uint32_t bindInfoCount,
                                const VkBindImageMemoryInfo* pBindInfos);
 #endif
 #ifdef VK_KHR_maintenance3
-    void vkGetDescriptorSetLayoutSupportKHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, VkDevice device,
+    void vkGetDescriptorSetLayoutSupportKHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkDevice device,
                                             const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                             VkDescriptorSetLayoutSupport* pSupport);
 #endif
 #ifdef VK_KHR_buffer_device_address
-    void vkGetBufferDeviceAddressKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkDeviceAddress input_result,
-                                     VkDevice device, const VkBufferDeviceAddressInfo* pInfo);
-    void vkGetBufferOpaqueCaptureAddressKHR(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool, uint64_t input_result,
-                                            VkDevice device,
+    void vkGetBufferDeviceAddressKHR(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkDeviceAddress input_result, VkDevice device,
+                                     const VkBufferDeviceAddressInfo* pInfo);
+    void vkGetBufferOpaqueCaptureAddressKHR(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            uint64_t input_result, VkDevice device,
                                             const VkBufferDeviceAddressInfo* pInfo);
     void vkGetDeviceMemoryOpaqueCaptureAddressKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        uint64_t input_result, VkDevice device,
-        const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, uint64_t input_result,
+        VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo);
 #endif
 #ifdef VK_KHR_pipeline_executable_properties
     void vkGetPipelineExecutablePropertiesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, const VkPipelineInfoKHR* pPipelineInfo,
-        uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount,
+        VkPipelineExecutablePropertiesKHR* pProperties);
     void vkGetPipelineExecutableStatisticsKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
         uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics);
     void vkGetPipelineExecutableInternalRepresentationsKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
         uint32_t* pInternalRepresentationCount,
         VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations);
 #endif
 #ifdef VK_KHR_synchronization2
-    void vkCmdSetEvent2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                           VkEvent event, const VkDependencyInfo* pDependencyInfo);
-    void vkCmdResetEvent2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             VkEvent event, VkPipelineStageFlags2 stageMask);
-    void vkCmdWaitEvents2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             uint32_t eventCount, const VkEvent* pEvents,
-                             const VkDependencyInfo* pDependencyInfos);
-    void vkCmdPipelineBarrier2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetEvent2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer, VkEvent event,
+                           const VkDependencyInfo* pDependencyInfo);
+    void vkCmdResetEvent2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, VkEvent event,
+                             VkPipelineStageFlags2 stageMask);
+    void vkCmdWaitEvents2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, uint32_t eventCount,
+                             const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos);
+    void vkCmdPipelineBarrier2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer,
                                   const VkDependencyInfo* pDependencyInfo);
-    void vkCmdWriteTimestamp2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 VkPipelineStageFlags2 stage, VkQueryPool queryPool,
-                                 uint32_t query);
-    void vkQueueSubmit2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkResult input_result, VkQueue queue,
-                           uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence);
-    void vkCmdWriteBufferMarker2AMD(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    VkPipelineStageFlags2 stage, VkBuffer dstBuffer,
-                                    VkDeviceSize dstOffset, uint32_t marker);
-    void vkGetQueueCheckpointData2NV(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkQueue queue,
-                                     uint32_t* pCheckpointDataCount,
+    void vkCmdWriteTimestamp2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
+                                 VkQueryPool queryPool, uint32_t query);
+    void vkQueueSubmit2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkResult input_result, VkQueue queue, uint32_t submitCount,
+                           const VkSubmitInfo2* pSubmits, VkFence fence);
+    void vkCmdWriteBufferMarker2AMD(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
+                                    VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker);
+    void vkGetQueueCheckpointData2NV(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkQueue queue, uint32_t* pCheckpointDataCount,
                                      VkCheckpointData2NV* pCheckpointData);
 #endif
 #ifdef VK_KHR_copy_commands2
-    void vkCmdCopyBuffer2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyBuffer2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer,
                              const VkCopyBufferInfo2* pCopyBufferInfo);
-    void vkCmdCopyImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            const VkCopyImageInfo2* pCopyImageInfo);
-    void vkCmdCopyBufferToImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo);
+    void vkCmdCopyBufferToImage2KHR(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer,
                                     const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo);
-    void vkCmdCopyImageToBuffer2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdCopyImageToBuffer2KHR(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer,
                                     const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo);
-    void vkCmdBlitImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            const VkBlitImageInfo2* pBlitImageInfo);
-    void vkCmdResolveImage2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBlitImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo);
+    void vkCmdResolveImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkCommandBuffer commandBuffer,
                                const VkResolveImageInfo2* pResolveImageInfo);
 #endif
 #ifdef VK_KHR_maintenance4
-    void vkGetDeviceBufferMemoryRequirementsKHR(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceBufferMemoryRequirementsKHR(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize, VkDevice device,
                                                 const VkDeviceBufferMemoryRequirements* pInfo,
                                                 VkMemoryRequirements2* pMemoryRequirements);
-    void vkGetDeviceImageMemoryRequirementsKHR(const uint8_t* snapshotTraceBegin,
-                                               size_t snapshotTraceBytes,
-                                               android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceImageMemoryRequirementsKHR(android::base::BumpPool* pool,
+                                               VkSnapshotApiCallInfo* apiCallInfo,
+                                               const uint8_t* apiCallPacket,
+                                               size_t apiCallPacketSize, VkDevice device,
                                                const VkDeviceImageMemoryRequirements* pInfo,
                                                VkMemoryRequirements2* pMemoryRequirements);
     void vkGetDeviceImageSparseMemoryRequirementsKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
-        uint32_t* pSparseMemoryRequirementCount,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount,
         VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);
 #endif
 #ifdef VK_KHR_maintenance5
-    void vkCmdBindIndexBuffer2KHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                  VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size,
-                                  VkIndexType indexType);
-    void vkGetRenderingAreaGranularityKHR(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdBindIndexBuffer2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkCommandBuffer commandBuffer, VkBuffer buffer,
+                                  VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType);
+    void vkGetRenderingAreaGranularityKHR(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device,
                                           const VkRenderingAreaInfoKHR* pRenderingAreaInfo,
                                           VkExtent2D* pGranularity);
-    void vkGetDeviceImageSubresourceLayoutKHR(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkDevice device,
+    void vkGetDeviceImageSubresourceLayoutKHR(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkDevice device,
                                               const VkDeviceImageSubresourceInfoKHR* pInfo,
                                               VkSubresourceLayout2KHR* pLayout);
-    void vkGetImageSubresourceLayout2KHR(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetImageSubresourceLayout2KHR(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkImage image,
                                          const VkImageSubresource2KHR* pSubresource,
                                          VkSubresourceLayout2KHR* pLayout);
 #endif
 #ifdef VK_KHR_line_rasterization
-    void vkCmdSetLineStippleKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                uint32_t lineStippleFactor, uint16_t lineStipplePattern);
+    void vkCmdSetLineStippleKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
+                                uint16_t lineStipplePattern);
 #endif
 #ifdef VK_ANDROID_native_buffer
-    void vkGetSwapchainGrallocUsageANDROID(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetSwapchainGrallocUsageANDROID(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device, VkFormat format,
                                            VkImageUsageFlags imageUsage, int* grallocUsage);
-    void vkAcquireImageANDROID(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device, VkImage image, int nativeFenceFd,
-                               VkSemaphore semaphore, VkFence fence);
-    void vkQueueSignalReleaseImageANDROID(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkAcquireImageANDROID(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device, VkImage image,
+                               int nativeFenceFd, VkSemaphore semaphore, VkFence fence);
+    void vkQueueSignalReleaseImageANDROID(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkQueue queue,
                                           uint32_t waitSemaphoreCount,
                                           const VkSemaphore* pWaitSemaphores, VkImage image,
                                           int* pNativeFenceFd);
-    void vkGetSwapchainGrallocUsage2ANDROID(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
-        VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
-        uint64_t* grallocProducerUsage);
+    void vkGetSwapchainGrallocUsage2ANDROID(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                            VkResult input_result, VkDevice device, VkFormat format,
+                                            VkImageUsageFlags imageUsage,
+                                            VkSwapchainImageUsageFlagsANDROID swapchainImageUsage,
+                                            uint64_t* grallocConsumerUsage,
+                                            uint64_t* grallocProducerUsage);
 #endif
 #ifdef VK_EXT_debug_report
-    void vkCreateDebugReportCallbackEXT(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateDebugReportCallbackEXT(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkInstance instance,
                                         const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkDebugReportCallbackEXT* pCallback);
-    void vkDestroyDebugReportCallbackEXT(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkDestroyDebugReportCallbackEXT(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkInstance instance, VkDebugReportCallbackEXT callback,
                                          const VkAllocationCallbacks* pAllocator);
-    void vkDebugReportMessageEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkInstance instance,
-                                 VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType,
-                                 uint64_t object, size_t location, int32_t messageCode,
-                                 const char* pLayerPrefix, const char* pMessage);
+    void vkDebugReportMessageEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkInstance instance, VkDebugReportFlagsEXT flags,
+                                 VkDebugReportObjectTypeEXT objectType, uint64_t object,
+                                 size_t location, int32_t messageCode, const char* pLayerPrefix,
+                                 const char* pMessage);
 #endif
 #ifdef VK_EXT_transform_feedback
     void vkCmdBindTransformFeedbackBuffersEXT(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
-        const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes);
-    void vkCmdBeginTransformFeedbackEXT(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
+        uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers,
+        const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes);
+    void vkCmdBeginTransformFeedbackEXT(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                         uint32_t counterBufferCount,
                                         const VkBuffer* pCounterBuffers,
                                         const VkDeviceSize* pCounterBufferOffsets);
-    void vkCmdEndTransformFeedbackEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      uint32_t firstCounterBuffer, uint32_t counterBufferCount,
-                                      const VkBuffer* pCounterBuffers,
+    void vkCmdEndTransformFeedbackEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
+                                      uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
                                       const VkDeviceSize* pCounterBufferOffsets);
-    void vkCmdBeginQueryIndexedEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginQueryIndexedEXT(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags,
                                    uint32_t index);
-    void vkCmdEndQueryIndexedEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                 android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                 VkQueryPool queryPool, uint32_t query, uint32_t index);
-    void vkCmdDrawIndirectByteCountEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       uint32_t instanceCount, uint32_t firstInstance,
-                                       VkBuffer counterBuffer, VkDeviceSize counterBufferOffset,
-                                       uint32_t counterOffset, uint32_t vertexStride);
+    void vkCmdEndQueryIndexedEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                 VkCommandBuffer commandBuffer, VkQueryPool queryPool,
+                                 uint32_t query, uint32_t index);
+    void vkCmdDrawIndirectByteCountEXT(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, uint32_t instanceCount,
+                                       uint32_t firstInstance, VkBuffer counterBuffer,
+                                       VkDeviceSize counterBufferOffset, uint32_t counterOffset,
+                                       uint32_t vertexStride);
 #endif
 #ifdef VK_EXT_debug_utils
-    void vkSetDebugUtilsObjectNameEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkResult input_result,
-                                      VkDevice device,
+    void vkSetDebugUtilsObjectNameEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkResult input_result, VkDevice device,
                                       const VkDebugUtilsObjectNameInfoEXT* pNameInfo);
-    void vkSetDebugUtilsObjectTagEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkResult input_result,
-                                     VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo);
-    void vkQueueBeginDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkSetDebugUtilsObjectTagEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkResult input_result, VkDevice device,
+                                     const VkDebugUtilsObjectTagInfoEXT* pTagInfo);
+    void vkQueueBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo);
-    void vkQueueEndDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkQueue queue);
-    void vkQueueInsertDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkQueueEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkQueue queue);
+    void vkQueueInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo);
-    void vkCmdBeginDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer,
                                       const VkDebugUtilsLabelEXT* pLabelInfo);
-    void vkCmdEndDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer);
-    void vkCmdInsertDebugUtilsLabelEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer);
+    void vkCmdInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer,
                                        const VkDebugUtilsLabelEXT* pLabelInfo);
-    void vkCreateDebugUtilsMessengerEXT(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCreateDebugUtilsMessengerEXT(android::base::BumpPool* pool,
+                                        VkSnapshotApiCallInfo* apiCallInfo,
+                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkInstance instance,
                                         const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkDebugUtilsMessengerEXT* pMessenger);
-    void vkDestroyDebugUtilsMessengerEXT(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkDestroyDebugUtilsMessengerEXT(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkInstance instance, VkDebugUtilsMessengerEXT messenger,
                                          const VkAllocationCallbacks* pAllocator);
-    void vkSubmitDebugUtilsMessageEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkInstance instance,
+    void vkSubmitDebugUtilsMessageEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkInstance instance,
                                       VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                       VkDebugUtilsMessageTypeFlagsEXT messageTypes,
                                       const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData);
 #endif
 #ifdef VK_EXT_image_drm_format_modifier
     void vkGetImageDrmFormatModifierPropertiesEXT(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, VkImage image,
-        VkImageDrmFormatModifierPropertiesEXT* pProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties);
 #endif
 #ifdef VK_EXT_external_memory_host
     void vkGetMemoryHostPointerPropertiesEXT(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType,
-        const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer,
+        VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties);
 #endif
 #ifdef VK_EXT_tooling_info
-    void vkGetPhysicalDeviceToolPropertiesEXT(const uint8_t* snapshotTraceBegin,
-                                              size_t snapshotTraceBytes,
-                                              android::base::BumpPool* pool, VkResult input_result,
+    void vkGetPhysicalDeviceToolPropertiesEXT(android::base::BumpPool* pool,
+                                              VkSnapshotApiCallInfo* apiCallInfo,
+                                              const uint8_t* apiCallPacket,
+                                              size_t apiCallPacketSize, VkResult input_result,
                                               VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
                                               VkPhysicalDeviceToolProperties* pToolProperties);
 #endif
 #ifdef VK_EXT_line_rasterization
-    void vkCmdSetLineStippleEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                uint32_t lineStippleFactor, uint16_t lineStipplePattern);
+    void vkCmdSetLineStippleEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
+                                uint16_t lineStipplePattern);
 #endif
 #ifdef VK_EXT_extended_dynamic_state
-    void vkCmdSetCullModeEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                             VkCullModeFlags cullMode);
-    void vkCmdSetFrontFaceEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkFrontFace frontFace);
-    void vkCmdSetPrimitiveTopologyEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetCullModeEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkCommandBuffer commandBuffer, VkCullModeFlags cullMode);
+    void vkCmdSetFrontFaceEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkFrontFace frontFace);
+    void vkCmdSetPrimitiveTopologyEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer,
                                       VkPrimitiveTopology primitiveTopology);
-    void vkCmdSetViewportWithCountEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      uint32_t viewportCount, const VkViewport* pViewports);
-    void vkCmdSetScissorWithCountEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                     uint32_t scissorCount, const VkRect2D* pScissors);
-    void vkCmdBindVertexBuffers2EXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    uint32_t firstBinding, uint32_t bindingCount,
-                                    const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
-                                    const VkDeviceSize* pSizes, const VkDeviceSize* pStrides);
-    void vkCmdSetDepthTestEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    VkBool32 depthTestEnable);
-    void vkCmdSetDepthWriteEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                     VkBool32 depthWriteEnable);
-    void vkCmdSetDepthCompareOpEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdSetViewportWithCountEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer, uint32_t viewportCount,
+                                      const VkViewport* pViewports);
+    void vkCmdSetScissorWithCountEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkCommandBuffer commandBuffer, uint32_t scissorCount,
+                                     const VkRect2D* pScissors);
+    void vkCmdBindVertexBuffers2EXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, uint32_t firstBinding,
+                                    uint32_t bindingCount, const VkBuffer* pBuffers,
+                                    const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
+                                    const VkDeviceSize* pStrides);
+    void vkCmdSetDepthTestEnableEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, VkBool32 depthTestEnable);
+    void vkCmdSetDepthWriteEnableEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable);
+    void vkCmdSetDepthCompareOpEXT(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                    VkCompareOp depthCompareOp);
-    void vkCmdSetDepthBoundsTestEnableEXT(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdSetDepthBoundsTestEnableEXT(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer,
                                           VkBool32 depthBoundsTestEnable);
-    void vkCmdSetStencilTestEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                      VkBool32 stencilTestEnable);
-    void vkCmdSetStencilOpEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                              VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp,
-                              VkStencilOp depthFailOp, VkCompareOp compareOp);
+    void vkCmdSetStencilTestEnableEXT(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable);
+    void vkCmdSetStencilOpEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
+                              VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
+                              VkCompareOp compareOp);
 #endif
 #ifdef VK_EXT_host_image_copy
-    void vkCopyMemoryToImageEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device,
+    void vkCopyMemoryToImageEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
                                 const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo);
-    void vkCopyImageToMemoryEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device,
+    void vkCopyImageToMemoryEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device,
                                 const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo);
-    void vkCopyImageToImageEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkResult input_result,
-                               VkDevice device,
+    void vkCopyImageToImageEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkResult input_result, VkDevice device,
                                const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo);
-    void vkTransitionImageLayoutEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    VkDevice device, uint32_t transitionCount,
+    void vkTransitionImageLayoutEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, VkDevice device,
+                                    uint32_t transitionCount,
                                     const VkHostImageLayoutTransitionInfoEXT* pTransitions);
-    void vkGetImageSubresourceLayout2EXT(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetImageSubresourceLayout2EXT(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkImage image,
                                          const VkImageSubresource2KHR* pSubresource,
                                          VkSubresourceLayout2KHR* pLayout);
 #endif
 #ifdef VK_EXT_swapchain_maintenance1
-    void vkReleaseSwapchainImagesEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkResult input_result,
-                                     VkDevice device,
+    void vkReleaseSwapchainImagesEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkResult input_result, VkDevice device,
                                      const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo);
 #endif
 #ifdef VK_EXT_private_data
-    void vkCreatePrivateDataSlotEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkResult input_result,
-                                    VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
+    void vkCreatePrivateDataSlotEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkResult input_result, VkDevice device,
+                                    const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkPrivateDataSlot* pPrivateDataSlot);
-    void vkDestroyPrivateDataSlotEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkDevice device,
-                                     VkPrivateDataSlot privateDataSlot,
+    void vkDestroyPrivateDataSlotEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkDevice device, VkPrivateDataSlot privateDataSlot,
                                      const VkAllocationCallbacks* pAllocator);
-    void vkSetPrivateDataEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                             VkObjectType objectType, uint64_t objectHandle,
-                             VkPrivateDataSlot privateDataSlot, uint64_t data);
-    void vkGetPrivateDataEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                             android::base::BumpPool* pool, VkDevice device,
-                             VkObjectType objectType, uint64_t objectHandle,
+    void vkSetPrivateDataEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkResult input_result, VkDevice device, VkObjectType objectType,
+                             uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
+                             uint64_t data);
+    void vkGetPrivateDataEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                             VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                              VkPrivateDataSlot privateDataSlot, uint64_t* pData);
 #endif
 #ifdef VK_EXT_extended_dynamic_state2
-    void vkCmdSetPatchControlPointsEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       uint32_t patchControlPoints);
-    void vkCmdSetRasterizerDiscardEnableEXT(const uint8_t* snapshotTraceBegin,
-                                            size_t snapshotTraceBytes,
-                                            android::base::BumpPool* pool,
+    void vkCmdSetPatchControlPointsEXT(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, uint32_t patchControlPoints);
+    void vkCmdSetRasterizerDiscardEnableEXT(android::base::BumpPool* pool,
+                                            VkSnapshotApiCallInfo* apiCallInfo,
+                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             VkBool32 rasterizerDiscardEnable);
-    void vkCmdSetDepthBiasEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                    VkBool32 depthBiasEnable);
-    void vkCmdSetLogicOpEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                            android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                            VkLogicOp logicOp);
-    void vkCmdSetPrimitiveRestartEnableEXT(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCmdSetDepthBiasEnableEXT(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable);
+    void vkCmdSetLogicOpEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                            VkCommandBuffer commandBuffer, VkLogicOp logicOp);
+    void vkCmdSetPrimitiveRestartEnableEXT(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            VkBool32 primitiveRestartEnable);
 #endif
 #ifdef VK_EXT_color_write_enable
-    void vkCmdSetColorWriteEnableEXT(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                     android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                     uint32_t attachmentCount, const VkBool32* pColorWriteEnables);
+    void vkCmdSetColorWriteEnableEXT(android::base::BumpPool* pool,
+                                     VkSnapshotApiCallInfo* apiCallInfo,
+                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                     VkCommandBuffer commandBuffer, uint32_t attachmentCount,
+                                     const VkBool32* pColorWriteEnables);
 #endif
 #ifdef VK_GOOGLE_gfxstream
-    void vkMapMemoryIntoAddressSpaceGOOGLE(const uint8_t* snapshotTraceBegin,
-                                           size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkMapMemoryIntoAddressSpaceGOOGLE(android::base::BumpPool* pool,
+                                           VkSnapshotApiCallInfo* apiCallInfo,
+                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            VkDeviceMemory memory, uint64_t* pAddress);
     void vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, VkDescriptorSet descriptorSet,
-        VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-        uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
-        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
-        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
-        const VkBufferView* pBufferViews);
-    void vkBeginCommandBufferAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
+        const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
+        const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
+        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews);
+    void vkBeginCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          const VkCommandBufferBeginInfo* pBeginInfo);
-    void vkEndCommandBufferAsyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool,
+    void vkEndCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer);
-    void vkResetCommandBufferAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                         size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkResetCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
+                                         VkSnapshotApiCallInfo* apiCallInfo,
+                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          VkCommandBufferResetFlags flags);
-    void vkCommandBufferHostSyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
-                                       uint32_t needHostSync, uint32_t sequenceNumber);
-    void vkCreateImageWithRequirementsGOOGLE(const uint8_t* snapshotTraceBegin,
-                                             size_t snapshotTraceBytes,
-                                             android::base::BumpPool* pool, VkResult input_result,
-                                             VkDevice device, const VkImageCreateInfo* pCreateInfo,
+    void vkCommandBufferHostSyncGOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkCommandBuffer commandBuffer, uint32_t needHostSync,
+                                       uint32_t sequenceNumber);
+    void vkCreateImageWithRequirementsGOOGLE(android::base::BumpPool* pool,
+                                             VkSnapshotApiCallInfo* apiCallInfo,
+                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                             VkResult input_result, VkDevice device,
+                                             const VkImageCreateInfo* pCreateInfo,
                                              const VkAllocationCallbacks* pAllocator,
                                              VkImage* pImage,
                                              VkMemoryRequirements* pMemoryRequirements);
     void vkCreateBufferWithRequirementsGOOGLE(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, const VkBufferCreateInfo* pCreateInfo,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, const VkBufferCreateInfo* pCreateInfo,
         const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer,
         VkMemoryRequirements* pMemoryRequirements);
-    void vkGetMemoryHostAddressInfoGOOGLE(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkGetMemoryHostAddressInfoGOOGLE(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           VkDeviceMemory memory, uint64_t* pAddress,
                                           uint64_t* pSize, uint64_t* pHostmemId);
-    void vkFreeMemorySyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                android::base::BumpPool* pool, VkResult input_result,
-                                VkDevice device, VkDeviceMemory memory,
+    void vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                VkResult input_result, VkDevice device, VkDeviceMemory memory,
                                 const VkAllocationCallbacks* pAllocator);
-    void vkQueueHostSyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                               android::base::BumpPool* pool, VkQueue queue, uint32_t needHostSync,
-                               uint32_t sequenceNumber);
-    void vkQueueSubmitAsyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                  android::base::BumpPool* pool, VkQueue queue,
-                                  uint32_t submitCount, const VkSubmitInfo* pSubmits,
+    void vkQueueHostSyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                               VkQueue queue, uint32_t needHostSync, uint32_t sequenceNumber);
+    void vkQueueSubmitAsyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                  VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                   VkFence fence);
-    void vkQueueWaitIdleAsyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkQueue queue);
-    void vkQueueBindSparseAsyncGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkQueue queue,
-                                      uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
-                                      VkFence fence);
-    void vkGetLinearImageLayoutGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                      android::base::BumpPool* pool, VkDevice device,
-                                      VkFormat format, VkDeviceSize* pOffset,
+    void vkQueueWaitIdleAsyncGOOGLE(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkQueue queue);
+    void vkQueueBindSparseAsyncGOOGLE(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkQueue queue, uint32_t bindInfoCount,
+                                      const VkBindSparseInfo* pBindInfo, VkFence fence);
+    void vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool,
+                                      VkSnapshotApiCallInfo* apiCallInfo,
+                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                      VkDevice device, VkFormat format, VkDeviceSize* pOffset,
                                       VkDeviceSize* pRowPitchAlignment);
-    void vkGetLinearImageLayout2GOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                       android::base::BumpPool* pool, VkDevice device,
-                                       const VkImageCreateInfo* pCreateInfo, VkDeviceSize* pOffset,
-                                       VkDeviceSize* pRowPitchAlignment);
-    void vkQueueFlushCommandsGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                    android::base::BumpPool* pool, VkQueue queue,
-                                    VkCommandBuffer commandBuffer, VkDeviceSize dataSize,
-                                    const void* pData);
+    void vkGetLinearImageLayout2GOOGLE(android::base::BumpPool* pool,
+                                       VkSnapshotApiCallInfo* apiCallInfo,
+                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                       VkDevice device, const VkImageCreateInfo* pCreateInfo,
+                                       VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment);
+    void vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool,
+                                    VkSnapshotApiCallInfo* apiCallInfo,
+                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                                    VkQueue queue, VkCommandBuffer commandBuffer,
+                                    VkDeviceSize dataSize, const void* pData);
     void vkQueueCommitDescriptorSetUpdatesGOOGLE(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkQueue queue, uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkQueue queue,
+        uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
         uint32_t descriptorSetCount, const VkDescriptorSetLayout* pSetLayouts,
         const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
         const uint32_t* pDescriptorSetPendingAllocation,
         const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
         const VkWriteDescriptorSet* pPendingDescriptorWrites);
-    void vkCollectDescriptorPoolIdsGOOGLE(const uint8_t* snapshotTraceBegin,
-                                          size_t snapshotTraceBytes, android::base::BumpPool* pool,
+    void vkCollectDescriptorPoolIdsGOOGLE(android::base::BumpPool* pool,
+                                          VkSnapshotApiCallInfo* apiCallInfo,
+                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device, VkDescriptorPool descriptorPool,
                                           uint32_t* pPoolIdCount, uint64_t* pPoolIds);
-    void vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                     size_t snapshotTraceBytes,
-                                                     android::base::BumpPool* pool, VkQueue queue,
-                                                     uint32_t waitSemaphoreCount,
-                                                     const VkSemaphore* pWaitSemaphores,
-                                                     VkImage image);
-    void vkQueueFlushCommandsFromAuxMemoryGOOGLE(const uint8_t* snapshotTraceBegin,
-                                                 size_t snapshotTraceBytes,
-                                                 android::base::BumpPool* pool, VkQueue queue,
+    void vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkQueue queue,
+        uint32_t waitSemaphoreCount, const VkSemaphore* pWaitSemaphores, VkImage image);
+    void vkQueueFlushCommandsFromAuxMemoryGOOGLE(android::base::BumpPool* pool,
+                                                 VkSnapshotApiCallInfo* apiCallInfo,
+                                                 const uint8_t* apiCallPacket,
+                                                 size_t apiCallPacketSize, VkQueue queue,
                                                  VkCommandBuffer commandBuffer,
                                                  VkDeviceMemory deviceMemory,
                                                  VkDeviceSize dataOffset, VkDeviceSize dataSize);
-    void vkGetBlobGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                         android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                         VkDeviceMemory memory);
+    void vkGetBlobGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                         VkResult input_result, VkDevice device, VkDeviceMemory memory);
     void vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkDevice device, VkDescriptorSet descriptorSet,
-        VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
-        uint32_t bufferInfoCount, uint32_t bufferViewCount, uint32_t inlineUniformBlockCount,
-        const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
-        const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
-        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews,
-        const uint8_t* pInlineUniformBlockData);
-    void vkQueueSubmitAsync2GOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                                   android::base::BumpPool* pool, VkQueue queue,
-                                   uint32_t submitCount, const VkSubmitInfo2* pSubmits,
-                                   VkFence fence);
-    void vkGetSemaphoreGOOGLE(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                              android::base::BumpPool* pool, VkResult input_result, VkDevice device,
-                              VkSemaphore semaphore, uint64_t syncId);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
+        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
+        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
+        uint32_t inlineUniformBlockCount, const uint32_t* pImageInfoEntryIndices,
+        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
+        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
+        const VkBufferView* pBufferViews, const uint8_t* pInlineUniformBlockData);
+    void vkQueueSubmitAsync2GOOGLE(android::base::BumpPool* pool,
+                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
+                                   size_t apiCallPacketSize, VkQueue queue, uint32_t submitCount,
+                                   const VkSubmitInfo2* pSubmits, VkFence fence);
+    void vkGetSemaphoreGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                              VkResult input_result, VkDevice device, VkSemaphore semaphore,
+                              uint64_t syncId);
 #endif
 #ifdef VK_KHR_ray_tracing_pipeline
-    void vkCmdTraceRaysKHR(const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes,
-                           android::base::BumpPool* pool, VkCommandBuffer commandBuffer,
+    void vkCmdTraceRaysKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
+                           VkCommandBuffer commandBuffer,
                            const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
                            const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
                            const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
                            const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
                            uint32_t width, uint32_t height, uint32_t depth);
-    void vkCreateRayTracingPipelinesKHR(const uint8_t* snapshotTraceBegin,
-                                        size_t snapshotTraceBytes, android::base::BumpPool* pool,
-                                        VkResult input_result, VkDevice device,
-                                        VkDeferredOperationKHR deferredOperation,
-                                        VkPipelineCache pipelineCache, uint32_t createInfoCount,
-                                        const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
-                                        const VkAllocationCallbacks* pAllocator,
-                                        VkPipeline* pPipelines);
+    void vkCreateRayTracingPipelinesKHR(
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache,
+        uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
+        const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
     void vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkResult input_result, VkDevice device, VkPipeline pipeline, uint32_t firstGroup,
-        uint32_t groupCount, size_t dataSize, void* pData);
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
+        VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount,
+        size_t dataSize, void* pData);
     void vkCmdTraceRaysIndirectKHR(
-        const uint8_t* snapshotTraceBegin, size_t snapshotTraceBytes, android::base::BumpPool* pool,
-        VkCommandBuffer commandBuffer,
+        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
+        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
         const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
         const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
         const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
         const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
         VkDeviceAddress indirectDeviceAddress);
-    void vkGetRayTracingShaderGroupStackSizeKHR(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
-                                                VkDeviceSize input_result, VkDevice device,
-                                                VkPipeline pipeline, uint32_t group,
-                                                VkShaderGroupShaderKHR groupShader);
-    void vkCmdSetRayTracingPipelineStackSizeKHR(const uint8_t* snapshotTraceBegin,
-                                                size_t snapshotTraceBytes,
-                                                android::base::BumpPool* pool,
+    void vkGetRayTracingShaderGroupStackSizeKHR(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize, VkDeviceSize input_result,
+                                                VkDevice device, VkPipeline pipeline,
+                                                uint32_t group, VkShaderGroupShaderKHR groupShader);
+    void vkCmdSetRayTracingPipelineStackSizeKHR(android::base::BumpPool* pool,
+                                                VkSnapshotApiCallInfo* apiCallInfo,
+                                                const uint8_t* apiCallPacket,
+                                                size_t apiCallPacketSize,
                                                 VkCommandBuffer commandBuffer,
                                                 uint32_t pipelineStackSize);
 #endif
@@ -1627,3 +1907,6 @@ class VkDecoderSnapshot {
     class Impl;
     std::unique_ptr<Impl> mImpl;
 };
+
+}  // namespace vk
+}  // namespace gfxstream
diff --git a/host/vulkan/VkDecoderSnapshotUtils.cpp b/host/vulkan/VkDecoderSnapshotUtils.cpp
index 7d75cfe77..bb0de1efa 100644
--- a/host/vulkan/VkDecoderSnapshotUtils.cpp
+++ b/host/vulkan/VkDecoderSnapshotUtils.cpp
@@ -655,7 +655,10 @@ void loadBufferContent(android::base::Stream* stream, StateBlock* stateBlock, Vk
     _RUN_AND_CHECK(dispatch->vkMapMemory(stateBlock->device, stagingMemory, 0, VK_WHOLE_SIZE,
                                          VkMemoryMapFlags{}, &mapped));
     size_t bufferSize = stream->getBe64();
-    assert(bufferSize == bufferInfo->size);
+    if (bufferSize != bufferInfo->size) {
+        GFXSTREAM_ABORT(emugl::FatalError(emugl::ABORT_REASON_OTHER))
+            << "Failed to read buffer on snapshot load";
+    }
     stream->read(mapped, bufferInfo->size);
 
     VkBufferCopy bufferCopy = {
@@ -669,7 +672,7 @@ void loadBufferContent(android::base::Stream* stream, StateBlock* stateBlock, Vk
     };
     if (dispatch->vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
         GFXSTREAM_ABORT(emugl::FatalError(emugl::ABORT_REASON_OTHER))
-            << "Failed to start command buffer on snapshot save";
+            << "Failed to start command buffer on snapshot load";
     }
     dispatch->vkCmdCopyBuffer(commandBuffer, stagingBuffer, buffer, 1, &bufferCopy);
     VkBufferMemoryBarrier barrier{.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
diff --git a/host/vulkan/VkEmulatedPhysicalDeviceMemory.h b/host/vulkan/VkEmulatedPhysicalDeviceMemory.h
index 3363a18df..27c42a722 100644
--- a/host/vulkan/VkEmulatedPhysicalDeviceMemory.h
+++ b/host/vulkan/VkEmulatedPhysicalDeviceMemory.h
@@ -49,7 +49,7 @@ class EmulatedPhysicalDeviceMemoryProperties {
         return mHostMemoryProperties;
     }
 
-    const uint32_t getGuestColorBufferMemoryTypeIndex() const {
+    uint32_t getGuestColorBufferMemoryTypeIndex() const {
         return mGuestColorBufferMemoryTypeIndex;
     }
 
diff --git a/host/vulkan/VkEmulatedPhysicalDeviceQueue.cpp b/host/vulkan/VkEmulatedPhysicalDeviceQueue.cpp
new file mode 100644
index 000000000..fd89a3b07
--- /dev/null
+++ b/host/vulkan/VkEmulatedPhysicalDeviceQueue.cpp
@@ -0,0 +1,47 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "VkEmulatedPhysicalDeviceQueue.h"
+
+#include <algorithm>
+#include <limits>
+
+namespace gfxstream {
+namespace vk {
+
+EmulatedPhysicalDeviceQueueProperties::EmulatedPhysicalDeviceQueueProperties(
+    const std::vector<VkQueueFamilyProperties>& host, const gfxstream::host::FeatureSet& features) {
+    mQueueFamilyProperties = host;
+
+    // Override queueCount for the virtual queue to be provided with device creations
+    mHasVirtualGraphicsQueue = features.VulkanVirtualQueue.enabled;
+    if (mHasVirtualGraphicsQueue) {
+        // This feature will enforce multiple queues on all graphics capable phsical queues
+        // by creating a virtual queue object, which forwards the work streams into the
+        // underlying host queue.
+        // This feature will override queue properties and handling even if the host device
+        // supports multiple graphics queues to reduce divergence.
+        for (VkQueueFamilyProperties& qfp : mQueueFamilyProperties) {
+            if (qfp.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
+                qfp.queueCount = 2;
+            }
+
+            // TODO(b/329845987) Protected memory is not supported yet on emulators.
+            qfp.queueFlags &= ~VK_QUEUE_PROTECTED_BIT;
+        }
+    }
+}
+
+}  // namespace vk
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/vulkan/VkEmulatedPhysicalDeviceQueue.h b/host/vulkan/VkEmulatedPhysicalDeviceQueue.h
new file mode 100644
index 000000000..1b3d8eb4f
--- /dev/null
+++ b/host/vulkan/VkEmulatedPhysicalDeviceQueue.h
@@ -0,0 +1,46 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <vulkan/vulkan.h>
+
+#include <optional>
+#include <vector>
+
+#include "gfxstream/host/Features.h"
+
+namespace gfxstream {
+namespace vk {
+
+class EmulatedPhysicalDeviceQueueProperties {
+   public:
+    EmulatedPhysicalDeviceQueueProperties(const std::vector<VkQueueFamilyProperties>& host,
+                                          const gfxstream::host::FeatureSet& features);
+
+    const std::vector<VkQueueFamilyProperties>& getQueueFamilyProperties() const {
+        return mQueueFamilyProperties;
+    }
+    bool hasVirtualGraphicsQueue() const { return mHasVirtualGraphicsQueue; }
+
+   private:
+    std::vector<VkQueueFamilyProperties> mQueueFamilyProperties;
+
+    // Indicates that the graphics queue family properties are overridden for
+    // this physical device to include a virtual graphics queue.
+    bool mHasVirtualGraphicsQueue = false;
+};
+
+}  // namespace vk
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/vulkan/VkEmulatedPhysicalDeviceQueueTests.cpp b/host/vulkan/VkEmulatedPhysicalDeviceQueueTests.cpp
new file mode 100644
index 000000000..aba9652bd
--- /dev/null
+++ b/host/vulkan/VkEmulatedPhysicalDeviceQueueTests.cpp
@@ -0,0 +1,100 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+#include <vector>
+
+#include "VkEmulatedPhysicalDeviceQueue.h"
+#include "gfxstream/host/Features.h"
+#include "vulkan/vulkan_core.h"
+
+namespace gfxstream {
+namespace vk {
+namespace {
+
+using ::testing::AllOf;
+using ::testing::ElementsAreArray;
+using ::testing::Eq;
+using ::testing::ExplainMatchResult;
+using ::testing::Field;
+using ::testing::Matcher;
+using ::testing::Optional;
+
+MATCHER_P(EqsVkExtent3D, expected, "") {
+    return ExplainMatchResult(AllOf(Field("width", &VkExtent3D::width, Eq(expected.width)),
+                                    Field("height", &VkExtent3D::height, Eq(expected.height)),
+                                    Field("depth", &VkExtent3D::depth, Eq(expected.depth))),
+                              arg, result_listener);
+}
+
+MATCHER_P(EqsVkQueueFamilyProperties, expected, "") {
+    return ExplainMatchResult(
+        AllOf(Field("queueFlags", &VkQueueFamilyProperties::queueFlags, Eq(expected.queueFlags)),
+              Field("queueCount", &VkQueueFamilyProperties::queueCount, Eq(expected.queueCount)),
+              Field("timestampValidBits", &VkQueueFamilyProperties::timestampValidBits,
+                    Eq(expected.timestampValidBits)),
+              Field("minImageTransferGranularity",
+                    &VkQueueFamilyProperties::minImageTransferGranularity,
+                    EqsVkExtent3D(expected.minImageTransferGranularity))),
+        arg, result_listener);
+}
+
+// Use VulkanVirtualQueue feature to multiplex physical queues.
+TEST(VkGuestQueueUtilsTest, Passthrough) {
+    const std::vector<VkQueueFamilyProperties> hostQueueFamilyProperties = {
+        {.queueFlags = VK_QUEUE_GRAPHICS_BIT,
+         .queueCount = 1,
+         .timestampValidBits = 16,
+         .minImageTransferGranularity = {1, 1, 1}}};
+
+    gfxstream::host::FeatureSet features;
+    EmulatedPhysicalDeviceQueueProperties helper(hostQueueFamilyProperties, features);
+
+    // Passthrough when no features enabled:
+    const auto actualQueueProperties = helper.getQueueFamilyProperties();
+    EXPECT_THAT(actualQueueProperties.size(), 1);
+    EXPECT_THAT(actualQueueProperties[0], EqsVkQueueFamilyProperties(hostQueueFamilyProperties[0]));
+}
+
+// Use VulkanVirtualQueue feature to multiplex physical queues.
+TEST(VkGuestQueueUtilsTest, VulkanVirtualQueue) {
+    const std::vector<VkQueueFamilyProperties> hostQueueFamilyProperties = {
+        {.queueFlags = VK_QUEUE_GRAPHICS_BIT,
+         .queueCount = 1,
+         .timestampValidBits = 16,
+         .minImageTransferGranularity = {1, 1, 1}}};
+
+    const std::vector<VkQueueFamilyProperties> expectedQueueFamilyProperties = {
+        {.queueFlags = VK_QUEUE_GRAPHICS_BIT,
+         .queueCount = 2,
+         .timestampValidBits = 16,
+         .minImageTransferGranularity = {1, 1, 1}}};
+
+    // Enable VulkanVirtualQueue, expect 2 graphics queues
+    gfxstream::host::FeatureSet features;
+    features.Vulkan.enabled = true;
+    features.VulkanVirtualQueue.enabled = true;
+
+    EmulatedPhysicalDeviceQueueProperties helper(hostQueueFamilyProperties, features);
+
+    const auto actualQueueProperties = helper.getQueueFamilyProperties();
+    EXPECT_THAT(actualQueueProperties.size(), 1);
+    EXPECT_THAT(actualQueueProperties[0], EqsVkQueueFamilyProperties(expectedQueueFamilyProperties[0]));
+}
+
+}  // namespace
+}  // namespace vk
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/vulkan/VkQsriTimeline.h b/host/vulkan/VkQsriTimeline.h
index e8a952652..e9127783a 100644
--- a/host/vulkan/VkQsriTimeline.h
+++ b/host/vulkan/VkQsriTimeline.h
@@ -7,6 +7,7 @@
 #include <mutex>
 #include <sstream>
 
+#include "aemu/base/ThreadAnnotations.h"
 #include "host-common/logging.h"
 
 namespace gfxstream {
@@ -17,13 +18,13 @@ class VkQsriTimeline {
     using Callback = std::function<void()>;
 
     void signalNextPresentAndPoll() {
-        std::lock_guard<std::mutex> guard(mLock);
+        std::lock_guard<std::mutex> guard(mMutex);
         mPresentCount++;
         pollLocked();
     }
 
     void registerCallbackForNextPresentAndPoll(Callback callback) {
-        std::lock_guard<std::mutex> guard(mLock);
+        std::lock_guard<std::mutex> guard(mMutex);
         uint64_t requestPresentCount = mRequestPresentCount;
         mRequestPresentCount++;
         mPendingCallbacks.emplace(requestPresentCount, std::move(callback));
@@ -32,7 +33,7 @@ class VkQsriTimeline {
 
     VkQsriTimeline() : mPresentCount(0), mRequestPresentCount(0) {}
     ~VkQsriTimeline() {
-        std::lock_guard<std::mutex> guard(mLock);
+        std::lock_guard<std::mutex> guard(mMutex);
         if (mPendingCallbacks.empty()) {
             return;
         }
@@ -48,12 +49,12 @@ class VkQsriTimeline {
     }
 
    private:
-    std::map<uint64_t, Callback> mPendingCallbacks;
-    std::mutex mLock;
-    uint64_t mPresentCount;
-    uint64_t mRequestPresentCount;
+    std::mutex mMutex;
+    std::map<uint64_t, Callback> mPendingCallbacks GUARDED_BY(mMutex);
+    uint64_t mPresentCount GUARDED_BY(mMutex) = 0;
+    uint64_t mRequestPresentCount GUARDED_BY(mMutex) = 0;
 
-    void pollLocked() {
+    void pollLocked() REQUIRES(mMutex) {
         auto firstPendingCallback = mPendingCallbacks.lower_bound(mPresentCount);
         for (auto readyCallback = mPendingCallbacks.begin(); readyCallback != firstPendingCallback;
              readyCallback++) {
diff --git a/host/vulkan/VkReconstruction.cpp b/host/vulkan/VkReconstruction.cpp
index b8bf3fb51..4a24ea9f8 100644
--- a/host/vulkan/VkReconstruction.cpp
+++ b/host/vulkan/VkReconstruction.cpp
@@ -18,12 +18,20 @@
 #include <unordered_map>
 
 #include "FrameBuffer.h"
-#include "render-utils/IOStream.h"
 #include "VkDecoder.h"
 #include "aemu/base/containers/EntityManager.h"
 
 namespace gfxstream {
 namespace vk {
+namespace {
+
+uint32_t GetOpcode(const VkSnapshotApiCallInfo& info) {
+    if (info.packet.size() <= 4) return -1;
+
+    return *(reinterpret_cast<const uint32_t*>(info.packet.data()));
+}
+
+}  // namespace
 
 #define DEBUG_RECONSTRUCTION 0
 
@@ -58,7 +66,12 @@ std::vector<VkReconstruction::HandleWithState> typeTagSortedHandles(
     return res;
 }
 
-void VkReconstruction::save(android::base::Stream* stream) {
+void VkReconstruction::clear() {
+    mApiCallManager.clear();
+    mHandleReconstructions.clear();
+}
+
+void VkReconstruction::saveReplayBuffers(android::base::Stream* stream) {
     DEBUG_RECON("start")
 
 #if DEBUG_RECONSTRUCTION
@@ -106,13 +119,13 @@ void VkReconstruction::save(android::base::Stream* stream) {
         for (const auto& handle : handles) {
             auto item = mHandleReconstructions.get(handle.first)->states[handle.second];
             for (uint64_t apiRef : item.apiRefs) {
-                auto apiItem = mApiTrace.get(apiRef);
+                auto apiItem = mApiCallManager.get(apiRef);
                 if (!apiItem) continue;
                 if (savedApis.find(apiRef) != savedApis.end()) continue;
                 savedApis.insert(apiRef);
 #if DEBUG_RECONSTRUCTION
                 DEBUG_RECON("adding handle 0x%lx API 0x%lx op code %d", handle.first, apiRef,
-                            apiItem->opCode);
+                            GetOpcode(*apiItem));
 #endif
                 nextApis.push_back(apiRef);
             }
@@ -126,10 +139,8 @@ void VkReconstruction::save(android::base::Stream* stream) {
 
     for (size_t i = 0; i < uniqApiRefsByTopoOrder.size(); ++i) {
         for (auto apiHandle : uniqApiRefsByTopoOrder[i]) {
-            auto item = mApiTrace.get(apiHandle);
-            totalApiTraceSize += 4;                 // opcode
-            totalApiTraceSize += 4;                 // buffer size of trace
-            totalApiTraceSize += item->traceBytes;  // the actual trace
+            const VkSnapshotApiCallInfo* info = mApiCallManager.get(apiHandle);
+            totalApiTraceSize += info->packet.size();
         }
     }
 
@@ -139,7 +150,7 @@ void VkReconstruction::save(android::base::Stream* stream) {
 
     for (size_t i = 0; i < uniqApiRefsByTopoOrder.size(); ++i) {
         for (auto apiHandle : uniqApiRefsByTopoOrder[i]) {
-            auto item = mApiTrace.get(apiHandle);
+            auto item = mApiCallManager.get(apiHandle);
             for (auto createdHandle : item->createdHandles) {
                 DEBUG_RECON("save handle: 0x%lx", createdHandle);
                 createdHandleBuffer.push_back(createdHandle);
@@ -154,128 +165,45 @@ void VkReconstruction::save(android::base::Stream* stream) {
 
     for (size_t i = 0; i < uniqApiRefsByTopoOrder.size(); ++i) {
         for (auto apiHandle : uniqApiRefsByTopoOrder[i]) {
-            auto item = mApiTrace.get(apiHandle);
+            auto item = mApiCallManager.get(apiHandle);
             // 4 bytes for opcode, and 4 bytes for saveBufferRaw's size field
-            DEBUG_RECON("saving api handle 0x%lx op code %d", apiHandle, item->opCode);
-            memcpy(apiTracePtr, &item->opCode, sizeof(uint32_t));
-            apiTracePtr += 4;
-            uint32_t traceBytesForSnapshot = item->traceBytes + 8;
-            memcpy(apiTracePtr, &traceBytesForSnapshot,
-                   sizeof(uint32_t));  // and 8 bytes for 'self' struct of { opcode, packetlen } as
-                                       // that is what decoder expects
-            apiTracePtr += 4;
-            memcpy(apiTracePtr, item->trace.data(), item->traceBytes);
-            apiTracePtr += item->traceBytes;
+            DEBUG_RECON("saving api handle 0x%lx op code %d", apiHandle, GetOpcode(*item));
+            memcpy(apiTracePtr, item->packet.data(), item->packet.size());
+            apiTracePtr += item->packet.size();
         }
     }
 
     DEBUG_RECON("created handle buffer size: %zu trace: %zu", createdHandleBuffer.size(),
                 apiTraceBuffer.size());
 
-    android::base::saveBufferRaw(stream, (char*)(createdHandleBuffer.data()),
-                                 createdHandleBuffer.size() * sizeof(uint64_t));
-    android::base::saveBufferRaw(stream, (char*)(apiTraceBuffer.data()), apiTraceBuffer.size());
+    android::base::saveBuffer(stream, createdHandleBuffer);
+    android::base::saveBuffer(stream, apiTraceBuffer);
 }
 
-class TrivialStream : public IOStream {
-   public:
-    TrivialStream() : IOStream(4) {}
-    virtual ~TrivialStream() = default;
-
-    void* allocBuffer(size_t minSize) {
-        size_t allocSize = (m_bufsize < minSize ? minSize : m_bufsize);
-        if (!m_buf) {
-            m_buf = (unsigned char*)malloc(allocSize);
-        } else if (m_bufsize < allocSize) {
-            unsigned char* p = (unsigned char*)realloc(m_buf, allocSize);
-            if (p != NULL) {
-                m_buf = p;
-                m_bufsize = allocSize;
-            } else {
-                ERR("realloc (%zu) failed", allocSize);
-                free(m_buf);
-                m_buf = NULL;
-                m_bufsize = 0;
-            }
-        }
-
-        return m_buf;
-    }
-
-    int commitBuffer(size_t size) {
-        if (size == 0) return 0;
-        return writeFully(m_buf, size);
-    }
-
-    int writeFully(const void* buf, size_t len) { return 0; }
-
-    const unsigned char* readFully(void* buf, size_t len) { return NULL; }
-
-    virtual void* getDmaForReading(uint64_t guest_paddr) { return nullptr; }
-    virtual void unlockDma(uint64_t guest_paddr) {}
-
-   protected:
-    virtual const unsigned char* readRaw(void* buf, size_t* inout_len) { return nullptr; }
-    virtual void onSave(android::base::Stream* stream) {}
-    virtual unsigned char* onLoad(android::base::Stream* stream) { return nullptr; }
-};
-
-void VkReconstruction::load(android::base::Stream* stream, emugl::GfxApiLogger& gfxLogger,
-                            emugl::HealthMonitor<>* healthMonitor) {
-    DEBUG_RECON("start. assuming VkDecoderGlobalState has been cleared for loading already");
-    mApiTrace.clear();
-    mHandleReconstructions.clear();
-
-    std::vector<uint8_t> createdHandleBuffer;
-    std::vector<uint8_t> apiTraceBuffer;
+/*static*/
+void VkReconstruction::loadReplayBuffers(android::base::Stream* stream,
+                                         std::vector<uint64_t>* outHandleBuffer,
+                                         std::vector<uint8_t>* outDecoderBuffer) {
+    DEBUG_RECON("starting to unpack decoder replay buffer");
 
-    android::base::loadBuffer(stream, &createdHandleBuffer);
-    android::base::loadBuffer(stream, &apiTraceBuffer);
+    android::base::loadBuffer(stream, outHandleBuffer);
+    android::base::loadBuffer(stream, outDecoderBuffer);
 
-    DEBUG_RECON("created handle buffer size: %zu trace: %zu", createdHandleBuffer.size(),
-                apiTraceBuffer.size());
-
-    uint32_t createdHandleBufferSize = createdHandleBuffer.size();
-
-    mLoadedTrace.resize(4 + createdHandleBufferSize + apiTraceBuffer.size());
-
-    unsigned char* finalTraceData = (unsigned char*)(mLoadedTrace.data());
-
-    memcpy(finalTraceData, &createdHandleBufferSize, sizeof(uint32_t));
-    memcpy(finalTraceData + 4, createdHandleBuffer.data(), createdHandleBufferSize);
-    memcpy(finalTraceData + 4 + createdHandleBufferSize, apiTraceBuffer.data(),
-           apiTraceBuffer.size());
-
-    VkDecoder decoderForLoading;
-    // A decoder that is set for snapshot load will load up the created handles first,
-    // if any, allowing us to 'catch' the results as they are decoded.
-    decoderForLoading.setForSnapshotLoad(true);
-    TrivialStream trivialStream;
-
-    DEBUG_RECON("start decoding trace");
-
-    // TODO: This needs to be the puid seqno ptr
-    auto resources = ProcessResources::create();
-    VkDecoderContext context = {
-        .processName = nullptr,
-        .gfxApiLogger = &gfxLogger,
-        .healthMonitor = healthMonitor,
-    };
-    decoderForLoading.decode(mLoadedTrace.data(), mLoadedTrace.size(), &trivialStream, resources.get(),
-                             context);
-
-    DEBUG_RECON("finished decoding trace");
+    DEBUG_RECON("finished unpacking decoder replay buffer");
 }
 
-VkReconstruction::ApiHandle VkReconstruction::createApiInfo() {
-    auto handle = mApiTrace.add(ApiInfo(), 1);
-    return handle;
+VkSnapshotApiCallInfo* VkReconstruction::createApiCallInfo() {
+    VkSnapshotApiCallHandle handle = mApiCallManager.add(VkSnapshotApiCallInfo(), 1);
+
+    auto* info = mApiCallManager.get(handle);
+    info->handle = handle;
+    return info;
 }
 
-void VkReconstruction::removeHandleFromApiInfo(VkReconstruction::ApiHandle h, uint64_t toRemove) {
+void VkReconstruction::removeHandleFromApiInfo(VkSnapshotApiCallHandle h, uint64_t toRemove) {
     auto vk_item = mHandleReconstructions.get(toRemove);
     if (!vk_item) return;
-    auto apiInfo = mApiTrace.get(h);
+    auto apiInfo = mApiCallManager.get(h);
     if (!apiInfo) return;
 
     auto& handles = apiInfo->createdHandles;
@@ -288,29 +216,46 @@ void VkReconstruction::removeHandleFromApiInfo(VkReconstruction::ApiHandle h, ui
                 (unsigned long long)toRemove, (unsigned long long)h, (int)handles.size());
 }
 
-void VkReconstruction::destroyApiInfo(VkReconstruction::ApiHandle h) {
-    auto item = mApiTrace.get(h);
+void VkReconstruction::destroyApiCallInfo(VkSnapshotApiCallHandle h) {
+    auto item = mApiCallManager.get(h);
 
     if (!item) return;
 
     if (!item->createdHandles.empty()) return;
 
-    item->traceBytes = 0;
     item->createdHandles.clear();
 
-    mApiTrace.remove(h);
+    mApiCallManager.remove(h);
 }
 
-VkReconstruction::ApiInfo* VkReconstruction::getApiInfo(VkReconstruction::ApiHandle h) {
-    return mApiTrace.get(h);
+void VkReconstruction::destroyApiCallInfoIfUnused(VkSnapshotApiCallInfo* info) {
+    if (!info) return;
+    auto handle = info->handle;
+    auto currentInfo = mApiCallManager.get(handle);
+    if (!currentInfo) return;
+
+    if (currentInfo->packet.empty()) {
+        mApiCallManager.remove(handle);
+        return;
+    }
+
+    if (!info->extraCreatedHandles.empty()) {
+        currentInfo->createdHandles.insert(currentInfo->createdHandles.end(), info->extraCreatedHandles.begin(),
+                                    info->extraCreatedHandles.end());
+        info->extraCreatedHandles.clear();
+    }
 }
 
-void VkReconstruction::setApiTrace(VkReconstruction::ApiInfo* apiInfo, uint32_t opCode,
-                                   const uint8_t* traceBegin, size_t traceBytes) {
-    if (apiInfo->trace.size() < traceBytes) apiInfo->trace.resize(traceBytes);
-    apiInfo->opCode = opCode;
-    memcpy(apiInfo->trace.data(), traceBegin, traceBytes);
-    apiInfo->traceBytes = traceBytes;
+VkSnapshotApiCallInfo* VkReconstruction::getApiInfo(VkSnapshotApiCallHandle h) {
+    return mApiCallManager.get(h);
+}
+
+void VkReconstruction::setApiTrace(VkSnapshotApiCallInfo* apiInfo, const uint8_t* packet,
+                                   size_t packetLenBytes) {
+    auto* info = mApiCallManager.get(apiInfo->handle);
+    if(info) {
+        info->packet.assign(packet, packet + packetLenBytes);
+    }
 }
 
 void VkReconstruction::dump() {
@@ -318,11 +263,12 @@ void VkReconstruction::dump() {
 
     size_t traceBytesTotal = 0;
 
-    mApiTrace.forEachLiveEntry_const(
-        [&traceBytesTotal](bool live, uint64_t handle, const ApiInfo& info) {
+    mApiCallManager.forEachLiveEntry_const(
+        [&traceBytesTotal](bool live, uint64_t handle, const VkSnapshotApiCallInfo& info) {
+            const uint32_t opcode = GetOpcode(info);
             INFO("VkReconstruction::%s: api handle 0x%llx: %s", __func__,
-                    (unsigned long long)handle, api_opcode_to_string(info.opCode));
-            traceBytesTotal += info.traceBytes;
+                 (unsigned long long)handle, api_opcode_to_string(opcode));
+            traceBytesTotal += info.packet.size();
         });
 
     mHandleReconstructions.forEachLiveComponent_const(
@@ -332,9 +278,9 @@ void VkReconstruction::dump() {
                     (unsigned long long)entityHandle);
             for (const auto& state : reconstruction.states) {
                 for (auto apiHandle : state.apiRefs) {
-                    auto apiInfo = mApiTrace.get(apiHandle);
+                    auto apiInfo = mApiCallManager.get(apiHandle);
                     const char* apiName =
-                        apiInfo ? api_opcode_to_string(apiInfo->opCode) : "unalloced";
+                        apiInfo ? api_opcode_to_string(GetOpcode(*apiInfo)) : "unalloced";
                     INFO("VkReconstruction::%s:     0x%llx: %s", __func__,
                             (unsigned long long)apiHandle, apiName);
                     for (auto createdHandle : apiInfo->createdHandles) {
@@ -351,8 +297,8 @@ void VkReconstruction::dump() {
         INFO("VkReconstruction::%s: mod: %p handle 0x%llx api refs:", __func__, this,
                 (unsigned long long)entityHandle);
         for (auto apiHandle : modification.apiRefs) {
-            auto apiInfo = mApiTrace.get(apiHandle);
-            const char* apiName = apiInfo ? api_opcode_to_string(apiInfo->opCode) : "unalloced";
+            auto apiInfo = mApiCallManager.get(apiHandle);
+            const char* apiName = apiInfo ? api_opcode_to_string(GetOpcode(*apiInfo)) : "unalloced";
             INFO("VkReconstruction::%s: mod:     0x%llx: %s", __func__,
                     (unsigned long long)apiHandle, apiName);
         }
@@ -452,7 +398,7 @@ void VkReconstruction::forEachHandleDeleteApi(const uint64_t* toProcess, uint32_
         for (auto& state : item->states) {
             for (auto handle : state.apiRefs) {
                 removeHandleFromApiInfo(handle, toProcess[i]);
-                destroyApiInfo(handle);
+                destroyApiCallInfo(handle);
             }
             state.apiRefs.clear();
         }
@@ -497,18 +443,11 @@ void VkReconstruction::setCreatedHandlesForApi(uint64_t apiHandle, const uint64_
                                                uint32_t count) {
     if (!created) return;
 
-    auto item = mApiTrace.get(apiHandle);
+    auto item = mApiCallManager.get(apiHandle);
 
     if (!item) return;
 
     item->createdHandles.insert(item->createdHandles.end(), created, created + count);
-    item->createdHandles.insert(item->createdHandles.end(), mExtraHandlesForNextApi.begin(),
-                                mExtraHandlesForNextApi.end());
-    mExtraHandlesForNextApi.clear();
-}
-
-void VkReconstruction::createExtraHandlesForNextApi(const uint64_t* created, uint32_t count) {
-    mExtraHandlesForNextApi.assign(created, created + count);
 }
 
 void VkReconstruction::forEachHandleAddModifyApi(const uint64_t* toProcess, uint32_t count,
diff --git a/host/vulkan/VkReconstruction.h b/host/vulkan/VkReconstruction.h
index 28f7cad11..0bba6267d 100644
--- a/host/vulkan/VkReconstruction.h
+++ b/host/vulkan/VkReconstruction.h
@@ -13,9 +13,9 @@
 // limitations under the License.
 #pragma once
 
+#include "VkSnapshotApiCall.h"
 #include "VulkanHandleMapping.h"
 #include "VulkanHandles.h"
-#include "aemu/base/containers/EntityManager.h"
 #include "aemu/base/HealthMonitor.h"
 #include "aemu/base/files/Stream.h"
 #include "common/goldfish_vk_marshaling.h"
@@ -30,21 +30,12 @@ class VkReconstruction {
    public:
     VkReconstruction();
 
-    void save(android::base::Stream* stream);
-    void load(android::base::Stream* stream, emugl::GfxApiLogger& gfxLogger,
-              emugl::HealthMonitor<>* healthMonitor);
-
-    struct ApiInfo {
-        // Fast
-        uint32_t opCode;
-        std::vector<uint8_t> trace;
-        size_t traceBytes = 0;
-        // Book-keeping for which handles were created by this API
-        std::vector<uint64_t> createdHandles;
-    };
+    void clear();
 
-    using ApiTrace = android::base::EntityManager<32, 16, 16, ApiInfo>;
-    using ApiHandle = ApiTrace::EntityHandle;
+    void saveReplayBuffers(android::base::Stream* stream);
+    static void loadReplayBuffers(android::base::Stream* stream,
+                                  std::vector<uint64_t>* outHandleBuffer,
+                                  std::vector<uint8_t>* outDecoderBuffer);
 
     enum HandleState { BEGIN = 0, CREATED = 0, BOUND_MEMORY = 1, HANDLE_STATE_COUNT };
 
@@ -57,7 +48,7 @@ class VkReconstruction {
     };
 
     struct HandleReconstruction {
-        std::vector<ApiHandle> apiRefs;
+        std::vector<VkSnapshotApiCallHandle> apiRefs;
         std::unordered_set<HandleWithState, HandleWithStateHash> childHandles;
         std::vector<HandleWithState> parentHandles;
     };
@@ -73,42 +64,45 @@ class VkReconstruction {
         android::base::UnpackedComponentManager<32, 16, 16, HandleWithStateReconstruction>;
 
     struct HandleModification {
-        std::vector<ApiHandle> apiRefs;
+        std::vector<VkSnapshotApiCallHandle> apiRefs;
         uint32_t order = 0;
     };
 
     using HandleModifications =
         android::base::UnpackedComponentManager<32, 16, 16, HandleModification>;
 
-    ApiHandle createApiInfo();
-    void destroyApiInfo(ApiHandle h);
+    VkSnapshotApiCallInfo* createApiCallInfo();
+    void destroyApiCallInfo(VkSnapshotApiCallHandle handle);
+    void destroyApiCallInfoIfUnused(VkSnapshotApiCallInfo* info);
 
-    void removeHandleFromApiInfo(ApiHandle h, uint64_t toRemove);
+    void removeHandleFromApiInfo(VkSnapshotApiCallHandle h, uint64_t toRemove);
 
-    ApiInfo* getApiInfo(ApiHandle h);
+    VkSnapshotApiCallInfo* getApiInfo(VkSnapshotApiCallHandle h);
 
-    void setApiTrace(ApiInfo* apiInfo, uint32_t opcode, const uint8_t* traceBegin,
-                     size_t traceBytes);
+    void setApiTrace(VkSnapshotApiCallInfo* apiInfo, const uint8_t* traceBegin, size_t traceBytes);
 
     void dump();
 
     void addHandles(const uint64_t* toAdd, uint32_t count);
     void removeHandles(const uint64_t* toRemove, uint32_t count, bool recursive = true);
 
-    void forEachHandleAddApi(const uint64_t* toProcess, uint32_t count, uint64_t apiHandle,
-                             HandleState state = CREATED);
+    void forEachHandleAddApi(const uint64_t* toProcess, uint32_t count,
+                             uint64_t VkSnapshotApiCallHandle, HandleState state = CREATED);
     void forEachHandleDeleteApi(const uint64_t* toProcess, uint32_t count);
 
     void addHandleDependency(const uint64_t* handles, uint32_t count, uint64_t parentHandle,
                              HandleState childState = CREATED, HandleState parentState = CREATED);
 
-    void setCreatedHandlesForApi(uint64_t apiHandle, const uint64_t* created, uint32_t count);
+    void setCreatedHandlesForApi(VkSnapshotApiCallHandle handle , const uint64_t* created,
+                                 uint32_t count);
 
-    void forEachHandleAddModifyApi(const uint64_t* toProcess, uint32_t count, uint64_t apiHandle);
+    void forEachHandleAddModifyApi(const uint64_t* toProcess, uint32_t count,
+                                   VkSnapshotApiCallHandle handle);
 
     void forEachHandleClearModifyApi(const uint64_t* toProcess, uint32_t count);
 
-    void setModifiedHandlesForApi(uint64_t apiHandle, const uint64_t* modified, uint32_t count);
+    void setModifiedHandlesForApi(VkSnapshotApiCallHandle handle, const uint64_t* modified,
+                                  uint32_t count);
 
     // Used by on_vkCreateDescriptorPool.
     //
@@ -133,13 +127,11 @@ class VkReconstruction {
    private:
     std::vector<uint64_t> getOrderedUniqueModifyApis() const;
 
-    ApiTrace mApiTrace;
+    VkSnapshotApiCallManager mApiCallManager;
 
     HandleWithStateReconstructions mHandleReconstructions;
     HandleModifications mHandleModifications;
 
-    std::vector<uint64_t> mExtraHandlesForNextApi;
-
     std::vector<uint8_t> mLoadedTrace;
 };
 
diff --git a/host/vulkan/VkSnapshotApiCall.h b/host/vulkan/VkSnapshotApiCall.h
new file mode 100644
index 000000000..68fae9c2b
--- /dev/null
+++ b/host/vulkan/VkSnapshotApiCall.h
@@ -0,0 +1,56 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <vector>
+
+#include "aemu/base/containers/EntityManager.h"
+
+namespace gfxstream {
+namespace vk {
+
+using VkSnapshotApiCallHandle = uint64_t;
+
+struct VkSnapshotApiCallInfo {
+    VkSnapshotApiCallHandle handle = -1;
+
+    // Raw packet from VkDecoder.
+    std::vector<uint8_t> packet;
+
+    // Book-keeping for which handles were created by this API
+    std::vector<uint64_t> createdHandles;
+
+    // Extra boxed handles created for this API call that are not identifiable
+    // solely from the API parameters itself. For example, the extra boxed `VkQueue`s
+    // that are created during `vkCreateDevice()` can not be identified from the
+    // parameters to `vkCreateDevice()`.
+    //
+    // TODO: remove this and require that all of the `new_boxed_*()` take a
+    // `VkSnapshotApiCallInfo` as an argument so the creation order of the boxed
+    // handles in `createdHandles` is guaranteed to match the replay order. For now,
+    // this relies on careful manual ordering.
+    std::vector<uint64_t> extraCreatedHandles;
+
+    void addOrderedBoxedHandlesCreatedByCall(const uint64_t* boxedHandles,
+                                             uint32_t boxedHandlesCount) {
+        extraCreatedHandles.insert(extraCreatedHandles.end(), boxedHandles,
+                                   boxedHandles + boxedHandlesCount);
+    }
+};
+
+using VkSnapshotApiCallManager = android::base::EntityManager<32, 16, 16, VkSnapshotApiCallInfo>;
+
+}  // namespace vk
+}  // namespace gfxstream
\ No newline at end of file
diff --git a/host/vulkan/VkSubDecoder.cpp b/host/vulkan/VkSubDecoder.cpp
index d06dfb36c..d218bbe03 100644
--- a/host/vulkan/VkSubDecoder.cpp
+++ b/host/vulkan/VkSubDecoder.cpp
@@ -32,15 +32,17 @@
 //
 #define MAX_STACK_ITEMS 16
 #define MAX_PACKET_LENGTH (400 * 1024 * 1024)  // 400MB
+#define CC_LIKELY(exp) (__builtin_expect(!!(exp), true))
+#define CC_UNLIKELY(exp) (__builtin_expect(!!(exp), false))
 size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* boxed_dispatchHandle,
-                 void* dispatchHandle, VkDeviceSize dataSize, const void* pData,
+                 void* dispatchHandle, VkDeviceSize subDecodeDataSize, const void* pSubDecodeData,
                  const VkDecoderContext& context) {
     auto& metricsLogger = *context.metricsLogger;
     uint32_t count = 0;
-    unsigned char* buf = (unsigned char*)pData;
+    unsigned char* buf = (unsigned char*)pSubDecodeData;
     android::base::BumpPool* pool = readStream->pool();
-    unsigned char* ptr = (unsigned char*)pData;
-    const unsigned char* const end = (const unsigned char*)buf + dataSize;
+    unsigned char* ptr = (unsigned char*)pSubDecodeData;
+    const unsigned char* const end = (const unsigned char*)buf + subDecodeDataSize;
     VkDecoderGlobalState* globalstate = VkDecoderGlobalState::get();
     while (end - ptr >= 8) {
         uint32_t opcode = *(uint32_t*)ptr;
@@ -72,9 +74,12 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCommandBufferBeginInfo(
                         globalstate, (VkCommandBufferBeginInfo*)(pBeginInfo));
                 }
-                VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
-                vkBeginCommandBuffer_VkResult_return = this->on_vkBeginCommandBuffer(
-                    pool, (VkCommandBuffer)(boxed_dispatchHandle), pBeginInfo, context);
+                VkResult vkBeginCommandBuffer_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkBeginCommandBuffer_VkResult_return = this->on_vkBeginCommandBuffer(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), pBeginInfo,
+                        context);
+                }
                 if ((vkBeginCommandBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     this->on_DeviceLost();
                 this->on_CheckOutOfMemory(vkBeginCommandBuffer_VkResult_return, opcode, context);
@@ -83,9 +88,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
             case OP_vkEndCommandBuffer: {
                 GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                       "VkSubDecoder vkEndCommandBuffer");
-                VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
-                vkEndCommandBuffer_VkResult_return = this->on_vkEndCommandBuffer(
-                    pool, (VkCommandBuffer)(boxed_dispatchHandle), context);
+                VkResult vkEndCommandBuffer_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkEndCommandBuffer_VkResult_return = this->on_vkEndCommandBuffer(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), context);
+                }
                 if ((vkEndCommandBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     this->on_DeviceLost();
                 this->on_CheckOutOfMemory(vkEndCommandBuffer_VkResult_return, opcode, context);
@@ -98,9 +105,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr,
                        sizeof(VkCommandBufferResetFlags));
                 *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
-                VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
-                vkResetCommandBuffer_VkResult_return = this->on_vkResetCommandBuffer(
-                    pool, (VkCommandBuffer)(boxed_dispatchHandle), flags);
+                VkResult vkResetCommandBuffer_VkResult_return = VK_ERROR_OUT_OF_HOST_MEMORY;
+                if (CC_LIKELY(vk)) {
+                    vkResetCommandBuffer_VkResult_return = this->on_vkResetCommandBuffer(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), flags);
+                }
                 if ((vkResetCommandBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                     this->on_DeviceLost();
                 this->on_CheckOutOfMemory(vkResetCommandBuffer_VkResult_return, opcode, context);
@@ -118,8 +127,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                 *readStreamPtrPtr += 1 * 8;
                 *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_0));
-                this->on_vkCmdBindPipeline(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                           pipelineBindPoint, pipeline);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdBindPipeline(pool, nullptr,
+                                               (VkCommandBuffer)(boxed_dispatchHandle),
+                                               pipelineBindPoint, pipeline);
+                }
                 break;
             }
             case OP_vkCmdSetViewport: {
@@ -148,8 +160,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkViewport(globalstate, (VkViewport*)(pViewports + i));
                     }
                 }
-                vk->vkCmdSetViewport((VkCommandBuffer)dispatchHandle, firstViewport, viewportCount,
-                                     pViewports);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetViewport((VkCommandBuffer)dispatchHandle, firstViewport,
+                                         viewportCount, pViewports);
+                }
                 break;
             }
             case OP_vkCmdSetScissor: {
@@ -178,8 +192,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkRect2D(globalstate, (VkRect2D*)(pScissors + i));
                     }
                 }
-                vk->vkCmdSetScissor((VkCommandBuffer)dispatchHandle, firstScissor, scissorCount,
-                                    pScissors);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetScissor((VkCommandBuffer)dispatchHandle, firstScissor, scissorCount,
+                                        pScissors);
+                }
                 break;
             }
             case OP_vkCmdSetLineWidth: {
@@ -188,7 +204,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 float lineWidth;
                 memcpy((float*)&lineWidth, *readStreamPtrPtr, sizeof(float));
                 *readStreamPtrPtr += sizeof(float);
-                vk->vkCmdSetLineWidth((VkCommandBuffer)dispatchHandle, lineWidth);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetLineWidth((VkCommandBuffer)dispatchHandle, lineWidth);
+                }
                 break;
             }
             case OP_vkCmdSetDepthBias: {
@@ -203,8 +221,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(float);
                 memcpy((float*)&depthBiasSlopeFactor, *readStreamPtrPtr, sizeof(float));
                 *readStreamPtrPtr += sizeof(float);
-                vk->vkCmdSetDepthBias((VkCommandBuffer)dispatchHandle, depthBiasConstantFactor,
-                                      depthBiasClamp, depthBiasSlopeFactor);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBias((VkCommandBuffer)dispatchHandle, depthBiasConstantFactor,
+                                          depthBiasClamp, depthBiasSlopeFactor);
+                }
                 break;
             }
             case OP_vkCmdSetBlendConstants: {
@@ -213,7 +233,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 float blendConstants[4];
                 memcpy((float*)blendConstants, *readStreamPtrPtr, 4 * sizeof(const float));
                 *readStreamPtrPtr += 4 * sizeof(const float);
-                vk->vkCmdSetBlendConstants((VkCommandBuffer)dispatchHandle, blendConstants);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetBlendConstants((VkCommandBuffer)dispatchHandle, blendConstants);
+                }
                 break;
             }
             case OP_vkCmdSetDepthBounds: {
@@ -225,8 +247,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(float);
                 memcpy((float*)&maxDepthBounds, *readStreamPtrPtr, sizeof(float));
                 *readStreamPtrPtr += sizeof(float);
-                vk->vkCmdSetDepthBounds((VkCommandBuffer)dispatchHandle, minDepthBounds,
-                                        maxDepthBounds);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBounds((VkCommandBuffer)dispatchHandle, minDepthBounds,
+                                            maxDepthBounds);
+                }
                 break;
             }
             case OP_vkCmdSetStencilCompareMask: {
@@ -239,8 +263,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                 memcpy((uint32_t*)&compareMask, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdSetStencilCompareMask((VkCommandBuffer)dispatchHandle, faceMask,
-                                               compareMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilCompareMask((VkCommandBuffer)dispatchHandle, faceMask,
+                                                   compareMask);
+                }
                 break;
             }
             case OP_vkCmdSetStencilWriteMask: {
@@ -253,7 +279,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                 memcpy((uint32_t*)&writeMask, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdSetStencilWriteMask((VkCommandBuffer)dispatchHandle, faceMask, writeMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilWriteMask((VkCommandBuffer)dispatchHandle, faceMask,
+                                                 writeMask);
+                }
                 break;
             }
             case OP_vkCmdSetStencilReference: {
@@ -266,7 +295,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                 memcpy((uint32_t*)&reference, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdSetStencilReference((VkCommandBuffer)dispatchHandle, faceMask, reference);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilReference((VkCommandBuffer)dispatchHandle, faceMask,
+                                                 reference);
+                }
                 break;
             }
             case OP_vkCmdBindDescriptorSets: {
@@ -321,10 +353,12 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((uint32_t*)pDynamicOffsets, *readStreamPtrPtr,
                        ((dynamicOffsetCount)) * sizeof(const uint32_t));
                 *readStreamPtrPtr += ((dynamicOffsetCount)) * sizeof(const uint32_t);
-                this->on_vkCmdBindDescriptorSets(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                                 pipelineBindPoint, layout, firstSet,
-                                                 descriptorSetCount, pDescriptorSets,
-                                                 dynamicOffsetCount, pDynamicOffsets);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdBindDescriptorSets(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), pipelineBindPoint,
+                        layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount,
+                        pDynamicOffsets);
+                }
                 break;
             }
             case OP_vkCmdBindIndexBuffer: {
@@ -341,8 +375,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkDeviceSize);
                 memcpy((VkIndexType*)&indexType, *readStreamPtrPtr, sizeof(VkIndexType));
                 *readStreamPtrPtr += sizeof(VkIndexType);
-                vk->vkCmdBindIndexBuffer((VkCommandBuffer)dispatchHandle, buffer, offset,
-                                         indexType);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindIndexBuffer((VkCommandBuffer)dispatchHandle, buffer, offset,
+                                             indexType);
+                }
                 break;
             }
             case OP_vkCmdBindVertexBuffers: {
@@ -382,8 +418,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkDeviceSize*)pOffsets, *readStreamPtrPtr,
                        ((bindingCount)) * sizeof(const VkDeviceSize));
                 *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
-                vk->vkCmdBindVertexBuffers((VkCommandBuffer)dispatchHandle, firstBinding,
-                                           bindingCount, pBuffers, pOffsets);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindVertexBuffers((VkCommandBuffer)dispatchHandle, firstBinding,
+                                               bindingCount, pBuffers, pOffsets);
+                }
                 break;
             }
             case OP_vkCmdDraw: {
@@ -400,8 +438,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdDraw((VkCommandBuffer)dispatchHandle, vertexCount, instanceCount,
-                              firstVertex, firstInstance);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDraw((VkCommandBuffer)dispatchHandle, vertexCount, instanceCount,
+                                  firstVertex, firstInstance);
+                }
                 break;
             }
             case OP_vkCmdDrawIndexed: {
@@ -422,8 +462,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(int32_t);
                 memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdDrawIndexed((VkCommandBuffer)dispatchHandle, indexCount, instanceCount,
-                                     firstIndex, vertexOffset, firstInstance);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndexed((VkCommandBuffer)dispatchHandle, indexCount, instanceCount,
+                                         firstIndex, vertexOffset, firstInstance);
+                }
                 break;
             }
             case OP_vkCmdDrawIndirect: {
@@ -443,8 +485,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdDrawIndirect((VkCommandBuffer)dispatchHandle, buffer, offset, drawCount,
-                                      stride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndirect((VkCommandBuffer)dispatchHandle, buffer, offset,
+                                          drawCount, stride);
+                }
                 break;
             }
             case OP_vkCmdDrawIndexedIndirect: {
@@ -464,8 +508,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdDrawIndexedIndirect((VkCommandBuffer)dispatchHandle, buffer, offset,
-                                             drawCount, stride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndexedIndirect((VkCommandBuffer)dispatchHandle, buffer, offset,
+                                                 drawCount, stride);
+                }
                 break;
             }
             case OP_vkCmdDispatch: {
@@ -480,8 +526,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdDispatch((VkCommandBuffer)dispatchHandle, groupCountX, groupCountY,
-                                  groupCountZ);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDispatch((VkCommandBuffer)dispatchHandle, groupCountX, groupCountY,
+                                      groupCountZ);
+                }
                 break;
             }
             case OP_vkCmdDispatchIndirect: {
@@ -495,7 +543,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                 memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                 *readStreamPtrPtr += sizeof(VkDeviceSize);
-                vk->vkCmdDispatchIndirect((VkCommandBuffer)dispatchHandle, buffer, offset);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDispatchIndirect((VkCommandBuffer)dispatchHandle, buffer, offset);
+                }
                 break;
             }
             case OP_vkCmdCopyBuffer: {
@@ -531,8 +581,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkBufferCopy(globalstate, (VkBufferCopy*)(pRegions + i));
                     }
                 }
-                vk->vkCmdCopyBuffer((VkCommandBuffer)dispatchHandle, srcBuffer, dstBuffer,
-                                    regionCount, pRegions);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdCopyBuffer((VkCommandBuffer)dispatchHandle, srcBuffer, dstBuffer,
+                                        regionCount, pRegions);
+                }
                 break;
             }
             case OP_vkCmdCopyImage: {
@@ -574,9 +626,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkImageCopy(globalstate, (VkImageCopy*)(pRegions + i));
                     }
                 }
-                this->on_vkCmdCopyImage(pool, (VkCommandBuffer)(boxed_dispatchHandle), srcImage,
-                                        srcImageLayout, dstImage, dstImageLayout, regionCount,
-                                        pRegions);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyImage(pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle),
+                                            srcImage, srcImageLayout, dstImage, dstImageLayout,
+                                            regionCount, pRegions);
+                }
                 break;
             }
             case OP_vkCmdBlitImage: {
@@ -621,8 +675,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkImageBlit(globalstate, (VkImageBlit*)(pRegions + i));
                     }
                 }
-                vk->vkCmdBlitImage((VkCommandBuffer)dispatchHandle, srcImage, srcImageLayout,
-                                   dstImage, dstImageLayout, regionCount, pRegions, filter);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBlitImage((VkCommandBuffer)dispatchHandle, srcImage, srcImageLayout,
+                                       dstImage, dstImageLayout, regionCount, pRegions, filter);
+                }
                 break;
             }
             case OP_vkCmdCopyBufferToImage: {
@@ -663,9 +719,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                                                            (VkBufferImageCopy*)(pRegions + i));
                     }
                 }
-                this->on_vkCmdCopyBufferToImage(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                                srcBuffer, dstImage, dstImageLayout, regionCount,
-                                                pRegions, context);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyBufferToImage(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), srcBuffer, dstImage,
+                        dstImageLayout, regionCount, pRegions, context);
+                }
                 break;
             }
             case OP_vkCmdCopyImageToBuffer: {
@@ -706,9 +764,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                                                            (VkBufferImageCopy*)(pRegions + i));
                     }
                 }
-                this->on_vkCmdCopyImageToBuffer(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                                srcImage, srcImageLayout, dstBuffer, regionCount,
-                                                pRegions);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyImageToBuffer(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), srcImage,
+                        srcImageLayout, dstBuffer, regionCount, pRegions);
+                }
                 break;
             }
             case OP_vkCmdUpdateBuffer: {
@@ -734,8 +794,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 }
                 memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(const uint8_t));
                 *readStreamPtrPtr += ((dataSize)) * sizeof(const uint8_t);
-                vk->vkCmdUpdateBuffer((VkCommandBuffer)dispatchHandle, dstBuffer, dstOffset,
-                                      dataSize, pData);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdUpdateBuffer((VkCommandBuffer)dispatchHandle, dstBuffer, dstOffset,
+                                          dataSize, pData);
+                }
                 break;
             }
             case OP_vkCmdFillBuffer: {
@@ -755,8 +817,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkDeviceSize);
                 memcpy((uint32_t*)&data, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdFillBuffer((VkCommandBuffer)dispatchHandle, dstBuffer, dstOffset, size,
-                                    data);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdFillBuffer((VkCommandBuffer)dispatchHandle, dstBuffer, dstOffset, size,
+                                        data);
+                }
                 break;
             }
             case OP_vkCmdClearColorImage: {
@@ -800,8 +864,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                             globalstate, (VkImageSubresourceRange*)(pRanges + i));
                     }
                 }
-                vk->vkCmdClearColorImage((VkCommandBuffer)dispatchHandle, image, imageLayout,
-                                         pColor, rangeCount, pRanges);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdClearColorImage((VkCommandBuffer)dispatchHandle, image, imageLayout,
+                                             pColor, rangeCount, pRanges);
+                }
                 break;
             }
             case OP_vkCmdClearDepthStencilImage: {
@@ -847,8 +913,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                             globalstate, (VkImageSubresourceRange*)(pRanges + i));
                     }
                 }
-                vk->vkCmdClearDepthStencilImage((VkCommandBuffer)dispatchHandle, image, imageLayout,
-                                                pDepthStencil, rangeCount, pRanges);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdClearDepthStencilImage((VkCommandBuffer)dispatchHandle, image,
+                                                    imageLayout, pDepthStencil, rangeCount,
+                                                    pRanges);
+                }
                 break;
             }
             case OP_vkCmdClearAttachments: {
@@ -895,8 +964,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkClearRect(globalstate, (VkClearRect*)(pRects + i));
                     }
                 }
-                vk->vkCmdClearAttachments((VkCommandBuffer)dispatchHandle, attachmentCount,
-                                          pAttachments, rectCount, pRects);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdClearAttachments((VkCommandBuffer)dispatchHandle, attachmentCount,
+                                              pAttachments, rectCount, pRects);
+                }
                 break;
             }
             case OP_vkCmdResolveImage: {
@@ -940,8 +1011,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                                                         (VkImageResolve*)(pRegions + i));
                     }
                 }
-                vk->vkCmdResolveImage((VkCommandBuffer)dispatchHandle, srcImage, srcImageLayout,
-                                      dstImage, dstImageLayout, regionCount, pRegions);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResolveImage((VkCommandBuffer)dispatchHandle, srcImage, srcImageLayout,
+                                          dstImage, dstImageLayout, regionCount, pRegions);
+                }
                 break;
             }
             case OP_vkCmdSetEvent: {
@@ -956,7 +1029,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkPipelineStageFlags*)&stageMask, *readStreamPtrPtr,
                        sizeof(VkPipelineStageFlags));
                 *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
-                vk->vkCmdSetEvent((VkCommandBuffer)dispatchHandle, event, stageMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetEvent((VkCommandBuffer)dispatchHandle, event, stageMask);
+                }
                 break;
             }
             case OP_vkCmdResetEvent: {
@@ -971,7 +1046,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkPipelineStageFlags*)&stageMask, *readStreamPtrPtr,
                        sizeof(VkPipelineStageFlags));
                 *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
-                vk->vkCmdResetEvent((VkCommandBuffer)dispatchHandle, event, stageMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResetEvent((VkCommandBuffer)dispatchHandle, event, stageMask);
+                }
                 break;
             }
             case OP_vkCmdWaitEvents: {
@@ -1073,10 +1150,12 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                             globalstate, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                     }
                 }
-                vk->vkCmdWaitEvents((VkCommandBuffer)dispatchHandle, eventCount, pEvents,
-                                    srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers,
-                                    bufferMemoryBarrierCount, pBufferMemoryBarriers,
-                                    imageMemoryBarrierCount, pImageMemoryBarriers);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWaitEvents(
+                        (VkCommandBuffer)dispatchHandle, eventCount, pEvents, srcStageMask,
+                        dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount,
+                        pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
+                }
                 break;
             }
             case OP_vkCmdPipelineBarrier: {
@@ -1162,10 +1241,13 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                             globalstate, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                     }
                 }
-                this->on_vkCmdPipelineBarrier(
-                    pool, (VkCommandBuffer)(boxed_dispatchHandle), srcStageMask, dstStageMask,
-                    dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount,
-                    pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdPipelineBarrier(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), srcStageMask,
+                        dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers,
+                        bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount,
+                        pImageMemoryBarriers);
+                }
                 break;
             }
             case OP_vkCmdBeginQuery: {
@@ -1184,7 +1266,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkQueryControlFlags*)&flags, *readStreamPtrPtr,
                        sizeof(VkQueryControlFlags));
                 *readStreamPtrPtr += sizeof(VkQueryControlFlags);
-                vk->vkCmdBeginQuery((VkCommandBuffer)dispatchHandle, queryPool, query, flags);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginQuery((VkCommandBuffer)dispatchHandle, queryPool, query, flags);
+                }
                 break;
             }
             case OP_vkCmdEndQuery: {
@@ -1199,7 +1283,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                 memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdEndQuery((VkCommandBuffer)dispatchHandle, queryPool, query);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndQuery((VkCommandBuffer)dispatchHandle, queryPool, query);
+                }
                 break;
             }
             case OP_vkCmdResetQueryPool: {
@@ -1217,8 +1303,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdResetQueryPool((VkCommandBuffer)dispatchHandle, queryPool, firstQuery,
-                                        queryCount);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResetQueryPool((VkCommandBuffer)dispatchHandle, queryPool, firstQuery,
+                                            queryCount);
+                }
                 break;
             }
             case OP_vkCmdWriteTimestamp: {
@@ -1237,8 +1325,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                 memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdWriteTimestamp((VkCommandBuffer)dispatchHandle, pipelineStage, queryPool,
-                                        query);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWriteTimestamp((VkCommandBuffer)dispatchHandle, pipelineStage,
+                                            queryPool, query);
+                }
                 break;
             }
             case OP_vkCmdCopyQueryPoolResults: {
@@ -1270,9 +1360,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkDeviceSize);
                 memcpy((VkQueryResultFlags*)&flags, *readStreamPtrPtr, sizeof(VkQueryResultFlags));
                 *readStreamPtrPtr += sizeof(VkQueryResultFlags);
-                this->on_vkCmdCopyQueryPoolResults(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                                   queryPool, firstQuery, queryCount, dstBuffer,
-                                                   dstOffset, stride, flags);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyQueryPoolResults(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), queryPool,
+                        firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
+                }
                 break;
             }
             case OP_vkCmdPushConstants: {
@@ -1303,8 +1395,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 }
                 memcpy((void*)pValues, *readStreamPtrPtr, ((size)) * sizeof(const uint8_t));
                 *readStreamPtrPtr += ((size)) * sizeof(const uint8_t);
-                vk->vkCmdPushConstants((VkCommandBuffer)dispatchHandle, layout, stageFlags, offset,
-                                       size, pValues);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdPushConstants((VkCommandBuffer)dispatchHandle, layout, stageFlags,
+                                           offset, size, pValues);
+                }
                 break;
             }
             case OP_vkCmdBeginRenderPass: {
@@ -1323,8 +1417,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkRenderPassBeginInfo(
                         globalstate, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                 }
-                this->on_vkCmdBeginRenderPass(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                              pRenderPassBegin, contents);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdBeginRenderPass(pool, nullptr,
+                                                  (VkCommandBuffer)(boxed_dispatchHandle),
+                                                  pRenderPassBegin, contents);
+                }
                 break;
             }
             case OP_vkCmdNextSubpass: {
@@ -1333,13 +1430,17 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkSubpassContents contents;
                 memcpy((VkSubpassContents*)&contents, *readStreamPtrPtr, sizeof(VkSubpassContents));
                 *readStreamPtrPtr += sizeof(VkSubpassContents);
-                vk->vkCmdNextSubpass((VkCommandBuffer)dispatchHandle, contents);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdNextSubpass((VkCommandBuffer)dispatchHandle, contents);
+                }
                 break;
             }
             case OP_vkCmdEndRenderPass: {
                 GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                       "VkSubDecoder vkCmdEndRenderPass");
-                vk->vkCmdEndRenderPass((VkCommandBuffer)dispatchHandle);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRenderPass((VkCommandBuffer)dispatchHandle);
+                }
                 break;
             }
             case OP_vkCmdExecuteCommands: {
@@ -1367,8 +1468,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                                    : VK_NULL_HANDLE;
                     }
                 }
-                this->on_vkCmdExecuteCommands(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                              commandBufferCount, pCommandBuffers);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdExecuteCommands(pool, nullptr,
+                                                  (VkCommandBuffer)(boxed_dispatchHandle),
+                                                  commandBufferCount, pCommandBuffers);
+                }
                 break;
             }
 #endif
@@ -1379,7 +1483,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 uint32_t deviceMask;
                 memcpy((uint32_t*)&deviceMask, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdSetDeviceMask((VkCommandBuffer)dispatchHandle, deviceMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDeviceMask((VkCommandBuffer)dispatchHandle, deviceMask);
+                }
                 break;
             }
             case OP_vkCmdDispatchBase: {
@@ -1403,8 +1509,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdDispatchBase((VkCommandBuffer)dispatchHandle, baseGroupX, baseGroupY,
-                                      baseGroupZ, groupCountX, groupCountY, groupCountZ);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDispatchBase((VkCommandBuffer)dispatchHandle, baseGroupX, baseGroupY,
+                                          baseGroupZ, groupCountX, groupCountY, groupCountZ);
+                }
                 break;
             }
 #endif
@@ -1434,8 +1542,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdDrawIndirectCount((VkCommandBuffer)dispatchHandle, buffer, offset,
-                                           countBuffer, countBufferOffset, maxDrawCount, stride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndirectCount((VkCommandBuffer)dispatchHandle, buffer, offset,
+                                               countBuffer, countBufferOffset, maxDrawCount,
+                                               stride);
+                }
                 break;
             }
             case OP_vkCmdDrawIndexedIndirectCount: {
@@ -1463,9 +1574,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdDrawIndexedIndirectCount((VkCommandBuffer)dispatchHandle, buffer, offset,
-                                                  countBuffer, countBufferOffset, maxDrawCount,
-                                                  stride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndexedIndirectCount((VkCommandBuffer)dispatchHandle, buffer,
+                                                      offset, countBuffer, countBufferOffset,
+                                                      maxDrawCount, stride);
+                }
                 break;
             }
             case OP_vkCmdBeginRenderPass2: {
@@ -1491,8 +1604,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkSubpassBeginInfo(globalstate,
                                                         (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                 }
-                this->on_vkCmdBeginRenderPass2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                               pRenderPassBegin, pSubpassBeginInfo);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdBeginRenderPass2(pool, nullptr,
+                                                   (VkCommandBuffer)(boxed_dispatchHandle),
+                                                   pRenderPassBegin, pSubpassBeginInfo);
+                }
                 break;
             }
             case OP_vkCmdNextSubpass2: {
@@ -1518,8 +1634,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkSubpassEndInfo(globalstate,
                                                       (VkSubpassEndInfo*)(pSubpassEndInfo));
                 }
-                vk->vkCmdNextSubpass2((VkCommandBuffer)dispatchHandle, pSubpassBeginInfo,
-                                      pSubpassEndInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdNextSubpass2((VkCommandBuffer)dispatchHandle, pSubpassBeginInfo,
+                                          pSubpassEndInfo);
+                }
                 break;
             }
             case OP_vkCmdEndRenderPass2: {
@@ -1535,7 +1653,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkSubpassEndInfo(globalstate,
                                                       (VkSubpassEndInfo*)(pSubpassEndInfo));
                 }
-                vk->vkCmdEndRenderPass2((VkCommandBuffer)dispatchHandle, pSubpassEndInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRenderPass2((VkCommandBuffer)dispatchHandle, pSubpassEndInfo);
+                }
                 break;
             }
 #endif
@@ -1558,7 +1678,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkDependencyInfo(globalstate,
                                                       (VkDependencyInfo*)(pDependencyInfo));
                 }
-                vk->vkCmdSetEvent2((VkCommandBuffer)dispatchHandle, event, pDependencyInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetEvent2((VkCommandBuffer)dispatchHandle, event, pDependencyInfo);
+                }
                 break;
             }
             case OP_vkCmdResetEvent2: {
@@ -1573,7 +1695,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkPipelineStageFlags2*)&stageMask, *readStreamPtrPtr,
                        sizeof(VkPipelineStageFlags2));
                 *readStreamPtrPtr += sizeof(VkPipelineStageFlags2);
-                vk->vkCmdResetEvent2((VkCommandBuffer)dispatchHandle, event, stageMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResetEvent2((VkCommandBuffer)dispatchHandle, event, stageMask);
+                }
                 break;
             }
             case OP_vkCmdWaitEvents2: {
@@ -1618,8 +1742,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                             globalstate, (VkDependencyInfo*)(pDependencyInfos + i));
                     }
                 }
-                vk->vkCmdWaitEvents2((VkCommandBuffer)dispatchHandle, eventCount, pEvents,
-                                     pDependencyInfos);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWaitEvents2((VkCommandBuffer)dispatchHandle, eventCount, pEvents,
+                                         pDependencyInfos);
+                }
                 break;
             }
             case OP_vkCmdPipelineBarrier2: {
@@ -1635,8 +1761,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkDependencyInfo(globalstate,
                                                       (VkDependencyInfo*)(pDependencyInfo));
                 }
-                this->on_vkCmdPipelineBarrier2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                               pDependencyInfo);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdPipelineBarrier2(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), pDependencyInfo);
+                }
                 break;
             }
             case OP_vkCmdWriteTimestamp2: {
@@ -1655,7 +1783,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                 memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdWriteTimestamp2((VkCommandBuffer)dispatchHandle, stage, queryPool, query);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWriteTimestamp2((VkCommandBuffer)dispatchHandle, stage, queryPool,
+                                             query);
+                }
                 break;
             }
             case OP_vkCmdCopyBuffer2: {
@@ -1671,7 +1802,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCopyBufferInfo2(globalstate,
                                                        (VkCopyBufferInfo2*)(pCopyBufferInfo));
                 }
-                vk->vkCmdCopyBuffer2((VkCommandBuffer)dispatchHandle, pCopyBufferInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdCopyBuffer2((VkCommandBuffer)dispatchHandle, pCopyBufferInfo);
+                }
                 break;
             }
             case OP_vkCmdCopyImage2: {
@@ -1687,8 +1820,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCopyImageInfo2(globalstate,
                                                       (VkCopyImageInfo2*)(pCopyImageInfo));
                 }
-                this->on_vkCmdCopyImage2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                         pCopyImageInfo);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyImage2(pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle),
+                                             pCopyImageInfo);
+                }
                 break;
             }
             case OP_vkCmdCopyBufferToImage2: {
@@ -1704,8 +1839,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCopyBufferToImageInfo2(
                         globalstate, (VkCopyBufferToImageInfo2*)(pCopyBufferToImageInfo));
                 }
-                this->on_vkCmdCopyBufferToImage2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                                 pCopyBufferToImageInfo, context);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyBufferToImage2(pool, nullptr,
+                                                     (VkCommandBuffer)(boxed_dispatchHandle),
+                                                     pCopyBufferToImageInfo, context);
+                }
                 break;
             }
             case OP_vkCmdCopyImageToBuffer2: {
@@ -1721,8 +1859,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCopyImageToBufferInfo2(
                         globalstate, (VkCopyImageToBufferInfo2*)(pCopyImageToBufferInfo));
                 }
-                this->on_vkCmdCopyImageToBuffer2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                                 pCopyImageToBufferInfo);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyImageToBuffer2(pool, nullptr,
+                                                     (VkCommandBuffer)(boxed_dispatchHandle),
+                                                     pCopyImageToBufferInfo);
+                }
                 break;
             }
             case OP_vkCmdBlitImage2: {
@@ -1738,7 +1879,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkBlitImageInfo2(globalstate,
                                                       (VkBlitImageInfo2*)(pBlitImageInfo));
                 }
-                vk->vkCmdBlitImage2((VkCommandBuffer)dispatchHandle, pBlitImageInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBlitImage2((VkCommandBuffer)dispatchHandle, pBlitImageInfo);
+                }
                 break;
             }
             case OP_vkCmdResolveImage2: {
@@ -1754,7 +1897,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkResolveImageInfo2(globalstate,
                                                          (VkResolveImageInfo2*)(pResolveImageInfo));
                 }
-                vk->vkCmdResolveImage2((VkCommandBuffer)dispatchHandle, pResolveImageInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResolveImage2((VkCommandBuffer)dispatchHandle, pResolveImageInfo);
+                }
                 break;
             }
             case OP_vkCmdBeginRendering: {
@@ -1770,13 +1915,17 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkRenderingInfo(globalstate,
                                                      (VkRenderingInfo*)(pRenderingInfo));
                 }
-                vk->vkCmdBeginRendering((VkCommandBuffer)dispatchHandle, pRenderingInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginRendering((VkCommandBuffer)dispatchHandle, pRenderingInfo);
+                }
                 break;
             }
             case OP_vkCmdEndRendering: {
                 GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                       "VkSubDecoder vkCmdEndRendering");
-                vk->vkCmdEndRendering((VkCommandBuffer)dispatchHandle);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRendering((VkCommandBuffer)dispatchHandle);
+                }
                 break;
             }
             case OP_vkCmdSetCullMode: {
@@ -1785,7 +1934,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkCullModeFlags cullMode;
                 memcpy((VkCullModeFlags*)&cullMode, *readStreamPtrPtr, sizeof(VkCullModeFlags));
                 *readStreamPtrPtr += sizeof(VkCullModeFlags);
-                vk->vkCmdSetCullMode((VkCommandBuffer)dispatchHandle, cullMode);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetCullMode((VkCommandBuffer)dispatchHandle, cullMode);
+                }
                 break;
             }
             case OP_vkCmdSetFrontFace: {
@@ -1794,7 +1945,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkFrontFace frontFace;
                 memcpy((VkFrontFace*)&frontFace, *readStreamPtrPtr, sizeof(VkFrontFace));
                 *readStreamPtrPtr += sizeof(VkFrontFace);
-                vk->vkCmdSetFrontFace((VkCommandBuffer)dispatchHandle, frontFace);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetFrontFace((VkCommandBuffer)dispatchHandle, frontFace);
+                }
                 break;
             }
             case OP_vkCmdSetPrimitiveTopology: {
@@ -1804,7 +1957,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkPrimitiveTopology*)&primitiveTopology, *readStreamPtrPtr,
                        sizeof(VkPrimitiveTopology));
                 *readStreamPtrPtr += sizeof(VkPrimitiveTopology);
-                vk->vkCmdSetPrimitiveTopology((VkCommandBuffer)dispatchHandle, primitiveTopology);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPrimitiveTopology((VkCommandBuffer)dispatchHandle,
+                                                  primitiveTopology);
+                }
                 break;
             }
             case OP_vkCmdSetViewportWithCount: {
@@ -1830,8 +1986,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkViewport(globalstate, (VkViewport*)(pViewports + i));
                     }
                 }
-                vk->vkCmdSetViewportWithCount((VkCommandBuffer)dispatchHandle, viewportCount,
-                                              pViewports);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetViewportWithCount((VkCommandBuffer)dispatchHandle, viewportCount,
+                                                  pViewports);
+                }
                 break;
             }
             case OP_vkCmdSetScissorWithCount: {
@@ -1857,8 +2015,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkRect2D(globalstate, (VkRect2D*)(pScissors + i));
                     }
                 }
-                vk->vkCmdSetScissorWithCount((VkCommandBuffer)dispatchHandle, scissorCount,
-                                             pScissors);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetScissorWithCount((VkCommandBuffer)dispatchHandle, scissorCount,
+                                                 pScissors);
+                }
                 break;
             }
             case OP_vkCmdBindVertexBuffers2: {
@@ -1940,8 +2100,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                            ((bindingCount)) * sizeof(const VkDeviceSize));
                     *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                 }
-                vk->vkCmdBindVertexBuffers2((VkCommandBuffer)dispatchHandle, firstBinding,
-                                            bindingCount, pBuffers, pOffsets, pSizes, pStrides);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindVertexBuffers2((VkCommandBuffer)dispatchHandle, firstBinding,
+                                                bindingCount, pBuffers, pOffsets, pSizes, pStrides);
+                }
                 break;
             }
             case OP_vkCmdSetDepthTestEnable: {
@@ -1950,7 +2112,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 depthTestEnable;
                 memcpy((VkBool32*)&depthTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetDepthTestEnable((VkCommandBuffer)dispatchHandle, depthTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthTestEnable((VkCommandBuffer)dispatchHandle, depthTestEnable);
+                }
                 break;
             }
             case OP_vkCmdSetDepthWriteEnable: {
@@ -1959,7 +2123,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 depthWriteEnable;
                 memcpy((VkBool32*)&depthWriteEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetDepthWriteEnable((VkCommandBuffer)dispatchHandle, depthWriteEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthWriteEnable((VkCommandBuffer)dispatchHandle, depthWriteEnable);
+                }
                 break;
             }
             case OP_vkCmdSetDepthCompareOp: {
@@ -1968,7 +2134,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkCompareOp depthCompareOp;
                 memcpy((VkCompareOp*)&depthCompareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                 *readStreamPtrPtr += sizeof(VkCompareOp);
-                vk->vkCmdSetDepthCompareOp((VkCommandBuffer)dispatchHandle, depthCompareOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthCompareOp((VkCommandBuffer)dispatchHandle, depthCompareOp);
+                }
                 break;
             }
             case OP_vkCmdSetDepthBoundsTestEnable: {
@@ -1977,8 +2145,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 depthBoundsTestEnable;
                 memcpy((VkBool32*)&depthBoundsTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetDepthBoundsTestEnable((VkCommandBuffer)dispatchHandle,
-                                                  depthBoundsTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBoundsTestEnable((VkCommandBuffer)dispatchHandle,
+                                                      depthBoundsTestEnable);
+                }
                 break;
             }
             case OP_vkCmdSetStencilTestEnable: {
@@ -1987,7 +2157,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 stencilTestEnable;
                 memcpy((VkBool32*)&stencilTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetStencilTestEnable((VkCommandBuffer)dispatchHandle, stencilTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilTestEnable((VkCommandBuffer)dispatchHandle,
+                                                  stencilTestEnable);
+                }
                 break;
             }
             case OP_vkCmdSetStencilOp: {
@@ -2009,8 +2182,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkStencilOp);
                 memcpy((VkCompareOp*)&compareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                 *readStreamPtrPtr += sizeof(VkCompareOp);
-                vk->vkCmdSetStencilOp((VkCommandBuffer)dispatchHandle, faceMask, failOp, passOp,
-                                      depthFailOp, compareOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilOp((VkCommandBuffer)dispatchHandle, faceMask, failOp, passOp,
+                                          depthFailOp, compareOp);
+                }
                 break;
             }
             case OP_vkCmdSetRasterizerDiscardEnable: {
@@ -2019,8 +2194,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 rasterizerDiscardEnable;
                 memcpy((VkBool32*)&rasterizerDiscardEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetRasterizerDiscardEnable((VkCommandBuffer)dispatchHandle,
-                                                    rasterizerDiscardEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetRasterizerDiscardEnable((VkCommandBuffer)dispatchHandle,
+                                                        rasterizerDiscardEnable);
+                }
                 break;
             }
             case OP_vkCmdSetDepthBiasEnable: {
@@ -2029,7 +2206,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 depthBiasEnable;
                 memcpy((VkBool32*)&depthBiasEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetDepthBiasEnable((VkCommandBuffer)dispatchHandle, depthBiasEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBiasEnable((VkCommandBuffer)dispatchHandle, depthBiasEnable);
+                }
                 break;
             }
             case OP_vkCmdSetPrimitiveRestartEnable: {
@@ -2038,8 +2217,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 primitiveRestartEnable;
                 memcpy((VkBool32*)&primitiveRestartEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetPrimitiveRestartEnable((VkCommandBuffer)dispatchHandle,
-                                                   primitiveRestartEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPrimitiveRestartEnable((VkCommandBuffer)dispatchHandle,
+                                                       primitiveRestartEnable);
+                }
                 break;
             }
 #endif
@@ -2057,13 +2238,17 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkRenderingInfo(globalstate,
                                                      (VkRenderingInfo*)(pRenderingInfo));
                 }
-                vk->vkCmdBeginRenderingKHR((VkCommandBuffer)dispatchHandle, pRenderingInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginRenderingKHR((VkCommandBuffer)dispatchHandle, pRenderingInfo);
+                }
                 break;
             }
             case OP_vkCmdEndRenderingKHR: {
                 GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                       "VkSubDecoder vkCmdEndRenderingKHR");
-                vk->vkCmdEndRenderingKHR((VkCommandBuffer)dispatchHandle);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRenderingKHR((VkCommandBuffer)dispatchHandle);
+                }
                 break;
             }
 #endif
@@ -2091,8 +2276,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkSubpassBeginInfo(globalstate,
                                                         (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                 }
-                this->on_vkCmdBeginRenderPass2KHR(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                                  pRenderPassBegin, pSubpassBeginInfo);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdBeginRenderPass2KHR(pool, nullptr,
+                                                      (VkCommandBuffer)(boxed_dispatchHandle),
+                                                      pRenderPassBegin, pSubpassBeginInfo);
+                }
                 break;
             }
             case OP_vkCmdNextSubpass2KHR: {
@@ -2118,8 +2306,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkSubpassEndInfo(globalstate,
                                                       (VkSubpassEndInfo*)(pSubpassEndInfo));
                 }
-                vk->vkCmdNextSubpass2KHR((VkCommandBuffer)dispatchHandle, pSubpassBeginInfo,
-                                         pSubpassEndInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdNextSubpass2KHR((VkCommandBuffer)dispatchHandle, pSubpassBeginInfo,
+                                             pSubpassEndInfo);
+                }
                 break;
             }
             case OP_vkCmdEndRenderPass2KHR: {
@@ -2135,7 +2325,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkSubpassEndInfo(globalstate,
                                                       (VkSubpassEndInfo*)(pSubpassEndInfo));
                 }
-                vk->vkCmdEndRenderPass2KHR((VkCommandBuffer)dispatchHandle, pSubpassEndInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndRenderPass2KHR((VkCommandBuffer)dispatchHandle, pSubpassEndInfo);
+                }
                 break;
             }
 #endif
@@ -2158,7 +2350,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkDependencyInfo(globalstate,
                                                       (VkDependencyInfo*)(pDependencyInfo));
                 }
-                vk->vkCmdSetEvent2KHR((VkCommandBuffer)dispatchHandle, event, pDependencyInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetEvent2KHR((VkCommandBuffer)dispatchHandle, event, pDependencyInfo);
+                }
                 break;
             }
             case OP_vkCmdResetEvent2KHR: {
@@ -2173,7 +2367,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkPipelineStageFlags2*)&stageMask, *readStreamPtrPtr,
                        sizeof(VkPipelineStageFlags2));
                 *readStreamPtrPtr += sizeof(VkPipelineStageFlags2);
-                vk->vkCmdResetEvent2KHR((VkCommandBuffer)dispatchHandle, event, stageMask);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResetEvent2KHR((VkCommandBuffer)dispatchHandle, event, stageMask);
+                }
                 break;
             }
             case OP_vkCmdWaitEvents2KHR: {
@@ -2218,8 +2414,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                             globalstate, (VkDependencyInfo*)(pDependencyInfos + i));
                     }
                 }
-                vk->vkCmdWaitEvents2KHR((VkCommandBuffer)dispatchHandle, eventCount, pEvents,
-                                        pDependencyInfos);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWaitEvents2KHR((VkCommandBuffer)dispatchHandle, eventCount, pEvents,
+                                            pDependencyInfos);
+                }
                 break;
             }
             case OP_vkCmdPipelineBarrier2KHR: {
@@ -2235,7 +2433,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkDependencyInfo(globalstate,
                                                       (VkDependencyInfo*)(pDependencyInfo));
                 }
-                vk->vkCmdPipelineBarrier2KHR((VkCommandBuffer)dispatchHandle, pDependencyInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdPipelineBarrier2KHR((VkCommandBuffer)dispatchHandle, pDependencyInfo);
+                }
                 break;
             }
             case OP_vkCmdWriteTimestamp2KHR: {
@@ -2254,8 +2454,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                 memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdWriteTimestamp2KHR((VkCommandBuffer)dispatchHandle, stage, queryPool,
-                                            query);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWriteTimestamp2KHR((VkCommandBuffer)dispatchHandle, stage, queryPool,
+                                                query);
+                }
                 break;
             }
             case OP_vkCmdWriteBufferMarker2AMD: {
@@ -2276,8 +2478,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkDeviceSize);
                 memcpy((uint32_t*)&marker, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdWriteBufferMarker2AMD((VkCommandBuffer)dispatchHandle, stage, dstBuffer,
-                                               dstOffset, marker);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdWriteBufferMarker2AMD((VkCommandBuffer)dispatchHandle, stage,
+                                                   dstBuffer, dstOffset, marker);
+                }
                 break;
             }
 #endif
@@ -2295,7 +2499,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCopyBufferInfo2(globalstate,
                                                        (VkCopyBufferInfo2*)(pCopyBufferInfo));
                 }
-                vk->vkCmdCopyBuffer2KHR((VkCommandBuffer)dispatchHandle, pCopyBufferInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdCopyBuffer2KHR((VkCommandBuffer)dispatchHandle, pCopyBufferInfo);
+                }
                 break;
             }
             case OP_vkCmdCopyImage2KHR: {
@@ -2311,8 +2517,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCopyImageInfo2(globalstate,
                                                       (VkCopyImageInfo2*)(pCopyImageInfo));
                 }
-                this->on_vkCmdCopyImage2KHR(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                            pCopyImageInfo);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyImage2KHR(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), pCopyImageInfo);
+                }
                 break;
             }
             case OP_vkCmdCopyBufferToImage2KHR: {
@@ -2328,8 +2536,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCopyBufferToImageInfo2(
                         globalstate, (VkCopyBufferToImageInfo2*)(pCopyBufferToImageInfo));
                 }
-                this->on_vkCmdCopyBufferToImage2KHR(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                                    pCopyBufferToImageInfo, context);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyBufferToImage2KHR(pool, nullptr,
+                                                        (VkCommandBuffer)(boxed_dispatchHandle),
+                                                        pCopyBufferToImageInfo, context);
+                }
                 break;
             }
             case OP_vkCmdCopyImageToBuffer2KHR: {
@@ -2345,8 +2556,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCopyImageToBufferInfo2(
                         globalstate, (VkCopyImageToBufferInfo2*)(pCopyImageToBufferInfo));
                 }
-                this->on_vkCmdCopyImageToBuffer2KHR(pool, (VkCommandBuffer)(boxed_dispatchHandle),
-                                                    pCopyImageToBufferInfo);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCmdCopyImageToBuffer2KHR(pool, nullptr,
+                                                        (VkCommandBuffer)(boxed_dispatchHandle),
+                                                        pCopyImageToBufferInfo);
+                }
                 break;
             }
             case OP_vkCmdBlitImage2KHR: {
@@ -2362,7 +2576,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkBlitImageInfo2(globalstate,
                                                       (VkBlitImageInfo2*)(pBlitImageInfo));
                 }
-                vk->vkCmdBlitImage2KHR((VkCommandBuffer)dispatchHandle, pBlitImageInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBlitImage2KHR((VkCommandBuffer)dispatchHandle, pBlitImageInfo);
+                }
                 break;
             }
             case OP_vkCmdResolveImage2KHR: {
@@ -2378,7 +2594,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkResolveImageInfo2(globalstate,
                                                          (VkResolveImageInfo2*)(pResolveImageInfo));
                 }
-                vk->vkCmdResolveImage2KHR((VkCommandBuffer)dispatchHandle, pResolveImageInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdResolveImage2KHR((VkCommandBuffer)dispatchHandle, pResolveImageInfo);
+                }
                 break;
             }
 #endif
@@ -2400,8 +2618,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkDeviceSize);
                 memcpy((VkIndexType*)&indexType, *readStreamPtrPtr, sizeof(VkIndexType));
                 *readStreamPtrPtr += sizeof(VkIndexType);
-                vk->vkCmdBindIndexBuffer2KHR((VkCommandBuffer)dispatchHandle, buffer, offset, size,
-                                             indexType);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindIndexBuffer2KHR((VkCommandBuffer)dispatchHandle, buffer, offset,
+                                                 size, indexType);
+                }
                 break;
             }
 #endif
@@ -2415,8 +2635,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint16_t*)&lineStipplePattern, *readStreamPtrPtr, sizeof(uint16_t));
                 *readStreamPtrPtr += sizeof(uint16_t);
-                vk->vkCmdSetLineStippleKHR((VkCommandBuffer)dispatchHandle, lineStippleFactor,
-                                           lineStipplePattern);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetLineStippleKHR((VkCommandBuffer)dispatchHandle, lineStippleFactor,
+                                               lineStipplePattern);
+                }
                 break;
             }
 #endif
@@ -2475,9 +2697,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                            ((bindingCount)) * sizeof(const VkDeviceSize));
                     *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                 }
-                vk->vkCmdBindTransformFeedbackBuffersEXT((VkCommandBuffer)dispatchHandle,
-                                                         firstBinding, bindingCount, pBuffers,
-                                                         pOffsets, pSizes);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindTransformFeedbackBuffersEXT((VkCommandBuffer)dispatchHandle,
+                                                             firstBinding, bindingCount, pBuffers,
+                                                             pOffsets, pSizes);
+                }
                 break;
             }
             case OP_vkCmdBeginTransformFeedbackEXT: {
@@ -2531,9 +2755,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                            ((counterBufferCount)) * sizeof(const VkDeviceSize));
                     *readStreamPtrPtr += ((counterBufferCount)) * sizeof(const VkDeviceSize);
                 }
-                vk->vkCmdBeginTransformFeedbackEXT((VkCommandBuffer)dispatchHandle,
-                                                   firstCounterBuffer, counterBufferCount,
-                                                   pCounterBuffers, pCounterBufferOffsets);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginTransformFeedbackEXT((VkCommandBuffer)dispatchHandle,
+                                                       firstCounterBuffer, counterBufferCount,
+                                                       pCounterBuffers, pCounterBufferOffsets);
+                }
                 break;
             }
             case OP_vkCmdEndTransformFeedbackEXT: {
@@ -2587,9 +2813,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                            ((counterBufferCount)) * sizeof(const VkDeviceSize));
                     *readStreamPtrPtr += ((counterBufferCount)) * sizeof(const VkDeviceSize);
                 }
-                vk->vkCmdEndTransformFeedbackEXT((VkCommandBuffer)dispatchHandle,
-                                                 firstCounterBuffer, counterBufferCount,
-                                                 pCounterBuffers, pCounterBufferOffsets);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndTransformFeedbackEXT((VkCommandBuffer)dispatchHandle,
+                                                     firstCounterBuffer, counterBufferCount,
+                                                     pCounterBuffers, pCounterBufferOffsets);
+                }
                 break;
             }
             case OP_vkCmdBeginQueryIndexedEXT: {
@@ -2611,8 +2839,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkQueryControlFlags);
                 memcpy((uint32_t*)&index, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdBeginQueryIndexedEXT((VkCommandBuffer)dispatchHandle, queryPool, query,
-                                              flags, index);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginQueryIndexedEXT((VkCommandBuffer)dispatchHandle, queryPool, query,
+                                                  flags, index);
+                }
                 break;
             }
             case OP_vkCmdEndQueryIndexedEXT: {
@@ -2630,8 +2860,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&index, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdEndQueryIndexedEXT((VkCommandBuffer)dispatchHandle, queryPool, query,
-                                            index);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndQueryIndexedEXT((VkCommandBuffer)dispatchHandle, queryPool, query,
+                                                index);
+                }
                 break;
             }
             case OP_vkCmdDrawIndirectByteCountEXT: {
@@ -2658,9 +2890,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&vertexStride, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdDrawIndirectByteCountEXT((VkCommandBuffer)dispatchHandle, instanceCount,
-                                                  firstInstance, counterBuffer, counterBufferOffset,
-                                                  counterOffset, vertexStride);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdDrawIndirectByteCountEXT(
+                        (VkCommandBuffer)dispatchHandle, instanceCount, firstInstance,
+                        counterBuffer, counterBufferOffset, counterOffset, vertexStride);
+                }
                 break;
             }
 #endif
@@ -2678,13 +2912,17 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkDebugUtilsLabelEXT(globalstate,
                                                           (VkDebugUtilsLabelEXT*)(pLabelInfo));
                 }
-                vk->vkCmdBeginDebugUtilsLabelEXT((VkCommandBuffer)dispatchHandle, pLabelInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBeginDebugUtilsLabelEXT((VkCommandBuffer)dispatchHandle, pLabelInfo);
+                }
                 break;
             }
             case OP_vkCmdEndDebugUtilsLabelEXT: {
                 GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                       "VkSubDecoder vkCmdEndDebugUtilsLabelEXT");
-                vk->vkCmdEndDebugUtilsLabelEXT((VkCommandBuffer)dispatchHandle);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdEndDebugUtilsLabelEXT((VkCommandBuffer)dispatchHandle);
+                }
                 break;
             }
             case OP_vkCmdInsertDebugUtilsLabelEXT: {
@@ -2700,7 +2938,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkDebugUtilsLabelEXT(globalstate,
                                                           (VkDebugUtilsLabelEXT*)(pLabelInfo));
                 }
-                vk->vkCmdInsertDebugUtilsLabelEXT((VkCommandBuffer)dispatchHandle, pLabelInfo);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdInsertDebugUtilsLabelEXT((VkCommandBuffer)dispatchHandle, pLabelInfo);
+                }
                 break;
             }
 #endif
@@ -2714,8 +2954,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint16_t*)&lineStipplePattern, *readStreamPtrPtr, sizeof(uint16_t));
                 *readStreamPtrPtr += sizeof(uint16_t);
-                vk->vkCmdSetLineStippleEXT((VkCommandBuffer)dispatchHandle, lineStippleFactor,
-                                           lineStipplePattern);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetLineStippleEXT((VkCommandBuffer)dispatchHandle, lineStippleFactor,
+                                               lineStipplePattern);
+                }
                 break;
             }
 #endif
@@ -2726,7 +2968,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkCullModeFlags cullMode;
                 memcpy((VkCullModeFlags*)&cullMode, *readStreamPtrPtr, sizeof(VkCullModeFlags));
                 *readStreamPtrPtr += sizeof(VkCullModeFlags);
-                vk->vkCmdSetCullModeEXT((VkCommandBuffer)dispatchHandle, cullMode);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetCullModeEXT((VkCommandBuffer)dispatchHandle, cullMode);
+                }
                 break;
             }
             case OP_vkCmdSetFrontFaceEXT: {
@@ -2735,7 +2979,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkFrontFace frontFace;
                 memcpy((VkFrontFace*)&frontFace, *readStreamPtrPtr, sizeof(VkFrontFace));
                 *readStreamPtrPtr += sizeof(VkFrontFace);
-                vk->vkCmdSetFrontFaceEXT((VkCommandBuffer)dispatchHandle, frontFace);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetFrontFaceEXT((VkCommandBuffer)dispatchHandle, frontFace);
+                }
                 break;
             }
             case OP_vkCmdSetPrimitiveTopologyEXT: {
@@ -2745,8 +2991,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkPrimitiveTopology*)&primitiveTopology, *readStreamPtrPtr,
                        sizeof(VkPrimitiveTopology));
                 *readStreamPtrPtr += sizeof(VkPrimitiveTopology);
-                vk->vkCmdSetPrimitiveTopologyEXT((VkCommandBuffer)dispatchHandle,
-                                                 primitiveTopology);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPrimitiveTopologyEXT((VkCommandBuffer)dispatchHandle,
+                                                     primitiveTopology);
+                }
                 break;
             }
             case OP_vkCmdSetViewportWithCountEXT: {
@@ -2772,8 +3020,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkViewport(globalstate, (VkViewport*)(pViewports + i));
                     }
                 }
-                vk->vkCmdSetViewportWithCountEXT((VkCommandBuffer)dispatchHandle, viewportCount,
-                                                 pViewports);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetViewportWithCountEXT((VkCommandBuffer)dispatchHandle, viewportCount,
+                                                     pViewports);
+                }
                 break;
             }
             case OP_vkCmdSetScissorWithCountEXT: {
@@ -2799,8 +3049,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         transform_tohost_VkRect2D(globalstate, (VkRect2D*)(pScissors + i));
                     }
                 }
-                vk->vkCmdSetScissorWithCountEXT((VkCommandBuffer)dispatchHandle, scissorCount,
-                                                pScissors);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetScissorWithCountEXT((VkCommandBuffer)dispatchHandle, scissorCount,
+                                                    pScissors);
+                }
                 break;
             }
             case OP_vkCmdBindVertexBuffers2EXT: {
@@ -2882,8 +3134,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                            ((bindingCount)) * sizeof(const VkDeviceSize));
                     *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                 }
-                vk->vkCmdBindVertexBuffers2EXT((VkCommandBuffer)dispatchHandle, firstBinding,
-                                               bindingCount, pBuffers, pOffsets, pSizes, pStrides);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdBindVertexBuffers2EXT((VkCommandBuffer)dispatchHandle, firstBinding,
+                                                   bindingCount, pBuffers, pOffsets, pSizes,
+                                                   pStrides);
+                }
                 break;
             }
             case OP_vkCmdSetDepthTestEnableEXT: {
@@ -2892,7 +3147,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 depthTestEnable;
                 memcpy((VkBool32*)&depthTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetDepthTestEnableEXT((VkCommandBuffer)dispatchHandle, depthTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthTestEnableEXT((VkCommandBuffer)dispatchHandle,
+                                                   depthTestEnable);
+                }
                 break;
             }
             case OP_vkCmdSetDepthWriteEnableEXT: {
@@ -2901,7 +3159,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 depthWriteEnable;
                 memcpy((VkBool32*)&depthWriteEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetDepthWriteEnableEXT((VkCommandBuffer)dispatchHandle, depthWriteEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthWriteEnableEXT((VkCommandBuffer)dispatchHandle,
+                                                    depthWriteEnable);
+                }
                 break;
             }
             case OP_vkCmdSetDepthCompareOpEXT: {
@@ -2910,7 +3171,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkCompareOp depthCompareOp;
                 memcpy((VkCompareOp*)&depthCompareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                 *readStreamPtrPtr += sizeof(VkCompareOp);
-                vk->vkCmdSetDepthCompareOpEXT((VkCommandBuffer)dispatchHandle, depthCompareOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthCompareOpEXT((VkCommandBuffer)dispatchHandle, depthCompareOp);
+                }
                 break;
             }
             case OP_vkCmdSetDepthBoundsTestEnableEXT: {
@@ -2919,8 +3182,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 depthBoundsTestEnable;
                 memcpy((VkBool32*)&depthBoundsTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetDepthBoundsTestEnableEXT((VkCommandBuffer)dispatchHandle,
-                                                     depthBoundsTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBoundsTestEnableEXT((VkCommandBuffer)dispatchHandle,
+                                                         depthBoundsTestEnable);
+                }
                 break;
             }
             case OP_vkCmdSetStencilTestEnableEXT: {
@@ -2929,8 +3194,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 stencilTestEnable;
                 memcpy((VkBool32*)&stencilTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetStencilTestEnableEXT((VkCommandBuffer)dispatchHandle,
-                                                 stencilTestEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilTestEnableEXT((VkCommandBuffer)dispatchHandle,
+                                                     stencilTestEnable);
+                }
                 break;
             }
             case OP_vkCmdSetStencilOpEXT: {
@@ -2952,8 +3219,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(VkStencilOp);
                 memcpy((VkCompareOp*)&compareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                 *readStreamPtrPtr += sizeof(VkCompareOp);
-                vk->vkCmdSetStencilOpEXT((VkCommandBuffer)dispatchHandle, faceMask, failOp, passOp,
-                                         depthFailOp, compareOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetStencilOpEXT((VkCommandBuffer)dispatchHandle, faceMask, failOp,
+                                             passOp, depthFailOp, compareOp);
+                }
                 break;
             }
 #endif
@@ -2964,8 +3233,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 uint32_t patchControlPoints;
                 memcpy((uint32_t*)&patchControlPoints, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdSetPatchControlPointsEXT((VkCommandBuffer)dispatchHandle,
-                                                  patchControlPoints);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPatchControlPointsEXT((VkCommandBuffer)dispatchHandle,
+                                                      patchControlPoints);
+                }
                 break;
             }
             case OP_vkCmdSetRasterizerDiscardEnableEXT: {
@@ -2974,8 +3245,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 rasterizerDiscardEnable;
                 memcpy((VkBool32*)&rasterizerDiscardEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetRasterizerDiscardEnableEXT((VkCommandBuffer)dispatchHandle,
-                                                       rasterizerDiscardEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetRasterizerDiscardEnableEXT((VkCommandBuffer)dispatchHandle,
+                                                           rasterizerDiscardEnable);
+                }
                 break;
             }
             case OP_vkCmdSetDepthBiasEnableEXT: {
@@ -2984,7 +3257,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 depthBiasEnable;
                 memcpy((VkBool32*)&depthBiasEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetDepthBiasEnableEXT((VkCommandBuffer)dispatchHandle, depthBiasEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetDepthBiasEnableEXT((VkCommandBuffer)dispatchHandle,
+                                                   depthBiasEnable);
+                }
                 break;
             }
             case OP_vkCmdSetLogicOpEXT: {
@@ -2993,7 +3269,9 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkLogicOp logicOp;
                 memcpy((VkLogicOp*)&logicOp, *readStreamPtrPtr, sizeof(VkLogicOp));
                 *readStreamPtrPtr += sizeof(VkLogicOp);
-                vk->vkCmdSetLogicOpEXT((VkCommandBuffer)dispatchHandle, logicOp);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetLogicOpEXT((VkCommandBuffer)dispatchHandle, logicOp);
+                }
                 break;
             }
             case OP_vkCmdSetPrimitiveRestartEnableEXT: {
@@ -3002,8 +3280,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 VkBool32 primitiveRestartEnable;
                 memcpy((VkBool32*)&primitiveRestartEnable, *readStreamPtrPtr, sizeof(VkBool32));
                 *readStreamPtrPtr += sizeof(VkBool32);
-                vk->vkCmdSetPrimitiveRestartEnableEXT((VkCommandBuffer)dispatchHandle,
-                                                      primitiveRestartEnable);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetPrimitiveRestartEnableEXT((VkCommandBuffer)dispatchHandle,
+                                                          primitiveRestartEnable);
+                }
                 break;
             }
 #endif
@@ -3025,8 +3305,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkBool32*)pColorWriteEnables, *readStreamPtrPtr,
                        ((attachmentCount)) * sizeof(const VkBool32));
                 *readStreamPtrPtr += ((attachmentCount)) * sizeof(const VkBool32);
-                vk->vkCmdSetColorWriteEnableEXT((VkCommandBuffer)dispatchHandle, attachmentCount,
-                                                pColorWriteEnables);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetColorWriteEnableEXT((VkCommandBuffer)dispatchHandle,
+                                                    attachmentCount, pColorWriteEnables);
+                }
                 break;
             }
 #endif
@@ -3044,15 +3326,20 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                     transform_tohost_VkCommandBufferBeginInfo(
                         globalstate, (VkCommandBufferBeginInfo*)(pBeginInfo));
                 }
-                this->on_vkBeginCommandBufferAsyncGOOGLE(
-                    pool, (VkCommandBuffer)(boxed_dispatchHandle), pBeginInfo, context);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkBeginCommandBufferAsyncGOOGLE(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), pBeginInfo,
+                        context);
+                }
                 break;
             }
             case OP_vkEndCommandBufferAsyncGOOGLE: {
                 GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                       "VkSubDecoder vkEndCommandBufferAsyncGOOGLE");
-                this->on_vkEndCommandBufferAsyncGOOGLE(
-                    pool, (VkCommandBuffer)(boxed_dispatchHandle), context);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkEndCommandBufferAsyncGOOGLE(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), context);
+                }
                 break;
             }
             case OP_vkResetCommandBufferAsyncGOOGLE: {
@@ -3062,8 +3349,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr,
                        sizeof(VkCommandBufferResetFlags));
                 *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
-                this->on_vkResetCommandBufferAsyncGOOGLE(
-                    pool, (VkCommandBuffer)(boxed_dispatchHandle), flags);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkResetCommandBufferAsyncGOOGLE(
+                        pool, nullptr, (VkCommandBuffer)(boxed_dispatchHandle), flags);
+                }
                 break;
             }
             case OP_vkCommandBufferHostSyncGOOGLE: {
@@ -3075,8 +3364,11 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 *readStreamPtrPtr += sizeof(uint32_t);
                 memcpy((uint32_t*)&sequenceNumber, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                this->on_vkCommandBufferHostSyncGOOGLE(
-                    pool, (VkCommandBuffer)(boxed_dispatchHandle), needHostSync, sequenceNumber);
+                if (CC_LIKELY(vk)) {
+                    this->on_vkCommandBufferHostSyncGOOGLE(pool, nullptr,
+                                                           (VkCommandBuffer)(boxed_dispatchHandle),
+                                                           needHostSync, sequenceNumber);
+                }
                 break;
             }
 #endif
@@ -3140,9 +3432,12 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         globalstate,
                         (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable));
                 }
-                vk->vkCmdTraceRaysKHR((VkCommandBuffer)dispatchHandle, pRaygenShaderBindingTable,
-                                      pMissShaderBindingTable, pHitShaderBindingTable,
-                                      pCallableShaderBindingTable, width, height, depth);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdTraceRaysKHR((VkCommandBuffer)dispatchHandle,
+                                          pRaygenShaderBindingTable, pMissShaderBindingTable,
+                                          pHitShaderBindingTable, pCallableShaderBindingTable,
+                                          width, height, depth);
+                }
                 break;
             }
             case OP_vkCmdTraceRaysIndirectKHR: {
@@ -3199,10 +3494,12 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                         globalstate,
                         (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable));
                 }
-                vk->vkCmdTraceRaysIndirectKHR((VkCommandBuffer)dispatchHandle,
-                                              pRaygenShaderBindingTable, pMissShaderBindingTable,
-                                              pHitShaderBindingTable, pCallableShaderBindingTable,
-                                              indirectDeviceAddress);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdTraceRaysIndirectKHR(
+                        (VkCommandBuffer)dispatchHandle, pRaygenShaderBindingTable,
+                        pMissShaderBindingTable, pHitShaderBindingTable,
+                        pCallableShaderBindingTable, indirectDeviceAddress);
+                }
                 break;
             }
             case OP_vkCmdSetRayTracingPipelineStackSizeKHR: {
@@ -3211,8 +3508,10 @@ size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* b
                 uint32_t pipelineStackSize;
                 memcpy((uint32_t*)&pipelineStackSize, *readStreamPtrPtr, sizeof(uint32_t));
                 *readStreamPtrPtr += sizeof(uint32_t);
-                vk->vkCmdSetRayTracingPipelineStackSizeKHR((VkCommandBuffer)dispatchHandle,
-                                                           pipelineStackSize);
+                if (CC_LIKELY(vk)) {
+                    vk->vkCmdSetRayTracingPipelineStackSizeKHR((VkCommandBuffer)dispatchHandle,
+                                                               pipelineStackSize);
+                }
                 break;
             }
 #endif
diff --git a/host/vulkan/VulkanBoxedHandles.cpp b/host/vulkan/VulkanBoxedHandles.cpp
new file mode 100644
index 000000000..a7380ccc7
--- /dev/null
+++ b/host/vulkan/VulkanBoxedHandles.cpp
@@ -0,0 +1,1694 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "VulkanBoxedHandles.h"
+
+#include "VkDecoderGlobalState.h"
+#include "VkDecoderInternalStructs.h"
+
+namespace gfxstream {
+namespace vk {
+namespace {
+
+struct ReadStreamRegistry {
+    android::base::Lock mLock;
+
+    std::vector<VulkanMemReadingStream*> freeStreams;
+
+    ReadStreamRegistry() { freeStreams.reserve(100); };
+
+    VulkanMemReadingStream* pop(const gfxstream::host::FeatureSet& features) {
+        android::base::AutoLock lock(mLock);
+        if (freeStreams.empty()) {
+            return new VulkanMemReadingStream(nullptr, features);
+        } else {
+            VulkanMemReadingStream* res = freeStreams.back();
+            freeStreams.pop_back();
+            return res;
+        }
+    }
+
+    void push(VulkanMemReadingStream* stream) {
+        android::base::AutoLock lock(mLock);
+        freeStreams.push_back(stream);
+    }
+};
+
+static ReadStreamRegistry sReadStreamRegistry;
+
+}  // namespace
+
+void BoxedHandleManager::replayHandles(std::vector<BoxedHandle> handles) {
+    mHandleReplay = true;
+    mHandleReplayQueue.clear();
+    for (BoxedHandle handle : handles) {
+        mHandleReplayQueue.push_back(handle);
+    }
+}
+
+void BoxedHandleManager::clear() {
+    std::lock_guard<std::mutex> lock(mMutex);
+    mReverseMap.clear();
+    mStore.clear();
+}
+
+BoxedHandle BoxedHandleManager::add(const BoxedHandleInfo& item, BoxedHandleTypeTag tag) {
+    BoxedHandle handle;
+
+    if (mHandleReplay) {
+        handle = mHandleReplayQueue.front();
+        mHandleReplayQueue.pop_front();
+        mHandleReplay = !mHandleReplayQueue.empty();
+
+        handle = (BoxedHandle)mStore.addFixed(handle, item, (size_t)tag);
+    } else {
+        handle = (BoxedHandle)mStore.add(item, (size_t)tag);
+    }
+
+    std::lock_guard<std::mutex> lock(mMutex);
+    mReverseMap[(BoxedHandle)(item.underlying)] = handle;
+    return handle;
+}
+
+void BoxedHandleManager::update(BoxedHandle handle, const BoxedHandleInfo& item,
+                                BoxedHandleTypeTag tag) {
+    auto storedItem = mStore.get(handle);
+    UnboxedHandle oldHandle = (UnboxedHandle)storedItem->underlying;
+    *storedItem = item;
+    std::lock_guard<std::mutex> lock(mMutex);
+    if (oldHandle) {
+        mReverseMap.erase(oldHandle);
+    }
+    mReverseMap[(UnboxedHandle)(item.underlying)] = handle;
+}
+
+void BoxedHandleManager::remove(BoxedHandle h) {
+    auto item = get(h);
+    if (item) {
+        std::lock_guard<std::mutex> lock(mMutex);
+        mReverseMap.erase((UnboxedHandle)(item->underlying));
+    }
+    mStore.remove(h);
+}
+
+void BoxedHandleManager::removeDelayed(uint64_t h, VkDevice device,
+                                       std::function<void()> callback) {
+    std::lock_guard<std::mutex> lock(mMutex);
+    mDelayedRemoves[device].push_back({h, callback});
+}
+
+void BoxedHandleManager::processDelayedRemoves(VkDevice device) {
+    std::vector<DelayedRemove> deviceDelayedRemoves;
+
+    {
+        std::lock_guard<std::mutex> lock(mMutex);
+
+        auto it = mDelayedRemoves.find(device);
+        if (it == mDelayedRemoves.end()) return;
+
+        deviceDelayedRemoves = std::move(it->second);
+        mDelayedRemoves.erase(it);
+    }
+
+    for (const auto& r : deviceDelayedRemoves) {
+        auto h = r.handle;
+
+        // VkDecoderGlobalState is not locked when callback is called.
+        if (r.callback) {
+            r.callback();
+        }
+
+        mStore.remove(h);
+    }
+}
+
+BoxedHandleInfo* BoxedHandleManager::get(BoxedHandle handle) {
+    return (BoxedHandleInfo*)mStore.get_const(handle);
+}
+
+BoxedHandle BoxedHandleManager::getBoxedFromUnboxed(UnboxedHandle unboxed) {
+    std::lock_guard<std::mutex> lock(mMutex);
+
+    auto it = mReverseMap.find(unboxed);
+    if (it == mReverseMap.end()) {
+        return 0;
+    }
+
+    return it->second;
+}
+
+BoxedHandleManager sBoxedHandleManager;
+
+template <typename VkObjectT>
+constexpr BoxedHandleTypeTag GetTag() {
+    if constexpr (std::is_same_v<VkObjectT, VkAccelerationStructureKHR>) {
+        return Tag_VkAccelerationStructureKHR;
+    } else if constexpr (std::is_same_v<VkObjectT, VkAccelerationStructureNV>) {
+        return Tag_VkAccelerationStructureNV;
+    } else if constexpr (std::is_same_v<VkObjectT, VkBuffer>) {
+        return Tag_VkBuffer;
+    } else if constexpr (std::is_same_v<VkObjectT, VkBufferView>) {
+        return Tag_VkBufferView;
+    } else if constexpr (std::is_same_v<VkObjectT, VkCommandBuffer>) {
+        return Tag_VkCommandBuffer;
+    } else if constexpr (std::is_same_v<VkObjectT, VkCommandPool>) {
+        return Tag_VkCommandPool;
+    } else if constexpr (std::is_same_v<VkObjectT, VkCuFunctionNVX>) {
+        return Tag_VkCuFunctionNVX;
+    } else if constexpr (std::is_same_v<VkObjectT, VkCuModuleNVX>) {
+        return Tag_VkCuModuleNVX;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDebugReportCallbackEXT>) {
+        return Tag_VkDebugReportCallbackEXT;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDebugUtilsMessengerEXT>) {
+        return Tag_VkDebugUtilsMessengerEXT;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDescriptorPool>) {
+        return Tag_VkDescriptorPool;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDescriptorSet>) {
+        return Tag_VkDescriptorSet;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDescriptorSetLayout>) {
+        return Tag_VkDescriptorSetLayout;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDescriptorUpdateTemplate>) {
+        return Tag_VkDescriptorUpdateTemplate;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDevice>) {
+        return Tag_VkDevice;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDeviceMemory>) {
+        return Tag_VkDeviceMemory;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDisplayKHR>) {
+        return Tag_VkDisplayKHR;
+    } else if constexpr (std::is_same_v<VkObjectT, VkDisplayModeKHR>) {
+        return Tag_VkDisplayModeKHR;
+    } else if constexpr (std::is_same_v<VkObjectT, VkEvent>) {
+        return Tag_VkEvent;
+    } else if constexpr (std::is_same_v<VkObjectT, VkFence>) {
+        return Tag_VkFence;
+    } else if constexpr (std::is_same_v<VkObjectT, VkFramebuffer>) {
+        return Tag_VkFramebuffer;
+    } else if constexpr (std::is_same_v<VkObjectT, VkImage>) {
+        return Tag_VkImage;
+    } else if constexpr (std::is_same_v<VkObjectT, VkImageView>) {
+        return Tag_VkImageView;
+    } else if constexpr (std::is_same_v<VkObjectT, VkIndirectCommandsLayoutNV>) {
+        return Tag_VkIndirectCommandsLayoutNV;
+    } else if constexpr (std::is_same_v<VkObjectT, VkInstance>) {
+        return Tag_VkInstance;
+    } else if constexpr (std::is_same_v<VkObjectT, VkMicromapEXT>) {
+        return Tag_VkMicromapEXT;
+    } else if constexpr (std::is_same_v<VkObjectT, VkPhysicalDevice>) {
+        return Tag_VkPhysicalDevice;
+    } else if constexpr (std::is_same_v<VkObjectT, VkPipeline>) {
+        return Tag_VkPipeline;
+    } else if constexpr (std::is_same_v<VkObjectT, VkPipelineCache>) {
+        return Tag_VkPipelineCache;
+    } else if constexpr (std::is_same_v<VkObjectT, VkPipelineLayout>) {
+        return Tag_VkPipelineLayout;
+    } else if constexpr (std::is_same_v<VkObjectT, VkPrivateDataSlot>) {
+        return Tag_VkPrivateDataSlot;
+    } else if constexpr (std::is_same_v<VkObjectT, VkQueryPool>) {
+        return Tag_VkQueryPool;
+    } else if constexpr (std::is_same_v<VkObjectT, VkQueue>) {
+        return Tag_VkQueue;
+    } else if constexpr (std::is_same_v<VkObjectT, VkRenderPass>) {
+        return Tag_VkRenderPass;
+    } else if constexpr (std::is_same_v<VkObjectT, VkSampler>) {
+        return Tag_VkSampler;
+    } else if constexpr (std::is_same_v<VkObjectT, VkSamplerYcbcrConversion>) {
+        return Tag_VkSamplerYcbcrConversion;
+    } else if constexpr (std::is_same_v<VkObjectT, VkSemaphore>) {
+        return Tag_VkSemaphore;
+    } else if constexpr (std::is_same_v<VkObjectT, VkShaderModule>) {
+        return Tag_VkShaderModule;
+    } else if constexpr (std::is_same_v<VkObjectT, VkSurfaceKHR>) {
+        return Tag_VkSurfaceKHR;
+    } else if constexpr (std::is_same_v<VkObjectT, VkSwapchainKHR>) {
+        return Tag_VkSwapchainKHR;
+    } else if constexpr (std::is_same_v<VkObjectT, VkValidationCacheEXT>) {
+        return Tag_VkValidationCacheEXT;
+    } else {
+        static_assert(sizeof(VkObjectT) == 0,
+                      "Unhandled VkObjectT. Please update BoxedHandleTypeTag.");
+    }
+}
+
+template <typename VkObjectT>
+constexpr const char* GetTypeStr() {
+    if constexpr (std::is_same_v<VkObjectT, VkAccelerationStructureKHR>) {
+        return "VkAccelerationStructureKHR";
+    } else if constexpr (std::is_same_v<VkObjectT, VkAccelerationStructureNV>) {
+        return "VkAccelerationStructureNV";
+    } else if constexpr (std::is_same_v<VkObjectT, VkBuffer>) {
+        return "VkBuffer";
+    } else if constexpr (std::is_same_v<VkObjectT, VkBufferView>) {
+        return "VkBufferView";
+    } else if constexpr (std::is_same_v<VkObjectT, VkCommandBuffer>) {
+        return "VkCommandBuffer";
+    } else if constexpr (std::is_same_v<VkObjectT, VkCommandPool>) {
+        return "VkCommandPool";
+    } else if constexpr (std::is_same_v<VkObjectT, VkCuFunctionNVX>) {
+        return "VkCuFunctionNVX";
+    } else if constexpr (std::is_same_v<VkObjectT, VkCuModuleNVX>) {
+        return "VkCuModuleNVX";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDebugReportCallbackEXT>) {
+        return "VkDebugReportCallbackEXT";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDebugUtilsMessengerEXT>) {
+        return "VkDebugUtilsMessengerEXT";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDescriptorPool>) {
+        return "VkDescriptorPool";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDescriptorSet>) {
+        return "VkDescriptorSet";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDescriptorSetLayout>) {
+        return "VkDescriptorSetLayout";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDescriptorUpdateTemplate>) {
+        return "VkDescriptorUpdateTemplate";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDevice>) {
+        return "VkDevice";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDeviceMemory>) {
+        return "VkDeviceMemory";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDisplayKHR>) {
+        return "VkDisplayKHR";
+    } else if constexpr (std::is_same_v<VkObjectT, VkDisplayModeKHR>) {
+        return "VkDisplayModeKHR";
+    } else if constexpr (std::is_same_v<VkObjectT, VkEvent>) {
+        return "VkEvent";
+    } else if constexpr (std::is_same_v<VkObjectT, VkFence>) {
+        return "VkFence";
+    } else if constexpr (std::is_same_v<VkObjectT, VkFramebuffer>) {
+        return "VkFramebuffer";
+    } else if constexpr (std::is_same_v<VkObjectT, VkImage>) {
+        return "VkImage";
+    } else if constexpr (std::is_same_v<VkObjectT, VkImageView>) {
+        return "VkImageView";
+    } else if constexpr (std::is_same_v<VkObjectT, VkIndirectCommandsLayoutNV>) {
+        return "VkIndirectCommandsLayoutNV";
+    } else if constexpr (std::is_same_v<VkObjectT, VkInstance>) {
+        return "VkInstance";
+    } else if constexpr (std::is_same_v<VkObjectT, VkMicromapEXT>) {
+        return "VkMicromapEXT";
+    } else if constexpr (std::is_same_v<VkObjectT, VkPhysicalDevice>) {
+        return "VkPhysicalDevice";
+    } else if constexpr (std::is_same_v<VkObjectT, VkPipeline>) {
+        return "VkPipeline";
+    } else if constexpr (std::is_same_v<VkObjectT, VkPipelineCache>) {
+        return "VkPipelineCache";
+    } else if constexpr (std::is_same_v<VkObjectT, VkPipelineLayout>) {
+        return "VkPipelineLayout";
+    } else if constexpr (std::is_same_v<VkObjectT, VkPrivateDataSlot>) {
+        return "VkPrivateDataSlot";
+    } else if constexpr (std::is_same_v<VkObjectT, VkQueryPool>) {
+        return "VkQueryPool";
+    } else if constexpr (std::is_same_v<VkObjectT, VkQueue>) {
+        return "VkQueue";
+    } else if constexpr (std::is_same_v<VkObjectT, VkRenderPass>) {
+        return "VkRenderPass";
+    } else if constexpr (std::is_same_v<VkObjectT, VkSampler>) {
+        return "VkSampler";
+    } else if constexpr (std::is_same_v<VkObjectT, VkSamplerYcbcrConversion>) {
+        return "VkSamplerYcbcrConversion";
+    } else if constexpr (std::is_same_v<VkObjectT, VkSemaphore>) {
+        return "VkSemaphore";
+    } else if constexpr (std::is_same_v<VkObjectT, VkShaderModule>) {
+        return "VkShaderModule";
+    } else if constexpr (std::is_same_v<VkObjectT, VkSurfaceKHR>) {
+        return "VkSurfaceKHR";
+    } else if constexpr (std::is_same_v<VkObjectT, VkSwapchainKHR>) {
+        return "VkSwapchainKHR";
+    } else if constexpr (std::is_same_v<VkObjectT, VkValidationCacheEXT>) {
+        return "VkValidationCacheEXT";
+    } else {
+        static_assert(sizeof(VkObjectT) == 0,
+                      "Unhandled VkObjectT. Please update BoxedHandleTypeTag.");
+    }
+}
+
+template <typename VkObjectT>
+VkObjectT new_boxed_VkType(VkObjectT underlying, bool dispatchable = false, VulkanDispatch* dispatch = nullptr, bool ownsDispatch = false) {
+    BoxedHandleInfo info;
+    info.underlying = (uint64_t)underlying;
+    if (dispatchable) {
+        if (dispatch != nullptr) {
+            info.dispatch = dispatch;
+        } else {
+            info.dispatch = new VulkanDispatch();
+        }
+        info.ownDispatch = ownsDispatch;
+        info.ordMaintInfo = new OrderMaintenanceInfo();
+        info.readStream = nullptr;
+    }
+    return (VkObjectT)sBoxedHandleManager.add(info, GetTag<VkObjectT>());
+}
+
+template <typename VkObjectT>
+void delete_VkType(VkObjectT boxed) {
+    if (boxed == VK_NULL_HANDLE) {
+        return;
+    }
+
+    BoxedHandleInfo* info = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);
+    if (info == nullptr) {
+        return;
+    }
+
+    releaseOrderMaintInfo(info->ordMaintInfo);
+
+    if (info->readStream) {
+        sReadStreamRegistry.push(info->readStream);
+        info->readStream = nullptr;
+    }
+
+    sBoxedHandleManager.remove((uint64_t)boxed);
+}
+
+template <typename VkObjectT>
+void delayed_delete_VkType(VkObjectT boxed, VkDevice device, std::function<void()> callback) {
+    if (boxed == VK_NULL_HANDLE) {
+        return;
+    }
+
+    sBoxedHandleManager.removeDelayed((uint64_t)boxed, device, std::move(callback));
+}
+
+// Custom unbox_* functions or GOLDFISH_VK_LIST_DISPATCHABLE_CUSTOM_UNBOX_HANDLE_TYPES
+// VkQueue objects can be virtual, meaning that multiple boxed queues can map into a single
+// physical queue on the host GPU. Some conversion is needed for unboxing to physical.
+VkQueue unbox_VkQueueImpl(VkQueue boxed) {
+    BoxedHandleInfo* info = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);
+    if (!info) {
+        return VK_NULL_HANDLE;
+    }
+    const uint64_t unboxedQueue64 = info->underlying;
+
+    // Use VulkanVirtualQueue directly to avoid locking for hasVirtualGraphicsQueue call.
+    if (VkDecoderGlobalState::get()->getFeatures().VulkanVirtualQueue.enabled) {
+        // Clear virtual bit and unbox into the actual physical queue handle
+        return (VkQueue)(unboxedQueue64 & ~QueueInfo::kVirtualQueueBit);
+    }
+
+    return (VkQueue)(unboxedQueue64);
+}
+
+template <typename VkObjectT>
+VkObjectT unbox_VkType(VkObjectT boxed) {
+    if (boxed == VK_NULL_HANDLE) {
+        return VK_NULL_HANDLE;
+    }
+
+    VkObjectT unboxed = VK_NULL_HANDLE;
+
+    if constexpr (std::is_same_v<VkObjectT, VkQueue>) {
+        unboxed = unbox_VkQueueImpl(boxed);
+    } else {
+        BoxedHandleInfo* info = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);
+        if (info == nullptr) {
+            if constexpr (std::is_same_v<VkObjectT, VkCommandBuffer> ||
+                          std::is_same_v<VkObjectT, VkDevice> ||
+                          std::is_same_v<VkObjectT, VkInstance> ||
+                          std::is_same_v<VkObjectT, VkPhysicalDevice> ||
+                          std::is_same_v<VkObjectT, VkQueue>) {
+                ERR("Failed to unbox %s %p", GetTypeStr<VkObjectT>(), boxed);
+            } else if constexpr (std::is_same_v<VkObjectT, VkFence>) {
+                // TODO: investigate.
+            } else {
+                GFXSTREAM_ABORT(FatalError(ABORT_REASON_OTHER))
+                        << "Failed to unbox "
+                        << GetTypeStr<VkObjectT>()
+                        << " "
+                        << boxed
+                        << ", not found.";
+            }
+            unboxed = VK_NULL_HANDLE;
+        } else {
+            unboxed = (VkObjectT)info->underlying;
+        }
+    }
+
+    return unboxed;
+}
+
+template <typename VkObjectT>
+VkObjectT try_unbox_VkType(VkObjectT boxed) {
+    if (boxed == VK_NULL_HANDLE) {
+        return VK_NULL_HANDLE;
+    }
+
+    VkObjectT unboxed = VK_NULL_HANDLE;
+
+    if constexpr (std::is_same_v<VkObjectT, VkQueue>) {
+        unboxed = unbox_VkQueueImpl(boxed);
+    } else {
+        BoxedHandleInfo* info = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);
+        if (info != nullptr) {
+            unboxed = (VkObjectT)info->underlying;
+        }
+    }
+
+    if (unboxed == VK_NULL_HANDLE) {
+        WARN("Failed to try unbox %s %p", GetTypeStr<VkObjectT>(), boxed);
+    }
+
+    return unboxed;
+}
+
+template <typename VkObjectT>
+VkObjectT unboxed_to_boxed_non_dispatchable_VkType(VkObjectT unboxed) {
+    if (unboxed == VK_NULL_HANDLE) {
+        return VK_NULL_HANDLE;
+    }
+
+    return (VkObjectT)sBoxedHandleManager.getBoxedFromUnboxed((uint64_t)(uintptr_t)unboxed);
+}
+
+template <typename VkObjectT>
+void set_boxed_non_dispatchable_VkType(VkObjectT boxed, VkObjectT new_unboxed) {
+    BoxedHandleInfo info;
+    info.underlying = (uint64_t)new_unboxed;
+    sBoxedHandleManager.update((uint64_t)boxed, info, GetTag<VkObjectT>());
+}
+
+template <typename VkObjectT>
+OrderMaintenanceInfo* get_order_maintenance_info_VkType(VkObjectT boxed) {
+    BoxedHandleInfo* info = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);
+    if (info == nullptr) {
+        return nullptr;
+    }
+
+    if (info->ordMaintInfo == nullptr) {
+        return nullptr;
+    }
+
+    acquireOrderMaintInfo(info->ordMaintInfo);
+
+    return info->ordMaintInfo;
+}
+
+template <typename VkObjectT>
+VulkanMemReadingStream* get_read_stream_VkType(VkObjectT boxed) {
+    BoxedHandleInfo* info = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);
+    if (info == nullptr) {
+        return nullptr;
+    }
+
+    if (info->readStream == nullptr) {
+        info->readStream = sReadStreamRegistry.pop(VkDecoderGlobalState::get()->getFeatures());
+    }
+
+    return info->readStream;
+}
+
+template <typename VkObjectT>
+VulkanDispatch* get_dispatch_VkType(VkObjectT boxed) {
+    BoxedHandleInfo* info = sBoxedHandleManager.get((uint64_t)(uintptr_t)boxed);
+    if (info == nullptr) {
+        ERR("Failed to unbox %s %p", GetTypeStr<VkObjectT>(), boxed);
+        return nullptr;
+    }
+    return info->dispatch;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//////////////             DISPATCHABLE TYPES                    //////////////
+///////////////////////////////////////////////////////////////////////////////
+
+VkInstance new_boxed_VkInstance(VkInstance unboxed, VulkanDispatch* dispatch, bool ownsDispatch) {
+    return new_boxed_VkType<VkInstance>(unboxed, /*dispatchable=*/true, dispatch, ownsDispatch);
+}
+
+void delete_VkInstance(VkInstance boxed) {
+    delete_VkType(boxed);
+}
+
+VkInstance unbox_VkInstance(VkInstance boxed) {
+    return unbox_VkType<VkInstance>(boxed);
+}
+
+VkInstance try_unbox_VkInstance(VkInstance boxed) {
+    return try_unbox_VkType<VkInstance>(boxed);
+}
+
+VkInstance unboxed_to_boxed_VkInstance(VkInstance unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkInstance>(unboxed);
+}
+
+OrderMaintenanceInfo* ordmaint_VkInstance(VkInstance boxed) {
+    return get_order_maintenance_info_VkType<VkInstance>(boxed);
+}
+
+VulkanMemReadingStream* readstream_VkInstance(VkInstance boxed) {
+    return get_read_stream_VkType<VkInstance>(boxed);
+}
+
+VulkanDispatch* dispatch_VkInstance(VkInstance boxed) {
+    return get_dispatch_VkType<VkInstance>(boxed);
+}
+
+VkPhysicalDevice new_boxed_VkPhysicalDevice(VkPhysicalDevice unboxed, VulkanDispatch* dispatch, bool ownsDispatch) {
+    return new_boxed_VkType<VkPhysicalDevice>(unboxed, /*dispatchable=*/true, dispatch, ownsDispatch);
+}
+
+void delete_VkPhysicalDevice(VkPhysicalDevice boxed) {
+    delete_VkType(boxed);
+}
+
+VkPhysicalDevice unbox_VkPhysicalDevice(VkPhysicalDevice boxed) {
+    return unbox_VkType<VkPhysicalDevice>(boxed);
+}
+
+VkPhysicalDevice try_unbox_VkPhysicalDevice(VkPhysicalDevice boxed) {
+    return try_unbox_VkType<VkPhysicalDevice>(boxed);
+}
+
+VkPhysicalDevice unboxed_to_boxed_VkPhysicalDevice(VkPhysicalDevice unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkPhysicalDevice>(unboxed);
+}
+
+OrderMaintenanceInfo* ordmaint_VkPhysicalDevice(VkPhysicalDevice boxed) {
+    return get_order_maintenance_info_VkType<VkPhysicalDevice>(boxed);
+}
+
+VulkanMemReadingStream* readstream_VkPhysicalDevice(VkPhysicalDevice boxed) {
+    return get_read_stream_VkType<VkPhysicalDevice>(boxed);
+}
+
+VulkanDispatch* dispatch_VkPhysicalDevice(VkPhysicalDevice boxed) {
+    return get_dispatch_VkType<VkPhysicalDevice>(boxed);
+}
+
+VkDevice new_boxed_VkDevice(VkDevice unboxed, VulkanDispatch* dispatch, bool ownsDispatch) {
+    return new_boxed_VkType<VkDevice>(unboxed, /*dispatchable=*/true, dispatch, ownsDispatch);
+}
+
+void delete_VkDevice(VkDevice boxed) {
+    delete_VkType(boxed);
+}
+
+VkDevice unbox_VkDevice(VkDevice boxed) {
+    return unbox_VkType<VkDevice>(boxed);
+}
+
+VkDevice try_unbox_VkDevice(VkDevice boxed) {
+    return try_unbox_VkType<VkDevice>(boxed);
+}
+
+VkDevice unboxed_to_boxed_VkDevice(VkDevice unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDevice>(unboxed);
+}
+
+OrderMaintenanceInfo* ordmaint_VkDevice(VkDevice boxed) {
+    return get_order_maintenance_info_VkType<VkDevice>(boxed);
+}
+
+VulkanMemReadingStream* readstream_VkDevice(VkDevice boxed) {
+    return get_read_stream_VkType<VkDevice>(boxed);
+}
+
+VulkanDispatch* dispatch_VkDevice(VkDevice boxed) {
+    return get_dispatch_VkType<VkDevice>(boxed);
+}
+
+VkCommandBuffer new_boxed_VkCommandBuffer(VkCommandBuffer unboxed, VulkanDispatch* dispatch, bool ownsDispatch) {
+    return new_boxed_VkType<VkCommandBuffer>(unboxed, /*dispatchable=*/true, dispatch, ownsDispatch);
+}
+
+void delete_VkCommandBuffer(VkCommandBuffer boxed) {
+    delete_VkType(boxed);
+}
+
+VkCommandBuffer unbox_VkCommandBuffer(VkCommandBuffer boxed) {
+    return unbox_VkType<VkCommandBuffer>(boxed);
+}
+
+VkCommandBuffer try_unbox_VkCommandBuffer(VkCommandBuffer boxed) {
+    return try_unbox_VkType<VkCommandBuffer>(boxed);
+}
+
+VkCommandBuffer unboxed_to_boxed_VkCommandBuffer(VkCommandBuffer unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkCommandBuffer>(unboxed);
+}
+
+OrderMaintenanceInfo* ordmaint_VkCommandBuffer(VkCommandBuffer boxed) {
+    return get_order_maintenance_info_VkType<VkCommandBuffer>(boxed);
+}
+
+VulkanMemReadingStream* readstream_VkCommandBuffer(VkCommandBuffer boxed) {
+    return get_read_stream_VkType<VkCommandBuffer>(boxed);
+}
+
+VulkanDispatch* dispatch_VkCommandBuffer(VkCommandBuffer boxed) {
+    return get_dispatch_VkType<VkCommandBuffer>(boxed);
+}
+
+VkQueue new_boxed_VkQueue(VkQueue unboxed, VulkanDispatch* dispatch, bool ownsDispatch) {
+    return new_boxed_VkType<VkQueue>(unboxed, /*dispatchable=*/true, dispatch, ownsDispatch);
+}
+
+void delete_VkQueue(VkQueue boxed) {
+    delete_VkType(boxed);
+}
+
+VkQueue unbox_VkQueue(VkQueue boxed) {
+    return unbox_VkType<VkQueue>(boxed);
+}
+
+VkQueue try_unbox_VkQueue(VkQueue boxed) {
+    return try_unbox_VkType<VkQueue>(boxed);
+}
+
+VkQueue unboxed_to_boxed_VkQueue(VkQueue unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkQueue>(unboxed);
+}
+
+OrderMaintenanceInfo* ordmaint_VkQueue(VkQueue boxed) {
+    return get_order_maintenance_info_VkType<VkQueue>(boxed);
+}
+
+VulkanMemReadingStream* readstream_VkQueue(VkQueue boxed) {
+    return get_read_stream_VkType<VkQueue>(boxed);
+}
+
+VulkanDispatch* dispatch_VkQueue(VkQueue boxed) {
+    return get_dispatch_VkType<VkQueue>(boxed);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//////////////             NON DISPATCHABLE TYPES                //////////////
+///////////////////////////////////////////////////////////////////////////////
+
+VkAccelerationStructureKHR new_boxed_non_dispatchable_VkAccelerationStructureKHR(VkAccelerationStructureKHR unboxed) {
+    return new_boxed_VkType<VkAccelerationStructureKHR>(unboxed);
+}
+
+void delete_VkAccelerationStructureKHR(VkAccelerationStructureKHR boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkAccelerationStructureKHR(VkAccelerationStructureKHR boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkAccelerationStructureKHR unbox_VkAccelerationStructureKHR(VkAccelerationStructureKHR boxed) {
+    return unbox_VkType<VkAccelerationStructureKHR>(boxed);
+}
+
+VkAccelerationStructureKHR try_unbox_VkAccelerationStructureKHR(VkAccelerationStructureKHR boxed) {
+    return try_unbox_VkType<VkAccelerationStructureKHR>(boxed);
+}
+
+VkAccelerationStructureKHR unboxed_to_boxed_non_dispatchable_VkAccelerationStructureKHR(VkAccelerationStructureKHR unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkAccelerationStructureKHR>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkAccelerationStructureKHR(VkAccelerationStructureKHR boxed, VkAccelerationStructureKHR new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkAccelerationStructureKHR>(boxed, new_unboxed);
+}
+
+VkAccelerationStructureNV new_boxed_non_dispatchable_VkAccelerationStructureNV(VkAccelerationStructureNV unboxed) {
+    return new_boxed_VkType<VkAccelerationStructureNV>(unboxed);
+}
+
+void delete_VkAccelerationStructureNV(VkAccelerationStructureNV boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkAccelerationStructureNV(VkAccelerationStructureNV boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkAccelerationStructureNV unbox_VkAccelerationStructureNV(VkAccelerationStructureNV boxed) {
+    return unbox_VkType<VkAccelerationStructureNV>(boxed);
+}
+
+VkAccelerationStructureNV try_unbox_VkAccelerationStructureNV(VkAccelerationStructureNV boxed) {
+    return try_unbox_VkType<VkAccelerationStructureNV>(boxed);
+}
+
+VkAccelerationStructureNV unboxed_to_boxed_non_dispatchable_VkAccelerationStructureNV(VkAccelerationStructureNV unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkAccelerationStructureNV>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkAccelerationStructureNV(VkAccelerationStructureNV boxed, VkAccelerationStructureNV new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkAccelerationStructureNV>(boxed, new_unboxed);
+}
+
+VkBuffer new_boxed_non_dispatchable_VkBuffer(VkBuffer unboxed) {
+    return new_boxed_VkType<VkBuffer>(unboxed);
+}
+
+void delete_VkBuffer(VkBuffer boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkBuffer(VkBuffer boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkBuffer unbox_VkBuffer(VkBuffer boxed) {
+    return unbox_VkType<VkBuffer>(boxed);
+}
+
+VkBuffer try_unbox_VkBuffer(VkBuffer boxed) {
+    return try_unbox_VkType<VkBuffer>(boxed);
+}
+
+VkBuffer unboxed_to_boxed_non_dispatchable_VkBuffer(VkBuffer unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkBuffer>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkBuffer(VkBuffer boxed, VkBuffer new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkBuffer>(boxed, new_unboxed);
+}
+
+VkBufferView new_boxed_non_dispatchable_VkBufferView(VkBufferView unboxed) {
+    return new_boxed_VkType<VkBufferView>(unboxed);
+}
+
+void delete_VkBufferView(VkBufferView boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkBufferView(VkBufferView boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkBufferView unbox_VkBufferView(VkBufferView boxed) {
+    return unbox_VkType<VkBufferView>(boxed);
+}
+
+VkBufferView try_unbox_VkBufferView(VkBufferView boxed) {
+    return try_unbox_VkType<VkBufferView>(boxed);
+}
+
+VkBufferView unboxed_to_boxed_non_dispatchable_VkBufferView(VkBufferView unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkBufferView>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkBufferView(VkBufferView boxed, VkBufferView new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkBufferView>(boxed, new_unboxed);
+}
+
+VkCommandPool new_boxed_non_dispatchable_VkCommandPool(VkCommandPool unboxed) {
+    return new_boxed_VkType<VkCommandPool>(unboxed);
+}
+
+void delete_VkCommandPool(VkCommandPool boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkCommandPool(VkCommandPool boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkCommandPool unbox_VkCommandPool(VkCommandPool boxed) {
+    return unbox_VkType<VkCommandPool>(boxed);
+}
+
+VkCommandPool try_unbox_VkCommandPool(VkCommandPool boxed) {
+    return try_unbox_VkType<VkCommandPool>(boxed);
+}
+
+VkCommandPool unboxed_to_boxed_non_dispatchable_VkCommandPool(VkCommandPool unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkCommandPool>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkCommandPool(VkCommandPool boxed, VkCommandPool new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkCommandPool>(boxed, new_unboxed);
+}
+
+VkCuFunctionNVX new_boxed_non_dispatchable_VkCuFunctionNVX(VkCuFunctionNVX unboxed) {
+    return new_boxed_VkType<VkCuFunctionNVX>(unboxed);
+}
+
+void delete_VkCuFunctionNVX(VkCuFunctionNVX boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkCuFunctionNVX(VkCuFunctionNVX boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkCuFunctionNVX unbox_VkCuFunctionNVX(VkCuFunctionNVX boxed) {
+    return unbox_VkType<VkCuFunctionNVX>(boxed);
+}
+
+VkCuFunctionNVX try_unbox_VkCuFunctionNVX(VkCuFunctionNVX boxed) {
+    return try_unbox_VkType<VkCuFunctionNVX>(boxed);
+}
+
+VkCuFunctionNVX unboxed_to_boxed_non_dispatchable_VkCuFunctionNVX(VkCuFunctionNVX unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkCuFunctionNVX>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkCuFunctionNVX(VkCuFunctionNVX boxed, VkCuFunctionNVX new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkCuFunctionNVX>(boxed, new_unboxed);
+}
+
+VkCuModuleNVX new_boxed_non_dispatchable_VkCuModuleNVX(VkCuModuleNVX unboxed) {
+    return new_boxed_VkType<VkCuModuleNVX>(unboxed);
+}
+
+void delete_VkCuModuleNVX(VkCuModuleNVX boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkCuModuleNVX(VkCuModuleNVX boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkCuModuleNVX unbox_VkCuModuleNVX(VkCuModuleNVX boxed) {
+    return unbox_VkType<VkCuModuleNVX>(boxed);
+}
+
+VkCuModuleNVX try_unbox_VkCuModuleNVX(VkCuModuleNVX boxed) {
+    return try_unbox_VkType<VkCuModuleNVX>(boxed);
+}
+
+VkCuModuleNVX unboxed_to_boxed_non_dispatchable_VkCuModuleNVX(VkCuModuleNVX unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkCuModuleNVX>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkCuModuleNVX(VkCuModuleNVX boxed, VkCuModuleNVX new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkCuModuleNVX>(boxed, new_unboxed);
+}
+
+VkDebugReportCallbackEXT new_boxed_non_dispatchable_VkDebugReportCallbackEXT(VkDebugReportCallbackEXT unboxed) {
+    return new_boxed_VkType<VkDebugReportCallbackEXT>(unboxed);
+}
+
+void delete_VkDebugReportCallbackEXT(VkDebugReportCallbackEXT boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkDebugReportCallbackEXT(VkDebugReportCallbackEXT boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkDebugReportCallbackEXT unbox_VkDebugReportCallbackEXT(VkDebugReportCallbackEXT boxed) {
+    return unbox_VkType<VkDebugReportCallbackEXT>(boxed);
+}
+
+VkDebugReportCallbackEXT try_unbox_VkDebugReportCallbackEXT(VkDebugReportCallbackEXT boxed) {
+    return try_unbox_VkType<VkDebugReportCallbackEXT>(boxed);
+}
+
+VkDebugReportCallbackEXT unboxed_to_boxed_non_dispatchable_VkDebugReportCallbackEXT(VkDebugReportCallbackEXT unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDebugReportCallbackEXT>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkDebugReportCallbackEXT(VkDebugReportCallbackEXT boxed, VkDebugReportCallbackEXT new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkDebugReportCallbackEXT>(boxed, new_unboxed);
+}
+
+VkDebugUtilsMessengerEXT new_boxed_non_dispatchable_VkDebugUtilsMessengerEXT(VkDebugUtilsMessengerEXT unboxed) {
+    return new_boxed_VkType<VkDebugUtilsMessengerEXT>(unboxed);
+}
+
+void delete_VkDebugUtilsMessengerEXT(VkDebugUtilsMessengerEXT boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkDebugUtilsMessengerEXT(VkDebugUtilsMessengerEXT boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkDebugUtilsMessengerEXT unbox_VkDebugUtilsMessengerEXT(VkDebugUtilsMessengerEXT boxed) {
+    return unbox_VkType<VkDebugUtilsMessengerEXT>(boxed);
+}
+
+VkDebugUtilsMessengerEXT try_unbox_VkDebugUtilsMessengerEXT(VkDebugUtilsMessengerEXT boxed) {
+    return try_unbox_VkType<VkDebugUtilsMessengerEXT>(boxed);
+}
+
+VkDebugUtilsMessengerEXT unboxed_to_boxed_non_dispatchable_VkDebugUtilsMessengerEXT(VkDebugUtilsMessengerEXT unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDebugUtilsMessengerEXT>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkDebugUtilsMessengerEXT(VkDebugUtilsMessengerEXT boxed, VkDebugUtilsMessengerEXT new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkDebugUtilsMessengerEXT>(boxed, new_unboxed);
+}
+
+VkDescriptorPool new_boxed_non_dispatchable_VkDescriptorPool(VkDescriptorPool unboxed) {
+    return new_boxed_VkType<VkDescriptorPool>(unboxed);
+}
+
+void delete_VkDescriptorPool(VkDescriptorPool boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkDescriptorPool(VkDescriptorPool boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkDescriptorPool unbox_VkDescriptorPool(VkDescriptorPool boxed) {
+    return unbox_VkType<VkDescriptorPool>(boxed);
+}
+
+VkDescriptorPool try_unbox_VkDescriptorPool(VkDescriptorPool boxed) {
+    return try_unbox_VkType<VkDescriptorPool>(boxed);
+}
+
+VkDescriptorPool unboxed_to_boxed_non_dispatchable_VkDescriptorPool(VkDescriptorPool unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDescriptorPool>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkDescriptorPool(VkDescriptorPool boxed, VkDescriptorPool new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkDescriptorPool>(boxed, new_unboxed);
+}
+
+VkDescriptorSet new_boxed_non_dispatchable_VkDescriptorSet(VkDescriptorSet unboxed) {
+    return new_boxed_VkType<VkDescriptorSet>(unboxed);
+}
+
+void delete_VkDescriptorSet(VkDescriptorSet boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkDescriptorSet(VkDescriptorSet boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkDescriptorSet unbox_VkDescriptorSet(VkDescriptorSet boxed) {
+    return unbox_VkType<VkDescriptorSet>(boxed);
+}
+
+VkDescriptorSet try_unbox_VkDescriptorSet(VkDescriptorSet boxed) {
+    return try_unbox_VkType<VkDescriptorSet>(boxed);
+}
+
+VkDescriptorSet unboxed_to_boxed_non_dispatchable_VkDescriptorSet(VkDescriptorSet unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDescriptorSet>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkDescriptorSet(VkDescriptorSet boxed, VkDescriptorSet new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkDescriptorSet>(boxed, new_unboxed);
+}
+
+VkDescriptorSetLayout new_boxed_non_dispatchable_VkDescriptorSetLayout(VkDescriptorSetLayout unboxed) {
+    return new_boxed_VkType<VkDescriptorSetLayout>(unboxed);
+}
+
+void delete_VkDescriptorSetLayout(VkDescriptorSetLayout boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkDescriptorSetLayout(VkDescriptorSetLayout boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkDescriptorSetLayout unbox_VkDescriptorSetLayout(VkDescriptorSetLayout boxed) {
+    return unbox_VkType<VkDescriptorSetLayout>(boxed);
+}
+
+VkDescriptorSetLayout try_unbox_VkDescriptorSetLayout(VkDescriptorSetLayout boxed) {
+    return try_unbox_VkType<VkDescriptorSetLayout>(boxed);
+}
+
+VkDescriptorSetLayout unboxed_to_boxed_non_dispatchable_VkDescriptorSetLayout(VkDescriptorSetLayout unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDescriptorSetLayout>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkDescriptorSetLayout(VkDescriptorSetLayout boxed, VkDescriptorSetLayout new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkDescriptorSetLayout>(boxed, new_unboxed);
+}
+
+VkDescriptorUpdateTemplate new_boxed_non_dispatchable_VkDescriptorUpdateTemplate(VkDescriptorUpdateTemplate unboxed) {
+    return new_boxed_VkType<VkDescriptorUpdateTemplate>(unboxed);
+}
+
+void delete_VkDescriptorUpdateTemplate(VkDescriptorUpdateTemplate boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkDescriptorUpdateTemplate(VkDescriptorUpdateTemplate boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkDescriptorUpdateTemplate unbox_VkDescriptorUpdateTemplate(VkDescriptorUpdateTemplate boxed) {
+    return unbox_VkType<VkDescriptorUpdateTemplate>(boxed);
+}
+
+VkDescriptorUpdateTemplate try_unbox_VkDescriptorUpdateTemplate(VkDescriptorUpdateTemplate boxed) {
+    return try_unbox_VkType<VkDescriptorUpdateTemplate>(boxed);
+}
+
+VkDescriptorUpdateTemplate unboxed_to_boxed_non_dispatchable_VkDescriptorUpdateTemplate(VkDescriptorUpdateTemplate unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDescriptorUpdateTemplate>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkDescriptorUpdateTemplate(VkDescriptorUpdateTemplate boxed, VkDescriptorUpdateTemplate new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkDescriptorUpdateTemplate>(boxed, new_unboxed);
+}
+
+VkDeviceMemory new_boxed_non_dispatchable_VkDeviceMemory(VkDeviceMemory unboxed) {
+    return new_boxed_VkType<VkDeviceMemory>(unboxed);
+}
+
+void delete_VkDeviceMemory(VkDeviceMemory boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkDeviceMemory(VkDeviceMemory boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkDeviceMemory unbox_VkDeviceMemory(VkDeviceMemory boxed) {
+    return unbox_VkType<VkDeviceMemory>(boxed);
+}
+
+VkDeviceMemory try_unbox_VkDeviceMemory(VkDeviceMemory boxed) {
+    return try_unbox_VkType<VkDeviceMemory>(boxed);
+}
+
+VkDeviceMemory unboxed_to_boxed_non_dispatchable_VkDeviceMemory(VkDeviceMemory unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDeviceMemory>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkDeviceMemory(VkDeviceMemory boxed, VkDeviceMemory new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkDeviceMemory>(boxed, new_unboxed);
+}
+
+VkDisplayKHR new_boxed_non_dispatchable_VkDisplayKHR(VkDisplayKHR unboxed) {
+    return new_boxed_VkType<VkDisplayKHR>(unboxed);
+}
+
+void delete_VkDisplayKHR(VkDisplayKHR boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkDisplayKHR(VkDisplayKHR boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkDisplayKHR unbox_VkDisplayKHR(VkDisplayKHR boxed) {
+    return unbox_VkType<VkDisplayKHR>(boxed);
+}
+
+VkDisplayKHR try_unbox_VkDisplayKHR(VkDisplayKHR boxed) {
+    return try_unbox_VkType<VkDisplayKHR>(boxed);
+}
+
+VkDisplayKHR unboxed_to_boxed_non_dispatchable_VkDisplayKHR(VkDisplayKHR unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDisplayKHR>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkDisplayKHR(VkDisplayKHR boxed, VkDisplayKHR new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkDisplayKHR>(boxed, new_unboxed);
+}
+
+VkDisplayModeKHR new_boxed_non_dispatchable_VkDisplayModeKHR(VkDisplayModeKHR unboxed) {
+    return new_boxed_VkType<VkDisplayModeKHR>(unboxed);
+}
+
+void delete_VkDisplayModeKHR(VkDisplayModeKHR boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkDisplayModeKHR(VkDisplayModeKHR boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkDisplayModeKHR unbox_VkDisplayModeKHR(VkDisplayModeKHR boxed) {
+    return unbox_VkType<VkDisplayModeKHR>(boxed);
+}
+
+VkDisplayModeKHR try_unbox_VkDisplayModeKHR(VkDisplayModeKHR boxed) {
+    return try_unbox_VkType<VkDisplayModeKHR>(boxed);
+}
+
+VkDisplayModeKHR unboxed_to_boxed_non_dispatchable_VkDisplayModeKHR(VkDisplayModeKHR unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkDisplayModeKHR>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkDisplayModeKHR(VkDisplayModeKHR boxed, VkDisplayModeKHR new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkDisplayModeKHR>(boxed, new_unboxed);
+}
+
+VkEvent new_boxed_non_dispatchable_VkEvent(VkEvent unboxed) {
+    return new_boxed_VkType<VkEvent>(unboxed);
+}
+
+void delete_VkEvent(VkEvent boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkEvent(VkEvent boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkEvent unbox_VkEvent(VkEvent boxed) {
+    return unbox_VkType<VkEvent>(boxed);
+}
+
+VkEvent try_unbox_VkEvent(VkEvent boxed) {
+    return try_unbox_VkType<VkEvent>(boxed);
+}
+
+VkEvent unboxed_to_boxed_non_dispatchable_VkEvent(VkEvent unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkEvent>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkEvent(VkEvent boxed, VkEvent new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkEvent>(boxed, new_unboxed);
+}
+
+VkFence new_boxed_non_dispatchable_VkFence(VkFence unboxed) {
+    return new_boxed_VkType<VkFence>(unboxed);
+}
+
+void delete_VkFence(VkFence boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkFence(VkFence boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkFence unbox_VkFence(VkFence boxed) {
+    return unbox_VkType<VkFence>(boxed);
+}
+
+VkFence try_unbox_VkFence(VkFence boxed) {
+    return try_unbox_VkType<VkFence>(boxed);
+}
+
+VkFence unboxed_to_boxed_non_dispatchable_VkFence(VkFence unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkFence>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkFence(VkFence boxed, VkFence new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkFence>(boxed, new_unboxed);
+}
+
+VkFramebuffer new_boxed_non_dispatchable_VkFramebuffer(VkFramebuffer unboxed) {
+    return new_boxed_VkType<VkFramebuffer>(unboxed);
+}
+
+void delete_VkFramebuffer(VkFramebuffer boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkFramebuffer(VkFramebuffer boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkFramebuffer unbox_VkFramebuffer(VkFramebuffer boxed) {
+    return unbox_VkType<VkFramebuffer>(boxed);
+}
+
+VkFramebuffer try_unbox_VkFramebuffer(VkFramebuffer boxed) {
+    return try_unbox_VkType<VkFramebuffer>(boxed);
+}
+
+VkFramebuffer unboxed_to_boxed_non_dispatchable_VkFramebuffer(VkFramebuffer unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkFramebuffer>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkFramebuffer(VkFramebuffer boxed, VkFramebuffer new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkFramebuffer>(boxed, new_unboxed);
+}
+
+VkImage new_boxed_non_dispatchable_VkImage(VkImage unboxed) {
+    return new_boxed_VkType<VkImage>(unboxed);
+}
+
+void delete_VkImage(VkImage boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkImage(VkImage boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkImage unbox_VkImage(VkImage boxed) {
+    return unbox_VkType<VkImage>(boxed);
+}
+
+VkImage try_unbox_VkImage(VkImage boxed) {
+    return try_unbox_VkType<VkImage>(boxed);
+}
+
+VkImage unboxed_to_boxed_non_dispatchable_VkImage(VkImage unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkImage>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkImage(VkImage boxed, VkImage new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkImage>(boxed, new_unboxed);
+}
+
+VkImageView new_boxed_non_dispatchable_VkImageView(VkImageView unboxed) {
+    return new_boxed_VkType<VkImageView>(unboxed);
+}
+
+void delete_VkImageView(VkImageView boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkImageView(VkImageView boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkImageView unbox_VkImageView(VkImageView boxed) {
+    return unbox_VkType<VkImageView>(boxed);
+}
+
+VkImageView try_unbox_VkImageView(VkImageView boxed) {
+    return try_unbox_VkType<VkImageView>(boxed);
+}
+
+VkImageView unboxed_to_boxed_non_dispatchable_VkImageView(VkImageView unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkImageView>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkImageView(VkImageView boxed, VkImageView new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkImageView>(boxed, new_unboxed);
+}
+
+VkIndirectCommandsLayoutNV new_boxed_non_dispatchable_VkIndirectCommandsLayoutNV(VkIndirectCommandsLayoutNV unboxed) {
+    return new_boxed_VkType<VkIndirectCommandsLayoutNV>(unboxed);
+}
+
+void delete_VkIndirectCommandsLayoutNV(VkIndirectCommandsLayoutNV boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkIndirectCommandsLayoutNV(VkIndirectCommandsLayoutNV boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkIndirectCommandsLayoutNV unbox_VkIndirectCommandsLayoutNV(VkIndirectCommandsLayoutNV boxed) {
+    return unbox_VkType<VkIndirectCommandsLayoutNV>(boxed);
+}
+
+VkIndirectCommandsLayoutNV try_unbox_VkIndirectCommandsLayoutNV(VkIndirectCommandsLayoutNV boxed) {
+    return try_unbox_VkType<VkIndirectCommandsLayoutNV>(boxed);
+}
+
+VkIndirectCommandsLayoutNV unboxed_to_boxed_non_dispatchable_VkIndirectCommandsLayoutNV(VkIndirectCommandsLayoutNV unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkIndirectCommandsLayoutNV>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkIndirectCommandsLayoutNV(VkIndirectCommandsLayoutNV boxed, VkIndirectCommandsLayoutNV new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkIndirectCommandsLayoutNV>(boxed, new_unboxed);
+}
+
+VkMicromapEXT new_boxed_non_dispatchable_VkMicromapEXT(VkMicromapEXT unboxed) {
+    return new_boxed_VkType<VkMicromapEXT>(unboxed);
+}
+
+void delete_VkMicromapEXT(VkMicromapEXT boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkMicromapEXT(VkMicromapEXT boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkMicromapEXT unbox_VkMicromapEXT(VkMicromapEXT boxed) {
+    return unbox_VkType<VkMicromapEXT>(boxed);
+}
+
+VkMicromapEXT try_unbox_VkMicromapEXT(VkMicromapEXT boxed) {
+    return try_unbox_VkType<VkMicromapEXT>(boxed);
+}
+
+VkMicromapEXT unboxed_to_boxed_non_dispatchable_VkMicromapEXT(VkMicromapEXT unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkMicromapEXT>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkMicromapEXT(VkMicromapEXT boxed, VkMicromapEXT new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkMicromapEXT>(boxed, new_unboxed);
+}
+
+VkPipeline new_boxed_non_dispatchable_VkPipeline(VkPipeline unboxed) {
+    return new_boxed_VkType<VkPipeline>(unboxed);
+}
+
+void delete_VkPipeline(VkPipeline boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkPipeline(VkPipeline boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkPipeline unbox_VkPipeline(VkPipeline boxed) {
+    return unbox_VkType<VkPipeline>(boxed);
+}
+
+VkPipeline try_unbox_VkPipeline(VkPipeline boxed) {
+    return try_unbox_VkType<VkPipeline>(boxed);
+}
+
+VkPipeline unboxed_to_boxed_non_dispatchable_VkPipeline(VkPipeline unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkPipeline>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkPipeline(VkPipeline boxed, VkPipeline new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkPipeline>(boxed, new_unboxed);
+}
+
+VkPipelineCache new_boxed_non_dispatchable_VkPipelineCache(VkPipelineCache unboxed) {
+    return new_boxed_VkType<VkPipelineCache>(unboxed);
+}
+
+void delete_VkPipelineCache(VkPipelineCache boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkPipelineCache(VkPipelineCache boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkPipelineCache unbox_VkPipelineCache(VkPipelineCache boxed) {
+    return unbox_VkType<VkPipelineCache>(boxed);
+}
+
+VkPipelineCache try_unbox_VkPipelineCache(VkPipelineCache boxed) {
+    return try_unbox_VkType<VkPipelineCache>(boxed);
+}
+
+VkPipelineCache unboxed_to_boxed_non_dispatchable_VkPipelineCache(VkPipelineCache unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkPipelineCache>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkPipelineCache(VkPipelineCache boxed, VkPipelineCache new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkPipelineCache>(boxed, new_unboxed);
+}
+
+VkPipelineLayout new_boxed_non_dispatchable_VkPipelineLayout(VkPipelineLayout unboxed) {
+    return new_boxed_VkType<VkPipelineLayout>(unboxed);
+}
+
+void delete_VkPipelineLayout(VkPipelineLayout boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkPipelineLayout(VkPipelineLayout boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkPipelineLayout unbox_VkPipelineLayout(VkPipelineLayout boxed) {
+    return unbox_VkType<VkPipelineLayout>(boxed);
+}
+
+VkPipelineLayout try_unbox_VkPipelineLayout(VkPipelineLayout boxed) {
+    return try_unbox_VkType<VkPipelineLayout>(boxed);
+}
+
+VkPipelineLayout unboxed_to_boxed_non_dispatchable_VkPipelineLayout(VkPipelineLayout unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkPipelineLayout>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkPipelineLayout(VkPipelineLayout boxed, VkPipelineLayout new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkPipelineLayout>(boxed, new_unboxed);
+}
+
+VkPrivateDataSlot new_boxed_non_dispatchable_VkPrivateDataSlot(VkPrivateDataSlot unboxed) {
+    return new_boxed_VkType<VkPrivateDataSlot>(unboxed);
+}
+
+void delete_VkPrivateDataSlot(VkPrivateDataSlot boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkPrivateDataSlot(VkPrivateDataSlot boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkPrivateDataSlot unbox_VkPrivateDataSlot(VkPrivateDataSlot boxed) {
+    return unbox_VkType<VkPrivateDataSlot>(boxed);
+}
+
+VkPrivateDataSlot try_unbox_VkPrivateDataSlot(VkPrivateDataSlot boxed) {
+    return try_unbox_VkType<VkPrivateDataSlot>(boxed);
+}
+
+VkPrivateDataSlot unboxed_to_boxed_non_dispatchable_VkPrivateDataSlot(VkPrivateDataSlot unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkPrivateDataSlot>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkPrivateDataSlot(VkPrivateDataSlot boxed, VkPrivateDataSlot new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkPrivateDataSlot>(boxed, new_unboxed);
+}
+
+VkQueryPool new_boxed_non_dispatchable_VkQueryPool(VkQueryPool unboxed) {
+    return new_boxed_VkType<VkQueryPool>(unboxed);
+}
+
+void delete_VkQueryPool(VkQueryPool boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkQueryPool(VkQueryPool boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkQueryPool unbox_VkQueryPool(VkQueryPool boxed) {
+    return unbox_VkType<VkQueryPool>(boxed);
+}
+
+VkQueryPool try_unbox_VkQueryPool(VkQueryPool boxed) {
+    return try_unbox_VkType<VkQueryPool>(boxed);
+}
+
+VkQueryPool unboxed_to_boxed_non_dispatchable_VkQueryPool(VkQueryPool unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkQueryPool>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkQueryPool(VkQueryPool boxed, VkQueryPool new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkQueryPool>(boxed, new_unboxed);
+}
+
+VkRenderPass new_boxed_non_dispatchable_VkRenderPass(VkRenderPass unboxed) {
+    return new_boxed_VkType<VkRenderPass>(unboxed);
+}
+
+void delete_VkRenderPass(VkRenderPass boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkRenderPass(VkRenderPass boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkRenderPass unbox_VkRenderPass(VkRenderPass boxed) {
+    return unbox_VkType<VkRenderPass>(boxed);
+}
+
+VkRenderPass try_unbox_VkRenderPass(VkRenderPass boxed) {
+    return try_unbox_VkType<VkRenderPass>(boxed);
+}
+
+VkRenderPass unboxed_to_boxed_non_dispatchable_VkRenderPass(VkRenderPass unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkRenderPass>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkRenderPass(VkRenderPass boxed, VkRenderPass new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkRenderPass>(boxed, new_unboxed);
+}
+
+VkSampler new_boxed_non_dispatchable_VkSampler(VkSampler unboxed) {
+    return new_boxed_VkType<VkSampler>(unboxed);
+}
+
+void delete_VkSampler(VkSampler boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkSampler(VkSampler boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkSampler unbox_VkSampler(VkSampler boxed) {
+    return unbox_VkType<VkSampler>(boxed);
+}
+
+VkSampler try_unbox_VkSampler(VkSampler boxed) {
+    return try_unbox_VkType<VkSampler>(boxed);
+}
+
+VkSampler unboxed_to_boxed_non_dispatchable_VkSampler(VkSampler unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkSampler>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkSampler(VkSampler boxed, VkSampler new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkSampler>(boxed, new_unboxed);
+}
+
+VkSamplerYcbcrConversion new_boxed_non_dispatchable_VkSamplerYcbcrConversion(VkSamplerYcbcrConversion unboxed) {
+    return new_boxed_VkType<VkSamplerYcbcrConversion>(unboxed);
+}
+
+void delete_VkSamplerYcbcrConversion(VkSamplerYcbcrConversion boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkSamplerYcbcrConversion(VkSamplerYcbcrConversion boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkSamplerYcbcrConversion unbox_VkSamplerYcbcrConversion(VkSamplerYcbcrConversion boxed) {
+    return unbox_VkType<VkSamplerYcbcrConversion>(boxed);
+}
+
+VkSamplerYcbcrConversion try_unbox_VkSamplerYcbcrConversion(VkSamplerYcbcrConversion boxed) {
+    return try_unbox_VkType<VkSamplerYcbcrConversion>(boxed);
+}
+
+VkSamplerYcbcrConversion unboxed_to_boxed_non_dispatchable_VkSamplerYcbcrConversion(VkSamplerYcbcrConversion unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkSamplerYcbcrConversion>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkSamplerYcbcrConversion(VkSamplerYcbcrConversion boxed, VkSamplerYcbcrConversion new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkSamplerYcbcrConversion>(boxed, new_unboxed);
+}
+
+VkSemaphore new_boxed_non_dispatchable_VkSemaphore(VkSemaphore unboxed) {
+    return new_boxed_VkType<VkSemaphore>(unboxed);
+}
+
+void delete_VkSemaphore(VkSemaphore boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkSemaphore(VkSemaphore boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkSemaphore unbox_VkSemaphore(VkSemaphore boxed) {
+    return unbox_VkType<VkSemaphore>(boxed);
+}
+
+VkSemaphore try_unbox_VkSemaphore(VkSemaphore boxed) {
+    return try_unbox_VkType<VkSemaphore>(boxed);
+}
+
+VkSemaphore unboxed_to_boxed_non_dispatchable_VkSemaphore(VkSemaphore unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkSemaphore>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkSemaphore(VkSemaphore boxed, VkSemaphore new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkSemaphore>(boxed, new_unboxed);
+}
+
+VkShaderModule new_boxed_non_dispatchable_VkShaderModule(VkShaderModule unboxed) {
+    return new_boxed_VkType<VkShaderModule>(unboxed);
+}
+
+void delete_VkShaderModule(VkShaderModule boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkShaderModule(VkShaderModule boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkShaderModule unbox_VkShaderModule(VkShaderModule boxed) {
+    return unbox_VkType<VkShaderModule>(boxed);
+}
+
+VkShaderModule try_unbox_VkShaderModule(VkShaderModule boxed) {
+    return try_unbox_VkType<VkShaderModule>(boxed);
+}
+
+VkShaderModule unboxed_to_boxed_non_dispatchable_VkShaderModule(VkShaderModule unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkShaderModule>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkShaderModule(VkShaderModule boxed, VkShaderModule new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkShaderModule>(boxed, new_unboxed);
+}
+
+VkSurfaceKHR new_boxed_non_dispatchable_VkSurfaceKHR(VkSurfaceKHR unboxed) {
+    return new_boxed_VkType<VkSurfaceKHR>(unboxed);
+}
+
+void delete_VkSurfaceKHR(VkSurfaceKHR boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkSurfaceKHR(VkSurfaceKHR boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkSurfaceKHR unbox_VkSurfaceKHR(VkSurfaceKHR boxed) {
+    return unbox_VkType<VkSurfaceKHR>(boxed);
+}
+
+VkSurfaceKHR try_unbox_VkSurfaceKHR(VkSurfaceKHR boxed) {
+    return try_unbox_VkType<VkSurfaceKHR>(boxed);
+}
+
+VkSurfaceKHR unboxed_to_boxed_non_dispatchable_VkSurfaceKHR(VkSurfaceKHR unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkSurfaceKHR>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkSurfaceKHR(VkSurfaceKHR boxed, VkSurfaceKHR new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkSurfaceKHR>(boxed, new_unboxed);
+}
+
+VkSwapchainKHR new_boxed_non_dispatchable_VkSwapchainKHR(VkSwapchainKHR unboxed) {
+    return new_boxed_VkType<VkSwapchainKHR>(unboxed);
+}
+
+void delete_VkSwapchainKHR(VkSwapchainKHR boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkSwapchainKHR(VkSwapchainKHR boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkSwapchainKHR unbox_VkSwapchainKHR(VkSwapchainKHR boxed) {
+    return unbox_VkType<VkSwapchainKHR>(boxed);
+}
+
+VkSwapchainKHR try_unbox_VkSwapchainKHR(VkSwapchainKHR boxed) {
+    return try_unbox_VkType<VkSwapchainKHR>(boxed);
+}
+
+VkSwapchainKHR unboxed_to_boxed_non_dispatchable_VkSwapchainKHR(VkSwapchainKHR unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkSwapchainKHR>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkSwapchainKHR(VkSwapchainKHR boxed, VkSwapchainKHR new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkSwapchainKHR>(boxed, new_unboxed);
+}
+
+VkValidationCacheEXT new_boxed_non_dispatchable_VkValidationCacheEXT(VkValidationCacheEXT unboxed) {
+    return new_boxed_VkType<VkValidationCacheEXT>(unboxed);
+}
+
+void delete_VkValidationCacheEXT(VkValidationCacheEXT boxed) {
+    delete_VkType(boxed);
+}
+
+void delayed_delete_VkValidationCacheEXT(VkValidationCacheEXT boxed, VkDevice device, std::function<void()> callback) {
+    delayed_delete_VkType(boxed, device, std::move(callback));
+}
+
+VkValidationCacheEXT unbox_VkValidationCacheEXT(VkValidationCacheEXT boxed) {
+    return unbox_VkType<VkValidationCacheEXT>(boxed);
+}
+
+VkValidationCacheEXT try_unbox_VkValidationCacheEXT(VkValidationCacheEXT boxed) {
+    return try_unbox_VkType<VkValidationCacheEXT>(boxed);
+}
+
+VkValidationCacheEXT unboxed_to_boxed_non_dispatchable_VkValidationCacheEXT(VkValidationCacheEXT unboxed) {
+    return unboxed_to_boxed_non_dispatchable_VkType<VkValidationCacheEXT>(unboxed);
+}
+
+void set_boxed_non_dispatchable_VkValidationCacheEXT(VkValidationCacheEXT boxed, VkValidationCacheEXT new_unboxed) {
+    set_boxed_non_dispatchable_VkType<VkValidationCacheEXT>(boxed, new_unboxed);
+}
+
+}  // namespace vk
+}  // namespace gfxstream
diff --git a/host/vulkan/VulkanBoxedHandles.h b/host/vulkan/VulkanBoxedHandles.h
new file mode 100644
index 000000000..1d2d4eb34
--- /dev/null
+++ b/host/vulkan/VulkanBoxedHandles.h
@@ -0,0 +1,151 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <deque>
+#include <mutex>
+
+#include "VulkanDispatch.h"
+#include "VulkanHandles.h"
+#include "VulkanStream.h"
+#include "aemu/base/ThreadAnnotations.h"
+#include "aemu/base/containers/HybridEntityManager.h"
+#include "aemu/base/containers/Lookup.h"
+#include "aemu/base/synchronization/ConditionVariable.h"
+#include "aemu/base/synchronization/Lock.h"
+
+namespace gfxstream {
+namespace vk {
+
+#define DEFINE_BOXED_HANDLE_TYPE_TAG(type) Tag_##type,
+
+enum BoxedHandleTypeTag {
+    Tag_Invalid = 0,
+
+    GOLDFISH_VK_LIST_HANDLE_TYPES_BY_STAGE(DEFINE_BOXED_HANDLE_TYPE_TAG)
+
+    // additional generic tag
+    Tag_VkGeneric = 1001,
+};
+
+using BoxedHandle = uint64_t;
+using UnboxedHandle = uint64_t;
+
+struct OrderMaintenanceInfo {
+    uint32_t sequenceNumber = 0;
+    android::base::Lock lock;
+    android::base::ConditionVariable cv;
+
+    uint32_t refcount = 1;
+
+    void incRef() { __atomic_add_fetch(&refcount, 1, __ATOMIC_SEQ_CST); }
+
+    bool decRef() { return 0 == __atomic_sub_fetch(&refcount, 1, __ATOMIC_SEQ_CST); }
+};
+
+inline void acquireOrderMaintInfo(OrderMaintenanceInfo* ord) {
+    if (!ord) return;
+    ord->incRef();
+}
+
+inline void releaseOrderMaintInfo(OrderMaintenanceInfo* ord) {
+    if (!ord) return;
+    if (ord->decRef()) delete ord;
+}
+
+class BoxedHandleInfo {
+   public:
+    UnboxedHandle underlying;
+    VulkanDispatch* dispatch = nullptr;
+    bool ownDispatch = false;
+    OrderMaintenanceInfo* ordMaintInfo = nullptr;
+    VulkanMemReadingStream* readStream = nullptr;
+};
+
+class BoxedHandleManager {
+   public:
+    // The hybrid entity manager uses a sequence lock to protect access to
+    // a working set of 16000 handles, allowing us to avoid using a regular
+    // lock for those. Performance is degraded when going over this number,
+    // as it will then fall back to a std::map.
+    //
+    // We use 16000 as the max number of live handles to track; we don't
+    // expect the system to go over 16000 total live handles, outside some
+    // dEQP object management tests.
+    using Store = android::base::HybridEntityManager<16000, BoxedHandle, BoxedHandleInfo>;
+
+    BoxedHandle add(const BoxedHandleInfo& item, BoxedHandleTypeTag tag);
+
+    void update(BoxedHandle handle, const BoxedHandleInfo& item, BoxedHandleTypeTag tag);
+
+    void remove(BoxedHandle h);
+    void removeDelayed(uint64_t h, VkDevice device, std::function<void()> callback);
+
+    // Do not call directly! Instead use `processDelayedRemovesForDevice()` which has
+    // thread safety annotations for `VkDecoderGlobalState::Impl`.
+    void processDelayedRemoves(VkDevice device);
+
+    BoxedHandleInfo* get(BoxedHandle handle);
+    BoxedHandle getBoxedFromUnboxed(UnboxedHandle unboxed);
+
+    void replayHandles(std::vector<BoxedHandle> handles);
+
+    void clear();
+
+   private:
+    mutable Store mStore;
+
+    std::mutex mMutex;
+    std::unordered_map<UnboxedHandle, BoxedHandle> mReverseMap GUARDED_BY(mMutex);
+
+    struct DelayedRemove {
+        BoxedHandle handle;
+        std::function<void()> callback;
+    };
+    std::unordered_map<VkDevice, std::vector<DelayedRemove>> mDelayedRemoves GUARDED_BY(mMutex);
+
+    // If true, `add()` will use and consume the handles in `mHandleReplayQueue`.
+    // This is useful for snapshot loading when a explicit set of handles should
+    // be used when replaying commands.
+    bool mHandleReplay = false;
+    std::deque<BoxedHandle> mHandleReplayQueue;
+};
+
+extern BoxedHandleManager sBoxedHandleManager;
+
+#define DEFINE_BOXED_DISPATCHABLE_HANDLE_API_DECL(type)                                 \
+    type new_boxed_##type(type underlying, VulkanDispatch* dispatch, bool ownDispatch); \
+    void delete_##type(type boxed);                                                     \
+    type unbox_##type(type boxed);                                                      \
+    type try_unbox_##type(type boxed);                                                  \
+    type unboxed_to_boxed_##type(type boxed);                                           \
+    VulkanDispatch* dispatch_##type(type boxed);                                        \
+    OrderMaintenanceInfo* ordmaint_##type(type boxed);                                  \
+    VulkanMemReadingStream* readstream_##type(type boxed);
+
+#define DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_DECL(type)                                  \
+    type new_boxed_non_dispatchable_##type(type underlying);                                 \
+    void delete_##type(type boxed);                                                          \
+    void delayed_delete_##type(type boxed, VkDevice device, std::function<void()> callback); \
+    type unbox_##type(type boxed);                                                           \
+    type try_unbox_##type(type boxed);                                                       \
+    type unboxed_to_boxed_non_dispatchable_##type(type boxed);                               \
+    void set_boxed_non_dispatchable_##type(type boxed, type underlying);
+
+GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_API_DECL)
+GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_API_DECL)
+
+}  // namespace vk
+}  // namespace gfxstream
diff --git a/host/vulkan/VulkanDispatch.cpp b/host/vulkan/VulkanDispatch.cpp
index fd3048888..4977b367f 100644
--- a/host/vulkan/VulkanDispatch.cpp
+++ b/host/vulkan/VulkanDispatch.cpp
@@ -45,25 +45,15 @@ static std::string icdJsonNameToProgramAndLauncherPaths(const std::string& icdFi
 static void setIcdPaths(const std::string& icdFilename) {
     const std::string paths = icdJsonNameToProgramAndLauncherPaths(icdFilename);
     INFO("Setting ICD filenames for the loader = %s", paths.c_str());
+    // Set both for backwards compatibility
+    android::base::setEnvironmentVariable("VK_DRIVER_FILES", paths);
     android::base::setEnvironmentVariable("VK_ICD_FILENAMES", paths);
 }
 
-static const char* getTestIcdFilename() {
-#if defined(__APPLE__)
-    return "libvk_swiftshader.dylib";
-#elif defined(__linux__) || defined(__QNX__)
-    return "libvk_swiftshader.so";
-#elif defined(_WIN32) || defined(_MSC_VER)
-    return "vk_swiftshader.dll";
-#else
-#error Host operating system not supported
-#endif
-}
-
 static void initIcdPaths(bool forTesting) {
     auto androidIcd = android::base::getEnvironmentVariable("ANDROID_EMU_VK_ICD");
     if (androidIcd == "") {
-        // Rely on user to set VK_ICD_FILENAMES
+        // Rely on user to set VK_DRIVER_FILES
         return;
     }
 
@@ -73,8 +63,10 @@ static void initIcdPaths(bool forTesting) {
         android::base::setEnvironmentVariable("ANDROID_EMU_VK_ICD", testingICD);
         androidIcd = testingICD;
     }
-
-    if (androidIcd == "swiftshader") {
+    if (androidIcd == "lavapipe") {
+        INFO("%s: ICD set to 'lavapipe', using Lavapipe ICD", __func__);
+        setIcdPaths("lvp_icd.x86_64.json");
+    } else if (androidIcd == "swiftshader") {
         INFO("%s: ICD set to 'swiftshader', using Swiftshader ICD", __func__);
         setIcdPaths("vk_swiftshader_icd.json");
     } else {
diff --git a/host/vulkan/VulkanHandleMapping.cpp b/host/vulkan/VulkanHandleMapping.cpp
index 1b5c6a669..bc35284f7 100644
--- a/host/vulkan/VulkanHandleMapping.cpp
+++ b/host/vulkan/VulkanHandleMapping.cpp
@@ -16,6 +16,9 @@
 
 #include <vulkan/vulkan.h>
 
+#include "VkDecoderGlobalState.h"
+#include "VulkanBoxedHandles.h"
+
 namespace gfxstream {
 namespace vk {
 
@@ -36,5 +39,119 @@ namespace vk {
 
 GOLDFISH_VK_LIST_HANDLE_TYPES(DEFAULT_HANDLE_MAP_DEFINE)
 
+
+#define MAKE_HANDLE_MAPPING_FOREACH(class_name, type_name, map_impl, map_to_u64_impl, map_from_u64_impl)       \
+    void class_name::mapHandles_##type_name(type_name* handles, size_t count)  {                               \
+        for (size_t i = 0; i < count; ++i) {                                                                   \
+            map_impl                                                                                           \
+        }                                                                                                      \
+    }                                                                                                          \
+    void class_name::mapHandles_##type_name##_u64(const type_name* handles, uint64_t* handle_u64s, size_t count)  { \
+        for (size_t i = 0; i < count; ++i) {                                                                        \
+            map_to_u64_impl                                                                                         \
+        }                                                                                                           \
+    }                                                                                                               \
+    void class_name::mapHandles_u64_##type_name(const uint64_t* handle_u64s, type_name* handles, size_t count) {    \
+        for (size_t i = 0; i < count; ++i) {                                                                        \
+            map_from_u64_impl                                                                                       \
+        }                                                                                                           \
+    }
+
+#define BOXED_DISPATCHABLE_UNWRAP_IMPL(type_name)                                                  \
+    MAKE_HANDLE_MAPPING_FOREACH(                                                                   \
+        BoxedHandleUnwrapMapping,                                                                  \
+        type_name,                                                                                 \
+        if (handles[i]) {                                                                          \
+            handles[i] = unbox_##type_name(handles[i]);                                            \
+        } else {                                                                                   \
+            handles[i] = (type_name) nullptr;                                                      \
+        }                                                                                          \
+        ,                                                                                          \
+        if (handles[i]) {                                                                          \
+            handle_u64s[i] = (uint64_t)unbox_##type_name(handles[i]);                              \
+        } else {                                                                                   \
+            handle_u64s[i] = 0;                                                                    \
+        },                                                                                         \
+        if (handle_u64s[i]) {                                                                      \
+            handles[i] = unbox_##type_name((type_name)(uintptr_t)handle_u64s[i]);                  \
+        } else {                                                                                   \
+            handles[i] = (type_name) nullptr;                                                      \
+        })
+
+#define BOXED_NON_DISPATCHABLE_UNWRAP_IMPL(type_name)                                              \
+    MAKE_HANDLE_MAPPING_FOREACH(                                                                   \
+        BoxedHandleUnwrapMapping,                                                                  \
+        type_name,                                                                                 \
+        if (handles[i]) {                                                                          \
+            handles[i] = unbox_##type_name(handles[i]);                                            \
+        } else {                                                                                   \
+            handles[i] = (type_name) nullptr;                                                      \
+        }                                                                                          \
+        ,                                                                                          \
+        if (handles[i]) {                                                                          \
+            handle_u64s[i] = (uint64_t)unbox_##type_name(handles[i]);                              \
+        } else {                                                                                   \
+            handle_u64s[i] = 0;                                                                    \
+        },                                                                                         \
+        if (handle_u64s[i]) {                                                                      \
+            handles[i] = unbox_##type_name((type_name)(uintptr_t)handle_u64s[i]);                  \
+        } else {                                                                                   \
+            handles[i] = (type_name) nullptr;                                                      \
+        })
+
+GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(BOXED_DISPATCHABLE_UNWRAP_IMPL)
+GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(BOXED_NON_DISPATCHABLE_UNWRAP_IMPL)
+
+// Not used, so we do not define.
+#define BOXED_DISPATCHABLE_CREATE_IMPL(type_name)                                  \
+    MAKE_HANDLE_MAPPING_FOREACH(                                                   \
+        BoxedHandleCreateMapping,                                                  \
+        type_name,                                                                 \
+        (void)handles[i]; ,                                                        \
+        (void)handle_u64s[i]; ,                                                    \
+        (void)handles[i];                                                          \
+        )
+
+// We only use the create/destroy mappings for non dispatchable handles.
+#define BOXED_NON_DISPATCHABLE_CREATE_IMPL(type_name)                                    \
+    MAKE_HANDLE_MAPPING_FOREACH(                                                         \
+        BoxedHandleCreateMapping,                                                        \
+        type_name,                                                                       \
+        handles[i] = new_boxed_non_dispatchable_##type_name(handles[i]); ,               \
+        handle_u64s[i] = (uint64_t)new_boxed_non_dispatchable_##type_name(handles[i]); , \
+        handles[i] = (type_name)new_boxed_non_dispatchable_##type_name(                  \
+            (type_name)(uintptr_t)handle_u64s[i]);                                       \
+        )
+
+#define BOXED_NON_DISPATCHABLE_UNWRAP_AND_DELETE_IMPL(type_name)                           \
+    MAKE_HANDLE_MAPPING_FOREACH(                                                           \
+        BoxedHandleCreateMapping,                                                          \
+        type_name,                                                                         \
+        if (handles[i]) {                                                                  \
+            auto boxed = handles[i];                                                       \
+            handles[i] = unbox_##type_name(handles[i]);                                    \
+            delete_##type_name(boxed);                                                     \
+        } else {                                                                           \
+            handles[i] = (type_name) nullptr;                                              \
+        }                                                                                  \
+        ,                                                                                  \
+        if (handles[i]) {                                                                  \
+            auto boxed = handles[i];                                                       \
+            handle_u64s[i] = (uint64_t)unbox_##type_name(handles[i]);                      \
+            delete_##type_name(boxed);                                                     \
+        } else {                                                                           \
+            handle_u64s[i] = 0;                                                            \
+        },                                                                                 \
+        if (handle_u64s[i]) {                                                              \
+            auto boxed = (type_name)(uintptr_t)handle_u64s[i];                             \
+            handles[i] = unbox_##type_name((type_name)(uintptr_t)handle_u64s[i]);          \
+            delete_##type_name(boxed);                                                     \
+        } else {                                                                           \
+            handles[i] = (type_name) nullptr;                                              \
+        })
+
+GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(BOXED_DISPATCHABLE_CREATE_IMPL)
+GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(BOXED_NON_DISPATCHABLE_CREATE_IMPL)
+
 }  // namespace vk
 }  // namespace gfxstream
diff --git a/host/vulkan/VulkanHandleMapping.h b/host/vulkan/VulkanHandleMapping.h
index aa6baf7dd..2a8a9fd78 100644
--- a/host/vulkan/VulkanHandleMapping.h
+++ b/host/vulkan/VulkanHandleMapping.h
@@ -43,39 +43,31 @@ class VulkanHandleMapping {
     VkDecoderGlobalState* m_state;
 };
 
+#define DECLARE_HANDLE_MAP_OVERRIDE(type)                                                            \
+    void mapHandles_##type(type* handles, size_t count) override;                                    \
+    void mapHandles_##type##_u64(const type* handles, uint64_t* handle_u64s, size_t count) override; \
+    void mapHandles_u64_##type(const uint64_t* handle_u64s, type* handles, size_t count) override;
+
 class DefaultHandleMapping : public VulkanHandleMapping {
    public:
     DefaultHandleMapping() : VulkanHandleMapping(nullptr) {}
     virtual ~DefaultHandleMapping() {}
-
-#define DECLARE_HANDLE_MAP_OVERRIDE(type)                                                  \
-    void mapHandles_##type(type* handles, size_t count) override;                          \
-    void mapHandles_##type##_u64(const type* handles, uint64_t* handle_u64s, size_t count) \
-        override;                                                                          \
-    void mapHandles_u64_##type(const uint64_t* handle_u64s, type* handles, size_t count) override;
-
     GOLDFISH_VK_LIST_HANDLE_TYPES(DECLARE_HANDLE_MAP_OVERRIDE)
 };
 
-#define DEFINE_BOXED_DISPATCHABLE_HANDLE_GLOBAL_API_DECL(type) \
-    type unbox_##type(type boxed);                             \
-    type try_unbox_##type(type boxed);                         \
-    type unboxed_to_boxed_##type(type boxed);                  \
-    void delete_##type(type boxed);                            \
-    VulkanDispatch* dispatch_##type(type boxed);
-
-GOLDFISH_VK_LIST_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_DISPATCHABLE_HANDLE_GLOBAL_API_DECL)
-
-#define DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_GLOBAL_API_DECL(type)                           \
-    type new_boxed_non_dispatchable_##type(type underlying);                                 \
-    void delete_##type(type boxed);                                                          \
-    void delayed_delete_##type(type boxed, VkDevice device, std::function<void()> callback); \
-    void set_boxed_non_dispatchable_##type(type boxed, type underlying);                     \
-    type unbox_##type(type boxed);                                                           \
-    type try_unbox_##type(type boxed);                                                       \
-    type unboxed_to_boxed_non_dispatchable_##type(type boxed);
+class BoxedHandleCreateMapping : public VulkanHandleMapping {
+   public:
+    BoxedHandleCreateMapping(VkDecoderGlobalState* state) : VulkanHandleMapping(state) {}
+    virtual ~BoxedHandleCreateMapping() {}
+    GOLDFISH_VK_LIST_HANDLE_TYPES(DECLARE_HANDLE_MAP_OVERRIDE)
+};
 
-GOLDFISH_VK_LIST_NON_DISPATCHABLE_HANDLE_TYPES(DEFINE_BOXED_NON_DISPATCHABLE_HANDLE_GLOBAL_API_DECL)
+class BoxedHandleUnwrapMapping : public VulkanHandleMapping {
+   public:
+    BoxedHandleUnwrapMapping(VkDecoderGlobalState* state) : VulkanHandleMapping(state) {}
+    virtual ~BoxedHandleUnwrapMapping() {}
+    GOLDFISH_VK_LIST_HANDLE_TYPES(DECLARE_HANDLE_MAP_OVERRIDE)
+};
 
 }  // namespace vk
 }  // namespace gfxstream
diff --git a/host/vulkan/VulkanStream.cpp b/host/vulkan/VulkanStream.cpp
index 36fb8ae68..0c0cefec9 100644
--- a/host/vulkan/VulkanStream.cpp
+++ b/host/vulkan/VulkanStream.cpp
@@ -187,7 +187,6 @@ VulkanMemReadingStream::~VulkanMemReadingStream() {}
 void VulkanMemReadingStream::setBuf(uint8_t* buf) {
     mStart = buf;
     mReadPos = 0;
-    resetTrace();
 }
 
 uint8_t* VulkanMemReadingStream::getBuf() { return mStart; }
@@ -205,18 +204,5 @@ ssize_t VulkanMemReadingStream::write(const void* buffer, size_t size) {
         << "VulkanMemReadingStream does not support writing";
 }
 
-uint8_t* VulkanMemReadingStream::beginTrace() {
-    resetTrace();
-    return mTraceStart;
-}
-
-size_t VulkanMemReadingStream::endTrace() {
-    uintptr_t current = (uintptr_t)(mStart + mReadPos);
-    size_t res = (size_t)(current - (uintptr_t)mTraceStart);
-    return res;
-}
-
-void VulkanMemReadingStream::resetTrace() { mTraceStart = mStart + mReadPos; }
-
 }  // namespace vk
 }  // namespace gfxstream
diff --git a/host/vulkan/VulkanStream.h b/host/vulkan/VulkanStream.h
index 13892ee6e..e5263a3be 100644
--- a/host/vulkan/VulkanStream.h
+++ b/host/vulkan/VulkanStream.h
@@ -100,14 +100,8 @@ class VulkanMemReadingStream : public VulkanStream {
     ssize_t read(void* buffer, size_t size) override;
     ssize_t write(const void* buffer, size_t size) override;
 
-    uint8_t* beginTrace();
-    size_t endTrace();
-
    private:
-    void resetTrace();
-
     uint8_t* mStart;
-    uint8_t* mTraceStart;
     uintptr_t mReadPos = 0;
 };
 
diff --git a/host/vulkan/cereal/common/goldfish_vk_deepcopy.cpp b/host/vulkan/cereal/common/goldfish_vk_deepcopy.cpp
index bb0c4a063..baed1124c 100644
--- a/host/vulkan/cereal/common/goldfish_vk_deepcopy.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_deepcopy.cpp
@@ -94,7 +94,7 @@ void deepcopy_VkBaseInStructure(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -115,7 +115,7 @@ void deepcopy_VkBaseOutStructure(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -136,7 +136,7 @@ void deepcopy_VkBufferMemoryBarrier(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -188,7 +188,7 @@ void deepcopy_VkImageMemoryBarrier(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -211,7 +211,7 @@ void deepcopy_VkMemoryBarrier(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -252,7 +252,7 @@ void deepcopy_VkApplicationInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -297,7 +297,7 @@ void deepcopy_VkInstanceCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -420,7 +420,7 @@ void deepcopy_VkDeviceQueueCreateInfo(Allocator* alloc, VkStructureType rootType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -446,7 +446,7 @@ void deepcopy_VkDeviceCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -514,7 +514,7 @@ void deepcopy_VkSubmitInfo(Allocator* alloc, VkStructureType rootType, const VkS
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -555,7 +555,7 @@ void deepcopy_VkMappedMemoryRange(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -576,7 +576,7 @@ void deepcopy_VkMemoryAllocateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -690,7 +690,7 @@ void deepcopy_VkBindSparseInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -780,7 +780,7 @@ void deepcopy_VkFenceCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -801,7 +801,7 @@ void deepcopy_VkSemaphoreCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -822,7 +822,7 @@ void deepcopy_VkEventCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -843,7 +843,7 @@ void deepcopy_VkQueryPoolCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -864,7 +864,7 @@ void deepcopy_VkBufferCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -891,7 +891,7 @@ void deepcopy_VkBufferViewCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -912,7 +912,7 @@ void deepcopy_VkImageCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -953,7 +953,7 @@ void deepcopy_VkImageViewCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -979,7 +979,7 @@ void deepcopy_VkShaderModuleCreateInfo(Allocator* alloc, VkStructureType rootTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1006,7 +1006,7 @@ void deepcopy_VkPipelineCacheCreateInfo(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1064,7 +1064,7 @@ void deepcopy_VkPipelineShaderStageCreateInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1097,7 +1097,7 @@ void deepcopy_VkComputePipelineCreateInfo(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1137,7 +1137,7 @@ void deepcopy_VkPipelineVertexInputStateCreateInfo(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1187,7 +1187,7 @@ void deepcopy_VkPipelineInputAssemblyStateCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1209,7 +1209,7 @@ void deepcopy_VkPipelineTessellationStateCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1238,7 +1238,7 @@ void deepcopy_VkPipelineViewportStateCreateInfo(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1283,7 +1283,7 @@ void deepcopy_VkPipelineRasterizationStateCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1305,7 +1305,7 @@ void deepcopy_VkPipelineMultisampleStateCreateInfo(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1340,7 +1340,7 @@ void deepcopy_VkPipelineDepthStencilStateCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1372,7 +1372,7 @@ void deepcopy_VkPipelineColorBlendStateCreateInfo(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1408,7 +1408,7 @@ void deepcopy_VkPipelineDynamicStateCreateInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1435,7 +1435,7 @@ void deepcopy_VkGraphicsPipelineCreateInfo(Allocator* alloc, VkStructureType roo
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1549,7 +1549,7 @@ void deepcopy_VkPipelineLayoutCreateInfo(Allocator* alloc, VkStructureType rootT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1587,7 +1587,7 @@ void deepcopy_VkSamplerCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1608,7 +1608,7 @@ void deepcopy_VkCopyDescriptorSet(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1652,7 +1652,7 @@ void deepcopy_VkDescriptorPoolCreateInfo(Allocator* alloc, VkStructureType rootT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1686,7 +1686,7 @@ void deepcopy_VkDescriptorSetAllocateInfo(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1726,7 +1726,7 @@ void deepcopy_VkDescriptorSetLayoutCreateInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1760,7 +1760,7 @@ void deepcopy_VkWriteDescriptorSet(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1826,7 +1826,7 @@ void deepcopy_VkFramebufferCreateInfo(Allocator* alloc, VkStructureType rootType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1916,7 +1916,7 @@ void deepcopy_VkRenderPassCreateInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1974,7 +1974,7 @@ void deepcopy_VkCommandPoolCreateInfo(Allocator* alloc, VkStructureType rootType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -1996,7 +1996,7 @@ void deepcopy_VkCommandBufferAllocateInfo(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2018,7 +2018,7 @@ void deepcopy_VkCommandBufferInheritanceInfo(Allocator* alloc, VkStructureType r
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2040,7 +2040,7 @@ void deepcopy_VkCommandBufferBeginInfo(Allocator* alloc, VkStructureType rootTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2186,7 +2186,7 @@ void deepcopy_VkRenderPassBeginInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2223,7 +2223,7 @@ void deepcopy_VkPhysicalDeviceSubgroupProperties(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2245,7 +2245,7 @@ void deepcopy_VkBindBufferMemoryInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2266,7 +2266,7 @@ void deepcopy_VkBindImageMemoryInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2288,7 +2288,7 @@ void deepcopy_VkPhysicalDevice16BitStorageFeatures(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2310,7 +2310,7 @@ void deepcopy_VkMemoryDedicatedRequirements(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2332,7 +2332,7 @@ void deepcopy_VkMemoryDedicatedAllocateInfo(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2354,7 +2354,7 @@ void deepcopy_VkMemoryAllocateFlagsInfo(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2376,7 +2376,7 @@ void deepcopy_VkDeviceGroupRenderPassBeginInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2410,7 +2410,7 @@ void deepcopy_VkDeviceGroupCommandBufferBeginInfo(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2432,7 +2432,7 @@ void deepcopy_VkDeviceGroupSubmitInfo(Allocator* alloc, VkStructureType rootType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2470,7 +2470,7 @@ void deepcopy_VkDeviceGroupBindSparseInfo(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2492,7 +2492,7 @@ void deepcopy_VkBindBufferMemoryDeviceGroupInfo(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2519,7 +2519,7 @@ void deepcopy_VkBindImageMemoryDeviceGroupInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2558,7 +2558,7 @@ void deepcopy_VkPhysicalDeviceGroupProperties(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2582,7 +2582,7 @@ void deepcopy_VkDeviceGroupDeviceCreateInfo(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2609,7 +2609,7 @@ void deepcopy_VkBufferMemoryRequirementsInfo2(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2631,7 +2631,7 @@ void deepcopy_VkImageMemoryRequirementsInfo2(Allocator* alloc, VkStructureType r
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2653,7 +2653,7 @@ void deepcopy_VkImageSparseMemoryRequirementsInfo2(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2674,7 +2674,7 @@ void deepcopy_VkMemoryRequirements2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2698,7 +2698,7 @@ void deepcopy_VkSparseImageMemoryRequirements2(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2723,7 +2723,7 @@ void deepcopy_VkPhysicalDeviceFeatures2(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2747,7 +2747,7 @@ void deepcopy_VkPhysicalDeviceProperties2(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2770,7 +2770,7 @@ void deepcopy_VkFormatProperties2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2794,7 +2794,7 @@ void deepcopy_VkImageFormatProperties2(Allocator* alloc, VkStructureType rootTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2818,7 +2818,7 @@ void deepcopy_VkPhysicalDeviceImageFormatInfo2(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2840,7 +2840,7 @@ void deepcopy_VkQueueFamilyProperties2(Allocator* alloc, VkStructureType rootTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2864,7 +2864,7 @@ void deepcopy_VkPhysicalDeviceMemoryProperties2(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2889,7 +2889,7 @@ void deepcopy_VkSparseImageFormatProperties2(Allocator* alloc, VkStructureType r
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2913,7 +2913,7 @@ void deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2935,7 +2935,7 @@ void deepcopy_VkPhysicalDevicePointClippingProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -2966,7 +2966,7 @@ void deepcopy_VkRenderPassInputAttachmentAspectCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3001,7 +3001,7 @@ void deepcopy_VkImageViewUsageCreateInfo(Allocator* alloc, VkStructureType rootT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3024,7 +3024,7 @@ void deepcopy_VkPipelineTessellationDomainOriginStateCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3046,7 +3046,7 @@ void deepcopy_VkRenderPassMultiviewCreateInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3083,7 +3083,7 @@ void deepcopy_VkPhysicalDeviceMultiviewFeatures(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3105,7 +3105,7 @@ void deepcopy_VkPhysicalDeviceMultiviewProperties(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3128,7 +3128,7 @@ void deepcopy_VkPhysicalDeviceVariablePointersFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3150,7 +3150,7 @@ void deepcopy_VkPhysicalDeviceProtectedMemoryFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3173,7 +3173,7 @@ void deepcopy_VkPhysicalDeviceProtectedMemoryProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3194,7 +3194,7 @@ void deepcopy_VkDeviceQueueInfo2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3215,7 +3215,7 @@ void deepcopy_VkProtectedSubmitInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3237,7 +3237,7 @@ void deepcopy_VkSamplerYcbcrConversionCreateInfo(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3261,7 +3261,7 @@ void deepcopy_VkSamplerYcbcrConversionInfo(Allocator* alloc, VkStructureType roo
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3283,7 +3283,7 @@ void deepcopy_VkBindImagePlaneMemoryInfo(Allocator* alloc, VkStructureType rootT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3305,7 +3305,7 @@ void deepcopy_VkImagePlaneMemoryRequirementsInfo(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3328,7 +3328,7 @@ void deepcopy_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3351,7 +3351,7 @@ void deepcopy_VkSamplerYcbcrConversionImageFormatProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3381,7 +3381,7 @@ void deepcopy_VkDescriptorUpdateTemplateCreateInfo(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3424,7 +3424,7 @@ void deepcopy_VkPhysicalDeviceExternalImageFormatInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3446,7 +3446,7 @@ void deepcopy_VkExternalImageFormatProperties(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3471,7 +3471,7 @@ void deepcopy_VkPhysicalDeviceExternalBufferInfo(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3493,7 +3493,7 @@ void deepcopy_VkExternalBufferProperties(Allocator* alloc, VkStructureType rootT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3518,7 +3518,7 @@ void deepcopy_VkPhysicalDeviceIDProperties(Allocator* alloc, VkStructureType roo
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3543,7 +3543,7 @@ void deepcopy_VkExternalMemoryImageCreateInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3565,7 +3565,7 @@ void deepcopy_VkExternalMemoryBufferCreateInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3587,7 +3587,7 @@ void deepcopy_VkExportMemoryAllocateInfo(Allocator* alloc, VkStructureType rootT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3609,7 +3609,7 @@ void deepcopy_VkPhysicalDeviceExternalFenceInfo(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3631,7 +3631,7 @@ void deepcopy_VkExternalFenceProperties(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3653,7 +3653,7 @@ void deepcopy_VkExportFenceCreateInfo(Allocator* alloc, VkStructureType rootType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3675,7 +3675,7 @@ void deepcopy_VkExportSemaphoreCreateInfo(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3697,7 +3697,7 @@ void deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3719,7 +3719,7 @@ void deepcopy_VkExternalSemaphoreProperties(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3741,7 +3741,7 @@ void deepcopy_VkPhysicalDeviceMaintenance3Properties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3763,7 +3763,7 @@ void deepcopy_VkDescriptorSetLayoutSupport(Allocator* alloc, VkStructureType roo
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3786,7 +3786,7 @@ void deepcopy_VkPhysicalDeviceShaderDrawParametersFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3810,7 +3810,7 @@ void deepcopy_VkPhysicalDeviceVulkan11Features(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3832,7 +3832,7 @@ void deepcopy_VkPhysicalDeviceVulkan11Properties(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3857,7 +3857,7 @@ void deepcopy_VkPhysicalDeviceVulkan12Features(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3886,7 +3886,7 @@ void deepcopy_VkPhysicalDeviceVulkan12Properties(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3912,7 +3912,7 @@ void deepcopy_VkImageFormatListCreateInfo(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3939,7 +3939,7 @@ void deepcopy_VkAttachmentDescription2(Allocator* alloc, VkStructureType rootTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3961,7 +3961,7 @@ void deepcopy_VkAttachmentReference2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -3982,7 +3982,7 @@ void deepcopy_VkSubpassDescription2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4054,7 +4054,7 @@ void deepcopy_VkSubpassDependency2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4076,7 +4076,7 @@ void deepcopy_VkRenderPassCreateInfo2(Allocator* alloc, VkStructureType rootType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4139,7 +4139,7 @@ void deepcopy_VkSubpassBeginInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4160,7 +4160,7 @@ void deepcopy_VkSubpassEndInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4182,7 +4182,7 @@ void deepcopy_VkPhysicalDevice8BitStorageFeatures(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4204,7 +4204,7 @@ void deepcopy_VkPhysicalDeviceDriverProperties(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4231,7 +4231,7 @@ void deepcopy_VkPhysicalDeviceShaderAtomicInt64Features(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4254,7 +4254,7 @@ void deepcopy_VkPhysicalDeviceShaderFloat16Int8Features(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4276,7 +4276,7 @@ void deepcopy_VkPhysicalDeviceFloatControlsProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4299,7 +4299,7 @@ void deepcopy_VkDescriptorSetLayoutBindingFlagsCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4327,7 +4327,7 @@ void deepcopy_VkPhysicalDeviceDescriptorIndexingFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4350,7 +4350,7 @@ void deepcopy_VkPhysicalDeviceDescriptorIndexingProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4373,7 +4373,7 @@ void deepcopy_VkDescriptorSetVariableDescriptorCountAllocateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4401,7 +4401,7 @@ void deepcopy_VkDescriptorSetVariableDescriptorCountLayoutSupport(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4423,7 +4423,7 @@ void deepcopy_VkSubpassDescriptionDepthStencilResolve(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4454,7 +4454,7 @@ void deepcopy_VkPhysicalDeviceDepthStencilResolveProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4477,7 +4477,7 @@ void deepcopy_VkPhysicalDeviceScalarBlockLayoutFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4499,7 +4499,7 @@ void deepcopy_VkImageStencilUsageCreateInfo(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4521,7 +4521,7 @@ void deepcopy_VkSamplerReductionModeCreateInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4544,7 +4544,7 @@ void deepcopy_VkPhysicalDeviceSamplerFilterMinmaxProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4567,7 +4567,7 @@ void deepcopy_VkPhysicalDeviceVulkanMemoryModelFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4590,7 +4590,7 @@ void deepcopy_VkPhysicalDeviceImagelessFramebufferFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4612,7 +4612,7 @@ void deepcopy_VkFramebufferAttachmentImageInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4639,7 +4639,7 @@ void deepcopy_VkFramebufferAttachmentsCreateInfo(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4674,7 +4674,7 @@ void deepcopy_VkRenderPassAttachmentBeginInfo(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4702,7 +4702,7 @@ void deepcopy_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4725,7 +4725,7 @@ void deepcopy_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4748,7 +4748,7 @@ void deepcopy_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4770,7 +4770,7 @@ void deepcopy_VkAttachmentReferenceStencilLayout(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4792,7 +4792,7 @@ void deepcopy_VkAttachmentDescriptionStencilLayout(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4814,7 +4814,7 @@ void deepcopy_VkPhysicalDeviceHostQueryResetFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4837,7 +4837,7 @@ void deepcopy_VkPhysicalDeviceTimelineSemaphoreFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4860,7 +4860,7 @@ void deepcopy_VkPhysicalDeviceTimelineSemaphoreProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4882,7 +4882,7 @@ void deepcopy_VkSemaphoreTypeCreateInfo(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4904,7 +4904,7 @@ void deepcopy_VkTimelineSemaphoreSubmitInfo(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4935,7 +4935,7 @@ void deepcopy_VkSemaphoreWaitInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4966,7 +4966,7 @@ void deepcopy_VkSemaphoreSignalInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -4989,7 +4989,7 @@ void deepcopy_VkPhysicalDeviceBufferDeviceAddressFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5011,7 +5011,7 @@ void deepcopy_VkBufferDeviceAddressInfo(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5033,7 +5033,7 @@ void deepcopy_VkBufferOpaqueCaptureAddressCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5056,7 +5056,7 @@ void deepcopy_VkMemoryOpaqueCaptureAddressAllocateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5078,7 +5078,7 @@ void deepcopy_VkDeviceMemoryOpaqueCaptureAddressInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5102,7 +5102,7 @@ void deepcopy_VkPhysicalDeviceVulkan13Features(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5124,7 +5124,7 @@ void deepcopy_VkPhysicalDeviceVulkan13Properties(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5154,7 +5154,7 @@ void deepcopy_VkPipelineCreationFeedbackCreateInfo(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5198,7 +5198,7 @@ void deepcopy_VkPhysicalDeviceShaderTerminateInvocationFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5220,7 +5220,7 @@ void deepcopy_VkPhysicalDeviceToolProperties(Allocator* alloc, VkStructureType r
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5247,7 +5247,7 @@ void deepcopy_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5269,7 +5269,7 @@ void deepcopy_VkPhysicalDevicePrivateDataFeatures(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5291,7 +5291,7 @@ void deepcopy_VkDevicePrivateDataCreateInfo(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5313,7 +5313,7 @@ void deepcopy_VkPrivateDataSlotCreateInfo(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5336,7 +5336,7 @@ void deepcopy_VkPhysicalDevicePipelineCreationCacheControlFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5357,7 +5357,7 @@ void deepcopy_VkMemoryBarrier2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5379,7 +5379,7 @@ void deepcopy_VkBufferMemoryBarrier2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5400,7 +5400,7 @@ void deepcopy_VkImageMemoryBarrier2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5423,7 +5423,7 @@ void deepcopy_VkDependencyInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5482,7 +5482,7 @@ void deepcopy_VkSemaphoreSubmitInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5504,7 +5504,7 @@ void deepcopy_VkCommandBufferSubmitInfo(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5525,7 +5525,7 @@ void deepcopy_VkSubmitInfo2(Allocator* alloc, VkStructureType rootType, const Vk
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5587,7 +5587,7 @@ void deepcopy_VkPhysicalDeviceSynchronization2Features(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5610,7 +5610,7 @@ void deepcopy_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5632,7 +5632,7 @@ void deepcopy_VkPhysicalDeviceImageRobustnessFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5653,7 +5653,7 @@ void deepcopy_VkBufferCopy2(Allocator* alloc, VkStructureType rootType, const Vk
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5674,7 +5674,7 @@ void deepcopy_VkCopyBufferInfo2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5707,7 +5707,7 @@ void deepcopy_VkImageCopy2(Allocator* alloc, VkStructureType rootType, const VkI
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5735,7 +5735,7 @@ void deepcopy_VkCopyImageInfo2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5768,7 +5768,7 @@ void deepcopy_VkBufferImageCopy2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5794,7 +5794,7 @@ void deepcopy_VkCopyBufferToImageInfo2(Allocator* alloc, VkStructureType rootTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5828,7 +5828,7 @@ void deepcopy_VkCopyImageToBufferInfo2(Allocator* alloc, VkStructureType rootTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5861,7 +5861,7 @@ void deepcopy_VkImageBlit2(Allocator* alloc, VkStructureType rootType, const VkI
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5894,7 +5894,7 @@ void deepcopy_VkBlitImageInfo2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5927,7 +5927,7 @@ void deepcopy_VkImageResolve2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5955,7 +5955,7 @@ void deepcopy_VkResolveImageInfo2(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -5990,7 +5990,7 @@ void deepcopy_VkPhysicalDeviceSubgroupSizeControlFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6013,7 +6013,7 @@ void deepcopy_VkPhysicalDeviceSubgroupSizeControlProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6036,7 +6036,7 @@ void deepcopy_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6059,7 +6059,7 @@ void deepcopy_VkPhysicalDeviceInlineUniformBlockFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6082,7 +6082,7 @@ void deepcopy_VkPhysicalDeviceInlineUniformBlockProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6104,7 +6104,7 @@ void deepcopy_VkWriteDescriptorSetInlineUniformBlock(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6131,7 +6131,7 @@ void deepcopy_VkDescriptorPoolInlineUniformBlockCreateInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6154,7 +6154,7 @@ void deepcopy_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6176,7 +6176,7 @@ void deepcopy_VkRenderingAttachmentInfo(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6198,7 +6198,7 @@ void deepcopy_VkRenderingInfo(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6248,7 +6248,7 @@ void deepcopy_VkPipelineRenderingCreateInfo(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6276,7 +6276,7 @@ void deepcopy_VkPhysicalDeviceDynamicRenderingFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6298,7 +6298,7 @@ void deepcopy_VkCommandBufferInheritanceRenderingInfo(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6326,7 +6326,7 @@ void deepcopy_VkPhysicalDeviceShaderIntegerDotProductFeatures(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6349,7 +6349,7 @@ void deepcopy_VkPhysicalDeviceShaderIntegerDotProductProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6372,7 +6372,7 @@ void deepcopy_VkPhysicalDeviceTexelBufferAlignmentProperties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6393,7 +6393,7 @@ void deepcopy_VkFormatProperties3(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6415,7 +6415,7 @@ void deepcopy_VkPhysicalDeviceMaintenance4Features(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6437,7 +6437,7 @@ void deepcopy_VkPhysicalDeviceMaintenance4Properties(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6459,7 +6459,7 @@ void deepcopy_VkDeviceBufferMemoryRequirements(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6487,7 +6487,7 @@ void deepcopy_VkDeviceImageMemoryRequirements(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6517,7 +6517,7 @@ void deepcopy_VkSwapchainCreateInfoKHR(Allocator* alloc, VkStructureType rootTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6544,7 +6544,7 @@ void deepcopy_VkPresentInfoKHR(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6586,7 +6586,7 @@ void deepcopy_VkImageSwapchainCreateInfoKHR(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6608,7 +6608,7 @@ void deepcopy_VkBindImageMemorySwapchainInfoKHR(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6630,7 +6630,7 @@ void deepcopy_VkAcquireNextImageInfoKHR(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6652,7 +6652,7 @@ void deepcopy_VkDeviceGroupPresentCapabilitiesKHR(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6675,7 +6675,7 @@ void deepcopy_VkDeviceGroupPresentInfoKHR(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6702,7 +6702,7 @@ void deepcopy_VkDeviceGroupSwapchainCreateInfoKHR(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6727,7 +6727,7 @@ void deepcopy_VkRenderingFragmentShadingRateAttachmentInfoKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6752,7 +6752,7 @@ void deepcopy_VkRenderingFragmentDensityMapAttachmentInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6774,7 +6774,7 @@ void deepcopy_VkAttachmentSampleCountInfoAMD(Allocator* alloc, VkStructureType r
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6802,7 +6802,7 @@ void deepcopy_VkMultiviewPerViewAttributesInfoNVX(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6826,7 +6826,7 @@ void deepcopy_VkImportSemaphoreFdInfoKHR(Allocator* alloc, VkStructureType rootT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6848,7 +6848,7 @@ void deepcopy_VkSemaphoreGetFdInfoKHR(Allocator* alloc, VkStructureType rootType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6899,7 +6899,7 @@ void deepcopy_VkPresentRegionsKHR(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6935,7 +6935,7 @@ void deepcopy_VkImportFenceFdInfoKHR(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6956,7 +6956,7 @@ void deepcopy_VkFenceGetFdInfoKHR(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -6966,6 +6966,79 @@ void deepcopy_VkFenceGetFdInfoKHR(Allocator* alloc, VkStructureType rootType,
     }
 }
 
+#endif
+#ifdef VK_KHR_global_priority
+void deepcopy_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkDeviceQueueGlobalPriorityCreateInfoKHR* from,
+    VkDeviceQueueGlobalPriorityCreateInfoKHR* to) {
+    (void)alloc;
+    (void)rootType;
+    *to = *from;
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = from->sType;
+    }
+    const void* from_pNext = from;
+    size_t pNext_size = 0u;
+    while (!pNext_size && from_pNext) {
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
+        pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
+    }
+    to->pNext = nullptr;
+    if (pNext_size) {
+        to->pNext = (void*)alloc->alloc(pNext_size);
+        deepcopy_extension_struct(alloc, rootType, from_pNext, (void*)(to->pNext));
+    }
+}
+
+void deepcopy_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* from,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* to) {
+    (void)alloc;
+    (void)rootType;
+    *to = *from;
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = from->sType;
+    }
+    const void* from_pNext = from;
+    size_t pNext_size = 0u;
+    while (!pNext_size && from_pNext) {
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
+        pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
+    }
+    to->pNext = nullptr;
+    if (pNext_size) {
+        to->pNext = (void*)alloc->alloc(pNext_size);
+        deepcopy_extension_struct(alloc, rootType, from_pNext, (void*)(to->pNext));
+    }
+}
+
+void deepcopy_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkQueueFamilyGlobalPriorityPropertiesKHR* from,
+    VkQueueFamilyGlobalPriorityPropertiesKHR* to) {
+    (void)alloc;
+    (void)rootType;
+    *to = *from;
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = from->sType;
+    }
+    const void* from_pNext = from;
+    size_t pNext_size = 0u;
+    while (!pNext_size && from_pNext) {
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
+        pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
+    }
+    to->pNext = nullptr;
+    if (pNext_size) {
+        to->pNext = (void*)alloc->alloc(pNext_size);
+        deepcopy_extension_struct(alloc, rootType, from_pNext, (void*)(to->pNext));
+    }
+    memcpy(to->priorities, from->priorities,
+           VK_MAX_GLOBAL_PRIORITY_SIZE_KHR * sizeof(VkQueueGlobalPriorityKHR));
+}
+
 #endif
 #ifdef VK_KHR_pipeline_executable_properties
 void deepcopy_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
@@ -6981,7 +7054,7 @@ void deepcopy_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7002,7 +7075,7 @@ void deepcopy_VkPipelineInfoKHR(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7024,7 +7097,7 @@ void deepcopy_VkPipelineExecutablePropertiesKHR(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7048,7 +7121,7 @@ void deepcopy_VkPipelineExecutableInfoKHR(Allocator* alloc, VkStructureType root
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7078,7 +7151,7 @@ void deepcopy_VkPipelineExecutableStatisticKHR(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7105,7 +7178,7 @@ void deepcopy_VkPipelineExecutableInternalRepresentationKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7135,7 +7208,7 @@ void deepcopy_VkPipelineLibraryCreateInfoKHR(Allocator* alloc, VkStructureType r
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7164,7 +7237,7 @@ void deepcopy_VkQueueFamilyCheckpointProperties2NV(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7185,7 +7258,7 @@ void deepcopy_VkCheckpointData2NV(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7213,7 +7286,7 @@ void deepcopy_VkPhysicalDeviceMaintenance5FeaturesKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7236,7 +7309,7 @@ void deepcopy_VkPhysicalDeviceMaintenance5PropertiesKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7258,7 +7331,7 @@ void deepcopy_VkRenderingAreaInfoKHR(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7285,7 +7358,7 @@ void deepcopy_VkImageSubresource2KHR(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7309,7 +7382,7 @@ void deepcopy_VkDeviceImageSubresourceInfoKHR(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7344,7 +7417,7 @@ void deepcopy_VkSubresourceLayout2KHR(Allocator* alloc, VkStructureType rootType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7368,7 +7441,7 @@ void deepcopy_VkPipelineCreateFlags2CreateInfoKHR(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7390,7 +7463,7 @@ void deepcopy_VkBufferUsageFlags2CreateInfoKHR(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7415,7 +7488,7 @@ void deepcopy_VkPhysicalDeviceLineRasterizationFeaturesKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7438,7 +7511,7 @@ void deepcopy_VkPhysicalDeviceLineRasterizationPropertiesKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7461,7 +7534,7 @@ void deepcopy_VkPipelineRasterizationLineStateCreateInfoKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7492,7 +7565,7 @@ void deepcopy_VkNativeBufferANDROID(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7520,7 +7593,7 @@ void deepcopy_VkSwapchainImageCreateInfoANDROID(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7543,7 +7616,7 @@ void deepcopy_VkPhysicalDevicePresentationPropertiesANDROID(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7567,7 +7640,7 @@ void deepcopy_VkDebugReportCallbackCreateInfoEXT(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7596,7 +7669,7 @@ void deepcopy_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7619,7 +7692,7 @@ void deepcopy_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7642,7 +7715,7 @@ void deepcopy_VkPipelineRasterizationStateStreamCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7667,7 +7740,7 @@ void deepcopy_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7690,7 +7763,7 @@ void deepcopy_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7713,7 +7786,7 @@ void deepcopy_VkDebugUtilsLabelEXT(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7740,7 +7813,7 @@ void deepcopy_VkDebugUtilsObjectNameInfoEXT(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7766,7 +7839,7 @@ void deepcopy_VkDebugUtilsMessengerCallbackDataEXT(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7833,7 +7906,7 @@ void deepcopy_VkDebugUtilsMessengerCreateInfoEXT(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7859,7 +7932,7 @@ void deepcopy_VkDebugUtilsObjectTagInfoEXT(Allocator* alloc, VkStructureType roo
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7895,7 +7968,7 @@ void deepcopy_VkDrmFormatModifierPropertiesListEXT(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7931,7 +8004,7 @@ void deepcopy_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7959,7 +8032,7 @@ void deepcopy_VkImageDrmFormatModifierListCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -7987,7 +8060,7 @@ void deepcopy_VkImageDrmFormatModifierExplicitCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8021,7 +8094,7 @@ void deepcopy_VkImageDrmFormatModifierPropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8051,7 +8124,7 @@ void deepcopy_VkDrmFormatModifierPropertiesList2EXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8088,7 +8161,7 @@ void deepcopy_VkImportMemoryHostPointerInfoEXT(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8114,7 +8187,7 @@ void deepcopy_VkMemoryHostPointerPropertiesEXT(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8137,7 +8210,7 @@ void deepcopy_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8162,7 +8235,7 @@ void deepcopy_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8194,7 +8267,7 @@ void deepcopy_VkPipelineVertexInputDivisorStateCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8231,7 +8304,7 @@ void deepcopy_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8256,7 +8329,7 @@ void deepcopy_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8279,7 +8352,7 @@ void deepcopy_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8306,7 +8379,7 @@ void deepcopy_VkRenderPassFragmentDensityMapCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8332,7 +8405,7 @@ void deepcopy_VkValidationFeaturesEXT(Allocator* alloc, VkStructureType rootType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8369,7 +8442,7 @@ void deepcopy_VkPhysicalDeviceProvokingVertexFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8392,7 +8465,7 @@ void deepcopy_VkPhysicalDeviceProvokingVertexPropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8415,7 +8488,7 @@ void deepcopy_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8440,7 +8513,7 @@ void deepcopy_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8465,7 +8538,7 @@ void deepcopy_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8490,7 +8563,7 @@ void deepcopy_VkPhysicalDeviceHostImageCopyFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8513,7 +8586,7 @@ void deepcopy_VkPhysicalDeviceHostImageCopyPropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8547,7 +8620,7 @@ void deepcopy_VkMemoryToImageCopyEXT(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8577,7 +8650,7 @@ void deepcopy_VkImageToMemoryCopyEXT(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8607,7 +8680,7 @@ void deepcopy_VkCopyMemoryToImageInfoEXT(Allocator* alloc, VkStructureType rootT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8641,7 +8714,7 @@ void deepcopy_VkCopyImageToMemoryInfoEXT(Allocator* alloc, VkStructureType rootT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8675,7 +8748,7 @@ void deepcopy_VkCopyImageToImageInfoEXT(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8709,7 +8782,7 @@ void deepcopy_VkHostImageLayoutTransitionInfoEXT(Allocator* alloc, VkStructureTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8733,7 +8806,7 @@ void deepcopy_VkSubresourceHostMemcpySizeEXT(Allocator* alloc, VkStructureType r
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8756,7 +8829,7 @@ void deepcopy_VkHostImageCopyDevicePerformanceQueryEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8781,7 +8854,7 @@ void deepcopy_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8803,7 +8876,7 @@ void deepcopy_VkSwapchainPresentFenceInfoEXT(Allocator* alloc, VkStructureType r
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8830,7 +8903,7 @@ void deepcopy_VkSwapchainPresentModesCreateInfoEXT(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8857,7 +8930,7 @@ void deepcopy_VkSwapchainPresentModeInfoEXT(Allocator* alloc, VkStructureType ro
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8884,7 +8957,7 @@ void deepcopy_VkSwapchainPresentScalingCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8906,7 +8979,7 @@ void deepcopy_VkReleaseSwapchainImagesInfoEXT(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8936,7 +9009,7 @@ void deepcopy_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8961,7 +9034,7 @@ void deepcopy_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -8983,7 +9056,7 @@ void deepcopy_VkDeviceMemoryReportCallbackDataEXT(Allocator* alloc, VkStructureT
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9005,7 +9078,7 @@ void deepcopy_VkDeviceDeviceMemoryReportCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9033,7 +9106,7 @@ void deepcopy_VkPhysicalDeviceRobustness2FeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9056,7 +9129,7 @@ void deepcopy_VkPhysicalDeviceRobustness2PropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9080,7 +9153,7 @@ void deepcopy_VkSamplerCustomBorderColorCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9105,7 +9178,7 @@ void deepcopy_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9128,7 +9201,7 @@ void deepcopy_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9153,7 +9226,7 @@ void deepcopy_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9176,7 +9249,7 @@ void deepcopy_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9198,7 +9271,7 @@ void deepcopy_VkGraphicsPipelineLibraryCreateInfoEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9223,7 +9296,7 @@ void deepcopy_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9248,7 +9321,7 @@ void deepcopy_VkPhysicalDeviceImageCompressionControlFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9270,7 +9343,7 @@ void deepcopy_VkImageCompressionControlEXT(Allocator* alloc, VkStructureType roo
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9298,7 +9371,7 @@ void deepcopy_VkImageCompressionPropertiesEXT(Allocator* alloc, VkStructureType
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9322,7 +9395,7 @@ void deepcopy_VkPhysicalDevice4444FormatsFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9347,7 +9420,7 @@ void deepcopy_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9372,7 +9445,7 @@ void deepcopy_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9397,7 +9470,7 @@ void deepcopy_VkPhysicalDeviceColorWriteEnableFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9419,7 +9492,7 @@ void deepcopy_VkPipelineColorWriteCreateInfoEXT(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9448,7 +9521,7 @@ void deepcopy_VkImportColorBufferGOOGLE(Allocator* alloc, VkStructureType rootTy
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9469,7 +9542,7 @@ void deepcopy_VkImportBufferGOOGLE(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9490,7 +9563,7 @@ void deepcopy_VkCreateBlobGOOGLE(Allocator* alloc, VkStructureType rootType,
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9515,7 +9588,7 @@ void deepcopy_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9539,7 +9612,7 @@ void deepcopy_VkRayTracingShaderGroupCreateInfoKHR(Allocator* alloc, VkStructure
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9567,7 +9640,7 @@ void deepcopy_VkRayTracingPipelineInterfaceCreateInfoKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9589,7 +9662,7 @@ void deepcopy_VkRayTracingPipelineCreateInfoKHR(Allocator* alloc, VkStructureTyp
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9662,7 +9735,7 @@ void deepcopy_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -9685,7 +9758,7 @@ void deepcopy_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
     const void* from_pNext = from;
     size_t pNext_size = 0u;
     while (!pNext_size && from_pNext) {
-        from_pNext = static_cast<const vk_struct_common*>(from_pNext)->pNext;
+        from_pNext = static_cast<const VkBaseOutStructure*>(from_pNext)->pNext;
         pNext_size = goldfish_vk_extension_struct_size(rootType, from_pNext);
     }
     to->pNext = nullptr;
@@ -10604,6 +10677,31 @@ void deepcopy_extension_struct(Allocator* alloc, VkStructureType rootType,
             break;
         }
 #endif
+#ifdef VK_KHR_global_priority
+        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: {
+            deepcopy_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+                alloc, rootType,
+                reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoKHR*>(structExtension),
+                reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoKHR*>(structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: {
+            deepcopy_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+                alloc, rootType,
+                reinterpret_cast<const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(
+                    structExtension),
+                reinterpret_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(
+                    structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: {
+            deepcopy_VkQueueFamilyGlobalPriorityPropertiesKHR(
+                alloc, rootType,
+                reinterpret_cast<const VkQueueFamilyGlobalPriorityPropertiesKHR*>(structExtension),
+                reinterpret_cast<VkQueueFamilyGlobalPriorityPropertiesKHR*>(structExtension_out));
+            break;
+        }
+#endif
 #ifdef VK_KHR_pipeline_executable_properties
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
             deepcopy_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
diff --git a/host/vulkan/cereal/common/goldfish_vk_deepcopy.h b/host/vulkan/cereal/common/goldfish_vk_deepcopy.h
index 26f32e0a2..e18b7aa4d 100644
--- a/host/vulkan/cereal/common/goldfish_vk_deepcopy.h
+++ b/host/vulkan/cereal/common/goldfish_vk_deepcopy.h
@@ -1209,6 +1209,17 @@ void deepcopy_VkMultiviewPerViewAttributesInfoNVX(Allocator* alloc, VkStructureT
                                                   const VkMultiviewPerViewAttributesInfoNVX* from,
                                                   VkMultiviewPerViewAttributesInfoNVX* to);
 
+#endif
+#ifdef VK_KHR_multiview
+DEFINE_ALIAS_FUNCTION(deepcopy_VkRenderPassMultiviewCreateInfo,
+                      deepcopy_VkRenderPassMultiviewCreateInfoKHR)
+
+DEFINE_ALIAS_FUNCTION(deepcopy_VkPhysicalDeviceMultiviewFeatures,
+                      deepcopy_VkPhysicalDeviceMultiviewFeaturesKHR)
+
+DEFINE_ALIAS_FUNCTION(deepcopy_VkPhysicalDeviceMultiviewProperties,
+                      deepcopy_VkPhysicalDeviceMultiviewPropertiesKHR)
+
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 DEFINE_ALIAS_FUNCTION(deepcopy_VkPhysicalDeviceFeatures2, deepcopy_VkPhysicalDeviceFeatures2KHR)
@@ -1442,6 +1453,23 @@ DEFINE_ALIAS_FUNCTION(deepcopy_VkDescriptorSetLayoutSupport,
 DEFINE_ALIAS_FUNCTION(deepcopy_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
                       deepcopy_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR)
 
+#endif
+#ifdef VK_KHR_global_priority
+void deepcopy_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkDeviceQueueGlobalPriorityCreateInfoKHR* from,
+    VkDeviceQueueGlobalPriorityCreateInfoKHR* to);
+
+void deepcopy_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* from,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* to);
+
+void deepcopy_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    Allocator* alloc, VkStructureType rootType,
+    const VkQueueFamilyGlobalPriorityPropertiesKHR* from,
+    VkQueueFamilyGlobalPriorityPropertiesKHR* to);
+
 #endif
 #ifdef VK_KHR_vulkan_memory_model
 DEFINE_ALIAS_FUNCTION(deepcopy_VkPhysicalDeviceVulkanMemoryModelFeatures,
diff --git a/host/vulkan/cereal/common/goldfish_vk_marshaling.cpp b/host/vulkan/cereal/common/goldfish_vk_marshaling.cpp
index 7e8873b17..ae05332b4 100644
--- a/host/vulkan/cereal/common/goldfish_vk_marshaling.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_marshaling.cpp
@@ -14368,6 +14368,122 @@ void unmarshal_VkFenceGetFdInfoKHR(VulkanStream* vkStream, VkStructureType rootT
                    sizeof(VkExternalFenceHandleTypeFlagBits));
 }
 
+#endif
+#ifdef VK_KHR_global_priority
+void marshal_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkDeviceQueueGlobalPriorityCreateInfoKHR* forMarshaling) {
+    (void)rootType;
+    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forMarshaling->sType;
+    }
+    marshal_extension_struct(vkStream, rootType, forMarshaling->pNext);
+    vkStream->write((VkQueueGlobalPriorityKHR*)&forMarshaling->globalPriority,
+                    sizeof(VkQueueGlobalPriorityKHR));
+}
+
+void unmarshal_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkDeviceQueueGlobalPriorityCreateInfoKHR* forUnmarshaling) {
+    (void)rootType;
+    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    size_t pNext_size;
+    pNext_size = vkStream->getBe32();
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        unmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext));
+    }
+    vkStream->read((VkQueueGlobalPriorityKHR*)&forUnmarshaling->globalPriority,
+                   sizeof(VkQueueGlobalPriorityKHR));
+}
+
+void marshal_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* forMarshaling) {
+    (void)rootType;
+    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forMarshaling->sType;
+    }
+    marshal_extension_struct(vkStream, rootType, forMarshaling->pNext);
+    vkStream->write((VkBool32*)&forMarshaling->globalPriorityQuery, sizeof(VkBool32));
+}
+
+void unmarshal_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* forUnmarshaling) {
+    (void)rootType;
+    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    size_t pNext_size;
+    pNext_size = vkStream->getBe32();
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        unmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext));
+    }
+    vkStream->read((VkBool32*)&forUnmarshaling->globalPriorityQuery, sizeof(VkBool32));
+}
+
+void marshal_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkQueueFamilyGlobalPriorityPropertiesKHR* forMarshaling) {
+    (void)rootType;
+    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forMarshaling->sType;
+    }
+    marshal_extension_struct(vkStream, rootType, forMarshaling->pNext);
+    vkStream->write((uint32_t*)&forMarshaling->priorityCount, sizeof(uint32_t));
+    vkStream->write((VkQueueGlobalPriorityKHR*)forMarshaling->priorities,
+                    VK_MAX_GLOBAL_PRIORITY_SIZE_KHR * sizeof(VkQueueGlobalPriorityKHR));
+}
+
+void unmarshal_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkQueueFamilyGlobalPriorityPropertiesKHR* forUnmarshaling) {
+    (void)rootType;
+    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    size_t pNext_size;
+    pNext_size = vkStream->getBe32();
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        unmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext));
+    }
+    vkStream->read((uint32_t*)&forUnmarshaling->priorityCount, sizeof(uint32_t));
+    vkStream->read((VkQueueGlobalPriorityKHR*)forUnmarshaling->priorities,
+                   VK_MAX_GLOBAL_PRIORITY_SIZE_KHR * sizeof(VkQueueGlobalPriorityKHR));
+}
+
 #endif
 #ifdef VK_KHR_pipeline_executable_properties
 void marshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
@@ -19948,6 +20064,27 @@ void marshal_extension_struct(VulkanStream* vkStream, VkStructureType rootType,
             break;
         }
 #endif
+#ifdef VK_KHR_global_priority
+        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: {
+            marshal_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+                vkStream, rootType,
+                reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoKHR*>(structExtension));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: {
+            marshal_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+                vkStream, rootType,
+                reinterpret_cast<const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(
+                    structExtension));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: {
+            marshal_VkQueueFamilyGlobalPriorityPropertiesKHR(
+                vkStream, rootType,
+                reinterpret_cast<const VkQueueFamilyGlobalPriorityPropertiesKHR*>(structExtension));
+            break;
+        }
+#endif
 #ifdef VK_KHR_pipeline_executable_properties
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
             marshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
@@ -21330,6 +21467,27 @@ void unmarshal_extension_struct(VulkanStream* vkStream, VkStructureType rootType
             break;
         }
 #endif
+#ifdef VK_KHR_global_priority
+        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: {
+            unmarshal_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoKHR*>(structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: {
+            unmarshal_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(
+                    structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: {
+            unmarshal_VkQueueFamilyGlobalPriorityPropertiesKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkQueueFamilyGlobalPriorityPropertiesKHR*>(structExtension_out));
+            break;
+        }
+#endif
 #ifdef VK_KHR_pipeline_executable_properties
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
             unmarshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
diff --git a/host/vulkan/cereal/common/goldfish_vk_marshaling.h b/host/vulkan/cereal/common/goldfish_vk_marshaling.h
index 2b2453f3a..9ae15892c 100644
--- a/host/vulkan/cereal/common/goldfish_vk_marshaling.h
+++ b/host/vulkan/cereal/common/goldfish_vk_marshaling.h
@@ -2296,6 +2296,26 @@ void unmarshal_VkMultiviewPerViewAttributesInfoNVX(
     VulkanStream* vkStream, VkStructureType rootType,
     VkMultiviewPerViewAttributesInfoNVX* forUnmarshaling);
 
+#endif
+#ifdef VK_KHR_multiview
+DEFINE_ALIAS_FUNCTION(marshal_VkRenderPassMultiviewCreateInfo,
+                      marshal_VkRenderPassMultiviewCreateInfoKHR)
+
+DEFINE_ALIAS_FUNCTION(unmarshal_VkRenderPassMultiviewCreateInfo,
+                      unmarshal_VkRenderPassMultiviewCreateInfoKHR)
+
+DEFINE_ALIAS_FUNCTION(marshal_VkPhysicalDeviceMultiviewFeatures,
+                      marshal_VkPhysicalDeviceMultiviewFeaturesKHR)
+
+DEFINE_ALIAS_FUNCTION(unmarshal_VkPhysicalDeviceMultiviewFeatures,
+                      unmarshal_VkPhysicalDeviceMultiviewFeaturesKHR)
+
+DEFINE_ALIAS_FUNCTION(marshal_VkPhysicalDeviceMultiviewProperties,
+                      marshal_VkPhysicalDeviceMultiviewPropertiesKHR)
+
+DEFINE_ALIAS_FUNCTION(unmarshal_VkPhysicalDeviceMultiviewProperties,
+                      unmarshal_VkPhysicalDeviceMultiviewPropertiesKHR)
+
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 DEFINE_ALIAS_FUNCTION(marshal_VkPhysicalDeviceFeatures2, marshal_VkPhysicalDeviceFeatures2KHR)
@@ -2744,6 +2764,32 @@ DEFINE_ALIAS_FUNCTION(marshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeature
 DEFINE_ALIAS_FUNCTION(unmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
                       unmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR)
 
+#endif
+#ifdef VK_KHR_global_priority
+void marshal_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkDeviceQueueGlobalPriorityCreateInfoKHR* forMarshaling);
+
+void unmarshal_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkDeviceQueueGlobalPriorityCreateInfoKHR* forUnmarshaling);
+
+void marshal_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* forMarshaling);
+
+void unmarshal_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* forUnmarshaling);
+
+void marshal_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    const VkQueueFamilyGlobalPriorityPropertiesKHR* forMarshaling);
+
+void unmarshal_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkQueueFamilyGlobalPriorityPropertiesKHR* forUnmarshaling);
+
 #endif
 #ifdef VK_KHR_vulkan_memory_model
 DEFINE_ALIAS_FUNCTION(marshal_VkPhysicalDeviceVulkanMemoryModelFeatures,
diff --git a/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.cpp b/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.cpp
index bd76867c1..748857516 100644
--- a/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.cpp
@@ -35,6 +35,7 @@
 
 #include <string.h>
 
+#include "VulkanBoxedHandles.h"
 #include "goldfish_vk_extension_structs.h"
 #include "goldfish_vk_private_defs.h"
 
@@ -11046,6 +11047,99 @@ void reservedunmarshal_VkFenceGetFdInfoKHR(VulkanStream* vkStream, VkStructureTy
     *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
 }
 
+#endif
+#ifdef VK_KHR_global_priority
+void reservedunmarshal_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkDeviceQueueGlobalPriorityCreateInfoKHR* forUnmarshaling, uint8_t** ptr) {
+    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
+    *ptr += sizeof(VkStructureType);
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    uint32_t pNext_size;
+    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
+    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
+    *ptr += sizeof(uint32_t);
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
+        *ptr += sizeof(VkStructureType);
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext),
+                                           ptr);
+    }
+    memcpy((VkQueueGlobalPriorityKHR*)&forUnmarshaling->globalPriority, *ptr,
+           sizeof(VkQueueGlobalPriorityKHR));
+    *ptr += sizeof(VkQueueGlobalPriorityKHR);
+}
+
+void reservedunmarshal_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* forUnmarshaling, uint8_t** ptr) {
+    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
+    *ptr += sizeof(VkStructureType);
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    uint32_t pNext_size;
+    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
+    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
+    *ptr += sizeof(uint32_t);
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
+        *ptr += sizeof(VkStructureType);
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext),
+                                           ptr);
+    }
+    memcpy((VkBool32*)&forUnmarshaling->globalPriorityQuery, *ptr, sizeof(VkBool32));
+    *ptr += sizeof(VkBool32);
+}
+
+void reservedunmarshal_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkQueueFamilyGlobalPriorityPropertiesKHR* forUnmarshaling, uint8_t** ptr) {
+    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
+    *ptr += sizeof(VkStructureType);
+    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM) {
+        rootType = forUnmarshaling->sType;
+    }
+    uint32_t pNext_size;
+    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
+    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
+    *ptr += sizeof(uint32_t);
+    forUnmarshaling->pNext = nullptr;
+    if (pNext_size) {
+        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
+        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
+        *ptr += sizeof(VkStructureType);
+        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
+        vkStream->alloc((void**)&forUnmarshaling->pNext,
+                        goldfish_vk_extension_struct_size_with_stream_features(
+                            vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
+        *(VkStructureType*)forUnmarshaling->pNext = extType;
+        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext),
+                                           ptr);
+    }
+    memcpy((uint32_t*)&forUnmarshaling->priorityCount, *ptr, sizeof(uint32_t));
+    *ptr += sizeof(uint32_t);
+    memcpy((VkQueueGlobalPriorityKHR*)forUnmarshaling->priorities, *ptr,
+           VK_MAX_GLOBAL_PRIORITY_SIZE_KHR * sizeof(VkQueueGlobalPriorityKHR));
+    *ptr += VK_MAX_GLOBAL_PRIORITY_SIZE_KHR * sizeof(VkQueueGlobalPriorityKHR);
+}
+
 #endif
 #ifdef VK_KHR_pipeline_executable_properties
 void reservedunmarshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
@@ -15649,6 +15743,30 @@ void reservedunmarshal_extension_struct(VulkanStream* vkStream, VkStructureType
             break;
         }
 #endif
+#ifdef VK_KHR_global_priority
+        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: {
+            reservedunmarshal_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoKHR*>(structExtension_out),
+                ptr);
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: {
+            reservedunmarshal_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(
+                    structExtension_out),
+                ptr);
+            break;
+        }
+        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: {
+            reservedunmarshal_VkQueueFamilyGlobalPriorityPropertiesKHR(
+                vkStream, rootType,
+                reinterpret_cast<VkQueueFamilyGlobalPriorityPropertiesKHR*>(structExtension_out),
+                ptr);
+            break;
+        }
+#endif
 #ifdef VK_KHR_pipeline_executable_properties
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
             reservedunmarshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
diff --git a/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.h b/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.h
index 184670ec0..7eb328666 100644
--- a/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.h
+++ b/host/vulkan/cereal/common/goldfish_vk_reserved_marshaling.h
@@ -1182,6 +1182,17 @@ void reservedunmarshal_VkMultiviewPerViewAttributesInfoNVX(
     VulkanStream* vkStream, VkStructureType rootType,
     VkMultiviewPerViewAttributesInfoNVX* forUnmarshaling, uint8_t** ptr);
 
+#endif
+#ifdef VK_KHR_multiview
+DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkRenderPassMultiviewCreateInfo,
+                      reservedunmarshal_VkRenderPassMultiviewCreateInfoKHR)
+
+DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkPhysicalDeviceMultiviewFeatures,
+                      reservedunmarshal_VkPhysicalDeviceMultiviewFeaturesKHR)
+
+DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkPhysicalDeviceMultiviewProperties,
+                      reservedunmarshal_VkPhysicalDeviceMultiviewPropertiesKHR)
+
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkPhysicalDeviceFeatures2,
@@ -1437,6 +1448,20 @@ DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkDescriptorSetLayoutSupport,
 DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
                       reservedunmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR)
 
+#endif
+#ifdef VK_KHR_global_priority
+void reservedunmarshal_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkDeviceQueueGlobalPriorityCreateInfoKHR* forUnmarshaling, uint8_t** ptr);
+
+void reservedunmarshal_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* forUnmarshaling, uint8_t** ptr);
+
+void reservedunmarshal_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VulkanStream* vkStream, VkStructureType rootType,
+    VkQueueFamilyGlobalPriorityPropertiesKHR* forUnmarshaling, uint8_t** ptr);
+
 #endif
 #ifdef VK_KHR_vulkan_memory_model
 DEFINE_ALIAS_FUNCTION(reservedunmarshal_VkPhysicalDeviceVulkanMemoryModelFeatures,
diff --git a/host/vulkan/cereal/common/goldfish_vk_transform.cpp b/host/vulkan/cereal/common/goldfish_vk_transform.cpp
index 2648c5b67..7a8976a0c 100644
--- a/host/vulkan/cereal/common/goldfish_vk_transform.cpp
+++ b/host/vulkan/cereal/common/goldfish_vk_transform.cpp
@@ -6524,6 +6524,64 @@ void transform_fromhost_VkFenceGetFdInfoKHR(VkDecoderGlobalState* resourceTracke
     }
 }
 
+#endif
+#ifdef VK_KHR_global_priority
+void transform_tohost_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VkDecoderGlobalState* resourceTracker, VkDeviceQueueGlobalPriorityCreateInfoKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_tohost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_fromhost_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VkDecoderGlobalState* resourceTracker, VkDeviceQueueGlobalPriorityCreateInfoKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_fromhost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_tohost_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_tohost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_fromhost_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_fromhost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_tohost_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VkDecoderGlobalState* resourceTracker, VkQueueFamilyGlobalPriorityPropertiesKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_tohost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
+void transform_fromhost_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VkDecoderGlobalState* resourceTracker, VkQueueFamilyGlobalPriorityPropertiesKHR* toTransform) {
+    (void)resourceTracker;
+    (void)toTransform;
+    if (toTransform->pNext) {
+        transform_fromhost_extension_struct(resourceTracker, (void*)(toTransform->pNext));
+    }
+}
+
 #endif
 #ifdef VK_KHR_pipeline_executable_properties
 void transform_tohost_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
@@ -9617,6 +9675,26 @@ void transform_tohost_extension_struct(VkDecoderGlobalState* resourceTracker,
             break;
         }
 #endif
+#ifdef VK_KHR_global_priority
+        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: {
+            transform_tohost_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+                resourceTracker,
+                reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoKHR*>(structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: {
+            transform_tohost_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+                resourceTracker, reinterpret_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(
+                                     structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: {
+            transform_tohost_VkQueueFamilyGlobalPriorityPropertiesKHR(
+                resourceTracker,
+                reinterpret_cast<VkQueueFamilyGlobalPriorityPropertiesKHR*>(structExtension_out));
+            break;
+        }
+#endif
 #ifdef VK_KHR_pipeline_executable_properties
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
             transform_tohost_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
@@ -10867,6 +10945,26 @@ void transform_fromhost_extension_struct(VkDecoderGlobalState* resourceTracker,
             break;
         }
 #endif
+#ifdef VK_KHR_global_priority
+        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: {
+            transform_fromhost_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+                resourceTracker,
+                reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoKHR*>(structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: {
+            transform_fromhost_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+                resourceTracker, reinterpret_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(
+                                     structExtension_out));
+            break;
+        }
+        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: {
+            transform_fromhost_VkQueueFamilyGlobalPriorityPropertiesKHR(
+                resourceTracker,
+                reinterpret_cast<VkQueueFamilyGlobalPriorityPropertiesKHR*>(structExtension_out));
+            break;
+        }
+#endif
 #ifdef VK_KHR_pipeline_executable_properties
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
             transform_fromhost_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
diff --git a/host/vulkan/cereal/common/goldfish_vk_transform.h b/host/vulkan/cereal/common/goldfish_vk_transform.h
index 6b4f90f51..28f7fe782 100644
--- a/host/vulkan/cereal/common/goldfish_vk_transform.h
+++ b/host/vulkan/cereal/common/goldfish_vk_transform.h
@@ -1929,6 +1929,26 @@ void transform_tohost_VkMultiviewPerViewAttributesInfoNVX(
 void transform_fromhost_VkMultiviewPerViewAttributesInfoNVX(
     VkDecoderGlobalState* resourceTracker, VkMultiviewPerViewAttributesInfoNVX* toTransform);
 
+#endif
+#ifdef VK_KHR_multiview
+DEFINE_ALIAS_FUNCTION(transform_tohost_VkRenderPassMultiviewCreateInfo,
+                      transform_tohost_VkRenderPassMultiviewCreateInfoKHR)
+
+DEFINE_ALIAS_FUNCTION(transform_fromhost_VkRenderPassMultiviewCreateInfo,
+                      transform_fromhost_VkRenderPassMultiviewCreateInfoKHR)
+
+DEFINE_ALIAS_FUNCTION(transform_tohost_VkPhysicalDeviceMultiviewFeatures,
+                      transform_tohost_VkPhysicalDeviceMultiviewFeaturesKHR)
+
+DEFINE_ALIAS_FUNCTION(transform_fromhost_VkPhysicalDeviceMultiviewFeatures,
+                      transform_fromhost_VkPhysicalDeviceMultiviewFeaturesKHR)
+
+DEFINE_ALIAS_FUNCTION(transform_tohost_VkPhysicalDeviceMultiviewProperties,
+                      transform_tohost_VkPhysicalDeviceMultiviewPropertiesKHR)
+
+DEFINE_ALIAS_FUNCTION(transform_fromhost_VkPhysicalDeviceMultiviewProperties,
+                      transform_fromhost_VkPhysicalDeviceMultiviewPropertiesKHR)
+
 #endif
 #ifdef VK_KHR_get_physical_device_properties2
 DEFINE_ALIAS_FUNCTION(transform_tohost_VkPhysicalDeviceFeatures2,
@@ -2389,6 +2409,28 @@ DEFINE_ALIAS_FUNCTION(transform_tohost_VkPhysicalDeviceShaderSubgroupExtendedTyp
 DEFINE_ALIAS_FUNCTION(transform_fromhost_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
                       transform_fromhost_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR)
 
+#endif
+#ifdef VK_KHR_global_priority
+void transform_tohost_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VkDecoderGlobalState* resourceTracker, VkDeviceQueueGlobalPriorityCreateInfoKHR* toTransform);
+
+void transform_fromhost_VkDeviceQueueGlobalPriorityCreateInfoKHR(
+    VkDecoderGlobalState* resourceTracker, VkDeviceQueueGlobalPriorityCreateInfoKHR* toTransform);
+
+void transform_tohost_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* toTransform);
+
+void transform_fromhost_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
+    VkDecoderGlobalState* resourceTracker,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* toTransform);
+
+void transform_tohost_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VkDecoderGlobalState* resourceTracker, VkQueueFamilyGlobalPriorityPropertiesKHR* toTransform);
+
+void transform_fromhost_VkQueueFamilyGlobalPriorityPropertiesKHR(
+    VkDecoderGlobalState* resourceTracker, VkQueueFamilyGlobalPriorityPropertiesKHR* toTransform);
+
 #endif
 #ifdef VK_KHR_vulkan_memory_model
 DEFINE_ALIAS_FUNCTION(transform_tohost_VkPhysicalDeviceVulkanMemoryModelFeatures,
diff --git a/host/vulkan/cereal/common/vk_struct_id.h b/host/vulkan/cereal/common/vk_struct_id.h
index 081d6795f..65f428b7a 100644
--- a/host/vulkan/cereal/common/vk_struct_id.h
+++ b/host/vulkan/cereal/common/vk_struct_id.h
@@ -105,6 +105,8 @@ REGISTER_VK_STRUCT_ID(VkPhysicalDevicePrivateDataFeatures,
                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES);
 REGISTER_VK_STRUCT_ID(VkPhysicalDeviceInlineUniformBlockFeatures,
                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES);
+REGISTER_VK_STRUCT_ID(VkPhysicalDeviceRobustness2FeaturesEXT,
+                      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT);
 
 #if defined(VK_USE_PLATFORM_SCREEN_QNX)
 REGISTER_VK_STRUCT_ID(VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX,
@@ -139,6 +141,10 @@ REGISTER_VK_STRUCT_ID(VkPhysicalDeviceDiagnosticsConfigFeaturesNV,
                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV);
 REGISTER_VK_STRUCT_ID(VkDeviceGroupDeviceCreateInfo,
                       VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO);
+REGISTER_VK_STRUCT_ID(VkPhysicalDeviceVulkan11Features,
+                      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES);
+REGISTER_VK_STRUCT_ID(VkPhysicalDeviceVulkan12Features,
+                      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES);
 REGISTER_VK_STRUCT_ID(VkPhysicalDeviceVulkan13Features,
                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES);
 
diff --git a/host/vulkan/emulated_textures/AstcTexture.cpp b/host/vulkan/emulated_textures/AstcTexture.cpp
index bebc0d11e..2c01d1bcb 100644
--- a/host/vulkan/emulated_textures/AstcTexture.cpp
+++ b/host/vulkan/emulated_textures/AstcTexture.cpp
@@ -223,7 +223,7 @@ void AstcTexture::on_vkCmdCopyBufferToImageImpl(VkCommandBuffer commandBuffer, u
     }
 
     // Decompress each region
-    for (int i = 0; i < regionCount; i++) {
+    for (uint32_t i = 0; i < regionCount; i++) {
         const auto& compRegion = pRegions[i];
         const auto& decompRegion = decompRegions[i];
         const auto& regionInfo = regionInfos[i];
diff --git a/host/vulkan/meson.build b/host/vulkan/meson.build
index c11957070..dd96489e5 100644
--- a/host/vulkan/meson.build
+++ b/host/vulkan/meson.build
@@ -25,11 +25,13 @@ files_lib_vulkan_server = files(
   'VkCommonOperations.cpp',
   'VkDecoder.cpp',
   'VkEmulatedPhysicalDeviceMemory.cpp',
+  'VkEmulatedPhysicalDeviceQueue.cpp',
   'VkDecoderGlobalState.cpp',
   'VkDecoderSnapshot.cpp',
   'VkDecoderSnapshotUtils.cpp',
   'VkFormatUtils.cpp',
   'VkReconstruction.cpp',
+  'VulkanBoxedHandles.cpp',
   'VulkanDispatch.cpp',
   'VulkanHandleMapping.cpp',
   'VulkanStream.cpp',
diff --git a/host/vulkan/testing/VkDecoderTestDispatch.h b/host/vulkan/testing/VkDecoderTestDispatch.h
index d8857d1eb..c187f4b63 100644
--- a/host/vulkan/testing/VkDecoderTestDispatch.h
+++ b/host/vulkan/testing/VkDecoderTestDispatch.h
@@ -14,9 +14,10 @@
 
 #pragma once
 
-#include "vulkan/VkDecoderGlobalState.h"
 #include "goldfish_vk_dispatch.h"
+#include "vulkan/VkDecoderGlobalState.h"
 #include "vulkan/vulkan.h"
+#include "VulkanBoxedHandles.h"
 
 namespace gfxstream {
 namespace vk {
@@ -38,29 +39,30 @@ class VkDecoderTestDispatch {
     VkResult vkAllocateCommandBuffers(VkDevice device,
                                       const VkCommandBufferAllocateInfo* pAllocateInfo,
                                       VkCommandBuffer* pCommandBuffers) {
-        return mDgs->on_vkAllocateCommandBuffers(mBp, device, pAllocateInfo, pCommandBuffers);
+        return mDgs->on_vkAllocateCommandBuffers(mBp, nullptr, device, pAllocateInfo,
+                                                 pCommandBuffers);
     }
 
     VkResult vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo,
                               const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory) {
-        return mDgs->on_vkAllocateMemory(mBp, device, pAllocateInfo, pAllocator, pMemory);
+        return mDgs->on_vkAllocateMemory(mBp, nullptr, device, pAllocateInfo, pAllocator, pMemory);
     }
 
     VkResult vkBeginCommandBuffer(VkCommandBuffer commandBuffer,
                                   const VkCommandBufferBeginInfo* pBeginInfo) {
-        return mDgs->on_vkBeginCommandBuffer(mBp, commandBuffer, pBeginInfo,
+        return mDgs->on_vkBeginCommandBuffer(mBp, nullptr, commandBuffer, pBeginInfo,
                                              *mDecoderContext);
     }
 
     VkResult vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory,
                                 VkDeviceSize memoryOffset) {
-        return mDgs->on_vkBindBufferMemory(mBp, device, unbox_VkBuffer(buffer),
+        return mDgs->on_vkBindBufferMemory(mBp, nullptr, device, unbox_VkBuffer(buffer),
                                            unbox_VkDeviceMemory(memory), memoryOffset);
     }
 
     VkResult vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory,
                                VkDeviceSize memoryOffset) {
-        return mDgs->on_vkBindImageMemory(mBp, device, unbox_VkImage(image),
+        return mDgs->on_vkBindImageMemory(mBp, nullptr, device, unbox_VkImage(image),
                                           unbox_VkDeviceMemory(memory), memoryOffset);
     }
 
@@ -75,7 +77,7 @@ class VkDecoderTestDispatch {
     void vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
                                 VkImageLayout dstImageLayout, uint32_t regionCount,
                                 const VkBufferImageCopy* pRegions) {
-        mDgs->on_vkCmdCopyBufferToImage(mBp, commandBuffer, unbox_VkBuffer(srcBuffer),
+        mDgs->on_vkCmdCopyBufferToImage(mBp, nullptr, commandBuffer, unbox_VkBuffer(srcBuffer),
                                         unbox_VkImage(dstImage), dstImageLayout, regionCount,
                                         pRegions, *mDecoderContext);
     }
@@ -84,8 +86,9 @@ class VkDecoderTestDispatch {
                         VkImageLayout srcImageLayout, VkImage dstImage,
                         VkImageLayout dstImageLayout, uint32_t regionCount,
                         const VkImageCopy* pRegions) {
-        mDgs->on_vkCmdCopyImage(mBp, commandBuffer, unbox_VkImage(srcImage), srcImageLayout,
-                                unbox_VkImage(dstImage), dstImageLayout, regionCount, pRegions);
+        mDgs->on_vkCmdCopyImage(mBp, nullptr, commandBuffer, unbox_VkImage(srcImage),
+                                srcImageLayout, unbox_VkImage(dstImage), dstImageLayout,
+                                regionCount, pRegions);
     }
 
     void vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
@@ -95,7 +98,7 @@ class VkDecoderTestDispatch {
                               const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                               uint32_t imageMemoryBarrierCount,
                               const VkImageMemoryBarrier* pImageMemoryBarriers) {
-        mDgs->on_vkCmdPipelineBarrier(mBp, commandBuffer, srcStageMask, dstStageMask,
+        mDgs->on_vkCmdPipelineBarrier(mBp, nullptr, commandBuffer, srcStageMask, dstStageMask,
                                       dependencyFlags, memoryBarrierCount, pMemoryBarriers,
                                       bufferMemoryBarrierCount, pBufferMemoryBarriers,
                                       imageMemoryBarrierCount, pImageMemoryBarriers);
@@ -103,25 +106,27 @@ class VkDecoderTestDispatch {
 
     void vkCmdPipelineBarrier2(VkCommandBuffer commandBuffer,
                                const VkDependencyInfo* pDependencyInfo) {
-        mDgs->on_vkCmdPipelineBarrier2(mBp, commandBuffer, pDependencyInfo);
+        mDgs->on_vkCmdPipelineBarrier2(mBp, nullptr, commandBuffer, pDependencyInfo);
     }
 
     void vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage,
                                 VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                 uint32_t regionCount, const VkBufferImageCopy* pRegions) {
-        mDgs->on_vkCmdCopyImageToBuffer(mBp, commandBuffer, unbox_VkImage(srcImage), srcImageLayout,
-                                        unbox_VkBuffer(dstBuffer), regionCount, pRegions);
+        mDgs->on_vkCmdCopyImageToBuffer(mBp, nullptr, commandBuffer, unbox_VkImage(srcImage),
+                                        srcImageLayout, unbox_VkBuffer(dstBuffer), regionCount,
+                                        pRegions);
     }
 
     VkResult vkCreateBuffer(VkDevice device, const VkBufferCreateInfo* pCreateInfo,
                             const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
-        return mDgs->on_vkCreateBuffer(mBp, device, pCreateInfo, pAllocator, pBuffer);
+        return mDgs->on_vkCreateBuffer(mBp, nullptr, device, pCreateInfo, pAllocator, pBuffer);
     }
 
     VkResult vkCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator,
                                  VkCommandPool* pCommandPool) {
-        return mDgs->on_vkCreateCommandPool(mBp, device, pCreateInfo, pAllocator, pCommandPool);
+        return mDgs->on_vkCreateCommandPool(mBp, nullptr, device, pCreateInfo, pAllocator,
+                                            pCommandPool);
     }
 
     VkResult vkCreateDebugUtilsMessengerEXT(VkInstance instance,
@@ -140,34 +145,36 @@ class VkDecoderTestDispatch {
 
     VkResult vkCreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo,
                             const VkAllocationCallbacks* pAllocator, VkDevice* pDevice) {
-        return mDgs->on_vkCreateDevice(mBp, physicalDevice, pCreateInfo, pAllocator, pDevice);
+        return mDgs->on_vkCreateDevice(mBp, nullptr, physicalDevice, pCreateInfo, pAllocator,
+                                       pDevice);
     }
 
     VkResult vkCreateImage(VkDevice device, const VkImageCreateInfo* pCreateInfo,
                            const VkAllocationCallbacks* pAllocator, VkImage* pImage) {
         mDgs->transformImpl_VkImageCreateInfo_tohost(pCreateInfo, 1);
-        return mDgs->on_vkCreateImage(mBp, device, pCreateInfo, pAllocator, pImage);
+        return mDgs->on_vkCreateImage(mBp, nullptr, device, pCreateInfo, pAllocator, pImage);
     }
 
     VkResult vkCreateImageView(VkDevice device, const VkImageViewCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator, VkImageView* pView) {
-        return mDgs->on_vkCreateImageView(mBp, device, pCreateInfo, pAllocator, pView);
+        return mDgs->on_vkCreateImageView(mBp, nullptr, device, pCreateInfo, pAllocator, pView);
     }
 
     VkResult vkCreateInstance(const VkInstanceCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator, VkInstance* pInstance) {
-        return mDgs->on_vkCreateInstance(mBp, pCreateInfo, pAllocator, pInstance);
+        return mDgs->on_vkCreateInstance(mBp, nullptr, pCreateInfo, pAllocator, pInstance);
     }
 
     void vkDestroyBuffer(VkDevice device, VkBuffer buffer,
                          const VkAllocationCallbacks* pAllocator) {
-        mDgs->on_vkDestroyBuffer(mBp, device, unbox_VkBuffer(buffer), pAllocator);
+        mDgs->on_vkDestroyBuffer(mBp, nullptr, device, unbox_VkBuffer(buffer), pAllocator);
         delete_VkBuffer(buffer);
     }
 
     void vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool,
                               const VkAllocationCallbacks* pAllocator) {
-        mDgs->on_vkDestroyCommandPool(mBp, device, unbox_VkCommandPool(commandPool), pAllocator);
+        mDgs->on_vkDestroyCommandPool(mBp, nullptr, device, unbox_VkCommandPool(commandPool),
+                                      pAllocator);
         delete_VkCommandPool(commandPool);
     }
 
@@ -183,26 +190,26 @@ class VkDecoderTestDispatch {
     }
 
     void vkDestroyDevice(VkDevice device, const VkAllocationCallbacks* pAllocator) {
-        mDgs->on_vkDestroyDevice(mBp, device, pAllocator);
+        mDgs->on_vkDestroyDevice(mBp, nullptr, device, pAllocator);
     }
 
     void vkDestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator) {
-        mDgs->on_vkDestroyImage(mBp, device, unbox_VkImage(image), pAllocator);
+        mDgs->on_vkDestroyImage(mBp, nullptr, device, unbox_VkImage(image), pAllocator);
         delete_VkImage(image);
     }
 
     void vkDestroyImageView(VkDevice device, VkImageView imageView,
                             const VkAllocationCallbacks* pAllocator) {
-        mDgs->on_vkDestroyImageView(mBp, device, unbox_VkImageView(imageView), pAllocator);
+        mDgs->on_vkDestroyImageView(mBp, nullptr, device, unbox_VkImageView(imageView), pAllocator);
         delete_VkImageView(imageView);
     }
 
     void vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks* pAllocator) {
-        mDgs->on_vkDestroyInstance(mBp, instance, pAllocator);
+        mDgs->on_vkDestroyInstance(mBp, nullptr, instance, pAllocator);
     }
 
     VkResult vkEndCommandBuffer(VkCommandBuffer commandBuffer) {
-        return mDgs->on_vkEndCommandBuffer(mBp, commandBuffer, *mDecoderContext);
+        return mDgs->on_vkEndCommandBuffer(mBp, nullptr, commandBuffer, *mDecoderContext);
     }
 
     VkResult vkEnumerateInstanceLayerProperties(uint32_t* pPropertyCount,
@@ -212,13 +219,13 @@ class VkDecoderTestDispatch {
 
     VkResult vkEnumeratePhysicalDevices(VkInstance instance, uint32_t* physicalDeviceCount,
                                         VkPhysicalDevice* physicalDevices) {
-        return mDgs->on_vkEnumeratePhysicalDevices(mBp, instance, physicalDeviceCount,
+        return mDgs->on_vkEnumeratePhysicalDevices(mBp, nullptr, instance, physicalDeviceCount,
                                                    physicalDevices);
     }
 
     void vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool,
                               uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers) {
-        mDgs->on_vkFreeCommandBuffers(mBp, device, unbox_VkCommandPool(commandPool),
+        mDgs->on_vkFreeCommandBuffers(mBp, nullptr, device, unbox_VkCommandPool(commandPool),
                                       commandBufferCount, pCommandBuffers);
         // Calling delete_VkCommandBuffer is normally done in the decoder, so we have to do it here.
         for (int i = 0; i < commandBufferCount; ++i) {
@@ -228,7 +235,7 @@ class VkDecoderTestDispatch {
 
     void vkFreeMemory(VkDevice device, VkDeviceMemory memory,
                       const VkAllocationCallbacks* pAllocator) {
-        mDgs->on_vkFreeMemory(mBp, device, unbox_VkDeviceMemory(memory), pAllocator);
+        mDgs->on_vkFreeMemory(mBp, nullptr, device, unbox_VkDeviceMemory(memory), pAllocator);
         delete_VkDeviceMemory(memory);
     }
 
@@ -240,31 +247,34 @@ class VkDecoderTestDispatch {
 
     void vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex,
                           VkQueue* pQueue) {
-        mDgs->on_vkGetDeviceQueue(mBp, device, queueFamilyIndex, queueIndex, pQueue);
+        mDgs->on_vkGetDeviceQueue(mBp, nullptr, device, queueFamilyIndex, queueIndex, pQueue);
     }
 
     void vkGetImageMemoryRequirements(VkDevice device, VkImage image,
                                       VkMemoryRequirements* pMemoryRequirements) {
-        mDgs->on_vkGetImageMemoryRequirements(mBp, device, unbox_VkImage(image),
+        mDgs->on_vkGetImageMemoryRequirements(mBp, nullptr, device, unbox_VkImage(image),
                                               pMemoryRequirements);
     }
 
     void vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format,
                                              VkFormatProperties* pFormatProperties) {
-        mDgs->on_vkGetPhysicalDeviceFormatProperties(mBp, physicalDevice, format,
+        mDgs->on_vkGetPhysicalDeviceFormatProperties(mBp, nullptr, physicalDevice, format,
                                                      pFormatProperties);
     }
     void vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice,
                                              VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
-        mDgs->on_vkGetPhysicalDeviceMemoryProperties(mBp, physicalDevice, pMemoryProperties);
+        mDgs->on_vkGetPhysicalDeviceMemoryProperties(mBp, nullptr, physicalDevice,
+                                                     pMemoryProperties);
     }
 
     VkResult vkQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits,
                            VkFence fence) {
-        return mDgs->on_vkQueueSubmit(mBp, queue, submitCount, pSubmits, fence);
+        return mDgs->on_vkQueueSubmit(mBp, nullptr, queue, submitCount, pSubmits, fence);
     }
 
-    VkResult vkQueueWaitIdle(VkQueue queue) { return mDgs->on_vkQueueWaitIdle(mBp, queue); }
+    VkResult vkQueueWaitIdle(VkQueue queue) {
+        return mDgs->on_vkQueueWaitIdle(mBp, nullptr, queue);
+    }
 
     VkResult vkDeviceWaitIdle(VkDevice device) {
         return mVk->vkDeviceWaitIdle(unbox_VkDevice(device));
@@ -280,12 +290,12 @@ class VkDecoderTestDispatch {
 
     VkResult vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset,
                          VkDeviceSize size, VkMemoryMapFlags flags, void** ppData) {
-        return mDgs->on_vkMapMemory(mBp, device, unbox_VkDeviceMemory(memory), offset, size, flags,
-                                    ppData);
+        return mDgs->on_vkMapMemory(mBp, nullptr, device, unbox_VkDeviceMemory(memory), offset,
+                                    size, flags, ppData);
     }
 
     void vkUnmapMemory(VkDevice device, VkDeviceMemory memory) {
-        mDgs->on_vkUnmapMemory(mBp, device, unbox_VkDeviceMemory(memory));
+        mDgs->on_vkUnmapMemory(mBp, nullptr, device, unbox_VkDeviceMemory(memory));
     }
 
    private:
diff --git a/host/vulkan/testing/VulkanTestHelper.cpp b/host/vulkan/testing/VulkanTestHelper.cpp
index ea24c49e7..01fd475d2 100644
--- a/host/vulkan/testing/VulkanTestHelper.cpp
+++ b/host/vulkan/testing/VulkanTestHelper.cpp
@@ -56,14 +56,13 @@ VulkanTestHelper::VulkanTestHelper()
       mLogger(),
       mMetricsLogger(android::base::CreateMetricsLogger()),
       mHealthMonitor(*mMetricsLogger),
-      mVkEmu(createGlobalVkEmulation(mVk, {}, getGfxstreamFeatures())),
+      mVkEmu(VkEmulation::create(mVk, {}, getGfxstreamFeatures())),
       mBp(std::make_unique<BumpPool>()),
       mDecoderContext(VkDecoderContext{.processName = "vulkan_test",
                                        .gfxApiLogger = &mLogger,
                                        .healthMonitor = &mHealthMonitor,
                                        .metricsLogger = mMetricsLogger.get()}),
       mTestDispatch(mVk, mBp.get(), &mDecoderContext) {
-
     // This is used by VkDecoderGlobalState::on_vkCreateInstance()
     QAndroidVmOperations vmOps;
     vmOps.setSkipSnapshotSave = [](bool) {};
@@ -91,7 +90,7 @@ void VulkanTestHelper::destroy() {
     mDebugMessenger = VK_NULL_HANDLE;
 
     VkDecoderGlobalState::reset();
-    teardownGlobalVkEmulation();
+    mVkEmu.reset();
 }
 
 VulkanTestHelper::~VulkanTestHelper() {
@@ -102,9 +101,9 @@ VulkanTestHelper::~VulkanTestHelper() {
 }
 
 void VulkanTestHelper::initialize(const InitializationOptions& options) {
-    initVkEmulationFeatures(std::make_unique<VkEmulationFeatures>(VkEmulationFeatures{
+    mVkEmu->initFeatures(VkEmulation::Features{
         .astcLdrEmulationMode = options.astcLdrEmulationMode,
-    }));
+    });
 
     // Check that the validation layer is present
     const char* validationLayer = "VK_LAYER_KHRONOS_validation";
diff --git a/host/vulkan/testing/VulkanTestHelper.h b/host/vulkan/testing/VulkanTestHelper.h
index b1497e873..31f36b1da 100644
--- a/host/vulkan/testing/VulkanTestHelper.h
+++ b/host/vulkan/testing/VulkanTestHelper.h
@@ -102,7 +102,7 @@ class VulkanTestHelper {
     emugl::GfxApiLogger mLogger;
     std::unique_ptr<android::base::MetricsLogger> mMetricsLogger;
     emugl::HealthMonitor<> mHealthMonitor;
-    VkEmulation* mVkEmu;
+    std::unique_ptr<VkEmulation> mVkEmu;
     std::unique_ptr<::android::base::BumpPool> mBp;
     VkDecoderContext mDecoderContext;
     VkDecoderTestDispatch mTestDispatch;
diff --git a/include/render-utils/Renderer.h b/include/render-utils/Renderer.h
index 7520d9e36..d1b62f9b8 100644
--- a/include/render-utils/Renderer.h
+++ b/include/render-utils/Renderer.h
@@ -274,7 +274,7 @@ public:
     virtual void pauseAllPreSave() = 0;
 
     // Resumes all channels after snapshot saving or loading.
-    virtual void resumeAll(bool waitForSave = true) = 0;
+    virtual void resumeAll() = 0;
 
     virtual void save(
             android::base::Stream* stream,
diff --git a/scripts/print_gfx_logs/vulkan_printer.py b/scripts/print_gfx_logs/vulkan_printer.py
index b7a35713f..8a5398bd6 100644
--- a/scripts/print_gfx_logs/vulkan_printer.py
+++ b/scripts/print_gfx_logs/vulkan_printer.py
@@ -236,6 +236,14 @@ def OP_vkCreatePipelineCache(printer, indent: int):
     pPipelineCache = printer.write_int("pPipelineCache", 8, indent, optional=False, count=None, big_endian=False)
     return
 
+def OP_vkCreatePipelineLayout(printer, indent: int):
+    printer.write_int("seqno: ", 4, indent)
+    device = printer.write_int("device", 8, indent, signed=False, big_endian=False)
+    printer.write_struct("pCreateInfo", struct_VkPipelineLayoutCreateInfo, False, None, indent)
+    printer.write_struct("pAllocator", struct_VkAllocationCallbacks, True, None, indent)
+    pPipelineLayout = printer.write_int("pPipelineLayout", 8, indent, optional=False, count=None, big_endian=False)
+    return
+
 def OP_vkCreateRenderPass(printer, indent: int):
     printer.write_int("seqno: ", 4, indent)
     device = printer.write_int("device", 8, indent, signed=False, big_endian=False)
@@ -983,6 +991,14 @@ def struct_VkPipelineInputAssemblyStateCreateInfo(printer, indent: int):
     printer.write_enum("topology", VkPrimitiveTopology, indent)
     primitiveRestartEnable = printer.write_int("primitiveRestartEnable", 4, indent, signed=False, big_endian=False)
 
+def struct_VkPipelineLayoutCreateInfo(printer, indent: int):
+    printer.write_stype_and_pnext("VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", indent)
+    flags = printer.write_int("flags", 4, indent, signed=False, big_endian=False)
+    setLayoutCount = printer.write_int("setLayoutCount", 4, indent, signed=False, big_endian=False)
+    pSetLayouts = printer.write_int("pSetLayouts", 8, indent, optional=False, count=setLayoutCount, big_endian=False)
+    pushConstantRangeCount = printer.write_int("pushConstantRangeCount", 4, indent, signed=False, big_endian=False)
+    printer.write_struct("pPushConstantRanges", struct_VkPushConstantRange, False, pushConstantRangeCount, indent)
+
 def struct_VkPipelineMultisampleStateCreateInfo(printer, indent: int):
     printer.write_stype_and_pnext("VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO", indent)
     flags = printer.write_int("flags", 4, indent, signed=False, big_endian=False)
@@ -1036,6 +1052,11 @@ def struct_VkPipelineViewportStateCreateInfo(printer, indent: int):
     scissorCount = printer.write_int("scissorCount", 4, indent, signed=False, big_endian=False)
     printer.write_struct("pScissors", struct_VkRect2D, True, scissorCount, indent)
 
+def struct_VkPushConstantRange(printer, indent: int):
+    stageFlags = printer.write_int("stageFlags", 4, indent, signed=False, big_endian=False)
+    offset = printer.write_int("offset", 4, indent, signed=False, big_endian=False)
+    size = printer.write_int("size", 4, indent, signed=False, big_endian=False)
+
 def struct_VkRect2D(printer, indent: int):
     printer.write_struct("offset", struct_VkOffset2D, False, None, indent)
     printer.write_struct("extent", struct_VkExtent2D, False, None, indent)
diff --git a/third-party/CMakeLists.txt b/third-party/CMakeLists.txt
index f7257003a..b012b3124 100644
--- a/third-party/CMakeLists.txt
+++ b/third-party/CMakeLists.txt
@@ -217,6 +217,21 @@ if(WITH_BENCHMARK)
     endif()
 endif()
 
+if(GFXSTREAM_ENABLE_HOST_TRACING)
+    if(DEPENDENCY_RESOLUTION STREQUAL "AOSP")
+        set(GFXSTREAM_PERFETTO_PATH ${PROJECT_SOURCE_DIR}/../../../external/perfetto)
+        if(NOT EXISTS ${GFXSTREAM_PERFETTO_PATH})
+            message(FATAL_ERROR "Perfetto is not found.")
+        endif()
+        add_library(perfetto
+                    STATIC
+                    ${GFXSTREAM_PERFETTO_PATH}/sdk/perfetto.cc)
+        target_include_directories(perfetto
+                                   INTERFACE
+                                   ${GFXSTREAM_PERFETTO_PATH}/sdk)
+    endif()
+endif()
+
 if(NOT TARGET libdrm_headers)
     if(DEPENDENCY_RESOLUTION STREQUAL "AOSP")
         set(LIBDRM_PATH ${PROJECT_SOURCE_DIR}/../../../external/libdrm)
diff --git a/third-party/fuchsia/magma/BUILD.bazel b/third-party/fuchsia/magma/BUILD.bazel
index e6f9804c8..8355af0b6 100644
--- a/third-party/fuchsia/magma/BUILD.bazel
+++ b/third-party/fuchsia/magma/BUILD.bazel
@@ -1,9 +1,9 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
+
 cc_library(
     name = "magma-headers",
     hdrs = glob([
         "include/**/*.h",
-        "include/**/*.hpp",
-        "include/**/*.inl",
     ]),
     includes = ["include"],
     visibility = ["//visibility:public"],
diff --git a/third-party/stb/Android.bp b/third-party/stb/Android.bp
index 034f32a64..24761f42a 100644
--- a/third-party/stb/Android.bp
+++ b/third-party/stb/Android.bp
@@ -24,4 +24,7 @@ cc_library {
     export_include_dirs: [
         "include",
     ],
+    cflags: [
+        "-Wno-implicit-fallthrough",
+    ],
 }
diff --git a/utils/BUILD.bazel b/utils/BUILD.bazel
index f04252493..245f9ca65 100644
--- a/utils/BUILD.bazel
+++ b/utils/BUILD.bazel
@@ -1,5 +1,7 @@
 # File: BUILD
 
+load("@rules_cc//cc:defs.bzl", "cc_library", "cc_test")
+
 # Interface Library
 cc_library(
     name = "gfxstream_utils_headers",
@@ -7,10 +9,10 @@ cc_library(
     includes = ["include"],
     visibility = ["//visibility:public"],
     deps = [
-        "//hardware/google/aemu/base:aemu-base-headers",
-        "//hardware/google/aemu/host-common:aemu-host-common-headers",
-        "//hardware/google/gfxstream/common/vulkan:gfxstream_vulkan_headers",
-        "//hardware/google/gfxstream/third-party/renderdoc",
+        "//common/vulkan:gfxstream_vulkan_headers",
+        "//third-party/renderdoc",
+        "@aemu//base:aemu-base-headers",
+        "@aemu//host-common:aemu-host-common-headers",
     ],
 )
 
@@ -31,6 +33,7 @@ cc_test(
     ],
     deps = [
         ":gfxstream_utils",
+        "@aemu//base:aemu-base",
         "@com_google_googletest//:gtest_main",
     ],
 )
```

