```diff
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 6e94e998..e4829811 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -14,14 +14,26 @@
     },
     {
       "name": "libuwb_uci_jni_rust_tests"
+    },
+    {
+      "name": "CtsRangingTestCases"
+    },
+    {
+      "name": "RangingServiceTests"
+    },
+    {
+      "name": "RangingFrameworkTests"
+    },
+    {
+      "name": "RangingUwbBackendTests"
+    },
+    {
+      "name": "RangingRttBackendTests"
     }
   ],
   "postsubmit": [
     {
       "name": "UwbFusionLibTests"
-    },
-    {
-      "name": "CtsRangingTestCases"
     }
   ]
 }
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/UwbClient.java b/androidx_backend/src/androidx/core/uwb/backend/impl/UwbClient.java
index f100f4cd..8612df70 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/UwbClient.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/UwbClient.java
@@ -35,6 +35,7 @@ import androidx.core.uwb.backend.impl.internal.RangingPosition;
 import androidx.core.uwb.backend.impl.internal.RangingSessionCallback;
 import androidx.core.uwb.backend.impl.internal.UwbDevice;
 import androidx.core.uwb.backend.impl.internal.UwbRangeDataNtfConfig;
+import androidx.core.uwb.backend.impl.internal.UwbRangeLimitsConfig;
 import androidx.core.uwb.backend.impl.internal.UwbServiceImpl;
 
 import java.util.ArrayList;
@@ -118,7 +119,9 @@ public abstract class UwbClient extends IUwbClient.Stub {
                         parameters.sessionKeyInfo, parameters.subSessionKeyInfo,
                         channel, addresses, parameters.rangingUpdateRate,
                         uwbRangeDataNtfConfigBuilder.build(), duration,
-                        !mSupportsAzimuthalAngle || parameters.isAoaDisabled));
+                        !mSupportsAzimuthalAngle || parameters.isAoaDisabled,
+                // Use default in uwb backend.
+                new UwbRangeLimitsConfig.Builder().build()));
     }
 
     public void setSubscribeConsumer(Consumer<IUwbAvailabilityObserver> subscribeConsumer) {
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/ConfigurationManager.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/ConfigurationManager.java
index 84acc826..8f2361c0 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/ConfigurationManager.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/ConfigurationManager.java
@@ -544,7 +544,11 @@ public final class ConfigurationManager {
                                 rangingParameters.getUwbRangeDataNtfConfig().getNtfProximityFar())
                         .setInBandTerminationAttemptCount(3)
                         .setStsConfig(configuration.getStsConfig())
-                        .setRangingErrorStreakTimeoutMs(10_000L);
+                        .setRangingErrorStreakTimeoutMs(10_000L)
+                        .setMaxNumberOfMeasurements(rangingParameters
+                                .getUwbRangeLimitsConfig().getRangeMaxNumberOfMeasurements())
+                        .setMaxRangingRoundRetries(rangingParameters
+                                .getUwbRangeLimitsConfig().getRangeMaxRangingRoundRetries());
 
         if (configuration.getStsConfig() == FiraParams.STS_CONFIG_STATIC) {
             byte[] staticStsIv =
@@ -590,7 +594,7 @@ public final class ConfigurationManager {
 
         if (configuration.getConfigId() == CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE
                 || configuration.getConfigId()
-                    == CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF) {
+                == CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF) {
             builder.setHasRangingResultReportMessage(false);
             builder.setFilterType(FILTER_TYPE_NONE);
         }
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingCapabilities.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingCapabilities.java
index dddf4b64..0c6acc93 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingCapabilities.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingCapabilities.java
@@ -19,16 +19,15 @@ package androidx.core.uwb.backend.impl.internal;
 import static androidx.core.uwb.backend.impl.internal.Utils.CONFIG_DL_TDOA_DT_TAG;
 import static androidx.core.uwb.backend.impl.internal.Utils.CONFIG_MULTICAST_DS_TWR;
 import static androidx.core.uwb.backend.impl.internal.Utils.CONFIG_MULTICAST_DS_TWR_NO_AOA;
+import static androidx.core.uwb.backend.impl.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE;
 import static androidx.core.uwb.backend.impl.internal.Utils.CONFIG_UNICAST_DS_TWR;
 import static androidx.core.uwb.backend.impl.internal.Utils.CONFIG_UNICAST_DS_TWR_NO_AOA;
-import static androidx.core.uwb.backend.impl.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE;
 import static androidx.core.uwb.backend.impl.internal.Utils.RANGE_DATA_NTF_ENABLE;
 
 import androidx.annotation.IntRange;
 
 import com.google.common.collect.ImmutableList;
 
-import java.util.ArrayList;
 import java.util.List;
 
 /** Describes UWB ranging capabilities for the current device. */
@@ -78,8 +77,8 @@ public class RangingCapabilities {
                 supportsElevationAngle,
                 DEFAULT_SUPPORTS_RANGING_INTERVAL_RECONFIGURE,
                 FIRA_DEFAULT_RANGING_INTERVAL_MS,
-                new ArrayList<>(FIRA_DEFAULT_SUPPORTED_CHANNEL),
-                new ArrayList<>(RANGE_DATA_NTF_ENABLE),
+                List.of(FIRA_DEFAULT_SUPPORTED_CHANNEL),
+                List.of(RANGE_DATA_NTF_ENABLE),
                 FIRA_DEFAULT_SUPPORTED_CONFIG_IDS,
                 DEFAULT_SUPPORTED_SLOT_DURATIONS,
                 DEFAULT_SUPPORTED_RANGING_UPDATE_RATE,
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingDevice.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingDevice.java
index a336bd17..91eea277 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingDevice.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingDevice.java
@@ -198,7 +198,8 @@ public abstract class RangingDevice {
                             rangingParameters.getRangingUpdateRate(),
                             rangingParameters.getUwbRangeDataNtfConfig(),
                             rangingParameters.getSlotDuration(),
-                            rangingParameters.isAoaDisabled());
+                            rangingParameters.isAoaDisabled(),
+                            rangingParameters.getUwbRangeLimitsConfig());
         } else {
             mRangingParameters = rangingParameters;
         }
@@ -291,7 +292,7 @@ public abstract class RangingDevice {
             @Override
             public void onOpened(RangingSession session) {
                 mRangingSession = session;
-                mOpAsyncCallbackRunner.complete(true);
+                mOpAsyncCallbackRunner.completeIfActive(true);
             }
 
             @WorkerThread
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingParameters.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingParameters.java
index 5d1b4e20..45f9df0c 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingParameters.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingParameters.java
@@ -17,6 +17,7 @@
 package androidx.core.uwb.backend.impl.internal;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import com.google.common.collect.ImmutableList;
 
@@ -39,6 +40,7 @@ public class RangingParameters {
     @Utils.SlotDuration
     private final int mSlotDuration;
     private final boolean mIsAoaDisabled;
+    @Nullable private final UwbRangeLimitsConfig mRangeLimitsConfig;
 
     public RangingParameters(
             @Utils.UwbConfigId int uwbConfigId,
@@ -51,7 +53,8 @@ public class RangingParameters {
             @Utils.RangingUpdateRate int rangingUpdateRate,
             @NonNull UwbRangeDataNtfConfig uwbRangeDataNtfConfig,
             @Utils.SlotDuration int slotDuration,
-            boolean isAoaDisabled) {
+            boolean isAoaDisabled,
+            @Nullable UwbRangeLimitsConfig rangeLimitsConfig) {
         mUwbConfigId = uwbConfigId;
         mSessionId = sessionId;
         mSubSessionId = subSessionId;
@@ -63,6 +66,7 @@ public class RangingParameters {
         mUwbRangeDataNtfConfig = uwbRangeDataNtfConfig;
         mSlotDuration = slotDuration;
         mIsAoaDisabled = isAoaDisabled;
+        mRangeLimitsConfig = rangeLimitsConfig;
     }
 
     public int getSessionId() {
@@ -110,4 +114,9 @@ public class RangingParameters {
     public boolean isAoaDisabled() {
         return mIsAoaDisabled;
     }
+
+    @Nullable
+    public UwbRangeLimitsConfig getUwbRangeLimitsConfig() {
+        return mRangeLimitsConfig;
+    }
 }
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/Utils.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/Utils.java
index 9c4b0790..14730446 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/Utils.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/Utils.java
@@ -376,7 +376,7 @@ public final class Utils {
     // Preamble index used by HPRF (high pulse repetition frequency) mode. HPRF supports bitrate up
     // to 31.2 Mbps.
     public static final ImmutableList<Integer> SUPPORTED_HPRF_PREAMBLE_INDEX =
-            ImmutableList.of(25, 26, 27, 28, 19, 30, 31, 32);
+            ImmutableList.of(25, 26, 27, 28, 29, 30, 31, 32);
 
     /** Converts millisecond to RSTU. */
     public static int convertMsToRstu(int value) {
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbAddress.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbAddress.java
index fb13e9a2..b2c87d27 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbAddress.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbAddress.java
@@ -22,6 +22,7 @@ import androidx.annotation.Nullable;
 import com.google.common.base.Objects;
 import com.google.common.primitives.Longs;
 import com.google.common.primitives.Shorts;
+import com.google.uwb.support.fira.FiraParams;
 
 import java.security.SecureRandom;
 import java.util.Arrays;
@@ -96,7 +97,9 @@ public class UwbAddress {
 
     private static byte[] generateRandomByteArray(int len, SecureRandom secureRandom) {
         byte[] bytes = new byte[len];
-        secureRandom.nextBytes(bytes);
+        do {
+            secureRandom.nextBytes(bytes);
+        } while (isForbiddenAddress(bytes));
         return bytes;
     }
 
@@ -112,6 +115,14 @@ public class UwbAddress {
         return fromBytes(generateRandomByteArray(EXTENDED_ADDRESS_LENGTH, secureRandom));
     }
 
+    private static boolean isForbiddenAddress(byte[] address) {
+        if (address.length == SHORT_ADDRESS_LENGTH) {
+            return Arrays.equals(address, FiraParams.getShortForbiddenAddress());
+        } else {
+            return Arrays.equals(address, FiraParams.getExtendedForbiddenAddress());
+        }
+    }
+
     public AddressingMode getAddressingMode() {
         return mAddressingMode;
     }
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbRangeLimitsConfig.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbRangeLimitsConfig.java
new file mode 100644
index 00000000..c9267bcd
--- /dev/null
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbRangeLimitsConfig.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package androidx.core.uwb.backend.impl.internal;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import java.util.Objects;
+
+import javax.annotation.Nonnegative;
+
+/** Configurable range duration limits for a UWB session. */
+public final class UwbRangeLimitsConfig {
+
+    public static final int UWB_PARAM_DISABLED = 0;
+    public static final int UWB_PARAM_UPPER_LIMIT = 65535;
+
+    private final int mRangeMaxNumberOfMeasurements;
+    private final int mRangeMaxRangingRoundRetries;
+
+    private UwbRangeLimitsConfig(
+            @Nonnegative int rangeMaxNumberOfMeasurements,
+            @Nonnegative int rangeMaxRangingRoundRetries) {
+        checkArgument(
+                rangeMaxNumberOfMeasurements <= UWB_PARAM_UPPER_LIMIT,
+                "Uwb Range Max Number of Measurements %s should be less than %s",
+                rangeMaxNumberOfMeasurements,
+                UWB_PARAM_UPPER_LIMIT);
+        checkArgument(
+                rangeMaxRangingRoundRetries <= UWB_PARAM_UPPER_LIMIT,
+                "UWB Range Max Ranging Round Retries should be less than and %s",
+                UWB_PARAM_UPPER_LIMIT);
+
+        this.mRangeMaxNumberOfMeasurements = rangeMaxNumberOfMeasurements;
+        this.mRangeMaxRangingRoundRetries = rangeMaxRangingRoundRetries;
+    }
+
+    public int getRangeMaxNumberOfMeasurements() {
+        return mRangeMaxNumberOfMeasurements;
+    }
+
+    public int getRangeMaxRangingRoundRetries() {
+        return mRangeMaxRangingRoundRetries;
+    }
+
+    /** Creates a new instance of {@link UwbRangeLimitsConfig}. */
+    public static class Builder {
+        private int mRangeMaxNumberOfMeasurements = UWB_PARAM_DISABLED;
+        private int mRangeMaxRangingRoundRetries = UWB_PARAM_DISABLED;
+
+        public Builder setRangeMaxNumberOfMeasurements(int rangeMaxNumberOfMeasurements) {
+            mRangeMaxNumberOfMeasurements = rangeMaxNumberOfMeasurements;
+            return this;
+        }
+
+        public Builder setRangeMaxRangingRoundRetries(int rangeMaxRangingRoundRetries) {
+            mRangeMaxRangingRoundRetries = rangeMaxRangingRoundRetries;
+            return this;
+        }
+
+        public UwbRangeLimitsConfig build() {
+            return new UwbRangeLimitsConfig(mRangeMaxNumberOfMeasurements,
+                    mRangeMaxRangingRoundRetries);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "UwbRangeLimitsConfig{"
+                + "rangeMaxNumberOfMeasurements="
+                + mRangeMaxNumberOfMeasurements
+                + ", rangeMaxRangingRoundRetries="
+                + mRangeMaxRangingRoundRetries
+                + '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof UwbRangeLimitsConfig)) {
+            return false;
+        }
+        UwbRangeLimitsConfig that = (UwbRangeLimitsConfig) o;
+        return mRangeMaxNumberOfMeasurements == that.mRangeMaxNumberOfMeasurements
+                && mRangeMaxRangingRoundRetries == that.mRangeMaxRangingRoundRetries;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mRangeMaxNumberOfMeasurements, mRangeMaxRangingRoundRetries);
+    }
+}
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbServiceImpl.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbServiceImpl.java
index 7d10080c..45594546 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbServiceImpl.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbServiceImpl.java
@@ -182,8 +182,8 @@ public class UwbServiceImpl {
                     mUwbFeatureFlags.hasElevationSupport(),
                     /* supportsRangingIntervalReconfigure */ false,
                     /* minRangingInterval= */ RangingCapabilities.FIRA_DEFAULT_RANGING_INTERVAL_MS,
-                    new ArrayList<Integer>(RangingCapabilities.FIRA_DEFAULT_SUPPORTED_CHANNEL),
-                    new ArrayList<>(RANGE_DATA_NTF_ENABLE),
+                    List.of(RangingCapabilities.FIRA_DEFAULT_SUPPORTED_CHANNEL),
+                    List.of(RANGE_DATA_NTF_ENABLE),
                     FIRA_DEFAULT_SUPPORTED_CONFIG_IDS,
                     DEFAULT_SUPPORTED_SLOT_DURATIONS,
                     DEFAULT_SUPPORTED_RANGING_UPDATE_RATE,
@@ -206,9 +206,9 @@ public class UwbServiceImpl {
         if (minRangingInterval <= 120) {
             supportedRangingUpdateRates.add(Utils.FAST);
         }
+
         if (supportedChannels == null || supportedChannels.isEmpty()) {
-            supportedChannels =
-                    new ArrayList<>(RangingCapabilities.FIRA_DEFAULT_SUPPORTED_CHANNEL);
+            supportedChannels = List.of(RangingCapabilities.FIRA_DEFAULT_SUPPORTED_CHANNEL);
         }
 
         Set<Integer> supportedNtfConfigsSet = new TreeSet<>();
diff --git a/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/ConfigurationManagerTest.java b/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/ConfigurationManagerTest.java
index 889ea843..3ec82179 100644
--- a/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/ConfigurationManagerTest.java
+++ b/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/ConfigurationManagerTest.java
@@ -86,7 +86,8 @@ public class ConfigurationManagerTest {
                         INFREQUENT,
                         mUwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
         when(mComplexChannel.getChannel()).thenReturn(1);
         when(mComplexChannel.getPreambleIndex()).thenReturn(1);
     }
@@ -117,7 +118,8 @@ public class ConfigurationManagerTest {
                         INFREQUENT,
                         mUwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
         FiraOpenSessionParams params =
                 ConfigurationManager.createOpenSessionParams(
                         TEST_DEVICE_TYPE, TEST_LOCAL_ADDRESS, rangingParameters,
diff --git a/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/RangingControleeTest.java b/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/RangingControleeTest.java
index 5167a662..a2c41a50 100644
--- a/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/RangingControleeTest.java
+++ b/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/RangingControleeTest.java
@@ -120,7 +120,8 @@ public class RangingControleeTest {
                         INFREQUENT,
                         uwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
         mRangingControlee.setRangingParameters(rangingParameters);
     }
 
@@ -143,7 +144,8 @@ public class RangingControleeTest {
                         INFREQUENT,
                         uwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
 
         mRangingControlee.setRangingParameters(rangingParameters);
 
diff --git a/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/RangingControllerTest.java b/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/RangingControllerTest.java
index 6f0aeb02..01fba634 100644
--- a/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/RangingControllerTest.java
+++ b/androidx_backend/tests/src/androidx/core/uwb/backend/impl/internal/RangingControllerTest.java
@@ -124,7 +124,8 @@ public class RangingControllerTest {
                         INFREQUENT,
                         uwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
         mRangingController =
                 new RangingController(mUwbManager, getExecutor(), mOpAsyncCallbackRunner,
                         new UwbFeatureFlags.Builder().build());
@@ -173,7 +174,8 @@ public class RangingControllerTest {
                         INFREQUENT,
                         uwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
 
         mRangingController.setRangingParameters(rangingParameters);
 
diff --git a/apex/Android.bp b/apex/Android.bp
index 1cbd4832..1deddd90 100644
--- a/apex/Android.bp
+++ b/apex/Android.bp
@@ -121,6 +121,12 @@ custom_bootclasspath_fragment {
         split_packages: [
             "android.uwb",
             "android.ranging",
+            "android.ranging.ble.cs",
+            "android.ranging.ble.rssi",
+            "android.ranging.oob",
+            "android.ranging.raw",
+            "android.ranging.uwb",
+            "android.ranging.wifi.rtt",
         ],
 
         // The following packages and all their subpackages currently only
diff --git a/flags/uwb_flags.aconfig b/flags/uwb_flags.aconfig
index cef4daf8..e42999fe 100644
--- a/flags/uwb_flags.aconfig
+++ b/flags/uwb_flags.aconfig
@@ -68,3 +68,11 @@ flag {
     description: "Implement CR-1022, CR-1047: Used to update data transfer phase config"
     bug: "319596317"
 }
+
+flag {
+    name: "uwb_fira_3_0_25q4"
+    is_exported: true
+    namespace: "uwb"
+    description: "This flag enables Fira 3.0 features supported in Android from 25Q4"
+    bug: "398833827"
+}
diff --git a/framework/api/system-current.txt b/framework/api/system-current.txt
index 82ab5136..b6c20d2d 100644
--- a/framework/api/system-current.txt
+++ b/framework/api/system-current.txt
@@ -48,6 +48,7 @@ package android.uwb {
     method @Nullable public android.uwb.AngleOfArrivalMeasurement getDestinationAngleOfArrivalMeasurement();
     method @Nullable public android.uwb.DistanceMeasurement getDistanceMeasurement();
     method public long getElapsedRealtimeNanos();
+    method @FlaggedApi("com.android.uwb.flags.uwb_fira_3_0_25q4") public long getHusPrimarySessionId();
     method public int getLineOfSight();
     method public int getMeasurementFocus();
     method @NonNull public android.os.PersistableBundle getRangingMeasurementMetadata();
@@ -63,6 +64,7 @@ package android.uwb {
     field public static final int MEASUREMENT_FOCUS_NONE = 0; // 0x0
     field public static final int MEASUREMENT_FOCUS_RANGE = 1; // 0x1
     field public static final int NLOS = 1; // 0x1
+    field @FlaggedApi("com.android.uwb.flags.uwb_fira_3_0_25q4") public static final int NON_HYBRID_UWB_SESSION_ID = 0; // 0x0
     field public static final int RANGING_STATUS_FAILURE_OUT_OF_RANGE = 1; // 0x1
     field public static final int RANGING_STATUS_FAILURE_UNKNOWN_ERROR = -1; // 0xffffffff
     field public static final int RANGING_STATUS_SUCCESS = 0; // 0x0
@@ -78,6 +80,7 @@ package android.uwb {
     method @NonNull public android.uwb.RangingMeasurement.Builder setDestinationAngleOfArrivalMeasurement(@NonNull android.uwb.AngleOfArrivalMeasurement);
     method @NonNull public android.uwb.RangingMeasurement.Builder setDistanceMeasurement(@NonNull android.uwb.DistanceMeasurement);
     method @NonNull public android.uwb.RangingMeasurement.Builder setElapsedRealtimeNanos(long);
+    method @FlaggedApi("com.android.uwb.flags.uwb_fira_3_0_25q4") @NonNull public android.uwb.RangingMeasurement.Builder setHusPrimarySessionId(long);
     method @NonNull public android.uwb.RangingMeasurement.Builder setLineOfSight(int);
     method @NonNull public android.uwb.RangingMeasurement.Builder setMeasurementFocus(int);
     method @NonNull public android.uwb.RangingMeasurement.Builder setRangingMeasurementMetadata(@NonNull android.os.PersistableBundle);
diff --git a/framework/java/android/uwb/RangingMeasurement.java b/framework/java/android/uwb/RangingMeasurement.java
index e4007742..0058e99f 100644
--- a/framework/java/android/uwb/RangingMeasurement.java
+++ b/framework/java/android/uwb/RangingMeasurement.java
@@ -16,6 +16,7 @@
 
 package android.uwb;
 
+import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
 import android.annotation.IntRange;
 import android.annotation.NonNull;
@@ -28,6 +29,8 @@ import android.os.PersistableBundle;
 import android.os.SystemClock;
 import android.uwb.util.PersistableBundleUtils;
 
+import com.android.uwb.flags.Flags;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Objects;
@@ -43,6 +46,9 @@ public final class RangingMeasurement implements Parcelable {
     public static final int RSSI_MIN = -127;
     public static final int RSSI_MAX = -1;
 
+    @FlaggedApi(Flags.FLAG_UWB_FIRA_3_0_25Q4)
+    public static final int NON_HYBRID_UWB_SESSION_ID = 0;
+
     private final UwbAddress mRemoteDeviceAddress;
     private final @Status int mStatus;
     private final long mElapsedRealtimeNanos;
@@ -52,6 +58,7 @@ public final class RangingMeasurement implements Parcelable {
     private final @LineOfSight int mLineOfSight;
     private final @MeasurementFocus int mMeasurementFocus;
     private final int mRssiDbm;
+    private final long mHusPrimarySessionId;
     private final PersistableBundle mRangingMeasurementMetadata;
 
     private RangingMeasurement(@NonNull UwbAddress remoteDeviceAddress, @Status int status,
@@ -60,6 +67,7 @@ public final class RangingMeasurement implements Parcelable {
             @Nullable AngleOfArrivalMeasurement destinationAngleOfArrivalMeasurement,
             @LineOfSight int lineOfSight, @MeasurementFocus int measurementFocus,
             @IntRange(from = RSSI_UNKNOWN, to = RSSI_MAX) int rssiDbm,
+            long husPrimarySessionId,
             PersistableBundle rangingMeasurementMetadata) {
         mRemoteDeviceAddress = remoteDeviceAddress;
         mStatus = status;
@@ -70,6 +78,7 @@ public final class RangingMeasurement implements Parcelable {
         mLineOfSight = lineOfSight;
         mMeasurementFocus = measurementFocus;
         mRssiDbm = rssiDbm;
+        mHusPrimarySessionId = husPrimarySessionId;
         mRangingMeasurementMetadata = rangingMeasurementMetadata;
     }
 
@@ -208,6 +217,25 @@ public final class RangingMeasurement implements Parcelable {
         return mRssiDbm;
     }
 
+    /**
+     * Gets the Hybrid UWB Session(HUS) Primary Session ID.
+     *
+     * <p>This API is only available on FIRA 3.0 compatible devices.</p>
+     *
+     * <p>This field contains the Session ID of the HUS Primary Session. It is applicable only
+     * if the session type is part of Hybrid UWB Scheduling (HUS).</p>
+     *
+     * <p>If the UWB session is <b>not</b> part of Hybrid UWB Scheduling, this field will be
+     * {@link #NON_HYBRID_UWB_SESSION_ID}.</p>
+     *
+     * @return The primary session ID for the Hybrid UWB Session (HUS).
+     * @see Flags#FLAG_UWB_FIRA_3_0_25Q4
+     */
+    @FlaggedApi(Flags.FLAG_UWB_FIRA_3_0_25Q4)
+    public long getHusPrimarySessionId() {
+        return mHusPrimarySessionId;
+    }
+
     /**
      * @hide
      */
@@ -272,6 +300,9 @@ public final class RangingMeasurement implements Parcelable {
 
         if (obj instanceof RangingMeasurement) {
             RangingMeasurement other = (RangingMeasurement) obj;
+            boolean isHusPrimarySessionIdEqual = !Flags.uwbFira3025q4()
+                    || (mHusPrimarySessionId == other.getHusPrimarySessionId());
+
             return Objects.equals(mRemoteDeviceAddress, other.getRemoteDeviceAddress())
                     && mStatus == other.getStatus()
                     && mElapsedRealtimeNanos == other.getElapsedRealtimeNanos()
@@ -284,6 +315,7 @@ public final class RangingMeasurement implements Parcelable {
                     && mLineOfSight == other.getLineOfSight()
                     && mMeasurementFocus == other.getMeasurementFocus()
                     && mRssiDbm == other.getRssiDbm()
+                    && isHusPrimarySessionIdEqual
                     && PersistableBundleUtils.isEqual(mRangingMeasurementMetadata,
                     other.mRangingMeasurementMetadata);
         }
@@ -298,7 +330,8 @@ public final class RangingMeasurement implements Parcelable {
         return Objects.hash(mRemoteDeviceAddress, mStatus, mElapsedRealtimeNanos,
                 mDistanceMeasurement, mAngleOfArrivalMeasurement,
                 mDestinationAngleOfArrivalMeasurement, mLineOfSight, mMeasurementFocus, mRssiDbm,
-                PersistableBundleUtils.getHashCode(mRangingMeasurementMetadata));
+                mHusPrimarySessionId, PersistableBundleUtils.getHashCode(
+                    mRangingMeasurementMetadata));
     }
 
     @Override
@@ -317,6 +350,7 @@ public final class RangingMeasurement implements Parcelable {
         dest.writeInt(mLineOfSight);
         dest.writeInt(mMeasurementFocus);
         dest.writeInt(mRssiDbm);
+        dest.writeLong(mHusPrimarySessionId);
         dest.writePersistableBundle(mRangingMeasurementMetadata);
     }
 
@@ -338,6 +372,7 @@ public final class RangingMeasurement implements Parcelable {
                     builder.setLineOfSight(in.readInt());
                     builder.setMeasurementFocus(in.readInt());
                     builder.setRssiDbm(in.readInt());
+                    builder.setHusPrimarySessionId(in.readLong());
                     PersistableBundle metadata =
                             in.readPersistableBundle(getClass().getClassLoader());
                     if (metadata != null) builder.setRangingMeasurementMetadata(metadata);
@@ -361,6 +396,7 @@ public final class RangingMeasurement implements Parcelable {
                 + ", lineOfSight: " + mLineOfSight
                 + ", measurementFocus: " + mMeasurementFocus
                 + ", rssiDbm: " + mRssiDbm
+                + ", husPrimarySessionId: " + mHusPrimarySessionId
                 + ", ranging measurement metadata: " + mRangingMeasurementMetadata
                 + ", elapsed real time nanos: " + mElapsedRealtimeNanos
                 + ", status: " + mStatus
@@ -380,6 +416,7 @@ public final class RangingMeasurement implements Parcelable {
         private @LineOfSight int mLineOfSight = LOS_UNDETERMINED;
         private @MeasurementFocus int mMeasurementFocus = MEASUREMENT_FOCUS_NONE;
         private int mRssiDbm = RSSI_UNKNOWN;
+        private long mHusPrimarySessionId = NON_HYBRID_UWB_SESSION_ID;
         private PersistableBundle mRangingMeasurementMetadata = null;
 
         /**
@@ -491,6 +528,28 @@ public final class RangingMeasurement implements Parcelable {
             return this;
         }
 
+        /**
+         * Sets the Hybrid UWB Session (HUS) Primary Session ID.
+         *
+         * <p>This API is only available on FIRA 3.0 compatible devices.</p>
+         *
+         * <p>This field represents the Session ID of the HUS Primary Session and is applicable
+         * only when the session type is part of a Hybrid UWB Session.</p>
+         *
+         * <p>If the UWB session is <b>not</b> part of Hybrid UWB Scheduling, this field is set to
+         * {@link #NON_HYBRID_UWB_SESSION_ID}.</p>
+         *
+         * @param husPrimarySessionId The primary session ID for the Hybrid UWB Session (HUS).
+         * @return The updated {@link Builder} instance.
+         * @see Flags#FLAG_UWB_FIRA_3_0_25Q4
+         */
+        @NonNull
+        @FlaggedApi(Flags.FLAG_UWB_FIRA_3_0_25Q4)
+        public Builder setHusPrimarySessionId(long husPrimarySessionId) {
+            mHusPrimarySessionId = husPrimarySessionId;
+            return this;
+        }
+
         /**
          * Set Ranging measurement metadata
          *
@@ -544,7 +603,7 @@ public final class RangingMeasurement implements Parcelable {
             return new RangingMeasurement(mRemoteDeviceAddress, mStatus, mElapsedRealtimeNanos,
                     mDistanceMeasurement, mAngleOfArrivalMeasurement,
                     mDestinationAngleOfArrivalMeasurement, mLineOfSight, mMeasurementFocus,
-                    mRssiDbm, mRangingMeasurementMetadata);
+                    mRssiDbm, mHusPrimarySessionId, mRangingMeasurementMetadata);
         }
     }
 }
diff --git a/framework/java/android/uwb/UwbOemExtensionCallbackListener.java b/framework/java/android/uwb/UwbOemExtensionCallbackListener.java
index 1160f916..62ffbbab 100644
--- a/framework/java/android/uwb/UwbOemExtensionCallbackListener.java
+++ b/framework/java/android/uwb/UwbOemExtensionCallbackListener.java
@@ -91,11 +91,15 @@ public final class UwbOemExtensionCallbackListener extends IUwbOemExtensionCallb
             if (mCallback == null || mExecutor == null) {
                 return;
             }
+            UwbManager.UwbOemExtensionCallback callback;
+            Executor executor;
             final long identity = Binder.clearCallingIdentity();
             try {
+                callback = mCallback;
+                executor = mExecutor;
                 if (SdkLevel.isAtLeastU()) {
-                    mExecutor.execute(() ->
-                            mCallback.onSessionStatusNotificationReceived(sessionStatusBundle));
+                    executor.execute(() ->
+                            callback.onSessionStatusNotificationReceived(sessionStatusBundle));
                 }
             } finally {
                 Binder.restoreCallingIdentity(identity);
diff --git a/framework/tests/src/android/uwb/UwbVendorUciCallbackListenerTest.java b/framework/tests/src/android/uwb/UwbVendorUciCallbackListenerTest.java
index e94f0258..d1a97e26 100644
--- a/framework/tests/src/android/uwb/UwbVendorUciCallbackListenerTest.java
+++ b/framework/tests/src/android/uwb/UwbVendorUciCallbackListenerTest.java
@@ -25,7 +25,6 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 
 import android.os.RemoteException;
 import android.uwb.UwbManager.UwbVendorUciCallback;
@@ -140,7 +139,7 @@ public class UwbVendorUciCallbackListenerTest {
         // Register first callback
         mUwbVendorUciCallbackListener.register(EXECUTOR, mUwbVendorUciCallback);
         verify(mUwbVendorUciCallback, times(1)).onVendorUciResponse(GID, OID, PAYLOAD);
-        verifyZeroInteractions(mUwbVendorUciCallback2);
+        verifyNoMoreInteractions(mUwbVendorUciCallback2);
         // Register second callback
         mUwbVendorUciCallbackListener.register(EXECUTOR, mUwbVendorUciCallback2);
         verify(mUwbVendorUciCallback, times(1)).onVendorUciResponse(GID, OID, PAYLOAD);
@@ -191,7 +190,7 @@ public class UwbVendorUciCallbackListenerTest {
         // Register first callback
         mUwbVendorUciCallbackListener.register(EXECUTOR, mUwbVendorUciCallback);
         verify(mUwbVendorUciCallback, times(1)).onVendorUciNotification(GID, OID, PAYLOAD);
-        verifyZeroInteractions(mUwbVendorUciCallback2);
+        verifyNoMoreInteractions(mUwbVendorUciCallback2);
         // Register second callback
         mUwbVendorUciCallbackListener.register(EXECUTOR, mUwbVendorUciCallback2);
         verify(mUwbVendorUciCallback, times(1)).onVendorUciNotification(GID, OID, PAYLOAD);
diff --git a/ranging/flags/ranging_flags.aconfig b/ranging/flags/ranging_flags.aconfig
index d9b44742..b3743afd 100644
--- a/ranging/flags/ranging_flags.aconfig
+++ b/ranging/flags/ranging_flags.aconfig
@@ -23,4 +23,12 @@ flag {
     namespace: "uwb"
     description: "This flags controls channel sounding in generic ranging"
     bug: "331206299"
-}
\ No newline at end of file
+}
+
+flag {
+    name: "ranging_stack_updates_25q4"
+    is_exported: true
+    namespace: "uwb"
+    description: "This flags controls updates to ranging stack for 25Q4"
+    bug: "398835649"
+}
diff --git a/ranging/framework/Android.bp b/ranging/framework/Android.bp
index 56224f23..c854f4a6 100644
--- a/ranging/framework/Android.bp
+++ b/ranging/framework/Android.bp
@@ -19,7 +19,7 @@ package {
 
 java_defaults {
     name: "ranging-module-sdk-version-defaults",
-    min_sdk_version: "current",
+    min_sdk_version: "35",
 }
 
 filegroup {
@@ -62,6 +62,7 @@ java_defaults {
     libs: [
         "androidx.annotation_annotation",
         "framework-bluetooth.stubs.module_lib",
+        "framework-wifi.stubs.module_lib",
         "unsupportedappusage", // for android.compat.annotation.UnsupportedAppUsage
     ],
     srcs: [
@@ -110,6 +111,7 @@ java_sdk_library {
         // Created by jarjar rules.
         "com.android.x.ranging",
     ],
+    min_sdk_version: "36",
 }
 
 // defaults for tests that need to build against framework-ranging's @hide APIs
@@ -119,10 +121,10 @@ java_defaults {
     libs: [
         "framework-ranging.impl",
     ],
-    //defaults_visibility: [
-    // "//packages/modules/Uwb/framework/tests:__subpackages__",
-    // "//packages/modules/Uwb/service/tests:__subpackages__",
-    //],
+    defaults_visibility: [
+        "//packages/modules/Uwb/ranging/framework/tests:__subpackages__",
+        "//packages/modules/Uwb/ranging/service/tests:__subpackages__",
+    ],
 }
 
 filegroup {
diff --git a/ranging/framework/api/current.txt b/ranging/framework/api/current.txt
index 2f546c3c..dfd28cae 100644
--- a/ranging/framework/api/current.txt
+++ b/ranging/framework/api/current.txt
@@ -4,27 +4,27 @@ package android.ranging {
   @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class DataNotificationConfig implements android.os.Parcelable {
     method public int describeContents();
     method public int getNotificationConfigType();
-    method public int getProximityFarCm();
-    method public int getProximityNearCm();
+    method @IntRange(from=0, to=20000) public int getProximityFarCm();
+    method @IntRange(from=0, to=20000) public int getProximityNearCm();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
     field @NonNull public static final android.os.Parcelable.Creator<android.ranging.DataNotificationConfig> CREATOR;
-    field public static final int DISABLE = 0; // 0x0
-    field public static final int ENABLE = 1; // 0x1
-    field public static final int PROXIMITY_EDGE = 3; // 0x3
-    field public static final int PROXIMITY_LEVEL = 2; // 0x2
+    field public static final int NOTIFICATION_CONFIG_DISABLE = 0; // 0x0
+    field public static final int NOTIFICATION_CONFIG_ENABLE = 1; // 0x1
+    field public static final int NOTIFICATION_CONFIG_PROXIMITY_EDGE = 3; // 0x3
+    field public static final int NOTIFICATION_CONFIG_PROXIMITY_LEVEL = 2; // 0x2
   }
 
   public static final class DataNotificationConfig.Builder {
     ctor public DataNotificationConfig.Builder();
     method @NonNull public android.ranging.DataNotificationConfig build();
     method @NonNull public android.ranging.DataNotificationConfig.Builder setNotificationConfigType(int);
-    method @NonNull public android.ranging.DataNotificationConfig.Builder setProximityFarCm(int);
-    method @NonNull public android.ranging.DataNotificationConfig.Builder setProximityNearCm(int);
+    method @NonNull public android.ranging.DataNotificationConfig.Builder setProximityFarCm(@IntRange(from=0, to=20000) int);
+    method @NonNull public android.ranging.DataNotificationConfig.Builder setProximityNearCm(@IntRange(from=0, to=20000) int);
   }
 
   @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingCapabilities implements android.os.Parcelable {
     method public int describeContents();
-    method @Nullable public android.ranging.ble.cs.CsRangingCapabilities getCsCapabilities();
+    method @Nullable public android.ranging.ble.cs.BleCsRangingCapabilities getCsCapabilities();
     method @Nullable public android.ranging.wifi.rtt.RttRangingCapabilities getRttRangingCapabilities();
     method @NonNull public java.util.Map<java.lang.Integer,java.lang.Integer> getTechnologyAvailability();
     method @Nullable public android.ranging.uwb.UwbRangingCapabilities getUwbCapabilities();
@@ -37,6 +37,13 @@ package android.ranging {
     field public static final int NOT_SUPPORTED = 0; // 0x0
   }
 
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public abstract class RangingConfig implements android.os.Parcelable {
+    ctor protected RangingConfig();
+    method public int getRangingSessionType();
+    field public static final int RANGING_SESSION_OOB = 1; // 0x1
+    field public static final int RANGING_SESSION_RAW = 0; // 0x0
+  }
+
   @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingData implements android.os.Parcelable {
     method public int describeContents();
     method @Nullable public android.ranging.RangingMeasurement getAzimuth();
@@ -88,18 +95,11 @@ package android.ranging {
     field @NonNull public static final android.os.Parcelable.Creator<android.ranging.RangingMeasurement> CREATOR;
   }
 
-  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public abstract class RangingParams implements android.os.Parcelable {
-    ctor protected RangingParams();
-    method public int getRangingSessionType();
-    field public static final int RANGING_SESSION_OOB = 1; // 0x1
-    field public static final int RANGING_SESSION_RAW = 0; // 0x0
-  }
-
   @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingPreference implements android.os.Parcelable {
     method public int describeContents();
     method public int getDeviceRole();
-    method @Nullable public android.ranging.RangingParams getRangingParameters();
-    method @NonNull public android.ranging.SessionConfiguration getSessionConfiguration();
+    method @Nullable public android.ranging.RangingConfig getRangingParams();
+    method @NonNull public android.ranging.SessionConfig getSessionConfig();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
     field @NonNull public static final android.os.Parcelable.Creator<android.ranging.RangingPreference> CREATOR;
     field public static final int DEVICE_ROLE_INITIATOR = 1; // 0x1
@@ -107,13 +107,13 @@ package android.ranging {
   }
 
   public static final class RangingPreference.Builder {
-    ctor public RangingPreference.Builder(int, @NonNull android.ranging.RangingParams);
+    ctor public RangingPreference.Builder(int, @NonNull android.ranging.RangingConfig);
     method @NonNull public android.ranging.RangingPreference build();
-    method @NonNull public android.ranging.RangingPreference.Builder setSessionConfiguration(@NonNull android.ranging.SessionConfiguration);
+    method @NonNull public android.ranging.RangingPreference.Builder setSessionConfig(@NonNull android.ranging.SessionConfig);
   }
 
   @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingSession implements java.lang.AutoCloseable {
-    method @RequiresPermission(android.Manifest.permission.RANGING) public void addDeviceToRangingSession(@NonNull android.ranging.RangingParams);
+    method @RequiresPermission(android.Manifest.permission.RANGING) public void addDeviceToRangingSession(@NonNull android.ranging.RangingConfig);
     method @RequiresPermission(android.Manifest.permission.RANGING) public void close();
     method @RequiresPermission(android.Manifest.permission.RANGING) public void reconfigureRangingInterval(@IntRange(from=0, to=255) int);
     method @RequiresPermission(android.Manifest.permission.RANGING) public void removeDeviceFromRangingSession(@NonNull android.ranging.RangingDevice);
@@ -149,39 +149,39 @@ package android.ranging {
     method @NonNull public android.ranging.SensorFusionParams.Builder setSensorFusionEnabled(boolean);
   }
 
-  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class SessionConfiguration implements android.os.Parcelable {
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class SessionConfig implements android.os.Parcelable {
     method public int describeContents();
     method @NonNull public android.ranging.DataNotificationConfig getDataNotificationConfig();
     method @IntRange(from=0, to=65535) public int getRangingMeasurementsLimit();
-    method @NonNull public android.ranging.SensorFusionParams getSensorFusionParameters();
+    method @NonNull public android.ranging.SensorFusionParams getSensorFusionParams();
     method public boolean isAngleOfArrivalNeeded();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
-    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.SessionConfiguration> CREATOR;
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.SessionConfig> CREATOR;
   }
 
-  public static final class SessionConfiguration.Builder {
-    ctor public SessionConfiguration.Builder();
-    method @NonNull public android.ranging.SessionConfiguration build();
-    method @NonNull public android.ranging.SessionConfiguration.Builder setAngleOfArrivalNeeded(boolean);
-    method @NonNull public android.ranging.SessionConfiguration.Builder setDataNotificationConfig(@NonNull android.ranging.DataNotificationConfig);
-    method @NonNull public android.ranging.SessionConfiguration.Builder setRangingMeasurementsLimit(@IntRange(from=0, to=65535) int);
-    method @NonNull public android.ranging.SessionConfiguration.Builder setSensorFusionParameters(@NonNull android.ranging.SensorFusionParams);
+  public static final class SessionConfig.Builder {
+    ctor public SessionConfig.Builder();
+    method @NonNull public android.ranging.SessionConfig build();
+    method @NonNull public android.ranging.SessionConfig.Builder setAngleOfArrivalNeeded(boolean);
+    method @NonNull public android.ranging.SessionConfig.Builder setDataNotificationConfig(@NonNull android.ranging.DataNotificationConfig);
+    method @NonNull public android.ranging.SessionConfig.Builder setRangingMeasurementsLimit(@IntRange(from=0, to=65535) int);
+    method @NonNull public android.ranging.SessionConfig.Builder setSensorFusionParams(@NonNull android.ranging.SensorFusionParams);
   }
 
 }
 
 package android.ranging.ble.cs {
 
-  @FlaggedApi("com.android.ranging.flags.ranging_cs_enabled") public final class CsRangingCapabilities implements android.os.Parcelable {
+  @FlaggedApi("com.android.ranging.flags.ranging_cs_enabled") public final class BleCsRangingCapabilities implements android.os.Parcelable {
     method public int describeContents();
     method @NonNull public java.util.Set<java.lang.Integer> getSupportedSecurityLevels();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
-    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.ble.cs.CsRangingCapabilities> CREATOR;
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.ble.cs.BleCsRangingCapabilities> CREATOR;
     field public static final int CS_SECURITY_LEVEL_FOUR = 4; // 0x4
     field public static final int CS_SECURITY_LEVEL_ONE = 1; // 0x1
   }
 
-  @FlaggedApi("com.android.ranging.flags.ranging_cs_enabled") public final class CsRangingParams implements android.os.Parcelable {
+  @FlaggedApi("com.android.ranging.flags.ranging_cs_enabled") public final class BleCsRangingParams implements android.os.Parcelable {
     method public int describeContents();
     method public int getLocationType();
     method @NonNull public String getPeerBluetoothAddress();
@@ -189,7 +189,7 @@ package android.ranging.ble.cs {
     method public int getSecurityLevel();
     method public int getSightType();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
-    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.ble.cs.CsRangingParams> CREATOR;
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.ble.cs.BleCsRangingParams> CREATOR;
     field public static final int LOCATION_TYPE_INDOOR = 1; // 0x1
     field public static final int LOCATION_TYPE_OUTDOOR = 2; // 0x2
     field public static final int LOCATION_TYPE_UNKNOWN = 0; // 0x0
@@ -198,13 +198,13 @@ package android.ranging.ble.cs {
     field public static final int SIGHT_TYPE_UNKNOWN = 0; // 0x0
   }
 
-  public static final class CsRangingParams.Builder {
-    ctor public CsRangingParams.Builder(@NonNull String);
-    method @NonNull public android.ranging.ble.cs.CsRangingParams build();
-    method @NonNull public android.ranging.ble.cs.CsRangingParams.Builder setLocationType(int);
-    method @NonNull public android.ranging.ble.cs.CsRangingParams.Builder setRangingUpdateRate(int);
-    method @NonNull public android.ranging.ble.cs.CsRangingParams.Builder setSecurityLevel(int);
-    method @NonNull public android.ranging.ble.cs.CsRangingParams.Builder setSightType(int);
+  public static final class BleCsRangingParams.Builder {
+    ctor public BleCsRangingParams.Builder(@NonNull String);
+    method @NonNull public android.ranging.ble.cs.BleCsRangingParams build();
+    method @NonNull public android.ranging.ble.cs.BleCsRangingParams.Builder setLocationType(int);
+    method @NonNull public android.ranging.ble.cs.BleCsRangingParams.Builder setRangingUpdateRate(int);
+    method @NonNull public android.ranging.ble.cs.BleCsRangingParams.Builder setSecurityLevel(int);
+    method @NonNull public android.ranging.ble.cs.BleCsRangingParams.Builder setSightType(int);
   }
 
 }
@@ -242,7 +242,7 @@ package android.ranging.oob {
     method @NonNull public android.ranging.oob.DeviceHandle build();
   }
 
-  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class OobInitiatorRangingParams extends android.ranging.RangingParams implements android.os.Parcelable {
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class OobInitiatorRangingConfig extends android.ranging.RangingConfig implements android.os.Parcelable {
     method public int describeContents();
     method @NonNull public java.util.List<android.ranging.oob.DeviceHandle> getDeviceHandles();
     method @NonNull public java.time.Duration getFastestRangingInterval();
@@ -251,7 +251,7 @@ package android.ranging.oob {
     method public int getSecurityLevel();
     method @NonNull public java.time.Duration getSlowestRangingInterval();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
-    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.oob.OobInitiatorRangingParams> CREATOR;
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.oob.OobInitiatorRangingConfig> CREATOR;
     field public static final int RANGING_MODE_AUTO = 0; // 0x0
     field public static final int RANGING_MODE_FUSED = 3; // 0x3
     field public static final int RANGING_MODE_HIGH_ACCURACY = 1; // 0x1
@@ -260,26 +260,27 @@ package android.ranging.oob {
     field public static final int SECURITY_LEVEL_SECURE = 1; // 0x1
   }
 
-  public static final class OobInitiatorRangingParams.Builder {
-    ctor public OobInitiatorRangingParams.Builder();
-    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder addDeviceHandle(@NonNull android.ranging.oob.DeviceHandle);
-    method @NonNull public android.ranging.oob.OobInitiatorRangingParams build();
-    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder setFastestRangingInterval(@NonNull java.time.Duration);
-    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder setRangingMode(int);
-    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder setSecurityLevel(int);
-    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder setSlowestRangingInterval(@NonNull java.time.Duration);
+  public static final class OobInitiatorRangingConfig.Builder {
+    ctor public OobInitiatorRangingConfig.Builder();
+    method @NonNull public android.ranging.oob.OobInitiatorRangingConfig.Builder addDeviceHandle(@NonNull android.ranging.oob.DeviceHandle);
+    method @NonNull public android.ranging.oob.OobInitiatorRangingConfig.Builder addDeviceHandles(@NonNull java.util.List<android.ranging.oob.DeviceHandle>);
+    method @NonNull public android.ranging.oob.OobInitiatorRangingConfig build();
+    method @NonNull public android.ranging.oob.OobInitiatorRangingConfig.Builder setFastestRangingInterval(@NonNull java.time.Duration);
+    method @NonNull public android.ranging.oob.OobInitiatorRangingConfig.Builder setRangingMode(int);
+    method @NonNull public android.ranging.oob.OobInitiatorRangingConfig.Builder setSecurityLevel(int);
+    method @NonNull public android.ranging.oob.OobInitiatorRangingConfig.Builder setSlowestRangingInterval(@NonNull java.time.Duration);
   }
 
-  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class OobResponderRangingParams extends android.ranging.RangingParams implements android.os.Parcelable {
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class OobResponderRangingConfig extends android.ranging.RangingConfig implements android.os.Parcelable {
     method public int describeContents();
     method @NonNull public android.ranging.oob.DeviceHandle getDeviceHandle();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
-    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.oob.OobResponderRangingParams> CREATOR;
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.oob.OobResponderRangingConfig> CREATOR;
   }
 
-  public static final class OobResponderRangingParams.Builder {
-    ctor public OobResponderRangingParams.Builder(@NonNull android.ranging.oob.DeviceHandle);
-    method @NonNull public android.ranging.oob.OobResponderRangingParams build();
+  public static final class OobResponderRangingConfig.Builder {
+    ctor public OobResponderRangingConfig.Builder(@NonNull android.ranging.oob.DeviceHandle);
+    method @NonNull public android.ranging.oob.OobResponderRangingConfig build();
   }
 
   @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public interface TransportHandle extends java.lang.AutoCloseable {
@@ -299,23 +300,24 @@ package android.ranging.oob {
 
 package android.ranging.raw {
 
-  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RawInitiatorRangingParams extends android.ranging.RangingParams implements android.os.Parcelable {
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RawInitiatorRangingConfig extends android.ranging.RangingConfig implements android.os.Parcelable {
     method public int describeContents();
     method @NonNull public java.util.List<android.ranging.raw.RawRangingDevice> getRawRangingDevices();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
-    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.raw.RawInitiatorRangingParams> CREATOR;
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.raw.RawInitiatorRangingConfig> CREATOR;
   }
 
-  public static final class RawInitiatorRangingParams.Builder {
-    ctor public RawInitiatorRangingParams.Builder();
-    method @NonNull public android.ranging.raw.RawInitiatorRangingParams.Builder addRawRangingDevice(@NonNull android.ranging.raw.RawRangingDevice);
-    method @NonNull public android.ranging.raw.RawInitiatorRangingParams build();
+  public static final class RawInitiatorRangingConfig.Builder {
+    ctor public RawInitiatorRangingConfig.Builder();
+    method @NonNull public android.ranging.raw.RawInitiatorRangingConfig.Builder addRawRangingDevice(@NonNull android.ranging.raw.RawRangingDevice);
+    method @NonNull public android.ranging.raw.RawInitiatorRangingConfig.Builder addRawRangingDevices(@NonNull java.util.List<android.ranging.raw.RawRangingDevice>);
+    method @NonNull public android.ranging.raw.RawInitiatorRangingConfig build();
   }
 
   @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RawRangingDevice implements android.os.Parcelable {
     method public int describeContents();
     method @Nullable public android.ranging.ble.rssi.BleRssiRangingParams getBleRssiRangingParams();
-    method @Nullable public android.ranging.ble.cs.CsRangingParams getCsRangingParams();
+    method @Nullable public android.ranging.ble.cs.BleCsRangingParams getCsRangingParams();
     method @NonNull public android.ranging.RangingDevice getRangingDevice();
     method @Nullable public android.ranging.wifi.rtt.RttRangingParams getRttRangingParams();
     method @Nullable public android.ranging.uwb.UwbRangingParams getUwbRangingParams();
@@ -330,23 +332,23 @@ package android.ranging.raw {
     ctor public RawRangingDevice.Builder();
     method @NonNull public android.ranging.raw.RawRangingDevice build();
     method @NonNull public android.ranging.raw.RawRangingDevice.Builder setBleRssiRangingParams(@NonNull android.ranging.ble.rssi.BleRssiRangingParams);
-    method @NonNull public android.ranging.raw.RawRangingDevice.Builder setCsRangingParams(@NonNull android.ranging.ble.cs.CsRangingParams);
+    method @NonNull public android.ranging.raw.RawRangingDevice.Builder setCsRangingParams(@NonNull android.ranging.ble.cs.BleCsRangingParams);
     method @NonNull public android.ranging.raw.RawRangingDevice.Builder setRangingDevice(@NonNull android.ranging.RangingDevice);
     method @NonNull public android.ranging.raw.RawRangingDevice.Builder setRttRangingParams(@NonNull android.ranging.wifi.rtt.RttRangingParams);
     method @NonNull public android.ranging.raw.RawRangingDevice.Builder setUwbRangingParams(@NonNull android.ranging.uwb.UwbRangingParams);
   }
 
-  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RawResponderRangingParams extends android.ranging.RangingParams implements android.os.Parcelable {
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RawResponderRangingConfig extends android.ranging.RangingConfig implements android.os.Parcelable {
     method public int describeContents();
     method @NonNull public android.ranging.raw.RawRangingDevice getRawRangingDevice();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
-    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.raw.RawResponderRangingParams> CREATOR;
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.raw.RawResponderRangingConfig> CREATOR;
   }
 
-  public static final class RawResponderRangingParams.Builder {
-    ctor public RawResponderRangingParams.Builder();
-    method @NonNull public android.ranging.raw.RawResponderRangingParams build();
-    method @NonNull public android.ranging.raw.RawResponderRangingParams.Builder setRawRangingDevice(@NonNull android.ranging.raw.RawRangingDevice);
+  public static final class RawResponderRangingConfig.Builder {
+    ctor public RawResponderRangingConfig.Builder();
+    method @NonNull public android.ranging.raw.RawResponderRangingConfig build();
+    method @NonNull public android.ranging.raw.RawResponderRangingConfig.Builder setRawRangingDevice(@NonNull android.ranging.raw.RawRangingDevice);
   }
 
 }
@@ -354,10 +356,10 @@ package android.ranging.raw {
 package android.ranging.uwb {
 
   @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class UwbAddress implements android.os.Parcelable {
+    method @NonNull public static android.ranging.uwb.UwbAddress createRandomShortAddress();
     method public int describeContents();
     method @NonNull public static android.ranging.uwb.UwbAddress fromBytes(@NonNull byte[]);
     method @NonNull public byte[] getAddressBytes();
-    method @NonNull public static android.ranging.uwb.UwbAddress getRandomShortAddress();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
     field @NonNull public static final android.os.Parcelable.Creator<android.ranging.uwb.UwbAddress> CREATOR;
     field public static final int EXTENDED_ADDRESS_BYTE_LENGTH = 8; // 0x8
@@ -459,7 +461,7 @@ package android.ranging.wifi.rtt {
 
   @FlaggedApi("com.android.ranging.flags.ranging_rtt_enabled") public final class RttRangingCapabilities implements android.os.Parcelable {
     method public int describeContents();
-    method public boolean hasPeriodicRangingHwFeature();
+    method public boolean hasPeriodicRangingHardwareFeature();
     method public void writeToParcel(@NonNull android.os.Parcel, int);
     field @NonNull public static final android.os.Parcelable.Creator<android.ranging.wifi.rtt.RttRangingCapabilities> CREATOR;
   }
diff --git a/ranging/framework/jarjar-rules.txt b/ranging/framework/jarjar-rules.txt
index bcec79bf..ecd04603 100644
--- a/ranging/framework/jarjar-rules.txt
+++ b/ranging/framework/jarjar-rules.txt
@@ -5,5 +5,10 @@ rule com.android.modules.utils.** com.android.x.ranging.@0
 rule com.android.ranging.flags.** com.android.x.ranging.@0
 # Statically included UWB support lib and guava lib.
 rule com.google.common.** com.android.x.ranging.@0
+rule com.google.uwb.** com.android.x.ranging.@0
 # Included by support lib.
 rule com.android.internal.util.** com.android.x.ranging.@0
+# Statically linked third party library
+rule com.google.thirdparty.** com.android.x.ranging.@0
+# Statically included androidx.concurrent_concurrent-futures
+rule androidx.concurrent.futures.** com.android.x.ranging.@0
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/DataNotificationConfig.java b/ranging/framework/java/android/ranging/DataNotificationConfig.java
index caef9f12..288a8b55 100644
--- a/ranging/framework/java/android/ranging/DataNotificationConfig.java
+++ b/ranging/framework/java/android/ranging/DataNotificationConfig.java
@@ -18,6 +18,7 @@ package android.ranging;
 
 import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
+import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.os.Parcel;
 import android.os.Parcelable;
@@ -26,6 +27,7 @@ import com.android.ranging.flags.Flags;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Objects;
 
 /**
  * Represents the configuration for data notifications in ranging operations.
@@ -76,23 +78,23 @@ public final class DataNotificationConfig implements Parcelable {
      */
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({
-            DISABLE,
-            ENABLE,
-            PROXIMITY_LEVEL,
-            PROXIMITY_EDGE,
+            NOTIFICATION_CONFIG_DISABLE,
+            NOTIFICATION_CONFIG_ENABLE,
+            NOTIFICATION_CONFIG_PROXIMITY_LEVEL,
+            NOTIFICATION_CONFIG_PROXIMITY_EDGE,
     })
     public @interface NotificationConfigType {
     }
 
     // Range data notification will be disabled.
-    public static final int DISABLE = 0;
+    public static final int NOTIFICATION_CONFIG_DISABLE = 0;
     // Range data notification will be enabled (default).
-    public static final int ENABLE = 1;
+    public static final int NOTIFICATION_CONFIG_ENABLE = 1;
     // Range data notification is enabled when peer device is in the configured range - [near, far].
-    public static final int PROXIMITY_LEVEL = 2;
+    public static final int NOTIFICATION_CONFIG_PROXIMITY_LEVEL = 2;
     //Range data notification is enabled when peer device enters or exits the configured range -
     // [near, far].
-    public static final int PROXIMITY_EDGE = 3;
+    public static final int NOTIFICATION_CONFIG_PROXIMITY_EDGE = 3;
 
 
     private DataNotificationConfig(Builder builder) {
@@ -121,6 +123,7 @@ public final class DataNotificationConfig implements Parcelable {
      *
      * @return the near proximity in centimeters.
      */
+    @IntRange(from = 0, to = 20000)
     public int getProximityNearCm() {
         return mProximityNearCm;
     }
@@ -130,6 +133,7 @@ public final class DataNotificationConfig implements Parcelable {
      *
      * @return the far proximity in centimeters.
      */
+    @IntRange(from = 0, to = 20000)
     public int getProximityFarCm() {
         return mProximityFarCm;
     }
@@ -137,13 +141,13 @@ public final class DataNotificationConfig implements Parcelable {
     /** Builder for {@link DataNotificationConfig} */
     public static final class Builder {
         @NotificationConfigType
-        private int mNotificationConfigType = ENABLE;
+        private int mNotificationConfigType = NOTIFICATION_CONFIG_ENABLE;
         private int mProximityNearCm = 0;
         private int mProximityFarCm = 20_000;
 
         /**
          * Sets the notification configuration type.
-         *  <p> defaults to {@link NotificationConfigType#ENABLE}
+         *  <p> defaults to {@link NotificationConfigType#NOTIFICATION_CONFIG_ENABLE}
          *
          * @param config The notification configuration type to set.
          * @return this Builder instance.
@@ -162,7 +166,7 @@ public final class DataNotificationConfig implements Parcelable {
          * @return this Builder instance.
          */
         @NonNull
-        public Builder setProximityNearCm(int proximityCm) {
+        public Builder setProximityNearCm(@IntRange(from = 0, to = 20000) int proximityCm) {
             mProximityNearCm = proximityCm;
             return this;
         }
@@ -175,7 +179,7 @@ public final class DataNotificationConfig implements Parcelable {
          * @return this Builder instance.
          */
         @NonNull
-        public Builder setProximityFarCm(int proximityCm) {
+        public Builder setProximityFarCm(@IntRange(from = 0, to = 20000) int proximityCm) {
             mProximityFarCm = proximityCm;
             return this;
         }
@@ -203,4 +207,24 @@ public final class DataNotificationConfig implements Parcelable {
                 + mProximityFarCm
                 + " }";
     }
+
+    /**
+     * @hide
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof DataNotificationConfig that)) return false;
+        return mNotificationConfigType == that.mNotificationConfigType
+                && mProximityNearCm == that.mProximityNearCm
+                && mProximityFarCm == that.mProximityFarCm;
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int hashCode() {
+        return Objects.hash(mNotificationConfigType, mProximityNearCm, mProximityFarCm);
+    }
 }
diff --git a/ranging/framework/java/android/ranging/IRangingAdapter.aidl b/ranging/framework/java/android/ranging/IRangingAdapter.aidl
index 2c94381a..819d12bf 100644
--- a/ranging/framework/java/android/ranging/IRangingAdapter.aidl
+++ b/ranging/framework/java/android/ranging/IRangingAdapter.aidl
@@ -22,10 +22,10 @@ import android.ranging.IRangingCallbacks;
 import android.ranging.SessionHandle;
 import android.ranging.RangingPreference;
 import android.ranging.RangingDevice;
-import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.raw.RawResponderRangingConfig;
 import android.ranging.oob.OobHandle;
 import android.ranging.oob.IOobSendDataListener;
-import android.ranging.oob.OobResponderRangingParams;
+import android.ranging.oob.OobResponderRangingConfig;
 
 /**
 *  @hide
@@ -37,9 +37,9 @@ interface IRangingAdapter {
 
     void reconfigureRangingInterval(in SessionHandle sessionHandle, int intervalSkipCount);
 
-    void addRawDevice(in SessionHandle sessionHandle, in RawResponderRangingParams rangingParams);
+    void addRawDevice(in SessionHandle sessionHandle, in RawResponderRangingConfig rangingConfig);
 
-    void addOobDevice(in SessionHandle sessionHandle, in OobResponderRangingParams rangingParams);
+    void addOobDevice(in SessionHandle sessionHandle, in OobResponderRangingConfig rangingConfig);
 
     void removeDevice(in SessionHandle sessionHandle, in RangingDevice rangingDevice);
 
diff --git a/ranging/framework/java/android/ranging/RangingCapabilities.java b/ranging/framework/java/android/ranging/RangingCapabilities.java
index daa83431..8ff81b74 100644
--- a/ranging/framework/java/android/ranging/RangingCapabilities.java
+++ b/ranging/framework/java/android/ranging/RangingCapabilities.java
@@ -23,7 +23,8 @@ import android.annotation.Nullable;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.ranging.RangingManager.RangingTechnology;
-import android.ranging.ble.cs.CsRangingCapabilities;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
+import android.ranging.ble.rssi.BleRssiRangingCapabilities;
 import android.ranging.uwb.UwbRangingCapabilities;
 import android.ranging.wifi.rtt.RttRangingCapabilities;
 
@@ -64,7 +65,10 @@ public final class RangingCapabilities implements Parcelable {
     private final RttRangingCapabilities mRttRangingCapabilities;
 
     @Nullable
-    private final CsRangingCapabilities mCsCapabilities;
+    private final BleCsRangingCapabilities mCsCapabilities;
+
+    @Nullable
+    private final BleRssiRangingCapabilities mBleRssiCapabilities;
 
     /**
      * @hide
@@ -119,7 +123,10 @@ public final class RangingCapabilities implements Parcelable {
                 (UwbRangingCapabilities) builder.mCapabilities.get(RangingManager.UWB);
         mRttRangingCapabilities = (RttRangingCapabilities) builder.mCapabilities.get(
                 RangingManager.WIFI_NAN_RTT);
-        mCsCapabilities = (CsRangingCapabilities) builder.mCapabilities.get(RangingManager.BLE_CS);
+        mCsCapabilities = (BleCsRangingCapabilities) builder.mCapabilities.get(
+                RangingManager.BLE_CS);
+        mBleRssiCapabilities = (BleRssiRangingCapabilities) builder.mCapabilities.get(
+                RangingManager.BLE_RSSI);
         mAvailabilities = builder.mAvailabilities;
     }
 
@@ -130,7 +137,10 @@ public final class RangingCapabilities implements Parcelable {
         mRttRangingCapabilities = in.readParcelable(RttRangingCapabilities.class.getClassLoader(),
                 RttRangingCapabilities.class);
         mCsCapabilities = in.readParcelable(
-                CsRangingCapabilities.class.getClassLoader(), CsRangingCapabilities.class);
+                BleCsRangingCapabilities.class.getClassLoader(), BleCsRangingCapabilities.class);
+        mBleRssiCapabilities = in.readParcelable(
+                BleRssiRangingCapabilities.class.getClassLoader(),
+                BleRssiRangingCapabilities.class);
         int size = in.readInt();
         mAvailabilities = new HashMap<>(size);
         for (int i = 0; i < size; i++) {
@@ -192,13 +202,24 @@ public final class RangingCapabilities implements Parcelable {
     /**
      * Gets the BLE channel sounding ranging capabilities.
      *
-     * @return a {@link CsRangingCapabilities} object or {@code null} if not available.
+     * @return a {@link BleCsRangingCapabilities} object or {@code null} if not available.
      */
     @Nullable
-    public CsRangingCapabilities getCsCapabilities() {
+    public BleCsRangingCapabilities getCsCapabilities() {
         return mCsCapabilities;
     }
 
+    /**
+     * Gets the BLE RSSI ranging capabilities.
+     * This method is for internal use only-- BLE RSSI has no non-trivial capabilities.
+     *
+     * @hide
+     */
+    @Nullable
+    public BleRssiRangingCapabilities getBleRssiCapabilities() {
+        return mBleRssiCapabilities;
+    }
+
     @Override
     public int describeContents() {
         return 0;
@@ -209,6 +230,7 @@ public final class RangingCapabilities implements Parcelable {
         dest.writeParcelable(mUwbCapabilities, flags);
         dest.writeParcelable(mRttRangingCapabilities, flags);
         dest.writeParcelable(mCsCapabilities, flags);
+        dest.writeParcelable(mBleRssiCapabilities, flags);
         dest.writeInt(mAvailabilities.size()); // Write map size
         for (Map.Entry<Integer, Integer> entry : mAvailabilities.entrySet()) {
             dest.writeInt(entry.getKey()); // Write the key
@@ -251,6 +273,8 @@ public final class RangingCapabilities implements Parcelable {
                 + mRttRangingCapabilities
                 + ", mCsCapabilities="
                 + mCsCapabilities
+                + ", mBleRssiCapabilities="
+                + mBleRssiCapabilities
                 + ", mAvailabilities="
                 + mAvailabilities
                 + " }";
diff --git a/ranging/framework/java/android/ranging/RangingParams.java b/ranging/framework/java/android/ranging/RangingConfig.java
similarity index 79%
rename from ranging/framework/java/android/ranging/RangingParams.java
rename to ranging/framework/java/android/ranging/RangingConfig.java
index 4b6fc9da..0aae9046 100644
--- a/ranging/framework/java/android/ranging/RangingParams.java
+++ b/ranging/framework/java/android/ranging/RangingConfig.java
@@ -20,6 +20,10 @@ import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
 import android.annotation.SuppressLint;
 import android.os.Parcelable;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.oob.OobResponderRangingConfig;
+import android.ranging.raw.RawInitiatorRangingConfig;
+import android.ranging.raw.RawResponderRangingConfig;
 
 import com.android.ranging.flags.Flags;
 
@@ -27,19 +31,19 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
 /**
- * Abstract class to represent type of ranging parameters.
+ * Abstract class to represent type of ranging configuration.
  *
  * <p>Subclasses include:</p>
  * <ul>
- *     <li>{@link android.ranging.raw.RawResponderRangingParams}</li>
- *     <li>{@link android.ranging.raw.RawInitiatorRangingParams}</li>
- *     <li>{@link android.ranging.oob.OobResponderRangingParams}</li>
- *     <li>{@link android.ranging.oob.OobInitiatorRangingParams}</li>
+ *     <li>{@link RawResponderRangingConfig}</li>
+ *     <li>{@link RawInitiatorRangingConfig}</li>
+ *     <li>{@link OobResponderRangingConfig}</li>
+ *     <li>{@link OobInitiatorRangingConfig}</li>
  * </ul>
  */
 @FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
 @SuppressLint({"ParcelCreator", "ParcelNotFinal"})
-public abstract class RangingParams implements Parcelable {
+public abstract class RangingConfig implements Parcelable {
     /**
      * @hide
      */
@@ -51,7 +55,7 @@ public abstract class RangingParams implements Parcelable {
     public @interface RangingSessionType {
     }
 
-    protected RangingParams() { }
+    protected RangingConfig() { }
 
     /** Ranging session with the out-of-band negotiations performed by the app. */
     public static final int RANGING_SESSION_RAW = 0;
diff --git a/ranging/framework/java/android/ranging/RangingData.java b/ranging/framework/java/android/ranging/RangingData.java
index 58e5a7f8..5fd1fbce 100644
--- a/ranging/framework/java/android/ranging/RangingData.java
+++ b/ranging/framework/java/android/ranging/RangingData.java
@@ -43,6 +43,9 @@ public final class RangingData implements Parcelable {
     @Nullable private final RangingMeasurement mElevation;
     private final int mRssi;
     private final long mTimestamp;
+    private final double mDelaySpreadMeters;
+    private final /* @android.bluetooth.le.Nadm */ byte mDetectedAttackLevel;
+    private final double mVelocityMetersPerSec;
 
     private RangingData(Builder builder) {
         if (builder.mDistance == null) {
@@ -60,6 +63,9 @@ public final class RangingData implements Parcelable {
         mElevation = builder.mElevation;
         mRssi = builder.mRssi;
         mTimestamp = builder.mTimestamp;
+        mDelaySpreadMeters = builder.mDelaySpreadMeters;
+        mDetectedAttackLevel = builder.mDetectedAttackLevel;
+        mVelocityMetersPerSec = builder.mVelocityMetersPerSec;
     }
 
     private RangingData(Parcel in) {
@@ -73,6 +79,9 @@ public final class RangingData implements Parcelable {
                 RangingMeasurement.class.getClassLoader(), RangingMeasurement.class);
         mRssi = in.readInt();
         mTimestamp = in.readLong();
+        mDelaySpreadMeters = in.readDouble();
+        mDetectedAttackLevel = in.readByte();
+        mVelocityMetersPerSec = in.readDouble();
     }
 
     public static final @NonNull Creator<RangingData> CREATOR = new Creator<>() {
@@ -148,6 +157,71 @@ public final class RangingData implements Parcelable {
         return mRssi;
     }
 
+    /**
+     * Check if the delay spread was set.
+     *
+     * @return True if a delay spread value was set, false if it was not.
+     * @hide
+     */
+    public boolean hasDelaySpread() {
+        return !Double.isNaN(mDelaySpreadMeters);
+    }
+
+    /**
+     * Get estimated delay spread in meters of the measured channel. This is a measure of the
+     * multipath richness of the channel.
+     *
+     * <p>Returned value will be positive if it exists</p>
+     *
+     * @return The delay spread in meters, or NaN if it was not set.
+     * @hide
+     */
+    public double getDelaySpreadMeters() {
+        return mDelaySpreadMeters;
+    }
+
+    /**
+     * Check if the NADM value for the ranging data has been set.
+     *
+     * @return True if a NADM value was set, false if not.
+     * @hide
+     */
+    public boolean hasDetectedAttackLevel() {
+        return Byte.compareUnsigned(mDetectedAttackLevel, (byte) 0xff) != 0;
+    }
+
+    /**
+     * Get the detected Normalized Attack Detector (NADM) value for the ranging data. This
+     * represents the probability of a malicious attack being underway to the application layer.
+     *
+     * @return The NADM value, or 0xFF if the value is unknown.
+     * @hide
+     */
+    public /* @android.bluetooth.le.Nadm */ byte getDetectedAttackLevel() {
+        return mDetectedAttackLevel;
+    }
+
+    /**
+     * Check if a velocity value is included in this ranging data.
+     *
+     * @return True if a velocity was set, false if not.
+     * @hide
+     */
+    public boolean hasVelocity() {
+        return !Double.isNaN(mVelocityMetersPerSec);
+    }
+
+    /**
+     * Get the estimated relative velocity along the direction of shortest distance between the
+     * devices in meters/second.
+     *
+     * @return the velocity in meters/second, or NaN if it was not set.
+     * @hide
+     */
+    public double getVelocityMetersPerSec() {
+        return mVelocityMetersPerSec;
+    }
+
     /**
      * Returns the timestamp of when the ranging data was collected.
      *
@@ -171,6 +245,9 @@ public final class RangingData implements Parcelable {
         dest.writeParcelable(mElevation, flags);
         dest.writeInt(mRssi);
         dest.writeLong(mTimestamp);
+        dest.writeDouble(mDelaySpreadMeters);
+        dest.writeByte(mDetectedAttackLevel);
+        dest.writeDouble(mVelocityMetersPerSec);
     }
 
     /**
@@ -185,6 +262,9 @@ public final class RangingData implements Parcelable {
         private RangingMeasurement mElevation = null;
         private int mRssi = Integer.MIN_VALUE;
         private long mTimestamp = Long.MIN_VALUE;
+        private double mDelaySpreadMeters = Double.NaN;
+        private /* @android.bluetooth.le.Nadm */ byte mDetectedAttackLevel = (byte) 0xff;
+        private double mVelocityMetersPerSec = Double.NaN;
 
         /**
          * Sets the ranging technology.
@@ -264,6 +344,56 @@ public final class RangingData implements Parcelable {
             return this;
         }
 
+        /**
+         * Sets the estimated delay spread in meters. This is a measure of the multipath richness
+         * of the channel.
+         *
+         * <p>Must be positive.</p>
+         *
+         * @param delaySpread The estinamted delay spread in meters.
+         * @return This {@link Builder} instance.
+         * @throws IllegalArgumentException if the provided value is < 0.
+         * @hide
+         */
+        @NonNull
+        public Builder setDelaySpreadMeters(double delaySpread) {
+            if (delaySpread < 0) {
+                throw new IllegalArgumentException("Delay spread meters must be >= 0");
+            }
+            mDelaySpreadMeters = delaySpread;
+            return this;
+        }
+
+        /**
+         * Set the detected Normalized Attack Detector (NADM) value for the ranging data. This
+         * represents the probability of a malicious attack being underway to the application layer.
+         *
+         * @param detectedAttackLevel The NADM value for this measurement.
+         * @return This {@link Builder} instance.
+         * @throws IllegalArgumentException If the provided NADM value is invalid.
+         * @hide
+         */
+        @NonNull
+        public Builder setDetectedAttackLevel(
+                /* @android.bluetooth.le.Nadm */ byte detectedAttackLevel) {
+            mDetectedAttackLevel = detectedAttackLevel;
+            return this;
+        }
+
+        /**
+         * Set the estimated relative velocity along the direction of shortest distance between the
+         * devices in meters/second.
+         *
+         * @param velocity The estimated velocity in meters.
+         * @return This {@link Builder} instance.
+         * @hide
+         */
+        @NonNull
+        public Builder setVelocityMetersPerSec(double velocity) {
+            mVelocityMetersPerSec = velocity;
+            return this;
+        }
+
         /**
          * Builds and returns a new instance of {@link RangingData}.
          *
diff --git a/ranging/framework/java/android/ranging/RangingMeasurement.java b/ranging/framework/java/android/ranging/RangingMeasurement.java
index c1aefa6b..5e3f79a5 100644
--- a/ranging/framework/java/android/ranging/RangingMeasurement.java
+++ b/ranging/framework/java/android/ranging/RangingMeasurement.java
@@ -17,6 +17,7 @@
 package android.ranging;
 
 import android.annotation.FlaggedApi;
+import android.annotation.FloatRange;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.os.Parcel;
@@ -63,6 +64,8 @@ public final class RangingMeasurement implements Parcelable {
     private final double mMeasurement;
     @Confidence
     private final int mConfidence;
+    private final double mRawConfidence;
+    private final double mError;
 
     private RangingMeasurement(Builder builder) {
         if (Double.isNaN(builder.mMeasurement)) {
@@ -70,11 +73,15 @@ public final class RangingMeasurement implements Parcelable {
         }
         mMeasurement = builder.mMeasurement;
         mConfidence = builder.mConfidence;
+        mRawConfidence = builder.mRawConfidence;
+        mError = builder.mError;
     }
 
     private RangingMeasurement(@NonNull Parcel in) {
         mMeasurement = in.readDouble();
         mConfidence = in.readInt();
+        mRawConfidence = in.readDouble();
+        mError = in.readDouble();
     }
 
     @NonNull
@@ -108,6 +115,50 @@ public final class RangingMeasurement implements Parcelable {
         return mConfidence;
     }
 
+    /**
+     * Check if the measurement has a reported raw confidence value.
+     *
+     * @return True if a floating-point confidence is part of this measurement, false if it is not.
+     * @hide
+     */
+    public boolean hasRawConfidence() {
+        return !Double.isNaN(mRawConfidence);
+    }
+
+    /**
+     * Get the raw confidence value of this measurement.
+     *
+     * @return The confidence as a floating-point value in [0, 1], or NaN if it was not set.
+     * @hide
+     */
+    public double getRawConfidence() {
+        return mRawConfidence;
+    }
+
+    /**
+     * Check if the measurement has a reported error value.
+
+     * @return True if an error value was record as part of this measurement, false if it was not.
+     * @hide
+     */
+    public boolean hasError() {
+        return !Double.isNaN(mError);
+    }
+
+    /**
+     * Get the error of this measurement, specifying that the underlying value being measured could
+     * fall within the range [value - error, value + error].
+     * <ul>
+     *     <li>Units are the same as the value returned by {@code this.getMeasurement()}</li>
+     *     <li>Returned value will be positive if it exists</li>
+     * </ul>
+     * @return The error, or NaN if it was not set.
+     * @hide
+     */
+    public double getError() {
+        return mError;
+    }
+
     @Override
     public int describeContents() {
         return 0;
@@ -117,6 +168,8 @@ public final class RangingMeasurement implements Parcelable {
     public void writeToParcel(@NonNull Parcel dest, int flags) {
         dest.writeDouble(mMeasurement);
         dest.writeInt(mConfidence);
+        dest.writeDouble(mRawConfidence);
+        dest.writeDouble(mError);
     }
 
     /**
@@ -127,6 +180,8 @@ public final class RangingMeasurement implements Parcelable {
     public static final class Builder {
         private double mMeasurement = Double.NaN;
         @Confidence private int mConfidence = CONFIDENCE_MEDIUM;
+        private double mRawConfidence = Double.NaN;
+        private double mError = Double.NaN;
 
         /**
          * Sets the measurement value.
@@ -153,6 +208,46 @@ public final class RangingMeasurement implements Parcelable {
             return this;
         }
 
+        /**
+         * Sets the raw confidence value for the measurement.
+         *
+         * @param confidence The confidence in this measurement as a floating-point value in [0, 1].
+         * @return This {@link Builder} instance.
+         * @throws IllegalArgumentException if the provided {@param confidence} is not in
+         *                                  [0.0, 1.0].
+         * @hide
+         */
+        @NonNull
+        public Builder setRawConfidence(@FloatRange(from = 0.0, to = 1.0) double confidence) {
+            if (confidence < 0.0 || confidence > 1.0) {
+                throw new IllegalArgumentException(
+                        "Provided raw confidence value must be in [0.0, 1.0]");
+            }
+            mRawConfidence = confidence;
+            return this;
+        }
+
+        /**
+         * Set the error of this measurement, specifying that the underlying value being measured
+         * could fall within the range [value - error, value + error].
+         * <ul>
+         *     <li>Must be the same units as the value itself</li>
+         *     <li>Must be >= 0</li>
+         * </ul>
+         * @param error The error.
+         * @return This {@link Builder} instance.
+         * @throws IllegalArgumentException if the provided value is not positive.
+         * @hide
+         */
+        @NonNull
+        public Builder setError(double error) {
+            if (error < 0) {
+                throw new IllegalArgumentException("Provided error must be positive");
+            }
+            mError = error;
+            return this;
+        }
+
         /**
          * Builds a new {@link RangingMeasurement} instance with the specified parameters.
          *
@@ -166,11 +261,11 @@ public final class RangingMeasurement implements Parcelable {
 
     @Override
     public String toString() {
-        return "RangingMeasurement{ "
-                + "mMeasurement="
-                + mMeasurement
-                + ", mConfidence="
-                + mConfidence
-                + " }";
+        return "RangingMeasurement{"
+                + "mMeasurement=" + mMeasurement
+                + ", mConfidence=" + mConfidence
+                + ", mRawConfidence=" + mRawConfidence
+                + ", mError=" + mError
+                + '}';
     }
 }
diff --git a/ranging/framework/java/android/ranging/RangingPreference.java b/ranging/framework/java/android/ranging/RangingPreference.java
index 08663820..45186958 100644
--- a/ranging/framework/java/android/ranging/RangingPreference.java
+++ b/ranging/framework/java/android/ranging/RangingPreference.java
@@ -22,6 +22,10 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.oob.OobResponderRangingConfig;
+import android.ranging.raw.RawInitiatorRangingConfig;
+import android.ranging.raw.RawResponderRangingConfig;
 
 import com.android.ranging.flags.Flags;
 
@@ -58,23 +62,23 @@ public final class RangingPreference implements Parcelable {
 
     @DeviceRole
     private final int mDeviceRole;
-    private final RangingParams mRangingParameters;
+    private final RangingConfig mRangingParams;
 
-    private final SessionConfiguration mSessionConfig;
+    private final SessionConfig mSessionConfig;
 
     private RangingPreference(Builder builder) {
         mDeviceRole = builder.mDeviceRole;
-        mRangingParameters = builder.mRangingParameters;
+        mRangingParams = builder.mRangingConfig;
         mSessionConfig = builder.mSessionConfig;
     }
 
     private RangingPreference(Parcel in) {
         mDeviceRole = in.readInt();
-        mRangingParameters = in.readParcelable(
-                RangingParams.class.getClassLoader(),
-                RangingParams.class);
+        mRangingParams = in.readParcelable(
+                RangingConfig.class.getClassLoader(),
+                RangingConfig.class);
         mSessionConfig = in.readParcelable(
-                SessionConfiguration.class.getClassLoader(), SessionConfiguration.class);
+                SessionConfig.class.getClassLoader(), SessionConfig.class);
     }
 
     @NonNull
@@ -101,20 +105,20 @@ public final class RangingPreference implements Parcelable {
     /**
      * Returns the ranging parameters associated with this preference.
      *
-     * @return the {@link android.ranging.RangingParams} or {@code null} if not set.
+     * @return the {@link RangingConfig} or {@code null} if not set.
      */
     @Nullable
-    public RangingParams getRangingParameters() {
-        return mRangingParameters;
+    public RangingConfig getRangingParams() {
+        return mRangingParams;
     }
 
     /**
      * Returns the ranging session configuration params.
      *
-     * @return a non-null {@link SessionConfiguration} instance.
+     * @return a non-null {@link SessionConfig} instance.
      */
     @NonNull
-    public SessionConfiguration getSessionConfiguration() {
+    public SessionConfig getSessionConfig() {
         return mSessionConfig;
     }
 
@@ -126,7 +130,7 @@ public final class RangingPreference implements Parcelable {
     @Override
     public void writeToParcel(@NonNull Parcel dest, int flags) {
         dest.writeInt(mDeviceRole);
-        dest.writeParcelable(mRangingParameters, flags);
+        dest.writeParcelable(mRangingParams, flags);
         dest.writeParcelable(mSessionConfig, flags);
     }
 
@@ -158,41 +162,41 @@ public final class RangingPreference implements Parcelable {
     public static final class Builder {
         @DeviceRole
         private final int mDeviceRole;
-        private final RangingParams mRangingParameters;
-        private SessionConfiguration mSessionConfig = new SessionConfiguration.Builder().build();
+        private final RangingConfig mRangingConfig;
+        private SessionConfig mSessionConfig = new SessionConfig.Builder().build();
 
         /**
-         * Creates a Builder instance with the required device role and {@link RangingParams}.
+         * Creates a Builder instance with the required device role and {@link RangingConfig}.
          *
-         * @param role the role of the device in {@link DeviceRole}
-         * @param rangingParams the {@link RangingParams} to use.
+         * @param role          the role of the device in {@link DeviceRole}
+         * @param rangingConfig the {@link RangingConfig} to use.
          *                      Needs to be an instance of one of the following:
-         *  <ul>
-         *     <li>{@link android.ranging.raw.RawResponderRangingParams}</li>
-         *     <li>{@link android.ranging.raw.RawInitiatorRangingParams}</li>
-         *     <li>{@link android.ranging.oob.OobResponderRangingParams}</li>
-         *     <li>{@link android.ranging.oob.OobInitiatorRangingParams}</li>
-         *  </ul>
+         *                      <ul>
+         *                         <li>{@link RawResponderRangingConfig}</li>
+         *                         <li>{@link RawInitiatorRangingConfig}</li>
+         *                         <li>{@link OobResponderRangingConfig}</li>
+         *                         <li>{@link OobInitiatorRangingConfig}</li>
+         *                      </ul>
          * @throws NullPointerException if {@code rangingParams} is null.
          */
-        public Builder(@DeviceRole int role, @NonNull RangingParams rangingParams) {
-            Objects.requireNonNull(rangingParams);
+        public Builder(@DeviceRole int role, @NonNull RangingConfig rangingConfig) {
+            Objects.requireNonNull(rangingConfig);
             mDeviceRole = role;
-            mRangingParameters = rangingParams;
+            mRangingConfig = rangingConfig;
         }
 
         /**
          * Sets the configuration parameters for the ranging session policy.
          *
          * <p>This method allows specifying additional configuration parameters encapsulated in
-         * {@link SessionConfiguration} for fine-tuning the behavior of the ranging session.
+         * {@link SessionConfig} for fine-tuning the behavior of the ranging session.
          *
-         * @param config the {@link SessionConfiguration}.
+         * @param config the {@link SessionConfig}.
          * @return this {@link Builder} instance.
          * @throws NullPointerException if {@code params} is null.
          */
         @NonNull
-        public Builder setSessionConfiguration(@NonNull SessionConfiguration config) {
+        public Builder setSessionConfig(@NonNull SessionConfig config) {
             Objects.requireNonNull(config);
             mSessionConfig = config;
             return this;
@@ -201,7 +205,7 @@ public final class RangingPreference implements Parcelable {
         /**
          * Builds the {@code RangingPreference} instance.
          *
-         * <p>If the {@link SessionConfiguration} is not set, default instances will be used.
+         * <p>If the {@link SessionConfig} is not set, default instances will be used.
          *
          * @return a new {@code RangingPreference} instance.
          */
@@ -217,7 +221,7 @@ public final class RangingPreference implements Parcelable {
                 + "mDeviceRole="
                 + mDeviceRole
                 + ", mRangingParameters="
-                + mRangingParameters
+                + mRangingParams
                 + ", mSessionConfig="
                 + mSessionConfig
                 + " }";
diff --git a/ranging/framework/java/android/ranging/RangingSession.java b/ranging/framework/java/android/ranging/RangingSession.java
index 5432f770..fa82a46e 100644
--- a/ranging/framework/java/android/ranging/RangingSession.java
+++ b/ranging/framework/java/android/ranging/RangingSession.java
@@ -27,16 +27,18 @@ import android.os.CancellationSignal;
 import android.os.RemoteException;
 import android.ranging.oob.DeviceHandle;
 import android.ranging.oob.OobHandle;
-import android.ranging.oob.OobInitiatorRangingParams;
-import android.ranging.oob.OobResponderRangingParams;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.oob.OobResponderRangingConfig;
 import android.ranging.oob.TransportHandle;
-import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.raw.RawResponderRangingConfig;
 import android.util.Log;
 
 import com.android.ranging.flags.Flags;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -100,13 +102,12 @@ public final class RangingSession implements AutoCloseable {
     @RequiresPermission(Manifest.permission.RANGING)
     @NonNull
     public CancellationSignal start(@NonNull RangingPreference rangingPreference) {
-        //TODO : check whether this needs to be called after start, or handle when a session is
-        // created in ranging service.
-        if (rangingPreference.getRangingParameters().getRangingSessionType()
-                == RangingParams.RANGING_SESSION_OOB) {
+        if (rangingPreference.getRangingParams().getRangingSessionType()
+                == RangingConfig.RANGING_SESSION_OOB) {
             mRangingSessionManager.registerOobSendDataListener();
             setupTransportHandles(rangingPreference);
         }
+        Log.v(TAG, "Start ranging - " + mSessionHandle);
         try {
             mRangingAdapter.startRanging(mAttributionSource, mSessionHandle, rangingPreference,
                     mRangingSessionManager);
@@ -121,12 +122,12 @@ public final class RangingSession implements AutoCloseable {
 
     private void setupTransportHandles(RangingPreference rangingPreference) {
         List<DeviceHandle> deviceHandleList = new ArrayList<>();
-        if (rangingPreference.getRangingParameters() instanceof OobInitiatorRangingParams) {
-            deviceHandleList.addAll(((OobInitiatorRangingParams)
-                    rangingPreference.getRangingParameters()).getDeviceHandles());
-        } else if (rangingPreference.getRangingParameters() instanceof OobResponderRangingParams) {
-            deviceHandleList.add(((OobResponderRangingParams)
-                    rangingPreference.getRangingParameters()).getDeviceHandle());
+        if (rangingPreference.getRangingParams() instanceof OobInitiatorRangingConfig) {
+            deviceHandleList.addAll(((OobInitiatorRangingConfig)
+                    rangingPreference.getRangingParams()).getDeviceHandles());
+        } else if (rangingPreference.getRangingParams() instanceof OobResponderRangingConfig) {
+            deviceHandleList.add(((OobResponderRangingConfig)
+                    rangingPreference.getRangingParams()).getDeviceHandle());
         }
         for (DeviceHandle deviceHandle : deviceHandleList) {
             TransportHandleReceiveCallback receiveCallback =
@@ -141,32 +142,27 @@ public final class RangingSession implements AutoCloseable {
     /**
      * Adds a new device to an ongoing ranging session.
      * <p>
-     * This method allows for adding a new device to an active ranging session using either
-     * raw or out-of-band (OOB) ranging parameters. Only devices represented by
-     * {@link RawResponderRangingParams} or {@link OobResponderRangingParams} are supported.
-     * If the provided {@link RangingParams} does not match one of these types, the addition fails
+     * This method allows for adding a new device to an active ranging session using raw ranging
+     * parameters. Only devices represented by {@link RawResponderRangingConfig} is supported.
+     * If the provided {@link RangingConfig} does not match one of these types, the addition fails
      * and invokes {@link Callback#onOpenFailed(int)} with a reason of
      * {@link Callback#REASON_UNSUPPORTED}.
      * </p>
      *
      * @param deviceRangingParams the ranging parameters for the device to be added,
-     *                            which must be an instance of either
-     *                            {@link RawResponderRangingParams}
-     *                            or {@link OobResponderRangingParams}.
+     *                            which must be an instance of {@link RawResponderRangingConfig}
      *
      * @apiNote If the underlying ranging technology cannot support this dynamic addition, failure
      * will be indicated via {@code Callback#onStartFailed(REASON_UNSUPPORTED, RangingDevice)}
      *
      */
     @RequiresPermission(Manifest.permission.RANGING)
-    public void addDeviceToRangingSession(@NonNull RangingParams deviceRangingParams) {
+    public void addDeviceToRangingSession(@NonNull RangingConfig deviceRangingParams) {
+        Log.v(TAG, " Add device - " + mSessionHandle);
         try {
-            if (deviceRangingParams instanceof RawResponderRangingParams) {
+            if (deviceRangingParams instanceof RawResponderRangingConfig) {
                 mRangingAdapter.addRawDevice(mSessionHandle,
-                        (RawResponderRangingParams) deviceRangingParams);
-            } else if (deviceRangingParams instanceof OobResponderRangingParams) {
-                mRangingAdapter.addOobDevice(mSessionHandle,
-                        (OobResponderRangingParams) deviceRangingParams);
+                        (RawResponderRangingConfig) deviceRangingParams);
             } else {
                 mCallback.onOpenFailed(Callback.REASON_UNSUPPORTED);
             }
@@ -186,11 +182,12 @@ public final class RangingSession implements AutoCloseable {
      *
      * @param rangingDevice the device to be removed from the session.
      * @apiNote Currently, this API is supported only for UWB multicast session if using
-     * {@link RangingParams#RANGING_SESSION_RAW}.
+     * {@link RangingConfig#RANGING_SESSION_RAW}.
      *
      */
     @RequiresPermission(Manifest.permission.RANGING)
     public void removeDeviceFromRangingSession(@NonNull RangingDevice rangingDevice) {
+        Log.v(TAG, " Remove device - " + mSessionHandle);
         try {
             mRangingAdapter.removeDevice(mSessionHandle, rangingDevice);
         } catch (RemoteException e) {
@@ -207,6 +204,7 @@ public final class RangingSession implements AutoCloseable {
      */
     @RequiresPermission(Manifest.permission.RANGING)
     public void reconfigureRangingInterval(@IntRange(from = 0, to = 255) int intervalSkipCount) {
+        Log.v(TAG, " Reconfiguring ranging interval - " + mSessionHandle);
         try {
             mRangingAdapter.reconfigureRangingInterval(mSessionHandle, intervalSkipCount);
         } catch (RemoteException e) {
@@ -222,6 +220,7 @@ public final class RangingSession implements AutoCloseable {
      */
     @RequiresPermission(Manifest.permission.RANGING)
     public void stop() {
+        Log.v(TAG, "Stop ranging - " + mSessionHandle);
         try {
             mRangingAdapter.stopRanging(mSessionHandle);
         } catch (RemoteException e) {
@@ -296,6 +295,7 @@ public final class RangingSession implements AutoCloseable {
          * @hide
          */
         @Retention(RetentionPolicy.SOURCE)
+        @Target({ElementType.TYPE_USE})
         @IntDef(value = {
                 REASON_UNKNOWN,
                 REASON_LOCAL_REQUEST,
diff --git a/ranging/framework/java/android/ranging/RangingSessionManager.java b/ranging/framework/java/android/ranging/RangingSessionManager.java
index e9b45048..434b3d61 100644
--- a/ranging/framework/java/android/ranging/RangingSessionManager.java
+++ b/ranging/framework/java/android/ranging/RangingSessionManager.java
@@ -60,6 +60,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
             RangingSession.Callback callback, Executor executor) {
         SessionHandle sessionHandle = new SessionHandle(sSessionIdCounter++, attributionSource,
                 Process.myPid());
+        Log.v(TAG, "Create ranging session - sessionHandle: " + sessionHandle);
         RangingSession rangingSession = new RangingSession(this, attributionSource, sessionHandle,
                 mRangingAdapter, callback, executor);
         mSessions.put(sessionHandle, rangingSession);
@@ -68,6 +69,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
 
     @Override
     public void onOpened(SessionHandle session) {
+        Log.v(TAG, "onOpened - sessionHandle: " + session);
         if (!mSessions.containsKey(session)) {
             Log.e(TAG, "SessionHandle not found");
             return;
@@ -77,6 +79,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
 
     @Override
     public void onOpenFailed(SessionHandle session, int reason) {
+        Log.v(TAG, "onOpenFailed - sessionHandle: " + session + " reason: " + reason);
         if (!mSessions.containsKey(session)) {
             Log.e(TAG, "SessionHandle not found");
             return;
@@ -86,6 +89,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
 
     @Override
     public void onStarted(SessionHandle session, RangingDevice peer, int technology) {
+        Log.v(TAG, "onStarted - sessionHandle: " + session + " technology: " + technology);
         if (!mSessions.containsKey(session)) {
             Log.e(TAG, "SessionHandle not found");
             return;
@@ -95,6 +99,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
 
     @Override
     public void onResults(SessionHandle session, RangingDevice peer, RangingData data) {
+        Log.v(TAG, "onResults - sessionHandle: " + session + " peer: " + peer.toString());
         if (!mSessions.containsKey(session)) {
             Log.e(TAG, "SessionHandle not found");
             return;
@@ -104,6 +109,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
 
     @Override
     public void onStopped(SessionHandle session, RangingDevice peer, int technology) {
+        Log.v(TAG, "onStopped - sessionHandle: " + session + " technology: " + technology);
         if (!mSessions.containsKey(session)) {
             Log.e(TAG, "SessionHandle not found");
             return;
@@ -113,6 +119,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
 
     @Override
     public void onClosed(SessionHandle session, int reason) {
+        Log.v(TAG, "onClosed - sessionHandle: " + session + " reason: " + reason);
         if (!mSessions.containsKey(session)) {
             Log.e(TAG, "SessionHandle not found");
             return;
@@ -127,6 +134,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
      * @param data      payload
      */
     public void oobDataReceived(OobHandle oobHandle, byte[] data) {
+        Log.v(TAG, "oobDataReceived - " + oobHandle);
         try {
             mRangingAdapter.oobDataReceived(oobHandle, data);
         } catch (RemoteException e) {
@@ -140,6 +148,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
      * @param oobHandle uniquely identifiers a session/device pair for OOB communication.
      */
     public void deviceOobReconnected(OobHandle oobHandle) {
+        Log.v(TAG, "deviceOobReconnected - " + oobHandle);
         try {
             mRangingAdapter.deviceOobReconnected(oobHandle);
         } catch (RemoteException e) {
@@ -153,6 +162,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
      * @param oobHandle uniquely identifiers a session/device pair for OOB communication.
      */
     public void deviceOobDisconnected(OobHandle oobHandle) {
+        Log.v(TAG, "deviceOobReconnected - " + oobHandle);
         try {
             mRangingAdapter.deviceOobDisconnected(oobHandle);
         } catch (RemoteException e) {
@@ -167,6 +177,7 @@ public final class RangingSessionManager extends IRangingCallbacks.Stub {
      * @param oobHandle uniquely identifiers a session/device pair for OOB communication.
      */
     public void deviceOobClosed(OobHandle oobHandle) {
+        Log.v(TAG, "deviceOobClosed - " + oobHandle);
         try {
             mRangingAdapter.deviceOobClosed(oobHandle);
         } catch (RemoteException e) {
diff --git a/ranging/framework/java/android/ranging/SensorFusionParams.java b/ranging/framework/java/android/ranging/SensorFusionParams.java
index 69191f3a..9422be3d 100644
--- a/ranging/framework/java/android/ranging/SensorFusionParams.java
+++ b/ranging/framework/java/android/ranging/SensorFusionParams.java
@@ -23,6 +23,8 @@ import android.os.Parcelable;
 
 import com.android.ranging.flags.Flags;
 
+import java.util.Objects;
+
 /**
  * Represents the parameters for sensor fusion in ranging operations. Uses IMU sensors to correct
  * HW AOA measurements. Adds a moving average filter for distance measurements to remove outliers.
@@ -111,4 +113,22 @@ public final class SensorFusionParams implements Parcelable {
                 + mSensorFusionEnabled
                 + " }";
     }
+
+    /**
+     * @hide
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof SensorFusionParams that)) return false;
+        return mSensorFusionEnabled == that.mSensorFusionEnabled;
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int hashCode() {
+        return Boolean.hashCode(mSensorFusionEnabled);
+    }
 }
diff --git a/ranging/framework/java/android/ranging/SessionConfiguration.java b/ranging/framework/java/android/ranging/SessionConfig.java
similarity index 75%
rename from ranging/framework/java/android/ranging/SessionConfiguration.java
rename to ranging/framework/java/android/ranging/SessionConfig.java
index 344417c6..9b395914 100644
--- a/ranging/framework/java/android/ranging/SessionConfiguration.java
+++ b/ranging/framework/java/android/ranging/SessionConfig.java
@@ -24,6 +24,8 @@ import android.os.Parcelable;
 
 import com.android.ranging.flags.Flags;
 
+import java.util.Objects;
+
 /**
  * Defines the ranging session configurations.
  *
@@ -31,22 +33,21 @@ import com.android.ranging.flags.Flags;
  *
  */
 @FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
-public final class SessionConfiguration implements Parcelable {
-
-    private final SensorFusionParams mFusionParameters;
+public final class SessionConfig implements Parcelable {
+    private final SensorFusionParams mFusionParams;
     private final DataNotificationConfig mDataNotificationConfig;
     private final boolean mIsAngleOfArrivalNeeded;
     private final int mRangingMeasurementsLimit;
 
-    private SessionConfiguration(Builder builder) {
-        mFusionParameters = builder.mFusionParameters;
+    private SessionConfig(Builder builder) {
+        mFusionParams = builder.mFusionParams;
         mDataNotificationConfig = builder.mDataNotificationConfig;
         mIsAngleOfArrivalNeeded = builder.mIsAngleOfArrivalNeeded;
         mRangingMeasurementsLimit = builder.mRangingMeasurementsLimit;
     }
 
-    private SessionConfiguration(Parcel in) {
-        mFusionParameters = in.readParcelable(SensorFusionParams.class.getClassLoader(),
+    private SessionConfig(Parcel in) {
+        mFusionParams = in.readParcelable(SensorFusionParams.class.getClassLoader(),
                 SensorFusionParams.class);
         mDataNotificationConfig = in.readParcelable(DataNotificationConfig.class.getClassLoader(),
                 DataNotificationConfig.class);
@@ -56,7 +57,7 @@ public final class SessionConfiguration implements Parcelable {
 
     @Override
     public void writeToParcel(@NonNull Parcel dest, int flags) {
-        dest.writeParcelable(mFusionParameters, flags);
+        dest.writeParcelable(mFusionParams, flags);
         dest.writeParcelable(mDataNotificationConfig, flags);
         dest.writeBoolean(mIsAngleOfArrivalNeeded);
         dest.writeInt(mRangingMeasurementsLimit);
@@ -68,16 +69,16 @@ public final class SessionConfiguration implements Parcelable {
     }
 
     @NonNull
-    public static final Creator<SessionConfiguration> CREATOR =
-            new Creator<SessionConfiguration>() {
+    public static final Creator<SessionConfig> CREATOR =
+            new Creator<SessionConfig>() {
                 @Override
-                public SessionConfiguration createFromParcel(Parcel in) {
-                    return new SessionConfiguration(in);
+                public SessionConfig createFromParcel(Parcel in) {
+                    return new SessionConfig(in);
                 }
 
                 @Override
-                public SessionConfiguration[] newArray(int size) {
-                    return new SessionConfiguration[size];
+                public SessionConfig[] newArray(int size) {
+                    return new SessionConfig[size];
                 }
             };
 
@@ -87,8 +88,8 @@ public final class SessionConfiguration implements Parcelable {
      * @return a non-null {@link SensorFusionParams} instance.
      */
     @NonNull
-    public SensorFusionParams getSensorFusionParameters() {
-        return mFusionParameters;
+    public SensorFusionParams getSensorFusionParams() {
+        return mFusionParams;
     }
 
     /**
@@ -117,12 +118,12 @@ public final class SessionConfiguration implements Parcelable {
     }
 
     /**
-     * Builder for creating instances of {@link SessionConfiguration}.
+     * Builder for creating instances of {@link SessionConfig}.
      */
     public static final class Builder {
         private DataNotificationConfig mDataNotificationConfig =
                 new DataNotificationConfig.Builder().build();
-        private SensorFusionParams mFusionParameters = new SensorFusionParams.Builder().build();
+        private SensorFusionParams mFusionParams = new SensorFusionParams.Builder().build();
         private boolean mIsAngleOfArrivalNeeded = false;
         private int mRangingMeasurementsLimit = 0;
 
@@ -134,9 +135,9 @@ public final class SessionConfiguration implements Parcelable {
          * @throws IllegalArgumentException if the parameters is null.
          */
         @NonNull
-        public Builder setSensorFusionParameters(
+        public Builder setSensorFusionParams(
                 @NonNull SensorFusionParams parameters) {
-            mFusionParameters = parameters;
+            mFusionParams = parameters;
             return this;
         }
 
@@ -194,21 +195,21 @@ public final class SessionConfiguration implements Parcelable {
         }
 
         /**
-         * Builds a new {@link SessionConfiguration} instance.
+         * Builds a new {@link SessionConfig} instance.
          *
-         * @return the new {@link SessionConfiguration} instance.
+         * @return the new {@link SessionConfig} instance.
          */
         @NonNull
-        public SessionConfiguration build() {
-            return new SessionConfiguration(this);
+        public SessionConfig build() {
+            return new SessionConfig(this);
         }
     }
 
     @Override
     public String toString() {
-        return "SessionConfiguration{"
-                + "mFusionParameters="
-                + mFusionParameters
+        return "SessionConfig{"
+                + "mFusionParams="
+                + mFusionParams
                 + ", mDataNotificationConfig="
                 + mDataNotificationConfig
                 + ", mIsAngleOfArrivalNeeded="
@@ -217,4 +218,26 @@ public final class SessionConfiguration implements Parcelable {
                 + mRangingMeasurementsLimit
                 + "}";
     }
+
+    /**
+     * @hide
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof SessionConfig that)) return false;
+        return mIsAngleOfArrivalNeeded == that.mIsAngleOfArrivalNeeded
+                && mRangingMeasurementsLimit == that.mRangingMeasurementsLimit
+                && Objects.equals(mFusionParams, that.mFusionParams)
+                && Objects.equals(mDataNotificationConfig, that.mDataNotificationConfig);
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int hashCode() {
+        return Objects.hash(mFusionParams, mDataNotificationConfig, mIsAngleOfArrivalNeeded,
+                mRangingMeasurementsLimit);
+    }
 }
diff --git a/ranging/framework/java/android/ranging/ble/cs/CsRangingCapabilities.java b/ranging/framework/java/android/ranging/ble/cs/BleCsRangingCapabilities.java
similarity index 64%
rename from ranging/framework/java/android/ranging/ble/cs/CsRangingCapabilities.java
rename to ranging/framework/java/android/ranging/ble/cs/BleCsRangingCapabilities.java
index c3be78de..63209b97 100644
--- a/ranging/framework/java/android/ranging/ble/cs/CsRangingCapabilities.java
+++ b/ranging/framework/java/android/ranging/ble/cs/BleCsRangingCapabilities.java
@@ -19,6 +19,7 @@ package android.ranging.ble.cs;
 import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
+import android.bluetooth.BluetoothAdapter;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.ranging.RangingCapabilities.TechnologyCapabilities;
@@ -26,8 +27,10 @@ import android.ranging.RangingManager;
 
 import com.android.ranging.flags.Flags;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -35,14 +38,14 @@ import java.util.Set;
 
 /**
  * Represents the capabilities of the Bluetooth-based Channel Sounding (CS) ranging.
- *
  */
 @FlaggedApi(Flags.FLAG_RANGING_CS_ENABLED)
-public final class CsRangingCapabilities implements Parcelable, TechnologyCapabilities {
+public final class BleCsRangingCapabilities implements Parcelable, TechnologyCapabilities {
     /**
      * @hide
      */
     @Retention(RetentionPolicy.SOURCE)
+    @Target({ElementType.TYPE_USE})
     @IntDef({
             CS_SECURITY_LEVEL_ONE,
             CS_SECURITY_LEVEL_FOUR,
@@ -64,12 +67,13 @@ public final class CsRangingCapabilities implements Parcelable, TechnologyCapabi
     public static final int CS_SECURITY_LEVEL_FOUR = 4;
 
     private final List<Integer> mSupportedSecurityLevels;
+    private final String mBluetoothAddress;
 
     /**
      * Returns a list of the supported security levels.
      *
      * @return a {@link Set} of integers representing the security levels,
-     *         where each level is one of {@link SecurityLevel}.
+     * where each level is one of {@link SecurityLevel}.
      */
     @NonNull
     @SecurityLevel
@@ -77,29 +81,43 @@ public final class CsRangingCapabilities implements Parcelable, TechnologyCapabi
         return new HashSet<>(mSupportedSecurityLevels);
     }
 
-    private CsRangingCapabilities(Builder builder) {
+    private BleCsRangingCapabilities(Builder builder) {
         mSupportedSecurityLevels = builder.mSupportedSecurityLevels;
+        mBluetoothAddress = builder.mBluetoothAddress;
     }
 
-    private CsRangingCapabilities(Parcel in) {
+    private BleCsRangingCapabilities(Parcel in) {
         mSupportedSecurityLevels = new ArrayList<>();
         in.readList(mSupportedSecurityLevels, Integer.class.getClassLoader(), Integer.class);
+        mBluetoothAddress = in.readString();
     }
 
     @NonNull
-    public static final Creator<CsRangingCapabilities> CREATOR =
-            new Creator<CsRangingCapabilities>() {
+    public static final Creator<BleCsRangingCapabilities> CREATOR =
+            new Creator<BleCsRangingCapabilities>() {
                 @Override
-                public CsRangingCapabilities createFromParcel(Parcel in) {
-                    return new CsRangingCapabilities(in);
+                public BleCsRangingCapabilities createFromParcel(Parcel in) {
+                    return new BleCsRangingCapabilities(in);
                 }
 
                 @Override
-                public CsRangingCapabilities[] newArray(int size) {
-                    return new CsRangingCapabilities[size];
+                public BleCsRangingCapabilities[] newArray(int size) {
+                    return new BleCsRangingCapabilities[size];
                 }
             };
 
+    /**
+     * Get the device's bluetooth address.
+     * Internal usage only. Clients of the ranging API should use
+     * {@link BluetoothAdapter#getAddress()} instead.
+     *
+     * @hide
+     */
+    @NonNull
+    public String getBluetoothAddress() {
+        return mBluetoothAddress;
+    }
+
     /**
      * @hide
      */
@@ -119,16 +137,19 @@ public final class CsRangingCapabilities implements Parcelable, TechnologyCapabi
     @Override
     public void writeToParcel(@NonNull Parcel dest, int flags) {
         dest.writeList(mSupportedSecurityLevels);
+        dest.writeString(mBluetoothAddress);
     }
 
     /**
-     * Builder class for {@link CsRangingCapabilities}.
-     * This class provides a fluent API for constructing instances of {@link CsRangingCapabilities}.
+     * Builder class for {@link BleCsRangingCapabilities}.
+     * This class provides a fluent API for constructing instances of
+     * {@link BleCsRangingCapabilities}.
      *
      * @hide
      */
     public static final class Builder {
         private List<Integer> mSupportedSecurityLevels;
+        private String mBluetoothAddress;
 
         /**
          * Set supported security levels to the capabilities.
@@ -144,20 +165,34 @@ public final class CsRangingCapabilities implements Parcelable, TechnologyCapabi
         }
 
         /**
-         * Builds and returns a {@link CsRangingCapabilities} instance.
+         * Set the device's bluetooth address.
+         *
+         * @param address of the device.
+         * @return this {@link Builder} instance for chaining calls.
+         */
+        @NonNull
+        public Builder setBluetoothAddress(String address) {
+            this.mBluetoothAddress = address;
+            return this;
+        }
+
+        /**
+         * Builds and returns a {@link BleCsRangingCapabilities} instance.
          *
-         * @return a new {@link CsRangingCapabilities} object.
+         * @return a new {@link BleCsRangingCapabilities} object.
          */
         @NonNull
-        public CsRangingCapabilities build() {
-            return new CsRangingCapabilities(this);
+        public BleCsRangingCapabilities build() {
+            return new BleCsRangingCapabilities(this);
         }
     }
 
     @Override
     public String toString() {
-        return "CsRangingCapabilities{ "
-                + "mSupportedSecurityLevels="
+        return "BleCsRangingCapabilities{ "
+                + "mBluetoothAddress="
+                + mBluetoothAddress
+                + ", mSupportedSecurityLevels="
                 + mSupportedSecurityLevels
                 + " }";
     }
diff --git a/ranging/framework/java/android/ranging/ble/cs/CsRangingParams.java b/ranging/framework/java/android/ranging/ble/cs/BleCsRangingParams.java
similarity index 78%
rename from ranging/framework/java/android/ranging/ble/cs/CsRangingParams.java
rename to ranging/framework/java/android/ranging/ble/cs/BleCsRangingParams.java
index e5522a46..4e526ef8 100644
--- a/ranging/framework/java/android/ranging/ble/cs/CsRangingParams.java
+++ b/ranging/framework/java/android/ranging/ble/cs/BleCsRangingParams.java
@@ -30,13 +30,14 @@ import com.android.ranging.flags.Flags;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Objects;
 
 /**
- * CsRangingParams encapsulates the parameters required for a bluetooth channel sounding ranging
+ * BleCsRangingParams encapsulates the parameters required for a bluetooth channel sounding ranging
  * session.
  */
 @FlaggedApi(Flags.FLAG_RANGING_CS_ENABLED)
-public final class CsRangingParams implements Parcelable {
+public final class BleCsRangingParams implements Parcelable {
 
     /**
      * @hide
@@ -94,10 +95,10 @@ public final class CsRangingParams implements Parcelable {
     private final int mSightType;
     @LocationType
     private final int mLocationType;
-    @CsRangingCapabilities.SecurityLevel
+    @BleCsRangingCapabilities.SecurityLevel
     private final int mSecurityLevel;
 
-    private CsRangingParams(Builder builder) {
+    private BleCsRangingParams(Builder builder) {
         mPeerBluetoothAddress = builder.mPeerBluetoothAddress;
         mRangingUpdateRate = builder.mRangingUpdateRate;
         mSightType = builder.mSightType;
@@ -105,7 +106,7 @@ public final class CsRangingParams implements Parcelable {
         mSecurityLevel = builder.mSecurityLevel;
     }
 
-    private CsRangingParams(Parcel in) {
+    private BleCsRangingParams(Parcel in) {
         mPeerBluetoothAddress = in.readString();
         mRangingUpdateRate = in.readInt();
         mSightType = in.readInt();
@@ -123,15 +124,15 @@ public final class CsRangingParams implements Parcelable {
     }
 
     @NonNull
-    public static final Creator<CsRangingParams> CREATOR = new Creator<CsRangingParams>() {
+    public static final Creator<BleCsRangingParams> CREATOR = new Creator<BleCsRangingParams>() {
         @Override
-        public CsRangingParams createFromParcel(Parcel in) {
-            return new CsRangingParams(in);
+        public BleCsRangingParams createFromParcel(Parcel in) {
+            return new BleCsRangingParams(in);
         }
 
         @Override
-        public CsRangingParams[] newArray(int size) {
-            return new CsRangingParams[size];
+        public BleCsRangingParams[] newArray(int size) {
+            return new BleCsRangingParams[size];
         }
     };
 
@@ -181,13 +182,13 @@ public final class CsRangingParams implements Parcelable {
      *
      * @return the security level
      */
-    @CsRangingCapabilities.SecurityLevel
+    @BleCsRangingCapabilities.SecurityLevel
     public int getSecurityLevel() {
         return mSecurityLevel;
     }
 
     /**
-     * Builder class to create {@link CsRangingParams} instances.
+     * Builder class to create {@link BleCsRangingParams} instances.
      */
     public static final class Builder {
         private String mPeerBluetoothAddress;
@@ -197,8 +198,8 @@ public final class CsRangingParams implements Parcelable {
         private int mSightType = SIGHT_TYPE_UNKNOWN;
         @LocationType
         private int mLocationType = LOCATION_TYPE_UNKNOWN;
-        @CsRangingCapabilities.SecurityLevel
-        private int mSecurityLevel = CsRangingCapabilities.CS_SECURITY_LEVEL_ONE;
+        @BleCsRangingCapabilities.SecurityLevel
+        private int mSecurityLevel = BleCsRangingCapabilities.CS_SECURITY_LEVEL_ONE;
 
         /**
          * Constructs a new {@link Builder} for creating a channel sounding ranging session.
@@ -211,10 +212,11 @@ public final class CsRangingParams implements Parcelable {
          * @param peerBluetoothAddress The address of the peer device must be non-null Bluetooth
          *                             address.
          * @throws IllegalArgumentException if {@code peerBluetoothAddress} is null or does not
-         * conform to "00:11:22:33:AA:BB" format.
+         *                                  conform to "00:11:22:33:AA:BB" format.
          * @see android.bluetooth.BluetoothDevice#getAddress()
          */
         public Builder(@NonNull String peerBluetoothAddress) {
+            Objects.requireNonNull(peerBluetoothAddress);
             if (!android.bluetooth.BluetoothAdapter.checkBluetoothAddress(peerBluetoothAddress)) {
                 throw new IllegalArgumentException(
                         "Bluetooth address is not in 00:11:22:33:AA:BB format");
@@ -263,25 +265,25 @@ public final class CsRangingParams implements Parcelable {
 
         /**
          * Sets the security level for the ranging session.
-         * <p>Defaults to {@link CsRangingCapabilities#CS_SECURITY_LEVEL_ONE}
+         * <p>Defaults to {@link BleCsRangingCapabilities#CS_SECURITY_LEVEL_ONE}
          *
          * @param securityLevel the security level.
          * @return this {@link Builder} instance.
          */
         @NonNull
-        public Builder setSecurityLevel(@CsRangingCapabilities.SecurityLevel int securityLevel) {
+        public Builder setSecurityLevel(@BleCsRangingCapabilities.SecurityLevel int securityLevel) {
             mSecurityLevel = securityLevel;
             return this;
         }
 
         /**
-         * Builds and returns a {@link CsRangingParams} instance.
+         * Builds and returns a {@link BleCsRangingParams} instance.
          *
-         * @return a new {@link CsRangingParams}.
+         * @return a new {@link BleCsRangingParams}.
          */
         @NonNull
-        public CsRangingParams build() {
-            return new CsRangingParams(this);
+        public BleCsRangingParams build() {
+            return new BleCsRangingParams(this);
         }
     }
 
@@ -290,5 +292,25 @@ public final class CsRangingParams implements Parcelable {
         return 0;
     }
 
+    /**
+     * @hide
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof BleCsRangingParams that)) return false;
+        return mRangingUpdateRate == that.mRangingUpdateRate && mSightType == that.mSightType
+                && mLocationType == that.mLocationType && mSecurityLevel == that.mSecurityLevel
+                && Objects.equals(mPeerBluetoothAddress, that.mPeerBluetoothAddress);
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int hashCode() {
+        return Objects.hash(mPeerBluetoothAddress, mRangingUpdateRate, mSightType, mLocationType,
+                mSecurityLevel);
+    }
 }
 
diff --git a/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingCapabilities.java b/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingCapabilities.java
new file mode 100644
index 00000000..13069807
--- /dev/null
+++ b/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingCapabilities.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.ble.rssi;
+
+import static android.ranging.RangingManager.BLE_RSSI;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingCapabilities.TechnologyCapabilities;
+import android.ranging.RangingManager;
+
+import androidx.annotation.NonNull;
+
+/**
+ * BLE RSSI has no non-trivial capabilities. This class is for internal use only.
+ *
+ * @hide
+ */
+public class BleRssiRangingCapabilities implements Parcelable, TechnologyCapabilities {
+    private final String mBluetoothAddress;
+
+    public BleRssiRangingCapabilities(String address) {
+        mBluetoothAddress = address;
+    }
+
+    protected BleRssiRangingCapabilities(Parcel in) {
+        mBluetoothAddress = in.readString();
+    }
+
+    public static final Creator<BleRssiRangingCapabilities> CREATOR = new Creator<>() {
+        @Override
+        public BleRssiRangingCapabilities createFromParcel(Parcel in) {
+            return new BleRssiRangingCapabilities(in);
+        }
+
+        @Override
+        public BleRssiRangingCapabilities[] newArray(int size) {
+            return new BleRssiRangingCapabilities[size];
+        }
+    };
+
+    public String getBluetoothAddress() {
+        return mBluetoothAddress;
+    }
+
+    @Override
+    public @RangingManager.RangingTechnology int getTechnology() {
+        return BLE_RSSI;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeString(mBluetoothAddress);
+    }
+
+    @Override public String toString() {
+        return "BleRssiCapabilities{" +
+                "mBluetoothAddress='" + mBluetoothAddress + '\'' +
+                '}';
+    }
+}
diff --git a/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingParams.java b/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingParams.java
index 5bf53c76..598cc74a 100644
--- a/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingParams.java
+++ b/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingParams.java
@@ -27,6 +27,8 @@ import android.ranging.raw.RawRangingDevice.RangingUpdateRate;
 
 import com.android.ranging.flags.Flags;
 
+import java.util.Objects;
+
 /**
  * BleRssiRangingParams encapsulates the parameters required for a bluetooth rssi based ranging
  * session.
@@ -118,6 +120,7 @@ public final class BleRssiRangingParams implements Parcelable {
          * conform to "00:11:22:33:AA:BB" format.
          */
         public Builder(@NonNull String peerBluetoothAddress) {
+            Objects.requireNonNull(peerBluetoothAddress);
             if (!android.bluetooth.BluetoothAdapter.checkBluetoothAddress(peerBluetoothAddress)) {
                 throw new IllegalArgumentException(
                         "Bluetooth address is not in 00:11:22:33:AA:BB format");
@@ -148,4 +151,23 @@ public final class BleRssiRangingParams implements Parcelable {
             return new BleRssiRangingParams(this);
         }
     }
+
+    /**
+     * @hide
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof BleRssiRangingParams that)) return false;
+        return mRangingUpdateRate == that.mRangingUpdateRate && Objects.equals(
+                mPeerBluetoothAddress, that.mPeerBluetoothAddress);
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int hashCode() {
+        return Objects.hash(mPeerBluetoothAddress, mRangingUpdateRate);
+    }
 }
diff --git a/ranging/framework/java/android/ranging/oob/OobInitiatorRangingParams.java b/ranging/framework/java/android/ranging/oob/OobInitiatorRangingConfig.java
similarity index 82%
rename from ranging/framework/java/android/ranging/oob/OobInitiatorRangingParams.java
rename to ranging/framework/java/android/ranging/oob/OobInitiatorRangingConfig.java
index e6d14543..43f63908 100644
--- a/ranging/framework/java/android/ranging/oob/OobInitiatorRangingParams.java
+++ b/ranging/framework/java/android/ranging/oob/OobInitiatorRangingConfig.java
@@ -21,7 +21,7 @@ import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.ranging.RangingParams;
+import android.ranging.RangingConfig;
 import android.util.Range;
 
 import com.android.ranging.flags.Flags;
@@ -33,12 +33,12 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Represents the parameters for an Out-of-Band (OOB) initiator in a ranging session.
+ * Represents the configuration for an Out-of-Band (OOB) initiator in a ranging session.
  * This class includes configuration options such as device handles, security level,
  * ranging mode, and interval range for setting up an OOB initiator ranging session.
  */
 @FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
-public final class OobInitiatorRangingParams extends RangingParams implements Parcelable {
+public final class OobInitiatorRangingConfig extends RangingConfig implements Parcelable {
 
     /**
      * @hide
@@ -81,16 +81,16 @@ public final class OobInitiatorRangingParams extends RangingParams implements Pa
     }
 
     /**
-     * Automatic ranging mode, allows the system to choose the best mode.
+     * Automatic ranging mode. Allows the system to choose the best mode.
      */
     public static final int RANGING_MODE_AUTO = 0;
     /**
-     * High accuracy ranging mode. Fallback to ranging technologies if high accuracy ranging is not
-     * supported
+     * High accuracy ranging mode. No fallback allowed.
      */
     public static final int RANGING_MODE_HIGH_ACCURACY = 1;
     /**
-     * High accuracy ranging mode. No fallback allowed.
+     * High accuracy ranging mode. Fallback to lower accuracy if high accuracy ranging is not
+     * supported by all devices.
      */
     public static final int RANGING_MODE_HIGH_ACCURACY_PREFERRED = 2;
     /**
@@ -108,16 +108,16 @@ public final class OobInitiatorRangingParams extends RangingParams implements Pa
     @RangingMode
     private final int mRangingMode;
 
-    private OobInitiatorRangingParams(Builder builder) {
-        setRangingSessionType(RangingParams.RANGING_SESSION_OOB);
+    private OobInitiatorRangingConfig(Builder builder) {
+        setRangingSessionType(RangingConfig.RANGING_SESSION_OOB);
         mDeviceHandles = new ArrayList<>(builder.mDeviceHandles);
         mSecurityLevel = builder.mSecurityLevel;
         mRangingMode = builder.mRangingMode;
-        mRangingIntervalRange = new Range<>(builder.mSlowestRangingInterval,
-                builder.mFastestRangingInterval);
+        mRangingIntervalRange = new Range<>(builder.mFastestRangingInterval,
+                builder.mSlowestRangingInterval);
     }
 
-    private OobInitiatorRangingParams(Parcel in) {
+    private OobInitiatorRangingConfig(Parcel in) {
         setRangingSessionType(in.readInt());
         mDeviceHandles = in.createTypedArrayList(DeviceHandle.CREATOR);
         mSecurityLevel = in.readInt();
@@ -144,16 +144,16 @@ public final class OobInitiatorRangingParams extends RangingParams implements Pa
     }
 
     @NonNull
-    public static final Creator<OobInitiatorRangingParams> CREATOR =
-            new Creator<OobInitiatorRangingParams>() {
+    public static final Creator<OobInitiatorRangingConfig> CREATOR =
+            new Creator<OobInitiatorRangingConfig>() {
                 @Override
-                public OobInitiatorRangingParams createFromParcel(Parcel in) {
-                    return new OobInitiatorRangingParams(in);
+                public OobInitiatorRangingConfig createFromParcel(Parcel in) {
+                    return new OobInitiatorRangingConfig(in);
                 }
 
                 @Override
-                public OobInitiatorRangingParams[] newArray(int size) {
-                    return new OobInitiatorRangingParams[size];
+                public OobInitiatorRangingConfig[] newArray(int size) {
+                    return new OobInitiatorRangingConfig[size];
                 }
             };
 
@@ -227,7 +227,7 @@ public final class OobInitiatorRangingParams extends RangingParams implements Pa
     }
 
     /**
-     * Builder class for creating instances of {@link OobInitiatorRangingParams}.
+     * Builder class for creating instances of {@link OobInitiatorRangingConfig}.
      */
     public static final class Builder {
         private final List<DeviceHandle> mDeviceHandles = new ArrayList<>();
@@ -280,6 +280,17 @@ public final class OobInitiatorRangingParams extends RangingParams implements Pa
             return this;
         }
 
+        /**
+         * Adds a list of DeviceHandle to the list of devices for the ranging session.
+         *
+         * @param deviceHandles The list of DeviceHandles to add.
+         * @return The Builder instance.
+         */
+        @NonNull
+        public Builder addDeviceHandles(@NonNull List<DeviceHandle> deviceHandles) {
+            mDeviceHandles.addAll(deviceHandles);
+            return this;
+        }
 
         /**
          * Sets the security level for the ranging session.
@@ -308,19 +319,22 @@ public final class OobInitiatorRangingParams extends RangingParams implements Pa
         }
 
         /**
-         * Builds an instance of {@link OobInitiatorRangingParams} with the provided parameters.
+         * Builds an instance of {@link OobInitiatorRangingConfig} with the provided parameters.
          *
-         * @return A new OobInitiatorRangingParams instance.
+         * @return A new OobInitiatorRangingConfig instance.
          */
         @NonNull
-        public OobInitiatorRangingParams build() {
-            return new OobInitiatorRangingParams(this);
+        public OobInitiatorRangingConfig build() {
+            if (mDeviceHandles.isEmpty()) {
+                throw new IllegalArgumentException("Device handle list cannot be empty");
+            }
+            return new OobInitiatorRangingConfig(this);
         }
     }
 
     @Override
     public String toString() {
-        return "OobInitiatorRangingParams{ "
+        return "OobInitiatorRangingConfig{ "
                 + "mDeviceHandles="
                 + mDeviceHandles
                 + ", mRangingIntervalRange="
diff --git a/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.aidl b/ranging/framework/java/android/ranging/oob/OobResponderRangingConfig.aidl
similarity index 94%
rename from ranging/framework/java/android/ranging/oob/OobResponderRangingParams.aidl
rename to ranging/framework/java/android/ranging/oob/OobResponderRangingConfig.aidl
index c6ac04ab..25b8d01c 100644
--- a/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.aidl
+++ b/ranging/framework/java/android/ranging/oob/OobResponderRangingConfig.aidl
@@ -16,4 +16,4 @@
 
 package android.ranging.oob;
 
-parcelable OobResponderRangingParams;
\ No newline at end of file
+parcelable OobResponderRangingConfig;
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.java b/ranging/framework/java/android/ranging/oob/OobResponderRangingConfig.java
similarity index 70%
rename from ranging/framework/java/android/ranging/oob/OobResponderRangingParams.java
rename to ranging/framework/java/android/ranging/oob/OobResponderRangingConfig.java
index 23444798..8df8e826 100644
--- a/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.java
+++ b/ranging/framework/java/android/ranging/oob/OobResponderRangingConfig.java
@@ -20,27 +20,29 @@ import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.ranging.RangingParams;
+import android.ranging.RangingConfig;
 
 import com.android.ranging.flags.Flags;
 
+import java.util.Objects;
+
 /**
- * Represents the parameters for an Out-of-Band (OOB) responder in a ranging session.
+ * Represents the configuration for an Out-of-Band (OOB) responder in a ranging session.
  * This class contains configuration and device handle information for establishing
  * a ranging session with an initiator.
  */
 @FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
-public final class OobResponderRangingParams extends RangingParams implements Parcelable {
+public final class OobResponderRangingConfig extends RangingConfig implements Parcelable {
 
     private final android.ranging.oob.DeviceHandle mDeviceHandle;
 
-    private OobResponderRangingParams(Builder builder) {
-        setRangingSessionType(RangingParams.RANGING_SESSION_OOB);
+    private OobResponderRangingConfig(Builder builder) {
+        setRangingSessionType(RangingConfig.RANGING_SESSION_OOB);
         mDeviceHandle = builder.mDeviceHandle;
     }
 
 
-    private OobResponderRangingParams(Parcel in) {
+    private OobResponderRangingConfig(Parcel in) {
         setRangingSessionType(in.readInt());
         mDeviceHandle = in.readParcelable(
                 DeviceHandle.class.getClassLoader(), android.ranging.oob.DeviceHandle.class);
@@ -53,16 +55,16 @@ public final class OobResponderRangingParams extends RangingParams implements Pa
     }
 
     @NonNull
-    public static final Creator<OobResponderRangingParams> CREATOR =
-            new Creator<OobResponderRangingParams>() {
+    public static final Creator<OobResponderRangingConfig> CREATOR =
+            new Creator<OobResponderRangingConfig>() {
                 @Override
-                public OobResponderRangingParams createFromParcel(Parcel in) {
-                    return new OobResponderRangingParams(in);
+                public OobResponderRangingConfig createFromParcel(Parcel in) {
+                    return new OobResponderRangingConfig(in);
                 }
 
                 @Override
-                public OobResponderRangingParams[] newArray(int size) {
-                    return new OobResponderRangingParams[size];
+                public OobResponderRangingConfig[] newArray(int size) {
+                    return new OobResponderRangingConfig[size];
                 }
             };
 
@@ -82,28 +84,29 @@ public final class OobResponderRangingParams extends RangingParams implements Pa
     }
 
     /**
-     * Builder class for creating instances of {@link OobResponderRangingParams}.
+     * Builder class for creating instances of {@link OobResponderRangingConfig}.
      */
     public static final class Builder {
-        private final android.ranging.oob.DeviceHandle mDeviceHandle;
+        private final DeviceHandle mDeviceHandle;
 
         /**
          * Constructs a new Builder instance with the specified DeviceHandle.
          *
          * @param deviceHandle The DeviceHandle to associate with this OOB responder.
          */
-        public Builder(@NonNull android.ranging.oob.DeviceHandle deviceHandle) {
+        public Builder(@NonNull DeviceHandle deviceHandle) {
+            Objects.requireNonNull(deviceHandle);
             mDeviceHandle = deviceHandle;
         }
 
         /**
-         * Builds an instance of {@link OobResponderRangingParams} with the provided parameters.
+         * Builds an instance of {@link OobResponderRangingConfig} with the provided parameters.
          *
          * @return A new OobResponderRangingParams instance.
          */
         @NonNull
-        public OobResponderRangingParams build() {
-            return new OobResponderRangingParams(this);
+        public OobResponderRangingConfig build() {
+            return new OobResponderRangingConfig(this);
         }
     }
 
diff --git a/ranging/framework/java/android/ranging/raw/RawInitiatorRangingParams.java b/ranging/framework/java/android/ranging/raw/RawInitiatorRangingConfig.java
similarity index 54%
rename from ranging/framework/java/android/ranging/raw/RawInitiatorRangingParams.java
rename to ranging/framework/java/android/ranging/raw/RawInitiatorRangingConfig.java
index eca07ec5..008cd138 100644
--- a/ranging/framework/java/android/ranging/raw/RawInitiatorRangingParams.java
+++ b/ranging/framework/java/android/ranging/raw/RawInitiatorRangingConfig.java
@@ -20,7 +20,7 @@ import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.ranging.RangingParams;
+import android.ranging.RangingConfig;
 
 import com.android.ranging.flags.Flags;
 
@@ -28,24 +28,24 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Represents the parameters for initiating a raw ranging session.
- * This class encapsulates a list of {@link android.ranging.raw.RawRangingDevice} objects that
+ * Represents the configuration for initiating a raw ranging session.
+ * This class encapsulates a list of {@link RawRangingDevice} objects that
  * participate in the
  * session.
  */
 @FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
-public final class RawInitiatorRangingParams extends RangingParams implements Parcelable {
+public final class RawInitiatorRangingConfig extends RangingConfig implements Parcelable {
 
-    private final List<android.ranging.raw.RawRangingDevice> mRawRangingDevices;
+    private final List<RawRangingDevice> mRawRangingDevices;
 
-    private RawInitiatorRangingParams(Builder builder) {
-        setRangingSessionType(RangingParams.RANGING_SESSION_RAW);
+    private RawInitiatorRangingConfig(Builder builder) {
+        setRangingSessionType(RangingConfig.RANGING_SESSION_RAW);
         mRawRangingDevices = new ArrayList<>(builder.mRawRangingDeviceList);
     }
 
-    private RawInitiatorRangingParams(Parcel in) {
+    private RawInitiatorRangingConfig(Parcel in) {
         setRangingSessionType(in.readInt());
-        mRawRangingDevices = in.createTypedArrayList(android.ranging.raw.RawRangingDevice.CREATOR);
+        mRawRangingDevices = in.createTypedArrayList(RawRangingDevice.CREATOR);
     }
 
     @Override
@@ -60,21 +60,21 @@ public final class RawInitiatorRangingParams extends RangingParams implements Pa
     }
 
     @NonNull
-    public static final Creator<RawInitiatorRangingParams> CREATOR =
-            new Creator<RawInitiatorRangingParams>() {
+    public static final Creator<RawInitiatorRangingConfig> CREATOR =
+            new Creator<RawInitiatorRangingConfig>() {
                 @Override
-                public RawInitiatorRangingParams createFromParcel(Parcel in) {
-                    return new RawInitiatorRangingParams(in);
+                public RawInitiatorRangingConfig createFromParcel(Parcel in) {
+                    return new RawInitiatorRangingConfig(in);
                 }
 
                 @Override
-                public RawInitiatorRangingParams[] newArray(int size) {
-                    return new RawInitiatorRangingParams[size];
+                public RawInitiatorRangingConfig[] newArray(int size) {
+                    return new RawInitiatorRangingConfig[size];
                 }
             };
 
     /**
-     * Returns the list of {@link android.ranging.raw.RawRangingDevice} objects involved in this
+     * Returns the list of {@link RawRangingDevice} objects involved in this
      * session.
      *
      * @return a list of ranging devices.
@@ -85,40 +85,56 @@ public final class RawInitiatorRangingParams extends RangingParams implements Pa
     }
 
     /**
-     * Builder class for constructing instances of {@link RawInitiatorRangingParams}.
+     * Builder class for constructing instances of {@link RawInitiatorRangingConfig}.
      */
     public static final class Builder {
         private final List<android.ranging.raw.RawRangingDevice> mRawRangingDeviceList =
                 new ArrayList<>();
 
         /**
-         * Adds a {@link android.ranging.raw.RawRangingDevice} to the list of devices for this
+         * Adds a {@link RawRangingDevice} to the list of devices for this
          * session.
          *
          * @param rangingDevice the device to be added.
          * @return this {@link Builder} instance.
          */
         @NonNull
-        public Builder addRawRangingDevice(
-                @NonNull android.ranging.raw.RawRangingDevice rangingDevice) {
+        public Builder addRawRangingDevice(@NonNull RawRangingDevice rangingDevice) {
             mRawRangingDeviceList.add(rangingDevice);
             return this;
         }
 
         /**
-         * Builds and returns a new {@link RawInitiatorRangingParams} instance.
+         * Adds a list of {@link android.ranging.raw.RawRangingDevice} to the list of devices for
+         * this session.
          *
-         * @return a configured instance of {@link RawInitiatorRangingParams}.
+         * @param rangingDevices the list of devices to be added.
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder addRawRangingDevices(@NonNull List<RawRangingDevice> rangingDevices) {
+            mRawRangingDeviceList.addAll(rangingDevices);
+            return this;
+        }
+
+        /**
+         * Builds and returns a new {@link RawInitiatorRangingConfig} instance.
+         *
+         * @return a configured instance of {@link RawInitiatorRangingConfig}.
+         * @throws  IllegalArgumentException if no {@link RawRangingDevice} is configured.
          */
         @NonNull
-        public RawInitiatorRangingParams build() {
-            return new RawInitiatorRangingParams(this);
+        public RawInitiatorRangingConfig build() {
+            if (mRawRangingDeviceList.isEmpty()) {
+                throw new IllegalArgumentException("Ranging device list cannot be empty");
+            }
+            return new RawInitiatorRangingConfig(this);
         }
     }
 
     @Override
     public String toString() {
-        return "RawInitiatorRangingParams{ "
+        return "RawInitiatorRangingConfig{ "
                 + "mRawRangingDevices="
                 + mRawRangingDevices
                 + ", "
diff --git a/ranging/framework/java/android/ranging/raw/RawRangingDevice.java b/ranging/framework/java/android/ranging/raw/RawRangingDevice.java
index f344ade3..974ba453 100644
--- a/ranging/framework/java/android/ranging/raw/RawRangingDevice.java
+++ b/ranging/framework/java/android/ranging/raw/RawRangingDevice.java
@@ -23,22 +23,27 @@ import android.annotation.Nullable;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.ranging.RangingDevice;
-import android.ranging.ble.cs.CsRangingParams;
+import android.ranging.ble.cs.BleCsRangingParams;
 import android.ranging.ble.rssi.BleRssiRangingParams;
+import android.ranging.uwb.UwbRangingCapabilities;
 import android.ranging.uwb.UwbRangingParams;
+import android.ranging.wifi.rtt.RttRangingCapabilities;
 import android.ranging.wifi.rtt.RttRangingParams;
 
 import com.android.ranging.flags.Flags;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.util.Objects;
+import java.util.stream.Stream;
 
 /**
  * Represents a device participating in ranging operations.
  * This class supports multiple ranging technologies, including UWB, BLE CS, BLE RSSI and Wi-Fi
  * NAN-RTT. The configuration for each technology is provided through corresponding parameter
  * objects.
- *
  */
 @FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
 public final class RawRangingDevice implements Parcelable {
@@ -49,6 +54,7 @@ public final class RawRangingDevice implements Parcelable {
      * @hide
      */
     @Retention(RetentionPolicy.SOURCE)
+    @Target({ElementType.TYPE_USE})
     @IntDef({
             UPDATE_RATE_NORMAL,
             UPDATE_RATE_INFREQUENT,
@@ -57,15 +63,49 @@ public final class RawRangingDevice implements Parcelable {
     public @interface RangingUpdateRate {
     }
 
-    /** Ranging interval between 200ms - 240ms for UWB, 2 seconds for BT-CS. */
+    /**
+     * Normal ranging interval (Default).
+     * <ul>
+     *     <li> UWB - 200 milliseconds for config ids {@link UwbRangingParams#getConfigId()} with
+     *     multicast ranging, 240 milliseconds for unicast. </li>
+     *     <li> BLE RSSI - 1 second. </li>
+     *     <li> BLE CS - 200 ms. </li>
+     *     <li> WiFi Rtt - 256 milliseconds if
+     *     {@link RttRangingCapabilities#hasPeriodicRangingHardwareFeature()} is true, 512
+     *     milliseconds otherwise. </li>
+     * </ul>
+     */
     public static final int UPDATE_RATE_NORMAL = 1;
-    /** Ranging interval between 600ms - 800ms for UWB, 5 seconds for BT-CS. */
+
+    /**
+     * Infrequent ranging interval.
+     * <ul>
+     *     <li> UWB - 600 milliseconds. </li>
+     *     <li> BLE RSSI - 3 seconds. </li>
+     *     <li> BLE CS - 5 seconds. </li>
+     *     <li> WiFi Rtt - 8192 milliseconds otherwise. </li>
+     * </ul>
+     */
     public static final int UPDATE_RATE_INFREQUENT = 2;
-    /** Ranging interval between 100ms - 200ms for UWB, 1 second for BT-CS. */
+
+    /**
+     * Frequent ranging interval.
+     * <ul>
+     *     <li> UWB - 96 milliseconds for config id
+     *     {@link UwbRangingParams#CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST}, 120 milliseconds
+     *     otherwise. See {@link UwbRangingCapabilities#getSupportedRangingUpdateRates()} to verify
+     *     Frequent update rate is supported. </li>
+     *     <li> BLE RSSI - 500 milliseconds. </li>
+     *     <li> BLE CS - 100 milliseconds. </li>
+     *     <li> WiFi Rtt - 128 milliseconds if
+     *     {@link RttRangingCapabilities#hasPeriodicRangingHardwareFeature()} is true, 256
+     *     milliseconds otherwise. </li>
+     * </ul>
+     */
     public static final int UPDATE_RATE_FREQUENT = 3;
     private final RangingDevice mRangingDevice;
     private final UwbRangingParams mUwbRangingParams;
-    private final CsRangingParams mCsRangingParams;
+    private final BleCsRangingParams mBleCsRangingParams;
     private final RttRangingParams mRttRangingParams;
     private final BleRssiRangingParams mBleRssiRangingParams;
 
@@ -73,7 +113,7 @@ public final class RawRangingDevice implements Parcelable {
     private RawRangingDevice(Builder builder) {
         mRangingDevice = builder.mRangingDevice;
         mUwbRangingParams = builder.mUwbRangingParams;
-        mCsRangingParams = builder.mCsRangingParams;
+        mBleCsRangingParams = builder.mBleCsRangingParams;
         mRttRangingParams = builder.mRttRangingParams;
         mBleRssiRangingParams = builder.mBleRssiRangingParams;
     }
@@ -84,8 +124,8 @@ public final class RawRangingDevice implements Parcelable {
         );
         mUwbRangingParams = in.readParcelable(UwbRangingParams.class.getClassLoader(),
                 UwbRangingParams.class);
-        mCsRangingParams = in.readParcelable(CsRangingParams.class.getClassLoader(),
-                CsRangingParams.class
+        mBleCsRangingParams = in.readParcelable(BleCsRangingParams.class.getClassLoader(),
+                BleCsRangingParams.class
         );
         mRttRangingParams = in.readParcelable(RttRangingParams.class.getClassLoader(),
                 RttRangingParams.class);
@@ -97,7 +137,7 @@ public final class RawRangingDevice implements Parcelable {
     public void writeToParcel(@NonNull Parcel dest, int flags) {
         dest.writeParcelable(mRangingDevice, flags);
         dest.writeParcelable(mUwbRangingParams, flags);
-        dest.writeParcelable(mCsRangingParams, flags);
+        dest.writeParcelable(mBleCsRangingParams, flags);
         dest.writeParcelable(mRttRangingParams, flags);
         dest.writeParcelable(mBleRssiRangingParams, flags);
     }
@@ -138,19 +178,17 @@ public final class RawRangingDevice implements Parcelable {
     /**
      * Returns the CS ranging parameters, if applicable.
      *
-     * @return the {@link CsRangingParams}, or {@code null} if not set.
-     *
+     * @return the {@link BleCsRangingParams}, or {@code null} if not set.
      */
     @Nullable
-    public CsRangingParams getCsRangingParams() {
-        return mCsRangingParams;
+    public BleCsRangingParams getCsRangingParams() {
+        return mBleCsRangingParams;
     }
 
     /**
      * Returns the RTT ranging parameters, if applicable.
      *
      * @return the {@link RttRangingParams}, or {@code null} if not set.
-     *
      */
     @Nullable
     public RttRangingParams getRttRangingParams() {
@@ -161,7 +199,6 @@ public final class RawRangingDevice implements Parcelable {
      * Returns the BLE rssi ranging parameters, if applicable.
      *
      * @return the {@link BleRssiRangingParams}, or {@code null} if not set.
-     *
      */
     @Nullable
     public BleRssiRangingParams getBleRssiRangingParams() {
@@ -179,7 +216,7 @@ public final class RawRangingDevice implements Parcelable {
     public static final class Builder {
         private RangingDevice mRangingDevice;
         private UwbRangingParams mUwbRangingParams;
-        private CsRangingParams mCsRangingParams;
+        private BleCsRangingParams mBleCsRangingParams;
         private RttRangingParams mRttRangingParams;
         private BleRssiRangingParams mBleRssiRangingParams;
 
@@ -191,6 +228,7 @@ public final class RawRangingDevice implements Parcelable {
          */
         @NonNull
         public Builder setRangingDevice(@NonNull RangingDevice rangingDevice) {
+            Objects.requireNonNull(rangingDevice);
             mRangingDevice = rangingDevice;
             return this;
         }
@@ -203,6 +241,7 @@ public final class RawRangingDevice implements Parcelable {
          */
         @NonNull
         public Builder setUwbRangingParams(@NonNull UwbRangingParams params) {
+            Objects.requireNonNull(params);
             mUwbRangingParams = params;
             return this;
         }
@@ -212,10 +251,10 @@ public final class RawRangingDevice implements Parcelable {
          *
          * @param params the {@link RttRangingParams} to be set.
          * @return this {@link Builder} instance for chaining calls.
-         *
          */
         @NonNull
         public Builder setRttRangingParams(@NonNull RttRangingParams params) {
+            Objects.requireNonNull(params);
             mRttRangingParams = params;
             return this;
         }
@@ -223,25 +262,25 @@ public final class RawRangingDevice implements Parcelable {
         /**
          * Sets the BLE channel sounding ranging parameters.
          *
-         * @param params the {@link CsRangingParams} to be set.
+         * @param params the {@link BleCsRangingParams} to be set.
          * @return this {@link Builder} instance for chaining calls.
-         *
          */
         @NonNull
-        public Builder setCsRangingParams(@NonNull CsRangingParams params) {
-            mCsRangingParams = params;
+        public Builder setCsRangingParams(@NonNull BleCsRangingParams params) {
+            Objects.requireNonNull(params);
+            mBleCsRangingParams = params;
             return this;
         }
 
         /**
          * Sets the BLE rssi ranging parameters.
          *
-         * @param params the {@link CsRangingParams} to be set.
+         * @param params the {@link BleCsRangingParams} to be set.
          * @return this {@link Builder} instance for chaining calls.
-         *
          */
         @NonNull
         public Builder setBleRssiRangingParams(@NonNull BleRssiRangingParams params) {
+            Objects.requireNonNull(params);
             mBleRssiRangingParams = params;
             return this;
         }
@@ -253,6 +292,13 @@ public final class RawRangingDevice implements Parcelable {
          */
         @NonNull
         public RawRangingDevice build() {
+            Objects.requireNonNull(this.mRangingDevice);
+            if (Stream.of(mUwbRangingParams, mBleCsRangingParams, mBleRssiRangingParams,
+                            mRttRangingParams)
+                    .allMatch(Objects::isNull)) {
+                throw new IllegalArgumentException(
+                        "At least one ranging params should be configured");
+            }
             return new RawRangingDevice(this);
         }
     }
@@ -264,8 +310,8 @@ public final class RawRangingDevice implements Parcelable {
                 + mRangingDevice
                 + ", mUwbRangingParams="
                 + mUwbRangingParams
-                + ", mCsRangingParams="
-                + mCsRangingParams
+                + ", mBleCsRangingParams="
+                + mBleCsRangingParams
                 + ", mRttRangingParams="
                 + mRttRangingParams
                 + ", mBleRssiRangingParams="
diff --git a/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.aidl b/ranging/framework/java/android/ranging/raw/RawResponderRangingConfig.aidl
similarity index 94%
rename from ranging/framework/java/android/ranging/raw/RawResponderRangingParams.aidl
rename to ranging/framework/java/android/ranging/raw/RawResponderRangingConfig.aidl
index c167808a..db3251cc 100644
--- a/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.aidl
+++ b/ranging/framework/java/android/ranging/raw/RawResponderRangingConfig.aidl
@@ -16,4 +16,4 @@
 
 package android.ranging.raw;
 
-parcelable RawResponderRangingParams;
\ No newline at end of file
+parcelable RawResponderRangingConfig;
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.java b/ranging/framework/java/android/ranging/raw/RawResponderRangingConfig.java
similarity index 76%
rename from ranging/framework/java/android/ranging/raw/RawResponderRangingParams.java
rename to ranging/framework/java/android/ranging/raw/RawResponderRangingConfig.java
index 60372b06..aefea4bd 100644
--- a/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.java
+++ b/ranging/framework/java/android/ranging/raw/RawResponderRangingConfig.java
@@ -20,42 +20,44 @@ import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.ranging.RangingParams;
+import android.ranging.RangingConfig;
 
 import com.android.ranging.flags.Flags;
 
+import java.util.Objects;
+
 /**
- * Represents the parameters for a raw ranging session initiated by a responder device.
+ * Represents the configuration for a raw ranging session initiated by a responder device.
  * This class holds a {@link android.ranging.raw.RawRangingDevice} object that participates in the
  * session.
  */
 @FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
-public final class RawResponderRangingParams extends RangingParams implements Parcelable {
+public final class RawResponderRangingConfig extends RangingConfig implements Parcelable {
 
     private final android.ranging.raw.RawRangingDevice mRawRangingDevice;
 
-    private RawResponderRangingParams(Builder builder) {
-        setRangingSessionType(RangingParams.RANGING_SESSION_RAW);
+    private RawResponderRangingConfig(Builder builder) {
+        setRangingSessionType(RangingConfig.RANGING_SESSION_RAW);
         mRawRangingDevice = builder.mRawRangingDevice;
     }
 
-    private RawResponderRangingParams(Parcel in) {
+    private RawResponderRangingConfig(Parcel in) {
         setRangingSessionType(in.readInt());
         mRawRangingDevice = in.readParcelable(
                 android.ranging.raw.RawRangingDevice.class.getClassLoader());
     }
 
     @NonNull
-    public static final Creator<RawResponderRangingParams> CREATOR =
-            new Creator<RawResponderRangingParams>() {
+    public static final Creator<RawResponderRangingConfig> CREATOR =
+            new Creator<RawResponderRangingConfig>() {
                 @Override
-                public RawResponderRangingParams createFromParcel(Parcel in) {
-                    return new RawResponderRangingParams(in);
+                public RawResponderRangingConfig createFromParcel(Parcel in) {
+                    return new RawResponderRangingConfig(in);
                 }
 
                 @Override
-                public RawResponderRangingParams[] newArray(int size) {
-                    return new RawResponderRangingParams[size];
+                public RawResponderRangingConfig[] newArray(int size) {
+                    return new RawResponderRangingConfig[size];
                 }
             };
 
@@ -96,6 +98,7 @@ public final class RawResponderRangingParams extends RangingParams implements Pa
         @NonNull
         public Builder setRawRangingDevice(
                 @NonNull android.ranging.raw.RawRangingDevice rangingDevice) {
+            Objects.requireNonNull(rangingDevice);
             mRawRangingDevice = rangingDevice;
             return this;
         }
@@ -106,8 +109,9 @@ public final class RawResponderRangingParams extends RangingParams implements Pa
          * @return a configured instance of {@link RawResponderRangingParams}.
          */
         @NonNull
-        public RawResponderRangingParams build() {
-            return new RawResponderRangingParams(this);
+        public RawResponderRangingConfig build() {
+            Objects.requireNonNull(mRawRangingDevice);
+            return new RawResponderRangingConfig(this);
         }
     }
 
diff --git a/ranging/framework/java/android/ranging/uwb/UwbAddress.java b/ranging/framework/java/android/ranging/uwb/UwbAddress.java
index 594d62cd..ec5ec40b 100644
--- a/ranging/framework/java/android/ranging/uwb/UwbAddress.java
+++ b/ranging/framework/java/android/ranging/uwb/UwbAddress.java
@@ -35,6 +35,18 @@ public final class UwbAddress implements Parcelable {
     public static final int SHORT_ADDRESS_BYTE_LENGTH = 2;
     public static final int EXTENDED_ADDRESS_BYTE_LENGTH = 8;
 
+    private static final byte[] sShortForbiddenUwbAddress = {(byte) 0xFF, (byte) 0xFF};
+    private static final byte[] sExtendedForbiddenUwbAddress = {
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF
+    };
+
     private final byte[] mAddressBytes;
 
     private UwbAddress(byte[] address) {
@@ -63,12 +75,12 @@ public final class UwbAddress implements Parcelable {
     }
 
     /**
-     * Generates a random 2 bytes {@link UwbAddress}.
+     * Generates a new random 2 bytes {@link UwbAddress}.
      *
-     * @return a randomly generated {@link UwbAddress}.
+     * @return a new randomly generated {@link UwbAddress}.
      */
     @NonNull
-    public static UwbAddress getRandomShortAddress() {
+    public static UwbAddress createRandomShortAddress() {
         SecureRandom secureRandom = new SecureRandom();
         return fromBytes(generateRandomByteArray(SHORT_ADDRESS_BYTE_LENGTH, secureRandom));
     }
@@ -88,10 +100,20 @@ public final class UwbAddress implements Parcelable {
 
     private static byte[] generateRandomByteArray(int len, SecureRandom secureRandom) {
         byte[] bytes = new byte[len];
-        secureRandom.nextBytes(bytes);
+        do {
+            secureRandom.nextBytes(bytes);
+        } while (isForbiddenAddress(bytes));
         return bytes;
     }
 
+    private static boolean isForbiddenAddress(byte[] address) {
+        if (address.length == SHORT_ADDRESS_BYTE_LENGTH) {
+            return Arrays.equals(address, sShortForbiddenUwbAddress);
+        } else {
+            return Arrays.equals(address, sExtendedForbiddenUwbAddress);
+        }
+    }
+
 
     /**
      * Get the address as a byte array
diff --git a/ranging/framework/java/android/ranging/uwb/UwbComplexChannel.java b/ranging/framework/java/android/ranging/uwb/UwbComplexChannel.java
index 4124a66a..73aaf755 100644
--- a/ranging/framework/java/android/ranging/uwb/UwbComplexChannel.java
+++ b/ranging/framework/java/android/ranging/uwb/UwbComplexChannel.java
@@ -24,8 +24,10 @@ import android.os.Parcelable;
 
 import com.android.ranging.flags.Flags;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 import java.util.Objects;
 import java.util.Random;
 
@@ -38,6 +40,8 @@ import java.util.Random;
  *     <li> BPRF - Base Pulse Repetition Frequency.</li>
  *     <li> HPRF - Higher Pulse Repetition Frequency.</li>
  * </ul>
+ *
+ * See <a href="https://groups.firaconsortium.org/wg/members/document/1949> FiRa UCI Spec.</a>
  */
 @FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
 public final class UwbComplexChannel implements Parcelable {
@@ -48,6 +52,7 @@ public final class UwbComplexChannel implements Parcelable {
      * @hide
      */
     @Retention(RetentionPolicy.SOURCE)
+    @Target({ElementType.TYPE_USE})
     @IntDef(
             value = {
                     UWB_CHANNEL_5,
@@ -85,6 +90,7 @@ public final class UwbComplexChannel implements Parcelable {
      * @hide
      */
     @Retention(RetentionPolicy.SOURCE)
+    @Target({ElementType.TYPE_USE})
     @IntDef(
             value = {
                     UWB_PREAMBLE_CODE_INDEX_9,
diff --git a/ranging/framework/java/android/ranging/uwb/UwbRangingCapabilities.java b/ranging/framework/java/android/ranging/uwb/UwbRangingCapabilities.java
index 55f023ed..8fbb7c78 100644
--- a/ranging/framework/java/android/ranging/uwb/UwbRangingCapabilities.java
+++ b/ranging/framework/java/android/ranging/uwb/UwbRangingCapabilities.java
@@ -57,6 +57,7 @@ public final class UwbRangingCapabilities implements Parcelable, TechnologyCapab
     private final List<Integer> mSupportedRangingUpdateRates;
     private final List<Integer> mSupportedPreambleIndexes;
     private final boolean mHasBackgroundRangingSupport;
+    private final String mCountryCode;
 
     private UwbRangingCapabilities(Builder builder) {
         mSupportsDistance = builder.mSupportsDistance;
@@ -71,6 +72,7 @@ public final class UwbRangingCapabilities implements Parcelable, TechnologyCapab
         mSupportedRangingUpdateRates = builder.mSupportedRangingUpdateRates;
         mSupportedPreambleIndexes = builder.mSupportedPreambleIndexes;
         mHasBackgroundRangingSupport = builder.mHasBackgroundRangingSupport;
+        mCountryCode = builder.mCountryCode;
     }
 
     private UwbRangingCapabilities(Parcel in) {
@@ -92,6 +94,7 @@ public final class UwbRangingCapabilities implements Parcelable, TechnologyCapab
         mSupportedPreambleIndexes = new ArrayList<>();
         in.readList(mSupportedPreambleIndexes, Integer.class.getClassLoader(), Integer.class);
         mHasBackgroundRangingSupport = in.readByte() != 0;
+        mCountryCode = in.readString();
     }
 
     @NonNull
@@ -240,6 +243,16 @@ public final class UwbRangingCapabilities implements Parcelable, TechnologyCapab
         return mHasBackgroundRangingSupport;
     }
 
+    /**
+     * Get the 2-letter ISO 3166 country code.
+     *
+     * @hide
+     */
+    @NonNull
+    public String getCountryCode() {
+        return mCountryCode;
+    }
+
     /**
      * @hide
      */
@@ -262,6 +275,7 @@ public final class UwbRangingCapabilities implements Parcelable, TechnologyCapab
         dest.writeList(mSupportedRangingUpdateRates);
         dest.writeList(mSupportedPreambleIndexes);
         dest.writeByte((byte) (mHasBackgroundRangingSupport ? 1 : 0));
+        dest.writeString(mCountryCode);
     }
 
     /**
@@ -282,6 +296,7 @@ public final class UwbRangingCapabilities implements Parcelable, TechnologyCapab
         private List<Integer> mSupportedRangingUpdateRates;
         private List<Integer> mSupportedPreambleIndexes;
         private boolean mHasBackgroundRangingSupport;
+        private String mCountryCode;
 
         /**
          * Sets supports distance.
@@ -435,6 +450,16 @@ public final class UwbRangingCapabilities implements Parcelable, TechnologyCapab
             return this;
         }
 
+        /**
+         * @param countryCode ISO 3166 country code.
+         * @return this builder instance for method chaining.
+         */
+        @NonNull
+        public Builder setCountryCode(String countryCode) {
+            this.mCountryCode = countryCode;
+            return this;
+        }
+
         /**
          * Build uwb ranging capabilities.
          *
@@ -473,6 +498,8 @@ public final class UwbRangingCapabilities implements Parcelable, TechnologyCapab
                 + mSupportedPreambleIndexes
                 + ", mHasBackgroundRangingSupport="
                 + mHasBackgroundRangingSupport
+                + ", mCountryCode="
+                + mCountryCode
                 + " }";
     }
 }
diff --git a/ranging/framework/java/android/ranging/uwb/UwbRangingParams.java b/ranging/framework/java/android/ranging/uwb/UwbRangingParams.java
index 929262ee..0a5f98d7 100644
--- a/ranging/framework/java/android/ranging/uwb/UwbRangingParams.java
+++ b/ranging/framework/java/android/ranging/uwb/UwbRangingParams.java
@@ -28,8 +28,10 @@ import android.ranging.raw.RawRangingDevice.RangingUpdateRate;
 
 import com.android.ranging.flags.Flags;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 import java.util.Arrays;
 import java.util.Objects;
 
@@ -94,6 +96,7 @@ public final class UwbRangingParams implements Parcelable {
      * @hide
      */
     @Retention(RetentionPolicy.SOURCE)
+    @Target({ElementType.TYPE_USE})
     @IntDef({
             CONFIG_UNICAST_DS_TWR,
             CONFIG_MULTICAST_DS_TWR,
@@ -444,4 +447,31 @@ public final class UwbRangingParams implements Parcelable {
                 + mSlotDurationMillis
                 + " }";
     }
+
+    /**
+     * @hide
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof UwbRangingParams that)) return false;
+        return mSessionId == that.mSessionId && mSubSessionId == that.mSubSessionId
+                && mConfigId == that.mConfigId && mRangingUpdateRate == that.mRangingUpdateRate
+                && mSlotDurationMillis == that.mSlotDurationMillis && Objects.equals(
+                mDeviceAddress, that.mDeviceAddress) && Objects.deepEquals(mSessionKeyInfo,
+                that.mSessionKeyInfo) && Objects.deepEquals(mSubSessionKeyInfo,
+                that.mSubSessionKeyInfo) && Objects.equals(mComplexChannel,
+                that.mComplexChannel) && Objects.equals(mPeerAddress, that.mPeerAddress);
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int hashCode() {
+        return Objects.hash(mSessionId, mSubSessionId, mConfigId, mDeviceAddress,
+                Arrays.hashCode(mSessionKeyInfo), Arrays.hashCode(mSubSessionKeyInfo),
+                mComplexChannel,
+                mPeerAddress, mRangingUpdateRate, mSlotDurationMillis);
+    }
 }
diff --git a/ranging/framework/java/android/ranging/wifi/rtt/RttRangingCapabilities.java b/ranging/framework/java/android/ranging/wifi/rtt/RttRangingCapabilities.java
index 467a55e0..5c48c556 100644
--- a/ranging/framework/java/android/ranging/wifi/rtt/RttRangingCapabilities.java
+++ b/ranging/framework/java/android/ranging/wifi/rtt/RttRangingCapabilities.java
@@ -16,6 +16,8 @@
 
 package android.ranging.wifi.rtt;
 
+import static android.net.wifi.rtt.ResponderConfig.CHANNEL_WIDTH_20MHZ;
+
 import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.os.Parcel;
@@ -33,19 +35,29 @@ import com.android.ranging.flags.Flags;
 @FlaggedApi(Flags.FLAG_RANGING_RTT_ENABLED)
 public final class RttRangingCapabilities implements Parcelable, TechnologyCapabilities {
 
-    private final boolean mHasPeriodicRangingHwFeature;
+    private final boolean mHasPeriodicRangingHardwareFeature;
+
+    private final int mMaxSupportedBandwidth;
+
+    private final int mMaxSupportedRxChain;
 
     private RttRangingCapabilities(Builder builder) {
-        mHasPeriodicRangingHwFeature = builder.mHasPeriodicRangingHwFeature;
+        mHasPeriodicRangingHardwareFeature = builder.mHasPeriodicRangingHardwareFeature;
+        mMaxSupportedBandwidth = builder.mMaxSupportedBandwidth;
+        mMaxSupportedRxChain = builder.mMaxSupportedRxChain;
     }
 
     private RttRangingCapabilities(Parcel in) {
-        mHasPeriodicRangingHwFeature = in.readBoolean();
+        mHasPeriodicRangingHardwareFeature = in.readBoolean();
+        mMaxSupportedBandwidth = in.readInt();
+        mMaxSupportedRxChain = in.readInt();
     }
 
     @Override
     public void writeToParcel(@NonNull Parcel dest, int flags) {
-        dest.writeBoolean(mHasPeriodicRangingHwFeature);
+        dest.writeBoolean(mHasPeriodicRangingHardwareFeature);
+        dest.writeInt(mMaxSupportedBandwidth);
+        dest.writeInt(mMaxSupportedRxChain);
     }
 
     @Override
@@ -80,8 +92,22 @@ public final class RttRangingCapabilities implements Parcelable, TechnologyCapab
      *
      * @return {@code true} if periodic ranging is supported; {@code false} otherwise.
      */
-    public boolean hasPeriodicRangingHwFeature() {
-        return mHasPeriodicRangingHwFeature;
+    public boolean hasPeriodicRangingHardwareFeature() {
+        return mHasPeriodicRangingHardwareFeature;
+    }
+
+    /**
+     * @hide
+     */
+    public int getMaxSupportedBandwidth() {
+        return mMaxSupportedBandwidth;
+    }
+
+    /**
+     * @hide
+     */
+    public int getMaxSupportedRxChain() {
+        return mMaxSupportedRxChain;
     }
 
     /**
@@ -90,7 +116,22 @@ public final class RttRangingCapabilities implements Parcelable, TechnologyCapab
      * @hide
      */
     public static class Builder {
-        private boolean mHasPeriodicRangingHwFeature = false;
+        private boolean mHasPeriodicRangingHardwareFeature = false;
+        private int mMaxSupportedBandwidth = CHANNEL_WIDTH_20MHZ;
+
+        private int mMaxSupportedRxChain = 0;
+
+        @NonNull
+        public Builder setMaxSupportedBandwidth(int maxSupportedBandwidth) {
+            mMaxSupportedBandwidth = maxSupportedBandwidth;
+            return this;
+        }
+
+        @NonNull
+        public Builder setMaxSupportedRxChain(int maxSupportedRxChain) {
+            mMaxSupportedRxChain = maxSupportedRxChain;
+            return this;
+        }
 
         /**
          * Sets whether hardware supports periodic ranging feature.
@@ -100,8 +141,8 @@ public final class RttRangingCapabilities implements Parcelable, TechnologyCapab
          * @return this {@link Builder} instance for method chaining.
          */
         @NonNull
-        public Builder setPeriodicRangingHwFeature(boolean periodicRangingHwFeature) {
-            mHasPeriodicRangingHwFeature = periodicRangingHwFeature;
+        public Builder setPeriodicRangingHardwareFeature(boolean periodicRangingHwFeature) {
+            mHasPeriodicRangingHardwareFeature = periodicRangingHwFeature;
             return this;
         }
 
@@ -121,7 +162,7 @@ public final class RttRangingCapabilities implements Parcelable, TechnologyCapab
     public String toString() {
         return "RttRangingCapabilities{ "
                 + "mHasPeriodicRangingHwFeature="
-                + mHasPeriodicRangingHwFeature
+                + mHasPeriodicRangingHardwareFeature
                 + " }";
     }
 }
diff --git a/ranging/framework/java/android/ranging/wifi/rtt/RttRangingParams.java b/ranging/framework/java/android/ranging/wifi/rtt/RttRangingParams.java
index 8c2aa4b7..f5440af4 100644
--- a/ranging/framework/java/android/ranging/wifi/rtt/RttRangingParams.java
+++ b/ranging/framework/java/android/ranging/wifi/rtt/RttRangingParams.java
@@ -226,4 +226,26 @@ public final class RttRangingParams implements Parcelable {
                 + mPeriodicRangingHwFeatureEnabled
                 + " }";
     }
+
+    /**
+     * @hide
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof RttRangingParams that)) return false;
+        return mRangingUpdateRate == that.mRangingUpdateRate
+                && mPeriodicRangingHwFeatureEnabled == that.mPeriodicRangingHwFeatureEnabled
+                && Objects.equals(mServiceName, that.mServiceName)
+                && Objects.deepEquals(mMatchFilter, that.mMatchFilter);
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int hashCode() {
+        return Objects.hash(mServiceName, Arrays.hashCode(mMatchFilter), mRangingUpdateRate,
+                mPeriodicRangingHwFeatureEnabled);
+    }
 }
diff --git a/ranging/framework/tests/Android.bp b/ranging/framework/tests/Android.bp
new file mode 100644
index 00000000..bd114f19
--- /dev/null
+++ b/ranging/framework/tests/Android.bp
@@ -0,0 +1,46 @@
+// Copyright (C) 2025 The Android Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Make test APK
+// ============================================================
+
+package {
+    default_team: "trendy_team_fwk_uwb",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+android_test {
+    name: "RangingFrameworkTests",
+    defaults: ["framework-ranging-test-defaults"],
+    sdk_version: "system_server_current",
+    target_sdk_version: "36",
+    certificate: "platform",
+    srcs: ["**/*.java"],
+
+    static_libs: [
+        "androidx.test.ext.junit",
+        "androidx.test.rules",
+        "guava",
+        "truth",
+        "modules-utils-build",
+        "androidx.test.runner",
+        "mockito-target-minus-junit4",
+        "mockito-target-extended-minus-junit4",
+    ],
+
+    test_suites: [
+        "general-tests",
+        "mts-uwb",
+    ],
+}
diff --git a/ranging/framework/tests/AndroidManifest.xml b/ranging/framework/tests/AndroidManifest.xml
new file mode 100644
index 00000000..236c488c
--- /dev/null
+++ b/ranging/framework/tests/AndroidManifest.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="android.ranging.test">
+
+
+    <application
+        android:debuggable="true">
+    </application>
+    <application>
+        <uses-library android:name="android.test.runner" />
+    </application>
+
+    <!-- This is a self-instrumenting test package. -->
+    <instrumentation android:name="androidx.test.runner.AndroidJUnitRunner"
+                     android:targetPackage="android.ranging.test"
+                     android:label="Ranging Manager Tests">
+    </instrumentation>
+
+</manifest>
\ No newline at end of file
diff --git a/ranging/framework/tests/AndroidTest.xml b/ranging/framework/tests/AndroidTest.xml
new file mode 100644
index 00000000..8d08b361
--- /dev/null
+++ b/ranging/framework/tests/AndroidTest.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<configuration description="Config for Ranging Manager test cases">
+    <option name="test-suite-tag" value="apct"/>
+    <option name="test-suite-tag" value="apct-instrumentation"/>
+    <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+        <option name="cleanup-apks" value="true" />
+        <option name="test-file-name" value="RangingFrameworkTests.apk" />
+    </target_preparer>
+
+    <option name="test-suite-tag" value="apct"/>
+    <option name="test-tag" value="RangingFrameworkTests"/>
+
+    <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
+        <option name="package" value="android.ranging.test" />
+        <option name="hidden-api-checks" value="false"/>
+        <option name="runner" value="androidx.test.runner.AndroidJUnitRunner"/>
+    </test>
+
+    <!-- Only run RangingFrameworkTests in MTS if the Uwb Mainline module is installed. -->
+    <object type="module_controller"
+            class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.uwb" />
+    </object>
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk36ModuleController" />
+</configuration>
\ No newline at end of file
diff --git a/ranging/framework/tests/src/android/ranging/RangingDataTest.java b/ranging/framework/tests/src/android/ranging/RangingDataTest.java
new file mode 100644
index 00000000..0a9fb634
--- /dev/null
+++ b/ranging/framework/tests/src/android/ranging/RangingDataTest.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import android.os.Parcel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.junit.MockitoJUnitRunner;
+
+@RunWith(MockitoJUnitRunner.class)
+public class RangingDataTest {
+
+    @Test
+    public void build_buildsDataWithAllFieldsSet() {
+        int rangingTechnology = RangingManager.UWB;
+        RangingMeasurement distance = new RangingMeasurement.Builder()
+                .setMeasurement(10.5)
+                .setConfidence(RangingMeasurement.CONFIDENCE_HIGH)
+                .setRawConfidence(0.8)
+                .setError(0.1)
+                .build();
+        RangingMeasurement azimuth = new RangingMeasurement.Builder()
+                .setMeasurement(45.0)
+                .setConfidence(RangingMeasurement.CONFIDENCE_MEDIUM)
+                .setRawConfidence(0.4)
+                .setError(0.2)
+                .build();
+        RangingMeasurement elevation = new RangingMeasurement.Builder()
+                .setMeasurement(30.0)
+                .setConfidence(RangingMeasurement.CONFIDENCE_LOW)
+                .setRawConfidence(0.09)
+                .setError(0.3)
+                .build();
+
+        int rssi = -2;
+        long timestamp = System.currentTimeMillis();
+        double delaySpreadMeters = 2.0;
+        byte detectedAttackLevel = 0x01;
+        double velocityMetersPerSec = 1.5;
+
+        RangingData rangingData = new RangingData.Builder()
+                .setRangingTechnology(rangingTechnology)
+                .setDistance(distance)
+                .setAzimuth(azimuth)
+                .setElevation(elevation)
+                .setRssi(rssi)
+                .setTimestampMillis(timestamp)
+                .setDelaySpreadMeters(delaySpreadMeters)
+                .setDetectedAttackLevel(detectedAttackLevel)
+                .setVelocityMetersPerSec(velocityMetersPerSec)
+                .build();
+
+        assertEquals(rangingTechnology, rangingData.getRangingTechnology());
+        assertEquals(distance, rangingData.getDistance());
+        assertEquals(azimuth, rangingData.getAzimuth());
+        assertEquals(elevation, rangingData.getElevation());
+        assertEquals(rssi, rangingData.getRssi());
+        assertEquals(timestamp, rangingData.getTimestampMillis());
+        assertEquals(delaySpreadMeters, rangingData.getDelaySpreadMeters(), 0.001);
+        assertEquals(detectedAttackLevel, rangingData.getDetectedAttackLevel());
+        assertEquals(velocityMetersPerSec, rangingData.getVelocityMetersPerSec(), 0.001);
+
+        assertTrue(rangingData.hasRssi());
+        assertTrue(rangingData.hasDelaySpread());
+        assertTrue(rangingData.hasDetectedAttackLevel());
+        assertTrue(rangingData.hasVelocity());
+
+        assertEquals(distance.getMeasurement(), rangingData.getDistance().getMeasurement(), 0.001);
+        assertEquals(distance.getConfidence(), rangingData.getDistance().getConfidence());
+        assertEquals(distance.getRawConfidence(), rangingData.getDistance().getRawConfidence(),
+                0.001);
+        assertEquals(distance.getError(), rangingData.getDistance().getError(), 0.001);
+
+        assertEquals(azimuth.getMeasurement(), rangingData.getAzimuth().getMeasurement(), 0.001);
+        assertEquals(azimuth.getConfidence(), rangingData.getAzimuth().getConfidence());
+        assertEquals(azimuth.getRawConfidence(), rangingData.getAzimuth().getRawConfidence(),
+                0.001);
+        assertEquals(azimuth.getError(), rangingData.getAzimuth().getError(), 0.001);
+
+        assertEquals(elevation.getMeasurement(), rangingData.getElevation().getMeasurement(),
+                0.001);
+        assertEquals(elevation.getConfidence(), rangingData.getElevation().getConfidence());
+        assertEquals(elevation.getRawConfidence(),
+                rangingData.getElevation().getRawConfidence(), 0.001);
+        assertEquals(elevation.getError(), rangingData.getElevation().getError(), 0.001);
+
+    }
+
+    @Test
+    public void build_buildsRangingDataWithMinimalFieldsSet() {
+        int rangingTechnology = RangingManager.UWB;
+        RangingMeasurement distance = new RangingMeasurement.Builder()
+                .setMeasurement(10.5)
+                .build();
+
+        long timestamp = System.currentTimeMillis();
+
+        RangingData rangingData = new RangingData.Builder()
+                .setRangingTechnology(rangingTechnology)
+                .setDistance(distance)
+                .setTimestampMillis(timestamp)
+                .build();
+
+        assertEquals(rangingTechnology, rangingData.getRangingTechnology());
+        assertEquals(distance, rangingData.getDistance());
+        assertEquals(timestamp, rangingData.getTimestampMillis());
+
+        assertNull(rangingData.getAzimuth());
+        assertNull(rangingData.getElevation());
+        assertFalse(rangingData.hasRssi());
+        assertFalse(rangingData.hasDelaySpread());
+        assertFalse(rangingData.hasDetectedAttackLevel());
+        assertFalse(rangingData.hasVelocity());
+
+        assertEquals(distance.getConfidence(), rangingData.getDistance().getConfidence());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void build_failsWhenDistanceIsMissing() {
+        new RangingData.Builder()
+                .setRangingTechnology(RangingManager.UWB)
+                .setTimestampMillis(System.currentTimeMillis())
+                .build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void build_failsWhenTimestampIsMissing() {
+        new RangingData.Builder()
+                .setDistance(new RangingMeasurement.Builder().setMeasurement(10.5).build())
+                .setRangingTechnology(RangingManager.UWB)
+                .build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void build_failsWhenRangingTechnologyIsMissing() {
+        new RangingData.Builder()
+                .setDistance(new RangingMeasurement.Builder().setMeasurement(10.5).build())
+                .setTimestampMillis(System.currentTimeMillis())
+                .build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void build_RangingMeasurement_failsWhenMeasurementIsMissing() {
+        new RangingMeasurement.Builder().build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void build_RangingMeasurement_failsWhenErrorIsNegative() {
+        new RangingMeasurement.Builder().setMeasurement(10).setError(-1).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void build_RangingMeasurement_failsWhenConfidenceLevelIsGreaterThan1() {
+        new RangingMeasurement.Builder().setMeasurement(1).setRawConfidence(11).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void build_RangingMeasurement_failsWhenConfidenceLevelIsLessThan0() {
+        new RangingMeasurement.Builder().setMeasurement(1).setRawConfidence(-1).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void build_failsWhenDelaySpreadIsNegative() {
+        new RangingData.Builder()
+                .setDistance(new RangingMeasurement.Builder().setMeasurement(10).build())
+                .setTimestampMillis(1)
+                .setRangingTechnology(RangingManager.UWB)
+                .setDelaySpreadMeters(-1)
+                .build();
+    }
+
+    @Test
+    public void parcel_createsParcelWithCorrectFields() {
+        Parcel parcel = Parcel.obtain();
+
+        RangingData data = new RangingData.Builder()
+                .setRangingTechnology(RangingManager.UWB)
+                .setDistance(new RangingMeasurement.Builder()
+                        .setMeasurement(10.5)
+                        .setConfidence(RangingMeasurement.CONFIDENCE_HIGH)
+                        .setRawConfidence(0.8)
+                        .setError(0.1)
+                        .build())
+                .setAzimuth(new RangingMeasurement.Builder()
+                        .setMeasurement(45.0)
+                        .setConfidence(RangingMeasurement.CONFIDENCE_MEDIUM)
+                        .setRawConfidence(0.4)
+                        .setError(0.2)
+                        .build())
+                .setElevation(new RangingMeasurement.Builder()
+                        .setMeasurement(30.0)
+                        .setConfidence(RangingMeasurement.CONFIDENCE_LOW)
+                        .setRawConfidence(0.09)
+                        .setError(0.3)
+                        .build())
+                .setRssi(-2)
+                .setTimestampMillis(System.currentTimeMillis())
+                .setDelaySpreadMeters(2.0)
+                .setDetectedAttackLevel((byte) 0x01)
+                .setVelocityMetersPerSec(1.5)
+                .build();
+
+        data.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+        RangingData dataFromParcel = RangingData.CREATOR.createFromParcel(parcel);
+
+        assertEquals(data.getRangingTechnology(), dataFromParcel.getRangingTechnology());
+
+        assertEquals(data.getDistance().getMeasurement(),
+                dataFromParcel.getDistance().getMeasurement(), 0.001);
+        assertEquals(data.getDistance().getConfidence(),
+                dataFromParcel.getDistance().getConfidence());
+        assertEquals(data.getDistance().getRawConfidence(),
+                dataFromParcel.getDistance().getRawConfidence(), 0.001);
+        assertEquals(data.getDistance().getError(),
+                dataFromParcel.getDistance().getError(), 0.001);
+
+        assertEquals(data.getAzimuth().getMeasurement(),
+                dataFromParcel.getAzimuth().getMeasurement(), 0.001);
+        assertEquals(data.getAzimuth().getConfidence(),
+                dataFromParcel.getAzimuth().getConfidence());
+        assertEquals(data.getAzimuth().getRawConfidence(),
+                dataFromParcel.getAzimuth().getRawConfidence(), 0.001);
+        assertEquals(data.getAzimuth().getError(),
+                dataFromParcel.getAzimuth().getError(), 0.001);
+
+        assertEquals(data.getElevation().getMeasurement(),
+                dataFromParcel.getElevation().getMeasurement(), 0.001);
+        assertEquals(data.getElevation().getConfidence(),
+                dataFromParcel.getElevation().getConfidence());
+        assertEquals(data.getElevation().getRawConfidence(),
+                dataFromParcel.getElevation().getRawConfidence(), 0.001);
+        assertEquals(data.getElevation().getError(),
+                dataFromParcel.getElevation().getError(), 0.001);
+
+        assertEquals(data.getRssi(), dataFromParcel.getRssi());
+        assertEquals(data.getTimestampMillis(), dataFromParcel.getTimestampMillis());
+        assertEquals(data.getDelaySpreadMeters(), dataFromParcel.getDelaySpreadMeters(), 0.001);
+        assertEquals(data.getDetectedAttackLevel(), dataFromParcel.getDetectedAttackLevel());
+        assertEquals(data.getVelocityMetersPerSec(),
+                dataFromParcel.getVelocityMetersPerSec(), 0.001);
+    }
+}
diff --git a/ranging/framework/tests/src/android/ranging/RangingFrameworkTest.java b/ranging/framework/tests/src/android/ranging/RangingFrameworkTest.java
new file mode 100644
index 00000000..4462a50f
--- /dev/null
+++ b/ranging/framework/tests/src/android/ranging/RangingFrameworkTest.java
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_ENABLE;
+import static android.ranging.RangingConfig.RANGING_SESSION_OOB;
+import static android.ranging.RangingConfig.RANGING_SESSION_RAW;
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+import static android.ranging.ble.cs.BleCsRangingParams.LOCATION_TYPE_INDOOR;
+import static android.ranging.oob.OobInitiatorRangingConfig.RANGING_MODE_AUTO;
+import static android.ranging.oob.OobInitiatorRangingConfig.SECURITY_LEVEL_BASIC;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_MULTICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.DURATION_2_MS;
+
+import static com.android.dx.mockito.inline.extended.ExtendedMockito.verify;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.when;
+
+import android.content.AttributionSource;
+import android.content.Context;
+import android.os.Process;
+import android.os.RemoteException;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
+import android.ranging.ble.cs.BleCsRangingParams;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+import android.ranging.oob.DeviceHandle;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.oob.OobResponderRangingConfig;
+import android.ranging.oob.TransportHandle;
+import android.ranging.raw.RawInitiatorRangingConfig;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.raw.RawResponderRangingConfig;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingCapabilities;
+import android.ranging.uwb.UwbRangingParams;
+import android.ranging.wifi.rtt.RttRangingCapabilities;
+import android.ranging.wifi.rtt.RttRangingParams;
+
+import androidx.test.filters.SmallTest;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Answers;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.UUID;
+import java.util.concurrent.Executor;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class RangingFrameworkTest {
+    @Mock
+    private Context mMockContext;
+    private static final int UID = Process.myUid();
+    private static final String PACKAGE_NAME = "com.uwb.test";
+    private static final AttributionSource ATTRIBUTION_SOURCE =
+            new AttributionSource.Builder(UID).setPackageName(PACKAGE_NAME).build();
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
+    private IRangingAdapter mMockRangingAdapter;
+
+    private RangingManager mRangingManager;
+    private RangingSession mRangingSession;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getAttributionSource()).thenReturn(ATTRIBUTION_SOURCE);
+        mRangingManager = new RangingManager(mMockContext, mMockRangingAdapter);
+        mRangingSession = mRangingManager.createRangingSession(getExecutor(),
+                mock(RangingSession.Callback.class));
+    }
+
+    private RangingPreference getGenericInitiatorRangingPreference() {
+        return new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingConfig.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setUwbRangingParams(
+                                        getUwbRangingParams(
+                                                new byte[]{3, 4}))
+                                .setBleRssiRangingParams(new BleRssiRangingParams.Builder(
+                                        "AA:BB:CC:AA:BB:CC").build())
+                                .setCsRangingParams(new BleCsRangingParams.Builder(
+                                        "AA:BB:CC:AA:BB:CC")
+                                        .setLocationType(LOCATION_TYPE_INDOOR)
+                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                        .setSecurityLevel(1)
+                                        .setSightType(1)
+                                        .build())
+                                .setRttRangingParams(new RttRangingParams.Builder("rtt")
+                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                        .setMatchFilter(new byte[]{})
+                                        .setPeriodicRangingHwFeatureEnabled(false)
+                                        .build())
+                                .build())
+                        .build())
+                .setSessionConfig(new SessionConfig.Builder()
+                        .setDataNotificationConfig(new DataNotificationConfig.Builder()
+                                .setNotificationConfigType(NOTIFICATION_CONFIG_ENABLE)
+                                .setProximityFarCm(100)
+                                .setProximityNearCm(50)
+                                .build())
+                        .setAngleOfArrivalNeeded(true)
+                        .setSensorFusionParams(new SensorFusionParams.Builder()
+                                .setSensorFusionEnabled(false)
+                                .build())
+                        .setRangingMeasurementsLimit(100)
+                        .build())
+                .build();
+    }
+
+    private RangingPreference getGenericResponderRangingPreference() {
+        return new RangingPreference.Builder(DEVICE_ROLE_RESPONDER,
+                new RawResponderRangingConfig.Builder()
+                        .setRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder()
+                                        .setUuid(UUID.randomUUID()).build())
+                                .setBleRssiRangingParams(new BleRssiRangingParams.Builder(
+                                        "AA:BB:CC:AA:BB:CC").build())
+                                .build())
+                        .build())
+                .build();
+    }
+
+    private RangingPreference getGenericOobResponderRangingPreference() {
+        return new RangingPreference.Builder(DEVICE_ROLE_RESPONDER,
+                new OobResponderRangingConfig.Builder(new DeviceHandle.Builder(
+                        new RangingDevice.Builder().build(),
+                        mock(TransportHandle.class)).build())
+                        .build())
+                .build();
+    }
+
+    private RangingPreference getGenericOobInitiatorRangingPreference() {
+        return new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new OobInitiatorRangingConfig.Builder()
+                        .addDeviceHandle(new DeviceHandle.Builder(
+                                new RangingDevice.Builder().build(),
+                                mock(TransportHandle.class)).build())
+                        .setRangingMode(RANGING_MODE_AUTO)
+                        .setFastestRangingInterval(Duration.ofMillis(240))
+                        .setSlowestRangingInterval(Duration.ofMillis(1000))
+                        .setSecurityLevel(SECURITY_LEVEL_BASIC)
+                        .addDeviceHandles(new ArrayList<>())
+                        .build())
+                .build();
+    }
+
+    private UwbRangingParams getUwbRangingParams(byte[] peerAddress) {
+        return new UwbRangingParams.Builder(10,
+                CONFIG_MULTICAST_DS_TWR,
+                UwbAddress.createRandomShortAddress(),
+                UwbAddress.fromBytes(peerAddress))
+                .setComplexChannel(
+                        new UwbComplexChannel.Builder().setChannel(
+                                9).setPreambleIndex(11).build())
+                .setSessionKeyInfo(
+                        new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
+                                2, 1})
+                .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                .setSlotDuration(DURATION_2_MS)
+                .setSubSessionId(100)
+                .setSubSessionKeyInfo(new byte[]{})
+                .build();
+    }
+
+    @Test
+    public void testRawRangingInitiatorSession() throws RemoteException {
+        RangingPreference rangingPreference = getGenericInitiatorRangingPreference();
+        assertThat(rangingPreference).isNotNull();
+        SessionConfig sessionConfig = rangingPreference.getSessionConfig();
+        assertThat(sessionConfig).isNotNull();
+
+        DataNotificationConfig ntfConfig = sessionConfig.getDataNotificationConfig();
+        assertThat(ntfConfig).isNotNull();
+        assertEquals(ntfConfig.getNotificationConfigType(), NOTIFICATION_CONFIG_ENABLE);
+        assertEquals(ntfConfig.getProximityNearCm(), 50);
+        assertEquals(ntfConfig.getProximityFarCm(), 100);
+
+        SensorFusionParams sensorFusionParams = sessionConfig.getSensorFusionParams();
+        assertThat(sensorFusionParams).isNotNull();
+        assertFalse(sensorFusionParams.isSensorFusionEnabled());
+
+        assertEquals(sessionConfig.getRangingMeasurementsLimit(), 100);
+        assertTrue(sessionConfig.isAngleOfArrivalNeeded());
+
+        RangingConfig rangingConfig = rangingPreference.getRangingParams();
+        assertThat(rangingConfig).isNotNull();
+        assertEquals(rangingConfig.getRangingSessionType(), RANGING_SESSION_RAW);
+        if (!(rangingConfig instanceof RawInitiatorRangingConfig)) {
+            fail();
+        }
+        RawInitiatorRangingConfig config = (RawInitiatorRangingConfig) rangingConfig;
+        assertThat(config.getRawRangingDevices()).isNotNull();
+        RawRangingDevice device = config.getRawRangingDevices().get(0);
+        assertThat(device).isNotNull();
+        UwbRangingParams uwbRangingParams = device.getUwbRangingParams();
+        assertThat(uwbRangingParams).isNotNull();
+        assertThat(uwbRangingParams.getPeerAddress()).isNotNull();
+        assertThat(uwbRangingParams.getDeviceAddress()).isNotNull();
+        assertThat(uwbRangingParams.getComplexChannel()).isNotNull();
+        assertThat(uwbRangingParams.getSessionKeyInfo()).isNotNull();
+        assertThat(uwbRangingParams.getSubSessionKeyInfo()).isNotNull();
+        assertEquals(uwbRangingParams.getSessionId(), 10);
+        assertEquals(uwbRangingParams.getRangingUpdateRate(), UPDATE_RATE_NORMAL);
+        assertEquals(uwbRangingParams.getSlotDuration(), DURATION_2_MS);
+        assertEquals(uwbRangingParams.getSubSessionId(), 100);
+        assertEquals(uwbRangingParams.getConfigId(), CONFIG_MULTICAST_DS_TWR);
+
+        UwbComplexChannel complexChannel = uwbRangingParams.getComplexChannel();
+        assertThat(complexChannel).isNotNull();
+        assertEquals(complexChannel.getChannel(), 9);
+        assertEquals(complexChannel.getPreambleIndex(), 11);
+
+        BleCsRangingParams bleCsRangingParams = device.getCsRangingParams();
+        assertThat(bleCsRangingParams).isNotNull();
+        assertThat(bleCsRangingParams.getPeerBluetoothAddress()).isNotNull();
+        assertEquals(bleCsRangingParams.getSightType(), 1);
+        assertEquals(bleCsRangingParams.getSecurityLevel(), 1);
+        assertEquals(bleCsRangingParams.getLocationType(), LOCATION_TYPE_INDOOR);
+        assertEquals(bleCsRangingParams.getRangingUpdateRate(), UPDATE_RATE_NORMAL);
+
+        BleRssiRangingParams bleRssiRangingParams = device.getBleRssiRangingParams();
+        assertThat(bleRssiRangingParams).isNotNull();
+        assertThat(bleRssiRangingParams.getPeerBluetoothAddress()).isNotNull();
+        assertEquals(bleRssiRangingParams.getRangingUpdateRate(), UPDATE_RATE_NORMAL);
+
+        RttRangingParams rttRangingParams = device.getRttRangingParams();
+        assertThat(rttRangingParams).isNotNull();
+        assertThat(rttRangingParams.getMatchFilter()).isNotNull();
+        assertThat(rttRangingParams.getServiceName()).isNotNull();
+        assertFalse(rttRangingParams.isPeriodicRangingHwFeatureEnabled());
+        assertEquals(rttRangingParams.getRangingUpdateRate(), UPDATE_RATE_NORMAL);
+
+        mRangingSession.start(rangingPreference);
+        verify(mMockRangingAdapter, times(1)).startRanging(any(), any(), any(), any());
+
+        mRangingSession.reconfigureRangingInterval(10);
+        verify(mMockRangingAdapter, times(1)).reconfigureRangingInterval(any(), eq(10));
+
+        mRangingSession.removeDeviceFromRangingSession(new RangingDevice.Builder().build());
+        verify(mMockRangingAdapter, times(1)).removeDevice(any(), any());
+
+        RawRangingDevice rawRangingDevice = new RawRangingDevice.Builder()
+                .setRangingDevice(new RangingDevice.Builder().build())
+                        .setUwbRangingParams(device.getUwbRangingParams())
+                                .build();
+        mRangingSession.addDeviceToRangingSession(new RawResponderRangingConfig.Builder()
+                .setRawRangingDevice(rawRangingDevice).build());
+        verify(mMockRangingAdapter, times(1)).addRawDevice(any(), any());
+
+        mRangingSession.stop();
+        verify(mMockRangingAdapter, times(1)).stopRanging(any());
+
+    }
+
+    @Test
+    public void testRawRangingResponderSession() throws RemoteException {
+        RangingPreference rangingPreference = getGenericResponderRangingPreference();
+        assertThat(rangingPreference).isNotNull();
+        SessionConfig sessionConfig = rangingPreference.getSessionConfig();
+        assertThat(sessionConfig).isNotNull();
+
+        RangingConfig rangingConfig = rangingPreference.getRangingParams();
+        assertThat(rangingConfig).isNotNull();
+        assertEquals(rangingConfig.getRangingSessionType(), RANGING_SESSION_RAW);
+        if (!(rangingConfig instanceof RawResponderRangingConfig)) {
+            fail();
+        }
+        RawResponderRangingConfig config = (RawResponderRangingConfig) rangingConfig;
+        assertThat(config.getRawRangingDevice()).isNotNull();
+        RawRangingDevice device = config.getRawRangingDevice();
+        assertThat(device).isNotNull();
+
+        BleRssiRangingParams bleRssiRangingParams = device.getBleRssiRangingParams();
+        assertThat(bleRssiRangingParams).isNotNull();
+        assertThat(bleRssiRangingParams.getPeerBluetoothAddress()).isNotNull();
+
+        mRangingSession.start(rangingPreference);
+        verify(mMockRangingAdapter, times(1)).startRanging(any(), any(), any(), any());
+
+        mRangingSession.close();
+        verify(mMockRangingAdapter, times(1)).stopRanging(any());
+    }
+
+    @Test
+    public void testOobRangingResponderSession() throws RemoteException {
+        RangingPreference rangingPreference = getGenericOobResponderRangingPreference();
+        assertThat(rangingPreference).isNotNull();
+        SessionConfig sessionConfig = rangingPreference.getSessionConfig();
+        assertThat(sessionConfig).isNotNull();
+
+        RangingConfig rangingConfig = rangingPreference.getRangingParams();
+        assertThat(rangingConfig).isNotNull();
+        assertEquals(rangingConfig.getRangingSessionType(), RANGING_SESSION_OOB);
+        if (!(rangingConfig instanceof OobResponderRangingConfig)) {
+            fail();
+        }
+        OobResponderRangingConfig config = (OobResponderRangingConfig) rangingConfig;
+        assertThat(config.getDeviceHandle()).isNotNull();
+
+        mRangingSession.start(rangingPreference);
+        verify(mMockRangingAdapter, times(1)).startRanging(any(), any(), any(), any());
+    }
+
+    @Test
+    public void testOobRangingInitiatorSession() throws RemoteException {
+        RangingPreference rangingPreference = getGenericOobInitiatorRangingPreference();
+        assertThat(rangingPreference).isNotNull();
+        SessionConfig sessionConfig = rangingPreference.getSessionConfig();
+        assertThat(sessionConfig).isNotNull();
+
+        RangingConfig rangingConfig = rangingPreference.getRangingParams();
+        assertThat(rangingConfig).isNotNull();
+        assertEquals(rangingConfig.getRangingSessionType(), RANGING_SESSION_OOB);
+        if (!(rangingConfig instanceof OobInitiatorRangingConfig)) {
+            fail();
+        }
+        OobInitiatorRangingConfig config = (OobInitiatorRangingConfig) rangingConfig;
+        assertThat(config.getDeviceHandles()).isNotNull();
+        assertEquals(config.getSecurityLevel(), SECURITY_LEVEL_BASIC);
+        assertEquals(config.getRangingMode(), RANGING_MODE_AUTO);
+        assertEquals(config.getFastestRangingInterval(), Duration.ofMillis(240));
+        assertEquals(config.getSlowestRangingInterval(), Duration.ofMillis(1000));
+
+        mRangingSession.start(rangingPreference);
+        verify(mMockRangingAdapter, times(1)).startRanging(any(), any(), any(), any());
+
+        mRangingSession.addDeviceToRangingSession(new OobResponderRangingConfig.Builder(
+                new DeviceHandle.Builder(new RangingDevice.Builder().build(),
+                        mock(TransportHandle.class))
+                        .build())
+                .build());
+
+        // Dynamic addition of responder is not yet supported for OOB.
+        verify(mMockRangingAdapter, times(0)).addOobDevice(any(), any());
+    }
+
+    @Test
+    public void testRangingCapabilities() throws RemoteException {
+        RangingManager.RangingCapabilitiesCallback callback = mock(
+                RangingManager.RangingCapabilitiesCallback.class);
+        mRangingManager.registerCapabilitiesCallback(getExecutor(), callback);
+        verify(mMockRangingAdapter, times(1)).registerCapabilitiesCallback(any());
+
+        mRangingManager.unregisterCapabilitiesCallback(callback);
+        verify(mMockRangingAdapter, times(1)).unregisterCapabilitiesCallback(any());
+
+        RangingCapabilities rangingCapabilities = new RangingCapabilities.Builder()
+                .addCapabilities(new UwbRangingCapabilities.Builder()
+                        .setSupportsDistance(true)
+                        .setSupportsAzimuthalAngle(true)
+                        .setSupportsElevationAngle(true)
+                        .setSupportsRangingIntervalReconfigure(true)
+                        .setMinRangingInterval(Duration.ofMillis(96))
+                        .setSupportedChannels(new ArrayList<>())
+                        .setSupportedRangingUpdateRates(new ArrayList<>())
+                        .setSupportedNtfConfigs(new ArrayList<>())
+                        .setSupportedPreambleIndexes(new ArrayList<>())
+                        .setSupportedPreambleIndexes(new ArrayList<>())
+                        .setSupportedConfigIds(new ArrayList<>())
+                        .setSupportedConfigIds(new ArrayList<>())
+                        .setSupportedSlotDurations(new ArrayList<>())
+                        .setHasBackgroundRangingSupport(true)
+                        .build())
+                .addCapabilities(new BleCsRangingCapabilities.Builder()
+                        .setSupportedSecurityLevels(new ArrayList<>())
+                        .build())
+                .addCapabilities(new RttRangingCapabilities.Builder()
+                        .setPeriodicRangingHardwareFeature(true)
+                        .build())
+                .addAvailability(RangingManager.UWB, RangingCapabilities.ENABLED)
+                .addAvailability(RangingManager.BLE_CS, RangingCapabilities.ENABLED)
+                .addAvailability(RangingManager.WIFI_NAN_RTT, RangingCapabilities.ENABLED)
+                .addAvailability(RangingManager.BLE_RSSI, RangingCapabilities.ENABLED)
+                .build();
+
+        assertThat(rangingCapabilities.getUwbCapabilities()).isNotNull();
+        UwbRangingCapabilities uwbRangingCapabilities = rangingCapabilities.getUwbCapabilities();
+
+        assertTrue(uwbRangingCapabilities.isDistanceMeasurementSupported());
+        assertTrue(uwbRangingCapabilities.isAzimuthalAngleSupported());
+        assertTrue(uwbRangingCapabilities.isElevationAngleSupported());
+        assertTrue(uwbRangingCapabilities.isBackgroundRangingSupported());
+        assertTrue(uwbRangingCapabilities.isRangingIntervalReconfigurationSupported());
+        assertThat(uwbRangingCapabilities.getSupportedRangingUpdateRates()).isNotNull();
+        assertThat(uwbRangingCapabilities.getSupportedChannels()).isNotNull();
+        assertThat(uwbRangingCapabilities.getSupportedSlotDurations()).isNotNull();
+        assertThat(uwbRangingCapabilities.getSupportedPreambleIndexes()).isNotNull();
+        assertThat(uwbRangingCapabilities.getSupportedNotificationConfigurations()).isNotNull();
+        assertThat(uwbRangingCapabilities.getSupportedConfigIds()).isNotNull();
+        assertEquals(uwbRangingCapabilities.getMinimumRangingInterval(), Duration.ofMillis(96));
+
+        assertThat(rangingCapabilities.getCsCapabilities()).isNotNull();
+        BleCsRangingCapabilities bleCsRangingCapabilities = rangingCapabilities.getCsCapabilities();
+        assertThat(bleCsRangingCapabilities.getSupportedSecurityLevels()).isNotNull();
+
+        assertThat(rangingCapabilities.getRttRangingCapabilities()).isNotNull();
+        RttRangingCapabilities rttRangingCapabilities =
+                rangingCapabilities.getRttRangingCapabilities();
+        assertTrue(rttRangingCapabilities.hasPeriodicRangingHardwareFeature());
+
+        assertEquals(
+                rangingCapabilities.getTechnologyAvailability().getOrDefault(RangingManager.UWB,
+                        RangingCapabilities.NOT_SUPPORTED).intValue(), RangingCapabilities.ENABLED);
+        assertEquals(
+                rangingCapabilities.getTechnologyAvailability().getOrDefault(RangingManager.BLE_CS,
+                        RangingCapabilities.NOT_SUPPORTED).intValue(), RangingCapabilities.ENABLED);
+        assertEquals(
+                rangingCapabilities.getTechnologyAvailability().getOrDefault(
+                        RangingManager.WIFI_NAN_RTT,
+                        RangingCapabilities.NOT_SUPPORTED).intValue(), RangingCapabilities.ENABLED);
+        assertEquals(
+                rangingCapabilities.getTechnologyAvailability().getOrDefault(
+                        RangingManager.BLE_RSSI,
+                        RangingCapabilities.NOT_SUPPORTED).intValue(), RangingCapabilities.ENABLED);
+
+    }
+
+    private static Executor getExecutor() {
+        return Runnable::run;
+    }
+}
diff --git a/ranging/rtt_backend/Android.bp b/ranging/rtt_backend/Android.bp
index 0bf557bf..d3f21210 100644
--- a/ranging/rtt_backend/Android.bp
+++ b/ranging/rtt_backend/Android.bp
@@ -19,16 +19,17 @@ package {
 
 java_library {
     name: "ranging_rtt_backend",
-    sdk_version: "system_UpsideDownCake",
+    sdk_version: "system_current",
     min_sdk_version: "33",
     installable: false,
     srcs: [
         "src/**/*.java",
     ],
-    //libs: ["android-support-annotations"],
-    static_libs: [
+    libs: [
         "androidx.annotation_annotation",
-        "androidx.concurrent_concurrent-futures",
+        "framework-wifi.stubs.system",
+    ],
+    static_libs: [
         "guava",
     ],
     apex_available: [
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttDevice.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttDevice.java
similarity index 87%
rename from ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttDevice.java
rename to ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttDevice.java
index f698bdcf..30655e42 100644
--- a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttDevice.java
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttDevice.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.ranging.rtt.backend.internal;
+package com.android.ranging.rtt.backend;
 
 /*
  * Represents a RTT device.
@@ -29,13 +29,19 @@ import java.util.Arrays;
 public class RttDevice {
 
     private final RttRangingDevice mRttRangingDevice;
-    private RttAddress mAddress;
+    private final RttAddress mAddress;
+
+    public RttRangingDevice getRttRangingDevice() {
+        return mRttRangingDevice;
+    }
 
     /**
      * Ranging Device for Wifi RTT
      *
      * @param rttRangingDevice RttRangingDevices
      */
+
+
     public RttDevice(RttRangingDevice rttRangingDevice) {
         mRttRangingDevice = rttRangingDevice;
         mAddress = new RttAddress(new byte[]{});
@@ -45,10 +51,6 @@ public class RttDevice {
         return mAddress;
     }
 
-    public void setAddress(String addressStr) {
-        mAddress = new RttAddress(addressStr);
-    }
-
     @Override
     public int hashCode() {
         return Arrays.hashCode(mAddress.toBytes());
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRanger.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRanger.java
similarity index 53%
rename from ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRanger.java
rename to ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRanger.java
index 55598751..f41e0b5b 100644
--- a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRanger.java
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRanger.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,21 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.android.ranging.rtt.backend.internal;
+package com.android.ranging.rtt.backend;
 
+import android.app.AlarmManager;
+import android.content.Context;
 import android.net.wifi.aware.PeerHandle;
 import android.net.wifi.rtt.RangingRequest;
 import android.net.wifi.rtt.RangingResult;
 import android.net.wifi.rtt.RangingResultCallback;
 import android.net.wifi.rtt.WifiRttManager;
+import android.os.SystemClock;
 import android.util.Log;
 
 import androidx.annotation.NonNull;
 
 import java.util.List;
+import java.util.Objects;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicLong;
 
-/** Ranges to a given WiFi Aware Peer handle. */
+/**
+ * Ranges to a given WiFi Aware Peer handle.
+ * Rtt Ranger is only used for legacy RTT sessions on devices that do not support the new periodic
+ * rtt API.
+ */
 public class RttRanger {
     private static final String TAG = RttRanger.class.getName();
 
@@ -39,13 +48,24 @@ public class RttRanger {
 
     private boolean mIsRunning;
 
-    public RttRanger(WifiRttManager wiFiRttManager, Executor executor) {
+    private final AlarmManager mAlarmManager;
+    private int mBaseUpdateRateMs = 512;
+    private int mCurrentUpdateRateMs = 512;
+    private AlarmManager.OnAlarmListener mAlarmListener;
+    private int mRangingRequestDelay = 500;
+    private AtomicLong mLastRangingRequestTimestamp;
+
+    public RttRanger(WifiRttManager wiFiRttManager, Executor executor, Context context) {
         this.mExecutor = executor;
         this.mWifiRttManager = wiFiRttManager;
+        mAlarmManager = context.getSystemService(AlarmManager.class);
+        mLastRangingRequestTimestamp = new AtomicLong(SystemClock.elapsedRealtime());
+        Objects.requireNonNull(mAlarmManager);
     }
 
     public void startRanging(@NonNull PeerHandle peerHandle,
-            @NonNull RttRangerListener rttRangerListener) {
+            @NonNull RttRangerListener rttRangerListener, int updateRateMs,
+            int rangingRequestDelay) {
         if (mIsRunning) {
             Log.w(TAG, "startRanging - already running");
             return;
@@ -53,7 +73,14 @@ public class RttRanger {
         mIsRunning = true;
         this.mPeerHandle = peerHandle;
         this.mRttRangerListener = rttRangerListener;
-        startRangingInternal();
+        mBaseUpdateRateMs = updateRateMs;
+        mCurrentUpdateRateMs = mBaseUpdateRateMs;
+        mRangingRequestDelay = rangingRequestDelay;
+        setPeriodicAlarm(rangingRequestDelay);
+    }
+
+    public void reconfigureInterval(int intervalSkipCount) {
+        mCurrentUpdateRateMs = (mBaseUpdateRateMs * intervalSkipCount) + mBaseUpdateRateMs;
     }
 
     private void startRangingInternal() {
@@ -64,14 +91,39 @@ public class RttRanger {
                     RttRangerListener.STATUS_CODE_FAIL_RTT_NOT_AVAILABLE);
             return;
         }
+        mLastRangingRequestTimestamp = new AtomicLong(SystemClock.elapsedRealtime());
         mWifiRttManager.startRanging(
                 new RangingRequest.Builder().addWifiAwarePeer(mPeerHandle).build(),
                 mExecutor,
                 mRangingResultCallback);
     }
 
+    private void setPeriodicAlarm(long nextRequestTime) {
+        if (mAlarmListener != null) {
+            mAlarmManager.cancel(mAlarmListener);
+        }
+        if (nextRequestTime == 0) {
+            startRangingInternal();
+            return;
+        }
+        mAlarmListener = () -> {
+            mExecutor.execute(this::startRangingInternal);
+        };
+        mAlarmManager.setExact(
+                AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                SystemClock.elapsedRealtime() + nextRequestTime,
+                "RttRangingInterval",
+                mAlarmListener,
+                null
+        );
+    }
+
     public void stopRanging() {
         mIsRunning = false;
+        if (mAlarmListener != null) {
+            mAlarmManager.cancel(mAlarmListener);
+            mAlarmListener = null;
+        }
     }
 
     private final RangingResultCallback mRangingResultCallback = new RangingResultCallback() {
@@ -83,45 +135,15 @@ public class RttRanger {
 
         @Override
         public void onRangingResults(List<RangingResult> results) {
-            if (results == null) {
-                Log.w(TAG, "Rtt Ranging result is null");
-                return;
-            }
+            setPeriodicAlarm(Math.max(mRangingRequestDelay,
+                    mCurrentUpdateRateMs - (SystemClock.elapsedRealtime()
+                            - mLastRangingRequestTimestamp.get())));
             Log.i(TAG, "RTT ranging results: " + results);
             if (mRttRangerListener == null) {
                 Log.w(TAG, "Rtt Ranging Listener is null");
                 return;
             }
-
-            if (results.isEmpty()) {
-                mRttRangerListener.onRangingFailure(
-                        RttRangerListener.STATUS_CODE_FAIL_RESULT_EMPTY);
-                return;
-            }
-
-            RangingResult result = results.get(0);
-            int status = result.getStatus();
-
-            if (status == RangingResult.STATUS_RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC) {
-                Log.w(TAG, "Responder does not support 11mc");
-                mRttRangerListener.onRangingFailure(
-                        RttRangerListener.STATUS_CODE_FAIL_RTT_NOT_AVAILABLE);
-                return;
-            } else if (status == RangingResult.UNSPECIFIED) {
-                Log.w(TAG, "Unspecified failed.");
-                mRttRangerListener.onRangingFailure(
-                        RttRangerListener.STATUS_CODE_FAIL_RTT_NOT_AVAILABLE);
-                return;
-            } else if (status == RangingResult.STATUS_FAIL) {
-                mRttRangerListener.onRangingFailure(
-                        RttRangerListener.STATUS_CODE_FAIL_RESULT_FAIL);
-            } else if (status == RangingResult.STATUS_SUCCESS) {
-                mRttRangerListener.onRangingResult(result);
-            }
-
-            if (mIsRunning) {
-                startRangingInternal();
-            }
+            mRttRangerListener.onRangingResults(results);
         }
     };
 
@@ -131,9 +153,10 @@ public class RttRanger {
         int STATUS_CODE_FAIL_RTT_NOT_AVAILABLE = 2;
         int STATUS_CODE_FAIL_RESULT_EMPTY = 3;
         int STATUS_CODE_FAIL_RESULT_FAIL = 4;
+        int STATUS_CODE_ERROR_STREAK_TIMEOUT = 5;
 
         void onRangingFailure(int code);
 
-        void onRangingResult(RangingResult results);
+        void onRangingResults(List<RangingResult> results);
     }
 }
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingDevice.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingDevice.java
similarity index 61%
rename from ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingDevice.java
rename to ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingDevice.java
index 339174f0..a4acba0f 100644
--- a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingDevice.java
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingDevice.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,15 @@
  * limitations under the License.
  */
 
-package com.android.ranging.rtt.backend.internal;
+package com.android.ranging.rtt.backend;
 
-import static com.android.ranging.rtt.backend.internal.RttRangingSessionCallback.REASON_STOP_RANGING_CALLED;
+import static com.android.ranging.rtt.backend.RttRangingSessionCallback.REASON_RTT_NOT_AVAILABLE;
+import static com.android.ranging.rtt.backend.RttRangingSessionCallback.REASON_STOP_RANGING_CALLED;
+import static com.android.ranging.rtt.backend.RttRangingSessionCallback.REASON_UNKNOWN;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.net.wifi.aware.AttachCallback;
 import android.net.wifi.aware.DiscoverySessionCallback;
@@ -39,11 +42,12 @@ import android.util.Log;
 
 import androidx.annotation.NonNull;
 
-import com.android.ranging.rtt.backend.internal.RttRanger.RttRangerListener;
+import com.android.ranging.rtt.backend.RttRanger.RttRangerListener;
 
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Class for interacting with nearby RTT devices to perform ranging.
@@ -51,6 +55,7 @@ import java.util.concurrent.ExecutorService;
 public class RttRangingDevice {
     private static final String TAG = RttRangingDevice.class.getName();
     private static final int GRAPI_RTT_MESSAGE_ID = 1;
+    private static final int MAX_RANGING_RESULT_ERROR_STREAK = 5;
     private final Handler mHandler;
     private final WifiAwareManager mWifiAwareManager;
     private WifiAwareSession mWifiAwareSession;
@@ -67,52 +72,82 @@ public class RttRangingDevice {
     private boolean mIsRunning;
     private final Object mLock = new Object();
     private final WifiRttManager mWifiRttManager;
+    private int mRangingRequestDelay = 500;
+    private AtomicInteger mResultErrorStreak;
+
+    public RttRangingParameters getRttRangingParameters() {
+        return mRttRangingParameters;
+    }
 
     /** Listener for range results. */
     private RttRangerListener mRttRangingListener = new RttRangerListener() {
         @Override
         public void onRangingFailure(int code) {
             switch (code) {
-                case STATUS_CODE_FAIL:
-                    Log.w(TAG, "Failed to range");
-                    break;
-
-                case STATUS_CODE_FAIL_RESULT_EMPTY:
-                    Log.i(TAG, "Range results are empty");
+                case STATUS_CODE_FAIL -> Log.w(TAG, "Failed to range");
+                case STATUS_CODE_FAIL_RESULT_EMPTY -> Log.i(TAG, "Range results are empty");
+                case STATUS_CODE_FAIL_RTT_NOT_AVAILABLE -> {
+                    Log.w(TAG, "RTT Not Available");
                     synchronized (mLock) {
-//                        if (mRttListener != null) {
-//                            mRttListener.onRangingSuspended(mRttDevice,
-//                                    RttRangingSessionCallback.REASON_RTT_NOT_AVAILABLE);
-//                        }
+                        if (mRttListener != null) {
+                            mRttListener.onRangingSuspended(mRttDevice,
+                                    REASON_RTT_NOT_AVAILABLE);
+                        }
                         stopRanging();
                     }
-                    break;
-                case STATUS_CODE_FAIL_RTT_NOT_AVAILABLE:
-                    Log.w(TAG, "RTT Not Available");
+                }
+                case STATUS_CODE_ERROR_STREAK_TIMEOUT -> {
+                    Log.w(TAG, "Ranging result error streak timeout");
                     synchronized (mLock) {
-//                        if (mRttListener != null) {
-//                            mRttListener.onRangingSuspended(mRttDevice,
-//                                    RttRangingSessionCallback.REASON_RTT_NOT_AVAILABLE);
-//                        }
+                        if (mRttListener != null) {
+                            mRttListener.onRangingSuspended(mRttDevice,
+                                    RttRangingSessionCallback.REASON_SYSTEM_POLICY);
+                        }
                         stopRanging();
                     }
-                    break;
+                }
             }
         }
 
         @Override
-        public void onRangingResult(RangingResult result) {
+        public void onRangingResults(List<RangingResult> results) {
+            if (results == null || results.isEmpty()) {
+                onRangingFailure(RttRangerListener.STATUS_CODE_FAIL_RESULT_EMPTY);
+                return;
+            }
+            RangingResult result = results.get(0);
+            int status = result.getStatus();
+            if (status != RangingResult.STATUS_SUCCESS) {
+                if (mResultErrorStreak.incrementAndGet() >= MAX_RANGING_RESULT_ERROR_STREAK) {
+                    onRangingFailure(RttRangerListener.STATUS_CODE_ERROR_STREAK_TIMEOUT);
+                }
+                return;
+            }
+            if (status == RangingResult.STATUS_RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC) {
+                Log.w(TAG, "Responder does not support 11mc");
+                onRangingFailure(RttRangerListener.STATUS_CODE_FAIL_RTT_NOT_AVAILABLE);
+                return;
+            } else if (status == RangingResult.UNSPECIFIED) {
+                Log.w(TAG, "Unspecified failed.");
+                onRangingFailure(RttRangerListener.STATUS_CODE_FAIL_RTT_NOT_AVAILABLE);
+                return;
+            } else if (status == RangingResult.STATUS_FAIL) {
+                onRangingFailure(RttRangerListener.STATUS_CODE_FAIL_RESULT_FAIL);
+                return;
+            }
             if (!mIsRunning) {
                 Log.w(TAG, "onRangingResult - ranging has stopped already.");
                 stopRanging();
                 return;
             }
 
+            mResultErrorStreak.set(0);
             PeerHandle peerHandle = result.getPeerHandle();
             if (mPeerHandle.equals(peerHandle)) {
                 synchronized (mLock) {
                     if (mRttListener != null) {
-                        mRttListener.onRangingResult(mRttDevice, new RttRangingPosition(result));
+                        mRttListener.onRangingResult(mRttDevice,
+                                new RttRangingPosition(result));
                     }
                 }
                 Log.i(TAG, "callback onRangingResult");
@@ -123,22 +158,6 @@ public class RttRangingDevice {
         }
     };
 
-    private Runnable mRunnablePingPublisher = new Runnable() {
-        @Override
-        public void run() {
-            synchronized (mLock) {
-                if (!mIsRunning) {
-                    Log.w(TAG, "RttRangingDevice is not running");
-                    return;
-                }
-                if (mRttListener != null) {
-                    mRttListener.onRangingResult(mRttDevice, new RttRangingPosition());
-                }
-                pingPublisher();
-            }
-        }
-    };
-
     public RttRangingDevice(@NonNull Context context, @NonNull DeviceType deviceType) {
         mContext = context;
         mDeviceType = deviceType;
@@ -146,15 +165,20 @@ public class RttRangingDevice {
         mHandler = new Handler(Looper.getMainLooper());
         mWifiAwareManager = context.getSystemService(WifiAwareManager.class);
         mWifiRttManager = context.getSystemService(WifiRttManager.class);
-        mRttRanger = new RttRanger(mWifiRttManager, mHandler::post);
+        mRttRanger = new RttRanger(mWifiRttManager, mHandler::post, context);
         mRttDevice = new RttDevice(this);
         mIsRunning = false;
+        mResultErrorStreak = new AtomicInteger(0);
     }
 
     public void setRangingParameters(@NonNull RttRangingParameters rttRangingParameters) {
         this.mRttRangingParameters = rttRangingParameters;
     }
 
+    public void setRangingRequestDelay(int rangingRequestDelay) {
+        mRangingRequestDelay = rangingRequestDelay;
+    }
+
     public void startRanging(@NonNull RttRangingSessionCallback rttListener,
             ExecutorService executorService) {
         Log.i(TAG, "Start ranging");
@@ -175,31 +199,39 @@ public class RttRangingDevice {
             }
             mIsRunning = true;
             mRttListener = rttListener;
-            mWifiAwareManager.attach(new AwareAttachCallback(mDeviceType, mRttRangingParameters),
-                    mHandler);
+            executorService.execute(() -> mWifiAwareManager.attach(
+                    new AwareAttachCallback(mDeviceType, mRttRangingParameters), mHandler));
         }
     }
 
-    public void stopRanging() {
-        Log.i(TAG, "Closing WiFi aware session");
+    public void reconfigureRangingInterval(int intervalSkipCount) {
+        if (!mRttRangingParameters.isPeriodicRangingHwFeatureEnabled()) {
+            mRttRanger.reconfigureInterval(intervalSkipCount);
+        } else {
+            Log.e(TAG, "Reconfiguration of ranging interval unsupported for HW periodic ranging");
+        }
+    }
 
+    public void stopRanging() {
         synchronized (mLock) {
             if (!mIsRunning) {
                 Log.w(TAG, "This client has stopped ranging already");
                 return;
             }
+            Log.i(TAG, "Closing WiFi aware session");
             mIsRunning = false;
             mRttRanger.stopRanging();
-            mHandler.removeCallbacks(mRunnablePingPublisher);
 
             if (mWifiAwareSession != null) {
                 mWifiAwareSession.close();
                 mWifiAwareSession = null;
+            } else {
+                Log.e(TAG, "Wifi aware session is null");
+                mRttListener.onRangingSuspended(mRttDevice, REASON_STOP_RANGING_CALLED);
             }
             mCurrentPublishDiscoverySession = null;
             mCurrentSubscribeDiscoverySession = null;
         }
-
     }
 
     private void notifyPeer(PeerHandle peerHandle, byte[] message) {
@@ -211,12 +243,6 @@ public class RttRangingDevice {
         }
     }
 
-    private void pingPublisher() {
-//        Log.i(TAG, "Publisher ping");
-//        mHandler.postDelayed(mRunnablePingPublisher,
-//                mRttRangingParameters.getPublisherPingDuration().toMillis());
-    }
-
     private DiscoverySessionCallback createPublishDiscoverySessionCallback() {
         return new DiscoverySessionCallback() {
             @Override
@@ -239,11 +265,12 @@ public class RttRangingDevice {
                     mPeerHandle = peerHandle; // Initialize mPeerHandle at publisher side.
                 }
 
-                if (mRttRangingParameters.getEnablePublisherRanging()) {
-                    mRttListener.onRangingInitialized(mRttDevice);
-                    mRttRanger.startRanging(peerHandle, mRttRangingListener);
-                } else {
-                    pingPublisher();
+                int updateRateMs = RttRangingParameters.getIntervalMs(mRttRangingParameters);
+                mRttListener.onRangingInitialized(mRttDevice);
+                if (!mRttRangingParameters.isPeriodicRangingHwFeatureEnabled()
+                        && !mRttRangingParameters.isRangeDataNtfDisabled()) {
+                    mRttRanger.startRanging(peerHandle, mRttRangingListener, updateRateMs,
+                            mRangingRequestDelay);
                 }
             }
 
@@ -254,6 +281,12 @@ public class RttRangingDevice {
                 mRttListener.onRangingSuspended(mRttDevice, REASON_STOP_RANGING_CALLED);
                 mRttListener = null;
             }
+
+            @Override
+            public void onServiceLost(PeerHandle peerHandle, int reason) {
+                Log.v(TAG, "onServiceLost peerHandle " + peerHandle + " reason " + reason);
+                mRttListener.onRangingSuspended(mRttDevice, REASON_UNKNOWN);
+            }
         };
     }
 
@@ -282,20 +315,42 @@ public class RttRangingDevice {
                     List<byte[]> matchFilter,
                     int distanceMm) {
                 Log.i(TAG,
-                        "onServiceDiscovered, peerHandle= " + peerHandle + ", initial distanceMm= "
-                                + distanceMm);
+                        "onServiceDiscoveredWithinRange, peerHandle= " + peerHandle
+                                + ", initial distanceMm= " + distanceMm);
+                onPeerHandleReceived(peerHandle);
+            }
+
+            @Override
+            public void onServiceDiscovered(PeerHandle peerHandle,
+                    byte[] serviceSpecificInfo, List<byte[]> matchFilter) {
+                Log.i(TAG,
+                        "onServiceDiscovered, peerHandle= " + peerHandle);
+                onPeerHandleReceived(peerHandle);
+            }
 
+            private void onPeerHandleReceived(PeerHandle peerHandle) {
                 mPeerHandle = peerHandle;
                 notifyPeer(peerHandle, Build.MODEL.getBytes(UTF_8));
 
                 if (mRttListener != null) {
+                    int updateRateMs = RttRangingParameters.getIntervalMs(mRttRangingParameters);
                     mRttListener.onRangingInitialized(mRttDevice);
-                    mRttRanger.startRanging(peerHandle, mRttRangingListener);
+                    // Rtt Ranger is only used for legacy RTT sessions.
+                    if (!mRttRangingParameters.isPeriodicRangingHwFeatureEnabled()) {
+                        mRttRanger.startRanging(peerHandle, mRttRangingListener, updateRateMs,
+                                mRangingRequestDelay);
+                    }
                 } else {
                     Log.e(TAG, "Rtt Listener is null");
                 }
             }
 
+            @Override
+            public void onRangingResultsReceived(List<RangingResult> results) {
+                Log.i(TAG, "RTT ranging results: " + results);
+                mRttRangingListener.onRangingResults(results);
+            }
+
             @Override
             public void onSessionTerminated() {
                 Log.i(TAG, "onSession Terminated. ");
@@ -303,9 +358,16 @@ public class RttRangingDevice {
                 mRttListener.onRangingSuspended(mRttDevice, REASON_STOP_RANGING_CALLED);
                 mRttListener = null;
             }
+
+            @Override
+            public void onServiceLost(PeerHandle peerHandle, int reason) {
+                Log.v(TAG, "onServiceLost peerHandle " + peerHandle + " reason " + reason);
+                mRttListener.onRangingSuspended(mRttDevice, REASON_UNKNOWN);
+            }
         };
     }
 
+    @SuppressLint("NewApi") // FLAG_RANGING_RTT_ENABLED will be enabled from Android 16.
     private class AwareAttachCallback extends AttachCallback {
         private final PublishConfig mPublishConfig;
         private final SubscribeConfig mSubscribeConfig;
@@ -323,17 +385,27 @@ public class RttRangingDevice {
                         .setServiceName(rttRangingParameters.getServiceName())
                         .setRangingEnabled(true)
                         .setTerminateNotificationEnabled(true)
+                        .setPeriodicRangingResultsEnabled(
+                                rttRangingParameters.isPeriodicRangingHwFeatureEnabled())
                         .build();
                 mSubscribeConfig = null;
             } else if (deviceType == DeviceType.SUBSCRIBER) {
-                mSubscribeConfig = new SubscribeConfig.Builder()
+                SubscribeConfig.Builder builder = new SubscribeConfig.Builder()
                         .setMatchFilter(
                                 Collections.singletonList(rttRangingParameters.getMatchFilter()))
                         .setServiceName(rttRangingParameters.getServiceName())
-                        .setMaxDistanceMm(rttRangingParameters.getMaxDistanceMm())
-                        .setMinDistanceMm(rttRangingParameters.getMinDistanceMm())
-                        .setTerminateNotificationEnabled(true)
-                        .build();
+                        .setTerminateNotificationEnabled(true);
+
+                if (rttRangingParameters.isPeriodicRangingHwFeatureEnabled()) {
+                    builder.setPeriodicRangingInterval(
+                                    RttRangingParameters.getIntervalMs(rttRangingParameters))
+                            .setPeriodicRangingEnabled(true);
+                } else {
+                    // Geofence is not supported when using rtt periodic ranging.
+                    builder.setMaxDistanceMm(rttRangingParameters.getMaxDistanceMm())
+                            .setMinDistanceMm(rttRangingParameters.getMinDistanceMm());
+                }
+                mSubscribeConfig = builder.build();
                 mPublishConfig = null;
             } else {
                 Log.w(TAG, "Unknown deviceType");
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingParameters.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingParameters.java
similarity index 64%
rename from ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingParameters.java
rename to ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingParameters.java
index 9e5ba561..7c40b638 100644
--- a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingParameters.java
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingParameters.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,14 +14,13 @@
  * limitations under the License.
  */
 
-package com.android.ranging.rtt.backend.internal;
+package com.android.ranging.rtt.backend;
 
 import androidx.annotation.IntDef;
 import androidx.annotation.NonNull;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
-import java.time.Duration;
 import java.util.Arrays;
 
 public class RttRangingParameters {
@@ -36,6 +35,28 @@ public class RttRangingParameters {
         int SUBSCRIBER = 1;
     }
 
+    @IntDef({
+            INFREQUENT,
+            NORMAL,
+            FAST,
+    })
+    public @interface RangingUpdateRate {}
+
+    /**
+     * Requests for ranging data in 512 milliseconds
+     */
+    public static final int NORMAL = 1;
+
+    /**
+     * Requests for ranging data in 8192 milliseconds
+     */
+    public static final int INFREQUENT = 2;
+
+    /**
+     * Requests for ranging data in 256 milliseconds
+     */
+    public static final int FAST = 3;
+
     private final @DeviceRole int mDeviceRole;
     /**
      * Returns Service ID for WiFi Aware
@@ -45,8 +66,13 @@ public class RttRangingParameters {
     protected final String mServiceName;
     protected final int mMaxDistanceMm;
     protected final int mMinDistanceMm;
-    protected final boolean mEnablePublisherRanging;
-    protected final Duration mPublisherPingDuration;
+
+    @RangingUpdateRate
+    private final int mUpdateRate;
+
+    private final boolean mEnablePeriodicRangingHwFeature;
+
+    private final boolean mRangeDataNtfDisabled;
 
     public int getDeviceRole() {
         return mDeviceRole;
@@ -97,23 +123,16 @@ public class RttRangingParameters {
         return mMinDistanceMm;
     }
 
-    /**
-     * If it is a publisher type, get whether a publisher will range.
-     *
-     * @return whether a publisher will range.
-     */
-    public boolean getEnablePublisherRanging() {
-        return mEnablePublisherRanging;
+    public int getUpdateRate() {
+        return mUpdateRate;
     }
 
-    /**
-     * If it is a publisher type, get whether to return a empty ping value by itself to maintain
-     * connection.
-     *
-     * @return whether to return a empty ping value by itself to maintain connection.
-     */
-    public Duration getPublisherPingDuration() {
-        return mPublisherPingDuration;
+    public boolean isPeriodicRangingHwFeatureEnabled() {
+        return mEnablePeriodicRangingHwFeature;
+    }
+
+    public boolean isRangeDataNtfDisabled() {
+        return mRangeDataNtfDisabled;
     }
 
     public RttRangingParameters(Builder builder) {
@@ -123,8 +142,9 @@ public class RttRangingParameters {
         mMatchFilter = builder.mMatchFilter;
         mMaxDistanceMm = builder.mMaxDistanceMm;
         mMinDistanceMm = builder.mMinDistanceMm;
-        mEnablePublisherRanging = builder.mEnablePublisherRanging;
-        mPublisherPingDuration = builder.mPublisherPingDuration;
+        mUpdateRate = builder.mRangingUpdateRate;
+        mEnablePeriodicRangingHwFeature = builder.mEnablePeriodicRangingHwFeature;
+        mRangeDataNtfDisabled = builder.mRangeDataNtfDisabled;
     }
 
 
@@ -138,8 +158,9 @@ public class RttRangingParameters {
         protected byte[] mMatchFilter = new byte[]{};
         protected int mMaxDistanceMm = 30 * 100 * 100;
         protected int mMinDistanceMm = 0;
-        protected boolean mEnablePublisherRanging = false;
-        protected Duration mPublisherPingDuration = Duration.ofSeconds(10);
+        private int mRangingUpdateRate = NORMAL;
+        private boolean mEnablePeriodicRangingHwFeature = false;
+        private boolean mRangeDataNtfDisabled = false;
 
         public Builder setDeviceRole(int deviceRole) {
             mDeviceRole = deviceRole;
@@ -167,18 +188,23 @@ public class RttRangingParameters {
             return this;
         }
 
-        public Builder setEnablePublisherRanging(boolean enablePublisherRanging) {
-            mEnablePublisherRanging = enablePublisherRanging;
+        public Builder setMatchFilter(byte[] matchFilter) {
+            mMatchFilter = matchFilter;
+            return this;
+        }
+
+        public Builder setUpdateRate(int updateRate) {
+            mRangingUpdateRate = updateRate;
             return this;
         }
 
-        public Builder setPublisherPingDuration(@NonNull Duration ping) {
-            mPublisherPingDuration = ping;
+        public Builder setPeriodicRangingHwFeatureEnabled(boolean enabled) {
+            mEnablePeriodicRangingHwFeature = enabled;
             return this;
         }
 
-        public Builder setMatchFilter(byte[] matchFilter) {
-            mMatchFilter = matchFilter;
+        public Builder setRangeDataNtfDisabled(boolean rangeDataNtfDisabled) {
+            mRangeDataNtfDisabled = rangeDataNtfDisabled;
             return this;
         }
 
@@ -187,6 +213,20 @@ public class RttRangingParameters {
         }
     }
 
+    public static int getIntervalMs(@NonNull RttRangingParameters rttRangingParameters) {
+        switch (rttRangingParameters.getUpdateRate()) {
+            case FAST -> {
+                return rttRangingParameters.isPeriodicRangingHwFeatureEnabled() ? 128 : 256;
+            }
+            case INFREQUENT -> {
+                return 8192;
+            }
+            default -> {
+                return rttRangingParameters.isPeriodicRangingHwFeatureEnabled() ? 256 : 512;
+            }
+        }
+    }
+
     @Override
     public String toString() {
         return "RttRangingParameters{ "
@@ -202,10 +242,10 @@ public class RttRangingParameters {
                 + mMaxDistanceMm
                 + ", minDistanceMm: "
                 + mMinDistanceMm
-                + ", enablePublisherRanging: "
-                + mEnablePublisherRanging
-                + ", publisherPingDuration: "
-                + mPublisherPingDuration
+                + ", enablePeriodicRangingHwFeature: "
+                + mEnablePeriodicRangingHwFeature
+                + ", rangeDataNtfDisabled: "
+                + mRangeDataNtfDisabled
                 + " }";
     }
 }
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingPosition.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingPosition.java
new file mode 100644
index 00000000..40dbd5c2
--- /dev/null
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingPosition.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rtt.backend;
+
+import android.net.wifi.rtt.RangingResult;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+/**
+ * This class is transform class of RangingResult to fit with RttAdapter.
+ */
+public class RttRangingPosition {
+    private static final String TAG = RttRangingPosition.class.getName();
+
+    private double mDistanceMeters;
+    private long mRangingTimestampMillis;
+    private int mRssi;
+    Azimuth mAzimuth;
+    Elevation mElevation;
+
+    /**
+     * Create Ranging Position for RTT from RangingResult
+     */
+    public RttRangingPosition(@NonNull RangingResult rangingResult) {
+        mDistanceMeters = rangingResult.getDistanceMm() / 1000.0;
+        mRssi = rangingResult.getRssi();
+        mAzimuth = null;
+        mElevation = null;
+        mRangingTimestampMillis = rangingResult.getRangingTimestampMillis();
+    }
+
+    /**
+     * Gets distance in meter.
+     */
+    public double getDistanceMeters() {
+        return mDistanceMeters;
+    }
+
+    /**
+     * get Rssi Dbm
+     */
+    public int getRssiDbm() {
+        return mRssi;
+    }
+
+    /**
+     * get Ranging Time stamp(Unit : ms)
+     */
+    public long getRangingTimestampMillis() {
+        return mRangingTimestampMillis;
+    }
+
+    // WiFi RTT doesn't support Azimuth yet.
+
+    /**
+     * get Azumith(Not supported yet)
+     */
+    public Azimuth getAzimuth() {
+        Log.w(TAG, "Azimuth feature is not yet supported in WiFi RTT");
+        return mAzimuth;
+    }
+
+    // WiFi RTT doesn't support Elevation yet.
+
+    /**
+     * get Elevation(Not supported yet)
+     */
+    public Elevation getElevation() {
+        Log.w(TAG, "Elevation feature is not yet supported in WiFi RTT");
+        return mElevation;
+    }
+
+    /**
+     * Azimuth data(Not supported yet)
+     */
+    public static class Azimuth {
+        public int getValue() {
+            return 0;
+        }
+    }
+
+    /**
+     * Elevation data(Not supported yet)
+     */
+    public static class Elevation {
+        public int getValue() {
+            return 0;
+        }
+    }
+}
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingSessionCallback.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingSessionCallback.java
similarity index 67%
rename from ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingSessionCallback.java
rename to ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingSessionCallback.java
index 4ae0d558..26fd5390 100644
--- a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingSessionCallback.java
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttRangingSessionCallback.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,9 @@
  * limitations under the License.
  */
 
-package com.android.ranging.rtt.backend.internal;
+package com.android.ranging.rtt.backend;
+
+import androidx.annotation.IntDef;
 
 /**
  * Callbacks used by startRanging.
@@ -30,6 +32,18 @@ public interface RttRangingSessionCallback {
     int REASON_SYSTEM_POLICY = 6;
     int REASON_RTT_NOT_AVAILABLE = 7;
 
+    @IntDef({
+            REASON_UNKNOWN,
+            REASON_WRONG_PARAMETERS,
+            REASON_FAILED_TO_START,
+            REASON_STOPPED_BY_PEER,
+            REASON_STOP_RANGING_CALLED,
+            REASON_MAX_RANGING_ROUND_RETRY_REACHED,
+            REASON_SYSTEM_POLICY,
+            REASON_RTT_NOT_AVAILABLE,
+    })
+    @interface RttSuspendedReason {}
+
     /**
      * Callback when a ranging session has been initiated.
      */
@@ -43,6 +57,6 @@ public interface RttRangingSessionCallback {
     /**
      * Callback when a session has been suspended.
      */
-    void onRangingSuspended(RttDevice device, int reason);
+    void onRangingSuspended(RttDevice device, @RttSuspendedReason int reason);
 
 }
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttService.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttService.java
similarity index 79%
rename from ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttService.java
rename to ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttService.java
index 8ca53c9b..83fd1614 100644
--- a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttService.java
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttService.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.ranging.rtt.backend.internal;
+package com.android.ranging.rtt.backend;
 
 import android.content.Context;
 
@@ -26,4 +26,9 @@ public interface RttService {
     boolean isAvailable();
 
     boolean hasPeriodicRangingSupport();
+
+    int getMaxSupportedBandwidth();
+
+    int getMaxSupportedRxChains();
+
 }
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttServiceImpl.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttServiceImpl.java
similarity index 58%
rename from ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttServiceImpl.java
rename to ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttServiceImpl.java
index bfe0c89b..82e3d327 100644
--- a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttServiceImpl.java
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/RttServiceImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,12 @@
  * limitations under the License.
  */
 
-package com.android.ranging.rtt.backend.internal;
+package com.android.ranging.rtt.backend;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.pm.PackageManager;
+import android.net.wifi.aware.Characteristics;
 import android.net.wifi.aware.WifiAwareManager;
 import android.util.Log;
 
@@ -30,6 +32,7 @@ public class RttServiceImpl implements RttService {
     private static final String TAG = RttServiceImpl.class.getSimpleName();
     private final Context mContext;
     private WifiAwareManager mWifiAwareManager;
+    private Characteristics mCharacteristics;
 
     public RttServiceImpl(@NonNull Context context) {
         this.mContext = context;
@@ -60,18 +63,52 @@ public class RttServiceImpl implements RttService {
         return true;
     }
 
-    @Override
-    public boolean hasPeriodicRangingSupport() {
+    public void getCharacteristics() {
+        if (mCharacteristics != null) {
+            return;
+        }
         if (mWifiAwareManager == null) {
             Log.e(TAG, "WifiAwareManager is null");
-            return false;
+            return;
         }
         try {
-            //TODO: Uncomment when the support is added.
-                //return mWifiAwareManager.getCharacteristics().isPeriodicRangingSupported();
+            mCharacteristics = mWifiAwareManager.getCharacteristics();
         } catch (RuntimeException e) {
             Log.e(TAG, "Failed to get WifiAwareManager#characteristics");
         }
-        return false;
     }
+
+    @SuppressLint("NewApi") // FLAG_RANGING_RTT_ENABLED will be enabled from Android 16.
+    @Override
+    public boolean hasPeriodicRangingSupport() {
+        getCharacteristics();
+        if (mCharacteristics == null) {
+            Log.e(TAG, "Not able to get WiFi aware characteristics");
+            return false;
+        }
+        return mCharacteristics.isPeriodicRangingSupported();
+    }
+
+    @SuppressLint("NewApi") // FLAG_RANGING_RTT_ENABLED will be enabled from Android 16.
+    @Override
+    public int getMaxSupportedBandwidth() {
+        getCharacteristics();
+        if (mCharacteristics == null) {
+            Log.e(TAG, "Not able to get WiFi aware characteristics");
+            return 255;
+        }
+        return mCharacteristics.getMaxSupportedRangingPacketBandwidth();
+    }
+
+    @SuppressLint("NewApi") // FLAG_RANGING_RTT_ENABLED will be enabled from Android 16.
+    @Override
+    public int getMaxSupportedRxChains() {
+        getCharacteristics();
+        if (mCharacteristics == null) {
+            Log.e(TAG, "Not able to get WiFi aware characteristics");
+            return 255;
+        }
+        return mCharacteristics.getMaxSupportedRxChains();
+    }
+
 }
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingPosition.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingPosition.java
deleted file mode 100644
index 4bc01a29..00000000
--- a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingPosition.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging.rtt.backend.internal;
-
-import android.net.MacAddress;
-import android.net.wifi.aware.PeerHandle;
-import android.net.wifi.rtt.RangingResult;
-import android.net.wifi.rtt.ResponderLocation;
-import android.os.Build;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-
-/**
- * This class is transform class of RangingResult to fit with RttAdapter.
- */
-public class RttRangingPosition {
-    private static final String TAG = RttRangingPosition.class.getName();
-
-    private int mDistanceMm;
-    private int mDistanceStdDevMm;
-    private byte[] mLci;
-    private byte[] mLcr;
-    private MacAddress mMacAddress;
-    //    private long mMaxTimeBetweenNtbMeasurementsMicros;
-    private int mMeasurementBandwidth;
-    private int mMeasurementChannelFrequencyMHz;
-    //    private long mMinTimeBetweenNtbMeasurementsMicros;
-    private int mNumAttemptedMeasurements;
-    private int mNumSuccessfulMeasurements;
-    private PeerHandle mPeerHandle;
-    private long mRangingTimestampMillis;
-    private int mRssi;
-    private int mStatus;
-    private ResponderLocation mUnverifiedResponderLocation;
-    boolean mIs80211azNtbMeasurement;
-    boolean mIs80211mcMeasurement;
-
-    Azimuth mAzimuth;
-    Elevation mElevation;
-
-
-    /**
-     * Create empty Ranging Position for RTT.
-     */
-    public RttRangingPosition() {
-        mDistanceMm = 0;
-        mDistanceStdDevMm = 0;
-        mLci = null;
-        mLcr = null;
-        mMacAddress = null;
-        mMeasurementBandwidth = 0;
-        mMeasurementChannelFrequencyMHz = 0;
-        mNumAttemptedMeasurements = 0;
-        mNumSuccessfulMeasurements = 0;
-        mPeerHandle = null;
-        mAzimuth = null;
-        mElevation = null;
-        mRangingTimestampMillis = System.currentTimeMillis();
-    }
-
-    /**
-     * Create Ranging Position for RTT from RangingResult
-     */
-    public RttRangingPosition(@NonNull RangingResult rangingResult) {
-        mDistanceMm = rangingResult.getDistanceMm();
-        mDistanceStdDevMm = rangingResult.getDistanceStdDevMm();
-        mLci = rangingResult.getLci();
-        mLcr = rangingResult.getLcr();
-        mMacAddress = rangingResult.getMacAddress();
-//        mMaxTimeBetweenNtbMeasurementsMicros = rangingResult
-//        .getMaxTimeBetweenNtbMeasurementsMicros();
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
-            mMeasurementBandwidth = rangingResult.getMeasurementBandwidth();
-            mMeasurementChannelFrequencyMHz = rangingResult.getMeasurementChannelFrequencyMHz();
-        }
-//        mMinTimeBetweenNtbMeasurementsMicros = rangingResult
-//        .getMinTimeBetweenNtbMeasurementsMicros();
-        mNumAttemptedMeasurements = rangingResult.getNumAttemptedMeasurements();
-        mNumSuccessfulMeasurements = rangingResult.getNumSuccessfulMeasurements();
-        mPeerHandle = rangingResult.getPeerHandle();
-        mAzimuth = null;
-        mElevation = null;
-        mRangingTimestampMillis = rangingResult.getRangingTimestampMillis();
-
-    }
-
-    /**
-     * get Distamce(Unit : mm)
-     */
-    public double getDistance() {
-        return mDistanceMm;
-    }
-
-    /**
-     * get Rssi Dbm
-     */
-    public int getRssiDbm() {
-        return mRssi;
-    }
-
-    /**
-     * get Ranging Time stamp(Unit : ms)
-     */
-    public long getRangingTimestampMillis() {
-        return mRangingTimestampMillis;
-    }
-
-    // WiFi RTT doesn't support Azimuth yet.
-
-    /**
-     * get Azumith(Not supported yet)
-     */
-    public Azimuth getAzimuth() {
-        Log.w(TAG, "Azimuth feature is not yet supported in WiFi RTT");
-        return mAzimuth;
-    }
-
-    // WiFi RTT doesn't support Elevation yet.
-
-    /**
-     * get Elevation(Not supported yet)
-     */
-    public Elevation getElevation() {
-        Log.w(TAG, "Elevation feature is not yet supported in WiFi RTT");
-        return mElevation;
-    }
-
-    /**
-     * Azimuth data(Not supported yet)
-     */
-    public static class Azimuth {
-        public int getValue() {
-            return 0;
-        }
-    }
-
-    /**
-     * Elevation data(Not supported yet)
-     */
-    public static class Elevation {
-        public int getValue() {
-            return 0;
-        }
-    }
-}
diff --git a/ranging/rtt_backend/tests/Android.bp b/ranging/rtt_backend/tests/Android.bp
index 96a63511..0de0d9f5 100644
--- a/ranging/rtt_backend/tests/Android.bp
+++ b/ranging/rtt_backend/tests/Android.bp
@@ -25,7 +25,8 @@ android_test {
     srcs: [
         "**/*.java",
     ],
-
+    sdk_version: "system_server_current",
+    target_sdk_version: "36",
     dxflags: ["--multi-dex"],
 
     java_version: "1.9",
@@ -47,6 +48,7 @@ android_test {
         "android.test.base.stubs.system",
         "android.test.mock.stubs.system",
         "framework-annotations-lib",
+        "framework-wifi.stubs.module_lib",
     ],
 
     jni_libs: [
@@ -56,9 +58,8 @@ android_test {
     ],
     compile_multilib: "both",
 
-    min_sdk_version: "Tiramisu",
-
     test_suites: [
         "general-tests",
+        "mts-uwb",
     ],
 }
diff --git a/ranging/rtt_backend/tests/AndroidManifest.xml b/ranging/rtt_backend/tests/AndroidManifest.xml
index 5f5cb507..fc7420b8 100644
--- a/ranging/rtt_backend/tests/AndroidManifest.xml
+++ b/ranging/rtt_backend/tests/AndroidManifest.xml
@@ -16,7 +16,7 @@
   -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.ranging.rtt.backend">
+    package="com.android.ranging.tests.rtt.backend">
 
     <application android:debuggable="true"
          android:largeHeap="true">
@@ -33,7 +33,7 @@
 
     <!-- This is a self-instrumenting test package. -->
     <instrumentation android:name="androidx.test.runner.AndroidJUnitRunner"
-        android:targetPackage="com.android.ranging.rtt.backend"
+        android:targetPackage="com.android.ranging.tests.rtt.backend"
         android:label="Tests for the generic ranging Rtt backend">
     </instrumentation>
 
diff --git a/ranging/rtt_backend/tests/AndroidTest.xml b/ranging/rtt_backend/tests/AndroidTest.xml
index b48665e9..c10336ef 100644
--- a/ranging/rtt_backend/tests/AndroidTest.xml
+++ b/ranging/rtt_backend/tests/AndroidTest.xml
@@ -22,8 +22,15 @@
     <option name="test-suite-tag" value="apct" />
     <option name="test-tag" value="RangingRttBackendTests" />
     <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
-        <option name="package" value="com.android.ranging.rtt.backend" />
+        <option name="package" value="com.android.ranging.tests.rtt.backend" />
         <option name="runner" value="androidx.test.runner.AndroidJUnitRunner" />
         <option name="hidden-api-checks" value="false"/>
     </test>
+
+    <!-- Only run the tests in MTS if the Uwb Mainline module is installed. -->
+    <object type="module_controller"
+            class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.uwb" />
+    </object>
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk36ModuleController" />
 </configuration>
\ No newline at end of file
diff --git a/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttDeviceTest.java b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttDeviceTest.java
new file mode 100644
index 00000000..1da836b4
--- /dev/null
+++ b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttDeviceTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.tests.rtt.backend;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.ranging.rtt.backend.RttDevice;
+import com.android.ranging.rtt.backend.RttRangingDevice;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class RttDeviceTest {
+    @Test
+    public void testRttDevice() {
+        RttRangingDevice mRttRangingDevice = mock(RttRangingDevice.class);
+        RttDevice.RttAddress rttAddress = new RttDevice.RttAddress("AA:BB:CC:AA:BB:CC");
+        assertThat(rttAddress.getAddress()).isNotNull();
+        assertThat(rttAddress.toBytes()).isNotNull();
+
+        RttDevice rttDevice = new RttDevice(mRttRangingDevice);
+        assertThat(rttDevice.getAddress()).isNotNull();
+        assertEquals(rttDevice.getRttRangingDevice(), mRttRangingDevice);
+    }
+}
diff --git a/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangerTest.java b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangerTest.java
new file mode 100644
index 00000000..f21f8fad
--- /dev/null
+++ b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangerTest.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.tests.rtt.backend;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.AlarmManager;
+import android.content.Context;
+import android.net.wifi.aware.PeerHandle;
+import android.net.wifi.rtt.WifiRttManager;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.ranging.rtt.backend.RttRanger;
+
+import com.google.common.util.concurrent.MoreExecutors;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class RttRangerTest {
+
+    @Mock
+    private Context mMockContext;
+
+    @Mock
+    private AlarmManager mMockAlarmManager;
+    @Mock
+    private WifiRttManager mMockRttManager;
+
+    @Mock
+    private PeerHandle mMockPeerHandle;
+
+    @Mock
+    private RttRanger.RttRangerListener mMockListener;
+
+    private RttRanger mRttRanger;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getSystemService(AlarmManager.class)).thenReturn(mMockAlarmManager);
+        when(mMockRttManager.isAvailable()).thenReturn(true);
+
+        mRttRanger = new RttRanger(mMockRttManager, MoreExecutors.newDirectExecutorService(),
+                mMockContext);
+    }
+
+    @Test
+    public void testStartStopRanging() {
+        mRttRanger.startRanging(mMockPeerHandle, mMockListener, 200, 0);
+
+        verify(mMockRttManager, times(1)).startRanging(any(), any(), any());
+
+        mRttRanger.stopRanging();
+        verify(mMockAlarmManager, times(0)).cancel(any(AlarmManager.OnAlarmListener.class));
+    }
+
+    @Test
+    public void testStartStopRanging_withDelay() {
+        mRttRanger.startRanging(mMockPeerHandle, mMockListener, 200, 100);
+
+        verify(mMockRttManager, times(0)).startRanging(any(), any(), any());
+        verify(mMockAlarmManager, times(1)).setExact(anyInt(), anyLong(), any(), any(), any());
+
+        mRttRanger.stopRanging();
+        verify(mMockAlarmManager, times(1)).cancel(any(AlarmManager.OnAlarmListener.class));
+    }
+
+    @Test
+    public void testStartRanging_whenDisabled() {
+        when(mMockRttManager.isAvailable()).thenReturn(false);
+        mRttRanger.startRanging(mMockPeerHandle, mMockListener, 200, 0);
+
+        verify(mMockRttManager, times(0)).startRanging(any(), any(), any());
+        verify(mMockListener).onRangingFailure(
+                RttRanger.RttRangerListener.STATUS_CODE_FAIL_RTT_NOT_AVAILABLE);
+
+        mRttRanger.stopRanging();
+        verify(mMockAlarmManager, times(0)).cancel(any(AlarmManager.OnAlarmListener.class));
+    }
+}
diff --git a/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangingDeviceTest.java b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangingDeviceTest.java
new file mode 100644
index 00000000..37dbbdbe
--- /dev/null
+++ b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangingDeviceTest.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.tests.rtt.backend;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.AlarmManager;
+import android.content.Context;
+import android.net.wifi.aware.WifiAwareManager;
+import android.net.wifi.rtt.WifiRttManager;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.ranging.rtt.backend.RttRangingDevice;
+import com.android.ranging.rtt.backend.RttRangingParameters;
+import com.android.ranging.rtt.backend.RttRangingSessionCallback;
+
+import com.google.common.util.concurrent.MoreExecutors;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import java.util.concurrent.ExecutorService;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class RttRangingDeviceTest {
+
+    @Mock
+    private Context mMockContext;
+
+    @Mock
+    private AlarmManager mMockAlarmManager;
+    @Mock
+    private WifiRttManager mMockRttManager;
+
+    @Mock
+    private WifiAwareManager mMockAwareManager;
+
+    @Mock
+    private RttRangingSessionCallback mMockRttListener;
+
+
+    private RttRangingDevice mRangingDevice;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getSystemService(AlarmManager.class)).thenReturn(mMockAlarmManager);
+        when(mMockContext.getSystemService(WifiAwareManager.class)).thenReturn(mMockAwareManager);
+        when(mMockContext.getSystemService(WifiRttManager.class)).thenReturn(mMockRttManager);
+        when(mMockAwareManager.isAvailable()).thenReturn(true);
+        when(mMockRttManager.isAvailable()).thenReturn(true);
+
+        mRangingDevice = new RttRangingDevice(mMockContext, RttRangingDevice.DeviceType.SUBSCRIBER);
+    }
+
+    @Test
+    public void testStartStopRanging() throws Exception {
+        ExecutorService executor = MoreExecutors.newDirectExecutorService();
+        mRangingDevice.setRangingParameters(new RttRangingParameters.Builder().build());
+        mRangingDevice.startRanging(mMockRttListener, executor);
+
+        verify(mMockAwareManager, times(1)).attach(any(), any());
+    }
+}
diff --git a/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangingParametersTest.java b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangingParametersTest.java
new file mode 100644
index 00000000..b0280fef
--- /dev/null
+++ b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangingParametersTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.tests.rtt.backend;
+
+import static org.junit.Assert.assertEquals;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.ranging.rtt.backend.RttRangingParameters;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class RttRangingParametersTest {
+
+    @Test
+    public void testRttRangingParameters() {
+        int deviceRole = RttRangingParameters.DeviceRole.PUBLISHER;
+        byte serviceId = 0;
+        String serviceName = "";
+        byte[] matchFilter = new byte[]{};
+        int maxDistanceMm = 30 * 100 * 100;
+        int minDistanceMm = 0;
+        int rangingUpdateRate = RttRangingParameters.NORMAL;
+        boolean enablePeriodicRangingHwFeature = false;
+
+        RttRangingParameters parameters = new RttRangingParameters.Builder()
+                .setDeviceRole(deviceRole)
+                .setServiceId(serviceId)
+                .setServiceName(serviceName)
+                .setMatchFilter(matchFilter)
+                .setMaxDistanceMm(maxDistanceMm)
+                .setMinDistanceMm(minDistanceMm)
+                .setUpdateRate(rangingUpdateRate)
+                .setPeriodicRangingHwFeatureEnabled(enablePeriodicRangingHwFeature)
+                .build();
+
+        assertEquals(parameters.getDeviceRole(), deviceRole);
+        assertEquals(parameters.getServiceId(), serviceId);
+        assertEquals(parameters.getServiceName(), serviceName);
+        assertEquals(parameters.getMatchFilter(), matchFilter);
+        assertEquals(parameters.getMaxDistanceMm(), maxDistanceMm);
+        assertEquals(parameters.getMinDistanceMm(), minDistanceMm);
+        assertEquals(parameters.getUpdateRate(), rangingUpdateRate);
+        assertEquals(parameters.isPeriodicRangingHwFeatureEnabled(),
+                enablePeriodicRangingHwFeature);
+    }
+}
diff --git a/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangingPositionTest.java b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangingPositionTest.java
new file mode 100644
index 00000000..e2c88740
--- /dev/null
+++ b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttRangingPositionTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.tests.rtt.backend;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.when;
+
+import android.net.wifi.rtt.RangingResult;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.ranging.rtt.backend.RttRangingPosition;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class RttRangingPositionTest {
+
+    @Mock
+    private RangingResult mMockRangingResult;
+
+    private RttRangingPosition mRttRangingPosition;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+    }
+
+    @Test
+    public void testRttRangingPosition() {
+        when(mMockRangingResult.getDistanceMm()).thenReturn(10000);
+        when(mMockRangingResult.getRangingTimestampMillis()).thenReturn(50_000L);
+        when(mMockRangingResult.getRssi()).thenReturn(50);
+
+        mRttRangingPosition = new RttRangingPosition(mMockRangingResult);
+
+        assertEquals(mRttRangingPosition.getDistanceMeters(), 10, 0);
+        assertEquals(mRttRangingPosition.getRssiDbm(), 50);
+        assertEquals(mRttRangingPosition.getRangingTimestampMillis(), 50_000L);
+        assertThat(mRttRangingPosition.getAzimuth()).isNull();
+        assertThat(mRttRangingPosition.getElevation()).isNull();
+    }
+}
diff --git a/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttServiceImplTest.java b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttServiceImplTest.java
new file mode 100644
index 00000000..76e0b35d
--- /dev/null
+++ b/ranging/rtt_backend/tests/src/com/android/ranging/rtt/backend/RttServiceImplTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.tests.rtt.backend;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.when;
+
+import android.app.AlarmManager;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.net.wifi.aware.WifiAwareManager;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.ranging.rtt.backend.RttServiceImpl;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class RttServiceImplTest {
+
+    @Mock
+    private Context mMockContext;
+
+    @Mock
+    private PackageManager mMockPackageManager;
+
+    @Mock
+    private WifiAwareManager mMockAwareManager;
+
+    @Mock
+    private AlarmManager mMockAlarmManager;
+
+    private RttServiceImpl mRttService;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
+        when(mMockPackageManager.hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE)).thenReturn(
+                true);
+        when(mMockContext.getSystemService(WifiAwareManager.class)).thenReturn(mMockAwareManager);
+        when(mMockContext.getSystemService(AlarmManager.class)).thenReturn(mMockAlarmManager);
+        mRttService = new RttServiceImpl(mMockContext);
+    }
+
+    @Test
+    public void testRttServiceImpl() {
+        when(mMockAwareManager.isAvailable()).thenReturn(true);
+        assertThat(mRttService.getPublisher(mMockContext)).isNotNull();
+        assertThat(mRttService.getSubscriber(mMockContext)).isNotNull();
+        assertTrue(mRttService.isAvailable());
+    }
+}
diff --git a/ranging/service/Android.bp b/ranging/service/Android.bp
index 321bdf57..f783d8f7 100644
--- a/ranging/service/Android.bp
+++ b/ranging/service/Android.bp
@@ -24,12 +24,15 @@ java_defaults {
     errorprone: {
         javacflags: ["-Xep:CheckReturnValue:ERROR"],
     },
+    java_version: "21",
 }
 
 filegroup {
     name: "service-ranging-srcs",
     srcs: [
         "java/**/*.java",
+        ":service-uwb-shared-with-ranging-srcs",
+        ":statslog-ranging-java-gen",
     ],
 }
 
@@ -54,6 +57,7 @@ java_library {
         "framework-wifi.stubs.module_lib",
         "framework-bluetooth.stubs.module_lib",
         "framework-location.stubs.module_lib",
+        "ServiceUwbResources",
     ],
 
     static_libs: [
@@ -62,12 +66,7 @@ java_library {
         "modules-utils-handlerexecutor",
         // TODO: migrate away from auto value if possible.
         "auto_value_annotations",
-        //"modules-utils-preconditions",
-        //"modules-utils-build",
         "framework-ranging-pre-jarjar",
-        "androidx.annotation_annotation",
-        "androidx.concurrent_concurrent-futures",
-        "androidx.concurrent_concurrent-futures",
         "com.uwb.fusion",
         "ranging_rtt_backend",
         "ranging_uwb_backend",
@@ -120,3 +119,16 @@ java_library {
         "com.android.uwb",
     ],
 }
+
+// Metrics logging
+// ============================================================
+genrule {
+    name: "statslog-ranging-java-gen",
+    tools: ["stats-log-api-gen"],
+    cmd: "$(location stats-log-api-gen) " +
+        "--java $(out) " +
+        "--module ranging " +
+        "--javaPackage com.android.server.ranging.metrics " +
+        "--javaClass RangingStatsLog",
+    out: ["com/android/server/ranging/metrics/RangingStatsLog.java"],
+}
diff --git a/ranging/service/java/com/android/server/ranging/CapabilitiesProvider.java b/ranging/service/java/com/android/server/ranging/CapabilitiesProvider.java
index af7e2522..44fc3e76 100644
--- a/ranging/service/java/com/android/server/ranging/CapabilitiesProvider.java
+++ b/ranging/service/java/com/android/server/ranging/CapabilitiesProvider.java
@@ -84,12 +84,8 @@ public class CapabilitiesProvider {
             @NonNull IRangingCapabilitiesCallback callback
     ) {
         mCallbacks.register(callback);
-        if (mCachedCapabilities == null) {
-            initializeAdaptersForAllTechnologies();
-            mCachedCapabilities = getCapabilities().build();
-        }
         try {
-            callback.onRangingCapabilities(mCachedCapabilities);
+            callback.onRangingCapabilities(getCapabilities());
         } catch (RemoteException e) {
             Log.e(TAG, "Failed to call provided capabilities callback", e);
         }
@@ -101,7 +97,15 @@ public class CapabilitiesProvider {
         mCallbacks.unregister(callback);
     }
 
-    private synchronized RangingCapabilities.Builder getCapabilities() {
+    public synchronized @NonNull RangingCapabilities getCapabilities() {
+        if (mCachedCapabilities == null) {
+            initializeAdaptersForAllTechnologies();
+            mCachedCapabilities = queryAdaptersForCapabilities().build();
+        }
+        return mCachedCapabilities;
+    }
+
+    private synchronized RangingCapabilities.Builder queryAdaptersForCapabilities() {
         RangingCapabilities.Builder builder = new RangingCapabilities.Builder();
         for (RangingTechnology technology : mCapabilityAdapters.keySet()) {
             CapabilitiesAdapter adapter = mCapabilityAdapters.get(technology);
@@ -145,7 +149,7 @@ public class CapabilitiesProvider {
                 @AvailabilityChangedReason int unused
         ) {
             synchronized (CapabilitiesProvider.this) {
-                mCachedCapabilities = getCapabilities()
+                mCachedCapabilities = queryAdaptersForCapabilities()
                         .addAvailability(mTechnology.getValue(), availability)
                         .build();
                 synchronized (mCallbacks) {
diff --git a/ranging/service/java/com/android/server/ranging/DeviceConfigFacade.java b/ranging/service/java/com/android/server/ranging/DeviceConfigFacade.java
new file mode 100644
index 00000000..3b073519
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/DeviceConfigFacade.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging;
+
+import android.content.Context;
+import android.os.Handler;
+import android.provider.DeviceConfig;
+
+import com.android.uwb.resources.R;
+
+/**
+ * This class allows getting all configurable flags from DeviceConfig.
+ */
+public class DeviceConfigFacade {
+    private final Context mContext;
+
+    // Cached values of fields updated via updateDeviceConfigFlags()
+    private String[] mTechnologyPreferenceList;
+    private int mRttRangingRequestDelay;
+
+    public DeviceConfigFacade(Handler handler, Context context) {
+        mContext = context;
+        updateDeviceConfigFlags();
+        DeviceConfig.addOnPropertiesChangedListener(
+                DeviceConfig.NAMESPACE_UWB,
+                command -> handler.post(command),
+                properties -> {
+                    updateDeviceConfigFlags();
+                });
+    }
+
+    // device config override with array is not natively supported, so read the value as a comma
+    // separated string.
+    private static String[] getDeviceConfigStringArray(String name, String[] defaultValue) {
+        String value = DeviceConfig.getString(DeviceConfig.NAMESPACE_UWB, name, null);
+        if (value == null) {
+            return defaultValue;
+        }
+        return value.split(" , ");
+    }
+
+    private void updateDeviceConfigFlags() {
+        mTechnologyPreferenceList = getDeviceConfigStringArray(
+                "technology_preference_list",
+                mContext.getResources().getStringArray(R.array.technology_preference_list)
+        );
+        mRttRangingRequestDelay = DeviceConfig.getInt(DeviceConfig.NAMESPACE_UWB,
+                "rtt_ranging_request_delay",
+                mContext.getResources().getInteger(R.integer.rtt_ranging_request_delay));
+    }
+
+    public String[] getTechnologyPreferenceList() {
+        return mTechnologyPreferenceList;
+    }
+
+    public int getRttRangingRequestDelay() {
+        return mRttRangingRequestDelay;
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/RangingAdapter.java b/ranging/service/java/com/android/server/ranging/RangingAdapter.java
index 0107551d..3ce4c8bd 100644
--- a/ranging/service/java/com/android/server/ranging/RangingAdapter.java
+++ b/ranging/service/java/com/android/server/ranging/RangingAdapter.java
@@ -16,32 +16,65 @@
 
 package com.android.server.ranging;
 
+import android.annotation.Nullable;
+import android.content.AttributionSource;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
+import android.ranging.raw.RawResponderRangingConfig;
 
-import androidx.annotation.IntDef;
 import androidx.annotation.NonNull;
 
+import com.android.server.ranging.RangingUtils.InternalReason;
 import com.android.server.ranging.session.RangingSessionConfig;
 
+import com.google.common.collect.ImmutableSet;
+
 /** RangingAdapter representing a common ranging class for multiple ranging technologies. */
 public interface RangingAdapter {
 
     /** Returns {@link RangingTechnology} of this adapter. */
-    @NonNull RangingTechnology getTechnology();
+    @NonNull
+    RangingTechnology getTechnology();
 
     /**
      * Start ranging. Does nothing if the ranging technology is not enabled on device or if ranging
      * has already been started. In the latter case, this method will not overwrite the existing
      * callback.
-     * @param config for the ranging session.
+     *
+     * @param config   for the ranging session.
      * @param callback to be called on the occurrence of ranging events.
      */
-    void start(@NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callback);
+    void start(@NonNull RangingSessionConfig.TechnologyConfig config,
+            @Nullable AttributionSource nonPrivilegedAttributionSource,
+            @NonNull Callback callback);
 
     /** Stop ranging. */
     void stop();
 
+    /** Dynamic add/remove peers. Defaults to unsupported.*/
+    default boolean isDynamicUpdatePeersSupported() {
+        return false;
+    }
+
+    default void addPeer(RawResponderRangingConfig params) {}
+
+    default void removePeer(RangingDevice device) {}
+
+    default void reconfigureRangingInterval(int intervalSkipCount) {}
+
+    default void appForegroundStateUpdated(boolean appInForeground) {
+        if (appInForeground) {
+            appMovedToForeground();
+        } else {
+            appMovedToBackground();
+        }
+    }
+    void appMovedToBackground();
+
+    void appMovedToForeground();
+
+    void appInBackgroundTimeout();
+
     /** Callback for getting notified when ranging starts or stops. */
     interface Callback {
         /**
@@ -49,17 +82,20 @@ public interface RangingAdapter {
          * be called after start if API failed to initialize, in that case onClosed with an
          * appropriate error code will be called instead.
          *
-         * @param peer that ranging was started with.
+         * @param peers that ranging was started with. Must be non-empty. Multicast technologies
+         *              may start ranging with multiple peers at once.
          */
-        void onStarted(@NonNull RangingDevice peer);
+        void onStarted(@NonNull ImmutableSet<RangingDevice> peers);
 
 
         /**
          * Notifies the caller that ranging has stopped with a particular peer.
          *
-         * @param peer that ranging was stopped with.
+         * @param peers that ranging was stopped with. Must be non-empty. Multicast technologies
+         *              may stop ranging with multiple peers at once.
+         * @param reason why ranging was stopped.
          */
-        void onStopped(@NonNull RangingDevice peer);
+        void onStopped(@NonNull ImmutableSet<RangingDevice> peers, @InternalReason int reason);
 
         /**
          * Notifies the caller on each instance of ranging data received from the ranging
@@ -70,28 +106,11 @@ public interface RangingAdapter {
          */
         void onRangingData(@NonNull RangingDevice peer, @NonNull RangingData data);
 
-        @IntDef({
-                ClosedReason.UNKNOWN,
-                ClosedReason.FAILED_TO_START,
-                ClosedReason.REQUESTED,
-                ClosedReason.LOST_CONNECTION,
-                ClosedReason.SYSTEM_POLICY,
-                ClosedReason.ERROR,
-        })
-        @interface ClosedReason {
-            int UNKNOWN = 0;
-            int ERROR = 1;
-            int FAILED_TO_START = 2;
-            int REQUESTED = 3;
-            int LOST_CONNECTION = 4;
-            int SYSTEM_POLICY = 5;
-        }
-
         /**
          * Notifies the caller that the ranging session was closed.
          *
          * @param reason why the session was closed.
          */
-        void onClosed(@ClosedReason int reason);
+        void onClosed(@InternalReason int reason);
     }
 }
diff --git a/ranging/service/java/com/android/server/ranging/RangingEngine.java b/ranging/service/java/com/android/server/ranging/RangingEngine.java
new file mode 100644
index 00000000..d6e01580
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/RangingEngine.java
@@ -0,0 +1,330 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging;
+
+import static android.ranging.oob.OobInitiatorRangingConfig.RANGING_MODE_AUTO;
+import static android.ranging.oob.OobInitiatorRangingConfig.RANGING_MODE_FUSED;
+import static android.ranging.oob.OobInitiatorRangingConfig.RANGING_MODE_HIGH_ACCURACY;
+import static android.ranging.oob.OobInitiatorRangingConfig.RANGING_MODE_HIGH_ACCURACY_PREFERRED;
+
+import android.ranging.RangingCapabilities;
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.SessionHandle;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.util.Log;
+import android.util.Pair;
+
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.RangingUtils.InternalReason;
+import com.android.server.ranging.blerssi.BleRssiConfigSelector;
+import com.android.server.ranging.cs.CsConfigSelector;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobHeader;
+import com.android.server.ranging.oob.SetConfigurationMessage;
+import com.android.server.ranging.oob.SetConfigurationMessage.TechnologyOobConfig;
+import com.android.server.ranging.rtt.RttConfigSelector;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+import com.android.server.ranging.uwb.UwbConfigSelector;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+
+import java.util.Arrays;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public class RangingEngine {
+    private static final String TAG = RangingEngine.class.getSimpleName();
+
+    private final SessionConfig mSessionConfig;
+    private final OobInitiatorRangingConfig mOobConfig;
+    private final SessionHandle mSessionHandle;
+    private final ImmutableSet<RangingTechnology> mRequestedTechnologies;
+    private final Map<RangingDevice, EnumSet<RangingTechnology>> mPeerTechnologies;
+    private final RangingInjector mInjector;
+
+    private final EnumMap<RangingTechnology, ConfigSelector> mConfigSelectors;
+
+    public static class ConfigSelectionException extends Exception {
+        private final @InternalReason int mReason;
+
+        public ConfigSelectionException(String message, @InternalReason int reason) {
+            super(message);
+            mReason = reason;
+        }
+
+        public @InternalReason int getReason() {
+            return mReason;
+        }
+    }
+
+    public interface ConfigSelector {
+        void addPeerCapabilities(@NonNull RangingDevice peer,
+                @NonNull CapabilityResponseMessage response) throws ConfigSelectionException;
+
+        boolean hasPeersToConfigure();
+
+        @NonNull Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > selectConfigs() throws ConfigSelectionException;
+    }
+
+    public static class SelectedConfig {
+        private final ImmutableSet<TechnologyConfig> mLocalConfigs;
+        private final ImmutableMap<RangingDevice, SetConfigurationMessage> mPeerConfigMessages;
+
+        private SelectedConfig(
+                ImmutableSet<TechnologyConfig> localConfigs,
+                ImmutableMap<RangingDevice, SetConfigurationMessage> peerConfigMessages
+        ) {
+            mLocalConfigs = localConfigs;
+            mPeerConfigMessages = peerConfigMessages;
+        }
+
+        public ImmutableSet<TechnologyConfig> getLocalConfigs() {
+            return mLocalConfigs;
+        }
+
+        public ImmutableMap<RangingDevice, SetConfigurationMessage> getPeerConfigMessages() {
+            return mPeerConfigMessages;
+        }
+    }
+
+    public RangingEngine(
+            SessionConfig sessionConfig, OobInitiatorRangingConfig oobConfig,
+            SessionHandle sessionHandle, RangingInjector injector
+    ) throws ConfigSelectionException {
+        mSessionConfig = sessionConfig;
+        mOobConfig = oobConfig;
+        mSessionHandle = sessionHandle;
+        mPeerTechnologies = new HashMap<>();
+        mConfigSelectors = Maps.newEnumMap(RangingTechnology.class);
+        mInjector = injector;
+
+        ImmutableSet.Builder<RangingTechnology> toRequest = ImmutableSet.builder();
+        if (shouldRequest(RangingTechnology.UWB)) toRequest.add(RangingTechnology.UWB);
+        if (oobConfig.getRangingMode() != RANGING_MODE_HIGH_ACCURACY) {
+            for (RangingTechnology technology :
+                    Set.of(RangingTechnology.CS, RangingTechnology.RTT, RangingTechnology.RSSI)) {
+                if (shouldRequest(technology)) toRequest.add(technology);
+            }
+        }
+        mRequestedTechnologies = toRequest.build();
+        if (mRequestedTechnologies.isEmpty()) {
+            throw new ConfigSelectionException(
+                    "No locally supported technologies are compatible with the provided config",
+                    InternalReason.UNSUPPORTED);
+        }
+    }
+
+    public ImmutableSet<RangingTechnology> getRequestedTechnologies() {
+        return mRequestedTechnologies;
+    }
+
+    public void addPeerCapabilities(
+            RangingDevice device, CapabilityResponseMessage capabilities
+    ) throws ConfigSelectionException {
+        EnumSet<RangingTechnology> selectedTechnologies =
+                selectTechnologiesToUseWithPeer(capabilities);
+        Log.v(TAG, "Selected technologies " + selectedTechnologies + " for peer " + device);
+
+        for (RangingTechnology technology : selectedTechnologies) {
+            ConfigSelector selector = mConfigSelectors.get(technology);
+            if (selector == null) {
+                throw new IllegalStateException(
+                        "Expected config selector to exist for mutually supported technology "
+                                + technology);
+            }
+            selector.addPeerCapabilities(device, capabilities);
+        }
+        mPeerTechnologies.put(device, selectedTechnologies);
+    }
+
+    public SelectedConfig selectConfigs() throws ConfigSelectionException {
+        ImmutableSet.Builder<TechnologyConfig> localConfigs = ImmutableSet.builder();
+        Map<RangingDevice, SetConfigurationMessage.Builder> peerConfigs = new HashMap<>();
+
+        for (RangingTechnology technology : mConfigSelectors.keySet()) {
+            ConfigSelector selector = mConfigSelectors.get(technology);
+            if (!selector.hasPeersToConfigure()) continue;
+
+            Pair<ImmutableSet<TechnologyConfig>, ImmutableMap<RangingDevice, TechnologyOobConfig>>
+                    configs = selector.selectConfigs();
+
+            localConfigs.addAll(configs.first);
+            configs.second.forEach((peer, config) ->
+                    peerConfigs.computeIfAbsent(peer,
+                            (unused) -> {
+                                ImmutableList<RangingTechnology> peerTechnologies =
+                                        ImmutableList.copyOf(mPeerTechnologies.get(peer));
+                                return SetConfigurationMessage.builder()
+                                        .setHeader(OobHeader.builder()
+                                                .setMessageType(MessageType.SET_CONFIGURATION)
+                                                .setVersion(OobHeader.OobVersion.CURRENT)
+                                                .build())
+                                        .setRangingTechnologiesSet(peerTechnologies)
+                                        .setStartRangingList(peerTechnologies);
+                            }
+                    )
+                    .setTechnologyConfig(configs.second.get(peer)));
+        }
+
+        return new SelectedConfig(
+                localConfigs.build(),
+                peerConfigs.keySet().stream().collect(
+                        ImmutableMap.toImmutableMap(
+                                Function.identity(),
+                                (peer) -> peerConfigs.get(peer).build())));
+    }
+
+    private boolean shouldRequest(RangingTechnology technology) {
+        @RangingCapabilities.RangingTechnologyAvailability int availability = mInjector
+                .getCapabilitiesProvider()
+                .getCapabilities()
+                .getTechnologyAvailability().get(technology.getValue());
+
+        return availability == RangingCapabilities.ENABLED
+                || availability == RangingCapabilities.DISABLED_USER;
+    }
+
+    /**
+     * If the {@param technology} is enabled and supported, create a config selector and add it to
+     * {@code mConfigSelectors}
+     * @return true if the {@param technology} is enabled and supported, false otherwise.
+     */
+    private boolean createConfigSelectorIfEnabledAndSupported(RangingTechnology technology) {
+        if (mConfigSelectors.containsKey(technology)) return true;
+        try {
+            mConfigSelectors.put(technology, createConfigSelector(technology));
+            return true;
+        } catch (ConfigSelectionException ignored) {
+            return false;
+        }
+    }
+
+    private ConfigSelector createConfigSelector(
+            RangingTechnology technology
+    ) throws ConfigSelectionException {
+        RangingCapabilities capabilities = mInjector.getCapabilitiesProvider().getCapabilities();
+        return switch (technology) {
+            case UWB -> new UwbConfigSelector(
+                    mSessionConfig, mOobConfig, mSessionHandle, capabilities.getUwbCapabilities());
+            case CS -> new CsConfigSelector(
+                    mSessionConfig, mOobConfig, capabilities.getCsCapabilities());
+            case RTT -> new RttConfigSelector(
+                    mSessionConfig, mOobConfig, capabilities.getRttRangingCapabilities());
+            case RSSI -> new BleRssiConfigSelector(
+                    mSessionConfig, mOobConfig, capabilities.getBleRssiCapabilities());
+        };
+    }
+
+    private List<RangingTechnology> getPreferredTechnologyList() {
+        String[] prefTechnologiesStringArray = mInjector
+                .getDeviceConfigFacade()
+                .getTechnologyPreferenceList();
+        return Arrays.stream(prefTechnologiesStringArray)
+                .map(str -> RangingTechnology.fromName(str))
+                .collect(Collectors.toUnmodifiableList());
+    }
+
+    private EnumSet<RangingTechnology> selectTechnologiesToUseWithPeer(
+            CapabilityResponseMessage peerCapabilities
+    ) throws ConfigSelectionException {
+        EnumSet<RangingTechnology> selectable = EnumSet.noneOf(RangingTechnology.class);
+        selectable.addAll(peerCapabilities.getSupportedRangingTechnologies());
+
+        // Skip CS if supported by the remote device but no Bluetooth bond is established.
+        if (selectable.contains(RangingTechnology.CS)
+                && peerCapabilities.getCsCapabilities() != null
+                && !mInjector.isRemoteDeviceBluetoothBonded(
+                peerCapabilities.getCsCapabilities().getBluetoothAddress())
+        ) {
+            Log.v(TAG, RangingTechnology.CS + " is mutually supported, but skipping it because no "
+                    + "Bluetooth bond exists with peer");
+            selectable.remove(RangingTechnology.CS);
+        }
+
+        if (selectable.isEmpty()) {
+            throw new ConfigSelectionException("Peer does not support any requested technologies",
+                    InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+
+        selectable = selectable
+                .stream()
+                .filter((technology -> mInjector
+                        .getCapabilitiesProvider()
+                        .getCapabilities()
+                        .getTechnologyAvailability()
+                        .get(technology.getValue()) == RangingCapabilities.ENABLED))
+                .collect(Collectors.toCollection(() -> EnumSet.noneOf(RangingTechnology.class)));
+
+        if (selectable.isEmpty()) {
+            throw new ConfigSelectionException(peerCapabilities.getSupportedRangingTechnologies()
+                    + " are mutually supported, but they are all disabled by the user so we cannot "
+                    + "proceed with ranging",
+                    InternalReason.SYSTEM_POLICY);
+        }
+
+        selectable = selectable
+                .stream()
+                .filter(this::createConfigSelectorIfEnabledAndSupported)
+                .collect(Collectors.toCollection(() -> EnumSet.noneOf(RangingTechnology.class)));
+
+        if (selectable.isEmpty()) {
+            throw new ConfigSelectionException(
+                    "No mutually supported technologies are compatible with the provided config",
+                    InternalReason.UNSUPPORTED);
+        }
+
+        EnumSet<RangingTechnology> selected = EnumSet.noneOf(RangingTechnology.class);
+        switch (mOobConfig.getRangingMode()) {
+            case RANGING_MODE_AUTO:
+            case RANGING_MODE_HIGH_ACCURACY_PREFERRED: {
+                getPreferredTechnologyList()
+                        .stream()
+                        .filter(selectable::contains)
+                        .findFirst()
+                        .ifPresent(selected::add);
+                break;
+            }
+            case RANGING_MODE_HIGH_ACCURACY: {
+                if (selectable.contains(RangingTechnology.UWB)) {
+                    selected.add(RangingTechnology.UWB);
+                }
+                break;
+            }
+            case RANGING_MODE_FUSED: {
+                selected.addAll(selectable);
+                break;
+            }
+        }
+
+        return selected;
+    }
+}
\ No newline at end of file
diff --git a/ranging/service/java/com/android/server/ranging/RangingInjector.java b/ranging/service/java/com/android/server/ranging/RangingInjector.java
index 980816d2..75412790 100644
--- a/ranging/service/java/com/android/server/ranging/RangingInjector.java
+++ b/ranging/service/java/com/android/server/ranging/RangingInjector.java
@@ -17,22 +17,34 @@
 package com.android.server.ranging;
 
 import static android.Manifest.permission.RANGING;
+import static android.bluetooth.BluetoothDevice.BOND_BONDED;
 import static android.permission.PermissionManager.PERMISSION_GRANTED;
 
 import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.SuppressLint;
+import android.app.ActivityManager;
+import android.bluetooth.BluetoothManager;
 import android.content.AttributionSource;
 import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
 import android.os.Binder;
+import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
+import android.os.Process;
+import android.os.UserHandle;
 import android.permission.PermissionManager;
-import android.ranging.RangingPreference;
+import android.util.Log;
 
+import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.ranging.CapabilitiesProvider.CapabilitiesAdapter;
 import com.android.server.ranging.blerssi.BleRssiAdapter;
 import com.android.server.ranging.blerssi.BleRssiCapabilitiesAdapter;
 import com.android.server.ranging.cs.CsAdapter;
 import com.android.server.ranging.cs.CsCapabilitiesAdapter;
+import com.android.server.ranging.oob.OobController;
 import com.android.server.ranging.rtt.RttAdapter;
 import com.android.server.ranging.rtt.RttCapabilitiesAdapter;
 import com.android.server.ranging.session.RangingSessionConfig;
@@ -41,26 +53,56 @@ import com.android.server.ranging.uwb.UwbCapabilitiesAdapter;
 
 import com.google.common.util.concurrent.ListeningExecutorService;
 
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
 public class RangingInjector {
 
     private static final String TAG = "RangingInjector";
 
+    private static final int APP_INFO_FLAGS_SYSTEM_APP =
+            ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
+
     private final Context mContext;
     private final RangingServiceManager mRangingServiceManager;
+    private final OobController mOobController;
 
     private final CapabilitiesProvider mCapabilitiesProvider;
     private final PermissionManager mPermissionManager;
 
     private final Looper mLooper;
 
+    private final Handler mAlarmHandler;
+    private final DeviceConfigFacade mDeviceConfigFacade;
+
+    @SuppressLint("StaticFieldLeak")
+    private static RangingInjector sInstance;
+
     public RangingInjector(@NonNull Context context) {
         HandlerThread rangingHandlerThread = new HandlerThread("RangingServiceHandler");
         rangingHandlerThread.start();
         mLooper = rangingHandlerThread.getLooper();
         mContext = context;
         mCapabilitiesProvider = new CapabilitiesProvider(this);
-        mRangingServiceManager = new RangingServiceManager(this, mLooper);
+        mRangingServiceManager = new RangingServiceManager(this,
+                mContext.getSystemService(ActivityManager.class),
+                mLooper);
+        mOobController = new OobController(this);
         mPermissionManager = context.getSystemService(PermissionManager.class);
+        mAlarmHandler = new Handler(mLooper);
+        mDeviceConfigFacade = new DeviceConfigFacade(new Handler(mLooper), mContext);
+        sInstance = this;
+    }
+
+     public static RangingInjector getInstance() {
+        return Objects.requireNonNull(sInstance);
+    }
+
+    @VisibleForTesting
+    public  static void setInstance(RangingInjector rangingInjector) {
+        sInstance = rangingInjector;
     }
 
     public Context getContext() {
@@ -75,23 +117,36 @@ public class RangingInjector {
         return mRangingServiceManager;
     }
 
+    public OobController getOobController() {
+        return mOobController;
+    }
+
+    public Handler getAlarmHandler() {
+        return mAlarmHandler;
+    }
+
+    public DeviceConfigFacade getDeviceConfigFacade() {
+        return mDeviceConfigFacade;
+    }
+
     /**
      * Create a new adapter for a technology.
      */
     public @NonNull RangingAdapter createAdapter(
+            @NonNull AttributionSource attributionSource,
             @NonNull RangingSessionConfig.TechnologyConfig config,
-            @RangingPreference.DeviceRole int role,
             @NonNull ListeningExecutorService executor
     ) {
         switch (config.getTechnology()) {
             case UWB:
-                return new UwbAdapter(mContext, executor, role);
+                return new UwbAdapter(
+                        mContext, this, attributionSource, executor, config.getDeviceRole());
             case CS:
-                return new CsAdapter(mContext);
+                return new CsAdapter(mContext, this);
             case RTT:
-                return new RttAdapter(mContext, executor, role);
+                return new RttAdapter(mContext, this, executor, config.getDeviceRole());
             case RSSI:
-                return new BleRssiAdapter(mContext);
+                return new BleRssiAdapter(mContext, this);
             default:
                 throw new IllegalArgumentException(
                         "Adapter does not exist for technology " + config.getTechnology());
@@ -117,7 +172,6 @@ public class RangingInjector {
         }
     }
 
-
     public void enforceRangingPermissionForPreflight(
             @NonNull AttributionSource attributionSource) {
         if (!attributionSource.checkCallingUid()) {
@@ -138,4 +192,136 @@ public class RangingInjector {
         return permissionCheckResult == PERMISSION_GRANTED;
     }
 
+    /** Helper method to check if the app is a system app. */
+    public boolean isSystemApp(int uid, @NonNull String packageName) {
+        try {
+            ApplicationInfo info = createPackageContextAsUser(uid)
+                    .getPackageManager()
+                    .getApplicationInfo(packageName, 0);
+            return (info.flags & APP_INFO_FLAGS_SYSTEM_APP) != 0;
+        } catch (PackageManager.NameNotFoundException e) {
+            // In case of exception, assume unknown app (more strict checking)
+            // Note: This case will never happen since checkPackage is
+            // called to verify validity before checking App's version.
+            Log.e(TAG, "Failed to get the app info", e);
+        }
+        return false;
+    }
+
+    /**
+     * Helper method creating a context based on the app's uid (to deal with multi user scenarios)
+     */
+    @Nullable
+    private Context createPackageContextAsUser(int uid) {
+        Context userContext;
+        try {
+            userContext = mContext.createPackageContextAsUser(mContext.getPackageName(), 0,
+                    UserHandle.getUserHandleForUid(uid));
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.e(TAG, "Unknown package name");
+            return null;
+        }
+        if (userContext == null) {
+            Log.e(TAG, "Unable to retrieve user context for " + uid);
+            return null;
+        }
+        return userContext;
+    }
+
+    @Nullable
+    public AttributionSource getAnyNonPrivilegedAppInAttributionSource(AttributionSource source) {
+        // Iterate attribution source chain to ensure that there is no non-fg 3p app in the
+        // request.
+        AttributionSource attributionSource = source;
+        while (attributionSource != null) {
+            int uid = attributionSource.getUid();
+            String packageName = attributionSource.getPackageName();
+            if (!isPrivilegedApp(uid, packageName)) {
+                return attributionSource;
+            }
+            attributionSource = attributionSource.getNext();
+        }
+        return null;
+    }
+
+    /** Whether the uid is signed with the same key as the platform. */
+    public boolean isAppSignedWithPlatformKey(int uid) {
+        return mContext.getPackageManager().checkSignatures(uid, Process.SYSTEM_UID)
+                == PackageManager.SIGNATURE_MATCH;
+    }
+
+    /** Helper method to check if the app is from foreground app/service. */
+    public static boolean isForegroundAppOrServiceImportance(int importance) {
+        return importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND_SERVICE;
+    }
+
+    /** Helper method to check if the app or service is no longer running. */
+    public static boolean isNonExistentAppOrService(int importance) {
+        return importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_GONE;
+    }
+
+    public boolean isPrivilegedApp(int uid, String packageName) {
+        return isSystemApp(uid, packageName) || isAppSignedWithPlatformKey(uid);
+    }
+
+    /** Helper method to check if the app is from foreground app/service. */
+    public boolean isForegroundAppOrService(int uid, @NonNull String packageName) {
+        long identity = Binder.clearCallingIdentity();
+        try {
+            return isForegroundAppOrServiceImportance(getPackageImportance(uid, packageName));
+        } catch (SecurityException e) {
+            Log.e(TAG, "Failed to retrieve the app importance", e);
+            return false;
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+    }
+
+    /** Helper method to retrieve app importance. */
+    private int getPackageImportance(int uid, @NonNull String packageName) {
+        if (sOverridePackageImportance.containsKey(packageName)) {
+            Log.w(TAG, "Overriding package importance for testing");
+            return sOverridePackageImportance.get(packageName);
+        }
+        try {
+            return createPackageContextAsUser(uid)
+                    .getSystemService(ActivityManager.class)
+                    .getPackageImportance(packageName);
+        } catch (SecurityException e) {
+            Log.e(TAG, "Failed to retrieve the app importance", e);
+            return ActivityManager.RunningAppProcessInfo.IMPORTANCE_GONE;
+        }
+    }
+
+    private static Map<String, Integer> sOverridePackageImportance = new HashMap();
+
+    // Use this if we have adb shell command support
+    public void setOverridePackageImportance(String packageName, int importance) {
+        sOverridePackageImportance.put(packageName, importance);
+    }
+    public void resetOverridePackageImportance(String packageName) {
+        sOverridePackageImportance.remove(packageName);
+    }
+
+    /**
+     * Valid Bluetooth hardware addresses must be upper case, in big endian byte order, and in a
+     * format such as "00:11:22:33:AA:BB".
+     */
+    public boolean isRemoteDeviceBluetoothBonded(String btAddress) {
+        long identity = Binder.clearCallingIdentity();
+        try {
+            return mContext.getSystemService(BluetoothManager.class)
+                    .getAdapter()
+                    .getRemoteDevice(btAddress)
+                    .getBondState() == BOND_BONDED;
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+    }
+
+    public boolean isRangingTechnologyEnabled(RangingTechnology rangingTechnology) {
+        return Arrays.asList(getDeviceConfigFacade().getTechnologyPreferenceList()).contains(
+                rangingTechnology.toString()
+        );
+    }
 }
diff --git a/ranging/service/java/com/android/server/ranging/RangingService.java b/ranging/service/java/com/android/server/ranging/RangingService.java
index 19382370..835bc0e4 100644
--- a/ranging/service/java/com/android/server/ranging/RangingService.java
+++ b/ranging/service/java/com/android/server/ranging/RangingService.java
@@ -20,6 +20,7 @@ import android.content.Context;
 import android.util.Log;
 
 import com.android.server.SystemService;
+import com.android.server.uwb.UwbContext;
 
 public class RangingService extends SystemService {
     private static final String TAG = "RangingService";
@@ -27,7 +28,8 @@ public class RangingService extends SystemService {
 
     public RangingService(Context context) {
         super(context);
-        mRangingImpl = new RangingServiceImpl(context, new RangingInjector(context));
+        mRangingImpl = new RangingServiceImpl(
+                context, new RangingInjector(new UwbContext(context)));
     }
 
     @Override
diff --git a/ranging/service/java/com/android/server/ranging/RangingServiceImpl.java b/ranging/service/java/com/android/server/ranging/RangingServiceImpl.java
index af51c8bd..82485979 100644
--- a/ranging/service/java/com/android/server/ranging/RangingServiceImpl.java
+++ b/ranging/service/java/com/android/server/ranging/RangingServiceImpl.java
@@ -31,8 +31,8 @@ import android.ranging.RangingPreference;
 import android.ranging.SessionHandle;
 import android.ranging.oob.IOobSendDataListener;
 import android.ranging.oob.OobHandle;
-import android.ranging.oob.OobResponderRangingParams;
-import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.oob.OobResponderRangingConfig;
+import android.ranging.raw.RawResponderRangingConfig;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -77,13 +77,13 @@ public class RangingServiceImpl extends IRangingAdapter.Stub {
     }
 
     @Override
-    public void addRawDevice(SessionHandle sessionHandle, RawResponderRangingParams rangingParams) {
+    public void addRawDevice(SessionHandle sessionHandle, RawResponderRangingConfig rangingParams) {
         enforceRangingPermission();
         mRangingInjector.getRangingServiceManager().addRawPeer(sessionHandle, rangingParams);
     }
 
     @Override
-    public void addOobDevice(SessionHandle sessionHandle, OobResponderRangingParams rangingParams) {
+    public void addOobDevice(SessionHandle sessionHandle, OobResponderRangingConfig rangingParams) {
         enforceRangingPermission();
         throw new IllegalArgumentException("Dynamic addition of oob peer not supported yet");
     }
diff --git a/ranging/service/java/com/android/server/ranging/RangingServiceManager.java b/ranging/service/java/com/android/server/ranging/RangingServiceManager.java
index 7f0b4fd4..935acb4e 100644
--- a/ranging/service/java/com/android/server/ranging/RangingServiceManager.java
+++ b/ranging/service/java/com/android/server/ranging/RangingServiceManager.java
@@ -16,12 +16,9 @@
 
 package com.android.server.ranging;
 
-import static android.ranging.RangingSession.Callback.REASON_LOCAL_REQUEST;
-import static android.ranging.RangingSession.Callback.REASON_NO_PEERS_FOUND;
-import static android.ranging.RangingSession.Callback.REASON_SYSTEM_POLICY;
-import static android.ranging.RangingSession.Callback.REASON_UNKNOWN;
-import static android.ranging.RangingSession.Callback.REASON_UNSUPPORTED;
+import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND_SERVICE;
 
+import android.app.ActivityManager;
 import android.content.AttributionSource;
 import android.os.Handler;
 import android.os.IBinder;
@@ -30,41 +27,48 @@ import android.os.Message;
 import android.os.RemoteException;
 import android.ranging.IRangingCallbacks;
 import android.ranging.IRangingCapabilitiesCallback;
+import android.ranging.RangingConfig;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
-import android.ranging.RangingParams;
 import android.ranging.RangingPreference;
 import android.ranging.RangingSession.Callback;
 import android.ranging.SessionHandle;
 import android.ranging.oob.IOobSendDataListener;
 import android.ranging.oob.OobHandle;
-import android.ranging.oob.OobInitiatorRangingParams;
-import android.ranging.oob.OobResponderRangingParams;
-import android.ranging.raw.RawInitiatorRangingParams;
-import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.oob.OobResponderRangingConfig;
+import android.ranging.raw.RawInitiatorRangingConfig;
+import android.ranging.raw.RawResponderRangingConfig;
 import android.util.Log;
 
 import androidx.annotation.NonNull;
 
-import com.android.server.ranging.oob.OobHandler;
+import com.android.server.ranging.RangingUtils.InternalReason;
+import com.android.server.ranging.RangingUtils.StateMachine;
+import com.android.server.ranging.metrics.SessionMetricsLogger;
 import com.android.server.ranging.session.OobInitiatorRangingSession;
 import com.android.server.ranging.session.OobResponderRangingSession;
 import com.android.server.ranging.session.RangingSession;
 import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
 import com.android.server.ranging.session.RawInitiatorRangingSession;
 import com.android.server.ranging.session.RawResponderRangingSession;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListeningExecutorService;
 import com.google.common.util.concurrent.MoreExecutors;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.ScheduledExecutorService;
 
-public final class RangingServiceManager {
+public final class RangingServiceManager implements ActivityManager.OnUidImportanceListener{
     private static final String TAG = RangingServiceManager.class.getSimpleName();
 
     public enum RangingTask {
@@ -96,17 +100,51 @@ public final class RangingServiceManager {
 
     private final RangingInjector mRangingInjector;
     private final ListeningExecutorService mAdapterExecutor;
+    private final ScheduledExecutorService mOobExecutor;
     private final RangingTaskManager mRangingTaskManager;
-    private final Map<SessionHandle, RangingSession<?>> mSessions = new ConcurrentHashMap<>();
+    private final Map<SessionHandle, RangingSession> mSessions = new ConcurrentHashMap<>();
+    final ConcurrentHashMap<Integer, List<RangingSession>> mNonPrivilegedUidToSessionsTable =
+            new ConcurrentHashMap<>();
 
-    private IOobSendDataListener mOobDataSender;
+    private final ActivityManager mActivityManager;
 
-    public RangingServiceManager(RangingInjector rangingInjector, Looper looper) {
+    public RangingServiceManager(RangingInjector rangingInjector, ActivityManager activityManager,
+            Looper looper) {
         mRangingInjector = rangingInjector;
-        mAdapterExecutor = MoreExecutors.listeningDecorator(Executors.newSingleThreadExecutor());
+        mActivityManager = activityManager;
+        mAdapterExecutor = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());
+        mOobExecutor = Executors.newSingleThreadScheduledExecutor();
         mRangingTaskManager = new RangingTaskManager(looper);
+        registerUidImportanceTransitions();
     }
 
+    @Override
+    public void onUidImportance(int uid, int importance) {
+        synchronized (mNonPrivilegedUidToSessionsTable) {
+            List<RangingSession> rangingSessions = mNonPrivilegedUidToSessionsTable.get(uid);
+
+            if (rangingSessions == null) {
+                return;
+            }
+
+            if (RangingInjector.isNonExistentAppOrService(importance)) {
+                mNonPrivilegedUidToSessionsTable.remove(uid);
+                return;
+            }
+
+            boolean isForeground = RangingInjector.isForegroundAppOrServiceImportance(importance);
+            for (RangingSession session : rangingSessions) {
+                mRangingTaskManager.post(
+                        ()->session.appForegroundStateUpdated(isForeground));
+            }
+        }
+    }
+
+    private void registerUidImportanceTransitions() {
+        mActivityManager.addOnUidImportanceListener(this, IMPORTANCE_FOREGROUND_SERVICE);
+    }
+
+
     public void registerCapabilitiesCallback(IRangingCapabilitiesCallback capabilitiesCallback) {
         Log.w(TAG, "Registering ranging capabilities callback");
         mRangingInjector
@@ -124,32 +162,28 @@ public final class RangingServiceManager {
             AttributionSource attributionSource, SessionHandle handle, RangingPreference preference,
             IRangingCallbacks callbacks
     ) {
-        // TODO android.permission.RANGING permission check here
-//        Context context = mRangingInjector.getContext()
-//                .createContext(new ContextParams
-//                        .Builder()
-//                        .setNextAttributionSource(attributionSource)
-//                        .build());
-
         RangingTaskManager.StartRangingArgs args = new RangingTaskManager.StartRangingArgs(
                 attributionSource, handle, preference, callbacks);
         mRangingTaskManager.enqueueTask(RangingTask.TASK_START_RANGING, args);
     }
 
-    public void addRawPeer(SessionHandle handle, RawResponderRangingParams params) {
+    public void addRawPeer(SessionHandle handle, RawResponderRangingConfig params) {
         if (!mSessions.containsKey(handle)) {
             Log.e(TAG, "Failed to add peer. Ranging session not found");
+            return;
         }
-        DynamicPeer peer = new DynamicPeer(params.getRawRangingDevice().getRangingDevice(),
-                mSessions.get(handle));
+        DynamicPeer peer = new DynamicPeer(params,
+                mSessions.get(handle), null /* Ranging device is in params*/);
         mRangingTaskManager.enqueueTask(RangingTask.TASK_ADD_DEVICE, peer);
     }
 
     public void removePeer(SessionHandle handle, RangingDevice device) {
         if (!mSessions.containsKey(handle)) {
             Log.e(TAG, "Failed to remove peer. Ranging session not found");
+            return;
         }
-        DynamicPeer peer = new DynamicPeer(device, mSessions.get(handle));
+        DynamicPeer peer = new DynamicPeer(null /* params not needed*/, mSessions.get(handle),
+                device);
         mRangingTaskManager.enqueueTask(RangingTask.TASK_REMOVE_DEVICE, peer);
     }
 
@@ -162,7 +196,7 @@ public final class RangingServiceManager {
     }
 
     public void stopRanging(SessionHandle handle) {
-        RangingSession<?> session = mSessions.get(handle);
+        RangingSession session = mSessions.get(handle);
         if (session == null) {
             Log.e(TAG, "stopRanging for nonexistent session");
             return;
@@ -177,11 +211,7 @@ public final class RangingServiceManager {
      * @param data      payload
      */
     public void oobDataReceived(OobHandle oobHandle, byte[] data) {
-        if (mSessions.get(oobHandle.getSessionHandle()) instanceof OobHandler session) {
-            session.handleOobMessage(oobHandle, data);
-        } else {
-            Log.e(TAG, "oobDataReceived for non-oob session " + oobHandle.getSessionHandle());
-        }
+        mRangingInjector.getOobController().handleOobDataReceived(oobHandle, data);
     }
 
     /**
@@ -190,24 +220,16 @@ public final class RangingServiceManager {
      * @param oobHandle unique session/device pair identifier.
      */
     public void deviceOobDisconnected(OobHandle oobHandle) {
-        if (mSessions.get(oobHandle.getSessionHandle()) instanceof OobHandler session) {
-            session.handleOobDeviceDisconnected(oobHandle);
-        } else {
-            Log.e(TAG, "deviceOobDisconnected for non-oob session " + oobHandle.getSessionHandle());
-        }
+        mRangingInjector.getOobController().handleOobDeviceDisconnected(oobHandle);
     }
 
     /**
-     * Device reconnected to the OOB channel
+     * Device reconnected to the OOB channe:l
      *
      * @param oobHandle unique session/device pair identifier.
      */
     public void deviceOobReconnected(OobHandle oobHandle) {
-        if (mSessions.get(oobHandle.getSessionHandle()) instanceof OobHandler session) {
-            session.handleOobDeviceReconnected(oobHandle);
-        } else {
-            Log.e(TAG, "deviceOobReconnected for non-oob session " + oobHandle.getSessionHandle());
-        }
+        mRangingInjector.getOobController().handleOobDeviceReconnected(oobHandle);
     }
 
     /**
@@ -216,20 +238,16 @@ public final class RangingServiceManager {
      * @param oobHandle unique session/device pair identifier.
      */
     public void deviceOobClosed(OobHandle oobHandle) {
-        if (mSessions.get(oobHandle.getSessionHandle()) instanceof OobHandler session) {
-            session.handleOobClosed(oobHandle);
-        } else {
-            Log.e(TAG, "deviceOobClosed for non-oob session " + oobHandle.getSessionHandle());
-        }
+        mRangingInjector.getOobController().handleOobClosed(oobHandle);
     }
 
     /**
      * Register send data listener.
      *
-     * @param oobSendDataListener listener for sending the data via OOB.
+     * @param oobDataSender listener for sending the data via OOB.
      */
-    public void registerOobSendDataListener(IOobSendDataListener oobSendDataListener) {
-        mOobDataSender = oobSendDataListener;
+    public void registerOobSendDataListener(IOobSendDataListener oobDataSender) {
+        mRangingInjector.getOobController().registerDataSender(oobDataSender);
     }
 
     /**
@@ -239,12 +257,17 @@ public final class RangingServiceManager {
     public class SessionListener implements IBinder.DeathRecipient {
         private final SessionHandle mSessionHandle;
         private final IRangingCallbacks mRangingCallbacks;
-        private final AtomicBoolean mIsSessionStarted;
+        private final SessionMetricsLogger mMetricsLogger;
+        private final StateMachine<State> mStateMachine;
 
-        SessionListener(SessionHandle sessionHandle, IRangingCallbacks callbacks) {
+        SessionListener(
+                SessionHandle sessionHandle, IRangingCallbacks callbacks,
+                SessionMetricsLogger metricsLogger
+        ) {
             mSessionHandle = sessionHandle;
             mRangingCallbacks = callbacks;
-            mIsSessionStarted = new AtomicBoolean(false);
+            mMetricsLogger = metricsLogger;
+            mStateMachine = new StateMachine<>(State.CLOSED);
             try {
                 mRangingCallbacks.asBinder().linkToDeath(this, 0);
             } catch (RemoteException e) {
@@ -259,31 +282,54 @@ public final class RangingServiceManager {
             stopRanging(mSessionHandle);
         }
 
-        public void onTechnologyStarted(
-                @NonNull RangingDevice peer, @NonNull RangingTechnology technology
+        public synchronized void onConfigurationComplete(
+                @NonNull ImmutableSet<TechnologyConfig> configs
         ) {
-            if (!mIsSessionStarted.getAndSet(true)) {
+            if (mStateMachine.transition(State.CLOSED, State.CONFIGURED)) {
+                mMetricsLogger.logSessionConfigured(configs.size());
+            }
+        }
+
+        public synchronized void onSessionOpened() {
+            if (mStateMachine.transition(State.CONFIGURED, State.ACTIVE)) {
+                mMetricsLogger.logSessionStarted();
                 try {
                     mRangingCallbacks.onOpened(mSessionHandle);
                 } catch (RemoteException e) {
                     Log.e(TAG, "onOpened callback failed: " + e);
                 }
             }
-            try {
-                mRangingCallbacks.onStarted(mSessionHandle, peer, technology.getValue());
-            } catch (RemoteException e) {
-                Log.e(TAG, "onTechnologyStarted callback failed: " + e);
-            }
         }
 
-        public void onTechnologyStopped(
-                @NonNull RangingDevice peer, @NonNull RangingTechnology technology
+        public synchronized void onTechnologyStarted(
+                @NonNull RangingTechnology technology, @NonNull Set<RangingDevice> peers
         ) {
-            try {
-                mRangingCallbacks.onStopped(mSessionHandle, peer, technology.getValue());
-            } catch (RemoteException e) {
-                Log.e(TAG, "onTechnologyStopped callback failed: " + e);
-            }
+            Log.v(TAG, "onTechnologyStarted " + technology + " for " + peers.size() + " peer(s)");
+            // Enforce that the session is already opened.
+            onSessionOpened();
+            mMetricsLogger.logTechnologyStarted(technology, peers.size());
+            peers.forEach((peer) -> {
+                try {
+                    mRangingCallbacks.onStarted(mSessionHandle, peer, technology.getValue());
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onTechnologyStarted callback failed: " + e);
+                }
+            });
+        }
+
+        public synchronized void onTechnologyStopped(
+                @NonNull RangingTechnology technology, @NonNull Set<RangingDevice> peers,
+                @InternalReason int reason
+        ) {
+            Log.v(TAG, "onTechnologyStopped " + technology + " for " + peers.size() + " peer(s)");
+            mMetricsLogger.logTechnologyStopped(technology, peers.size(), reason);
+            peers.forEach((peer) -> {
+                try {
+                    mRangingCallbacks.onStopped(mSessionHandle, peer, technology.getValue());
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onTechnologyStopped callback failed: " + e);
+                }
+            });
         }
 
         public void onResults(
@@ -296,13 +342,11 @@ public final class RangingServiceManager {
             }
         }
 
-        /**
-         * Signals that ranging in the session has stopped. Called by a {@link RangingSession} once
-         * all of its constituent technology-specific sessions have stopped.
-         */
-        public void onSessionStopped(@RangingAdapter.Callback.ClosedReason int reason) {
-            mSessions.remove(mSessionHandle);
-            if (mIsSessionStarted.get()) {
+        public synchronized void onSessionClosed(@InternalReason int reason) {
+            Log.v(TAG, "onSessionClosed reason " + reason);
+            mSessions.remove(mSessionHandle).close();
+            mMetricsLogger.logSessionClosed(reason);
+            if (mStateMachine.getAndSet(State.CLOSED) == State.ACTIVE) {
                 try {
                     mRangingCallbacks.onClosed(mSessionHandle, convertReason(reason));
                 } catch (RemoteException e) {
@@ -317,21 +361,22 @@ public final class RangingServiceManager {
             }
         }
 
-        private @Callback.Reason int convertReason(
-                @RangingAdapter.Callback.ClosedReason int reason
-        ) {
-            switch (reason) {
-                case RangingAdapter.Callback.ClosedReason.REQUESTED:
-                    return REASON_LOCAL_REQUEST;
-                case RangingAdapter.Callback.ClosedReason.FAILED_TO_START:
-                    return REASON_UNSUPPORTED;
-                case RangingAdapter.Callback.ClosedReason.LOST_CONNECTION:
-                    return REASON_NO_PEERS_FOUND;
-                case RangingAdapter.Callback.ClosedReason.SYSTEM_POLICY:
-                    return REASON_SYSTEM_POLICY;
-                default:
-                    return REASON_UNKNOWN;
-            }
+        private @Callback.Reason int convertReason(@InternalReason int reason) {
+            return switch (reason) {
+                case InternalReason.UNKNOWN, InternalReason.LOCAL_REQUEST,
+                     InternalReason.REMOTE_REQUEST, InternalReason.UNSUPPORTED,
+                     InternalReason.SYSTEM_POLICY, InternalReason.NO_PEERS_FOUND -> reason;
+                case InternalReason.INTERNAL_ERROR -> Callback.REASON_UNKNOWN;
+                case InternalReason.BACKGROUND_RANGING_POLICY -> Callback.REASON_SYSTEM_POLICY;
+                case InternalReason.PEER_CAPABILITIES_MISMATCH -> Callback.REASON_UNSUPPORTED;
+                default -> Callback.REASON_UNKNOWN;
+            };
+        }
+
+        private enum State {
+            CLOSED,
+            CONFIGURED,
+            ACTIVE
         }
     }
 
@@ -366,11 +411,11 @@ public final class RangingServiceManager {
                 }
                 case TASK_ADD_DEVICE -> {
                     DynamicPeer peer = (DynamicPeer) msg.obj;
-                    peer.mSession.addPeer(peer.mDevice);
+                    peer.mSession.addPeer(peer.mParams);
                 }
                 case TASK_REMOVE_DEVICE -> {
                     DynamicPeer peer = (DynamicPeer) msg.obj;
-                    peer.mSession.removePeer(peer.mDevice);
+                    peer.mSession.removePeer(peer.mRangingDevice);
                 }
                 case TASK_RECONFIGURE_INTERVAL -> {
                     RangingSession session = (RangingSession) msg.obj;
@@ -389,64 +434,74 @@ public final class RangingServiceManager {
 
         public void handleStartRanging(StartRangingArgs args) {
             RangingSessionConfig config = new RangingSessionConfig.Builder()
-                    .setDeviceRole(
-                            args.preference.getDeviceRole())
-                    .setSensorFusionConfig(
-                            args.preference.getSessionConfiguration().getSensorFusionParameters())
-                    .setDataNotificationConfig(
-                            args.preference.getSessionConfiguration().getDataNotificationConfig())
-                    .setAoaNeeded(
-                            args.preference.getSessionConfiguration().isAngleOfArrivalNeeded())
+                    .setDeviceRole(args.preference.getDeviceRole())
+                    .setSessionConfig(args.preference().getSessionConfig())
                     .build();
 
-            RangingParams baseParams = args.preference.getRangingParameters();
-            if (baseParams instanceof RawInitiatorRangingParams params) {
-                RawInitiatorRangingSession session = new RawInitiatorRangingSession(
-                        args.attributionSource, args.handle, mRangingInjector, config,
-                        new SessionListener(args.handle, args.callbacks), mAdapterExecutor
-                );
-                session.start(params);
-                mSessions.put(args.handle, session);
-            } else if (baseParams instanceof RawResponderRangingParams params) {
-                RawResponderRangingSession session = new RawResponderRangingSession(
-                        args.attributionSource, args.handle, mRangingInjector, config,
-                        new SessionListener(args.handle, args.callbacks), mAdapterExecutor
-                );
-                session.start(params);
-                mSessions.put(args.handle, session);
-            } else if (baseParams instanceof OobInitiatorRangingParams params) {
-                OobInitiatorRangingSession session = new OobInitiatorRangingSession(
-                        args.attributionSource, args.handle, mRangingInjector, config,
-                        new SessionListener(args.handle, args.callbacks), mOobDataSender,
-                        mAdapterExecutor
-                );
-                session.start(params);
-                mSessions.put(args.handle, session);
-            } else if (baseParams instanceof OobResponderRangingParams params) {
-                OobResponderRangingSession session = new OobResponderRangingSession(
-                        args.attributionSource, args.handle, mRangingInjector, config,
-                        new SessionListener(args.handle, args.callbacks), mOobDataSender,
-                        mAdapterExecutor
-                );
-                session.start(params);
-                mSessions.put(args.handle, session);
+            RangingConfig baseParams = args.preference.getRangingParams();
+            SessionListener listener = new SessionListener(
+                    args.handle, args.callbacks,
+                    SessionMetricsLogger.startLogging(
+                            args.handle, config.getDeviceRole(), baseParams.getRangingSessionType(),
+                            args.attributionSource, mRangingInjector));
+
+            switch (baseParams) {
+                case RawInitiatorRangingConfig params -> startSession(params, args,
+                        new RawInitiatorRangingSession(args.attributionSource, args.handle,
+                                mRangingInjector, config, listener, mAdapterExecutor));
+                case RawResponderRangingConfig params -> startSession(params, args,
+                        new RawResponderRangingSession(args.attributionSource, args.handle,
+                                mRangingInjector, config, listener, mAdapterExecutor));
+                case OobInitiatorRangingConfig params -> startSession(params, args,
+                        new OobInitiatorRangingSession(args.attributionSource, args.handle,
+                                mRangingInjector, config, listener, mAdapterExecutor,
+                                mOobExecutor));
+                case OobResponderRangingConfig params -> startSession(params, args,
+                        new OobResponderRangingSession(args.attributionSource, args.handle,
+                                mRangingInjector, config, listener, mAdapterExecutor,
+                                mOobExecutor));
+                default -> {
+                    Log.e(TAG, "Unknown configuration object " + baseParams.getClass());
+                    listener.onSessionClosed(InternalReason.INTERNAL_ERROR);
+                }
+            }
+        }
+    }
+
+    public void startSession(
+            RangingConfig params,
+            RangingTaskManager.StartRangingArgs args,
+            RangingSession rangingSession
+    ) {
+        AttributionSource attributionSource = mRangingInjector
+                .getAnyNonPrivilegedAppInAttributionSource(args.attributionSource);
+        if (attributionSource != null) {
+            synchronized (mNonPrivilegedUidToSessionsTable) {
+                List<RangingSession> session = mNonPrivilegedUidToSessionsTable.computeIfAbsent(
+                        attributionSource.getUid(), v -> new ArrayList<>());
+                session.add(rangingSession);
             }
         }
+        mSessions.put(args.handle, rangingSession);
+        rangingSession.start(params);
     }
 
     public static final class DynamicPeer {
-        public final RangingDevice mDevice;
-        public final RangingSession<?> mSession;
+        public final RangingDevice mRangingDevice;
+        public final RawResponderRangingConfig mParams;
+        public final RangingSession mSession;
 
-        public DynamicPeer(RangingDevice device, RangingSession<?> session) {
-            mDevice = device;
+        public DynamicPeer(RawResponderRangingConfig params, RangingSession session,
+                RangingDevice device) {
+            mParams = params;
             mSession = session;
+            mRangingDevice = device;
         }
     }
 
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("---- Dump of RangingServiceManager ----");
-        for (RangingSession<?> session : mSessions.values()) {
+        for (RangingSession session : mSessions.values()) {
             session.dump(fd, pw, args);
         }
         pw.println("---- Dump of RangingServiceManager ----");
diff --git a/ranging/service/java/com/android/server/ranging/RangingTechnology.java b/ranging/service/java/com/android/server/ranging/RangingTechnology.java
index 92c8c532..04394a2f 100644
--- a/ranging/service/java/com/android/server/ranging/RangingTechnology.java
+++ b/ranging/service/java/com/android/server/ranging/RangingTechnology.java
@@ -29,7 +29,7 @@ import com.android.server.ranging.uwb.UwbCapabilitiesAdapter;
 import com.google.common.collect.ImmutableList;
 
 import java.util.BitSet;
-import java.util.List;
+import java.util.Collection;
 
 /** Enum representing an individual ranging technology. */
 public enum RangingTechnology {
@@ -88,7 +88,7 @@ public enum RangingTechnology {
         return technologies.build();
     }
 
-    public static byte[] toBitmap(List<RangingTechnology> technologies) {
+    public static byte[] toBitmap(Collection<RangingTechnology> technologies) {
         if (technologies.isEmpty()) {
             return new byte[BITMAP_SIZE_BYTES];
         }
@@ -108,11 +108,23 @@ public enum RangingTechnology {
         BitSet bitSet = BitSet.valueOf(technologiesBitmap);
         for (int i = 0; i < BITMAP_SIZE_BYTES * 8; i++) {
             if (bitSet.get(i)) {
-                if (i < RangingTechnology.values().length) {
-                    techs.add(RangingTechnology.values()[i]);
+                try {
+                    techs.add(RangingTechnology.TECHNOLOGIES.get(i));
+                } catch (IndexOutOfBoundsException e) {
+                    throw new IllegalArgumentException("Unknown technology " + i);
                 }
             }
         }
         return techs.build();
     }
+
+    @Override
+    public String toString() {
+        return name();
+    }
+
+    /** Create enum from string */
+    public static RangingTechnology fromName(String name) {
+        return RangingTechnology.valueOf(name);
+    }
 }
\ No newline at end of file
diff --git a/ranging/service/java/com/android/server/ranging/RangingUtils.java b/ranging/service/java/com/android/server/ranging/RangingUtils.java
index 546cb2ac..bbc065b1 100644
--- a/ranging/service/java/com/android/server/ranging/RangingUtils.java
+++ b/ranging/service/java/com/android/server/ranging/RangingUtils.java
@@ -16,21 +16,43 @@
 
 package com.android.server.ranging;
 
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
 import static java.lang.Math.min;
 
+import android.annotation.IntDef;
+import android.app.AlarmManager;
+import android.bluetooth.BluetoothStatusCodes;
+import android.os.SystemClock;
+import android.ranging.raw.RawRangingDevice.RangingUpdateRate;
+import android.util.Range;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.time.Duration;
 import java.util.BitSet;
 import java.util.List;
+import java.util.Optional;
 
 /**
  * Utilities for {@link com.android.ranging}.
  */
 public class RangingUtils {
+
+    private static final String MEASUREMENT_TIME_LIMIT_EXCEEDED = "measurementTimeLimitExceeded";
+
     /**
      * A basic synchronized state machine.
+     *
      * @param <E> enum representing the different states of the machine.
      */
     public static class StateMachine<E extends Enum<E>> {
@@ -52,6 +74,7 @@ public class RangingUtils {
 
         /**
          * Sets the current state.
+         *
          * @return true if the state was successfully changed, false if the current state is
          * already {@code state}.
          */
@@ -65,6 +88,7 @@ public class RangingUtils {
 
         /**
          * If the current state is {@code from}, sets it to {@code to}.
+         *
          * @return true if the current state is {@code from}, false otherwise.
          */
         public synchronized boolean transition(E from, E to) {
@@ -75,6 +99,17 @@ public class RangingUtils {
             return true;
         }
 
+        /**
+         * Atomically get the current state before setting it to a new one.
+         *
+         * @return the previous state before it was set to the provided one.
+         */
+        public synchronized E getAndSet(E state) {
+            E previousState = mState;
+            mState = state;
+            return previousState;
+        }
+
         @Override
         public String toString() {
             return "StateMachine{ "
@@ -132,5 +167,178 @@ public class RangingUtils {
             buffer.put(byteArray).rewind();
             return buffer.getInt();
         }
+
+        /**
+         * Converts a Bluetooth MAC address from byte array to string format. Throws if input byte
+         * array is not of correct format.
+         *
+         * <p>e.g. {-84, 55, 67, -68, -87, 40} -> "AC:37:43:BC:A9:28".
+         */
+        public static String macAddressToString(byte[] macAddress) {
+            if (macAddress == null || macAddress.length != 6) {
+                throw new IllegalArgumentException("Invalid mac address byte array");
+            }
+            StringBuilder sb = new StringBuilder(18);
+            for (byte b : macAddress) {
+                if (sb.length() > 0) {
+                    sb.append(':');
+                }
+                sb.append(String.format("%02x", b));
+            }
+            return Ascii.toUpperCase(sb.toString());
+        }
+
+        /**
+         * Convert a Bluetooth MAC address from string to byte array format. Throws if input string
+         * is not of correct format.
+         *
+         * <p>e.g. "AC:37:43:BC:A9:28" -> {-84, 55, 67, -68, -87, 40}.
+         */
+        public static byte[] macAddressToBytes(String macAddress) {
+            if (macAddress.isEmpty()) {
+                throw new IllegalArgumentException("MAC address cannot be empty");
+            }
+
+            byte[] bytes = new byte[6];
+            List<String> address = Splitter.on(':').splitToList(macAddress);
+            if (address.size() != 6) {
+                throw new IllegalArgumentException("Invalid MAC address format");
+            }
+            for (int i = 0; i < 6; i++) {
+                bytes[i] = Integer.decode("0x" + address.get(i)).byteValue();
+            }
+            return bytes;
+        }
+
+        /**
+         * Convert the hex string to byte array.
+         */
+        public static byte[] hexStringToByteArray(String hex) {
+            // remove whitespace in the hex string.
+            hex = hex.replaceAll("\\s", "");
+
+            int len = hex.length();
+            if (len % 2 != 0) {
+                // Pad the hex string with a leading zero.
+                hex = String.format("0%s", hex);
+                len++;
+            }
+            byte[] data = new byte[len / 2];
+            for (int i = 0; i < len; i += 2) {
+                data[i / 2] =
+                        (byte) ((Character.digit(hex.charAt(i), 16) << 4)
+                                | Character.digit(hex.charAt(i + 1), 16));
+            }
+            return data;
+        }
+    }
+
+    public static long convertNanosToMillis(long timestampNanos) {
+        return timestampNanos / 1_000_000L;
+    }
+
+    public static void setMeasurementsLimitTimeout(
+            AlarmManager alarmManager,
+            AlarmManager.OnAlarmListener measurementLimitListener,
+            int measurementsLimit, int rangingIntervalMs) {
+        if (alarmManager == null) {
+            return;
+        }
+        alarmManager.setExact(
+                AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                SystemClock.elapsedRealtime() + ((long) measurementsLimit * rangingIntervalMs),
+                MEASUREMENT_TIME_LIMIT_EXCEEDED,
+                measurementLimitListener,
+                null
+        );
+    }
+
+    /**
+     * Covert bluetooth reason code to ranging reason code.
+     */
+    public static @InternalReason int convertBluetoothReasonCode(int bluetoothReasonCode) {
+        return switch (bluetoothReasonCode) {
+            case BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED,
+                 BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED,
+                 BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED,
+                 BluetoothStatusCodes.FEATURE_NOT_SUPPORTED,
+                 BluetoothStatusCodes.ERROR_BAD_PARAMETERS -> InternalReason.UNSUPPORTED;
+
+            case BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION,
+                 BluetoothStatusCodes.ERROR_PROFILE_SERVICE_NOT_BOUND,
+                 BluetoothStatusCodes.ERROR_NOT_ACTIVE_DEVICE,
+                 BluetoothStatusCodes.ERROR_NO_ACTIVE_DEVICES,
+                 BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED,
+                 BluetoothStatusCodes.ERROR_HARDWARE_GENERIC,
+                 BluetoothStatusCodes.ERROR_LOCAL_NOT_ENOUGH_RESOURCES,
+                 BluetoothStatusCodes.ERROR_REMOTE_NOT_ENOUGH_RESOURCES,
+                 BluetoothStatusCodes.ERROR_REMOTE_OPERATION_REJECTED,
+                 BluetoothStatusCodes.ERROR_ALREADY_IN_TARGET_STATE,
+                 BluetoothStatusCodes.ERROR_CALLBACK_NOT_REGISTERED,
+                 BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_REQUEST,
+                 BluetoothStatusCodes.ERROR_REMOTE_OPERATION_NOT_SUPPORTED ->
+                    InternalReason.INTERNAL_ERROR;
+
+            case BluetoothStatusCodes.ERROR_TIMEOUT,
+                 BluetoothStatusCodes.ERROR_REMOTE_LINK_ERROR,
+                 BluetoothStatusCodes.ERROR_NO_LE_CONNECTION -> InternalReason.NO_PEERS_FOUND;
+
+            case BluetoothStatusCodes.REASON_LOCAL_APP_REQUEST -> InternalReason.LOCAL_REQUEST;
+
+            case BluetoothStatusCodes.REASON_REMOTE_REQUEST -> InternalReason.REMOTE_REQUEST;
+
+            case BluetoothStatusCodes.REASON_LOCAL_STACK_REQUEST,
+                 BluetoothStatusCodes.REASON_SYSTEM_POLICY -> InternalReason.SYSTEM_POLICY;
+
+            default -> InternalReason.UNKNOWN;
+        };
+    }
+
+    public static Optional<@RangingUpdateRate Integer> getUpdateRateFromDurationRange(
+            Range<Duration> preferred,
+            ImmutableMap<@RangingUpdateRate Integer, Duration> allowed
+    ) {
+        if (preferred.getLower().compareTo(allowed.get(UPDATE_RATE_INFREQUENT)) > 0) {
+            // Range of preferred durations lies entirely above allowed durations
+            return Optional.of(UPDATE_RATE_INFREQUENT);
+        }
+        if (preferred.getUpper().compareTo(allowed.get(UPDATE_RATE_FREQUENT)) < 0) {
+            // Range of preferred durations lies entirely below allowed durations
+            return Optional.of(UPDATE_RATE_FREQUENT);
+        }
+        // Otherwise, the intervals overlap. Pick fastest we can.
+        if (preferred.contains(allowed.get(UPDATE_RATE_FREQUENT))) {
+            return Optional.of(UPDATE_RATE_FREQUENT);
+        } else if (preferred.contains(allowed.get(UPDATE_RATE_NORMAL))) {
+            return Optional.of(UPDATE_RATE_NORMAL);
+        } else if (preferred.contains(allowed.get(UPDATE_RATE_INFREQUENT))) {
+            return Optional.of(UPDATE_RATE_INFREQUENT);
+        } else {
+            return Optional.empty();
+        }
+    }
+
+    @IntDef(value = {
+            InternalReason.UNKNOWN,
+            InternalReason.LOCAL_REQUEST,
+            InternalReason.REMOTE_REQUEST,
+            InternalReason.UNSUPPORTED,
+            InternalReason.SYSTEM_POLICY,
+            InternalReason.NO_PEERS_FOUND,
+            InternalReason.INTERNAL_ERROR,
+            InternalReason.BACKGROUND_RANGING_POLICY,
+            InternalReason.PEER_CAPABILITIES_MISMATCH,
+    })
+    @Target({ElementType.TYPE_USE})
+    public @interface InternalReason {
+        int UNKNOWN = 0;
+        int LOCAL_REQUEST = 1;
+        int REMOTE_REQUEST = 2;
+        int UNSUPPORTED = 3;
+        int SYSTEM_POLICY = 4;
+        int NO_PEERS_FOUND = 5;
+        int INTERNAL_ERROR = 6;
+        int BACKGROUND_RANGING_POLICY = 7;
+        int PEER_CAPABILITIES_MISMATCH = 8;
     }
 }
diff --git a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiAdapter.java b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiAdapter.java
index b5b09319..361b7bfd 100644
--- a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiAdapter.java
+++ b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiAdapter.java
@@ -19,7 +19,11 @@ package com.android.server.ranging.blerssi;
 import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
 import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
 
+import static com.android.server.ranging.RangingUtils.convertBluetoothReasonCode;
+
 import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.AlarmManager;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothManager;
@@ -28,7 +32,10 @@ import android.bluetooth.le.DistanceMeasurementMethod;
 import android.bluetooth.le.DistanceMeasurementParams;
 import android.bluetooth.le.DistanceMeasurementResult;
 import android.bluetooth.le.DistanceMeasurementSession;
+import android.content.AttributionSource;
 import android.content.Context;
+import android.os.SystemClock;
+import android.ranging.DataNotificationConfig;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
 import android.ranging.RangingManager;
@@ -36,10 +43,17 @@ import android.ranging.RangingMeasurement;
 import android.ranging.ble.rssi.BleRssiRangingParams;
 import android.util.Log;
 
+import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils;
+import com.android.server.ranging.RangingUtils.InternalReason;
 import com.android.server.ranging.RangingUtils.StateMachine;
 import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.util.DataNotificationManager;
+
+import com.google.common.collect.ImmutableSet;
 
 import java.util.concurrent.Executors;
 
@@ -47,6 +61,8 @@ public class BleRssiAdapter implements RangingAdapter {
 
     private static final String TAG = BleRssiAdapter.class.getSimpleName();
 
+    private final Context mContext;
+    private final RangingInjector mRangingInjector;
     private final BluetoothAdapter mBluetoothAdapter;
     private final StateMachine<State> mStateMachine;
     private Callback mCallbacks;
@@ -55,15 +71,43 @@ public class BleRssiAdapter implements RangingAdapter {
     private DistanceMeasurementSession mSession;
     private BleRssiConfig mConfig;
 
-    public BleRssiAdapter(@NonNull Context context) {
+    private DataNotificationManager mDataNotificationManager;
+    @Nullable
+    private AttributionSource mNonPrivilegedAttributionSource;
+
+    private final AlarmManager mAlarmManager;
+
+    private final AlarmManager.OnAlarmListener mMeasurementLimitListener;
+
+    public BleRssiAdapter(@NonNull Context context, RangingInjector rangingInjector) {
         if (!RangingTechnology.RSSI.isSupported(context)) {
             throw new IllegalArgumentException("BT_RSSI system feature not found.");
         }
+        mContext = context;
+        mRangingInjector = rangingInjector;
         mBluetoothAdapter = context.getSystemService(BluetoothManager.class).getAdapter();
         mStateMachine = new StateMachine<>(State.STOPPED);
         mCallbacks = null;
         mSession = null;
         mConfig = null;
+        mDataNotificationManager = new DataNotificationManager(
+                new DataNotificationConfig.Builder().build(),
+                new DataNotificationConfig.Builder().build()
+        );
+        mAlarmManager = mContext.getSystemService(AlarmManager.class);
+        mMeasurementLimitListener = () -> {
+            Log.i(TAG, "Measurements limit exceeded. Stopping the session");
+            Executors.newCachedThreadPool().execute(this::stop);
+        };
+    }
+
+    public DataNotificationManager getDataNotificationManager() {
+        return mDataNotificationManager;
+    }
+
+    @VisibleForTesting
+    public void setSession(DistanceMeasurementSession session) {
+        mSession = session;
     }
 
     @Override
@@ -73,28 +117,44 @@ public class BleRssiAdapter implements RangingAdapter {
 
     @Override
     public void start(
-            @NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callback
+            @NonNull RangingSessionConfig.TechnologyConfig config,
+            @Nullable AttributionSource nonPrivilegedAttributionSource,
+            @NonNull Callback callback
     ) {
         Log.i(TAG, "Start called.");
-        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
-            Log.v(TAG, "Attempted to start adapter when it was already started");
+        mCallbacks = callback;
+        mNonPrivilegedAttributionSource = nonPrivilegedAttributionSource;
+        if (mNonPrivilegedAttributionSource != null && !mRangingInjector.isForegroundAppOrService(
+                mNonPrivilegedAttributionSource.getUid(),
+                mNonPrivilegedAttributionSource.getPackageName())) {
+            Log.w(TAG, "Background ranging is not supported");
+            closeForReason(InternalReason.BACKGROUND_RANGING_POLICY);
             return;
         }
-
         if (!(config instanceof BleRssiConfig bleRssiConfig)) {
             Log.w(TAG, "Tried to start adapter with invalid ranging parameters");
+            closeForReason(InternalReason.INTERNAL_ERROR);
             return;
         }
-
         BleRssiRangingParams bleRssiRangingParams = bleRssiConfig.getRangingParams();
         if ((bleRssiConfig.getPeerDevice() == null)
                 || (bleRssiRangingParams.getPeerBluetoothAddress() == null)) {
             Log.e(TAG, "Peer device is null");
+            closeForReason(InternalReason.INTERNAL_ERROR);
+            return;
+        }
+        if (mBluetoothAdapter.getState() == BluetoothAdapter.STATE_OFF) {
+            Log.e(TAG, "Failed to start ranging, Bluetooth is turned off!");
+            closeForReason(InternalReason.UNSUPPORTED);
+            return;
+        }
+        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
+            Log.v(TAG, "Attempted to start adapter when it was already started");
+            closeForReason(InternalReason.INTERNAL_ERROR);
             return;
         }
 
         mConfig = bleRssiConfig;
-        mCallbacks = callback;
         mRangingDevice = bleRssiConfig.getPeerDevice();
         mDeviceFromPeerBluetoothAddress =
                 mBluetoothAdapter.getRemoteDevice(bleRssiRangingParams.getPeerBluetoothAddress());
@@ -108,11 +168,21 @@ public class BleRssiAdapter implements RangingAdapter {
                                 bleRssiConfig.getRangingParams().getRangingUpdateRate()))
                         .setMethodId(DistanceMeasurementMethod.DISTANCE_MEASUREMENT_METHOD_RSSI)
                         .build();
+        mDataNotificationManager = new DataNotificationManager(
+                bleRssiConfig.getSessionConfig().getDataNotificationConfig(),
+                bleRssiConfig.getSessionConfig().getDataNotificationConfig());
 
         distanceMeasurementManager.startMeasurementSession(params,
                 Executors.newSingleThreadExecutor(), mDistanceMeasurementCallback);
         // Added callback here to be consistent with other ranging technology.
-        mCallbacks.onStarted(bleRssiConfig.getPeerDevice());
+        mCallbacks.onStarted(ImmutableSet.of(bleRssiConfig.getPeerDevice()));
+        if (mConfig.getSessionConfig().getRangingMeasurementsLimit() > 0) {
+            RangingUtils.setMeasurementsLimitTimeout(
+                    mAlarmManager,
+                    mMeasurementLimitListener,
+                    mConfig.getSessionConfig().getRangingMeasurementsLimit(),
+                    getIntervalInMs(mConfig.getRangingParams().getRangingUpdateRate()));
+        }
     }
 
     public enum State {
@@ -131,6 +201,41 @@ public class BleRssiAdapter implements RangingAdapter {
         }
     }
 
+    public static int getIntervalInMs(int updateRate) {
+        switch (updateRate) {
+            case UPDATE_RATE_FREQUENT -> {
+                return 500;
+            }
+            case UPDATE_RATE_INFREQUENT -> {
+                return 3000;
+            }
+            default -> {
+                return 1000;
+            }
+        }
+    }
+
+    @Override
+    public void appMovedToBackground() {
+        if (mNonPrivilegedAttributionSource != null && mStateMachine.getState() != State.STOPPED) {
+            mDataNotificationManager.updateConfigAppMovedToBackground();
+        }
+    }
+
+    @Override
+    public void appMovedToForeground() {
+        if (mNonPrivilegedAttributionSource != null && mStateMachine.getState() != State.STOPPED) {
+            mDataNotificationManager.updateConfigAppMovedToForeground();
+        }
+    }
+
+    @Override
+    public void appInBackgroundTimeout() {
+        if (mNonPrivilegedAttributionSource != null && mStateMachine.getState() != State.STOPPED) {
+            stop();
+        }
+    }
+
     @Override
     public void stop() {
         Log.i(TAG, "Stop called.");
@@ -147,17 +252,24 @@ public class BleRssiAdapter implements RangingAdapter {
     }
 
     private void clear() {
+        if (mConfig != null && mConfig.getSessionConfig().getRangingMeasurementsLimit() > 0) {
+            mAlarmManager.cancel(mMeasurementLimitListener);
+        }
         mSession = null;
         mCallbacks = null;
+        mConfig = null;
     }
 
-    private void closeForReason(@Callback.ClosedReason int reason) {
-        mCallbacks.onStopped(mConfig.getPeerDevice());
+    private void closeForReason(@InternalReason int reason) {
+        if (mRangingDevice != null) {
+            mCallbacks.onStopped(ImmutableSet.of(mRangingDevice), reason);
+        }
         mCallbacks.onClosed(reason);
         clear();
     }
 
-    private final DistanceMeasurementSession.Callback mDistanceMeasurementCallback =
+    @VisibleForTesting
+    public final DistanceMeasurementSession.Callback mDistanceMeasurementCallback =
             new DistanceMeasurementSession.Callback() {
                 public void onStarted(DistanceMeasurementSession session) {
                     Log.i(TAG, "DistanceMeasurement onStarted !");
@@ -170,16 +282,18 @@ public class BleRssiAdapter implements RangingAdapter {
 
                 public void onStartFail(int reason) {
                     Log.i(TAG, "DistanceMeasurement onStartFail ! reason " + reason);
-                    closeForReason(Callback.ClosedReason.FAILED_TO_START);
+                    closeForReason(convertBluetoothReasonCode(reason));
                 }
 
                 public void onStopped(DistanceMeasurementSession session, int reason) {
                     Log.i(TAG, "DistanceMeasurement onStopped ! reason " + reason);
-                    // TODO: Check this.
-                    closeForReason(Callback.ClosedReason.REQUESTED);
+                    closeForReason(convertBluetoothReasonCode(reason));
                 }
 
                 public void onResult(BluetoothDevice device, DistanceMeasurementResult result) {
+                    if (!mDataNotificationManager.shouldSendResult(result.getResultMeters())) {
+                        return;
+                    }
                     Log.i(TAG, "DistanceMeasurement onResult ! "
                             + result.getResultMeters()
                             + ", "
@@ -189,7 +303,10 @@ public class BleRssiAdapter implements RangingAdapter {
                             .setDistance(new RangingMeasurement.Builder()
                                     .setMeasurement(result.getResultMeters())
                                     .build())
-                            .setTimestampMillis(result.getMeasurementTimestampNanos() * 1000);
+                            // DistanceMeasurementResult#getMeasurementTimestampNanos is flagged
+                            // with FLAG_CHANNEL_SOUNDING_25Q2_APIS, check whether we can use that
+                            // instead.
+                            .setTimestampMillis(SystemClock.elapsedRealtime());
                     if (!Double.isNaN(result.getAzimuthAngle())) {
                         dataBuilder.setAzimuth(new RangingMeasurement.Builder()
                                 .setMeasurement(result.getAzimuthAngle())
diff --git a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiCapabilitiesAdapter.java b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiCapabilitiesAdapter.java
index 331a18c8..bdd011ef 100644
--- a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiCapabilitiesAdapter.java
+++ b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiCapabilitiesAdapter.java
@@ -27,11 +27,16 @@ import android.bluetooth.BluetoothManager;
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.ranging.RangingCapabilities;
+import android.ranging.ble.rssi.BleRssiRangingCapabilities;
+import android.util.Log;
 
 import com.android.server.ranging.CapabilitiesProvider;
 import com.android.server.ranging.CapabilitiesProvider.TechnologyAvailabilityListener;
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingTechnology;
 
 public class BleRssiCapabilitiesAdapter extends CapabilitiesProvider.CapabilitiesAdapter {
+    private static final String TAG = BleRssiCapabilitiesAdapter.class.getSimpleName();
 
     private final Context mContext;
     private final BluetoothManager mBluetoothManager;
@@ -50,7 +55,8 @@ public class BleRssiCapabilitiesAdapter extends CapabilitiesProvider.Capabilitie
     }
 
     public static boolean isSupported(Context context) {
-        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE);
+        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)
+                && RangingInjector.getInstance().isRangingTechnologyEnabled(RangingTechnology.RSSI);
     }
 
     @Override
@@ -70,8 +76,17 @@ public class BleRssiCapabilitiesAdapter extends CapabilitiesProvider.Capabilitie
 
     @Nullable
     @Override
-    public RangingCapabilities.TechnologyCapabilities getCapabilities() {
-        // No special capabilities.
-        return null;
+    public BleRssiRangingCapabilities getCapabilities() {
+        if (getAvailability() != ENABLED) return null;
+
+        try {
+            return new BleRssiRangingCapabilities(
+                    ((BluetoothManager) mContext.getSystemService(BluetoothManager.class))
+                            .getAdapter()
+                            .getAddress());
+        } catch (UnsupportedOperationException e) {
+            Log.e(TAG, "Failed to get ble rssi capabilities: " + e);
+            return null;
+        }
     }
 }
diff --git a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfig.java b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfig.java
index 612d0222..d5d939f8 100644
--- a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfig.java
+++ b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfig.java
@@ -16,20 +16,36 @@
 
 package com.android.server.ranging.blerssi;
 
-import android.ranging.DataNotificationConfig;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
 import android.ranging.RangingDevice;
 import android.ranging.RangingPreference;
+import android.ranging.SessionConfig;
 import android.ranging.ble.rssi.BleRssiRangingParams;
+import android.ranging.raw.RawRangingDevice;
 
 import androidx.annotation.NonNull;
 
 import com.android.server.ranging.RangingTechnology;
 import com.android.server.ranging.session.RangingSessionConfig;
 
+import com.google.common.collect.ImmutableMap;
+
+import java.time.Duration;
+import java.util.Objects;
+
 public class BleRssiConfig implements RangingSessionConfig.UnicastTechnologyConfig {
     private static final String TAG = BleRssiConfig.class.getSimpleName();
 
-    private final DataNotificationConfig mDataNotificationConfig;
+    public static final ImmutableMap<@RawRangingDevice.RangingUpdateRate Integer, Duration>
+            BLE_RSSI_UPDATE_RATE_DURATIONS = ImmutableMap.of(
+            UPDATE_RATE_NORMAL, Duration.ofSeconds(1),
+            UPDATE_RATE_INFREQUENT, Duration.ofSeconds(3),
+            UPDATE_RATE_FREQUENT, Duration.ofMillis(500));
+
+    private final SessionConfig mSessionConfig;
     private final BleRssiRangingParams mRangingParams;
 
     private final RangingDevice mPeerDevice;
@@ -39,11 +55,11 @@ public class BleRssiConfig implements RangingSessionConfig.UnicastTechnologyConf
 
     public BleRssiConfig(int deviceRole,
             BleRssiRangingParams bleRssiRangingParams,
-            DataNotificationConfig dataNotificationConfig,
+            SessionConfig sessionConfig,
             RangingDevice peerDevice) {
         mDeviceRole = deviceRole;
         mRangingParams = bleRssiRangingParams;
-        mDataNotificationConfig = dataNotificationConfig;
+        mSessionConfig = sessionConfig;
         mPeerDevice = peerDevice;
     }
 
@@ -52,15 +68,16 @@ public class BleRssiConfig implements RangingSessionConfig.UnicastTechnologyConf
         return RangingTechnology.RSSI;
     }
 
-    public DataNotificationConfig getDataNotificationConfig() {
-        return mDataNotificationConfig;
+    public SessionConfig getSessionConfig() {
+        return mSessionConfig;
     }
 
     public BleRssiRangingParams getRangingParams() {
         return mRangingParams;
     }
 
-    public int getDeviceRole() {
+    @Override
+    public @RangingPreference.DeviceRole int getDeviceRole() {
         return mDeviceRole;
     }
 
@@ -72,8 +89,8 @@ public class BleRssiConfig implements RangingSessionConfig.UnicastTechnologyConf
     @Override
     public String toString() {
         return "BleRssiConfig{ "
-                + "mDataNotificationConfig="
-                + mDataNotificationConfig
+                + "mSessionConfig="
+                + mSessionConfig
                 + ", mRangingParams="
                 + mRangingParams
                 + ", mDeviceRole="
@@ -82,4 +99,18 @@ public class BleRssiConfig implements RangingSessionConfig.UnicastTechnologyConf
                 + mPeerDevice
                 + " }";
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof BleRssiConfig that)) return false;
+        return mDeviceRole == that.mDeviceRole && Objects.equals(mSessionConfig,
+                that.mSessionConfig) && Objects.equals(mRangingParams, that.mRangingParams)
+                && Objects.equals(mPeerDevice, that.mPeerDevice);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mSessionConfig, mRangingParams, mPeerDevice, mDeviceRole);
+    }
 }
diff --git a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfigSelector.java b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfigSelector.java
new file mode 100644
index 00000000..97e1e468
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfigSelector.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.blerssi;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+
+import static com.android.server.ranging.RangingUtils.getUpdateRateFromDurationRange;
+import static com.android.server.ranging.blerssi.BleRssiConfig.BLE_RSSI_UPDATE_RATE_DURATIONS;
+
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.ble.rssi.BleRssiRangingCapabilities;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.raw.RawRangingDevice;
+import android.util.Pair;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.server.ranging.RangingEngine;
+import com.android.server.ranging.RangingEngine.ConfigSelectionException;
+import com.android.server.ranging.RangingUtils.InternalReason;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.SetConfigurationMessage.TechnologyOobConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+
+import java.util.function.Function;
+
+public class BleRssiConfigSelector implements RangingEngine.ConfigSelector {
+    private final SessionConfig mSessionConfig;
+    private final OobInitiatorRangingConfig mOobConfig;
+    private final String mLocalAddress;
+    private final BiMap<RangingDevice, String> mPeerAddresses;
+
+    private static boolean isCapableOfConfig(
+            @NonNull OobInitiatorRangingConfig oobConfig, BleRssiRangingCapabilities capabilities
+    ) {
+        if (capabilities == null) return false;
+        return getUpdateRateFromDurationRange(
+                oobConfig.getRangingIntervalRange(), BLE_RSSI_UPDATE_RATE_DURATIONS).isPresent();
+    }
+
+    public BleRssiConfigSelector(
+            @NonNull SessionConfig sessionConfig,
+            @NonNull OobInitiatorRangingConfig oobConfig,
+            @Nullable BleRssiRangingCapabilities capabilities
+    ) throws ConfigSelectionException {
+        if (!isCapableOfConfig(oobConfig, capabilities)) {
+            throw new ConfigSelectionException(
+                    "Local device is incapable of provided BLE RSSI config",
+                    InternalReason.UNSUPPORTED);
+        }
+        mSessionConfig = sessionConfig;
+        mOobConfig = oobConfig;
+        mLocalAddress = capabilities.getBluetoothAddress();
+        mPeerAddresses = HashBiMap.create();
+    }
+
+    public void addPeerCapabilities(
+            @NonNull RangingDevice peer, @NonNull CapabilityResponseMessage response
+    ) throws ConfigSelectionException {
+        BleRssiOobCapabilities capabilities = response.getBleRssiCapabilities();
+        if (capabilities == null) {
+            throw new ConfigSelectionException("Peer " + peer + " does not support BLE RSSI",
+                    InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+
+        mPeerAddresses.put(peer, capabilities.getBluetoothAddress());
+    }
+
+    @Override
+    public boolean hasPeersToConfigure() {
+        return !mPeerAddresses.isEmpty();
+    }
+
+    @Override
+    public @NonNull Pair<
+            ImmutableSet<TechnologyConfig>,
+            ImmutableMap<RangingDevice, TechnologyOobConfig>
+    > selectConfigs() throws ConfigSelectionException {
+        SelectedBleRssiConfig configs = new SelectedBleRssiConfig();
+        return Pair.create(configs.getLocalConfigs(), configs.getPeerConfigs());
+    }
+
+    private class SelectedBleRssiConfig {
+        private final @RawRangingDevice.RangingUpdateRate int mRangingUpdateRate;
+
+        SelectedBleRssiConfig() throws ConfigSelectionException {
+            mRangingUpdateRate = selectRangingUpdateRate();
+        }
+
+        public @NonNull ImmutableSet<TechnologyConfig> getLocalConfigs() {
+            return mPeerAddresses.entrySet().stream()
+                    .map((entry) -> new BleRssiConfig(
+                            DEVICE_ROLE_INITIATOR,
+                            new BleRssiRangingParams.Builder(entry.getValue())
+                                    .setRangingUpdateRate(mRangingUpdateRate)
+                                    .build(),
+                            mSessionConfig,
+                            entry.getKey()))
+                    .collect(ImmutableSet.toImmutableSet());
+        }
+
+        public @NonNull ImmutableMap<RangingDevice, TechnologyOobConfig> getPeerConfigs() {
+            BleRssiOobConfig config = BleRssiOobConfig.builder()
+                    .setBluetoothAddress(mLocalAddress)
+                    .build();
+            return mPeerAddresses.keySet().stream().collect(
+                    ImmutableMap.toImmutableMap(Function.identity(), (unused) -> config));
+        }
+    }
+
+    private @RawRangingDevice.RangingUpdateRate int selectRangingUpdateRate()
+            throws ConfigSelectionException {
+
+        return getUpdateRateFromDurationRange(
+                mOobConfig.getRangingIntervalRange(), BLE_RSSI_UPDATE_RATE_DURATIONS)
+                .orElseThrow(() -> new ConfigSelectionException(
+                        "Configured ranging interval range is incompatible with BLE RSSI",
+                        InternalReason.UNSUPPORTED));
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiOobCapabilities.java b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiOobCapabilities.java
new file mode 100644
index 00000000..6e983be0
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiOobCapabilities.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.blerssi;
+
+import android.ranging.ble.rssi.BleRssiRangingCapabilities;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.Conversions;
+import com.android.server.ranging.oob.TechnologyHeader;
+
+import com.google.auto.value.AutoValue;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+@AutoValue
+public abstract class BleRssiOobCapabilities {
+    /** Size in bytes of all properties when serialized. */
+    private static final int EXPECTED_SIZE_BYTES = 8;
+
+    // Size in bytes of properties for serialization/deserialization.
+    private static final int BLUETOOTH_ADDRESS_SIZE = 6;
+
+    public static int getSize() {
+        return EXPECTED_SIZE_BYTES;
+    }
+
+    /** Returns the size of the object in bytes when serialized. */
+    public static BleRssiOobCapabilities parseBytes(byte[] bytes) {
+        TechnologyHeader header = TechnologyHeader.parseBytes(bytes);
+
+        if (bytes.length < EXPECTED_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "BleRssiOobCapabilities size is %d, expected at least %d",
+                            bytes.length, EXPECTED_SIZE_BYTES));
+        }
+
+        if (bytes.length < header.getSize()) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "BleRssiOobCapabilities header size field is %d, but the size of the "
+                                    + "array is %d", header.getSize(), bytes.length));
+        }
+
+        if (header.getRangingTechnology() != RangingTechnology.RSSI) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "BleRssiOobCapabilities header technology field is %s, expected %s",
+                            header.getRangingTechnology(), RangingTechnology.RSSI));
+        }
+
+        int cursor = header.getHeaderSize();
+
+        // Device address
+        String bluetoothAddress = Conversions.macAddressToString(
+                Arrays.copyOfRange(bytes, cursor, cursor + BLUETOOTH_ADDRESS_SIZE));
+        cursor += BLUETOOTH_ADDRESS_SIZE;
+
+        return BleRssiOobCapabilities.builder().setBluetoothAddress(bluetoothAddress).build();
+    }
+
+    public final byte[] toBytes() {
+        ByteBuffer buffer = ByteBuffer.allocate(EXPECTED_SIZE_BYTES);
+        buffer
+                .put(RangingTechnology.RSSI.toByte())
+                .put((byte) EXPECTED_SIZE_BYTES)
+                .put(Conversions.macAddressToBytes(getBluetoothAddress()));
+
+        return buffer.array();
+    }
+
+    public static BleRssiOobCapabilities fromRangingCapabilities(
+            BleRssiRangingCapabilities capabilities) {
+        return BleRssiOobCapabilities.builder()
+                .setBluetoothAddress(capabilities.getBluetoothAddress())
+                .build();
+    }
+
+    /** Returns the Bluetooth address of the device. */
+    public abstract String getBluetoothAddress();
+
+    /** Returns a builder for {@link BleRssiOobCapabilities}. */
+    public static Builder builder() {
+        return new AutoValue_BleRssiOobCapabilities.Builder();
+    }
+
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setBluetoothAddress(String address);
+
+        public abstract BleRssiOobCapabilities autoBuild();
+
+        public BleRssiOobCapabilities build() {
+            BleRssiOobCapabilities capabilities = autoBuild();
+            // Validate Bluetooth Address, will throw if invalid.
+            var unused = Conversions.macAddressToBytes(capabilities.getBluetoothAddress());
+            return capabilities;
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiOobConfig.java b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiOobConfig.java
new file mode 100644
index 00000000..9ef9aefd
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiOobConfig.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.blerssi;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.Conversions;
+import com.android.server.ranging.oob.SetConfigurationMessage;
+import com.android.server.ranging.oob.TechnologyHeader;
+
+import com.google.auto.value.AutoValue;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+@AutoValue
+public abstract class BleRssiOobConfig implements SetConfigurationMessage.TechnologyOobConfig {
+    /** Size in bytes of all properties when serialized. */
+    private static final int EXPECTED_SIZE_BYTES = 8;
+
+    private static final int BLUETOOTH_ADDRESS_SIZE = 6;
+
+    public static int getSize() {
+        return EXPECTED_SIZE_BYTES;
+    }
+
+    public static BleRssiOobConfig parseBytes(byte[] bytes) {
+        TechnologyHeader header = TechnologyHeader.parseBytes(bytes);
+
+        if (bytes.length < EXPECTED_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format("BleRssiOobConfig size is %d, expected at least %d",
+                            bytes.length, EXPECTED_SIZE_BYTES));
+        }
+
+        if (header.getRangingTechnology() != RangingTechnology.RSSI) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "BleRssiOobConfig header technology field is %s, expected %s",
+                            header.getRangingTechnology(), RangingTechnology.RSSI));
+        }
+
+        int parseCursor = header.getHeaderSize();
+
+        String address = Conversions.macAddressToString(
+                Arrays.copyOfRange(bytes, parseCursor, parseCursor + BLUETOOTH_ADDRESS_SIZE));
+        parseCursor += BLUETOOTH_ADDRESS_SIZE;
+
+        return BleRssiOobConfig.builder()
+                .setBluetoothAddress(address)
+                .build();
+    }
+
+    public final byte[] toBytes() {
+        ByteBuffer buffer = ByteBuffer.allocate(EXPECTED_SIZE_BYTES);
+        buffer
+                .put(RangingTechnology.RSSI.toByte())
+                .put((byte) EXPECTED_SIZE_BYTES)
+                .put(Conversions.macAddressToBytes(getBluetoothAddress()));
+
+        return buffer.array();
+    }
+
+    /** Returns the Bluetooth address of the device. */
+    public abstract String getBluetoothAddress();
+
+    /** Returns a builder for {@link BleRssiOobConfig}. */
+    public static BleRssiOobConfig.Builder builder() {
+        return new AutoValue_BleRssiOobConfig.Builder();
+    }
+
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setBluetoothAddress(String address);
+
+        public abstract BleRssiOobConfig autoBuild();
+
+        public BleRssiOobConfig build() {
+            BleRssiOobConfig config = autoBuild();
+            var unused = Conversions.macAddressToBytes(config.getBluetoothAddress());
+            return config;
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsAdapter.java b/ranging/service/java/com/android/server/ranging/cs/CsAdapter.java
index 70864f76..0d7c6975 100644
--- a/ranging/service/java/com/android/server/ranging/cs/CsAdapter.java
+++ b/ranging/service/java/com/android/server/ranging/cs/CsAdapter.java
@@ -20,6 +20,11 @@ import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
 import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
 import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
 
+import static com.android.server.ranging.RangingUtils.InternalReason;
+import static com.android.server.ranging.RangingUtils.convertBluetoothReasonCode;
+
+import android.annotation.Nullable;
+import android.app.AlarmManager;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothManager;
@@ -29,19 +34,28 @@ import android.bluetooth.le.DistanceMeasurementMethod;
 import android.bluetooth.le.DistanceMeasurementParams;
 import android.bluetooth.le.DistanceMeasurementResult;
 import android.bluetooth.le.DistanceMeasurementSession;
+import android.content.AttributionSource;
 import android.content.Context;
+import android.os.CancellationSignal;
+import android.ranging.DataNotificationConfig;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
 import android.ranging.RangingMeasurement;
-import android.ranging.ble.cs.CsRangingParams;
+import android.ranging.ble.cs.BleCsRangingParams;
 import android.util.Log;
 
 import androidx.annotation.NonNull;
 
+import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils;
 import com.android.server.ranging.RangingUtils.StateMachine;
 import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.util.DataNotificationManager;
+
+import com.google.common.collect.ImmutableSet;
 
 import java.util.concurrent.Executors;
 
@@ -52,6 +66,8 @@ import java.util.concurrent.Executors;
 public class CsAdapter implements RangingAdapter {
     private static final String TAG = CsAdapter.class.getSimpleName();
 
+    private final Context mContext;
+    private final RangingInjector mRangingInjector;
     private final BluetoothAdapter mBluetoothAdapter;
     private final StateMachine<State> mStateMachine;
     private Callback mCallbacks;
@@ -63,17 +79,35 @@ public class CsAdapter implements RangingAdapter {
     private RangingDevice mRangingDevice;
 
     /** Invariant: non-null while a ranging session is active */
+    private CancellationSignal mStartCancellationSignal;
     private DistanceMeasurementSession mSession;
+    private CsConfig mConfig;
+    private DataNotificationManager mDataNotificationManager;
+    private AttributionSource mNonPrivilegedAttributionSource;
+
+    private final AlarmManager mAlarmManager;
+    private final AlarmManager.OnAlarmListener mMeasurementLimitListener;
 
     /** Injectable constructor for testing. */
-    public CsAdapter(@NonNull Context context) {
+    public CsAdapter(@NonNull Context context, RangingInjector rangingInjector) {
         if (!RangingTechnology.CS.isSupported(context)) {
             throw new IllegalArgumentException("BT_CS system feature not found.");
         }
+        mContext = context;
         mBluetoothAdapter = context.getSystemService(BluetoothManager.class).getAdapter();
         mStateMachine = new StateMachine<>(State.STOPPED);
         mCallbacks = null;
         mSession = null;
+        mRangingInjector = rangingInjector;
+        mDataNotificationManager = new DataNotificationManager(
+                new DataNotificationConfig.Builder().build(),
+                new DataNotificationConfig.Builder().build()
+        );
+        mAlarmManager = mContext.getSystemService(AlarmManager.class);
+        mMeasurementLimitListener = () -> {
+            Log.i(TAG, "Measurements limit exceeded. Stopping the session");
+            Executors.newCachedThreadPool().execute(this::stop);
+        };
     }
 
     @Override
@@ -81,54 +115,117 @@ public class CsAdapter implements RangingAdapter {
         return RangingTechnology.CS;
     }
 
+    public DataNotificationManager getDataNotificationManager() {
+        return mDataNotificationManager;
+    }
+
+    @VisibleForTesting
+    public void setSession(DistanceMeasurementSession session) {
+        mSession = session;
+    }
+
     @Override
     public void start(
-            @NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callback
+            @NonNull RangingSessionConfig.TechnologyConfig config,
+            @Nullable AttributionSource nonPrivilegedAttributionSource,
+            @NonNull Callback callback
     ) {
         Log.i(TAG, "Start called.");
-        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
-            Log.v(TAG, "Attempted to start adapter when it was already started");
+        mCallbacks = callback;
+        mNonPrivilegedAttributionSource = nonPrivilegedAttributionSource;
+        if (mNonPrivilegedAttributionSource != null && !mRangingInjector.isForegroundAppOrService(
+                mNonPrivilegedAttributionSource.getUid(),
+                mNonPrivilegedAttributionSource.getPackageName())) {
+            Log.e(TAG, "Background ranging is not supported");
+            closeForReason(InternalReason.BACKGROUND_RANGING_POLICY);
             return;
         }
-
         if (!(config instanceof CsConfig csConfig)) {
             Log.w(TAG, "Tried to start adapter with invalid ranging parameters");
+            closeForReason(InternalReason.INTERNAL_ERROR);
             return;
         }
-
-        CsRangingParams csRangingParams = csConfig.getRangingParams();
+        BleCsRangingParams bleCsRangingParams = csConfig.getRangingParams();
         if ((csConfig.getPeerDevice() == null)
-                || (csRangingParams.getPeerBluetoothAddress() == null)) {
+                || (bleCsRangingParams.getPeerBluetoothAddress() == null)) {
             Log.e(TAG, "Peer device is null");
+            closeForReason(InternalReason.INTERNAL_ERROR);
             return;
         }
-
-        mCallbacks = callback;
+        if (mBluetoothAdapter.getState() == BluetoothAdapter.STATE_OFF) {
+            Log.e(TAG, "Failed to start ranging, Bluetooth is turned off!");
+            closeForReason(InternalReason.UNSUPPORTED);
+            return;
+        }
+        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
+            Log.v(TAG, "Attempted to start adapter when it was already started");
+            closeForReason(InternalReason.INTERNAL_ERROR);
+            return;
+        }
+        mConfig = csConfig;
         mRangingDevice = csConfig.getPeerDevice();
         mDeviceFromPeerBluetoothAddress =
-                mBluetoothAdapter.getRemoteDevice(csRangingParams.getPeerBluetoothAddress());
+                mBluetoothAdapter.getRemoteDevice(bleCsRangingParams.getPeerBluetoothAddress());
         DistanceMeasurementManager distanceMeasurementManager =
                 mBluetoothAdapter.getDistanceMeasurementManager();
         int duration = DistanceMeasurementParams.getMaxDurationSeconds();
-        int frequency = getFrequency(csRangingParams.getRangingUpdateRate());
+        int frequency = getFrequency(bleCsRangingParams.getRangingUpdateRate());
         int methodId = DistanceMeasurementMethod.DISTANCE_MEASUREMENT_METHOD_CHANNEL_SOUNDING;
 
         DistanceMeasurementParams params =
                 new DistanceMeasurementParams.Builder(mDeviceFromPeerBluetoothAddress)
                         .setChannelSoundingParams(new ChannelSoundingParams.Builder()
-                                .setLocationType(csRangingParams.getLocationType())
-                                .setCsSecurityLevel(csRangingParams.getSecurityLevel())
-                                .setSightType(csRangingParams.getSightType())
+                                .setLocationType(bleCsRangingParams.getLocationType())
+                                .setCsSecurityLevel(bleCsRangingParams.getSecurityLevel())
+                                .setSightType(bleCsRangingParams.getSightType())
                                 .build())
                         .setDurationSeconds(duration)
                         .setFrequency(frequency)
                         .setMethodId(methodId)
                         .build();
 
-        distanceMeasurementManager.startMeasurementSession(params,
-                Executors.newSingleThreadExecutor(), mDistanceMeasurementCallback);
+        mDataNotificationManager = new DataNotificationManager(
+                csConfig.getSessionConfig().getDataNotificationConfig(),
+                csConfig.getSessionConfig().getDataNotificationConfig());
+
+        try {
+            mStartCancellationSignal = distanceMeasurementManager.startMeasurementSession(params,
+                    Executors.newSingleThreadExecutor(), mDistanceMeasurementCallback);
+        } catch (IllegalStateException e) {
+            Log.e(TAG, "Error starting CS session", e);
+            closeForReason(InternalReason.INTERNAL_ERROR);
+            return;
+        }
         // Callback here to be consistent with other ranging technologies.
-        mCallbacks.onStarted(csConfig.getPeerDevice());
+        mCallbacks.onStarted(ImmutableSet.of(csConfig.getPeerDevice()));
+        if (mConfig.getSessionConfig().getRangingMeasurementsLimit() > 0) {
+            RangingUtils.setMeasurementsLimitTimeout(
+                    mAlarmManager,
+                    mMeasurementLimitListener,
+                    mConfig.getSessionConfig().getRangingMeasurementsLimit(),
+                    getIntervalInMs(mConfig.getRangingParams().getRangingUpdateRate()));
+        }
+    }
+
+    @Override
+    public void appMovedToBackground() {
+        if (mNonPrivilegedAttributionSource != null && mStateMachine.getState() != State.STOPPED) {
+            mDataNotificationManager.updateConfigAppMovedToBackground();
+        }
+    }
+
+    @Override
+    public void appMovedToForeground() {
+        if (mNonPrivilegedAttributionSource != null && mStateMachine.getState() != State.STOPPED) {
+            mDataNotificationManager.updateConfigAppMovedToForeground();
+        }
+    }
+
+    @Override
+    public void appInBackgroundTimeout() {
+        if (mNonPrivilegedAttributionSource != null && mStateMachine.getState() != State.STOPPED) {
+            stop();
+        }
     }
 
     @Override
@@ -138,12 +235,15 @@ public class CsAdapter implements RangingAdapter {
             Log.v(TAG, "Attempted to stop adapter when it was already stopped");
             return;
         }
-
-        if (mSession == null) {
+        if (mStartCancellationSignal == null && mSession == null) {
             Log.v(TAG, "Attempted to stop adapter when ranging session was already stopped");
             return;
         }
-        mSession.stopSession();
+        if (mSession == null) {
+            mStartCancellationSignal.cancel(); // In the middle of starting.
+        } else {
+            mSession.stopSession();
+        }
     }
 
     private int getFrequency(int updateRate) {
@@ -157,15 +257,36 @@ public class CsAdapter implements RangingAdapter {
         return DistanceMeasurementParams.REPORT_FREQUENCY_LOW;
     }
 
-    private void closeForReason(@Callback.ClosedReason int reason) {
-        mCallbacks.onStopped(mRangingDevice);
+    public static int getIntervalInMs(int updateRate) {
+        switch (updateRate) {
+            case UPDATE_RATE_FREQUENT -> {
+                return 200;
+            }
+            case UPDATE_RATE_INFREQUENT -> {
+                return 5000;
+            }
+            default -> {
+                return 3000;
+            }
+        }
+    }
+
+    private void closeForReason(@InternalReason int reason) {
+        if (mRangingDevice != null) {
+            mCallbacks.onStopped(ImmutableSet.of(mRangingDevice), reason);
+        }
         mCallbacks.onClosed(reason);
         clear();
     }
 
     private void clear() {
+        if (mConfig != null && mConfig.getSessionConfig().getRangingMeasurementsLimit() > 0) {
+            mAlarmManager.cancel(mMeasurementLimitListener);
+        }
         mSession = null;
+        mStartCancellationSignal = null;
         mCallbacks = null;
+        mConfig = null;
     }
 
     public enum State {
@@ -173,7 +294,8 @@ public class CsAdapter implements RangingAdapter {
         STOPPED,
     }
 
-    private DistanceMeasurementSession.Callback mDistanceMeasurementCallback =
+    @VisibleForTesting
+    public DistanceMeasurementSession.Callback mDistanceMeasurementCallback =
             new DistanceMeasurementSession.Callback() {
                 public void onStarted(DistanceMeasurementSession session) {
                     Log.i(TAG, "DistanceMeasurement onStarted !");
@@ -186,33 +308,46 @@ public class CsAdapter implements RangingAdapter {
 
                 public void onStartFail(int reason) {
                     Log.i(TAG, "DistanceMeasurement onStartFail ! reason " + reason);
-                    closeForReason(Callback.ClosedReason.FAILED_TO_START);
+                    closeForReason(convertBluetoothReasonCode(reason));
                 }
 
                 public void onStopped(DistanceMeasurementSession session, int reason) {
                     Log.i(TAG, "DistanceMeasurement onStopped ! reason " + reason);
-                    closeForReason(Callback.ClosedReason.REQUESTED);
+                    closeForReason(convertBluetoothReasonCode(reason));
                 }
 
                 public void onResult(BluetoothDevice device, DistanceMeasurementResult result) {
+                    if (!mDataNotificationManager.shouldSendResult(result.getResultMeters())) {
+                        return;
+                    }
                     Log.i(TAG, "DistanceMeasurement onResult ! "
-                                    + result.getResultMeters()
-                                    + ", "
-                                    + result.getErrorMeters());
+                            + result.getResultMeters()
+                            + ", "
+                            + result.getErrorMeters());
                     RangingData.Builder dataBuilder = new RangingData.Builder()
-                            .setRangingTechnology((int) RangingTechnology.CS.getValue())
+                            .setRangingTechnology(RangingTechnology.CS.getValue())
                             .setDistance(new RangingMeasurement.Builder()
                                     .setMeasurement(result.getResultMeters())
+                                    .setConfidence(
+                                            (int) Math.round(result.getConfidenceLevel() * 2.0))
+                                    .setRawConfidence(result.getConfidenceLevel())
+                                    .setError(result.getErrorMeters())
                                     .build())
-                            .setTimestampMillis(result.getMeasurementTimestampNanos() * 1000);
+                            .setTimestampMillis(RangingUtils.convertNanosToMillis(
+                                    result.getMeasurementTimestampNanos()))
+                            .setDelaySpreadMeters(result.getDelaySpreadMeters())
+                            .setDetectedAttackLevel((byte) result.getDetectedAttackLevel())
+                            .setVelocityMetersPerSec(result.getVelocityMetersPerSecond());
                     if (!Double.isNaN(result.getAzimuthAngle())) {
                         dataBuilder.setAzimuth(new RangingMeasurement.Builder()
                                 .setMeasurement(result.getAzimuthAngle())
+                                .setError(result.getErrorAzimuthAngle())
                                 .build());
                     }
                     if (!Double.isNaN(result.getAltitudeAngle())) {
                         dataBuilder.setElevation(new RangingMeasurement.Builder()
                                 .setMeasurement(result.getAltitudeAngle())
+                                .setError(result.getErrorAltitudeAngle())
                                 .build());
                     }
                     synchronized (mStateMachine) {
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsCapabilities.java b/ranging/service/java/com/android/server/ranging/cs/CsCapabilities.java
deleted file mode 100644
index 88d85a9f..00000000
--- a/ranging/service/java/com/android/server/ranging/cs/CsCapabilities.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.ranging.cs;
-
-import com.android.server.ranging.RangingTechnology;
-import com.android.server.ranging.RangingUtils.Conversions;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableList;
-
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-
-/** Channel Sounding Capability data send as part of CapabilityResponseMessage during Finder OOB. */
-@AutoValue
-public abstract class CsCapabilities {
-
-    /** Size in bytes of all properties when serialized. */
-    private static final int EXPECTED_SIZE_BYTES = 2;
-
-    // Size in bytes for each properties for serialization/deserialization.
-    private static final int TECHNOLOGY_ID_SIZE = 1;
-    private static final int SECURITY_LEVELS_SIZE = 4;
-
-    private static final int SECURITY_LEVELS_SHIFT = 0;
-
-    /** Returns the size of this {@link CsCapabilities} object when serialized. */
-    public int getSize() {
-        return EXPECTED_SIZE_BYTES;
-    }
-
-    /**
-     * Parses the given byte array and returns {@link CsCapabilities} object. Throws {@link
-     * IllegalArgumentException} on invalid input.
-     */
-    public static CsCapabilities parseBytes(byte[] csCapabilitiesBytes) {
-        if (csCapabilitiesBytes.length < EXPECTED_SIZE_BYTES) {
-            throw new IllegalArgumentException("Couldn't parse CsCapabilities, invalid byte size");
-        }
-
-        int parseCursor = 0;
-        var technology = RangingTechnology.parseByte(csCapabilitiesBytes[parseCursor]);
-        if (technology.size() != 1 || technology.get(0) != RangingTechnology.CS) {
-            throw new IllegalArgumentException(
-                    "Couldn't parse CsCapabilities, invalid technology id");
-        }
-        parseCursor += TECHNOLOGY_ID_SIZE;
-
-        // Parse Supported Channels
-        ImmutableList<Integer> supportedSecurityLevels =
-                Conversions.byteArrayToIntList(
-                        Arrays.copyOfRange(csCapabilitiesBytes, parseCursor,
-                                parseCursor + SECURITY_LEVELS_SIZE),
-                        SECURITY_LEVELS_SHIFT);
-        parseCursor += SECURITY_LEVELS_SIZE;
-
-        return CsCapabilities.builder()
-                .setSupportedSecurityLevels(supportedSecurityLevels)
-                .build();
-    }
-
-    /** Serializes this {@link CsCapabilities} object to bytes. */
-    public final byte[] toBytes() {
-        ByteBuffer byteBuffer = ByteBuffer.allocate(EXPECTED_SIZE_BYTES);
-        byteBuffer
-                .put(RangingTechnology.CS.toByte())
-                .put(Conversions.intListToByteArrayBitmap(getSupportedSecurityLevels(),
-                        SECURITY_LEVELS_SIZE, SECURITY_LEVELS_SHIFT));
-
-        return byteBuffer.array();
-    }
-
-    /** Returns a list of supported security levels. */
-    public abstract ImmutableList<Integer> getSupportedSecurityLevels();
-
-    /** Returns a builder for {@link CsCapabilities}. */
-    public static Builder builder() {
-        return new AutoValue_CsCapabilities.Builder();
-    }
-
-    /** Builder for {@link CsCapabilities}. */
-    @AutoValue.Builder
-    public abstract static class Builder {
-        /** Returns maximum supported security level. */
-        public abstract Builder
-                setSupportedSecurityLevels(ImmutableList<Integer> supportedChannels);
-
-        /** Returns a builder for {@link CsCapabilities}. */
-        public abstract CsCapabilities build();
-    }
-
-    @Override
-    public String toString() {
-        return "CsCapabilities{ "
-                + "supportedSecurityLevels="
-                + getSupportedSecurityLevels()
-                + " }";
-    }
-}
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsCapabilitiesAdapter.java b/ranging/service/java/com/android/server/ranging/cs/CsCapabilitiesAdapter.java
index 8596e575..4a109211 100644
--- a/ranging/service/java/com/android/server/ranging/cs/CsCapabilitiesAdapter.java
+++ b/ranging/service/java/com/android/server/ranging/cs/CsCapabilitiesAdapter.java
@@ -29,19 +29,23 @@ import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
 import android.ranging.RangingCapabilities.RangingTechnologyAvailability;
-import android.ranging.ble.cs.CsRangingCapabilities;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
+import android.util.Log;
 
 import androidx.annotation.Nullable;
 
 import com.android.server.ranging.CapabilitiesProvider;
 import com.android.server.ranging.CapabilitiesProvider.CapabilitiesAdapter;
 import com.android.server.ranging.CapabilitiesProvider.TechnologyAvailabilityListener;
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingTechnology;
 
-import java.util.ArrayList;
 import java.util.List;
 
 public class CsCapabilitiesAdapter extends CapabilitiesAdapter {
 
+    private static final String TAG = CsCapabilitiesAdapter.class.getSimpleName();
+
     private final Context mContext;
 
     private final BluetoothManager mBluetoothManager;
@@ -49,7 +53,8 @@ public class CsCapabilitiesAdapter extends CapabilitiesAdapter {
     /** @return true if CS is supported in the provided context, false otherwise */
     public static boolean isSupported(Context context) {
         return context.getPackageManager()
-                .hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE_CHANNEL_SOUNDING);
+                .hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE_CHANNEL_SOUNDING)
+                && RangingInjector.getInstance().isRangingTechnologyEnabled(RangingTechnology.CS);
     }
 
     @Override
@@ -64,16 +69,22 @@ public class CsCapabilitiesAdapter extends CapabilitiesAdapter {
     }
 
     @Override
-    public @Nullable CsRangingCapabilities getCapabilities() {
+    public @Nullable BleCsRangingCapabilities getCapabilities() {
         if (getAvailability() == ENABLED) {
-            List<Integer> securityLevels = new ArrayList<>(
-                mContext.getSystemService(BluetoothManager.class)
-                    .getAdapter()
-                    .getDistanceMeasurementManager()
-                    .getChannelSoundingSupportedSecurityLevels());
-            return new CsRangingCapabilities.Builder()
-                    .setSupportedSecurityLevels(securityLevels)
-                    .build();
+            try {
+                BluetoothAdapter btAdapter = mContext
+                        .getSystemService(BluetoothManager.class).getAdapter();
+
+                return new BleCsRangingCapabilities.Builder()
+                        .setBluetoothAddress(btAdapter.getAddress())
+                        .setSupportedSecurityLevels(List.copyOf(btAdapter
+                                .getDistanceMeasurementManager()
+                                .getChannelSoundingSupportedSecurityLevels()))
+                        .build();
+            } catch (UnsupportedOperationException e) {
+                Log.e(TAG, "Failed to get channel sounding capabilities: " + e);
+                return null;
+            }
         } else {
             return null;
         }
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsConfig.java b/ranging/service/java/com/android/server/ranging/cs/CsConfig.java
index a0b3762b..7617f88f 100644
--- a/ranging/service/java/com/android/server/ranging/cs/CsConfig.java
+++ b/ranging/service/java/com/android/server/ranging/cs/CsConfig.java
@@ -16,33 +16,52 @@
 
 package com.android.server.ranging.cs;
 
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
 import android.annotation.NonNull;
-import android.ranging.DataNotificationConfig;
 import android.ranging.RangingDevice;
 import android.ranging.RangingPreference;
-import android.ranging.ble.cs.CsRangingParams;
+import android.ranging.SessionConfig;
+import android.ranging.ble.cs.BleCsRangingParams;
+import android.ranging.raw.RawRangingDevice;
 
 import com.android.server.ranging.RangingTechnology;
 import com.android.server.ranging.session.RangingSessionConfig.UnicastTechnologyConfig;
 
+import com.google.common.collect.ImmutableMap;
+
+import java.time.Duration;
+import java.util.Objects;
+
+/**
+ * Only the CS initiator needs to be configured. The responder does not need to call into any API
+ * and therefore has no configuration or adapter.
+ */
 public class CsConfig implements UnicastTechnologyConfig {
     private static final String TAG = CsConfig.class.getSimpleName();
 
-    private final DataNotificationConfig mDataNotificationConfig;
-    private final CsRangingParams mRangingParams;
+    // TODO(390665219): Update this once we decide on a set of measurement intervals for channel
+    //  sounding.
+    public static final ImmutableMap<@RawRangingDevice.RangingUpdateRate Integer, Duration>
+            CS_UPDATE_RATE_DURATIONS = ImmutableMap.of(
+                    UPDATE_RATE_NORMAL, Duration.ofMillis(200),
+                    UPDATE_RATE_INFREQUENT, Duration.ofSeconds(5),
+                    UPDATE_RATE_FREQUENT, Duration.ofMillis(100));
 
-    private final RangingDevice mPeerDevice;
+    private final SessionConfig mSessionConfig;
+    private final BleCsRangingParams mRangingParams;
 
-    @RangingPreference.DeviceRole
-    private final int mDeviceRole;
+    private final RangingDevice mPeerDevice;
 
-    public CsConfig(int deviceRole,
-            CsRangingParams csRangingParams,
-            DataNotificationConfig dataNotificationConfig,
+    public CsConfig(
+            BleCsRangingParams bleCsRangingParams,
+            SessionConfig sessionConfig,
             @NonNull RangingDevice peerDevice) {
-        mDeviceRole = deviceRole;
-        mRangingParams = csRangingParams;
-        mDataNotificationConfig = dataNotificationConfig;
+        mRangingParams = bleCsRangingParams;
+        mSessionConfig = sessionConfig;
         mPeerDevice = peerDevice;
     }
 
@@ -51,16 +70,17 @@ public class CsConfig implements UnicastTechnologyConfig {
         return RangingTechnology.CS;
     }
 
-    public DataNotificationConfig getDataNotificationConfig() {
-        return mDataNotificationConfig;
+    public SessionConfig getSessionConfig() {
+        return mSessionConfig;
     }
 
-    public CsRangingParams getRangingParams() {
+    public BleCsRangingParams getRangingParams() {
         return mRangingParams;
     }
 
-    public int getDeviceRole() {
-        return mDeviceRole;
+    @Override
+    public @RangingPreference.DeviceRole int getDeviceRole() {
+        return DEVICE_ROLE_INITIATOR;
     }
 
     @Override
@@ -71,14 +91,26 @@ public class CsConfig implements UnicastTechnologyConfig {
     @Override
     public String toString() {
         return "CsConfig{ "
-                + "mDataNotificationConfig="
-                + mDataNotificationConfig
+                + "mSessionConfig="
+                + mSessionConfig
                 + ", mRangingParams="
                 + mRangingParams
-                + ", mDeviceRole="
-                + mDeviceRole
                 + ", mPeerDevice="
                 + mPeerDevice
                 + " }";
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof CsConfig csConfig)) return false;
+        return Objects.equals(mSessionConfig, csConfig.mSessionConfig)
+                && Objects.equals(mRangingParams, csConfig.mRangingParams)
+                && Objects.equals(mPeerDevice, csConfig.mPeerDevice);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mSessionConfig, mRangingParams, mPeerDevice);
+    }
 }
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsConfigSelector.java b/ranging/service/java/com/android/server/ranging/cs/CsConfigSelector.java
new file mode 100644
index 00000000..49094e21
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/cs/CsConfigSelector.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.cs;
+
+import static android.ranging.ble.cs.BleCsRangingCapabilities.CS_SECURITY_LEVEL_FOUR;
+import static android.ranging.ble.cs.BleCsRangingCapabilities.CS_SECURITY_LEVEL_ONE;
+
+import static com.android.server.ranging.RangingUtils.getUpdateRateFromDurationRange;
+import static com.android.server.ranging.cs.CsConfig.CS_UPDATE_RATE_DURATIONS;
+
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
+import android.ranging.ble.cs.BleCsRangingParams;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.raw.RawRangingDevice;
+import android.util.Pair;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.server.ranging.RangingEngine;
+import com.android.server.ranging.RangingEngine.ConfigSelectionException;
+import com.android.server.ranging.RangingUtils.InternalReason;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.SetConfigurationMessage.TechnologyOobConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+
+import java.util.Set;
+import java.util.function.Function;
+
+public class CsConfigSelector implements RangingEngine.ConfigSelector {
+    private final SessionConfig mSessionConfig;
+    private final OobInitiatorRangingConfig mOobConfig;
+    private final BiMap<RangingDevice, String> mPeerAddresses;
+
+    private final Set<@BleCsRangingCapabilities.SecurityLevel Integer> mSecurityLevels;
+
+    private static boolean isCapableOfConfig(
+            @NonNull OobInitiatorRangingConfig oobConfig,
+            @Nullable BleCsRangingCapabilities capabilities
+    ) {
+        if (capabilities == null) return false;
+
+        if (!(capabilities.getSupportedSecurityLevels().contains(CS_SECURITY_LEVEL_ONE)
+                || capabilities.getSupportedSecurityLevels().contains(CS_SECURITY_LEVEL_FOUR))
+        ) return false;
+
+        if (getUpdateRateFromDurationRange(
+                oobConfig.getRangingIntervalRange(), CS_UPDATE_RATE_DURATIONS).isEmpty()
+        ) return false;
+
+        return true;
+    }
+
+    public CsConfigSelector(
+            @NonNull SessionConfig sessionConfig,
+            @NonNull OobInitiatorRangingConfig oobConfig,
+            @Nullable BleCsRangingCapabilities capabilities
+    ) throws ConfigSelectionException {
+        if (!isCapableOfConfig(oobConfig, capabilities)) {
+            throw new ConfigSelectionException(
+                    "Local device CS capabilities is incompatible with provided config",
+                    InternalReason.UNSUPPORTED);
+        }
+        mSessionConfig = sessionConfig;
+        mOobConfig = oobConfig;
+        mPeerAddresses = HashBiMap.create();
+        mSecurityLevels = capabilities.getSupportedSecurityLevels();
+    }
+
+    @Override
+    public void addPeerCapabilities(
+            @NonNull RangingDevice peer, @NonNull CapabilityResponseMessage response
+    ) throws ConfigSelectionException {
+        CsOobCapabilities capabilities = response.getCsCapabilities();
+        if (capabilities == null) {
+            throw new ConfigSelectionException("Peer " + peer + " does not support CS",
+                    InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+
+        mPeerAddresses.put(peer, capabilities.getBluetoothAddress());
+    }
+
+    @Override
+    public boolean hasPeersToConfigure() {
+        return !mPeerAddresses.isEmpty();
+    }
+
+    @Override
+    public @NonNull Pair<
+            ImmutableSet<TechnologyConfig>,
+            ImmutableMap<RangingDevice, TechnologyOobConfig>
+    > selectConfigs() throws ConfigSelectionException {
+        SelectedCsConfig configs = new SelectedCsConfig();
+        return Pair.create(configs.getLocalConfigs(), configs.getPeerConfigs());
+    }
+
+    private class SelectedCsConfig {
+        private final @RawRangingDevice.RangingUpdateRate int mRangingUpdateRate;
+        private final @BleCsRangingCapabilities.SecurityLevel int mSecurityLevel;
+
+        SelectedCsConfig() throws ConfigSelectionException {
+            mRangingUpdateRate = selectRangingUpdateRate();
+            mSecurityLevel = selectSecurityLevel();
+        }
+
+        public @NonNull ImmutableSet<TechnologyConfig> getLocalConfigs() {
+            return mPeerAddresses.entrySet().stream()
+                    .map((entry) -> new CsConfig(
+                            new BleCsRangingParams.Builder(entry.getValue())
+                                    .setRangingUpdateRate(mRangingUpdateRate)
+                                    .setSecurityLevel(mSecurityLevel)
+                                    .build(),
+                            mSessionConfig,
+                            entry.getKey()))
+                    .collect(ImmutableSet.toImmutableSet());
+        }
+
+        public @NonNull ImmutableMap<RangingDevice, TechnologyOobConfig> getPeerConfigs() {
+            CsOobConfig config = CsOobConfig.builder().build();
+            return mPeerAddresses.keySet().stream()
+                    .collect(ImmutableMap.toImmutableMap(Function.identity(), (unused) -> config));
+        }
+    }
+
+    private @BleCsRangingCapabilities.SecurityLevel int selectSecurityLevel() {
+        if (mOobConfig.getSecurityLevel() == OobInitiatorRangingConfig.SECURITY_LEVEL_SECURE
+                && mSecurityLevels.contains(CS_SECURITY_LEVEL_FOUR)
+        ) return CS_SECURITY_LEVEL_FOUR;
+
+        return CS_SECURITY_LEVEL_ONE;
+    }
+
+    private @RawRangingDevice.RangingUpdateRate int selectRangingUpdateRate()
+            throws ConfigSelectionException {
+
+        return getUpdateRateFromDurationRange(
+                mOobConfig.getRangingIntervalRange(), CS_UPDATE_RATE_DURATIONS)
+                .orElseThrow(() -> new ConfigSelectionException(
+                        "Configured ranging interval range is incompatible with BLE CS",
+                        InternalReason.UNSUPPORTED));
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsOobCapabilities.java b/ranging/service/java/com/android/server/ranging/cs/CsOobCapabilities.java
index 8056dda0..40fd6598 100644
--- a/ranging/service/java/com/android/server/ranging/cs/CsOobCapabilities.java
+++ b/ranging/service/java/com/android/server/ranging/cs/CsOobCapabilities.java
@@ -16,56 +16,151 @@
 
 package com.android.server.ranging.cs;
 
-import com.google.errorprone.annotations.DoNotCall;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
 
-/** Channel Sounding Capability data send as part of CapabilityResponseMessage during Finder OOB. */
-public final class CsOobCapabilities {
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.Conversions;
+import com.android.server.ranging.cs.CsOobConfig.CsSecurityType;
+import com.android.server.ranging.oob.TechnologyHeader;
 
-    private CsOobCapabilities() {
-    }
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/** Capability data for CS sent as part of CapabilityResponseMessage. */
+@AutoValue
+public abstract class CsOobCapabilities {
+
+    /** Size in bytes of all properties when serialized. */
+    private static final int EXPECTED_SIZE_BYTES = 9;
+
+    // Size in bytes of properties for serialization/deserialization.
+    private static final int SECURITY_TYPE_SIZE = 1;
+    private static final int BLUETOOTH_ADDRESS_SIZE = 6;
+
+    private static final int SECURITY_TYPE_SHIFT = 0;
 
-    // // CS data
-    // // 2 byte bitmask bit 0 - standard, rest rfu
-    // private byte[] supportedFeatures;
-    // private boolean isDeviceBonded;
-    // // 16 bytes
-    // private byte[] confirmationHash;
-    // private boolean isRandmizerHashPresent;
-    // // 16 bytes if it exists
-    // private byte[] randmizerHash;
-    // // 7 bytes
-    // private byte[] deviceAddress;
-    // // 1 byte
-    // private int deviceRole;
-    // // 16 bytes
-    // private byte[] leTemporaryKey;
-    // // 2 bytes
-    // private byte[] leAppearance;
-    // private int discoveryMode;
-
-    /** Returns the size of this {@link CsOobCapabilities} object when serialized. */
-    @DoNotCall("Always throws UnsupportedOperationException.")
-    public int getSize() {
-        throw new UnsupportedOperationException("Not implemented");
+    /** Returns the size of the object in bytes when serialized. */
+    public static int getSize() {
+        return EXPECTED_SIZE_BYTES;
     }
 
     /**
      * Parses the given byte array and returns {@link CsOobCapabilities} object. Throws {@link
      * IllegalArgumentException} on invalid input.
      */
-    @DoNotCall("Always throws UnsupportedOperationException.")
-    public static CsOobCapabilities parseBytes(byte[] csCapabilitiesBytes) {
-        throw new UnsupportedOperationException("Not implemented");
+    public static CsOobCapabilities parseBytes(byte[] capabilitiesBytes) {
+        TechnologyHeader header = TechnologyHeader.parseBytes(capabilitiesBytes);
+
+        if (capabilitiesBytes.length < EXPECTED_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "CsOobCapabilities size is %d, expected at least %d",
+                            capabilitiesBytes.length, EXPECTED_SIZE_BYTES));
+        }
+
+        if (capabilitiesBytes.length < header.getSize()) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "CsOobCapabilities header size field is %d, but the size of the array"
+                                    + " is"
+                                    + " %d",
+                            header.getSize(), capabilitiesBytes.length));
+        }
+
+        if (header.getRangingTechnology() != RangingTechnology.CS) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "CsOobCapabilities header technology field is %s, expected %s",
+                            header.getRangingTechnology(), RangingTechnology.CS));
+        }
+
+        int parseCursor = header.getHeaderSize();
+
+        // Supported security type
+        ImmutableList<CsSecurityType> securityTypes =
+                Conversions.byteArrayToIntList(
+                                Arrays.copyOfRange(
+                                        capabilitiesBytes, parseCursor,
+                                        parseCursor + SECURITY_TYPE_SIZE),
+                                SECURITY_TYPE_SHIFT)
+                        .stream()
+                        .map(CsSecurityType::fromValue)
+                        .collect(ImmutableList.toImmutableList());
+        parseCursor += SECURITY_TYPE_SIZE;
+
+        // CS Address
+        String bluetoothAddress =
+                Conversions.macAddressToString(
+                        Arrays.copyOfRange(
+                                capabilitiesBytes, parseCursor,
+                                parseCursor + BLUETOOTH_ADDRESS_SIZE));
+        parseCursor += BLUETOOTH_ADDRESS_SIZE;
+
+        return CsOobCapabilities.builder()
+                .setSupportedSecurityTypes(securityTypes)
+                .setBluetoothAddress(bluetoothAddress)
+                .build();
     }
 
     /** Serializes this {@link CsOobCapabilities} object to bytes. */
-    @DoNotCall("Always throws UnsupportedOperationException.")
-    public byte[] toBytes() {
-        throw new UnsupportedOperationException("Not implemented");
+    public final byte[] toBytes() {
+        ByteBuffer byteBuffer = ByteBuffer.allocate(EXPECTED_SIZE_BYTES);
+        byteBuffer
+                .put(RangingTechnology.CS.toByte())
+                .put((byte) EXPECTED_SIZE_BYTES)
+                .put(
+                        Conversions.intListToByteArrayBitmap(
+                                getSupportedSecurityTypes().stream()
+                                        .map(CsSecurityType::getValue)
+                                        .collect(ImmutableList.toImmutableList()),
+                                SECURITY_TYPE_SIZE,
+                                SECURITY_TYPE_SHIFT))
+                .put(Conversions.macAddressToBytes(getBluetoothAddress()));
+
+        return byteBuffer.array();
+    }
+
+    public static CsOobCapabilities fromRangingCapabilities(
+            BleCsRangingCapabilities capabilities
+    ) {
+        return CsOobCapabilities.builder()
+                .setBluetoothAddress(capabilities.getBluetoothAddress())
+                .setSupportedSecurityTypes(capabilities.getSupportedSecurityLevels().stream()
+                        .map(CsSecurityType.SECURITY_TYPES::get)
+                        .collect(ImmutableList.toImmutableList()))
+                .build();
+    }
+
+    /** Returns the security type for CS. */
+    public abstract ImmutableList<CsSecurityType> getSupportedSecurityTypes();
+
+    /** Returns the Bluetooth address of the device. */
+    public abstract String getBluetoothAddress();
+
+    /** Returns a builder for {@link CsOobCapabilities}. */
+    public static Builder builder() {
+        return new AutoValue_CsOobCapabilities.Builder();
     }
 
-    @Override
-    public String toString() {
-        return "CsCapabilities{}";
+    /** Builder for {@link CsOobCapabilities}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+
+        public abstract Builder setSupportedSecurityTypes(
+                ImmutableList<CsSecurityType> securityTypes);
+
+        public abstract Builder setBluetoothAddress(String bluetoothAddress);
+
+        public abstract CsOobCapabilities autoBuild();
+
+        public CsOobCapabilities build() {
+            CsOobCapabilities csCapabilities = autoBuild();
+            // Validate Bluetooth Address, will throw if invalid.
+            var unused = Conversions.macAddressToBytes(csCapabilities.getBluetoothAddress());
+            return csCapabilities;
+        }
     }
-}
+}
\ No newline at end of file
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsOobConfig.java b/ranging/service/java/com/android/server/ranging/cs/CsOobConfig.java
new file mode 100644
index 00000000..b75e3977
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/cs/CsOobConfig.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.cs;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.SetConfigurationMessage;
+import com.android.server.ranging.oob.TechnologyHeader;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+
+/** Configuration for UWB sent as part SetConfigurationMessage for Finder OOB. */
+@AutoValue
+public abstract class CsOobConfig implements SetConfigurationMessage.TechnologyOobConfig {
+
+    private static final int EXPECTED_SIZE_BYTES = 2;
+
+    /** Returns the size of the object in bytes when serialized. */
+    public final int getSize() {
+        return EXPECTED_SIZE_BYTES;
+    }
+
+    /** Enum representing security type for Channel Sounding. */
+    public enum CsSecurityType {
+        UNKNOWN(0),
+        LEVEL_ONE(1),
+        LEVEL_TWO(2),
+        LEVEL_THREE(3),
+        LEVEL_FOUR(4);
+
+        public static final ImmutableList<CsSecurityType> SECURITY_TYPES =
+                ImmutableList.copyOf(CsSecurityType.values());
+
+        private final int mValue;
+
+        CsSecurityType(int value) {
+            this.mValue = value;
+        }
+
+        public int getValue() {
+            return mValue;
+        }
+
+        public static CsSecurityType fromValue(int value) {
+            return value < 0 || value > LEVEL_FOUR.mValue ? UNKNOWN
+                    : CsSecurityType.values()[value];
+        }
+    }
+
+    /** Enum representing BR/EDR support and capability flag for Channel Sounding. */
+    public enum CsLeFlag {
+        LE_FLAG_LIMITED_DISCOVERY_MODE(0),
+        LE_FLAG_GENERAL_DISCOVERY_MODE(1),
+        LE_FLAG_BREDR_NOT_SUPPORTED(2),
+        LE_FLAG_SIMULTANEOUS_CONTROLLER(3),
+        LE_FLAG_SIMULTANEOUS_HOST(4),
+        UNKNOWN(5);
+
+        private final int mValue;
+
+        CsLeFlag(int value) {
+            this.mValue = value;
+        }
+
+        public byte toByte() {
+            return (byte) mValue;
+        }
+
+        public static CsLeFlag parseByte(byte leFlagByte) {
+            if (leFlagByte < 0 || leFlagByte > UNKNOWN.mValue) {
+                return UNKNOWN;
+            }
+            return CsLeFlag.values()[leFlagByte];
+        }
+    }
+
+    /**
+     * Parses the given byte array and returns {@link CsOobConfig} object. Throws {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static CsOobConfig parseBytes(byte[] csConfigBytes) {
+        TechnologyHeader header = TechnologyHeader.parseBytes(csConfigBytes);
+
+        if (csConfigBytes.length < EXPECTED_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "CsOobConfig size is %d, expected at least %d",
+                            csConfigBytes.length, EXPECTED_SIZE_BYTES));
+        }
+
+        if (header.getRangingTechnology() != RangingTechnology.CS) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "CsOobConfig header technology field is %s, expected %s",
+                            header.getRangingTechnology(), RangingTechnology.CS));
+        }
+
+        int parseCursor = header.getHeaderSize();
+
+        return builder().build();
+    }
+
+    /** Serializes this {@link CsOobConfig} object to bytes. */
+    public final byte[] toBytes() {
+        return ByteBuffer.allocate(EXPECTED_SIZE_BYTES)
+                .put(RangingTechnology.CS.toByte())
+                .put((byte) EXPECTED_SIZE_BYTES)
+                .array();
+    }
+
+    /** Returns a builder for {@link CsOobConfig}. */
+    public static Builder builder() {
+        return new AutoValue_CsOobConfig.Builder();
+    }
+
+    /** Builder for {@link CsOobConfig}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract CsOobConfig build();
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/fusion/FilteringFusionEngine.java b/ranging/service/java/com/android/server/ranging/fusion/FilteringFusionEngine.java
index e7d42d68..8576c5b3 100644
--- a/ranging/service/java/com/android/server/ranging/fusion/FilteringFusionEngine.java
+++ b/ranging/service/java/com/android/server/ranging/fusion/FilteringFusionEngine.java
@@ -20,10 +20,19 @@ import android.ranging.RangingData;
 import android.ranging.RangingMeasurement;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 
+import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingTechnology;
 import com.android.uwb.fusion.UwbFilterEngine;
+import com.android.uwb.fusion.filtering.MedAvgFilter;
+import com.android.uwb.fusion.filtering.MedAvgRotationFilter;
+import com.android.uwb.fusion.filtering.PositionFilterImpl;
 import com.android.uwb.fusion.math.SphericalVector;
+import com.android.uwb.fusion.pose.RotationPoseSource;
+import com.android.uwb.fusion.primers.AoaPrimer;
+import com.android.uwb.fusion.primers.BackAzimuthPrimer;
+import com.android.uwb.fusion.primers.FovPrimer;
 
 import java.util.EnumMap;
 import java.util.Optional;
@@ -36,19 +45,77 @@ public class FilteringFusionEngine extends FusionEngine {
 
     private static final String TAG = FilteringFusionEngine.class.getSimpleName();
 
+    /**
+     * Documented at
+     * {@code packages/modules/Uwb/service/ServiceUwbResources/res/values/config.xml}
+     */
+    private static class FilterConfig {
+        private static final float DISTANCE_INLIERS_FACTOR = 0f / 100f;
+        private static final int DISTANCE_WINDOW = 3;
+
+        private static final float ANGLE_INLIERS_FACTOR = 50f / 100f;
+        private static final int ANGLE_WINDOW = 5;
+
+        private static final float PRIMER_FOV_RADS = (float) Math.toRadians(60);
+
+        private static final int POSE_UPDATE_INTERVAL_MS = 100;
+
+        private static final float FRONT_AZIMUTH_RADS_PER_SEC = (float) Math.toRadians(12);
+        private static final float BACK_AZIMUTH_RADS_PER_SEC = (float) Math.toRadians(10);
+        private static final int BACK_AZIMUTH_DETECTION_WINDOW = 5;
+        private static final boolean ENABLE_BACK_AZIMUTH_MASKING = true;
+        private static final float MIRROR_SCORE_STD_RADS = (float) Math.toRadians(8);
+        private static final float BACK_AZIMUTH_NOISE_COEFF = 8f / 100f;
+    }
+
+
+    private final RangingInjector mInjector;
+    private final boolean mUseAoa;
     private final EnumMap<RangingTechnology, UwbFilterEngine> mFilters;
 
-    public FilteringFusionEngine(@NonNull DataFuser fuser) {
+    public FilteringFusionEngine(
+            @NonNull DataFuser fuser, boolean useAoa, RangingInjector injector
+    ) {
         super(fuser);
+        mInjector = injector;
         mFilters = new EnumMap<>(RangingTechnology.class);
+        mUseAoa = useAoa;
     }
 
     /**
      * Construct a filter engine configured for the provided technology.
+     * Config forked from
+     * {@code packages/modules/Uwb/service/java/com/android/server/uwb/UwbInjector.java}
      */
-    private @NonNull UwbFilterEngine newFilter(@NonNull RangingTechnology unused) {
-        // TODO(365631954): Build a properly configured filter depending on the technology.
-        return new UwbFilterEngine.Builder().build();
+    @VisibleForTesting
+    public @NonNull UwbFilterEngine createFilter(@NonNull RangingTechnology technology) {
+        UwbFilterEngine.Builder builder = new UwbFilterEngine.Builder()
+                .setFilter(
+                        new PositionFilterImpl(
+                                new MedAvgRotationFilter(
+                                        FilterConfig.ANGLE_WINDOW,
+                                        FilterConfig.ANGLE_INLIERS_FACTOR),
+                                new MedAvgRotationFilter(
+                                        FilterConfig.ANGLE_WINDOW,
+                                        FilterConfig.ANGLE_INLIERS_FACTOR),
+                                new MedAvgFilter(
+                                        FilterConfig.DISTANCE_WINDOW,
+                                        FilterConfig.DISTANCE_INLIERS_FACTOR)));
+
+        if (mUseAoa && technology == RangingTechnology.UWB) {
+            builder.setPoseSource(new RotationPoseSource(
+                    mInjector.getContext(), FilterConfig.POSE_UPDATE_INTERVAL_MS));
+
+            builder.addPrimer(new AoaPrimer());
+            builder.addPrimer(new FovPrimer(FilterConfig.PRIMER_FOV_RADS));
+            builder.addPrimer(new BackAzimuthPrimer(
+                    FilterConfig.FRONT_AZIMUTH_RADS_PER_SEC, FilterConfig.BACK_AZIMUTH_RADS_PER_SEC,
+                    FilterConfig.BACK_AZIMUTH_DETECTION_WINDOW,
+                    FilterConfig.ENABLE_BACK_AZIMUTH_MASKING,
+                    FilterConfig.MIRROR_SCORE_STD_RADS, FilterConfig.BACK_AZIMUTH_NOISE_COEFF));
+        }
+
+        return builder.build();
     }
 
     @Override
@@ -96,18 +163,22 @@ public class FilteringFusionEngine extends FusionEngine {
                                 .setConfidence(data.getDistance().getConfidence())
                                 .build()
                 );
-        azimuth.ifPresent(azimuthMeasure -> filteredData.setAzimuth(
-                new RangingMeasurement.Builder()
-                        .setMeasurement(out.azimuth)
-                        .setConfidence(azimuthMeasure.getConfidence())
-                        .build()
-        ));
-        elevation.ifPresent(elevationMeasure -> filteredData.setElevation(
-                new RangingMeasurement.Builder()
-                        .setMeasurement(out.elevation)
-                        .setConfidence(elevationMeasure.getConfidence())
-                        .build()
-        ));
+
+        if (mUseAoa && data.getRangingTechnology() == RangingTechnology.UWB.getValue()) {
+            azimuth.ifPresent(azimuthMeasure -> filteredData.setAzimuth(
+                    new RangingMeasurement.Builder()
+                            .setMeasurement(out.azimuth)
+                            .setConfidence(azimuthMeasure.getConfidence())
+                            .build()
+            ));
+            elevation.ifPresent(elevationMeasure -> filteredData.setElevation(
+                    new RangingMeasurement.Builder()
+                            .setMeasurement(out.elevation)
+                            .setConfidence(elevationMeasure.getConfidence())
+                            .build()
+            ));
+        }
+
         if (data.hasRssi()) {
             filteredData.setRssi(data.getRssi());
         }
@@ -116,14 +187,14 @@ public class FilteringFusionEngine extends FusionEngine {
     }
 
     @Override
-    protected @NonNull Set<RangingTechnology> getDataSources() {
+    public @NonNull Set<RangingTechnology> getDataSources() {
         return mFilters.keySet();
     }
 
     @Override
     public void addDataSource(@NonNull RangingTechnology technology) {
         if (!mFilters.containsKey(technology)) {
-            mFilters.put(technology, newFilter(technology));
+            mFilters.put(technology, createFilter(technology));
         }
     }
 
diff --git a/ranging/service/java/com/android/server/ranging/metrics/SessionMetricsLogger.java b/ranging/service/java/com/android/server/ranging/metrics/SessionMetricsLogger.java
new file mode 100644
index 00000000..72852dbf
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/metrics/SessionMetricsLogger.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.metrics;
+
+import static android.ranging.RangingConfig.RANGING_SESSION_RAW;
+
+import android.content.AttributionSource;
+import android.ranging.RangingConfig;
+import android.ranging.RangingPreference;
+import android.ranging.SessionHandle;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.InternalReason;
+import com.android.server.ranging.RangingUtils.StateMachine;
+
+public class SessionMetricsLogger {
+    private final SessionHandle mSessionHandle;
+    private final @RangingPreference.DeviceRole int mDeviceRole;
+    private final @RangingConfig.RangingSessionType int mSessionType;
+    private final StateMachine<State> mStateMachine;
+    private final AttributionSource mAttributionSource;
+    private final RangingInjector mInjector;
+
+    private long mLastStateChangeTimestampMs;
+
+    public static SessionMetricsLogger startLogging(
+            SessionHandle sessionHandle,
+            @RangingPreference.DeviceRole int deviceRole,
+            @RangingConfig.RangingSessionType int sessionType,
+            AttributionSource attributionSource,
+            RangingInjector injector
+    ) {
+        return new SessionMetricsLogger(sessionHandle, deviceRole, sessionType, attributionSource,
+                injector);
+    }
+
+    private SessionMetricsLogger(
+            SessionHandle sessionHandle,
+            @RangingPreference.DeviceRole int deviceRole,
+            @RangingConfig.RangingSessionType int sessionType,
+            AttributionSource attributionSource,
+            RangingInjector injector
+    ) {
+        mSessionHandle = sessionHandle;
+        mDeviceRole = deviceRole;
+        mSessionType = sessionType;
+        mStateMachine = new StateMachine<>(
+                sessionType == RANGING_SESSION_RAW
+                        ? State.STARTING
+                        : State.OOB);
+        mLastStateChangeTimestampMs = System.currentTimeMillis();
+        mAttributionSource = attributionSource;
+        mInjector = injector;
+    }
+
+    public synchronized void logSessionConfigured(int numPeers) {
+        RangingStatsLog.write(
+                RangingStatsLog.RANGING_SESSION_CONFIGURED,
+                mSessionHandle.hashCode(),
+                mStateMachine.getState() == State.OOB
+                        ? System.currentTimeMillis() - mLastStateChangeTimestampMs
+                        : 0,
+                coerceUnknownEnumValueToZero(mSessionType, 2),
+                coerceUnknownEnumValueToZero(mDeviceRole, 2),
+                numPeers,
+                mAttributionSource.getUid());
+        mLastStateChangeTimestampMs = System.currentTimeMillis();
+        mStateMachine.setState(State.STARTING);
+    }
+
+    public synchronized void logSessionStarted() {
+        RangingStatsLog.write(
+                RangingStatsLog.RANGING_SESSION_STARTED,
+                mSessionHandle.hashCode(),
+                mAttributionSource.getUid(),
+                System.currentTimeMillis() - mLastStateChangeTimestampMs,
+                mInjector.isPrivilegedApp(
+                        mAttributionSource.getUid(),
+                        mAttributionSource.getPackageName()));
+        mLastStateChangeTimestampMs = System.currentTimeMillis();
+        mStateMachine.setState(State.RANGING);
+    }
+
+    public synchronized void logTechnologyStarted(RangingTechnology technology, int numPeers) {
+        RangingStatsLog.write(
+                RangingStatsLog.RANGING_TECHNOLOGY_STARTED,
+                mSessionHandle.hashCode(),
+                coerceUnknownEnumValueToZero(
+                        technology.getValue(), RangingTechnology.TECHNOLOGIES.size()),
+                numPeers,
+                mAttributionSource.getUid());
+    }
+
+    public synchronized void logTechnologyStopped(
+            RangingTechnology technology, int numPeers, @InternalReason int reason
+    ) {
+        RangingStatsLog.write(
+                RangingStatsLog.RANGING_TECHNOLOGY_STOPPED,
+                mSessionHandle.hashCode(),
+                coerceUnknownEnumValueToZero(
+                        technology.getValue(), RangingTechnology.TECHNOLOGIES.size()),
+                coerceUnknownEnumValueToZero(
+                        mStateMachine.getState().toInt(), State.values().length),
+                reason,
+                numPeers,
+                mAttributionSource.getUid());
+    }
+
+    public synchronized void logSessionClosed(@InternalReason int reason) {
+        RangingStatsLog.write(
+                RangingStatsLog.RANGING_SESSION_CLOSED,
+                mSessionHandle.hashCode(),
+                coerceUnknownEnumValueToZero(
+                        mStateMachine.getState().toInt(), State.values().length),
+                System.currentTimeMillis() - mLastStateChangeTimestampMs,
+                reason,
+                mAttributionSource.getUid());
+        mLastStateChangeTimestampMs = System.currentTimeMillis();
+    }
+
+    private int coerceUnknownEnumValueToZero(int enumValue, int numEnumValues) {
+        if (enumValue >= numEnumValues) {
+            return 0;
+        } else {
+            return enumValue + 1;
+        }
+    }
+
+    private enum State {
+        OOB(0),
+        STARTING(1),
+        RANGING(2);
+
+        private final int mValue;
+
+        State(int value) {
+            mValue = value;
+        }
+
+        public final int toInt() {
+            return mValue;
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/CapabilityRequestMessage.java b/ranging/service/java/com/android/server/ranging/oob/CapabilityRequestMessage.java
index 604f6ba1..cba209ab 100644
--- a/ranging/service/java/com/android/server/ranging/oob/CapabilityRequestMessage.java
+++ b/ranging/service/java/com/android/server/ranging/oob/CapabilityRequestMessage.java
@@ -19,7 +19,7 @@ package com.android.server.ranging.oob;
 import com.android.server.ranging.RangingTechnology;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 
 import java.nio.ByteBuffer;
 import java.util.Arrays;
@@ -39,6 +39,13 @@ public abstract class CapabilityRequestMessage {
     public static CapabilityRequestMessage parseBytes(byte[] payload) {
         OobHeader header = OobHeader.parseBytes(payload);
 
+        if (header.getMessageType() != MessageType.CAPABILITY_REQUEST) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "Invalid message type: %s, expected %s",
+                            header.getMessageType(), MessageType.CAPABILITY_REQUEST));
+        }
+
         if (payload.length < header.getSize() + CAPABILITY_SIZE_BYTES) {
             throw new IllegalArgumentException(
                     String.format("CapabilityRequestMessage payload size is %d bytes",
@@ -48,11 +55,13 @@ public abstract class CapabilityRequestMessage {
         int parseCursor = header.getSize();
         byte[] capabilityBytes =
                 Arrays.copyOfRange(payload, parseCursor, parseCursor + CAPABILITY_SIZE_BYTES);
-        ImmutableList<RangingTechnology> rangingTechnologies =
-                RangingTechnology.fromBitmap(capabilityBytes);
+        ImmutableSet<RangingTechnology> rangingTechnologies =
+                ImmutableSet.copyOf(RangingTechnology.fromBitmap(capabilityBytes));
 
-        return builder().setHeader(header).setRequestedRangingTechnologies(
-                rangingTechnologies).build();
+        return builder()
+                .setHeader(header)
+                .setRequestedRangingTechnologies(rangingTechnologies)
+                .build();
     }
 
     /** Serializes this {@link CapabilityRequestMessage} object to bytes. */
@@ -69,7 +78,7 @@ public abstract class CapabilityRequestMessage {
     public abstract OobHeader getHeader();
 
     /** Returns a list of ranging technologies for which capabilities are requested. */
-    public abstract ImmutableList<RangingTechnology> getRequestedRangingTechnologies();
+    public abstract ImmutableSet<RangingTechnology> getRequestedRangingTechnologies();
 
     /** Returns a builder for {@link CapabilityRequestMessage}. */
     public static Builder builder() {
@@ -80,7 +89,7 @@ public abstract class CapabilityRequestMessage {
     @AutoValue.Builder
     public abstract static class Builder {
         public abstract Builder setRequestedRangingTechnologies(
-                ImmutableList<RangingTechnology> requestedRangingTechnologies);
+                ImmutableSet<RangingTechnology> requestedRangingTechnologies);
 
         public abstract Builder setHeader(OobHeader header);
 
diff --git a/ranging/service/java/com/android/server/ranging/oob/CapabilityResponseMessage.java b/ranging/service/java/com/android/server/ranging/oob/CapabilityResponseMessage.java
index c07ad8c7..81703da7 100644
--- a/ranging/service/java/com/android/server/ranging/oob/CapabilityResponseMessage.java
+++ b/ranging/service/java/com/android/server/ranging/oob/CapabilityResponseMessage.java
@@ -17,7 +17,9 @@
 package com.android.server.ranging.oob;
 
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.blerssi.BleRssiOobCapabilities;
 import com.android.server.ranging.cs.CsOobCapabilities;
+import com.android.server.ranging.rtt.RttOobCapabilities;
 import com.android.server.ranging.uwb.UwbOobCapabilities;
 
 import com.google.auto.value.AutoValue;
@@ -47,10 +49,15 @@ public abstract class CapabilityResponseMessage {
     public static CapabilityResponseMessage parseBytes(byte[] payload) {
         OobHeader header = OobHeader.parseBytes(payload);
 
-        if (payload.length < header.getSize() + MIN_SIZE_BYTES) {
+        if (header.getMessageType() != MessageType.CAPABILITY_RESPONSE) {
             throw new IllegalArgumentException(
-                    String.format("CapabilityResponseMessage payload size is %d bytes",
-                            payload.length));
+                    String.format("Invalid message type: %s, expected %s",
+                            header.getMessageType(), MessageType.CAPABILITY_RESPONSE));
+        }
+
+        if (payload.length < header.getSize() + MIN_SIZE_BYTES) {
+            throw new IllegalArgumentException(String.format(
+                    "CapabilityResponseMessage payload size is %d bytes", payload.length));
         }
 
         int parseCursor = header.getSize();
@@ -66,6 +73,8 @@ public abstract class CapabilityResponseMessage {
         // Parse Capability data for different ranging technologies
         UwbOobCapabilities uwbCapabilities = null;
         CsOobCapabilities csCapabilities = null;
+        RttOobCapabilities rttCapabilities = null;
+        BleRssiOobCapabilities bleRssiCapabilities = null;
         ImmutableList.Builder<RangingTechnology> rangingTechnologiesPriority =
                 ImmutableList.builder();
         int countTechsParsed = 0;
@@ -77,7 +86,21 @@ public abstract class CapabilityResponseMessage {
                     uwbCapabilities = UwbOobCapabilities.parseBytes(remainingBytes);
                     parseCursor += techHeader.getSize();
                     rangingTechnologiesPriority.add(RangingTechnology.UWB);
-
+                    break;
+                case CS:
+                    csCapabilities = CsOobCapabilities.parseBytes(remainingBytes);
+                    parseCursor += techHeader.getSize();
+                    rangingTechnologiesPriority.add(RangingTechnology.CS);
+                    break;
+                case RTT:
+                    rttCapabilities = RttOobCapabilities.parseBytes(remainingBytes);
+                    parseCursor += techHeader.getSize();
+                    rangingTechnologiesPriority.add(RangingTechnology.RTT);
+                    break;
+                case RSSI:
+                    bleRssiCapabilities = BleRssiOobCapabilities.parseBytes(remainingBytes);
+                    parseCursor += techHeader.getSize();
+                    rangingTechnologiesPriority.add(RangingTechnology.RSSI);
                     break;
                 default:
                     rangingTechnologiesPriority.add(techHeader.getRangingTechnology());
@@ -91,6 +114,8 @@ public abstract class CapabilityResponseMessage {
                 .setSupportedRangingTechnologies(rangingTechnologies)
                 .setUwbCapabilities(uwbCapabilities)
                 .setCsCapabilities(csCapabilities)
+                .setRttCapabilities(rttCapabilities)
+                .setBleRssiCapabilities(bleRssiCapabilities)
                 .setRangingTechnologiesPriority(rangingTechnologiesPriority.build())
                 .build();
     }
@@ -101,6 +126,15 @@ public abstract class CapabilityResponseMessage {
         if (getUwbCapabilities() != null) {
             size += UwbOobCapabilities.getSize();
         }
+        if (getCsCapabilities() != null) {
+            size += CsOobCapabilities.getSize();
+        }
+        if (getRttCapabilities() != null) {
+            size += getRttCapabilities().toBytes().length;
+        }
+        if (getBleRssiCapabilities() != null) {
+            size += BleRssiOobCapabilities.getSize();
+        }
         ByteBuffer byteBuffer = ByteBuffer.allocate(size);
         byteBuffer
                 .put(getHeader().toBytes())
@@ -113,6 +147,24 @@ public abstract class CapabilityResponseMessage {
                         byteBuffer.put(uwbCapabilities.toBytes());
                     }
                     break;
+                case CS:
+                    CsOobCapabilities csCapabilities = getCsCapabilities();
+                    if (csCapabilities != null) {
+                        byteBuffer.put(csCapabilities.toBytes());
+                    }
+                    break;
+                case RTT:
+                    RttOobCapabilities rttCapabilities = getRttCapabilities();
+                    if (rttCapabilities != null) {
+                        byteBuffer.put(rttCapabilities.toBytes());
+                    }
+                    break;
+                case RSSI:
+                    BleRssiOobCapabilities rssiOobCapabilities = getBleRssiCapabilities();
+                    if (rssiOobCapabilities != null) {
+                        byteBuffer.put(rssiOobCapabilities.toBytes());
+                    }
+                    break;
                 default:
                     throw new UnsupportedOperationException("Not implemented");
             }
@@ -141,6 +193,12 @@ public abstract class CapabilityResponseMessage {
     @Nullable
     public abstract CsOobCapabilities getCsCapabilities();
 
+    @Nullable
+    public abstract RttOobCapabilities getRttCapabilities();
+
+    @Nullable
+    public abstract BleRssiOobCapabilities getBleRssiCapabilities();
+
     /** Returns a builder for {@link CapabilityResponseMessage}. */
     public static Builder builder() {
         return new AutoValue_CapabilityResponseMessage.Builder()
@@ -160,6 +218,11 @@ public abstract class CapabilityResponseMessage {
 
         public abstract Builder setCsCapabilities(@Nullable CsOobCapabilities csCapabilities);
 
+        public abstract Builder setRttCapabilities(@Nullable RttOobCapabilities rttCapabilities);
+
+        public abstract Builder setBleRssiCapabilities(
+                @Nullable BleRssiOobCapabilities bleRssiCapabilities);
+
         public abstract Builder setRangingTechnologiesPriority(
                 ImmutableList<RangingTechnology> rangingTechnologiesPriority
         );
diff --git a/ranging/service/java/com/android/server/ranging/oob/OobController.java b/ranging/service/java/com/android/server/ranging/oob/OobController.java
new file mode 100644
index 00000000..9d16d29e
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/OobController.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import android.annotation.IntDef;
+import android.app.AlarmManager;
+import android.os.RemoteException;
+import android.os.SystemClock;
+import android.ranging.oob.IOobSendDataListener;
+import android.ranging.oob.OobHandle;
+import android.util.Log;
+import android.util.Pair;
+
+import androidx.annotation.Nullable;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingUtils.StateMachine;
+
+import com.google.common.collect.Queues;
+import com.google.common.util.concurrent.FluentFuture;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.SettableFuture;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
+
+public class OobController {
+    private static final String TAG = OobController.class.getSimpleName();
+
+    private static final int OOB_DISCONNECT_TIMEOUT_MS = 5_000;
+
+    private final RangingInjector mInjector;
+    private final AlarmManager mAlarmManager;
+    private final ConcurrentMap<OobHandle, OobConnection> mConnections;
+
+    private @Nullable IOobSendDataListener mOobDataSender = null;
+
+    public static class ConnectionClosedException extends Exception {
+        @IntDef(value = {
+                Reason.REQUESTED,
+                Reason.TRANSPORT_CLOSED,
+                Reason.TRANSPORT_TIMEOUT,
+        })
+        @Target({ElementType.TYPE_USE})
+        public @interface Reason {
+            int REQUESTED = 0;
+            int TRANSPORT_CLOSED = 1;
+            int TRANSPORT_TIMEOUT = 2;
+        }
+
+        private final @Reason int mReason;
+
+        public ConnectionClosedException(@Reason int reason) {
+            super("OOB connection closed");
+            mReason = reason;
+        }
+
+        public @Reason int getReason() {
+            return mReason;
+        }
+    }
+
+    /**
+     * An OOB connection between the local device and a remote device. Each connection is
+     * uniquely identified by its {@link OobHandle}.
+     */
+    public class OobConnection implements AutoCloseable {
+        private final OobHandle mHandle;
+        private final String mDisconnectTimeoutAlarmTag;
+        private final ConcurrentLinkedQueue<Pair<byte[], SettableFuture<Void>>> mPendingDataSends;
+        private final ConcurrentLinkedQueue<SettableFuture<byte[]>> mPendingReceivers;
+        private final ConcurrentLinkedQueue<byte[]> mReceivedData;
+        private final StateMachine<State> mStateMachine = new StateMachine<>(State.CONNECTED);
+
+        /** Invariant: Non-null iff {@code mStateMachine.getState() == State.CLOSED} */
+        private ConnectionClosedException mClosedException = null;
+
+        OobConnection(OobHandle handle) {
+            mHandle = handle;
+            mDisconnectTimeoutAlarmTag = "RangingOobConnection" + mHandle + "DisconnectTimeout";
+            mPendingDataSends = Queues.newConcurrentLinkedQueue();
+            mPendingReceivers = Queues.newConcurrentLinkedQueue();
+            mReceivedData = Queues.newConcurrentLinkedQueue();
+        }
+
+        public FluentFuture<Void> sendData(byte[] data) {
+            SettableFuture<Void> future = SettableFuture.create();
+            setDataSendFuture(data, future);
+            return FluentFuture.from(future);
+        }
+
+        public FluentFuture<byte[]> receiveData() {
+            if (mStateMachine.getState() == State.CLOSED) {
+                return FluentFuture.from(Futures.immediateFailedFuture(mClosedException));
+            }
+
+            if (mReceivedData.isEmpty()) {
+                SettableFuture<byte[]> future = SettableFuture.create();
+                mPendingReceivers.offer(future);
+                return FluentFuture.from(future);
+            } else {
+                return FluentFuture.from(Futures.immediateFuture(mReceivedData.poll()));
+            }
+        }
+
+        @Override
+        public void close() {
+            close(ConnectionClosedException.Reason.REQUESTED);
+        }
+
+        private void close(@ConnectionClosedException.Reason int reason) {
+            synchronized (mStateMachine) {
+                if (mStateMachine.getState() == State.CLOSED) return;
+                mStateMachine.setState(State.CLOSED);
+                mClosedException = new ConnectionClosedException(reason);
+            }
+
+            mPendingDataSends.forEach((sender) -> sender.second.setException(mClosedException));
+            mPendingDataSends.clear();
+
+            mPendingReceivers.forEach((receiver) -> receiver.setException(mClosedException));
+            mPendingReceivers.clear();
+
+            mReceivedData.clear();
+            mConnections.remove(mHandle);
+        }
+
+        /**
+         * @return true if the connection is connected. A connection in this state may eventually be
+         * re-established. Data sent while disconnected will be queued up for when the connection
+         * re-establishes.
+         */
+        public boolean isConnected() {
+            return mStateMachine.getState() == State.CONNECTED;
+        }
+
+        /**
+         * @return true if the connection is closed. A closed connection cannot be reopened. Sending
+         * or receiving data on a closed connection will result in an error.
+         */
+        public boolean isClosed() {
+            return mStateMachine.getState() == State.CLOSED;
+        }
+
+        private void handleReceiveData(byte[] data) {
+            if (mPendingReceivers.isEmpty()) {
+                mReceivedData.offer(data);
+            } else {
+                mPendingReceivers.poll().set(data);
+            }
+        }
+
+        private void handleDisconnect() {
+            synchronized (mStateMachine) {
+                if (mStateMachine.getState() != State.CONNECTED) return;
+                mStateMachine.setState(State.DISCONNECTED);
+                mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                        SystemClock.elapsedRealtime() + OOB_DISCONNECT_TIMEOUT_MS,
+                        mDisconnectTimeoutAlarmTag, mDisconnectTimeoutListener,
+                        mInjector.getAlarmHandler());
+            }
+        }
+
+        private void handleReconnect() {
+            synchronized (mStateMachine) {
+                if (mStateMachine.getState() != State.DISCONNECTED) return;
+                mStateMachine.setState(State.CONNECTED);
+                mAlarmManager.cancel(mDisconnectTimeoutListener);
+            }
+
+            while (mStateMachine.getState() == State.CONNECTED && !mPendingDataSends.isEmpty()) {
+                Pair<byte[], SettableFuture<Void>> send = mPendingDataSends.poll();
+                setDataSendFuture(send.first, send.second);
+            }
+        }
+
+        private void setDataSendFuture(byte[] data, SettableFuture<Void> future) {
+            if (mOobDataSender == null) {
+                future.setException(new IllegalStateException(
+                        "Attempted to send oob message with no data sender registered"));
+                return;
+            }
+            switch (mStateMachine.getState()) {
+                case CLOSED: {
+                    future.setException(mClosedException);
+                    return;
+                }
+                case CONNECTED: {
+                    try {
+                        mOobDataSender.sendOobData(mHandle, data);
+                        future.setFuture(Futures.immediateVoidFuture());
+                    } catch (RemoteException e) {
+                        future.setException(e);
+                    }
+                    return;
+                }
+                case DISCONNECTED: {
+                    mPendingDataSends.add(Pair.create(data, future));
+                    return;
+                }
+            }
+        }
+
+        private final AlarmManager.OnAlarmListener mDisconnectTimeoutListener = () -> {
+            if (mStateMachine.getState() != State.DISCONNECTED) return;
+
+            Log.w(TAG, "Oob connection in disconnected state for longer than timeout of "
+                    + OOB_DISCONNECT_TIMEOUT_MS + " ms. Closing...");
+            close(ConnectionClosedException.Reason.TRANSPORT_TIMEOUT);
+        };
+    }
+
+    public OobController(RangingInjector injector) {
+        mInjector = injector;
+        mConnections = new ConcurrentHashMap<>();
+        mAlarmManager = mInjector.getContext().getSystemService(AlarmManager.class);
+    }
+
+    public void registerDataSender(IOobSendDataListener oobDataSender) {
+        if (mOobDataSender != null) {
+            Log.w(TAG, "Re-registered oob send data listener");
+        }
+        mOobDataSender = oobDataSender;
+    }
+
+    public OobConnection createConnection(OobHandle handle) {
+        OobConnection connection = new OobConnection(handle);
+        mConnections.put(handle, connection);
+        return connection;
+    }
+
+    public void handleOobDataReceived(OobHandle oobHandle, byte[] data) {
+        OobConnection connection = mConnections.get(oobHandle);
+        if (connection == null) {
+            Log.w(TAG, "Received message on unknown connection " + oobHandle + ". Ignoring...");
+        } else {
+            connection.handleReceiveData(data);
+        }
+    }
+
+    public void handleOobDeviceDisconnected(OobHandle oobHandle) {
+        OobConnection connection = mConnections.get(oobHandle);
+        if (connection == null) {
+            Log.w(TAG, "Unknown peer disconnected on handle " + oobHandle + ". Ignoring...");
+        } else {
+            Log.v(TAG, "A peer with an active connection has disconnected on handle " + oobHandle);
+            connection.handleDisconnect();
+        }
+    }
+
+    public void handleOobDeviceReconnected(OobHandle oobHandle) {
+        OobConnection connection = mConnections.get(oobHandle);
+        if (connection == null) {
+            Log.w(TAG, "Unknown peer reconnected on handle " + oobHandle + ". Ignoring...");
+        } else {
+            Log.v(TAG, "The peer on handle " + oobHandle + " has reconnected");
+            connection.handleReconnect();
+        }
+    }
+
+    public void handleOobClosed(OobHandle oobHandle) {
+        OobConnection connection = mConnections.remove(oobHandle);
+        if (connection == null) {
+            Log.w(TAG, "Attempted to close unknown oob connection " + oobHandle + ". Ignoring...");
+        } else {
+            connection.close(ConnectionClosedException.Reason.TRANSPORT_CLOSED);
+        }
+    }
+
+    private enum State {
+        CONNECTED,
+        DISCONNECTED,
+        CLOSED
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/OobHeader.java b/ranging/service/java/com/android/server/ranging/oob/OobHeader.java
index 159e0778..ee242a12 100644
--- a/ranging/service/java/com/android/server/ranging/oob/OobHeader.java
+++ b/ranging/service/java/com/android/server/ranging/oob/OobHeader.java
@@ -16,12 +16,21 @@
 
 package com.android.server.ranging.oob;
 
+import android.annotation.IntDef;
+
 import com.google.auto.value.AutoValue;
 
 /** Header for OOB messages. */
 @AutoValue
 public abstract class OobHeader {
 
+    @IntDef({
+            OobVersion.CURRENT,
+    })
+    public @interface OobVersion {
+        int CURRENT = 1;
+    }
+
     private static final int SIZE_BYTES = 2;
 
     public static OobHeader parseBytes(byte[] payload) {
diff --git a/ranging/service/java/com/android/server/ranging/oob/SetConfigurationMessage.java b/ranging/service/java/com/android/server/ranging/oob/SetConfigurationMessage.java
index 0b1ec591..61bcef6c 100644
--- a/ranging/service/java/com/android/server/ranging/oob/SetConfigurationMessage.java
+++ b/ranging/service/java/com/android/server/ranging/oob/SetConfigurationMessage.java
@@ -17,6 +17,9 @@
 package com.android.server.ranging.oob;
 
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.blerssi.BleRssiOobConfig;
+import com.android.server.ranging.cs.CsOobConfig;
+import com.android.server.ranging.rtt.RttOobConfig;
 import com.android.server.ranging.uwb.UwbOobConfig;
 
 import com.google.auto.value.AutoValue;
@@ -32,6 +35,8 @@ import javax.annotation.Nullable;
 @AutoValue
 public abstract class SetConfigurationMessage {
 
+    public interface TechnologyOobConfig { }
+
     // Size in bytes of properties when serialized.
     private static final int MIN_SIZE_BYTES = 4;
     private static final int RANGING_TECHNOLOGIES_SET_SIZE = 2;
@@ -44,30 +49,38 @@ public abstract class SetConfigurationMessage {
     public static SetConfigurationMessage parseBytes(byte[] payload) {
         OobHeader header = OobHeader.parseBytes(payload);
 
+        if (header.getMessageType() != MessageType.SET_CONFIGURATION) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "Invalid message type: %s, expected %s",
+                            header.getMessageType(), MessageType.SET_CONFIGURATION));
+        }
+
         if (payload.length < header.getSize() + MIN_SIZE_BYTES) {
             throw new IllegalArgumentException(
-                    String.format("CapabilityResponseMessage payload size is %d bytes",
-                            payload.length));
+                    String.format(
+                            "CapabilityResponseMessage payload size is %d bytes", payload.length));
         }
 
         int parseCursor = header.getSize();
 
         // Parse Ranging Technologies Set
         var rangingTechnologiesSet =
-                RangingTechnology.fromBitmap(
-                        Arrays.copyOfRange(payload, parseCursor,
-                                parseCursor + RANGING_TECHNOLOGIES_SET_SIZE));
+                RangingTechnology.fromBitmap(Arrays.copyOfRange(
+                        payload, parseCursor, parseCursor + RANGING_TECHNOLOGIES_SET_SIZE));
         parseCursor += RANGING_TECHNOLOGIES_SET_SIZE;
 
         // Parse Start Ranging List
         var startRangingList =
-                RangingTechnology.fromBitmap(
-                        Arrays.copyOfRange(payload, parseCursor,
-                                parseCursor + START_RANGING_LIST_SIZE));
+                RangingTechnology.fromBitmap(Arrays.copyOfRange(
+                        payload, parseCursor, parseCursor + START_RANGING_LIST_SIZE));
         parseCursor += START_RANGING_LIST_SIZE;
 
         // Parse Configs for ranging technologies that are set
         UwbOobConfig uwbConfig = null;
+        CsOobConfig csConfig = null;
+        RttOobConfig rttConfig = null;
+        BleRssiOobConfig bleRssiConfig = null;
         int countTechsParsed = 0;
         while (parseCursor < payload.length && countTechsParsed++ < rangingTechnologiesSet.size()) {
             byte[] remainingBytes = Arrays.copyOfRange(payload, parseCursor, payload.length);
@@ -77,12 +90,38 @@ public abstract class SetConfigurationMessage {
                     if (uwbConfig != null) {
                         throw new IllegalArgumentException(
                                 "Failed to parse SetConfigurationMessage, UwbConfig already set. "
-                                        + "Bytes:"
-                                        + Arrays.toString(payload));
+                                        + "Bytes: " + Arrays.toString(payload));
                     }
                     uwbConfig = UwbOobConfig.parseBytes(remainingBytes);
                     parseCursor += uwbConfig.getSize();
                     break;
+                case CS:
+                    if (csConfig != null) {
+                        throw new IllegalArgumentException(
+                                "Failed to parse SetConfigurationMessage, CsConfig already set. "
+                                        + "Bytes: " + Arrays.toString(payload));
+                    }
+                    csConfig = CsOobConfig.parseBytes(remainingBytes);
+                    parseCursor += csConfig.getSize();
+                    break;
+                case RTT:
+                    if (rttConfig != null) {
+                        throw new IllegalArgumentException(
+                                "Failed to parse SetConfigurationMessage, RttConfig already set. "
+                                        + "Bytes: " + Arrays.toString(payload));
+                    }
+                    rttConfig = RttOobConfig.parseBytes(remainingBytes);
+                    parseCursor += rttConfig.getSize();
+                    break;
+                case RSSI:
+                    if (bleRssiConfig != null) {
+                        throw new IllegalArgumentException(
+                                "Failed to parse SetConfigurationMessage, BleRssiConfig already "
+                                        + "set. Bytes: " + Arrays.toString(payload));
+                    }
+                    bleRssiConfig = BleRssiOobConfig.parseBytes(remainingBytes);
+                    parseCursor += bleRssiConfig.getSize();
+                    break;
                 default:
                     parseCursor += techHeader.getSize();
             }
@@ -93,6 +132,9 @@ public abstract class SetConfigurationMessage {
                 .setRangingTechnologiesSet(rangingTechnologiesSet)
                 .setStartRangingList(startRangingList)
                 .setUwbConfig(uwbConfig)
+                .setCsConfig(csConfig)
+                .setRttConfig(rttConfig)
+                .setBleRssiConfig(bleRssiConfig)
                 .build();
     }
 
@@ -100,9 +142,21 @@ public abstract class SetConfigurationMessage {
     public final byte[] toBytes() {
         int size = MIN_SIZE_BYTES + getHeader().getSize();
         UwbOobConfig uwbConfig = getUwbConfig();
+        CsOobConfig csConfig = getCsConfig();
+        RttOobConfig rttConfig = getRttConfig();
+        BleRssiOobConfig bleRssiConfig = getBleRssiConfig();
         if (uwbConfig != null) {
             size += uwbConfig.getSize();
         }
+        if (csConfig != null) {
+            size += csConfig.getSize();
+        }
+        if (rttConfig != null) {
+            size += rttConfig.getSize();
+        }
+        if (bleRssiConfig != null) {
+            size += bleRssiConfig.getSize();
+        }
         ByteBuffer byteBuffer = ByteBuffer.allocate(size);
         byteBuffer
                 .put(getHeader().toBytes())
@@ -111,6 +165,15 @@ public abstract class SetConfigurationMessage {
         if (uwbConfig != null) {
             byteBuffer.put(uwbConfig.toBytes());
         }
+        if (csConfig != null) {
+            byteBuffer.put(csConfig.toBytes());
+        }
+        if (rttConfig != null) {
+            byteBuffer.put(rttConfig.toBytes());
+        }
+        if (bleRssiConfig != null) {
+            byteBuffer.put(bleRssiConfig.toBytes());
+        }
         return byteBuffer.array();
     }
 
@@ -130,6 +193,16 @@ public abstract class SetConfigurationMessage {
     @Nullable
     public abstract UwbOobConfig getUwbConfig();
 
+    /** Returns @Nullable CsConfig data that should be used to configure CS ranging session. */
+    @Nullable
+    public abstract CsOobConfig getCsConfig();
+
+    @Nullable
+    public abstract RttOobConfig getRttConfig();
+
+    @Nullable
+    public abstract BleRssiOobConfig getBleRssiConfig();
+
     /** Returns a builder for {@link SetConfigurationMessage}. */
     public static Builder builder() {
         return new AutoValue_SetConfigurationMessage.Builder()
@@ -147,10 +220,27 @@ public abstract class SetConfigurationMessage {
                 ImmutableList<RangingTechnology> rangingTechnologiesSet);
 
         public abstract Builder setStartRangingList(
-                ImmutableList<RangingTechnology> startRangingList);
+                ImmutableList<RangingTechnology> startRangingList
+        );
 
         public abstract Builder setUwbConfig(@Nullable UwbOobConfig uwbConfig);
 
+        public abstract Builder setCsConfig(@Nullable CsOobConfig csConfig);
+
+        public abstract Builder setRttConfig(@Nullable RttOobConfig rttConfig);
+
+        public abstract Builder setBleRssiConfig(@Nullable BleRssiOobConfig bleRssiConfig);
+
+        public Builder setTechnologyConfig(@Nullable TechnologyOobConfig config) {
+            return switch (config) {
+                case UwbOobConfig c -> setUwbConfig(c);
+                case CsOobConfig c -> setCsConfig(c);
+                case RttOobConfig c -> setRttConfig(c);
+                case BleRssiOobConfig c -> setBleRssiConfig(c);
+                default -> this;
+            };
+        }
+
         abstract SetConfigurationMessage autoBuild();
 
         public SetConfigurationMessage build() {
@@ -166,6 +256,24 @@ public abstract class SetConfigurationMessage {
                             .contains(RangingTechnology.UWB)
                             == (setConfigurationMessage.getUwbConfig() != null),
                     "UwbConfig or rangingTechnologiesSet for UWB not set properly.");
+            Preconditions.checkArgument(
+                    setConfigurationMessage
+                            .getRangingTechnologiesSet()
+                            .contains(RangingTechnology.CS)
+                            == (setConfigurationMessage.getCsConfig() != null),
+                    "csConfig or rangingTechnologiesSet for CS not set properly.");
+            Preconditions.checkArgument(
+                    setConfigurationMessage
+                            .getRangingTechnologiesSet()
+                            .contains(RangingTechnology.RTT)
+                            == (setConfigurationMessage.getRttConfig() != null),
+                    "rttConfig or rangingTechnologiesSet for Rtt not set properly.");
+            Preconditions.checkArgument(
+                    setConfigurationMessage
+                            .getRangingTechnologiesSet()
+                            .contains(RangingTechnology.RSSI)
+                            == (setConfigurationMessage.getBleRssiConfig() != null),
+                    "BleRssiConfig or rangingTechnologiesSet for BLE RSSI not set properly.");
             return setConfigurationMessage;
         }
     }
diff --git a/ranging/service/java/com/android/server/ranging/oob/StartRangingMessage.java b/ranging/service/java/com/android/server/ranging/oob/StartRangingMessage.java
index 52a8530e..597fdffb 100644
--- a/ranging/service/java/com/android/server/ranging/oob/StartRangingMessage.java
+++ b/ranging/service/java/com/android/server/ranging/oob/StartRangingMessage.java
@@ -38,6 +38,12 @@ public abstract class StartRangingMessage {
     public static StartRangingMessage parseBytes(byte[] payload) {
         OobHeader header = OobHeader.parseBytes(payload);
 
+        if (header.getMessageType() != MessageType.START_RANGING) {
+            throw new IllegalArgumentException(
+                    String.format("Invalid message type: %s, expected %s", header.getMessageType(),
+                            MessageType.START_RANGING));
+        }
+
         if (payload.length < header.getSize() + SIZE_IN_BYTES) {
             throw new IllegalArgumentException(
                     String.format("StartRangingMessage payload size is %d bytes", payload.length));
diff --git a/ranging/service/java/com/android/server/ranging/oob/StatusResponseMessage.java b/ranging/service/java/com/android/server/ranging/oob/StatusResponseMessage.java
index 0b3322b4..d44bb33f 100644
--- a/ranging/service/java/com/android/server/ranging/oob/StatusResponseMessage.java
+++ b/ranging/service/java/com/android/server/ranging/oob/StatusResponseMessage.java
@@ -41,6 +41,15 @@ public abstract class StatusResponseMessage {
     public static StatusResponseMessage parseBytes(byte[] payload) {
         OobHeader header = OobHeader.parseBytes(payload);
 
+        if (header.getMessageType() != MessageType.SET_CONFIGURATION_RESPONSE
+                && header.getMessageType() != MessageType.START_RANGING_RESPONSE
+                && header.getMessageType() != MessageType.STOP_RANGING_RESPONSE) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "Invalid message type: %s, expected status response type",
+                            header.getMessageType()));
+        }
+
         if (payload.length < header.getSize() + SIZE_IN_BYTES) {
             throw new IllegalArgumentException(
                     String.format("StatusResponseMessage payload size is %d bytes",
diff --git a/ranging/service/java/com/android/server/ranging/oob/StopRangingMessage.java b/ranging/service/java/com/android/server/ranging/oob/StopRangingMessage.java
index 5b441067..2d8d03c5 100644
--- a/ranging/service/java/com/android/server/ranging/oob/StopRangingMessage.java
+++ b/ranging/service/java/com/android/server/ranging/oob/StopRangingMessage.java
@@ -38,6 +38,13 @@ public abstract class StopRangingMessage {
     public static StopRangingMessage parseBytes(byte[] payload) {
         OobHeader header = OobHeader.parseBytes(payload);
 
+        if (header.getMessageType() != MessageType.STOP_RANGING) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "Invalid message type: %s, expected %s",
+                            header.getMessageType(), MessageType.STOP_RANGING));
+        }
+
         if (payload.length < header.getSize() + SIZE_IN_BYTES) {
             throw new IllegalArgumentException(
                     String.format("StopRangingMessage payload size is %d bytes", payload.length));
diff --git a/ranging/service/java/com/android/server/ranging/oob/TechnologyHeader.java b/ranging/service/java/com/android/server/ranging/oob/TechnologyHeader.java
index 442ab132..35297276 100644
--- a/ranging/service/java/com/android/server/ranging/oob/TechnologyHeader.java
+++ b/ranging/service/java/com/android/server/ranging/oob/TechnologyHeader.java
@@ -35,8 +35,14 @@ public abstract class TechnologyHeader {
         }
 
         int parseCursor = 0;
-        RangingTechnology rangingTechnology =
-                RangingTechnology.TECHNOLOGIES.get(payload[parseCursor++]);
+        byte technologyId = payload[parseCursor++];
+        RangingTechnology rangingTechnology;
+        try {
+            rangingTechnology = RangingTechnology.TECHNOLOGIES.get(technologyId);
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(
+                    "Attempted to parse unknown technology with id" + technologyId);
+        }
         int size = payload[parseCursor++];
 
         return builder().setRangingTechnology(rangingTechnology).setSize(size).build();
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttAdapter.java b/ranging/service/java/com/android/server/ranging/rtt/RttAdapter.java
index 76b4f55d..d36a793f 100644
--- a/ranging/service/java/com/android/server/ranging/rtt/RttAdapter.java
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttAdapter.java
@@ -18,7 +18,11 @@ package com.android.server.ranging.rtt;
 
 import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
 
+import android.annotation.Nullable;
+import android.app.AlarmManager;
+import android.content.AttributionSource;
 import android.content.Context;
+import android.ranging.DataNotificationConfig;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
 import android.ranging.RangingManager;
@@ -28,18 +32,24 @@ import android.util.Log;
 
 import androidx.annotation.NonNull;
 
-import com.android.ranging.rtt.backend.internal.RttDevice;
-import com.android.ranging.rtt.backend.internal.RttRangingDevice;
-import com.android.ranging.rtt.backend.internal.RttRangingPosition;
-import com.android.ranging.rtt.backend.internal.RttRangingSessionCallback;
-import com.android.ranging.rtt.backend.internal.RttService;
-import com.android.ranging.rtt.backend.internal.RttServiceImpl;
+import com.android.ranging.rtt.backend.RttDevice;
+import com.android.ranging.rtt.backend.RttRangingDevice;
+import com.android.ranging.rtt.backend.RttRangingParameters;
+import com.android.ranging.rtt.backend.RttRangingPosition;
+import com.android.ranging.rtt.backend.RttRangingSessionCallback;
+import com.android.ranging.rtt.backend.RttService;
+import com.android.ranging.rtt.backend.RttServiceImpl;
 import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils;
+import com.android.server.ranging.RangingUtils.InternalReason;
 import com.android.server.ranging.RangingUtils.StateMachine;
 import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.util.DataNotificationManager;
 
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.FutureCallback;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListeningExecutorService;
@@ -51,6 +61,8 @@ public class RttAdapter implements RangingAdapter {
 
     private static final String TAG = RttAdapter.class.getSimpleName();
 
+    private final Context mContext;
+    private final RangingInjector mRangingInjector;
     private final RttService mRttService;
     private final RttRangingDevice mRttClient;
     private final ListeningExecutorService mExecutorService;
@@ -62,21 +74,34 @@ public class RttAdapter implements RangingAdapter {
     private Callback mCallbacks;
     /** Invariant: non-null while a ranging session is active */
     private RangingDevice mPeerDevice;
+    private RttConfig mConfig;
+
+    private DataNotificationManager mDataNotificationManager;
+    @Nullable
+    private AttributionSource mNonPrivilegedAttributionSource;
+    private final AlarmManager mAlarmManager;
+    private final AlarmManager.OnAlarmListener mMeasurementLimitListener;
 
     public RttAdapter(
-            @NonNull Context context, @NonNull ListeningExecutorService executorService,
+            @NonNull Context context,
+            @NonNull RangingInjector rangingInjector,
+            @NonNull ListeningExecutorService executorService,
             @RangingPreference.DeviceRole int role
     ) {
-        this(context, executorService, new RttServiceImpl(context), role);
+        this(context, rangingInjector, executorService, new RttServiceImpl(context), role);
     }
 
     @VisibleForTesting
-    public RttAdapter(@NonNull Context context, @NonNull ListeningExecutorService executorService,
-            @NonNull RttService rttService, @RangingPreference.DeviceRole int role) {
+    public RttAdapter(@NonNull Context context,
+            @NonNull RangingInjector rangingInjector,
+            @NonNull ListeningExecutorService executorService,
+            @NonNull RttService rttService,
+            @RangingPreference.DeviceRole int role) {
         if (!RttCapabilitiesAdapter.isSupported(context)) {
             throw new IllegalArgumentException("WiFi RTT system feature not found.");
         }
-
+        mContext = context;
+        mRangingInjector = rangingInjector;
         mStateMachine = new StateMachine<>(State.STOPPED);
         mRttService = rttService;
         mRttClient = role == DEVICE_ROLE_INITIATOR
@@ -86,6 +111,15 @@ public class RttAdapter implements RangingAdapter {
         mExecutorService = executorService;
         mCallbacks = null;
         mPeerDevice = null;
+        mDataNotificationManager = new DataNotificationManager(
+                new DataNotificationConfig.Builder().build(),
+                new DataNotificationConfig.Builder().build()
+        );
+        mAlarmManager = mContext.getSystemService(AlarmManager.class);
+        mMeasurementLimitListener = () -> {
+            Log.i(TAG, "Measurements limit exceeded. Stopping the session");
+            Executors.newCachedThreadPool().execute(this::stop);
+        };
     }
 
     @Override
@@ -93,35 +127,89 @@ public class RttAdapter implements RangingAdapter {
         return RangingTechnology.RTT;
     }
 
+    public DataNotificationManager getDataNotificationManager() {
+        return mDataNotificationManager;
+    }
+
     @Override
     public void start(
-            @NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callbacks
+            @NonNull RangingSessionConfig.TechnologyConfig config,
+            @Nullable AttributionSource nonPrivilegedAttributionSource,
+            @NonNull Callback callbacks
     ) {
         Log.i(TAG, "Start called.");
-        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
-            Log.v(TAG, "Attempted to start adapter when it was already started");
+        mNonPrivilegedAttributionSource = nonPrivilegedAttributionSource;
+        mCallbacks = callbacks;
+        if (mNonPrivilegedAttributionSource != null && !mRangingInjector.isForegroundAppOrService(
+                mNonPrivilegedAttributionSource.getUid(),
+                mNonPrivilegedAttributionSource.getPackageName())) {
+            Log.w(TAG, "Background ranging is not supported");
+            closeForReason(InternalReason.BACKGROUND_RANGING_POLICY);
             return;
         }
-
-        mCallbacks = callbacks;
         if (!(config instanceof RttConfig rttConfig)) {
             Log.w(TAG, "Tried to start adapter with invalid ranging parameters");
-            closeForReason(Callback.ClosedReason.FAILED_TO_START);
+            closeForReason(InternalReason.INTERNAL_ERROR);
+            return;
+        }
+        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
+            Log.v(TAG, "Attempted to start adapter when it was already started");
+            closeForReason(InternalReason.INTERNAL_ERROR);
             return;
         }
+        mConfig = rttConfig;
         mPeerDevice = rttConfig.getPeerDevice();
         mRttClient.setRangingParameters(rttConfig.asBackendParameters());
+        mRttClient.setRangingRequestDelay(
+                mRangingInjector.getDeviceConfigFacade().getRttRangingRequestDelay());
+        mDataNotificationManager = new DataNotificationManager(
+                rttConfig.getSessionConfig().getDataNotificationConfig(),
+                rttConfig.getSessionConfig().getDataNotificationConfig());
 
         var future = Futures.submit(() -> {
             mRttClient.startRanging(mRttListener, Executors.newSingleThreadExecutor());
         }, mExecutorService);
         Futures.addCallback(future, mRttClientResultHandlers.startRanging, mExecutorService);
+        if (mConfig.getSessionConfig().getRangingMeasurementsLimit() > 0) {
+            RangingUtils.setMeasurementsLimitTimeout(
+                    mAlarmManager,
+                    mMeasurementLimitListener,
+                    mConfig.getSessionConfig().getRangingMeasurementsLimit(),
+                    RttRangingParameters.getIntervalMs(mRttClient.getRttRangingParameters()));
+        }
+    }
+
+    @Override
+    public void reconfigureRangingInterval(int intervalSkipCount) {
+        Log.i(TAG, "Reconfigure ranging interval called");
+        mRttClient.reconfigureRangingInterval(intervalSkipCount);
+    }
+
+    @Override
+    public void appMovedToBackground() {
+        if (mNonPrivilegedAttributionSource != null && mStateMachine.getState() != State.STOPPED) {
+            mDataNotificationManager.updateConfigAppMovedToBackground();
+        }
+    }
+
+    @Override
+    public void appMovedToForeground() {
+        if (mNonPrivilegedAttributionSource != null && mStateMachine.getState() != State.STOPPED) {
+            mDataNotificationManager.updateConfigAppMovedToForeground();
+        }
+    }
+
+    @Override
+    public void appInBackgroundTimeout() {
+        if (mNonPrivilegedAttributionSource != null && mStateMachine.getState() != State.STOPPED) {
+            stop();
+        }
     }
 
     @Override
     public void stop() {
         Log.i(TAG, "Stop called.");
-        if (!mStateMachine.transition(State.STARTED, State.STOPPED)) {
+        if (mStateMachine.getState() == State.STOPPED) {
             Log.v(TAG, "Attempted to stop adapter when it was already stopped");
             return;
         }
@@ -137,17 +225,20 @@ public class RttAdapter implements RangingAdapter {
             Log.i(TAG, "onRangingInitialized");
             synchronized (mStateMachine) {
                 if (mStateMachine.getState() == State.STARTED) {
-                    mCallbacks.onStarted(mPeerDevice);
+                    mCallbacks.onStarted(ImmutableSet.of(mPeerDevice));
                 }
             }
         }
 
         @Override
         public void onRangingResult(RttDevice peer, RttRangingPosition position) {
+            if (!mDataNotificationManager.shouldSendResult(position.getDistanceMeters())) {
+                return;
+            }
             RangingData.Builder dataBuilder = new RangingData.Builder()
                     .setRangingTechnology(RangingManager.WIFI_NAN_RTT)
                     .setDistance(new RangingMeasurement.Builder()
-                            .setMeasurement(position.getDistance())
+                            .setMeasurement(position.getDistanceMeters())
                             .build())
                     .setRssi(position.getRssiDbm())
                     .setTimestampMillis(position.getRangingTimestampMillis());
@@ -169,21 +260,18 @@ public class RttAdapter implements RangingAdapter {
             }
         }
 
-        private static int convertReason(int reason) {
-            switch (reason) {
-                case REASON_WRONG_PARAMETERS:
-                case REASON_FAILED_TO_START:
-                    return Callback.ClosedReason.FAILED_TO_START;
-                case REASON_STOPPED_BY_PEER:
-                case REASON_STOP_RANGING_CALLED:
-                    return Callback.ClosedReason.REQUESTED;
-                case REASON_MAX_RANGING_ROUND_RETRY_REACHED:
-                    return Callback.ClosedReason.LOST_CONNECTION;
-                case REASON_SYSTEM_POLICY:
-                    return Callback.ClosedReason.SYSTEM_POLICY;
-                default:
-                    return Callback.ClosedReason.UNKNOWN;
-            }
+        private static @InternalReason int convertReason(@RttSuspendedReason int reason) {
+            return switch (reason) {
+                case REASON_UNKNOWN -> InternalReason.UNKNOWN;
+                case REASON_WRONG_PARAMETERS,
+                        REASON_FAILED_TO_START,
+                        REASON_RTT_NOT_AVAILABLE -> InternalReason.UNSUPPORTED;
+                case REASON_STOPPED_BY_PEER -> InternalReason.REMOTE_REQUEST;
+                case REASON_STOP_RANGING_CALLED -> InternalReason.LOCAL_REQUEST;
+                case REASON_MAX_RANGING_ROUND_RETRY_REACHED -> InternalReason.NO_PEERS_FOUND;
+                case REASON_SYSTEM_POLICY -> InternalReason.SYSTEM_POLICY;
+                default -> InternalReason.UNKNOWN;
+            };
         }
 
         @Override
@@ -194,17 +282,21 @@ public class RttAdapter implements RangingAdapter {
     }
 
     /** Close the session, disconnecting the peer and resetting internal state. */
-    private void closeForReason(@Callback.ClosedReason int reason) {
+    private void closeForReason(@InternalReason int reason) {
         synchronized (mStateMachine) {
             mStateMachine.setState(State.STOPPED);
-            mCallbacks.onStopped(mPeerDevice);
-            mCallbacks.onClosed(reason);
+            if (mCallbacks != null) {
+                mCallbacks.onStopped(ImmutableSet.of(mPeerDevice), reason);
+                mCallbacks.onClosed(reason);
+            }
             clear();
         }
     }
 
     private void clear() {
-        mRttClient.stopRanging();
+        if (mConfig.getSessionConfig().getRangingMeasurementsLimit() > 0) {
+            mAlarmManager.cancel(mMeasurementLimitListener);
+        }
         mCallbacks = null;
         mPeerDevice = null;
     }
@@ -224,7 +316,7 @@ public class RttAdapter implements RangingAdapter {
             @Override
             public void onFailure(@NonNull Throwable t) {
                 Log.w(TAG, "startRanging failed ", t);
-                closeForReason(Callback.ClosedReason.ERROR);
+                closeForReason(InternalReason.INTERNAL_ERROR);
             }
         };
 
@@ -236,7 +328,7 @@ public class RttAdapter implements RangingAdapter {
             @Override
             public void onFailure(@NonNull Throwable t) {
                 Log.w(TAG, "stopRanging failed ", t);
-                closeForReason(Callback.ClosedReason.ERROR);
+                closeForReason(InternalReason.INTERNAL_ERROR);
             }
         };
     }
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttCapabilitiesAdapter.java b/ranging/service/java/com/android/server/ranging/rtt/RttCapabilitiesAdapter.java
index d71c7dcd..4f4d2a25 100644
--- a/ranging/service/java/com/android/server/ranging/rtt/RttCapabilitiesAdapter.java
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttCapabilitiesAdapter.java
@@ -32,10 +32,12 @@ import android.ranging.wifi.rtt.RttRangingCapabilities;
 
 import androidx.annotation.Nullable;
 
-import com.android.ranging.rtt.backend.internal.RttServiceImpl;
+import com.android.ranging.rtt.backend.RttServiceImpl;
 import com.android.server.ranging.CapabilitiesProvider;
 import com.android.server.ranging.CapabilitiesProvider.CapabilitiesAdapter;
 import com.android.server.ranging.CapabilitiesProvider.TechnologyAvailabilityListener;
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingTechnology;
 
 public class RttCapabilitiesAdapter extends CapabilitiesAdapter {
 
@@ -44,7 +46,9 @@ public class RttCapabilitiesAdapter extends CapabilitiesAdapter {
 
     /** @return true if WiFi RTT is supported in the provided context, false otherwise */
     public static boolean isSupported(Context context) {
-        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE);
+        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE)
+                && context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_RTT)
+                && RangingInjector.getInstance().isRangingTechnologyEnabled(RangingTechnology.RTT);
     }
 
     public RttCapabilitiesAdapter(
@@ -79,7 +83,9 @@ public class RttCapabilitiesAdapter extends CapabilitiesAdapter {
     public RttRangingCapabilities getCapabilities() {
         if (getAvailability() == ENABLED) {
             return new RttRangingCapabilities.Builder()
-                    .setPeriodicRangingHwFeature(mRttService.hasPeriodicRangingSupport())
+                    .setPeriodicRangingHardwareFeature(mRttService.hasPeriodicRangingSupport())
+                    .setMaxSupportedBandwidth(mRttService.getMaxSupportedBandwidth())
+                    .setMaxSupportedRxChain(mRttService.getMaxSupportedRxChains())
                     .build();
         }
         return null;
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttConfig.java b/ranging/service/java/com/android/server/ranging/rtt/RttConfig.java
index 06388ef2..90c00eff 100644
--- a/ranging/service/java/com/android/server/ranging/rtt/RttConfig.java
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttConfig.java
@@ -19,17 +19,20 @@ package com.android.server.ranging.rtt;
 import android.ranging.DataNotificationConfig;
 import android.ranging.RangingDevice;
 import android.ranging.RangingPreference;
+import android.ranging.SessionConfig;
 import android.ranging.wifi.rtt.RttRangingParams;
 
 import androidx.annotation.NonNull;
 
-import com.android.ranging.rtt.backend.internal.RttRangingParameters;
+import com.android.ranging.rtt.backend.RttRangingParameters;
 import com.android.server.ranging.RangingTechnology;
 import com.android.server.ranging.session.RangingSessionConfig;
 
+import java.util.Objects;
+
 public class RttConfig implements RangingSessionConfig.UnicastTechnologyConfig {
 
-    private final DataNotificationConfig mDataNotificationConfig;
+    private final SessionConfig mSessionConfig;
     private final RttRangingParams mRangingParams;
     private final RangingDevice mPeerDevice;
 
@@ -38,29 +41,31 @@ public class RttConfig implements RangingSessionConfig.UnicastTechnologyConfig {
     public RttConfig(
             int deviceRole,
             @NonNull RttRangingParams rttRangingParams,
-            @NonNull DataNotificationConfig dataNotificationConfig,
+            @NonNull SessionConfig sessionConfig,
             @NonNull RangingDevice peerDevice
     ) {
         mDeviceRole = deviceRole;
         mRangingParams = rttRangingParams;
-        mDataNotificationConfig = dataNotificationConfig;
+        mSessionConfig = sessionConfig;
         mPeerDevice = peerDevice;
     }
 
     @Override
-    @NonNull public RangingTechnology getTechnology() {
+    @NonNull
+    public RangingTechnology getTechnology() {
         return RangingTechnology.RTT;
     }
 
-    public DataNotificationConfig getDataNotificationConfig() {
-        return mDataNotificationConfig;
+    public SessionConfig getSessionConfig() {
+        return mSessionConfig;
     }
 
     public RttRangingParams getRangingParams() {
         return mRangingParams;
     }
 
-    public int getDeviceRole() {
+    @Override
+    public @RangingPreference.DeviceRole int getDeviceRole() {
         return mDeviceRole;
     }
 
@@ -70,21 +75,36 @@ public class RttConfig implements RangingSessionConfig.UnicastTechnologyConfig {
     }
 
     public RttRangingParameters asBackendParameters() {
-        return new RttRangingParameters.Builder()
+        RttRangingParameters.Builder builder = new RttRangingParameters.Builder()
                 .setDeviceRole(mDeviceRole)
                 .setServiceName(mRangingParams.getServiceName())
                 .setMatchFilter(mRangingParams.getMatchFilter())
-                .setMaxDistanceMm(mDataNotificationConfig.getProximityFarCm() * 100)
-                .setMinDistanceMm(mDataNotificationConfig.getProximityNearCm() * 100)
-                .setEnablePublisherRanging(true)
-                .build();
+                .setUpdateRate(mRangingParams.getRangingUpdateRate())
+                .setPeriodicRangingHwFeatureEnabled(
+                        mRangingParams.isPeriodicRangingHwFeatureEnabled());
+
+        DataNotificationConfig ntfConfig = mSessionConfig.getDataNotificationConfig();
+        switch (ntfConfig.getNotificationConfigType()) {
+            case DataNotificationConfig.NOTIFICATION_CONFIG_ENABLE,
+                    // Handled in adapter.
+                    DataNotificationConfig.NOTIFICATION_CONFIG_PROXIMITY_EDGE -> builder
+                    .setMinDistanceMm(0)
+                    .setMaxDistanceMm(50 * 100 * 100); // 50 meters.
+            case DataNotificationConfig.NOTIFICATION_CONFIG_DISABLE ->
+                    builder.setRangeDataNtfDisabled(true);
+            case DataNotificationConfig.NOTIFICATION_CONFIG_PROXIMITY_LEVEL ->
+                    builder.setMinDistanceMm(
+                                    ntfConfig.getProximityNearCm() * 100)
+                            .setMaxDistanceMm(ntfConfig.getProximityFarCm() * 100);
+        }
+        return builder.build();
     }
 
     @Override
     public String toString() {
         return "RttConfig{ "
-                + "mDataNotificationConfig="
-                + mDataNotificationConfig
+                + "mSessionConfig="
+                + mSessionConfig
                 + ", mRangingParams="
                 + mRangingParams
                 + ", mPeerDevice="
@@ -93,4 +113,19 @@ public class RttConfig implements RangingSessionConfig.UnicastTechnologyConfig {
                 + mDeviceRole
                 + " }";
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof RttConfig rttConfig)) return false;
+        return mDeviceRole == rttConfig.mDeviceRole && Objects.equals(mSessionConfig,
+                rttConfig.mSessionConfig) && Objects.equals(mRangingParams,
+                rttConfig.mRangingParams) && Objects.equals(mPeerDevice,
+                rttConfig.mPeerDevice);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mSessionConfig, mRangingParams, mPeerDevice, mDeviceRole);
+    }
 }
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttConfigSelector.java b/ranging/service/java/com/android/server/ranging/rtt/RttConfigSelector.java
new file mode 100644
index 00000000..92fd303b
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttConfigSelector.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.rtt;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
+import static com.android.server.ranging.RangingUtils.getUpdateRateFromDurationRange;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.wifi.rtt.RttRangingCapabilities;
+import android.ranging.wifi.rtt.RttRangingParams;
+import android.util.Pair;
+
+import com.android.server.ranging.RangingEngine;
+import com.android.server.ranging.RangingEngine.ConfigSelectionException;
+import com.android.server.ranging.RangingUtils.InternalReason;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.SetConfigurationMessage.TechnologyOobConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+
+import java.time.Duration;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class RttConfigSelector implements RangingEngine.ConfigSelector {
+
+    public static int RTT_SUFFIX_SIZE = 6;
+    private static boolean sLocalPeriodicRangingSupport = false;
+    private static final String SERVICE_NAME_PREFIX = "rtt_ranging";
+
+    private final SessionConfig mSessionConfig;
+
+    private final OobInitiatorRangingConfig mOobConfig;
+
+    private final Map<RangingDevice, RttDeviceConfig> mRangingDevices = new ConcurrentHashMap<>();
+    public static ImmutableMap<@RawRangingDevice.RangingUpdateRate Integer, Duration>
+            RTT_UPDATE_RATE_DURATIONS;
+
+    private static boolean isCapableOfConfig(
+            @NonNull OobInitiatorRangingConfig oobConfig,
+            @Nullable RttRangingCapabilities capabilities) {
+
+        if (capabilities == null) return false;
+
+        sLocalPeriodicRangingSupport = capabilities.hasPeriodicRangingHardwareFeature();
+        if (RTT_UPDATE_RATE_DURATIONS == null) {
+            getLazyUpdateRate();
+        }
+
+        if (getUpdateRateFromDurationRange(
+                oobConfig.getRangingIntervalRange(), RTT_UPDATE_RATE_DURATIONS).isEmpty()
+        ) return false;
+
+        return true;
+    }
+
+    public RttConfigSelector(
+            @NonNull SessionConfig sessionConfig,
+            @NonNull OobInitiatorRangingConfig oobConfig,
+            @Nullable RttRangingCapabilities capabilities
+    ) throws ConfigSelectionException {
+        if (!isCapableOfConfig(oobConfig, capabilities)) {
+            throw new ConfigSelectionException(
+                    "Local device is incapable of provided RTT config",
+                    InternalReason.UNSUPPORTED);
+        }
+
+        mSessionConfig = sessionConfig;
+        mOobConfig = oobConfig;
+    }
+
+    @Override
+    public boolean hasPeersToConfigure() {
+        return !mRangingDevices.isEmpty();
+    }
+
+
+    @Override
+    public void addPeerCapabilities(
+            @NonNull RangingDevice peer, @NonNull CapabilityResponseMessage response
+    ) throws ConfigSelectionException {
+        RttOobCapabilities capabilities = response.getRttCapabilities();
+        if (capabilities == null) {
+            throw new ConfigSelectionException(
+                    "Peer " + peer + " does not support Wifi RTT",
+                    InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+
+        mRangingDevices.put(peer, new RttDeviceConfig(getServiceName(peer),
+                capabilities.hasPeriodicRangingSupport() && sLocalPeriodicRangingSupport));
+    }
+
+    @Override
+    public @NonNull Pair<
+            ImmutableSet<TechnologyConfig>,
+            ImmutableMap<RangingDevice, TechnologyOobConfig>
+    > selectConfigs() throws ConfigSelectionException {
+        SelectedRttConfig configs = new SelectedRttConfig();
+        return Pair.create(configs.getLocalConfigs(), configs.getPeerConfigs());
+    }
+
+    private class SelectedRttConfig {
+        // TODO: Check whether this needs to be added to OOB.
+        private final @RawRangingDevice.RangingUpdateRate int mRangingUpdateRate;
+
+        SelectedRttConfig() throws RangingEngine.ConfigSelectionException {
+            mRangingUpdateRate = getUpdateRateFromDurationRange(
+                    mOobConfig.getRangingIntervalRange(), RTT_UPDATE_RATE_DURATIONS)
+                    .orElseThrow(() -> new RangingEngine.ConfigSelectionException(
+                            "Configured ranging interval range is incompatible with Wifi RTT",
+                            InternalReason.UNSUPPORTED));
+        }
+
+        @NonNull
+        public ImmutableSet<TechnologyConfig> getLocalConfigs() {
+            return mRangingDevices.entrySet().stream()
+                    .map((entry -> new RttConfig(DEVICE_ROLE_INITIATOR,
+                            new RttRangingParams.Builder(entry.getValue().mServiceName)
+                                    .setPeriodicRangingHwFeatureEnabled(
+                                            entry.getValue().mUsePeriodicRangingFeature)
+                                    .build(),
+                            mSessionConfig,
+                            entry.getKey())))
+                    .collect(ImmutableSet.toImmutableSet());
+        }
+
+        @NonNull
+        public ImmutableMap<RangingDevice, TechnologyOobConfig> getPeerConfigs() {
+            return mRangingDevices.entrySet().stream()
+                    .collect(ImmutableMap.toImmutableMap(
+                            Map.Entry::getKey,
+                            entry -> RttOobConfig.builder()
+                                    .setDeviceRole(DEVICE_ROLE_RESPONDER)
+                                    .setServiceName(entry.getValue().mServiceName)
+                                    .setUsePeriodicRanging(
+                                            entry.getValue().mUsePeriodicRangingFeature)
+                                    .build()));
+        }
+    }
+
+    public static void getLazyUpdateRate() {
+        if (sLocalPeriodicRangingSupport) {
+            RTT_UPDATE_RATE_DURATIONS = ImmutableMap.of(
+                    UPDATE_RATE_NORMAL, Duration.ofMillis(256),
+                    UPDATE_RATE_INFREQUENT, Duration.ofMillis(8192),
+                    UPDATE_RATE_FREQUENT, Duration.ofMillis(128));
+        } else {
+            RTT_UPDATE_RATE_DURATIONS = ImmutableMap.of(
+                    UPDATE_RATE_NORMAL, Duration.ofMillis(512),
+                    UPDATE_RATE_INFREQUENT, Duration.ofMillis(8192),
+                    UPDATE_RATE_FREQUENT, Duration.ofMillis(256));
+        }
+    }
+
+    private static String getServiceName(RangingDevice device) {
+        return SERVICE_NAME_PREFIX + device.getUuid().toString().replace("-",
+                "").substring(0, RTT_SUFFIX_SIZE);
+    }
+
+    private static class RttDeviceConfig {
+        String mServiceName;
+        boolean mUsePeriodicRangingFeature;
+
+        RttDeviceConfig(String serviceName, boolean usePeriodicRangingFeature) {
+            mServiceName = serviceName;
+            mUsePeriodicRangingFeature = usePeriodicRangingFeature;
+        }
+    }
+
+}
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttOobCapabilities.java b/ranging/service/java/com/android/server/ranging/rtt/RttOobCapabilities.java
new file mode 100644
index 00000000..6ef5374a
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttOobCapabilities.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.rtt;
+
+import android.ranging.wifi.rtt.RttRangingCapabilities;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils;
+import com.android.server.ranging.oob.TechnologyHeader;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+@AutoValue
+public abstract class RttOobCapabilities {
+
+    /** Size in bytes of all properties when serialized. */
+    private static final int EXPECTED_SIZE_BYTES = 6;
+
+    private static final int RTT_SUPPORTED_FEATURES_SIZE = 1;
+    private static final int RTT_SUPPORTED_FEATURES_SHIFT = 0;
+
+    public static RttOobCapabilities parseBytes(byte[] capabilitiesBytes) {
+        TechnologyHeader header = TechnologyHeader.parseBytes(capabilitiesBytes);
+
+        if (capabilitiesBytes.length < EXPECTED_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "RttOobCapabilities size is %d, expected at least %d",
+                            capabilitiesBytes.length, EXPECTED_SIZE_BYTES));
+        }
+
+        if (capabilitiesBytes.length < header.getSize()) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "RttOobCapabilities header size field is %d, but the size of the array"
+                                    + " is"
+                                    + " %d",
+                            header.getSize(), capabilitiesBytes.length));
+        }
+
+        if (header.getRangingTechnology() != RangingTechnology.RTT) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "RttOobCapabilities header technology field is %s, expected %s",
+                            header.getRangingTechnology(), RangingTechnology.RTT));
+        }
+
+        int parseCursor = header.getHeaderSize();
+
+        ImmutableList<RttOobConfig.RttSupportedFeatures> supportedFeatures =
+                RangingUtils.Conversions.byteArrayToIntList(
+                                Arrays.copyOfRange(capabilitiesBytes, parseCursor,
+                                        parseCursor + RTT_SUPPORTED_FEATURES_SIZE),
+                                RTT_SUPPORTED_FEATURES_SHIFT)
+                        .stream()
+                        .map(RttOobConfig.RttSupportedFeatures::fromValue)
+                        .collect(ImmutableList.toImmutableList());
+        parseCursor += RTT_SUPPORTED_FEATURES_SIZE;
+
+        boolean periodicRangingSupport = capabilitiesBytes[parseCursor++] != 0;
+        int maxBandwidth = capabilitiesBytes[parseCursor++];
+        int maxSupportedRxChain = capabilitiesBytes[parseCursor++];
+
+        return RttOobCapabilities.builder()
+                //.setSupportedFeatures(supportedFeatures)
+                .setHasPeriodicRangingSupport(periodicRangingSupport)
+                .setMaxSupportedBandwidth(maxBandwidth)
+                .setMaxSupportedRxChain(maxSupportedRxChain)
+                .build();
+    }
+
+    public final byte[] toBytes() {
+        ByteBuffer byteBuffer = ByteBuffer.allocate(EXPECTED_SIZE_BYTES);
+        byteBuffer
+                .put(RangingTechnology.RTT.toByte())
+                .put((byte) EXPECTED_SIZE_BYTES)
+                .put((byte) 1) // TODO: how to check for 11mc or 11az support
+                .put((byte) (hasPeriodicRangingSupport() ? 1 : 0))
+                .put((byte) maxSupportedBandwidth())
+                .put((byte) maxSupportedRxChain());
+
+        return byteBuffer.array();
+    }
+
+    public static RttOobCapabilities fromRangingCapabilities(RttRangingCapabilities capabilities) {
+        return RttOobCapabilities.builder()
+                .setHasPeriodicRangingSupport(capabilities.hasPeriodicRangingHardwareFeature())
+                .setMaxSupportedBandwidth(capabilities.getMaxSupportedBandwidth())
+                .setMaxSupportedRxChain(capabilities.getMaxSupportedRxChain())
+                .build();
+    }
+
+    //public abstract ImmutableList<RttOobConfig.RttSupportedFeatures> supportedFeatures();
+    public abstract boolean hasPeriodicRangingSupport();
+
+    public abstract int maxSupportedBandwidth();
+
+    public abstract int maxSupportedRxChain();
+
+    public static Builder builder() {
+        return new AutoValue_RttOobCapabilities.Builder();
+    }
+
+    @AutoValue.Builder
+    public abstract static class Builder {
+        //public abstract Builder setSupportedFeatures(
+        //ImmutableList<RttOobConfig.RttSupportedFeatures> value);
+        public abstract Builder setHasPeriodicRangingSupport(boolean value);
+
+        public abstract Builder setMaxSupportedBandwidth(int value);
+
+        public abstract Builder setMaxSupportedRxChain(int value);
+
+        public abstract RttOobCapabilities autoBuild();
+
+        public RttOobCapabilities build() {
+            return autoBuild();
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttOobConfig.java b/ranging/service/java/com/android/server/ranging/rtt/RttOobConfig.java
new file mode 100644
index 00000000..9e57dcd3
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttOobConfig.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.rtt;
+
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.wifi.rtt.RttRangingParams;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.SetConfigurationMessage;
+import com.android.server.ranging.oob.TechnologyHeader;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+@AutoValue
+public abstract class RttOobConfig implements SetConfigurationMessage.TechnologyOobConfig {
+
+    private static final int MIN_SIZE_BYTES = 6;
+
+    public enum RttSupportedFeatures {
+        RTT_11_MC(1),
+        RTT_11_AZ(2),
+        RTT_UNKNOWN(255);
+
+        public static final ImmutableList<RttSupportedFeatures> FEATURES =
+                ImmutableList.copyOf(RttSupportedFeatures.values());
+
+        private final int mValue;
+
+        RttSupportedFeatures(int value) {
+            this.mValue = value;
+        }
+
+        public int getValue() {
+            return mValue;
+        }
+
+        public static RttSupportedFeatures fromValue(int value) {
+            return value < RTT_11_MC.mValue || value > RTT_11_AZ.mValue ? RTT_UNKNOWN :
+                    RttSupportedFeatures.values()[value];
+        }
+    }
+
+    public enum Bandwidth {
+        BANDWIDTH_20MHZ(0),
+        BANDWIDTH_40MHZ(1),
+        BANDWIDTH_80MHZ(2),
+        BANDWIDTH_160MHZ(3),
+        BANDWIDTH_80MHZ_PLUS_MHZ(4),
+        BANDWIDTH_320MHZ(5),
+        BANDWIDTH_UNDEFINED(255);
+
+        private final int mValue;
+
+        Bandwidth(int value) {
+            this.mValue = value;
+        }
+
+        public int getValue() {
+            return mValue;
+        }
+    }
+
+    public static RttOobConfig parseBytes(byte[] rttConfigBytes) {
+        TechnologyHeader header = TechnologyHeader.parseBytes(rttConfigBytes);
+
+        if (rttConfigBytes.length < MIN_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format("RttConfig size is %d, expected at least %d",
+                            rttConfigBytes.length, MIN_SIZE_BYTES));
+        }
+
+        if (rttConfigBytes.length < header.getSize()) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "RttConfig header size field is %d, but the size of the array is %d",
+                            header.getSize(), rttConfigBytes.length));
+        }
+
+        if (header.getRangingTechnology() != RangingTechnology.RTT) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "RttConfig header technology field is %s, expected %s",
+                            header.getRangingTechnology(), RangingTechnology.RTT));
+        }
+
+        int parseCursor = header.getHeaderSize();
+        int serviceNameSize = rttConfigBytes[parseCursor++];
+        byte[] serviceNameBytes = Arrays.copyOfRange(rttConfigBytes, parseCursor,
+                parseCursor + serviceNameSize);
+        String serviceName = new String(serviceNameBytes);
+        parseCursor += serviceNameSize;
+
+        int deviceRole = rttConfigBytes[parseCursor++];
+        boolean usePeriodicRanging = rttConfigBytes[parseCursor++] != 0;
+
+        return builder()
+                .setDeviceRole(deviceRole)
+                .setServiceName(serviceName)
+                .setUsePeriodicRanging(usePeriodicRanging)
+                .build();
+    }
+
+    public final byte[] toBytes() {
+        int size = MIN_SIZE_BYTES + serviceName().length() - 1;
+        return ByteBuffer.allocate(size)
+                .put(RangingTechnology.RTT.toByte())
+                .put((byte) size)
+                .put((byte) serviceName().length())
+                .put(serviceName().getBytes())
+                .put((byte) deviceRole())
+                .put((byte) (usePeriodicRanging() ? 1 : 0))
+                .array();
+    }
+
+    public int getSize() {
+        return toBytes().length;
+    }
+
+    public RttConfig toTechnologyConfig(RangingDevice peer, int deviceRole) {
+        return new RttConfig(
+                deviceRole,
+                new RttRangingParams.Builder(serviceName()).build(),
+                new SessionConfig.Builder().build(),
+                peer);
+    }
+
+    public abstract String serviceName();
+
+    @OobDeviceRole
+    public abstract int deviceRole();
+
+    public abstract boolean usePeriodicRanging();
+
+    public @interface OobDeviceRole {
+        int RESPONDER = 0;
+        int INITIATOR = 1;
+    }
+
+    public static Builder builder() {
+        return new AutoValue_RttOobConfig.Builder();
+    }
+
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setServiceName(String value);
+
+        public abstract Builder setDeviceRole(int value);
+
+        public abstract Builder setUsePeriodicRanging(boolean value);
+
+        abstract RttOobConfig autoBuild();
+
+        public RttOobConfig build() {
+            return autoBuild();
+        }
+
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttParameters.java b/ranging/service/java/com/android/server/ranging/rtt/RttParameters.java
deleted file mode 100644
index 1e7e3529..00000000
--- a/ranging/service/java/com/android/server/ranging/rtt/RttParameters.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.ranging.rtt;
-
-import android.ranging.RangingDevice;
-
-import androidx.annotation.NonNull;
-
-import com.android.ranging.rtt.backend.internal.RttRangingParameters;
-import com.android.server.ranging.RangingTechnology;
-import com.android.server.ranging.session.RangingSessionConfig;
-
-import java.time.Duration;
-
-public class RttParameters extends com.android.ranging.rtt.backend.internal.RttRangingParameters
-        implements RangingSessionConfig.UnicastTechnologyConfig {
-    public RttParameters(Builder builder) {
-        super(builder);
-    }
-
-    @Override
-    public @NonNull RangingTechnology getTechnology() {
-        return RangingTechnology.RTT;
-    }
-
-    @Override
-    public @NonNull RangingDevice getPeerDevice() {
-        throw new UnsupportedOperationException("Not implemented!");
-    }
-
-    public static class Builder extends RttRangingParameters.Builder {
-        /** Set the service ID that produced this data */
-        public Builder setServiceId(byte serviceId) {
-            mServiceId = serviceId;
-            return this;
-        }
-
-        public Builder setServiceName(String serviceName) {
-            mServiceName = serviceName;
-            return this;
-        }
-
-        public Builder setMaxDistanceMm(int maxDistanceMm) {
-            mMaxDistanceMm = maxDistanceMm;
-            return this;
-        }
-
-        public Builder setMinDistanceMm(int minDistanceMm) {
-            mMinDistanceMm = minDistanceMm;
-            return this;
-        }
-
-        public Builder setEnablePublisherRanging(boolean enablePublisherRange) {
-            mEnablePublisherRanging = enablePublisherRange;
-            return this;
-        }
-
-        public Builder setPublisherPingDuration(@NonNull Duration ping) {
-            mPublisherPingDuration = ping;
-            return this;
-        }
-
-        public Builder setMatchFilter(byte[] matchFilter) {
-            mMatchFilter = matchFilter;
-            return this;
-        }
-
-        public RttParameters build() {
-            return new RttParameters(this);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return super.toString();
-    }
-}
diff --git a/ranging/service/java/com/android/server/ranging/session/BaseRangingSession.java b/ranging/service/java/com/android/server/ranging/session/BaseRangingSession.java
index fc2e7e43..76fa589f 100644
--- a/ranging/service/java/com/android/server/ranging/session/BaseRangingSession.java
+++ b/ranging/service/java/com/android/server/ranging/session/BaseRangingSession.java
@@ -16,11 +16,14 @@
 
 package com.android.server.ranging.session;
 
+import android.app.AlarmManager;
 import android.content.AttributionSource;
 import android.os.Binder;
+import android.os.SystemClock;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
 import android.ranging.SessionHandle;
+import android.ranging.raw.RawResponderRangingConfig;
 import android.util.Log;
 
 import androidx.annotation.GuardedBy;
@@ -28,8 +31,9 @@ import androidx.annotation.NonNull;
 
 import com.android.server.ranging.RangingAdapter;
 import com.android.server.ranging.RangingInjector;
-import com.android.server.ranging.RangingServiceManager;
+import com.android.server.ranging.RangingServiceManager.SessionListener;
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.InternalReason;
 import com.android.server.ranging.RangingUtils.StateMachine;
 import com.android.server.ranging.fusion.DataFusers;
 import com.android.server.ranging.fusion.FilteringFusionEngine;
@@ -44,6 +48,8 @@ import com.google.common.util.concurrent.ListeningExecutorService;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
+import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
@@ -52,13 +58,20 @@ import java.util.concurrent.ConcurrentMap;
 public class BaseRangingSession {
     private static final String TAG = BaseRangingSession.class.getSimpleName();
 
-    private final RangingInjector mInjector;
+    private static final int NON_PRIVILEGED_RANGING_BG_APP_TIMEOUT_MS = 60_000;
+
+    public static final String NON_PRIVILEGED_RANGING_BG_APP_TIMER_TAG =
+            "RangingSessionNonPrivilegedBgAppTimeout";
     private final AttributionSource mAttributionSource;
-    private final RangingServiceManager.SessionListener mSessionListener;
     private final ListeningExecutorService mAdapterExecutor;
 
+    protected final RangingInjector mInjector;
     protected final SessionHandle mSessionHandle;
-    protected final RangingSessionConfig mConfig;
+    protected final RangingSessionConfig mSessionConfig;
+    protected final SessionListener mSessionListener;
+
+    private final AlarmManager mAlarmManager;
+    private AlarmManager.OnAlarmListener mNonPrivilegedBgAppTimerListener;
 
     /* Lock for internal state. */
     private final Object mLock = new Object();
@@ -82,6 +95,9 @@ public class BaseRangingSession {
      */
     @GuardedBy("mLock")
     private final ConcurrentMap<TechnologyConfig, RangingAdapter> mAdapters;
+    @GuardedBy("mLock")
+    private final ConcurrentMap<TechnologyConfig, @InternalReason Integer>
+            mStopReasonOverride;
 
     /** State of all peers in the session */
     @GuardedBy("mLock")
@@ -96,9 +112,10 @@ public class BaseRangingSession {
 
         Peer(@NonNull RangingDevice device, @NonNull RangingTechnology initialTechnology) {
             technologies = Sets.newConcurrentHashSet(Set.of(initialTechnology));
-            if (mConfig.getSensorFusionConfig().isSensorFusionEnabled()) {
+            if (mSessionConfig.getSessionConfig().getSensorFusionParams().isSensorFusionEnabled()) {
                 fusionEngine = new FilteringFusionEngine(
-                        new DataFusers.PreferentialDataFuser(RangingTechnology.UWB));
+                        new DataFusers.PreferentialDataFuser(RangingTechnology.UWB),
+                        mSessionConfig.getSessionConfig().isAngleOfArrivalNeeded(), mInjector);
             } else {
                 fusionEngine = new NoOpFusionEngine(device);
             }
@@ -121,27 +138,38 @@ public class BaseRangingSession {
             @NonNull SessionHandle sessionHandle,
             @NonNull RangingInjector injector,
             @NonNull RangingSessionConfig config,
-            @NonNull RangingServiceManager.SessionListener listener,
+            @NonNull SessionListener listener,
             @NonNull ListeningExecutorService adapterExecutor
     ) {
         mInjector = injector;
         mAttributionSource = attributionSource;
         mSessionHandle = sessionHandle;
-        mConfig = config;
+        mSessionConfig = config;
         mSessionListener = listener;
         mAdapterExecutor = adapterExecutor;
         mStateMachine = new StateMachine<>(State.STOPPED);
         mPeers = new ConcurrentHashMap<>();
         mAdapters = new ConcurrentHashMap<>();
+        mStopReasonOverride = new ConcurrentHashMap<>();
+        mAlarmManager = mInjector.getContext().getSystemService(AlarmManager.class);
     }
 
-    /** Start ranging in this session. */
+    /**
+     * Start ranging in this session.
+     * Send {@code onSessionClosed(INTERNAL_ERROR)} if this session is already active.
+     */
     public void start(ImmutableSet<TechnologyConfig> technologyConfigs) {
+        Log.v(TAG, "Starting session");
         synchronized (mLock) {
+            mSessionListener.onConfigurationComplete(technologyConfigs);
+
             if (!mStateMachine.transition(State.STOPPED, State.STARTING)) {
                 Log.w(TAG, "Failed transition STOPPED -> STARTING");
+                onSessionClosed(InternalReason.INTERNAL_ERROR);
                 return;
             }
+            AttributionSource nonPrivilegedAttributionSource =
+                    mInjector.getAnyNonPrivilegedAppInAttributionSource(mAttributionSource);
 
             for (TechnologyConfig config : technologyConfigs) {
                 ImmutableSet<RangingDevice> peerDevices;
@@ -151,10 +179,9 @@ public class BaseRangingSession {
                 } else if (config instanceof MulticastTechnologyConfig multicastConfig) {
                     peerDevices = multicastConfig.getPeerDevices();
                 } else {
-                    Log.e(TAG,
-                            "Received unsupported config for technology " + config.getTechnology());
-                    mSessionListener.onSessionStopped(
-                            RangingAdapter.Callback.ClosedReason.FAILED_TO_START);
+                    Log.e(TAG, "Received unknown RangingTechnology subclass "
+                            + config.getClass());
+                    onSessionClosed(InternalReason.INTERNAL_ERROR);
                     return;
                 }
 
@@ -170,49 +197,198 @@ public class BaseRangingSession {
                 // done with a clear calling identity.
                 long token = Binder.clearCallingIdentity();
                 RangingAdapter adapter = mInjector.createAdapter(
-                        config, mConfig.getDeviceRole(), mAdapterExecutor);
+                        mAttributionSource, config, mAdapterExecutor);
                 mAdapters.put(config, adapter);
-                adapter.start(config, new AdapterListener(config));
+                Log.v(TAG, "Starting ranging with technology : " + config.getTechnology());
+                adapter.start(config, nonPrivilegedAttributionSource, new AdapterListener(config));
                 Binder.restoreCallingIdentity(token);
             }
         }
     }
 
-    public void addPeer(RangingDevice params) {
-        //TODO: Implement this
-        throw new IllegalArgumentException("Dynamic addition of raw peer not supported yet");
+    /**
+     * <ul>
+     *     <li>If this session currently active with a different configuration from the one
+     *     provided, return false.</li>
+     *     <li>If this session is currently active with the same configuration as the one provided,
+     *     return true.</li>
+     *     <li>If this session is not currently active, start it with the provided configuration and
+     *     return true.</li>
+     * </ul>
+     */
+    protected boolean startOrReAttach(ImmutableSet<TechnologyConfig> technologyConfigs) {
+        synchronized (mLock) {
+            if (mStateMachine.getState() == State.STARTING
+                    || mStateMachine.getState() == State.STARTED) {
+                return Sets.difference(technologyConfigs, mAdapters.keySet()).isEmpty();
+            } else {
+                start(technologyConfigs);
+                return true;
+            }
+        }
+    }
+
+    public void addPeer(RawResponderRangingConfig params) {
+        synchronized (mLock) {
+            for (Map.Entry<TechnologyConfig, RangingAdapter> entry : mAdapters.entrySet()) {
+                if (entry.getValue().isDynamicUpdatePeersSupported()) {
+                    RangingDevice peerDevice = params.getRawRangingDevice().getRangingDevice();
+                    mPeers.put(peerDevice, new Peer(peerDevice, entry.getKey().getTechnology()));
+                    entry.getValue().addPeer(params);
+                }
+            }
+        }
     }
 
-    public void removePeer(RangingDevice params) {
-        //TODO: Implement this
-        throw new IllegalArgumentException("Dynamic addition of raw peer not supported yet");
+    public void removePeer(RangingDevice device) {
+        synchronized (mLock) {
+            for (Map.Entry<TechnologyConfig, RangingAdapter> entry : mAdapters.entrySet()) {
+                if (entry.getValue().isDynamicUpdatePeersSupported()) {
+                    entry.getValue().removePeer(device);
+                }
+            }
+        }
     }
 
     public void reconfigureInterval(int intervalSkipCount) {
-        //TODO: Implement this
-        throw new IllegalArgumentException("Dynamic addition of raw peer not supported yet");
+        synchronized (mLock) {
+            for (Map.Entry<TechnologyConfig, RangingAdapter> entry : mAdapters.entrySet()) {
+                entry.getValue().reconfigureRangingInterval(intervalSkipCount);
+            }
+        }
+    }
+
+    public void appForegroundStateUpdated(boolean appInForeground) {
+        synchronized (mLock) {
+            for (Map.Entry<TechnologyConfig, RangingAdapter> entry : mAdapters.entrySet()) {
+                entry.getValue().appForegroundStateUpdated(appInForeground);
+                if (!appInForeground) {
+                    startNonPrivilegedBgAppTimerIfNotSet();
+                } else {
+                    stopNonPrivilegedBgAppTimerIfSet();
+                }
+            }
+        }
+    }
+
+    public void appInBackgroundTimeout() {
+        synchronized (mLock) {
+            for (Map.Entry<TechnologyConfig, RangingAdapter> entry : mAdapters.entrySet()) {
+                entry.getValue().appInBackgroundTimeout();
+            }
+        }
+    }
+
+    /**
+     * Starts a timer to detect if the app that started the UWB session is in the background
+     * for longer than NON_PRIVILEGED_BG_APP_TIMEOUT_MS.
+     */
+    private void startNonPrivilegedBgAppTimerIfNotSet() {
+        // Start a timer when the non-privileged app goes into the background.
+        if (mNonPrivilegedBgAppTimerListener == null) {
+            mNonPrivilegedBgAppTimerListener = () -> {
+                Log.w(TAG, "Non-privileged app in background for longer than timeout");
+                appInBackgroundTimeout();
+            };
+            mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                    SystemClock.elapsedRealtime() + NON_PRIVILEGED_RANGING_BG_APP_TIMEOUT_MS,
+                    NON_PRIVILEGED_RANGING_BG_APP_TIMER_TAG,
+                    mNonPrivilegedBgAppTimerListener,
+                    mInjector.getAlarmHandler());
+        }
+    }
+
+    public void stopNonPrivilegedBgAppTimerIfSet() {
+        // Stop the timer when the non-privileged app goes into the foreground.
+        if (mNonPrivilegedBgAppTimerListener != null) {
+            mAlarmManager.cancel(mNonPrivilegedBgAppTimerListener);
+            mNonPrivilegedBgAppTimerListener = null;
+        }
     }
 
     /** Stop ranging in this session. */
     public void stop() {
+        stop(InternalReason.LOCAL_REQUEST);
+    }
+
+    /**
+     * Stop all adapters in the session.
+     * @param reason When we receive the
+     * {@link RangingAdapter.Callback#onStopped(ImmutableSet, int)} callback for each of these
+     * adapters, override the reason code provided in the callback with this one.
+     * @return true if there are currently any active adapters in the session.
+     */
+    protected boolean stop(@InternalReason int reason) {
+        Log.v(TAG, "Stop ranging, stopping all adapters");
         synchronized (mLock) {
             if (mStateMachine.getState() == State.STOPPING
                     || mStateMachine.getState() == State.STOPPED) {
                 Log.v(TAG, "Ranging already stopping or stopped, skipping");
-                return;
+                return false;
             }
+            stopNonPrivilegedBgAppTimerIfSet();
             mStateMachine.setState(State.STOPPING);
 
             // Any calls to the corresponding technology stacks must be
             // done with a clear calling identity.
             long token = Binder.clearCallingIdentity();
-            for (RangingAdapter adapter : mAdapters.values()) {
-                adapter.stop();
+            boolean existsAdaptersWithActiveRanging = !mAdapters.isEmpty();
+            for (TechnologyConfig config : mAdapters.keySet()) {
+                if (reason != InternalReason.LOCAL_REQUEST) mStopReasonOverride.put(config, reason);
+                mAdapters.get(config).stop();
+            }
+            Binder.restoreCallingIdentity(token);
+            return existsAdaptersWithActiveRanging;
+        }
+    }
+
+    /**
+     * Stop all adapters associated with the provided {@code technologies}. When we receive the
+     * {@link RangingAdapter.Callback#onStopped(ImmutableSet, int)} callback for each of these
+     * adapters, override the reason code provided in the callback with the {@code reason} given
+     * here.
+     */
+    protected void stopTechnologies(
+            Set<RangingTechnology> technologies, @InternalReason int reason) {
+        Log.v(TAG, "Stop ranging with technologies " + technologies);
+        synchronized (mLock) {
+            long token = Binder.clearCallingIdentity();
+            for (TechnologyConfig config : mAdapters.keySet()) {
+                if (technologies.contains(config.getTechnology())) {
+                    if (reason != InternalReason.LOCAL_REQUEST) {
+                        mStopReasonOverride.put(config, reason);
+                    }
+                    mAdapters.get(config).stop();
+                }
             }
             Binder.restoreCallingIdentity(token);
         }
     }
 
+    protected ImmutableSet<RangingTechnology> getTechnologiesUsedByPeer(RangingDevice device) {
+        synchronized (mLock) {
+            Peer peer = mPeers.get(device);
+            if (peer == null) {
+                return ImmutableSet.of();
+            } else {
+                return ImmutableSet.copyOf(peer.technologies);
+            }
+        }
+    }
+
+    /** Let subclasses override how onTechnologyStopped gets called. */
+    protected void onTechnologyStopped(
+            @NonNull RangingTechnology technology, @NonNull Set<RangingDevice> peers,
+            @InternalReason int reason
+    ) {
+        mSessionListener.onTechnologyStopped(technology, peers, reason);
+    }
+
+    /** Let subclasses override how onSessionClosed gets called. */
+    protected void onSessionClosed(@InternalReason int reason) {
+        mSessionListener.onSessionClosed(reason);
+    }
+
     private class AdapterListener implements RangingAdapter.Callback {
         private final TechnologyConfig mConfig;
 
@@ -221,24 +397,38 @@ public class BaseRangingSession {
         }
 
         @Override
-        public void onStarted(@NonNull RangingDevice peerDevice) {
+        public void onStarted(@NonNull ImmutableSet<RangingDevice> peerDevices) {
             synchronized (mLock) {
-                mStateMachine.transition(State.STARTING, State.STARTED);
-                mPeers.get(peerDevice).setUsingTechnology(mConfig.getTechnology());
-                mSessionListener.onTechnologyStarted(peerDevice, mConfig.getTechnology());
+                for (RangingDevice peerDevice : peerDevices) {
+                    if (!mPeers.containsKey(peerDevice)) {
+                        Log.w(TAG, "onStarted peer not found");
+                        continue;
+                    }
+                    mStateMachine.transition(State.STARTING, State.STARTED);
+                    mPeers.get(peerDevice).setUsingTechnology(mConfig.getTechnology());
+                }
+                mSessionListener.onTechnologyStarted(mConfig.getTechnology(), peerDevices);
             }
         }
 
         @Override
-        public void onStopped(@NonNull RangingDevice peerDevice) {
+        public void onStopped(
+                @NonNull ImmutableSet<RangingDevice> peerDevices, @InternalReason int reason
+        ) {
             synchronized (mLock) {
-                Peer peer = mPeers.get(peerDevice);
-                peer.setNotUsingTechnology(mConfig.getTechnology());
-                mSessionListener.onTechnologyStopped(peerDevice, mConfig.getTechnology());
-                if (peer.technologies.isEmpty()) {
-                    peer.fusionEngine.stop();
-                    mPeers.remove(peerDevice);
+                for (RangingDevice peerDevice : peerDevices) {
+                    Peer peer = mPeers.get(peerDevice);
+                    if (peer == null) {
+                        Log.w(TAG, "onStopped peer not found");
+                        continue;
+                    }
+                    peer.setNotUsingTechnology(mConfig.getTechnology());
+                    if (peer.technologies.isEmpty()) {
+                        peer.fusionEngine.stop();
+                        mPeers.remove(peerDevice);
+                    }
                 }
+                onTechnologyStopped(mConfig.getTechnology(), peerDevices, maybeOverridden(reason));
             }
         }
 
@@ -254,13 +444,24 @@ public class BaseRangingSession {
         }
 
         @Override
-        public void onClosed(@ClosedReason int reason) {
+        public void onClosed(@InternalReason int reason) {
             synchronized (mLock) {
                 mAdapters.remove(mConfig);
                 if (mAdapters.isEmpty()) {
                     mStateMachine.setState(State.STOPPED);
-                    mSessionListener.onSessionStopped(reason);
+                    onSessionClosed(maybeOverridden(reason));
                 }
+                mStopReasonOverride.remove(mConfig);
+            }
+        }
+
+        /** @return the (possibly overriding) reason code for the last state change. */
+        @GuardedBy("mLock")
+        private @InternalReason int maybeOverridden(@InternalReason int reason) {
+            if (reason == InternalReason.LOCAL_REQUEST) {
+                return Optional.ofNullable(mStopReasonOverride.get(mConfig)).orElse(reason);
+            } else {
+                return reason;
             }
         }
     }
@@ -315,6 +516,7 @@ public class BaseRangingSession {
         pw.println("---- Dump of RangingSession ----");
         pw.println("Session handle: " + mSessionHandle);
         pw.println("Attribution source: " + mAttributionSource);
+        pw.println("Config: " + mSessionConfig);
         pw.println("Adapters:");
         for (RangingAdapter adapter : mAdapters.values()) {
             pw.println(adapter);
diff --git a/ranging/service/java/com/android/server/ranging/session/OobInitiatorRangingSession.java b/ranging/service/java/com/android/server/ranging/session/OobInitiatorRangingSession.java
index d3c799ef..61cc4642 100644
--- a/ranging/service/java/com/android/server/ranging/session/OobInitiatorRangingSession.java
+++ b/ranging/service/java/com/android/server/ranging/session/OobInitiatorRangingSession.java
@@ -17,30 +17,54 @@
 package com.android.server.ranging.session;
 
 import android.content.AttributionSource;
+import android.ranging.RangingConfig;
 import android.ranging.SessionHandle;
-import android.ranging.oob.IOobSendDataListener;
+import android.ranging.oob.DeviceHandle;
 import android.ranging.oob.OobHandle;
-import android.ranging.oob.OobInitiatorRangingParams;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.util.Log;
 
 import androidx.annotation.NonNull;
 
+import com.android.server.ranging.RangingEngine;
 import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingServiceManager;
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.InternalReason;
 import com.android.server.ranging.oob.CapabilityRequestMessage;
-import com.android.server.ranging.oob.OobHandler;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobController;
+import com.android.server.ranging.oob.OobController.OobConnection;
+import com.android.server.ranging.oob.OobHeader;
+import com.android.server.ranging.oob.SetConfigurationMessage;
+import com.android.server.ranging.oob.StopRangingMessage;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.FluentFuture;
+import com.google.common.util.concurrent.FutureCallback;
+import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListeningExecutorService;
 
-public class OobInitiatorRangingSession
-        extends BaseRangingSession
-        implements RangingSession<OobInitiatorRangingParams>, OobHandler {
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
-    private final IOobSendDataListener mOobDataSender;
+public class OobInitiatorRangingSession extends BaseRangingSession implements RangingSession {
+    private static final String TAG = OobInitiatorRangingSession.class.getSimpleName();
 
-    private ImmutableSet<OobHandle> mOobHandles;
+    private static final long MESSAGE_TIMEOUT_MS = 4000;
+
+    private final ScheduledExecutorService mOobExecutor;
+    private final ConcurrentHashMap<OobHandle, OobConnection> mOobConnections;
+
+    private RangingEngine mRangingEngine;
 
     public OobInitiatorRangingSession(
             @NonNull AttributionSource attributionSource,
@@ -48,48 +72,201 @@ public class OobInitiatorRangingSession
             @NonNull RangingInjector injector,
             @NonNull RangingSessionConfig config,
             @NonNull RangingServiceManager.SessionListener listener,
-            @NonNull IOobSendDataListener oobDataSender,
-            @NonNull ListeningExecutorService adapterExecutor
+            @NonNull ListeningExecutorService adapterExecutor,
+            @NonNull ScheduledExecutorService oobExecutor
     ) {
         super(attributionSource, sessionHandle, injector, config, listener, adapterExecutor);
-        mOobDataSender = oobDataSender;
-        mOobHandles = null;
+        mOobExecutor = oobExecutor;
+        mOobConnections = new ConcurrentHashMap<>();
     }
 
     @Override
-    public void start(@NonNull OobInitiatorRangingParams params) {
+    public void start(@NonNull RangingConfig rangingConfig) {
+        if (!(rangingConfig instanceof OobInitiatorRangingConfig config)) {
+            Log.e(TAG, "Unexpected configuration object for oob initiator session "
+                    + rangingConfig.getClass());
+            mSessionListener.onSessionClosed(InternalReason.INTERNAL_ERROR);
+            return;
+        }
+
+        try {
+            mRangingEngine = new RangingEngine(
+                    mSessionConfig.getSessionConfig(), config, mSessionHandle, mInjector);
+        } catch (RangingEngine.ConfigSelectionException e) {
+            Log.w(TAG, "Provided config incompatible with local capabilities: ", e);
+            mSessionListener.onSessionClosed(InternalReason.UNSUPPORTED);
+            return;
+        }
 
-        mOobHandles = params.getDeviceHandles()
-                .stream().map((handle) -> new OobHandle(mSessionHandle, handle.getRangingDevice()))
-                .collect(ImmutableSet.toImmutableSet());
+        sendCapabilityRequestMessages(config.getDeviceHandles())
+                .transformAsync((unused) -> sendSetConfigMessages(), mOobExecutor)
+                .addCallback(new FutureCallback<>() {
+                    @Override
+                    public void onSuccess(ImmutableSet<TechnologyConfig> localConfigs) {
+                        // TODO: Send start ranging message to peers who don't have all active
+                        //  technologies in their start ranging list
+                        OobInitiatorRangingSession.super.start(localConfigs);
+                    }
 
-        // TODO
-        CapabilityRequestMessage message = CapabilityRequestMessage.builder()
-                .setRequestedRangingTechnologies(ImmutableList.of(RangingTechnology.UWB))
-                .build();
+                    @Override
+                    public void onFailure(@NonNull Throwable t) {
+                        Log.w(TAG, "Oob failed: ", t);
+                        switch (t) {
+                            case RangingEngine.ConfigSelectionException e ->
+                                    mSessionListener.onSessionClosed(e.getReason());
+                            case OobController.ConnectionClosedException e ->
+                                    mSessionListener.onSessionClosed(InternalReason.NO_PEERS_FOUND);
+                            case TimeoutException unused ->
+                                    mSessionListener.onSessionClosed(InternalReason.NO_PEERS_FOUND);
+                            default ->
+                                    mSessionListener.onSessionClosed(InternalReason.INTERNAL_ERROR);
+                        }
+                    }
+                }, mOobExecutor);
     }
 
     @Override
-    public void handleOobMessage(OobHandle oobHandle, byte[] data) {
-        // TODO
-        throw new UnsupportedOperationException("Not implemented");
+    public void stop() {
+        Map<OobHandle, FluentFuture<Void>> pendingSends = new HashMap<>(mOobConnections.size());
+
+        mOobConnections.forEach((oobHandle, connection) -> {
+            ImmutableSet<RangingTechnology> technologies = OobInitiatorRangingSession.super
+                    .getTechnologiesUsedByPeer(oobHandle.getRangingDevice());
+
+            Log.v(TAG, "Sending stop ranging to peer " + oobHandle + " with technologies "
+                    + technologies);
+
+            pendingSends.put(oobHandle, mOobConnections.get(oobHandle)
+                    .sendData(StopRangingMessage.builder()
+                            .setOobHeader(OobHeader.builder()
+                                    .setMessageType(MessageType.STOP_RANGING)
+                                    .setVersion(OobHeader.OobVersion.CURRENT)
+                                    .build())
+                            .setRangingTechnologiesToStop(ImmutableList.copyOf(technologies))
+                            .build()
+                            .toBytes()));
+        });
+
+        FluentFuture.from(Futures
+                        .whenAllComplete(pendingSends.values())
+                        .call(() -> handleFailedFutures(pendingSends), mOobExecutor))
+                .addCallback(new FutureCallback<>() {
+                    @Override
+                    public void onSuccess(Map<OobHandle, Void> result) {
+                        Log.i(TAG, "Sent stop ranging on OOB handles " + result.keySet());
+                        OobInitiatorRangingSession.super.stop();
+                    }
+
+                    @Override
+                    public void onFailure(Throwable t) {
+                        Log.e(TAG, "Failed to send stop ranging message over oob", t);
+                        OobInitiatorRangingSession.super.stop();
+                    }
+                }, mOobExecutor);
     }
 
-    @Override
-    public void handleOobDeviceDisconnected(OobHandle oobHandle) {
-        // TODO
-        throw new UnsupportedOperationException("Not implemented");
+    private FluentFuture<Void> sendCapabilityRequestMessages(List<DeviceHandle> deviceHandles) {
+        Map<OobHandle, FluentFuture<byte[]>> pendingResponses = new HashMap<>();
+        for (DeviceHandle deviceHandle : deviceHandles) {
+            OobHandle handle = new OobHandle(mSessionHandle, deviceHandle.getRangingDevice());
+            mOobConnections.put(handle, mInjector.getOobController().createConnection(handle));
+        }
+        ImmutableSet<RangingTechnology> requestedTechnologies =
+                mRangingEngine.getRequestedTechnologies();
+        Log.v(TAG, "Requesting technologies " + requestedTechnologies
+                + " based on local capabilities");
+
+        byte[] message = CapabilityRequestMessage.builder()
+                .setHeader(OobHeader.builder()
+                        .setMessageType(MessageType.CAPABILITY_REQUEST)
+                        .setVersion(OobHeader.OobVersion.CURRENT)
+                        .build())
+                .setRequestedRangingTechnologies(mRangingEngine.getRequestedTechnologies())
+                .build()
+                .toBytes();
+
+        mOobConnections.forEach((peer, connection) ->
+                pendingResponses.put(
+                        peer,
+                        connection
+                                .sendData(message)
+                                .transformAsync((unused) -> connection.receiveData(), mOobExecutor)
+                                .withTimeout(MESSAGE_TIMEOUT_MS, TimeUnit.MILLISECONDS,
+                                        mOobExecutor)));
+
+        return FluentFuture.from(
+                Futures.whenAllComplete(pendingResponses.values())
+                        .call(() -> {
+                            handleCapabilitiesResponses(handleFailedFutures(pendingResponses));
+                            return null;
+                        }, mOobExecutor));
     }
 
-    @Override
-    public void handleOobDeviceReconnected(OobHandle oobHandle) {
-        // TODO
-        throw new UnsupportedOperationException("Not implemented");
+    private FluentFuture<ImmutableSet<TechnologyConfig>> sendSetConfigMessages()
+            throws RangingEngine.ConfigSelectionException {
+
+        RangingEngine.SelectedConfig configs = mRangingEngine.selectConfigs();
+
+        Map<OobHandle, FluentFuture<Void>> pendingSends = new HashMap<>(mOobConnections.size());
+        mOobConnections.forEach((oobHandle, connection) -> {
+            SetConfigurationMessage message = configs
+                    .getPeerConfigMessages()
+                    .get(oobHandle.getRangingDevice());
+
+            if (message == null) {
+                pendingSends.put(
+                        oobHandle,
+                        FluentFuture.from(Futures.immediateFailedFuture(
+                                new RangingEngine.ConfigSelectionException(
+                                        "No set configuration message was selected to send on "
+                                                + "handle " + oobHandle,
+                                        InternalReason.NO_PEERS_FOUND))));
+            } else {
+                pendingSends.put(
+                        oobHandle,
+                        mOobConnections.get(oobHandle).sendData(message.toBytes()));
+            }
+        });
+
+        return FluentFuture.from(
+                Futures.whenAllComplete(pendingSends.values())
+                        .call(() -> {
+                            handleFailedFutures(pendingSends);
+                            return configs.getLocalConfigs();
+                        }, mOobExecutor));
+    }
+
+    private void handleCapabilitiesResponses(
+            Map<OobHandle, byte[]> responses
+    ) throws RangingEngine.ConfigSelectionException {
+        Log.i(TAG, "Received capabilities response messages");
+
+        for (OobHandle oobHandle : responses.keySet()) {
+            CapabilityResponseMessage response =
+                    CapabilityResponseMessage.parseBytes(responses.get(oobHandle));
+            mRangingEngine.addPeerCapabilities(oobHandle.getRangingDevice(), response);
+        }
+    }
+
+    private <T> Map<OobHandle, T> handleFailedFutures(Map<OobHandle, FluentFuture<T>> futures) {
+        Map<OobHandle, T> unwrapped = new HashMap<>(futures.size());
+        for (OobHandle handle : futures.keySet()) {
+            try {
+                unwrapped.put(handle, futures.get(handle).get());
+            } catch (Exception e) {
+                Log.w(TAG, "Peer " + handle + " dropped from ongoing OOB", e);
+                mOobConnections.remove(handle).close();
+            }
+        }
+        if (mOobConnections.isEmpty()) {
+            throw new IllegalStateException("All peers dropped from OOB");
+        }
+        return unwrapped;
     }
 
     @Override
-    public void handleOobClosed(OobHandle oobHandle) {
-        // TODO
-        throw new UnsupportedOperationException("Not implemented");
+    public void close() {
+        mOobConnections.values().forEach(OobController.OobConnection::close);
+        mOobConnections.clear();
     }
 }
diff --git a/ranging/service/java/com/android/server/ranging/session/OobResponderRangingSession.java b/ranging/service/java/com/android/server/ranging/session/OobResponderRangingSession.java
index 207e65d8..8a111a14 100644
--- a/ranging/service/java/com/android/server/ranging/session/OobResponderRangingSession.java
+++ b/ranging/service/java/com/android/server/ranging/session/OobResponderRangingSession.java
@@ -16,66 +16,301 @@
 
 package com.android.server.ranging.session;
 
+import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+
 import android.content.AttributionSource;
+import android.ranging.RangingCapabilities;
+import android.ranging.RangingConfig;
+import android.ranging.RangingDevice;
 import android.ranging.SessionHandle;
-import android.ranging.oob.IOobSendDataListener;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
+import android.ranging.ble.rssi.BleRssiRangingCapabilities;
 import android.ranging.oob.OobHandle;
-import android.ranging.oob.OobResponderRangingParams;
+import android.ranging.oob.OobResponderRangingConfig;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbRangingCapabilities;
+import android.ranging.wifi.rtt.RttRangingCapabilities;
+import android.util.Log;
 
 import androidx.annotation.NonNull;
 
 import com.android.server.ranging.RangingInjector;
-import com.android.server.ranging.RangingServiceManager;
-import com.android.server.ranging.oob.OobHandler;
+import com.android.server.ranging.RangingServiceManager.SessionListener;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.InternalReason;
+import com.android.server.ranging.blerssi.BleRssiOobCapabilities;
+import com.android.server.ranging.cs.CsOobCapabilities;
+import com.android.server.ranging.oob.CapabilityRequestMessage;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobController;
+import com.android.server.ranging.oob.OobController.ConnectionClosedException;
+import com.android.server.ranging.oob.OobHeader;
+import com.android.server.ranging.oob.SetConfigurationMessage;
+import com.android.server.ranging.oob.StopRangingMessage;
+import com.android.server.ranging.rtt.RttOobCapabilities;
+import com.android.server.ranging.rtt.RttOobConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+import com.android.server.ranging.uwb.UwbOobCapabilities;
+import com.android.server.ranging.uwb.UwbOobConfig;
 
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.FluentFuture;
+import com.google.common.util.concurrent.FutureCallback;
 import com.google.common.util.concurrent.ListeningExecutorService;
 
-public class OobResponderRangingSession
-        extends BaseRangingSession
-        implements RangingSession<OobResponderRangingParams>, OobHandler {
+import java.util.Set;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * OOB responder session. For this session, the callbacks have different semantics:
+ * <ul>
+ *     <li>{@link SessionListener#onSessionOpened()} indicates that the session has
+ *     started listening for OOB messages. This will be called before ranging actually starts.</li>
+ *     <li>{@link SessionListener#onSessionClosed(int)} indicates that the session
+ *     is no longer listening for OOB messages. This will only be called if the session is stopped
+ *     explicitly via {@code stop()} or if the underlying OOB transport closes.</li>
+ * </ul>
+ *
+ */
+public class OobResponderRangingSession extends BaseRangingSession implements RangingSession {
+    private static final String TAG = OobResponderRangingSession.class.getSimpleName();
+
+    private final ScheduledExecutorService mOobExecutor;
+    private final OobConnectionListener mOobConnectionListener;
 
-    private final IOobSendDataListener mOobDataSender;
+    private OobHandle mPeer;
+    private OobController.OobConnection mOobConnection;
+    private AtomicReference<ImmutableSet<TechnologyConfig>> mRestartingWithConfigs;
+    private AtomicBoolean mKeepAliveFlag;
+    private UwbAddress mMyUwbAddress;
 
     public OobResponderRangingSession(
             @NonNull AttributionSource attributionSource,
             @NonNull SessionHandle sessionHandle,
             @NonNull RangingInjector injector,
             @NonNull RangingSessionConfig config,
-            @NonNull RangingServiceManager.SessionListener listener,
-            @NonNull IOobSendDataListener oobDataSender,
-            @NonNull ListeningExecutorService adapterExecutor
+            @NonNull SessionListener listener,
+            @NonNull ListeningExecutorService adapterExecutor,
+            @NonNull ScheduledExecutorService oobExecutor
     ) {
         super(attributionSource, sessionHandle, injector, config, listener, adapterExecutor);
-        mOobDataSender = oobDataSender;
+        mOobExecutor = oobExecutor;
+        mOobConnectionListener = new OobConnectionListener();
     }
 
     @Override
-    public void start(@NonNull OobResponderRangingParams params) {
-        // TODO
-        throw new UnsupportedOperationException("Not implemented");
+    public void start(@NonNull RangingConfig rangingConfig) {
+        if (!(rangingConfig instanceof OobResponderRangingConfig config)) {
+            Log.e(TAG, "Unexpected configuration object for oob responder session "
+                    + rangingConfig.getClass());
+            mSessionListener.onSessionClosed(InternalReason.INTERNAL_ERROR);
+            return;
+        }
+
+        mPeer = new OobHandle(mSessionHandle, config.getDeviceHandle().getRangingDevice());
+        mOobConnection = mInjector.getOobController().createConnection(mPeer);
+        mRestartingWithConfigs = new AtomicReference<>(null);
+        mKeepAliveFlag = new AtomicBoolean(true);
+        mMyUwbAddress = UwbAddress.createRandomShortAddress();
+
+        mOobConnection.receiveData().addCallback(mOobConnectionListener, mOobExecutor);
+        mSessionListener.onSessionOpened();
     }
 
     @Override
-    public void handleOobMessage(OobHandle oobHandle, byte[] data) {
-        // TODO
-        throw new UnsupportedOperationException("Not implemented");
+    public void stop() {
+        stopSessionForReason(InternalReason.LOCAL_REQUEST);
     }
 
+
     @Override
-    public void handleOobDeviceDisconnected(OobHandle oobHandle) {
-        // TODO
-        throw new UnsupportedOperationException("Not implemented");
+    protected void onTechnologyStopped(
+            @NonNull RangingTechnology technology, @NonNull Set<RangingDevice> peers,
+            @InternalReason int reason
+    ) {
+        // Don't send onTechnologyStopped if the technologies stopped due to a restart.
+        if (mRestartingWithConfigs.get() == null) {
+            mSessionListener.onTechnologyStopped(technology, peers, reason);
+        }
     }
 
     @Override
-    public void handleOobDeviceReconnected(OobHandle oobHandle) {
-        // TODO
-        throw new UnsupportedOperationException("Not implemented");
+    protected void onSessionClosed(@InternalReason int reason) {
+        ImmutableSet<TechnologyConfig> configsForRestart = mRestartingWithConfigs.getAndSet(null);
+        if (configsForRestart != null) {
+            super.start(configsForRestart);
+        } else if (!mKeepAliveFlag.getAndSet(true)) {
+            mSessionListener.onSessionClosed(reason);
+        }
+    }
+
+    private class OobConnectionListener implements FutureCallback<byte[]> {
+        @Override
+        public void onSuccess(byte[] data) {
+            OobHeader header = OobHeader.parseBytes(data);
+            (switch (header.getMessageType()) {
+                case CAPABILITY_REQUEST ->
+                        sendCapabilityResponse(data)
+                                .transformAsync(unused ->
+                                        mOobConnection.receiveData(), mOobExecutor);
+                case SET_CONFIGURATION -> {
+                    handleSetConfig(data);
+                    yield mOobConnection.receiveData();
+                }
+                case STOP_RANGING -> {
+                    handleStopRanging(data);
+                    yield mOobConnection.receiveData();
+                }
+                default -> {
+                    Log.e(TAG, "Received unexpected OOB message with type "
+                            + header.getMessageType());
+                    yield mOobConnection.receiveData();
+                }
+            }).addCallback(mOobConnectionListener, mOobExecutor);
+        }
+
+        @Override
+        public void onFailure(Throwable t) {
+            switch (t) {
+                case ConnectionClosedException e
+                    when e.getReason() == ConnectionClosedException.Reason.REQUESTED ->
+                        Log.i(TAG, "No longer listening for OOB messages- OOB connection closed by"
+                                + " local request");
+                case ConnectionClosedException e -> {
+                    Log.w(TAG, "Stopping session due to unexpected OOB connection closure with "
+                            + "reason " + e.getReason());
+                    stopSessionForReason(InternalReason.NO_PEERS_FOUND);
+                }
+                default -> {
+                    Log.e(TAG, "Stopping session due to OOB connection failure " + t);
+                    stopSessionForReason(InternalReason.INTERNAL_ERROR);
+                }
+            }
+        }
+    }
+
+    private FluentFuture<Void> sendCapabilityResponse(byte[] data) {
+        Log.i(TAG, "Received capabilities request message");
+
+        CapabilityResponseMessage response =
+                getCapabilityResponseForRequest(CapabilityRequestMessage.parseBytes(data));
+
+        return mOobConnection.sendData(response.toBytes());
+    }
+
+    private void handleSetConfig(byte[] data) {
+        Log.i(TAG, "Received set configuration message");
+
+        ImmutableSet.Builder<TechnologyConfig> configs = ImmutableSet.builder();
+        SetConfigurationMessage setConfigMessage = SetConfigurationMessage.parseBytes(data);
+
+        Log.v(TAG, "Configured ranging for technologies "
+                + setConfigMessage.getRangingTechnologiesSet());
+        UwbOobConfig uwbConfig = setConfigMessage.getUwbConfig();
+        if (uwbConfig != null) {
+            try {
+                configs.add(uwbConfig.toTechnologyConfig(mMyUwbAddress, mPeer.getRangingDevice()));
+            } catch (IllegalArgumentException e) {
+                Log.e(TAG, "Failed to convert uwb set config message to local uwb config");
+            }
+        }
+        // Skip CS because the CS responder side does not need to be configured.
+        RttOobConfig rttOobConfig = setConfigMessage.getRttConfig();
+        if (rttOobConfig != null) {
+            configs.add(rttOobConfig.toTechnologyConfig(
+                    mPeer.getRangingDevice(), DEVICE_ROLE_RESPONDER));
+        }
+
+        // TODO: Only start for technologies who have the start ranging immediately
+        //  bit set. Otherwise we need to wait for the start ranging message
+
+        ImmutableSet<TechnologyConfig> technologyConfigs = configs.build();
+        boolean sessionAlreadyActive = !super.startOrReAttach(technologyConfigs);
+        if (sessionAlreadyActive) {
+            Log.w(TAG, "Session already exists with active ranging. Restarting it with newly "
+                    + "provided config...");
+            mRestartingWithConfigs.set(technologyConfigs);
+            super.stop(InternalReason.SYSTEM_POLICY);
+        }
+    }
+
+    private void handleStopRanging(byte[] data) {
+        StopRangingMessage message = StopRangingMessage.parseBytes(data);
+        OobResponderRangingSession.super
+                .stopTechnologies(
+                        Set.copyOf(message.getRangingTechnologiesToStop()),
+                        InternalReason.REMOTE_REQUEST);
+    }
+
+    private CapabilityResponseMessage getCapabilityResponseForRequest(
+            CapabilityRequestMessage request) {
+
+        RangingCapabilities myCapabilities = mInjector
+                .getCapabilitiesProvider()
+                .getCapabilities();
+
+        CapabilityResponseMessage.Builder response = CapabilityResponseMessage.builder()
+                .setHeader(OobHeader.builder()
+                        .setMessageType(MessageType.CAPABILITY_RESPONSE)
+                        .setVersion(OobHeader.OobVersion.CURRENT)
+                        .build());
+
+        ImmutableList.Builder<RangingTechnology> supportedTechnologies = ImmutableList.builder();
+
+        if (request.getRequestedRangingTechnologies().contains(RangingTechnology.UWB)) {
+            UwbRangingCapabilities uwbCapabilities = myCapabilities.getUwbCapabilities();
+            if (uwbCapabilities != null) {
+                supportedTechnologies.add(RangingTechnology.UWB);
+                response.setUwbCapabilities(
+                        UwbOobCapabilities.fromRangingCapabilities(uwbCapabilities, mMyUwbAddress));
+            }
+        }
+        if (request.getRequestedRangingTechnologies().contains(RangingTechnology.CS)) {
+            BleCsRangingCapabilities csCapabilities = myCapabilities.getCsCapabilities();
+            if (csCapabilities != null) {
+                supportedTechnologies.add(RangingTechnology.CS);
+                response.setCsCapabilities(
+                        CsOobCapabilities.fromRangingCapabilities(csCapabilities));
+            }
+        }
+        if (request.getRequestedRangingTechnologies().contains(RangingTechnology.RTT)) {
+            RttRangingCapabilities rttRangingCapabilities =
+                    myCapabilities.getRttRangingCapabilities();
+            if (rttRangingCapabilities != null) {
+                supportedTechnologies.add(RangingTechnology.RTT);
+                response.setRttCapabilities(
+                        RttOobCapabilities.fromRangingCapabilities(rttRangingCapabilities));
+            }
+        }
+        if (request.getRequestedRangingTechnologies().contains(RangingTechnology.RSSI)) {
+            BleRssiRangingCapabilities bleRssiCapabilities =
+                    myCapabilities.getBleRssiCapabilities();
+            if (bleRssiCapabilities != null) {
+                supportedTechnologies.add(RangingTechnology.RSSI);
+                response.setBleRssiCapabilities(
+                        BleRssiOobCapabilities.fromRangingCapabilities(bleRssiCapabilities));
+            }
+        }
+
+        return response
+                .setRangingTechnologiesPriority(supportedTechnologies.build())
+                .setSupportedRangingTechnologies(supportedTechnologies.build())
+                .build();
     }
 
     @Override
-    public void handleOobClosed(OobHandle oobHandle) {
-        // TODO
-        throw new UnsupportedOperationException("Not implemented");
+    public void close() {
+        mOobConnection.close();
+    }
+
+    private void stopSessionForReason(@InternalReason int reason) {
+        mKeepAliveFlag.set(false);
+        boolean existsAdaptersWithActiveRanging = super.stop(reason);
+        // We want to trigger onSessionClosed even if there are no active adapters to close.
+        if (!existsAdaptersWithActiveRanging) onSessionClosed(reason);
     }
 }
diff --git a/ranging/service/java/com/android/server/ranging/session/RangingSession.java b/ranging/service/java/com/android/server/ranging/session/RangingSession.java
index b956588a..052c620a 100644
--- a/ranging/service/java/com/android/server/ranging/session/RangingSession.java
+++ b/ranging/service/java/com/android/server/ranging/session/RangingSession.java
@@ -16,24 +16,30 @@
 
 package com.android.server.ranging.session;
 
+import android.ranging.RangingConfig;
 import android.ranging.RangingDevice;
-import android.ranging.RangingParams;
+import android.ranging.raw.RawResponderRangingConfig;
 
 import androidx.annotation.NonNull;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 
-public interface RangingSession<P extends RangingParams> {
-    void start(@NonNull P params);
+public interface RangingSession extends AutoCloseable {
+    void start(@NonNull RangingConfig params);
 
     void stop();
 
-    void addPeer(RangingDevice params);
+    void addPeer(RawResponderRangingConfig params);
 
     void removePeer(RangingDevice params);
 
     void reconfigureInterval(int intervalSkipCount);
 
+    void appForegroundStateUpdated(boolean appInForeground);
+
+    @Override
+    void close();
+
     void dump(FileDescriptor fd, PrintWriter pw, String[] args);
 }
diff --git a/ranging/service/java/com/android/server/ranging/session/RangingSessionConfig.java b/ranging/service/java/com/android/server/ranging/session/RangingSessionConfig.java
index af24af82..8d6f9d11 100644
--- a/ranging/service/java/com/android/server/ranging/session/RangingSessionConfig.java
+++ b/ranging/service/java/com/android/server/ranging/session/RangingSessionConfig.java
@@ -16,11 +16,13 @@
 
 package com.android.server.ranging.session;
 
-import android.ranging.DataNotificationConfig;
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+
+import android.ranging.RangingConfig;
 import android.ranging.RangingDevice;
 import android.ranging.RangingManager;
 import android.ranging.RangingPreference;
-import android.ranging.SensorFusionParams;
+import android.ranging.SessionConfig;
 import android.ranging.raw.RawRangingDevice;
 import android.ranging.uwb.UwbAddress;
 import android.ranging.uwb.UwbRangingParams;
@@ -48,18 +50,21 @@ import java.util.Set;
 
 public class RangingSessionConfig {
     private final @RangingPreference.DeviceRole int mDeviceRole;
-    private final SensorFusionParams mFusionConfig;
-    private final boolean mIsAoaNeeded;
-    private final DataNotificationConfig mDataNotificationConfig;
+    private final @RangingConfig.RangingSessionType int mSessionType;
+    private final SessionConfig mSessionConfig;
 
     /** A complete configuration for a session within a specific ranging technology's stack */
     public interface TechnologyConfig {
-        @NonNull RangingTechnology getTechnology();
+        @NonNull
+        RangingTechnology getTechnology();
+
+        @RangingPreference.DeviceRole int getDeviceRole();
     }
 
     /** A config for a technology that only supports 1 peer per session. */
     public interface UnicastTechnologyConfig extends TechnologyConfig {
-        @NonNull RangingDevice getPeerDevice();
+        @NonNull
+        RangingDevice getPeerDevice();
     }
 
     /** A config for a technology that supports multiple peers per session. */
@@ -67,14 +72,14 @@ public class RangingSessionConfig {
         /**
          * @return the set of peers within this technology-specific session.
          */
-        @NonNull ImmutableSet<RangingDevice> getPeerDevices();
+        @NonNull
+        ImmutableSet<RangingDevice> getPeerDevices();
     }
 
     private RangingSessionConfig(Builder builder) {
         mDeviceRole = builder.mDeviceRole;
-        mFusionConfig = builder.mFusionConfig;
-        mIsAoaNeeded = builder.mIsAoaNeeded;
-        mDataNotificationConfig = builder.mDataNotificationConfig;
+        mSessionType = builder.mSessionType;
+        mSessionConfig = builder.mSessionConfig;
     }
 
     public @NonNull ImmutableSet<TechnologyConfig> getTechnologyConfigs(
@@ -99,10 +104,7 @@ public class RangingSessionConfig {
             configs.add(new UwbConfig.Builder(key.mParams)
                     .setDeviceRole(mDeviceRole)
                     .setPeerAddresses(ImmutableBiMap.copyOf(uwbPeersByParams.get(key)))
-                    .setAoaNeeded(mIsAoaNeeded)
-                    // TODO(370077264): Set country code based on geolocation.
-                    .setCountryCode("US")
-                    .setDataNotificationConfig(mDataNotificationConfig)
+                    .setSessionConfig(mSessionConfig)
                     .build());
         }
 
@@ -119,21 +121,21 @@ public class RangingSessionConfig {
                 configs.add(new RttConfig(
                         mDeviceRole,
                         peer.getRttRangingParams(),
-                        mDataNotificationConfig,
+                        mSessionConfig,
                         peer.getRangingDevice()));
             }
             if (peer.getBleRssiRangingParams() != null) {
                 configs.add(new BleRssiConfig(
                         mDeviceRole,
                         peer.getBleRssiRangingParams(),
-                        mDataNotificationConfig,
+                        mSessionConfig,
                         peer.getRangingDevice()));
             }
-            if (peer.getCsRangingParams() != null) {
+            // Only CS initiator needs to be configured.
+            if (peer.getCsRangingParams() != null && mDeviceRole == DEVICE_ROLE_INITIATOR) {
                 configs.add(new CsConfig(
-                        mDeviceRole,
                         peer.getCsRangingParams(),
-                        mDataNotificationConfig,
+                        mSessionConfig,
                         peer.getRangingDevice()));
             }
         }
@@ -145,23 +147,18 @@ public class RangingSessionConfig {
         return mDeviceRole;
     }
 
-    public @NonNull SensorFusionParams getSensorFusionConfig() {
-        return mFusionConfig;
-    }
-
-    public boolean isAoaNeeded() {
-        return mIsAoaNeeded;
+    public @RangingConfig.RangingSessionType int getSessionType() {
+        return mSessionType;
     }
 
-    public @NonNull DataNotificationConfig getDataNotificationConfig() {
-        return mDataNotificationConfig;
+    public SessionConfig getSessionConfig() {
+        return mSessionConfig;
     }
 
     public static class Builder {
         private @RangingPreference.DeviceRole int mDeviceRole;
-        private SensorFusionParams mFusionConfig;
-        private boolean mIsAoaNeeded;
-        private DataNotificationConfig mDataNotificationConfig;
+        private @RangingConfig.RangingSessionType int mSessionType;
+        private SessionConfig mSessionConfig;
 
         public RangingSessionConfig build() {
             return new RangingSessionConfig(this);
@@ -172,18 +169,13 @@ public class RangingSessionConfig {
             return this;
         }
 
-        public Builder setSensorFusionConfig(@NonNull SensorFusionParams config) {
-            mFusionConfig = config;
+        public Builder setSessionType(@RangingConfig.RangingSessionType int type) {
+            mSessionType = type;
             return this;
         }
 
-        public Builder setDataNotificationConfig(@NonNull DataNotificationConfig config) {
-            mDataNotificationConfig = config;
-            return this;
-        }
-
-        public Builder setAoaNeeded(boolean isAoaNeeded) {
-            mIsAoaNeeded = isAoaNeeded;
+        public Builder setSessionConfig(@NonNull SessionConfig config) {
+            mSessionConfig = config;
             return this;
         }
     }
@@ -195,8 +187,8 @@ public class RangingSessionConfig {
          * Group together UWB peer devices that share the same params so that they can be put into a
          * a multicast session.
          */
-        public static
-        Map<PeerIgnoringParamsHasher<UwbRangingParams>, BiMap<RangingDevice, UwbAddress>>
+        public static Map<PeerIgnoringParamsHasher<UwbRangingParams>, BiMap<RangingDevice,
+                UwbAddress>>
         groupUwbPeersByParams(@NonNull Set<RawRangingDevice> peerParams) {
             Map<PeerIgnoringParamsHasher<UwbRangingParams>, BiMap<RangingDevice, UwbAddress>>
                     peersByParams = new HashMap<>();
@@ -267,11 +259,11 @@ public class RangingSessionConfig {
 
     @Override
     public String toString() {
-        return "RangingSessionConfig{" +
-                "mDeviceRole=" + mDeviceRole +
-                ", mFusionConfig=" + mFusionConfig +
-                ", mIsAoaNeeded=" + mIsAoaNeeded +
-                ", mDataNotificationConfig=" + mDataNotificationConfig +
-                '}';
+        return "RangingSessionConfig{"
+                + "mDeviceRole="
+                + mDeviceRole
+                + ", mSessionConfig="
+                + mSessionConfig
+                + '}';
     }
 }
diff --git a/ranging/service/java/com/android/server/ranging/session/RawInitiatorRangingSession.java b/ranging/service/java/com/android/server/ranging/session/RawInitiatorRangingSession.java
index d3b4345d..e1cfc1e7 100644
--- a/ranging/service/java/com/android/server/ranging/session/RawInitiatorRangingSession.java
+++ b/ranging/service/java/com/android/server/ranging/session/RawInitiatorRangingSession.java
@@ -17,21 +17,23 @@
 package com.android.server.ranging.session;
 
 import android.content.AttributionSource;
+import android.ranging.RangingConfig;
 import android.ranging.SessionHandle;
-import android.ranging.raw.RawInitiatorRangingParams;
+import android.ranging.raw.RawInitiatorRangingConfig;
+import android.util.Log;
 
 import androidx.annotation.NonNull;
 
 import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingServiceManager;
+import com.android.server.ranging.RangingUtils;
 
 import com.google.common.util.concurrent.ListeningExecutorService;
 
 import java.util.Set;
 
-public class RawInitiatorRangingSession
-        extends BaseRangingSession
-        implements RangingSession<RawInitiatorRangingParams> {
+public class RawInitiatorRangingSession extends BaseRangingSession implements RangingSession {
+    private static final String TAG = RawInitiatorRangingSession.class.getSimpleName();
 
     public RawInitiatorRangingSession(
             @NonNull AttributionSource attributionSource,
@@ -45,7 +47,22 @@ public class RawInitiatorRangingSession
     }
 
     @Override
-    public void start(@NonNull RawInitiatorRangingParams params) {
-        super.start(mConfig.getTechnologyConfigs(Set.copyOf(params.getRawRangingDevices())));
+    public void start(@NonNull RangingConfig rangingConfig) {
+        if (!(rangingConfig instanceof RawInitiatorRangingConfig config)) {
+            Log.e(TAG, "Unexpected configuration object for raw initiator session "
+                    + rangingConfig.getClass());
+            mSessionListener.onSessionClosed(RangingUtils.InternalReason.INTERNAL_ERROR);
+            return;
+        }
+
+        super.start(mSessionConfig.getTechnologyConfigs(Set.copyOf(config.getRawRangingDevices())));
+    }
+
+    @Override
+    public void appForegroundStateUpdated(boolean appInForeground) {
+        super.appForegroundStateUpdated(appInForeground);
     }
+
+    @Override
+    public void close() { }
 }
diff --git a/ranging/service/java/com/android/server/ranging/session/RawResponderRangingSession.java b/ranging/service/java/com/android/server/ranging/session/RawResponderRangingSession.java
index 74ade6da..a3e46e29 100644
--- a/ranging/service/java/com/android/server/ranging/session/RawResponderRangingSession.java
+++ b/ranging/service/java/com/android/server/ranging/session/RawResponderRangingSession.java
@@ -17,21 +17,23 @@
 package com.android.server.ranging.session;
 
 import android.content.AttributionSource;
+import android.ranging.RangingConfig;
 import android.ranging.SessionHandle;
-import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.raw.RawResponderRangingConfig;
+import android.util.Log;
 
 import androidx.annotation.NonNull;
 
 import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingServiceManager;
+import com.android.server.ranging.RangingUtils;
 
 import com.google.common.util.concurrent.ListeningExecutorService;
 
 import java.util.Set;
 
-public class RawResponderRangingSession
-        extends BaseRangingSession
-        implements RangingSession<RawResponderRangingParams> {
+public class RawResponderRangingSession extends BaseRangingSession implements RangingSession {
+    private static final String TAG = RawResponderRangingSession.class.getSimpleName();
 
     public RawResponderRangingSession(
             @NonNull AttributionSource attributionSource,
@@ -45,7 +47,22 @@ public class RawResponderRangingSession
     }
 
     @Override
-    public void start(@NonNull RawResponderRangingParams params) {
-        super.start(mConfig.getTechnologyConfigs(Set.of(params.getRawRangingDevice())));
+    public void start(@NonNull RangingConfig rangingConfig) {
+        if (!(rangingConfig instanceof RawResponderRangingConfig config)) {
+            Log.e(TAG, "Unexpected configuration object for raw responder session "
+                    + rangingConfig.getClass());
+            mSessionListener.onSessionClosed(RangingUtils.InternalReason.INTERNAL_ERROR);
+            return;
+        }
+
+        super.start(mSessionConfig.getTechnologyConfigs(Set.of(config.getRawRangingDevice())));
+    }
+
+    @Override
+    public void appForegroundStateUpdated(boolean appInForeground) {
+        super.appForegroundStateUpdated(appInForeground);
     }
+
+    @Override
+    public void close() { }
 }
diff --git a/ranging/service/java/com/android/server/ranging/util/DataNotificationManager.java b/ranging/service/java/com/android/server/ranging/util/DataNotificationManager.java
new file mode 100644
index 00000000..fa39fde1
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/util/DataNotificationManager.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.util;
+
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_DISABLE;
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_ENABLE;
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_PROXIMITY_EDGE;
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_PROXIMITY_LEVEL;
+
+import android.ranging.DataNotificationConfig;
+
+public class DataNotificationManager {
+
+    private final DataNotificationConfig mInitialConfig;
+
+    private DataNotificationConfig mCurrentConfig;
+
+    private boolean mCheckProximityEdgeFlag = true;
+
+    public DataNotificationManager(DataNotificationConfig initialConfig,
+            DataNotificationConfig currentConfig) {
+        mInitialConfig = initialConfig;
+        mCurrentConfig = currentConfig;
+    }
+
+    public DataNotificationConfig getInitialConfig() {
+        return mInitialConfig;
+    }
+
+    public DataNotificationConfig getCurrentConfig() {
+        return mCurrentConfig;
+    }
+
+    public void updateConfigAppMovedToBackground() {
+        mCurrentConfig = new DataNotificationConfig.Builder()
+                .setNotificationConfigType(NOTIFICATION_CONFIG_DISABLE)
+                .build();
+        mCheckProximityEdgeFlag = true;
+    }
+
+    public void updateConfigAppMovedToForeground() {
+        mCurrentConfig = mInitialConfig;
+        mCheckProximityEdgeFlag = true;
+    }
+
+    public boolean shouldSendResult(double distanceMeters) {
+        switch (mCurrentConfig.getNotificationConfigType()) {
+            case NOTIFICATION_CONFIG_ENABLE -> {
+                return true;
+            }
+            case NOTIFICATION_CONFIG_PROXIMITY_LEVEL -> {
+                if (distanceMeters <= ((double) mCurrentConfig.getProximityFarCm() / 100)
+                        && distanceMeters >= ((double) mCurrentConfig.getProximityNearCm() / 100)) {
+                    return true;
+                }
+            }
+            case NOTIFICATION_CONFIG_PROXIMITY_EDGE -> {
+                return shouldSendProximityEdgeResult(distanceMeters);
+            }
+        }
+        return false;
+    }
+
+    private boolean shouldSendProximityEdgeResult(double distanceMeters) {
+        int nearMeters = mCurrentConfig.getProximityNearCm() / 100;
+        int farMeters = mCurrentConfig.getProximityFarCm() / 100;
+
+        // Notification for crossing above `far` or below `near`
+        if (!mCheckProximityEdgeFlag && (distanceMeters <= nearMeters
+                || distanceMeters >= farMeters)) {
+            mCheckProximityEdgeFlag = true;
+            return true;
+        }
+
+        // Notification for crossing back below `far` or back above `near`
+        if (mCheckProximityEdgeFlag && (distanceMeters > nearMeters
+                && distanceMeters < farMeters)) {
+            mCheckProximityEdgeFlag = false;
+            return true;
+        }
+        return false;
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbAdapter.java b/ranging/service/java/com/android/server/ranging/uwb/UwbAdapter.java
index d93270cb..71170c96 100644
--- a/ranging/service/java/com/android/server/ranging/uwb/UwbAdapter.java
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbAdapter.java
@@ -20,13 +20,18 @@ import static com.android.ranging.uwb.backend.internal.RangingMeasurement.CONFID
 import static com.android.ranging.uwb.backend.internal.RangingMeasurement.CONFIDENCE_MEDIUM;
 import static com.android.server.ranging.uwb.UwbConfig.toBackend;
 
+import android.content.AttributionSource;
 import android.content.Context;
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingCapabilities;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
 import android.ranging.RangingMeasurement;
 import android.ranging.RangingPreference;
+import android.ranging.raw.RawResponderRangingConfig;
 import android.ranging.uwb.UwbAddress;
 import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingCapabilities;
 import android.util.Log;
 
 import androidx.annotation.NonNull;
@@ -37,72 +42,94 @@ import com.android.ranging.uwb.backend.internal.RangingPosition;
 import com.android.ranging.uwb.backend.internal.RangingSessionCallback;
 import com.android.ranging.uwb.backend.internal.Utils;
 import com.android.ranging.uwb.backend.internal.UwbDevice;
+import com.android.ranging.uwb.backend.internal.UwbHwSwitchHelper;
 import com.android.ranging.uwb.backend.internal.UwbServiceImpl;
+import com.android.server.ranging.CapabilitiesProvider;
 import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils;
+import com.android.server.ranging.RangingUtils.InternalReason;
 import com.android.server.ranging.RangingUtils.StateMachine;
 import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.util.DataNotificationManager;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.BiMap;
 import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.common.util.concurrent.FutureCallback;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListeningExecutorService;
 
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
+import java.util.Optional;
 
 /** Ranging adapter for Ultra-wideband (UWB). */
 public class UwbAdapter implements RangingAdapter {
     private static final String TAG = UwbAdapter.class.getSimpleName();
-
+    private final Context mContext;
+    private final RangingInjector mRangingInjector;
     private final com.android.ranging.uwb.backend.internal.RangingDevice mUwbClient;
     private final ListeningExecutorService mExecutorService;
-    private final ExecutorService mBackendExecutor;
     private final ExecutorResultHandlers mUwbClientResultHandlers = new ExecutorResultHandlers();
     private final RangingSessionCallback mUwbListener = new UwbListener();
     private final StateMachine<State> mStateMachine;
     private final BiMap<RangingDevice, UwbAddress> mPeers;
 
+    private DataNotificationManager mDataNotificationManager;
+
     /** Invariant: non-null while a ranging session is active */
     private Callback mCallbacks;
 
+    private AttributionSource mNonPrivilegedAttributionSource;
+    boolean mIsBackgroundRangingSupported;
+
+    private final AttributionSource mAttributionSource;
+
     public UwbAdapter(
-            @NonNull Context context, @NonNull ListeningExecutorService executor,
+            @NonNull Context context,
+            RangingInjector injector,
+            AttributionSource attributionSource,
+            @NonNull ListeningExecutorService executor,
             @RangingPreference.DeviceRole int role
     ) {
-        this(context, executor, Executors.newSingleThreadExecutor(), role);
-    }
-
-    /** Intermediary constructor used to make an additional reference to backendExecutor. */
-    private UwbAdapter(
-            @NonNull Context context, @NonNull ListeningExecutorService executor,
-            @NonNull ExecutorService backendExecutor, @RangingPreference.DeviceRole int role
-    ) {
-        this(context, executor, backendExecutor,
+        this(context, injector, attributionSource, executor,
                 role == RangingPreference.DEVICE_ROLE_INITIATOR
-                        ? UwbServiceImpl.getController(context, backendExecutor)
-                        : UwbServiceImpl.getControlee(context, backendExecutor));
+                        ? UwbServiceImpl.getController(context, executor)
+                        : UwbServiceImpl.getControlee(context, executor));
     }
 
     /** Injectable constructor for testing. */
     @VisibleForTesting
     public UwbAdapter(
-            @NonNull Context context, @NonNull ListeningExecutorService executor,
-            @NonNull ExecutorService backendExecutor,
+            @NonNull Context context,
+            RangingInjector injector,
+            AttributionSource attributionSource,
+            @NonNull ListeningExecutorService executor,
             @NonNull com.android.ranging.uwb.backend.internal.RangingDevice uwbClient
     ) {
         if (!RangingTechnology.UWB.isSupported(context)) {
             throw new IllegalArgumentException("UWB system feature not found.");
         }
-
+        mContext = context;
+        mRangingInjector = injector;
         mStateMachine = new StateMachine<>(State.STOPPED);
         mUwbClient = uwbClient;
         mExecutorService = executor;
-        mBackendExecutor = backendExecutor;
         mCallbacks = null;
-        mPeers = HashBiMap.create();
+        mPeers = Maps.synchronizedBiMap(HashBiMap.create());
+        mDataNotificationManager = new DataNotificationManager(
+                new DataNotificationConfig.Builder().build(),
+                new DataNotificationConfig.Builder().build()
+        );
+        mIsBackgroundRangingSupported = Optional.ofNullable(mRangingInjector)
+                .map(RangingInjector::getCapabilitiesProvider)
+                .map(CapabilitiesProvider::getCapabilities)
+                .map(RangingCapabilities::getUwbCapabilities)
+                .map(UwbRangingCapabilities::isBackgroundRangingSupported)
+                .orElse(true); // Defaults to true;
+        mAttributionSource = attributionSource;
     }
 
     @Override
@@ -112,34 +139,132 @@ public class UwbAdapter implements RangingAdapter {
 
     @Override
     public void start(
-            @NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callbacks
+            @NonNull RangingSessionConfig.TechnologyConfig config,
+            @android.annotation.Nullable AttributionSource nonPrivilegedAttributionSource,
+            @NonNull Callback callbacks
     ) {
         Log.i(TAG, "Start called.");
-        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
-            Log.v(TAG, "Attempted to start adapter when it was already started");
-            return;
-        }
-
         mCallbacks = callbacks;
+        mNonPrivilegedAttributionSource = nonPrivilegedAttributionSource;
         if (!(config instanceof UwbConfig uwbConfig)) {
             Log.w(TAG, "Tried to start adapter with invalid ranging parameters");
-            closeForReason(Callback.ClosedReason.FAILED_TO_START);
+            closeForReason(InternalReason.INTERNAL_ERROR);
             return;
         }
+        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
+            Log.v(TAG, "Attempted to start adapter when it was already started");
+            closeForReason(InternalReason.INTERNAL_ERROR);
+            return;
+        }
+        mDataNotificationManager = new DataNotificationManager(
+                uwbConfig.getSessionConfig().getDataNotificationConfig(),
+                uwbConfig.getSessionConfig().getDataNotificationConfig());
+        if (mNonPrivilegedAttributionSource != null && !mRangingInjector.isForegroundAppOrService(
+                mNonPrivilegedAttributionSource.getUid(),
+                mNonPrivilegedAttributionSource.getPackageName())) {
+            if (!mIsBackgroundRangingSupported) {
+                Log.w(TAG, "Background ranging is not supported");
+                closeForReason(InternalReason.BACKGROUND_RANGING_POLICY);
+                return;
+            }
+            mDataNotificationManager.updateConfigAppMovedToBackground();
+        }
+
         mPeers.putAll(uwbConfig.getPeerAddresses());
-        mUwbClient.setRangingParameters(uwbConfig.asBackendParameters());
+        mUwbClient.setRangingParameters(
+                uwbConfig.asBackendParameters(mDataNotificationManager.getCurrentConfig()));
         mUwbClient.setLocalAddress(toBackend(uwbConfig.getParameters().getDeviceAddress()));
         if (mUwbClient instanceof RangingController controller) {
             controller.setComplexChannel(
                     toBackend(uwbConfig.getParameters().getComplexChannel()));
         }
-
-        var future = Futures.submit(() -> {
-            mUwbClient.startRanging(mUwbListener, mBackendExecutor);
-        }, mExecutorService);
+        if (mUwbClient.isHwTurnOffEnabled()) {
+            if (!UwbHwSwitchHelper.enable(mContext, mAttributionSource)) {
+                Log.e(TAG, "Failed enabling UWB Hardware");
+                closeForReason(InternalReason.UNSUPPORTED);
+                return;
+            }
+        }
+        var future = Futures.submit(() -> mUwbClient.startRanging(mUwbListener), mExecutorService);
         Futures.addCallback(future, mUwbClientResultHandlers.startRanging, mExecutorService);
     }
 
+    @Override
+    public boolean isDynamicUpdatePeersSupported() {
+        return true;
+    }
+
+    @Override
+    public void addPeer(RawResponderRangingConfig params) {
+        Log.i(TAG, "Add peer called");
+        if (mUwbClient instanceof RangingController) {
+            UwbAddress uwbAddress =
+                    params.getRawRangingDevice().getUwbRangingParams().getPeerAddress();
+            com.android.ranging.uwb.backend.internal.UwbAddress uwbBackendAddress =
+                    com.android.ranging.uwb.backend.internal.UwbAddress.fromBytes(
+                            uwbAddress.getAddressBytes());
+            mPeers.put(params.getRawRangingDevice().getRangingDevice(), uwbAddress);
+            var unused = Futures.submit(
+                    () -> ((RangingController) mUwbClient).addControlee(uwbBackendAddress),
+                    mExecutorService);
+        }
+    }
+
+    @Override
+    public void removePeer(RangingDevice device) {
+        Log.i(TAG, "Remove peer called");
+        if (mUwbClient instanceof RangingController) {
+            synchronized (mPeers) {
+                if (mPeers.containsKey(device)) {
+                    com.android.ranging.uwb.backend.internal.UwbAddress uwbBackendAddress =
+                            com.android.ranging.uwb.backend.internal.UwbAddress.fromBytes(
+                                    mPeers.get(device).getAddressBytes());
+                    var unused = Futures.submit(
+                            () -> ((RangingController) mUwbClient)
+                                    .removeControlee(uwbBackendAddress),
+                            mExecutorService);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void reconfigureRangingInterval(int intervalSkipCount) {
+        Log.i(TAG, "Reconfigure ranging interval called");
+        if (mUwbClient instanceof RangingController) {
+            ((RangingController) mUwbClient).setBlockStriding(intervalSkipCount);
+        }
+    }
+
+    @Override
+    public void appMovedToBackground() {
+        if (mNonPrivilegedAttributionSource != null && mDataNotificationManager != null) {
+            mDataNotificationManager.updateConfigAppMovedToBackground();
+            var unused = Futures.submit(
+                    () -> mUwbClient.reconfigureRangeDataNtfConfig(
+                            UwbConfig.toBackend(mDataNotificationManager.getCurrentConfig())),
+                    mExecutorService);
+        }
+    }
+
+    @Override
+    public void appMovedToForeground() {
+        if (mNonPrivilegedAttributionSource != null && mDataNotificationManager != null) {
+            mDataNotificationManager.updateConfigAppMovedToForeground();
+            var unused = Futures.submit(
+                    () -> mUwbClient.reconfigureRangeDataNtfConfig(
+                            UwbConfig.toBackend(mDataNotificationManager.getCurrentConfig())),
+                    mExecutorService);
+        }
+    }
+
+    @Override
+    public void appInBackgroundTimeout() {
+        if (mNonPrivilegedAttributionSource != null && !mIsBackgroundRangingSupported) {
+            stop();
+        }
+    }
+
     @Override
     public void stop() {
         Log.i(TAG, "Stop called.");
@@ -147,7 +272,6 @@ public class UwbAdapter implements RangingAdapter {
             Log.v(TAG, "Attempted to stop adapter when it was already stopped");
             return;
         }
-
         var future = Futures.submit(mUwbClient::stopRanging, mExecutorService);
         Futures.addCallback(future, mUwbClientResultHandlers.stopRanging, mExecutorService);
     }
@@ -170,8 +294,8 @@ public class UwbAdapter implements RangingAdapter {
         public void onRangingInitialized(UwbDevice localDevice) {
             Log.i(TAG, "onRangingInitialized");
             synchronized (mStateMachine) {
-                if (mStateMachine.getState() == State.STARTED) {
-                    mPeers.keySet().forEach(mCallbacks::onStarted);
+                if (mStateMachine.getState() == State.STARTED && !mPeers.isEmpty()) {
+                    mCallbacks.onStarted(ImmutableSet.copyOf(mPeers.keySet()));
                 }
             }
         }
@@ -181,7 +305,8 @@ public class UwbAdapter implements RangingAdapter {
             RangingData.Builder dataBuilder = new RangingData.Builder()
                     .setRangingTechnology((int) RangingTechnology.UWB.getValue())
                     .setDistance(convertMeasurement(position.getDistance()))
-                    .setTimestampMillis(position.getElapsedRealtimeNanos());
+                    .setTimestampMillis(RangingUtils.convertNanosToMillis(
+                            position.getElapsedRealtimeNanos()));
 
             if (position.getAzimuth() != null) {
                 dataBuilder.setAzimuth(convertMeasurement(position.getAzimuth()));
@@ -206,7 +331,10 @@ public class UwbAdapter implements RangingAdapter {
         @Override
         public void onRangingSuspended(UwbDevice localDevice, @RangingSuspendedReason int reason) {
             Log.i(TAG, "onRangingSuspended: " + reason);
-            closeForReason(convertReason(reason));
+            if (mUwbClient.isHwTurnOffEnabled()) {
+                UwbHwSwitchHelper.disable(mContext, mAttributionSource);
+            }
+            closeForReason(convertClosedReason(reason));
         }
 
         @Override
@@ -217,29 +345,47 @@ public class UwbAdapter implements RangingAdapter {
                 RangingDevice device = convertPeerDevice(peer);
                 if (device != null) {
                     mPeers.remove(device);
-                    mCallbacks.onStopped(device);
+                    mCallbacks.onStopped(
+                            ImmutableSet.of(device), convertDisconnectedReason(reason));
                 }
             }
         }
 
-        private static @Callback.ClosedReason int convertReason(
-                @RangingSessionCallback.RangingSuspendedReason int reason) {
-            switch (reason) {
-                case REASON_WRONG_PARAMETERS:
-                case REASON_FAILED_TO_START:
-                    return Callback.ClosedReason.FAILED_TO_START;
-                case REASON_STOPPED_BY_PEER:
-                case REASON_STOP_RANGING_CALLED:
-                    return Callback.ClosedReason.REQUESTED;
-                case REASON_MAX_RANGING_ROUND_RETRY_REACHED:
-                    return Callback.ClosedReason.LOST_CONNECTION;
-                case REASON_SYSTEM_POLICY:
-                    return Callback.ClosedReason.SYSTEM_POLICY;
-                default:
-                    return Callback.ClosedReason.UNKNOWN;
+        @Override
+        public void onPeerConnected(UwbDevice peer) {
+            RangingDevice device = convertPeerDevice(peer);
+            if (device != null) {
+                mCallbacks.onStarted(ImmutableSet.of(device));
             }
         }
 
+
+        private static @InternalReason int convertDisconnectedReason(
+                @PeerDisconnectedReason int reason
+        ) {
+            return switch (reason) {
+                case PeerDisconnectedReason.UNKNOWN -> InternalReason.UNKNOWN;
+                case PeerDisconnectedReason.LOCAL_DEVICE_REQUEST -> InternalReason.LOCAL_REQUEST;
+                case PeerDisconnectedReason.SYSTEM_POLICY -> InternalReason.SYSTEM_POLICY;
+                case PeerDisconnectedReason.FAILED_TO_ADD_CONTROLEE ->
+                        InternalReason.NO_PEERS_FOUND;
+                default -> InternalReason.UNKNOWN;
+            };
+        }
+
+        private static @InternalReason int convertClosedReason(
+                @RangingSessionCallback.RangingSuspendedReason int reason) {
+            return switch (reason) {
+                case REASON_UNKNOWN -> InternalReason.UNKNOWN;
+                case REASON_WRONG_PARAMETERS, REASON_FAILED_TO_START -> InternalReason.UNSUPPORTED;
+                case REASON_STOPPED_BY_PEER -> InternalReason.REMOTE_REQUEST;
+                case REASON_STOP_RANGING_CALLED -> InternalReason.LOCAL_REQUEST;
+                case REASON_MAX_RANGING_ROUND_RETRY_REACHED -> InternalReason.NO_PEERS_FOUND;
+                case REASON_SYSTEM_POLICY -> InternalReason.SYSTEM_POLICY;
+                default -> InternalReason.UNKNOWN;
+            };
+        }
+
         private @Nullable RangingDevice convertPeerDevice(
                 @NonNull com.android.ranging.uwb.backend.internal.UwbDevice peer
         ) {
@@ -264,11 +410,20 @@ public class UwbAdapter implements RangingAdapter {
         }
     }
 
-    /** Close the session, disconnecting all peers and resetting internal state. */
-    private void closeForReason(@Callback.ClosedReason int reason) {
+    /**
+     * Informs callbacks that all peers disconnected and the session closed. Resets internal
+     * state.
+     */
+    private void closeForReason(@InternalReason int reason) {
         synchronized (mStateMachine) {
             mStateMachine.setState(State.STOPPED);
-            mPeers.keySet().forEach(mCallbacks::onStopped);
+            if (mCallbacks == null) {
+                Log.i(TAG, "Callback is empty.");
+                return;
+            }
+            if (!mPeers.isEmpty()) {
+                mCallbacks.onStopped(ImmutableSet.copyOf(mPeers.keySet()), reason);
+            }
             mCallbacks.onClosed(reason);
             clear();
         }
@@ -285,33 +440,52 @@ public class UwbAdapter implements RangingAdapter {
     }
 
     private class ExecutorResultHandlers {
-        public final FutureCallback<Void> startRanging = new FutureCallback<>() {
+        public final FutureCallback<Integer> startRanging = new FutureCallback<>() {
             @Override
-            public void onSuccess(Void v) {
+            public void onSuccess(Integer status) {
+                if (status != Utils.STATUS_OK) {
+                    Log.e(TAG, "startRainging failed with status " + status);
+                    closeForReason(convertStatus(status));
+                }
                 Log.i(TAG, "startRanging succeeded.");
             }
 
             @Override
             public void onFailure(@NonNull Throwable t) {
-                Log.w(TAG, "startRanging failed ", t);
-                closeForReason(Callback.ClosedReason.ERROR);
+                Log.e(TAG, "startRanging failed ", t);
+                closeForReason(InternalReason.INTERNAL_ERROR);
             }
         };
 
         public final FutureCallback<Integer> stopRanging = new FutureCallback<>() {
             @Override
             public void onSuccess(@Utils.UwbStatusCodes Integer status) {
+                if (status != Utils.STATUS_OK) {
+                    Log.e(TAG, "stopRanging failed with status " + status);
+                }
             }
 
             @Override
             public void onFailure(@NonNull Throwable t) {
-                Log.w(TAG, "stopRanging failed ", t);
+                Log.e(TAG, "stopRanging failed ", t);
                 // We failed to stop but there's nothing else we can do.
-                closeForReason(Callback.ClosedReason.ERROR);
+                closeForReason(InternalReason.INTERNAL_ERROR);
             }
         };
     }
 
+    public static @InternalReason int convertStatus(@Utils.UwbStatusCodes int status) {
+        return switch (status) {
+            case Utils.STATUS_OK -> InternalReason.UNKNOWN;
+            case Utils.STATUS_ERROR,
+                 Utils.INVALID_API_CALL,
+                 Utils.MISSING_PERMISSION_UWB_RANGING,
+                 Utils.UWB_SYSTEM_CALLBACK_FAILURE,
+                 Utils.RANGING_ALREADY_STARTED -> InternalReason.INTERNAL_ERROR;
+            default -> InternalReason.UNKNOWN;
+        };
+    }
+
     public static int convertConfidence(int confidence) {
         return switch (confidence) {
             case CONFIDENCE_HIGH -> android.ranging.RangingMeasurement.CONFIDENCE_HIGH;
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbCapabilitiesAdapter.java b/ranging/service/java/com/android/server/ranging/uwb/UwbCapabilitiesAdapter.java
index bb156723..9b34543f 100644
--- a/ranging/service/java/com/android/server/ranging/uwb/UwbCapabilitiesAdapter.java
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbCapabilitiesAdapter.java
@@ -35,6 +35,8 @@ import com.android.ranging.uwb.backend.internal.UwbServiceImpl;
 import com.android.server.ranging.CapabilitiesProvider.AvailabilityChangedReason;
 import com.android.server.ranging.CapabilitiesProvider.CapabilitiesAdapter;
 import com.android.server.ranging.CapabilitiesProvider.TechnologyAvailabilityListener;
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingTechnology;
 
 import java.time.Duration;
 
@@ -47,7 +49,8 @@ public class UwbCapabilitiesAdapter extends CapabilitiesAdapter {
 
     /** @return true if UWB is supported in the provided context, false otherwise */
     public static boolean isSupported(Context context) {
-        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_UWB);
+        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_UWB)
+                && RangingInjector.getInstance().isRangingTechnologyEnabled(RangingTechnology.UWB);
     }
 
     public UwbCapabilitiesAdapter(
@@ -103,6 +106,7 @@ public class UwbCapabilitiesAdapter extends CapabilitiesAdapter {
                 .setSupportedPreambleIndexes(capabilities.getSupportedPreambleIndexes())
                 .setHasBackgroundRangingSupport(
                         capabilities.hasBackgroundRangingSupport())
+                .setCountryCode(capabilities.getCountryCode())
                 .build();
     }
 
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbConfig.java b/ranging/service/java/com/android/server/ranging/uwb/UwbConfig.java
index 0c3495e3..bdf09c31 100644
--- a/ranging/service/java/com/android/server/ranging/uwb/UwbConfig.java
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbConfig.java
@@ -21,21 +21,25 @@ import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
 import android.ranging.DataNotificationConfig;
 import android.ranging.RangingDevice;
 import android.ranging.RangingPreference;
+import android.ranging.SessionConfig;
 import android.ranging.uwb.UwbAddress;
 import android.ranging.uwb.UwbComplexChannel;
 import android.ranging.uwb.UwbRangingParams;
 
 import androidx.annotation.NonNull;
 
+import com.android.ranging.uwb.backend.internal.RangingParameters;
 import com.android.ranging.uwb.backend.internal.UwbRangeDataNtfConfig;
+import com.android.ranging.uwb.backend.internal.UwbRangeLimitsConfig;
 import com.android.server.ranging.RangingTechnology;
-import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.session.RangingSessionConfig.MulticastTechnologyConfig;
 
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.uwb.support.base.RequiredParam;
 
 import java.util.List;
+import java.util.Objects;
 import java.util.stream.Collectors;
 
 /**
@@ -43,22 +47,18 @@ import java.util.stream.Collectors;
  * configuration message sent over OOB and everything required to start a session in the underlying
  * UWB system API.
  */
-public class UwbConfig implements RangingSessionConfig.MulticastTechnologyConfig {
+public class UwbConfig implements MulticastTechnologyConfig {
     private static final String TAG = UwbConfig.class.getSimpleName();
 
-    private final String mCountryCode;
-    private final DataNotificationConfig mDataNotificationConfig;
+    private final SessionConfig mSessionConfig;
     private final UwbRangingParams mParameters;
     private final int mDeviceRole;
-    private final boolean mIsAoaNeeded;
     private final ImmutableBiMap<RangingDevice, UwbAddress> mPeerAddresses;
 
     private UwbConfig(Builder builder) {
         mParameters = builder.mParameters;
-        mCountryCode = builder.mCountryCode.get();
-        mDataNotificationConfig = builder.mDataNotificationConfig;
+        mSessionConfig = builder.mSessionConfig;
         mDeviceRole = builder.mDeviceRole;
-        mIsAoaNeeded = builder.mIsAoaNeeded;
         mPeerAddresses = builder.mPeerAddresses.get();
     }
 
@@ -85,20 +85,13 @@ public class UwbConfig implements RangingSessionConfig.MulticastTechnologyConfig
         return mParameters;
     }
 
-    public @NonNull String getCountryCode() {
-        return mCountryCode;
-    }
-
-    public @NonNull DataNotificationConfig getDataNotificationConfig() {
-        return mDataNotificationConfig;
-    }
-
-    public int getDeviceRole() {
+    @Override
+    public @RangingPreference.DeviceRole int getDeviceRole() {
         return mDeviceRole;
     }
 
-    public boolean isAoaNeeded() {
-        return mIsAoaNeeded;
+    public SessionConfig getSessionConfig() {
+        return mSessionConfig;
     }
 
     public @NonNull ImmutableBiMap<RangingDevice, UwbAddress> getPeerAddresses() {
@@ -111,7 +104,7 @@ public class UwbConfig implements RangingSessionConfig.MulticastTechnologyConfig
      * {@link androidx.core.uwb.backend.impl.internal.RangingParameters} accepted by the UWB
      * backend.
      */
-    public com.android.ranging.uwb.backend.internal.RangingParameters asBackendParameters() {
+    public RangingParameters asBackendParameters(DataNotificationConfig dataNotificationConfig) {
         List<com.android.ranging.uwb.backend.internal.UwbAddress> peerAddresses = mPeerAddresses
                 .values()
                 .stream()
@@ -119,7 +112,7 @@ public class UwbConfig implements RangingSessionConfig.MulticastTechnologyConfig
                         com.android.ranging.uwb.backend.internal.UwbAddress.fromBytes(
                                 address.getAddressBytes()))
                 .collect(Collectors.toList());
-        return new com.android.ranging.uwb.backend.internal.RangingParameters(
+        return new RangingParameters(
                 (int) mParameters.getConfigId(),
                 mParameters.getSessionId(),
                 mParameters.getSubSessionId(),
@@ -128,9 +121,13 @@ public class UwbConfig implements RangingSessionConfig.MulticastTechnologyConfig
                 toBackend(mParameters.getComplexChannel()),
                 peerAddresses,
                 (int) mParameters.getRangingUpdateRate(),
-                toBackend(getDataNotificationConfig()),
+                toBackend(dataNotificationConfig),
                 (int) mParameters.getSlotDuration(),
-                mIsAoaNeeded
+                // RangingParameters has isAoaDisabled field, Inverting here.
+                !mSessionConfig.isAngleOfArrivalNeeded(),
+                new UwbRangeLimitsConfig.Builder().setRangeMaxNumberOfMeasurements(
+                        mSessionConfig.getRangingMeasurementsLimit()
+                ).build()
         );
     }
 
@@ -164,9 +161,7 @@ public class UwbConfig implements RangingSessionConfig.MulticastTechnologyConfig
         private final UwbRangingParams mParameters;
         private final RequiredParam<ImmutableBiMap<RangingDevice, UwbAddress>> mPeerAddresses =
                 new RequiredParam<>();
-        private final RequiredParam<String> mCountryCode = new RequiredParam<>();
-        private DataNotificationConfig mDataNotificationConfig =
-                new DataNotificationConfig.Builder().build();
+        private SessionConfig mSessionConfig = new SessionConfig.Builder().build();
 
         private int mDeviceRole = DEVICE_ROLE_RESPONDER;
         private boolean mIsAoaNeeded = false;
@@ -186,23 +181,13 @@ public class UwbConfig implements RangingSessionConfig.MulticastTechnologyConfig
             return this;
         }
 
-        public Builder setCountryCode(@NonNull String countryCode) {
-            mCountryCode.set(countryCode);
-            return this;
-        }
-
         public Builder setDeviceRole(@RangingPreference.DeviceRole int deviceRole) {
             mDeviceRole = deviceRole;
             return this;
         }
 
-        public Builder setAoaNeeded(boolean isAoaNeeded) {
-            mIsAoaNeeded = isAoaNeeded;
-            return this;
-        }
-
-        public Builder setDataNotificationConfig(@NonNull DataNotificationConfig config) {
-            mDataNotificationConfig = config;
+        public Builder setSessionConfig(SessionConfig sessionConfig) {
+            mSessionConfig = sessionConfig;
             return this;
         }
     }
@@ -212,16 +197,27 @@ public class UwbConfig implements RangingSessionConfig.MulticastTechnologyConfig
         return "UwbConfig{"
                 + "mParameters="
                 + mParameters
-                + ", mCountryCode='"
-                + mCountryCode
-                + ", mDataNotificationConfig="
-                + mDataNotificationConfig
+                + ", mSessionConfig="
+                + mSessionConfig
                 + ", mDeviceRole="
                 + mDeviceRole
-                + ", mIsAoaNeeded="
-                + mIsAoaNeeded
                 + ", mPeerAddresses="
                 + mPeerAddresses
                 + " }";
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof UwbConfig uwbConfig)) return false;
+        return mDeviceRole == uwbConfig.mDeviceRole && Objects.equals(mSessionConfig,
+                uwbConfig.mSessionConfig) && Objects.equals(mParameters,
+                uwbConfig.mParameters) && Objects.equals(mPeerAddresses,
+                uwbConfig.mPeerAddresses);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mSessionConfig, mParameters, mDeviceRole, mPeerAddresses);
+    }
 }
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbConfigSelector.java b/ranging/service/java/com/android/server/ranging/uwb/UwbConfigSelector.java
new file mode 100644
index 00000000..d8d20d9e
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbConfigSelector.java
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.uwb;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+import static android.ranging.oob.OobInitiatorRangingConfig.SECURITY_LEVEL_BASIC;
+import static android.ranging.oob.OobInitiatorRangingConfig.SECURITY_LEVEL_SECURE;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+import static android.ranging.uwb.UwbComplexChannel.UWB_CHANNEL_5;
+import static android.ranging.uwb.UwbComplexChannel.UWB_CHANNEL_9;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_25;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_32;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_MULTICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_PROVISIONED_MULTICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_PROVISIONED_UNICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_UNICAST_DS_TWR;
+
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.SessionHandle;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingCapabilities;
+import android.ranging.uwb.UwbRangingParams;
+import android.util.Log;
+import android.util.Pair;
+import android.util.Range;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.ranging.uwb.backend.internal.RangingTimingParams;
+import com.android.ranging.uwb.backend.internal.Utils;
+import com.android.server.ranging.RangingEngine;
+import com.android.server.ranging.RangingEngine.ConfigSelectionException;
+import com.android.server.ranging.RangingUtils.InternalReason;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.SetConfigurationMessage.TechnologyOobConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+
+/** Selects a {@link UwbConfig} from local and peer device capabilities */
+public class UwbConfigSelector implements RangingEngine.ConfigSelector {
+    private static final String TAG = UwbConfigSelector.class.getSimpleName();
+
+    private static final Set<@UwbComplexChannel.UwbPreambleCodeIndex Integer> HPRF_INDEXES =
+            IntStream.rangeClosed(UWB_PREAMBLE_CODE_INDEX_25, UWB_PREAMBLE_CODE_INDEX_32)
+                        .boxed()
+                        .collect(Collectors.toSet());
+
+    private final SessionConfig mSessionConfig;
+    private final OobInitiatorRangingConfig mOobConfig;
+    private final SessionHandle mSessionHandle;
+    private final BiMap<RangingDevice, UwbAddress> mPeerAddresses;
+
+    private final Set<@UwbRangingParams.ConfigId Integer> mConfigIds;
+    private final Set<@UwbComplexChannel.UwbChannel Integer> mChannels;
+    private final Set<@UwbComplexChannel.UwbPreambleCodeIndex Integer> mPreambleIndexes;
+    private @UwbRangingParams.SlotDuration int mMinSlotDurationMs;
+    private long mMinRangingIntervalMs;
+    private final String mCountryCode;
+
+    private static boolean isCapableOfConfig(
+            @NonNull SessionConfig sessionConfig, @NonNull OobInitiatorRangingConfig oobConfig,
+            @Nullable UwbRangingCapabilities capabilities
+    ) {
+        if (capabilities == null) return false;
+
+        boolean isMulticast = oobConfig.getDeviceHandles().size() > 1;
+
+        if (oobConfig.getSecurityLevel() == SECURITY_LEVEL_BASIC
+                && isMulticast
+                && !capabilities.getSupportedConfigIds().contains(CONFIG_MULTICAST_DS_TWR)
+        ) return false;
+
+        if (oobConfig.getSecurityLevel() == SECURITY_LEVEL_BASIC
+                && !isMulticast
+                && !capabilities.getSupportedConfigIds().contains(CONFIG_UNICAST_DS_TWR)
+        ) return false;
+
+        if (oobConfig.getSecurityLevel() == SECURITY_LEVEL_SECURE
+                && isMulticast
+                && !capabilities
+                        .getSupportedConfigIds().contains(CONFIG_PROVISIONED_MULTICAST_DS_TWR)
+        ) return false;
+
+        if (oobConfig.getSecurityLevel() == SECURITY_LEVEL_SECURE
+                && !isMulticast
+                && !capabilities
+                        .getSupportedConfigIds().contains(CONFIG_PROVISIONED_UNICAST_DS_TWR)
+        ) return false;
+
+        // TODO: If we add support for AoA via ARCore in the future, this will need to be changed.
+        if (sessionConfig.isAngleOfArrivalNeeded() && !capabilities.isAzimuthalAngleSupported())
+            return false;
+
+        return true;
+    }
+
+    public UwbConfigSelector(
+            @NonNull SessionConfig sessionConfig,
+            @NonNull OobInitiatorRangingConfig oobConfig,
+            @NonNull SessionHandle sessionHandle,
+            @Nullable UwbRangingCapabilities capabilities
+    ) throws ConfigSelectionException {
+        if (!isCapableOfConfig(sessionConfig, oobConfig, capabilities)) {
+            throw new ConfigSelectionException("Local device is incapable of provided UWB config",
+                    InternalReason.UNSUPPORTED);
+        }
+
+        mSessionConfig = sessionConfig;
+        mOobConfig = oobConfig;
+        mSessionHandle = sessionHandle;
+        mPeerAddresses = HashBiMap.create();
+        mConfigIds = new HashSet<>(capabilities.getSupportedConfigIds());
+        // TODO(406020462): Temporary debug log
+        Log.d(TAG, "Locally supported channels: " + capabilities.getSupportedChannels());
+        mChannels = new HashSet<>(capabilities.getSupportedChannels());
+        mPreambleIndexes = new HashSet<>(capabilities.getSupportedPreambleIndexes());
+        mMinSlotDurationMs = Collections.min(capabilities.getSupportedSlotDurations());
+        mMinRangingIntervalMs = capabilities.getMinimumRangingInterval().toMillis();
+        mCountryCode = capabilities.getCountryCode();
+    }
+
+    /**
+     * @throws ConfigSelectionException if the provided capabilities are incompatible with the
+     *                                  configuration
+     */
+    @Override
+    public void addPeerCapabilities(
+            @NonNull RangingDevice peer, @NonNull CapabilityResponseMessage response
+    ) throws ConfigSelectionException {
+        UwbOobCapabilities capabilities = response.getUwbCapabilities();
+        if (capabilities == null) {
+            throw new ConfigSelectionException("Peer " + peer + " does not support UWB",
+                    InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+        if (!capabilities.getSupportedDeviceRole().contains(UwbOobConfig.OobDeviceRole.INITIATOR)) {
+            throw new ConfigSelectionException("Peer does not support initiator role",
+                    InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+
+        mPeerAddresses.put(peer, capabilities.getUwbAddress());
+        mConfigIds.retainAll(capabilities.getSupportedConfigIds());
+        mChannels.retainAll(capabilities.getSupportedChannels());
+        // TODO(406020462): Temporary debug log
+        Log.d(TAG, "Add peer with supported channels " + capabilities.getSupportedChannels()
+                + " set of selectable channels updated to " + mChannels);
+        mPreambleIndexes.retainAll(capabilities.getSupportedPreambleIndexes());
+        mMinSlotDurationMs = Math.max(
+                mMinSlotDurationMs, capabilities.getMinimumSlotDurationMs());
+        mMinRangingIntervalMs = Math.max(
+                mMinRangingIntervalMs, capabilities.getMinimumRangingIntervalMs());
+    }
+
+    @Override
+    public boolean hasPeersToConfigure() {
+        return !mPeerAddresses.isEmpty();
+    }
+
+    @Override
+    public @NonNull Pair<
+            ImmutableSet<TechnologyConfig>,
+            ImmutableMap<RangingDevice, TechnologyOobConfig>
+    > selectConfigs() throws ConfigSelectionException {
+        SelectedUwbConfig configs = new SelectedUwbConfig();
+        return Pair.create(configs.getLocalConfigs(), configs.getPeerConfigs());
+    }
+
+    private class SelectedUwbConfig {
+        private final int mSessionId;
+        private final UwbAddress mLocalAddress;
+        private final @UwbRangingParams.ConfigId int mConfigId;
+        private final @UwbComplexChannel.UwbChannel int mChannel;
+        private final @UwbComplexChannel.UwbPreambleCodeIndex int mPreambleIndex;
+        private final @RawRangingDevice.RangingUpdateRate int mRangingUpdateRate;
+        private final byte[] mSessionKeyInfo;
+
+        SelectedUwbConfig() throws ConfigSelectionException {
+            mSessionId = mSessionHandle.hashCode();
+            mLocalAddress = UwbAddress.createRandomShortAddress();
+            mConfigId = selectConfigId();
+            mChannel = selectChannel();
+            mPreambleIndex = selectPreambleIndex();
+            mRangingUpdateRate = selectRangingUpdateRate();
+            mSessionKeyInfo = selectSessionKeyInfo();
+        }
+
+        // For now, each GRAPI responder will be a UWB initiator for a unicast session. In the
+        // future we can look into combining these into a single multicast session somehow.
+
+        public @NonNull ImmutableSet<TechnologyConfig> getLocalConfigs() {
+            return mPeerAddresses.keySet().stream().map(
+                    (device) -> new UwbConfig.Builder(
+                            new UwbRangingParams.Builder(
+                                    mSessionId, mConfigId, mLocalAddress,
+                                    mPeerAddresses.get(device))
+                                    .setSessionKeyInfo(mSessionKeyInfo)
+                                    .setComplexChannel(new UwbComplexChannel.Builder()
+                                            .setChannel(mChannel)
+                                            .setPreambleIndex(mPreambleIndex)
+                                            .build())
+                                    .setRangingUpdateRate(mRangingUpdateRate)
+                                    .setSlotDuration(mMinSlotDurationMs)
+                                    .build())
+                            .setSessionConfig(mSessionConfig)
+                            .setDeviceRole(DEVICE_ROLE_RESPONDER)
+                            .setPeerAddresses(ImmutableBiMap.of(device, mPeerAddresses.get(device)))
+                            .build())
+                    .collect(ImmutableSet.toImmutableSet());
+        }
+
+        public @NonNull ImmutableMap<RangingDevice, TechnologyOobConfig> getPeerConfigs() {
+            UwbOobConfig config = UwbOobConfig.builder()
+                    .setUwbAddress(mLocalAddress)
+                    .setSessionId(mSessionId)
+                    .setSelectedConfigId(mConfigId)
+                    .setSelectedChannel(mChannel)
+                    .setSelectedPreambleIndex(mPreambleIndex)
+                    .setSelectedRangingIntervalMs(Utils.getRangingTimingParams((int) mConfigId)
+                            .getRangingInterval((int) mRangingUpdateRate))
+                    .setSelectedSlotDurationMs(mMinSlotDurationMs)
+                    .setSessionKey(mSessionKeyInfo)
+                    .setCountryCode(mCountryCode)
+                    .setDeviceRole(UwbOobConfig.OobDeviceRole.INITIATOR)
+                    .setDeviceMode(UwbOobConfig.OobDeviceMode.CONTROLLER)
+                    .build();
+
+            return mPeerAddresses.keySet().stream()
+                    .collect(ImmutableMap.toImmutableMap(Function.identity(), (unused) -> config));
+        }
+    }
+
+    private @UwbRangingParams.ConfigId int selectConfigId() throws ConfigSelectionException {
+        if (mOobConfig.getSecurityLevel() == SECURITY_LEVEL_BASIC) {
+            if (mConfigIds.contains(CONFIG_UNICAST_DS_TWR)) {
+                return CONFIG_UNICAST_DS_TWR;
+            }
+        } else if (mOobConfig.getSecurityLevel() == SECURITY_LEVEL_SECURE) {
+            if (mConfigIds.contains(CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST)) {
+                return CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST;
+            } else if (mConfigIds.contains(CONFIG_PROVISIONED_UNICAST_DS_TWR)) {
+                return CONFIG_PROVISIONED_UNICAST_DS_TWR;
+            }
+        }
+
+        throw new ConfigSelectionException("Failed to find agreeable config id",
+                InternalReason.PEER_CAPABILITIES_MISMATCH);
+    }
+
+    private byte[] selectSessionKeyInfo() {
+        byte[] sessionKeyInfo;
+        if (mOobConfig.getSecurityLevel() == SECURITY_LEVEL_BASIC) {
+            sessionKeyInfo = new byte[8];
+        } else {
+            sessionKeyInfo = new byte[16];
+        }
+        new Random().nextBytes(sessionKeyInfo);
+        return sessionKeyInfo;
+    }
+
+    private @UwbComplexChannel.UwbChannel int selectChannel() throws ConfigSelectionException {
+        if (mChannels.contains(UWB_CHANNEL_9)) {
+            return UWB_CHANNEL_9;
+        } else if (mChannels.contains(UWB_CHANNEL_5)) {
+            return UWB_CHANNEL_5;
+        } else {
+            // TODO(b/406020462): This is a temporary workaround for the 25Q2 release. Undo this
+            //  change once release snapshot is taken so we can continue to debug the failure.
+            Log.e(TAG, "Not all peers support uwb channel 9 or 5, if you see this, please attach "
+                    + "logcat to b/406020462");
+            return UWB_CHANNEL_9;
+            // throw new ConfigSelectionException("Not all peers support uwb channel 9 or 5",
+            //         InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+    }
+
+    private @UwbComplexChannel.UwbPreambleCodeIndex int selectPreambleIndex()
+            throws ConfigSelectionException {
+
+        if (mPreambleIndexes.isEmpty()) {
+            throw new ConfigSelectionException(
+                    "Peers do not share support for any uwb preamble indexes",
+                    InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+        Set<@UwbComplexChannel.UwbPreambleCodeIndex Integer> supportedHprfIndexes =
+                Sets.intersection(mPreambleIndexes, HPRF_INDEXES);
+
+        // Prioritize HPRF indexes
+        if (!supportedHprfIndexes.isEmpty()) {
+            return List.copyOf(supportedHprfIndexes).get(
+                    new Random().nextInt(supportedHprfIndexes.size()));
+        } else {
+            return List.copyOf(mPreambleIndexes).get(
+                    new Random().nextInt(mPreambleIndexes.size()));
+        }
+    }
+
+    private @RawRangingDevice.RangingUpdateRate int selectRangingUpdateRate()
+            throws ConfigSelectionException {
+
+        @UwbRangingParams.ConfigId int configId = selectConfigId();
+        RangingTimingParams timings = Utils.getRangingTimingParams((int) configId);
+
+        Range<Long> intervalsMs;
+        try {
+            intervalsMs = Range.create(
+                    Math.max(mMinRangingIntervalMs, timings.getRangingIntervalFast()),
+                    (long) timings.getRangingIntervalInfrequent());
+        } catch (IllegalArgumentException unused) {
+            throw new ConfigSelectionException("Timings supported by selected config id " + configId
+                    + " are incompatible with local or peer ranging interval capabilities",
+                    InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+
+        // The code below is a little hard to read, but there are 3 cases:
+        //   1. If configured range overlaps with the intervals that devices are capable of, select
+        //      fastest supported.
+        //   2. If configured range lies entirely above the intervals that devices are capable of,
+        //      select UPDATE_RATE_INFREQUENT.
+        //   3. If configured range lies entirely below the intervals that devices are capable of,
+        //      select fastest supported.
+        try {
+            intervalsMs = intervalsMs.intersect(
+                    mOobConfig.getFastestRangingInterval().toMillis(),
+                    mOobConfig.getSlowestRangingInterval().toMillis());
+        } catch (IllegalArgumentException ignored) {
+            if (mOobConfig.getFastestRangingInterval().toMillis() > intervalsMs.getUpper()) {
+                return UPDATE_RATE_INFREQUENT;
+            }
+        }
+
+        return getFastestUpdateRateInRange(intervalsMs, timings);
+    }
+
+    private @RawRangingDevice.RangingUpdateRate int getFastestUpdateRateInRange(
+            Range<Long> rangeMs, RangingTimingParams timings
+    ) throws ConfigSelectionException {
+        if (rangeMs.contains((long) timings.getRangingIntervalFast())) {
+            return UPDATE_RATE_FREQUENT;
+        } else if (rangeMs.contains((long) timings.getRangingIntervalNormal())) {
+            return UPDATE_RATE_NORMAL;
+        } else if (rangeMs.contains((long) timings.getRangingIntervalInfrequent())) {
+            return UPDATE_RATE_INFREQUENT;
+        } else {
+            throw new ConfigSelectionException(
+                    "Could not find update rate within the "
+                            + "requested range that satisfies all peer capabilities",
+                    InternalReason.PEER_CAPABILITIES_MISMATCH);
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbOobCapabilities.java b/ranging/service/java/com/android/server/ranging/uwb/UwbOobCapabilities.java
index 6a0a7202..d9742979 100644
--- a/ranging/service/java/com/android/server/ranging/uwb/UwbOobCapabilities.java
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbOobCapabilities.java
@@ -18,7 +18,10 @@ package com.android.server.ranging.uwb;
 
 import static com.google.common.collect.ImmutableList.toImmutableList;
 
+import android.ranging.RangingCapabilities;
+import android.ranging.RangingManager;
 import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbRangingCapabilities;
 
 import com.android.server.ranging.RangingTechnology;
 import com.android.server.ranging.RangingUtils.Conversions;
@@ -32,7 +35,7 @@ import java.util.Arrays;
 
 /** Capability data for UWB sent as part of CapabilityResponseMessage. */
 @AutoValue
-public abstract class UwbOobCapabilities {
+public abstract class UwbOobCapabilities implements RangingCapabilities.TechnologyCapabilities {
 
     /** Size in bytes of all properties when serialized. */
     private static final int EXPECTED_SIZE_BYTES = 20;
@@ -56,6 +59,11 @@ public abstract class UwbOobCapabilities {
         return EXPECTED_SIZE_BYTES;
     }
 
+    @Override
+    public @RangingManager.RangingTechnology int getTechnology() {
+        return RangingTechnology.UWB.getValue();
+    }
+
     /**
      * Parses the given byte array and returns {@link UwbOobCapabilities} object. Throws {@link
      * IllegalArgumentException} on invalid input.
@@ -180,6 +188,27 @@ public abstract class UwbOobCapabilities {
         return byteBuffer.array();
     }
 
+    public static UwbOobCapabilities fromRangingCapabilities(
+            UwbRangingCapabilities capabilities, UwbAddress address
+    ) {
+        return UwbOobCapabilities.builder()
+                .setUwbAddress(address)
+                .setSupportedChannels(
+                        ImmutableList.copyOf(capabilities.getSupportedChannels()))
+                .setSupportedPreambleIndexes(
+                        ImmutableList.copyOf(capabilities.getSupportedPreambleIndexes()))
+                .setSupportedConfigIds(
+                        ImmutableList.copyOf(capabilities.getSupportedConfigIds()))
+                .setMinimumRangingIntervalMs(
+                        (int) capabilities.getMinimumRangingInterval().toMillis())
+                .setMinimumSlotDurationMs(capabilities.getSupportedSlotDurations()
+                        .stream().min(Integer::compare).get())
+                .setSupportedDeviceRole(ImmutableList.of(
+                        UwbOobConfig.OobDeviceRole.INITIATOR,
+                        UwbOobConfig.OobDeviceRole.RESPONDER))
+                .build();
+    }
+
     /** Returns the {@link UwbAddress} of the device. */
     public abstract UwbAddress getUwbAddress();
 
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbOobConfig.java b/ranging/service/java/com/android/server/ranging/uwb/UwbOobConfig.java
index 4e00df33..a382233e 100644
--- a/ranging/service/java/com/android/server/ranging/uwb/UwbOobConfig.java
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbOobConfig.java
@@ -16,48 +16,39 @@
 
 package com.android.server.ranging.uwb;
 
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
-import android.annotation.IntDef;
+import android.ranging.RangingDevice;
+import android.ranging.raw.RawRangingDevice;
 import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingParams;
+
+import androidx.annotation.NonNull;
 
+import com.android.ranging.uwb.backend.internal.RangingTimingParams;
+import com.android.ranging.uwb.backend.internal.Utils;
 import com.android.server.ranging.RangingTechnology;
 import com.android.server.ranging.RangingUtils.Conversions;
+import com.android.server.ranging.oob.SetConfigurationMessage;
 import com.android.server.ranging.oob.TechnologyHeader;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableBiMap;
 
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
 /** Configuration for UWB sent as part SetConfigurationMessage for Finder OOB. */
 @AutoValue
-public abstract class UwbOobConfig {
-
-    @IntDef({
-            OobDeviceMode.UNKNOWN,
-            OobDeviceMode.CONTROLLER,
-            OobDeviceMode.CONTROLEE,
-    })
-    public @interface OobDeviceMode {
-        int UNKNOWN = 0;
-        int CONTROLLER = 1;
-        int CONTROLEE = 2;
-    }
-
-    @IntDef({
-            OobDeviceRole.UNKNOWN,
-            OobDeviceRole.INITIATOR,
-            OobDeviceRole.RESPONDER,
-    })
-    public @interface OobDeviceRole {
-        int UNKNOWN = 0;
-        int INITIATOR = 1;
-        int RESPONDER = 2;
-    }
+public abstract class UwbOobConfig implements SetConfigurationMessage.TechnologyOobConfig {
 
-    private static final int MIN_SIZE_BYTES = 20;
+    private static final int MIN_SIZE_BYTES = 19;
 
     // Size in bytes for properties when serialized.
     private static final int UWB_ADDRESS_SIZE = 2;
@@ -81,7 +72,7 @@ public abstract class UwbOobConfig {
     }
 
     /**
-     * Parses the given byte array and returns {@link UwbOobConfig} object. Throws {@link
+     * Parses the given byte array and returns {@link UwbConfig} object. Throws {@link
      * IllegalArgumentException} on invalid input.
      */
     public static UwbOobConfig parseBytes(byte[] uwbConfigBytes) {
@@ -89,9 +80,8 @@ public abstract class UwbOobConfig {
 
         if (uwbConfigBytes.length < MIN_SIZE_BYTES) {
             throw new IllegalArgumentException(
-                    String.format(
-                            "UwbConfig size is %d, expected at least %d", uwbConfigBytes.length,
-                            MIN_SIZE_BYTES));
+                    String.format("UwbConfig size is %d, expected at least %d",
+                            uwbConfigBytes.length, MIN_SIZE_BYTES));
         }
 
         if (uwbConfigBytes.length < header.getSize()) {
@@ -112,16 +102,14 @@ public abstract class UwbOobConfig {
 
         // Parse Uwb Address
         UwbAddress uwbAddress =
-                UwbAddress.fromBytes(
-                        Arrays.copyOfRange(uwbConfigBytes, parseCursor,
-                                parseCursor + UWB_ADDRESS_SIZE));
+                UwbAddress.fromBytes(Arrays.copyOfRange(
+                        uwbConfigBytes, parseCursor, parseCursor + UWB_ADDRESS_SIZE));
         parseCursor += UWB_ADDRESS_SIZE;
 
         // Parse Session Id
         int sessionId =
-                Conversions.byteArrayToInt(
-                        Arrays.copyOfRange(uwbConfigBytes, parseCursor,
-                                parseCursor + SESSION_ID_SIZE));
+                Conversions.byteArrayToInt(Arrays.copyOfRange(
+                        uwbConfigBytes, parseCursor, parseCursor + SESSION_ID_SIZE));
         parseCursor += SESSION_ID_SIZE;
 
         // Parse Config Id
@@ -138,9 +126,8 @@ public abstract class UwbOobConfig {
 
         // Parse Ranging Interval Ms
         int rangingIntervalMs =
-                Conversions.byteArrayToInt(
-                        Arrays.copyOfRange(uwbConfigBytes, parseCursor,
-                                parseCursor + RANGING_INTERVAL_SIZE));
+                Conversions.byteArrayToInt(Arrays.copyOfRange(
+                        uwbConfigBytes, parseCursor, parseCursor + RANGING_INTERVAL_SIZE));
         parseCursor += RANGING_INTERVAL_SIZE;
 
         // Parse Slot Duration
@@ -153,26 +140,25 @@ public abstract class UwbOobConfig {
 
         if (uwbConfigBytes.length < MIN_SIZE_BYTES + sessionKeyLength) {
             throw new IllegalArgumentException(
-                    "Failed to parse UwbConfig, invalid size. Bytes: " + Arrays.toString(
-                            uwbConfigBytes));
+                    "Failed to parse UwbConfig, invalid size. Bytes: "
+                            + Arrays.toString(uwbConfigBytes));
         }
-        byte[] sessionKey = Arrays.copyOfRange(
-                uwbConfigBytes, parseCursor, parseCursor + sessionKeyLength);
+        byte[] sessionKey =
+                Arrays.copyOfRange(uwbConfigBytes, parseCursor, parseCursor + sessionKeyLength);
         parseCursor += sessionKeyLength;
 
         // Parse Country Code
         String countryCode =
-                new String(
-                        Arrays.copyOfRange(uwbConfigBytes, parseCursor,
-                                parseCursor + COUNTRY_CODE_SIZE));
+                new String(Arrays.copyOfRange(
+                        uwbConfigBytes, parseCursor, parseCursor + COUNTRY_CODE_SIZE));
         parseCursor += COUNTRY_CODE_SIZE;
 
         // Parse Device Role
-        @OobDeviceRole int deviceRole = uwbConfigBytes[parseCursor];
+        int deviceRole = uwbConfigBytes[parseCursor];
         parseCursor += DEVICE_ROLE_SIZE;
 
         // Parse Device Mode
-        @OobDeviceMode int deviceMode = uwbConfigBytes[parseCursor];
+        int deviceMode = uwbConfigBytes[parseCursor];
         parseCursor += DEVICE_MODE_SIZE;
 
         return builder()
@@ -190,20 +176,19 @@ public abstract class UwbOobConfig {
                 .build();
     }
 
-    /** Serializes this {@link UwbOobConfig} object to bytes. */
+    /** Serializes this {@link UwbConfig} object to bytes. */
     public final byte[] toBytes() {
         int size = MIN_SIZE_BYTES + getSessionKeyLength();
         return ByteBuffer.allocate(size)
                 .put(RangingTechnology.UWB.toByte())
                 .put((byte) size)
-                .put(RangingTechnology.UWB.toByte())
                 .put(getUwbAddress().getAddressBytes())
                 .put(Conversions.intToByteArray(getSessionId(), SESSION_ID_SIZE))
                 .put(Conversions.intToByteArray(getSelectedConfigId(), CONFIG_ID_SIZE))
                 .put(Conversions.intToByteArray(getSelectedChannel(), CHANNEL_SIZE))
                 .put(Conversions.intToByteArray(getSelectedPreambleIndex(), PREAMBLE_INDEX_SIZE))
-                .put(Conversions.intToByteArray(getSelectedRangingIntervalMs(),
-                        RANGING_INTERVAL_SIZE))
+                .put(Conversions.intToByteArray(
+                        getSelectedRangingIntervalMs(), RANGING_INTERVAL_SIZE))
                 .put(Conversions.intToByteArray(getSelectedSlotDurationMs(), SLOT_DURATION_SIZE))
                 .put(Conversions.intToByteArray(getSessionKeyLength(), SESSION_KEY_LENGTH_SIZE))
                 .put(getSessionKey())
@@ -213,6 +198,45 @@ public abstract class UwbOobConfig {
                 .array();
     }
 
+    /**
+     * Throws {@link IllegalArgumentException} if the conversion could not be completed successfully
+     */
+    public @NonNull UwbConfig toTechnologyConfig(UwbAddress localAddress, RangingDevice peer) {
+        return new UwbConfig.Builder(
+                new UwbRangingParams.Builder(
+                        getSessionId(), getSelectedConfigId(), localAddress, getUwbAddress())
+                        .setSessionKeyInfo(getSessionKey())
+                        .setComplexChannel(new UwbComplexChannel.Builder()
+                                .setChannel(getSelectedChannel())
+                                .setPreambleIndex(getSelectedPreambleIndex())
+                                .build())
+                        .setRangingUpdateRate(getUpdateRateFromIntervalMs())
+                        .setSlotDuration(getSelectedSlotDurationMs())
+                        .build())
+                .setPeerAddresses(ImmutableBiMap.of(peer, getUwbAddress()))
+                .setDeviceRole(getDeviceRole())
+                .build();
+    }
+
+    /**
+     * Throws {@link IllegalArgumentException} if the ranging interval does not correspond to an
+     * update rate.
+     */
+    private @RawRangingDevice.RangingUpdateRate int getUpdateRateFromIntervalMs() {
+        RangingTimingParams timings = Utils.getRangingTimingParams((int) getSelectedConfigId());
+
+        if (getSelectedRangingIntervalMs() == timings.getRangingIntervalFast()) {
+            return UPDATE_RATE_FREQUENT;
+        } else if (getSelectedRangingIntervalMs() == timings.getRangingIntervalNormal()) {
+            return UPDATE_RATE_NORMAL;
+        } else if (getSelectedRangingIntervalMs() == timings.getRangingIntervalInfrequent()) {
+            return UPDATE_RATE_INFREQUENT;
+        } else {
+            throw new IllegalArgumentException(
+                    "Unsupported ranging interval ms " + getSelectedRangingIntervalMs());
+        }
+    }
+
     /** Returns {@link UwbAddress} of the device. */
     public abstract UwbAddress getUwbAddress();
 
@@ -242,8 +266,7 @@ public abstract class UwbOobConfig {
     /**
      * Returns the session key bytes. If S-STS is used then first two bytes are VENDOR ID and
      * following 6 bytes are STATIC STS IV. If P-STS is used then this is either a 16 byte or 32
-     * byte
-     * session key.
+     * byte session key.
      */
     @SuppressWarnings("mutable")
     public abstract byte[] getSessionKey();
@@ -257,12 +280,24 @@ public abstract class UwbOobConfig {
     /** Returns Device Mode. */
     public abstract @OobDeviceMode int getDeviceMode();
 
-    /** Returns a builder for {@link UwbOobConfig}. */
+    /** Returns a builder for {@link UwbConfig}. */
     public static Builder builder() {
-        return new AutoValue_UwbOobConfig.Builder().setSessionKey(new byte[]{});
+        return new AutoValue_UwbOobConfig.Builder().setSessionKey(new byte[] {});
+    }
+
+    public @interface OobDeviceMode {
+        int UNKNOWN = 0;
+        int CONTROLLER = 1;
+        int CONTROLEE = 2;
+    }
+
+    public @interface OobDeviceRole {
+        int UNKNOWN = 0;
+        int INITIATOR = 1;
+        int RESPONDER = 2;
     }
 
-    /** Builder for {@link UwbOobConfig}. */
+    /** Builder for {@link UwbConfig}. */
     @AutoValue.Builder
     public abstract static class Builder {
         public abstract Builder setUwbAddress(UwbAddress uwbAddress);
diff --git a/ranging/service/tests/unittests/Android.bp b/ranging/service/tests/unittests/Android.bp
index f1e431d0..080429b1 100644
--- a/ranging/service/tests/unittests/Android.bp
+++ b/ranging/service/tests/unittests/Android.bp
@@ -20,12 +20,16 @@ package {
 }
 
 android_test {
-    name: "GenericRangingTests",
+    name: "RangingServiceTests",
     srcs: ["src/**/*.java"],
-    sdk_version: "34",
+    sdk_version: "system_server_current",
+    target_sdk_version: "36",
     certificate: "platform",
     static_libs: [
+        "truth",
         "service-ranging-pre-jarjar",
+        "framework-bluetooth.stubs.module_lib",
+        "framework-wifi.stubs.module_lib",
         "framework-uwb.stubs.module_lib",
         "androidx.test.rules",
         "androidx.test.ext.junit",
@@ -37,5 +41,8 @@ android_test {
         "libdexmakerjvmtiagent",
         "libstaticjvmtiagent",
     ],
-    test_suites: ["device-tests"],
+    test_suites: [
+        "general-tests",
+        "mts-uwb",
+    ],
 }
diff --git a/ranging/service/tests/unittests/AndroidManifest.xml b/ranging/service/tests/unittests/AndroidManifest.xml
index ab8b7596..40fe1714 100644
--- a/ranging/service/tests/unittests/AndroidManifest.xml
+++ b/ranging/service/tests/unittests/AndroidManifest.xml
@@ -28,6 +28,6 @@
     <instrumentation
         android:name="androidx.test.runner.AndroidJUnitRunner"
         android:targetPackage="com.android.ranging.tests"
-        android:label="Generic Ranging Unit Tests" >
+        android:label="Ranging service unit tests" >
     </instrumentation>
 </manifest>
\ No newline at end of file
diff --git a/ranging/service/tests/unittests/AndroidTest.xml b/ranging/service/tests/unittests/AndroidTest.xml
index 172c8c63..35995694 100644
--- a/ranging/service/tests/unittests/AndroidTest.xml
+++ b/ranging/service/tests/unittests/AndroidTest.xml
@@ -16,7 +16,7 @@
   limitations under the License.
 -->
 
-<configuration description="Configuration for Generic Ranging unit tests">
+<configuration description="Configuration for Ranging service unit tests">
     <option name="test-suite-tag" value="apct" />
     <option name="config-descriptor:metadata" key="component" value="systems" />
     <option name="config-descriptor:metadata" key="parameter" value="instant_app" />
@@ -26,12 +26,14 @@
     <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.uwb.apex" />
     <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
         <option name="cleanup-apks" value="true" />
-        <option name="test-file-name" value="GenericRangingTests.apk" />
+        <option name="test-file-name" value="RangingServiceTests.apk" />
     </target_preparer>
     <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
         <option name="package" value="com.android.ranging.tests" />
+        <option name="hidden-api-checks" value="false"/>
     </test>
     <object type="module_controller" class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
         <option name="mainline-module-package-name" value="com.google.android.uwb" />
     </object>
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk36ModuleController" />
 </configuration>
\ No newline at end of file
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionConfigTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionConfigTest.java
index 26af22f6..9dbc6043 100644
--- a/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionConfigTest.java
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionConfigTest.java
@@ -24,9 +24,8 @@ import static android.ranging.uwb.UwbRangingParams.DURATION_2_MS;
 
 import static org.mockito.Mockito.mock;
 
-import android.ranging.DataNotificationConfig;
 import android.ranging.RangingDevice;
-import android.ranging.SensorFusionParams;
+import android.ranging.SessionConfig;
 import android.ranging.raw.RawRangingDevice;
 import android.ranging.uwb.UwbAddress;
 import android.ranging.uwb.UwbComplexChannel;
@@ -77,9 +76,7 @@ public class RangingSessionConfigTest {
     public void setup() {
         mConfig = new RangingSessionConfig.Builder()
                 .setDeviceRole(DEVICE_ROLE_INITIATOR)
-                .setSensorFusionConfig(new SensorFusionParams.Builder().build())
-                .setDataNotificationConfig(new DataNotificationConfig.Builder().build())
-                .setAoaNeeded(true)
+                .setSessionConfig(new SessionConfig.Builder().build())
                 .build();
     }
 
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/blerssi/BleRssiAdapterTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/blerssi/BleRssiAdapterTest.java
new file mode 100644
index 00000000..b802ef7c
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/blerssi/BleRssiAdapterTest.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.blerssi;
+
+
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_DISABLE;
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_ENABLE;
+
+import static junit.framework.Assert.assertEquals;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.AlarmManager;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.DistanceMeasurementManager;
+import android.bluetooth.le.DistanceMeasurementResult;
+import android.bluetooth.le.DistanceMeasurementSession;
+import android.content.AttributionSource;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.blerssi.BleRssiAdapter;
+import com.android.server.ranging.blerssi.BleRssiConfig;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+import com.google.common.collect.ImmutableSet;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class BleRssiAdapterTest {
+
+    @Mock
+    private Context mMockContext;
+    @Mock
+    private RangingInjector mMockRangingInjector;
+    @Mock
+    private BluetoothAdapter mMockBluetoothAdapter;
+    @Mock
+    private DistanceMeasurementManager mMockDistanceMeasurementManager;
+    @Mock
+    private DistanceMeasurementSession mMockDistanceMeasurementSession;
+    @Mock
+    private RangingDevice mMockRangingDevice;
+    @Mock
+    private RangingSessionConfig.TechnologyConfig mMockTechnologyConfig;
+    @Mock
+    private com.android.server.ranging.RangingAdapter.Callback mMockCallback;
+    @Mock
+    private AlarmManager mMockAlarmManager;
+    @Mock
+    private BluetoothManager mMockBluetoothManager;
+
+    @Mock
+    private PackageManager mMockPackageManager;
+    @Mock
+    private AttributionSource mMockAttributionSource;
+    @Mock
+    private BluetoothDevice mMockBluetoothDevice;
+
+    @Mock
+    private BleRssiConfig mMockBleRssiConfig;
+
+    @Mock
+    private SessionConfig mMockSessionConfig;
+    @Mock
+    private BleRssiRangingParams mMockRangingParams;
+
+    private final DataNotificationConfig mDataNotificationConfig =
+            new DataNotificationConfig.Builder().build();
+
+    private BleRssiAdapter mBleRssiAdapter;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getSystemService(BluetoothManager.class)).thenReturn(
+                mMockBluetoothManager);
+        when(mMockContext.getSystemService(BluetoothAdapter.class)).thenReturn(
+                mMockBluetoothAdapter);
+        when(mMockBluetoothAdapter.getDistanceMeasurementManager()).thenReturn(
+                mMockDistanceMeasurementManager);
+        when(mMockContext.getSystemService(AlarmManager.class)).thenReturn(mMockAlarmManager);
+        when(mMockContext.getSystemService(PackageManager.class)).thenReturn(mMockPackageManager);
+        when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
+        when(mMockPackageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)).thenReturn(
+                true);
+        when(mMockBluetoothManager.getAdapter()).thenReturn(mMockBluetoothAdapter);
+        when(mMockBluetoothAdapter.getRemoteDevice(anyString())).thenReturn(mMockBluetoothDevice);
+        when(mMockBleRssiConfig.getRangingParams()).thenReturn(mMockRangingParams);
+        when(mMockBleRssiConfig.getPeerDevice()).thenReturn(mMockRangingDevice);
+        when(mMockBleRssiConfig.getSessionConfig()).thenReturn(mMockSessionConfig);
+        when(mMockSessionConfig.getDataNotificationConfig()).thenReturn(mDataNotificationConfig);
+        when(mMockRangingParams.getPeerBluetoothAddress()).thenReturn("mockAddress");
+        when(mMockAttributionSource.getUid()).thenReturn(100);
+        when(mMockAttributionSource.getPackageName()).thenReturn("TestPkgName");
+        when(mMockRangingInjector.isForegroundAppOrService(anyInt(), anyString())).thenReturn(true);
+        RangingInjector.setInstance(mMockRangingInjector);
+        when(mMockRangingInjector.isRangingTechnologyEnabled(any())).thenReturn(true);
+        mBleRssiAdapter = new BleRssiAdapter(mMockContext, mMockRangingInjector);
+    }
+
+    @Test
+    public void testStartStop_ValidConfig() {
+        mBleRssiAdapter.start(mMockBleRssiConfig, null, mMockCallback);
+
+        verify(mMockDistanceMeasurementManager, times(1)).startMeasurementSession(any(), any(),
+                any());
+        verify(mMockCallback, times(1)).onStarted(ImmutableSet.of(mMockRangingDevice));
+
+        mBleRssiAdapter.setSession(mMockDistanceMeasurementSession);
+        mBleRssiAdapter.stop();
+
+        verify(mMockDistanceMeasurementSession, times(1)).stopSession();
+    }
+
+    @Test
+    public void testStart_InvalidConfig() {
+
+        // When
+        mBleRssiAdapter.start(mMockTechnologyConfig, null, mMockCallback);
+
+        // Then
+        verify(mMockCallback, never()).onStarted(any());
+        verify(mMockDistanceMeasurementManager, never()).startMeasurementSession(any(), any(),
+                any());
+    }
+
+    @Test
+    public void testStop_WhenNotStarted() {
+        // Given
+        // Not starting the adapter
+
+        // When
+        mBleRssiAdapter.stop();
+
+        // Then
+        verify(mMockDistanceMeasurementSession, never()).stopSession();
+    }
+
+    @Test
+    public void testAppMovingBackgroundForeground() {
+        mBleRssiAdapter.start(mMockBleRssiConfig, mMockAttributionSource, mMockCallback);
+
+        assertEquals(mBleRssiAdapter.getDataNotificationManager().getCurrentConfig()
+                .getNotificationConfigType(), NOTIFICATION_CONFIG_ENABLE);
+
+        verify(mMockCallback, times(1)).onStarted(eq(ImmutableSet.of(mMockRangingDevice)));
+
+        mBleRssiAdapter.appMovedToBackground();
+
+        assertEquals(mBleRssiAdapter.getDataNotificationManager().getCurrentConfig()
+                .getNotificationConfigType(), NOTIFICATION_CONFIG_DISABLE);
+
+        mBleRssiAdapter.appMovedToForeground();
+
+        assertEquals(mBleRssiAdapter.getDataNotificationManager().getCurrentConfig()
+                .getNotificationConfigType(), NOTIFICATION_CONFIG_ENABLE);
+
+        mBleRssiAdapter.stop();
+    }
+
+    @Test
+    public void testAppInBackgroundTimeout() {
+        // Given
+        mBleRssiAdapter.start(mMockBleRssiConfig, mMockAttributionSource, mMockCallback);
+        mBleRssiAdapter.setSession(mMockDistanceMeasurementSession);
+
+        verify(mMockCallback, times(1)).onStarted(eq(ImmutableSet.of(mMockRangingDevice)));
+        // When
+        mBleRssiAdapter.appInBackgroundTimeout();
+
+        // Then
+        verify(mMockDistanceMeasurementSession, times(1)).stopSession();
+    }
+
+    @Test
+    public void testDistanceMeasurementCallback_OnResult() {
+        // Given
+        DistanceMeasurementResult mockResult = mock(DistanceMeasurementResult.class);
+        when(mockResult.getResultMeters()).thenReturn(1.0);
+        //when(mockResult.getMeasurementTimestampNanos()).thenReturn(1000L);
+        mBleRssiAdapter.start(mMockBleRssiConfig, null, mMockCallback);
+
+        // When
+        mBleRssiAdapter.mDistanceMeasurementCallback.onResult(mMockBluetoothDevice, mockResult);
+
+        // Then
+        verify(mMockCallback, times(1)).onRangingData(any(), any());
+    }
+
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/blerssi/BleRssiCapabilitiesAdapterTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/blerssi/BleRssiCapabilitiesAdapterTest.java
new file mode 100644
index 00000000..472af553
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/blerssi/BleRssiCapabilitiesAdapterTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.blerssi;
+
+import static android.ranging.RangingCapabilities.DISABLED_USER;
+import static android.ranging.RangingCapabilities.ENABLED;
+import static android.ranging.RangingCapabilities.NOT_SUPPORTED;
+
+import static junit.framework.Assert.assertEquals;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.content.Context;
+import android.content.pm.PackageManager;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.CapabilitiesProvider;
+import com.android.server.ranging.blerssi.BleRssiCapabilitiesAdapter;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class BleRssiCapabilitiesAdapterTest {
+
+    @Mock
+    private Context mMockContext;
+
+    @Mock
+    private CapabilitiesProvider.TechnologyAvailabilityListener mMockListener;
+    @Mock
+    private PackageManager mMockPackageManager;
+    @Mock
+    private BluetoothManager mMockBluetoothManager;
+    private BleRssiCapabilitiesAdapter mAdapter;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
+        when(mMockPackageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)).thenReturn(
+                true);
+        when(mMockContext.getSystemService(BluetoothManager.class)).thenReturn(
+                mMockBluetoothManager);
+        mAdapter = new BleRssiCapabilitiesAdapter(mMockContext, mMockListener);
+    }
+
+    @Test
+    public void testBleRssiEnabled() {
+        BluetoothAdapter bluetoothAdapter = mock(BluetoothAdapter.class);
+        when(mMockBluetoothManager.getAdapter()).thenReturn(bluetoothAdapter);
+        when(bluetoothAdapter.getState()).thenReturn(BluetoothAdapter.STATE_ON);
+
+        int availability = mAdapter.getAvailability();
+        assertEquals(availability, ENABLED);
+    }
+
+    @Test
+    public void testBleRssiDisabled() {
+        BluetoothAdapter bluetoothAdapter = mock(BluetoothAdapter.class);
+        when(mMockBluetoothManager.getAdapter()).thenReturn(bluetoothAdapter);
+        when(bluetoothAdapter.getState()).thenReturn(BluetoothAdapter.STATE_OFF);
+
+        int availability = mAdapter.getAvailability();
+        assertEquals(availability, DISABLED_USER);
+    }
+
+    @Test
+    public void testBleRssiNotSupported() {
+        when(mMockContext.getSystemService(BluetoothManager.class)).thenReturn(null);
+        BleRssiCapabilitiesAdapter adapter = new BleRssiCapabilitiesAdapter(mMockContext,
+                mMockListener);
+
+        int availability = adapter.getAvailability();
+        assertEquals(availability, NOT_SUPPORTED);
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/blerssi/BleRssiConfigTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/blerssi/BleRssiConfigTest.java
new file mode 100644
index 00000000..5a7909c0
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/blerssi/BleRssiConfigTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.blerssi;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+
+import static junit.framework.Assert.assertEquals;
+
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.blerssi.BleRssiConfig;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class BleRssiConfigTest {
+
+    @Test
+    public void testBleRssiConfig() {
+        BleRssiRangingParams bleRssiRangingParams = new BleRssiRangingParams.Builder(
+                "AA:BB:CC:AA:BB:CC").build();
+        SessionConfig sessionConfig = new SessionConfig.Builder().build();
+        RangingDevice rangingDevice = new RangingDevice.Builder().build();
+
+        BleRssiConfig config = new BleRssiConfig(
+                DEVICE_ROLE_RESPONDER,
+                bleRssiRangingParams,
+                sessionConfig,
+                rangingDevice);
+
+        assertEquals(config.getDeviceRole(), DEVICE_ROLE_RESPONDER);
+        assertEquals(config.getRangingParams(), bleRssiRangingParams);
+        assertEquals(config.getSessionConfig(), sessionConfig);
+        assertEquals(config.getPeerDevice(), rangingDevice);
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsAdapterTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsAdapterTest.java
new file mode 100644
index 00000000..638ef136
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsAdapterTest.java
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.cs;
+
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_DISABLE;
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_ENABLE;
+
+import static junit.framework.Assert.assertEquals;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.AlarmManager;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.DistanceMeasurementManager;
+import android.bluetooth.le.DistanceMeasurementResult;
+import android.bluetooth.le.DistanceMeasurementSession;
+import android.content.AttributionSource;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.os.CancellationSignal;
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.ble.cs.BleCsRangingParams;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.cs.CsAdapter;
+import com.android.server.ranging.cs.CsConfig;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+import com.google.common.collect.ImmutableSet;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class CsAdapterTest {
+
+    @Mock
+    private Context mMockContext;
+    @Mock
+    private RangingInjector mMockRangingInjector;
+    @Mock
+    private BluetoothAdapter mMockBluetoothAdapter;
+    @Mock
+    private DistanceMeasurementManager mMockDistanceMeasurementManager;
+    @Mock
+    private DistanceMeasurementSession mMockDistanceMeasurementSession;
+    @Mock
+    private RangingDevice mMockRangingDevice;
+    @Mock
+    private RangingSessionConfig.TechnologyConfig mMockTechnologyConfig;
+    @Mock
+    private com.android.server.ranging.RangingAdapter.Callback mMockCallback;
+    @Mock
+    private AlarmManager mMockAlarmManager;
+    @Mock
+    private BluetoothManager mMockBluetoothManager;
+
+    @Mock
+    private PackageManager mMockPackageManager;
+    @Mock
+    private AttributionSource mMockAttributionSource;
+    @Mock
+    private BluetoothDevice mMockBluetoothDevice;
+
+    @Mock
+    private CsConfig mMockCsConfig;
+
+    @Mock
+    private SessionConfig mMockSessionConfig;
+    @Mock
+    private BleCsRangingParams mMockRangingParams;
+    @Mock
+    private CancellationSignal mCancellationSignal;
+
+    private final DataNotificationConfig mDataNotificationConfig =
+            new DataNotificationConfig.Builder().build();
+
+    private CsAdapter mCsAdapter;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getSystemService(BluetoothManager.class)).thenReturn(
+                mMockBluetoothManager);
+        when(mMockContext.getSystemService(BluetoothAdapter.class)).thenReturn(
+                mMockBluetoothAdapter);
+        when(mMockBluetoothAdapter.getDistanceMeasurementManager()).thenReturn(
+                mMockDistanceMeasurementManager);
+        when(mMockDistanceMeasurementManager.startMeasurementSession(any(), any(), any()))
+                .thenReturn(mCancellationSignal);
+        when(mMockContext.getSystemService(AlarmManager.class)).thenReturn(mMockAlarmManager);
+        when(mMockContext.getSystemService(PackageManager.class)).thenReturn(mMockPackageManager);
+        when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
+        when(mMockPackageManager.hasSystemFeature(
+                PackageManager.FEATURE_BLUETOOTH_LE_CHANNEL_SOUNDING)).thenReturn(true);
+        when(mMockBluetoothManager.getAdapter()).thenReturn(mMockBluetoothAdapter);
+        when(mMockBluetoothAdapter.getRemoteDevice(anyString())).thenReturn(mMockBluetoothDevice);
+        when(mMockCsConfig.getRangingParams()).thenReturn(mMockRangingParams);
+        when(mMockCsConfig.getPeerDevice()).thenReturn(mMockRangingDevice);
+        when(mMockCsConfig.getSessionConfig()).thenReturn(mMockSessionConfig);
+        when(mMockRangingParams.getSecurityLevel()).thenReturn(1);
+        when(mMockSessionConfig.getDataNotificationConfig()).thenReturn(mDataNotificationConfig);
+        when(mMockRangingParams.getPeerBluetoothAddress()).thenReturn("mockAddress");
+        when(mMockAttributionSource.getUid()).thenReturn(100);
+        when(mMockAttributionSource.getPackageName()).thenReturn("TestPkgName");
+        when(mMockRangingInjector.isForegroundAppOrService(anyInt(), anyString())).thenReturn(true);
+        RangingInjector.setInstance(mMockRangingInjector);
+        when(mMockRangingInjector.isRangingTechnologyEnabled(any())).thenReturn(true);
+        mCsAdapter = new CsAdapter(mMockContext, mMockRangingInjector);
+    }
+
+    @Test
+    public void testStartStop_ValidConfig() {
+        mCsAdapter.start(mMockCsConfig, null, mMockCallback);
+
+        verify(mMockDistanceMeasurementManager, times(1)).startMeasurementSession(any(), any(),
+                any());
+        verify(mMockCallback, times(1)).onStarted(ImmutableSet.of(mMockRangingDevice));
+
+        mCsAdapter.setSession(mMockDistanceMeasurementSession);
+        mCsAdapter.stop();
+
+        verify(mMockDistanceMeasurementSession, times(1)).stopSession();
+        verify(mCancellationSignal, never()).cancel();
+    }
+
+    @Test
+    public void testStartStopWhenStarting_ValidConfig() {
+        mCsAdapter.start(mMockCsConfig, null, mMockCallback);
+
+        verify(mMockDistanceMeasurementManager, times(1)).startMeasurementSession(any(), any(),
+                any());
+        verify(mMockCallback, times(1)).onStarted(ImmutableSet.of(mMockRangingDevice));
+
+        mCsAdapter.stop();
+
+        verify(mCancellationSignal, times(1)).cancel();
+        verify(mMockDistanceMeasurementSession, never()).stopSession();
+    }
+
+    @Test
+    public void testStart_InvalidConfig() {
+
+        mCsAdapter.start(mMockTechnologyConfig, null, mMockCallback);
+
+        verify(mMockCallback, never()).onStarted(any());
+        verify(mMockDistanceMeasurementManager, never()).startMeasurementSession(any(), any(),
+                any());
+    }
+
+    @Test
+    public void testStop_WhenNotStarted() {
+        mCsAdapter.stop();
+        verify(mMockDistanceMeasurementSession, never()).stopSession();
+    }
+
+    @Test
+    public void testAppMovingBackgroundForeground() {
+        mCsAdapter.start(mMockCsConfig, mMockAttributionSource, mMockCallback);
+
+        assertEquals(mCsAdapter.getDataNotificationManager().getCurrentConfig()
+                .getNotificationConfigType(), NOTIFICATION_CONFIG_ENABLE);
+
+        verify(mMockCallback, times(1)).onStarted(ImmutableSet.of(mMockRangingDevice));
+
+        mCsAdapter.appMovedToBackground();
+
+        assertEquals(mCsAdapter.getDataNotificationManager().getCurrentConfig()
+                .getNotificationConfigType(), NOTIFICATION_CONFIG_DISABLE);
+
+        mCsAdapter.appMovedToForeground();
+
+        assertEquals(mCsAdapter.getDataNotificationManager().getCurrentConfig()
+                .getNotificationConfigType(), NOTIFICATION_CONFIG_ENABLE);
+
+        mCsAdapter.stop();
+    }
+
+    @Test
+    public void testAppInBackgroundTimeout() {
+        mCsAdapter.start(mMockCsConfig, mMockAttributionSource, mMockCallback);
+        mCsAdapter.setSession(mMockDistanceMeasurementSession);
+
+        verify(mMockCallback, times(1)).onStarted(ImmutableSet.of(mMockRangingDevice));
+
+        mCsAdapter.appInBackgroundTimeout();
+        verify(mMockDistanceMeasurementSession, times(1)).stopSession();
+    }
+
+    @Test
+    public void testDistanceMeasurementCallback_OnResult() {
+        DistanceMeasurementResult mockResult = mock(DistanceMeasurementResult.class);
+        when(mockResult.getResultMeters()).thenReturn(1.0);
+        //when(mockResult.getMeasurementTimestampNanos()).thenReturn(1000L);
+        mCsAdapter.start(mMockCsConfig, null, mMockCallback);
+        mCsAdapter.mDistanceMeasurementCallback.onResult(mMockBluetoothDevice, mockResult);
+
+        verify(mMockCallback, times(1)).onRangingData(any(), any());
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsCapabilitiesAdapterTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsCapabilitiesAdapterTest.java
new file mode 100644
index 00000000..63058fbd
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsCapabilitiesAdapterTest.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.cs;
+
+import static android.ranging.RangingCapabilities.DISABLED_USER;
+import static android.ranging.RangingCapabilities.ENABLED;
+import static android.ranging.RangingCapabilities.NOT_SUPPORTED;
+
+import static junit.framework.Assert.assertEquals;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.content.Context;
+import android.content.pm.PackageManager;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.CapabilitiesProvider;
+import com.android.server.ranging.blerssi.BleRssiCapabilitiesAdapter;
+import com.android.server.ranging.cs.CsCapabilitiesAdapter;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class CsCapabilitiesAdapterTest {
+
+    @Mock
+    private Context mMockContext;
+
+    @Mock
+    private CapabilitiesProvider.TechnologyAvailabilityListener mMockListener;
+    @Mock
+    private PackageManager mMockPackageManager;
+    @Mock
+    private BluetoothManager mMockBluetoothManager;
+    private CsCapabilitiesAdapter mAdapter;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
+        when(mMockPackageManager.hasSystemFeature(
+                PackageManager.FEATURE_BLUETOOTH_LE_CHANNEL_SOUNDING)).thenReturn(true);
+        when(mMockContext.getSystemService(BluetoothManager.class)).thenReturn(
+                mMockBluetoothManager);
+        mAdapter = new CsCapabilitiesAdapter(mMockContext, mMockListener);
+    }
+
+    @Test
+    public void testBleCsEnabled() {
+        BluetoothAdapter bluetoothAdapter = mock(BluetoothAdapter.class);
+        when(mMockBluetoothManager.getAdapter()).thenReturn(bluetoothAdapter);
+        when(bluetoothAdapter.getState()).thenReturn(BluetoothAdapter.STATE_ON);
+
+        int availability = mAdapter.getAvailability();
+        assertEquals(availability, ENABLED);
+    }
+
+    @Test
+    public void testBleCsDisabled() {
+        BluetoothAdapter bluetoothAdapter = mock(BluetoothAdapter.class);
+        when(mMockBluetoothManager.getAdapter()).thenReturn(bluetoothAdapter);
+        when(bluetoothAdapter.getState()).thenReturn(BluetoothAdapter.STATE_OFF);
+
+        int availability = mAdapter.getAvailability();
+        assertEquals(availability, DISABLED_USER);
+    }
+
+    @Test
+    public void testBleCsNotSupported() {
+        when(mMockContext.getSystemService(BluetoothManager.class)).thenReturn(null);
+        BleRssiCapabilitiesAdapter adapter = new BleRssiCapabilitiesAdapter(mMockContext,
+                mMockListener);
+
+        int availability = adapter.getAvailability();
+        assertEquals(availability, NOT_SUPPORTED);
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsConfigSelectorTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsConfigSelectorTest.java
new file mode 100644
index 00000000..bae50182
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsConfigSelectorTest.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.cs;
+
+import static android.ranging.ble.cs.BleCsRangingCapabilities.CS_SECURITY_LEVEL_FOUR;
+import static android.ranging.ble.cs.BleCsRangingCapabilities.CS_SECURITY_LEVEL_ONE;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
+import static com.android.server.ranging.cs.CsConfig.CS_UPDATE_RATE_DURATIONS;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.when;
+
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.util.Pair;
+import android.util.Range;
+
+import com.android.server.ranging.RangingEngine.ConfigSelectionException;
+import com.android.server.ranging.cs.CsConfig;
+import com.android.server.ranging.cs.CsConfigSelector;
+import com.android.server.ranging.cs.CsOobCapabilities;
+import com.android.server.ranging.cs.CsOobConfig;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.SetConfigurationMessage.TechnologyOobConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterators;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.time.Duration;
+
+@RunWith(MockitoJUnitRunner.class)
+public class CsConfigSelectorTest {
+
+    private CsConfigSelector mSelector;
+
+    private @Mock SessionConfig mMockSessionConfig;
+    private @Mock OobInitiatorRangingConfig mMockOobConfig;
+    private @Mock BleCsRangingCapabilities mMockCapabilities;
+    private @Mock CsOobCapabilities mMockOobCapabilities;
+    private @Mock CapabilityResponseMessage mMockCapabilityResponse;
+    private @Mock RangingDevice mMockPeerDevice;
+
+    @Before
+    public void setup() {
+        when(mMockCapabilities.getSupportedSecurityLevels())
+                .thenReturn(ImmutableSet.of(CS_SECURITY_LEVEL_ONE, CS_SECURITY_LEVEL_FOUR));
+        when(mMockOobConfig.getRangingIntervalRange())
+                .thenReturn(Range.create(
+                        CS_UPDATE_RATE_DURATIONS.get(UPDATE_RATE_NORMAL),
+                        CS_UPDATE_RATE_DURATIONS.get(UPDATE_RATE_NORMAL)));
+
+        when(mMockCapabilityResponse.getCsCapabilities()).thenReturn(mMockOobCapabilities);
+        when(mMockOobCapabilities.getBluetoothAddress()).thenReturn("AC:37:43:BC:A9:28");
+    }
+
+    @Test
+    public void constructor_withCapableConfig() throws ConfigSelectionException {
+        new CsConfigSelector(mMockSessionConfig, mMockOobConfig, mMockCapabilities);
+    }
+
+    @Test(expected = ConfigSelectionException.class)
+    public void constructorFails_whenIncapableOfConfiguredSecurityLevel()
+            throws ConfigSelectionException {
+
+        when(mMockCapabilities.getSupportedSecurityLevels()).thenReturn(ImmutableSet.of());
+        new CsConfigSelector(mMockSessionConfig, mMockOobConfig, mMockCapabilities);
+    }
+
+    @Test(expected = ConfigSelectionException.class)
+    public void constructorFails_whenIncapableOfConfiguredRangingInterval()
+            throws ConfigSelectionException {
+
+        when(mMockOobConfig.getRangingIntervalRange())
+                .thenReturn(Range.create(Duration.ofMillis(333), Duration.ofMillis(334)));
+        new CsConfigSelector(mMockSessionConfig, mMockOobConfig, mMockCapabilities);
+    }
+
+    @Test
+    public void addPeerCapabilities_addsPeerToConfigure() throws ConfigSelectionException {
+        mSelector = new CsConfigSelector(
+                mMockSessionConfig, mMockOobConfig, mMockCapabilities);
+
+
+        mSelector.addPeerCapabilities(mMockPeerDevice, mMockCapabilityResponse);
+
+        assertTrue(mSelector.hasPeersToConfigure());
+    }
+
+    @Test(expected = ConfigSelectionException.class)
+    public void addPeerCapabilities_failsWhenCsCapabilitiesNull() throws ConfigSelectionException {
+        mSelector = new CsConfigSelector(
+                mMockSessionConfig, mMockOobConfig, mMockCapabilities);
+        when(mMockCapabilityResponse.getCsCapabilities()).thenReturn(null);
+
+        mSelector.addPeerCapabilities(mMockPeerDevice, mMockCapabilityResponse);
+    }
+
+    @Test
+    public void selectConfigs_selectsCompatibleConfig() throws ConfigSelectionException {
+        mSelector = new CsConfigSelector(
+                mMockSessionConfig, mMockOobConfig, mMockCapabilities);
+
+        mSelector.addPeerCapabilities(mMockPeerDevice, mMockCapabilityResponse);
+
+        Pair<ImmutableSet<TechnologyConfig>, ImmutableMap<RangingDevice, TechnologyOobConfig>>
+                configs = mSelector.selectConfigs();
+
+        assertNotNull(configs);
+        assertNotNull(configs.first);
+        assertNotNull(configs.second);
+        assertFalse(configs.first.isEmpty());
+        assertFalse(configs.second.isEmpty());
+
+        CsConfig csConfig = (CsConfig) Iterators.getOnlyElement(configs.first.iterator());
+        assertEquals("AC:37:43:BC:A9:28", csConfig.getRangingParams().getPeerBluetoothAddress());
+        assertEquals(UPDATE_RATE_NORMAL, csConfig.getRangingParams().getRangingUpdateRate());
+        assertEquals(CS_SECURITY_LEVEL_ONE, csConfig.getRangingParams().getSecurityLevel());
+
+        CsOobConfig peerConfig = (CsOobConfig) configs.second.get(mMockPeerDevice);
+        assertNotNull(peerConfig);
+    }
+
+    @Test
+    public void selectConfigs_selectsSecureSecurityLevel_whenConfigured()
+            throws ConfigSelectionException {
+
+        when(mMockOobConfig.getSecurityLevel())
+                .thenReturn(OobInitiatorRangingConfig.SECURITY_LEVEL_SECURE);
+
+        mSelector = new CsConfigSelector(mMockSessionConfig, mMockOobConfig, mMockCapabilities);
+        mSelector.addPeerCapabilities(mMockPeerDevice, mMockCapabilityResponse);
+
+        Pair<ImmutableSet<TechnologyConfig>, ImmutableMap<RangingDevice, TechnologyOobConfig>>
+                configs = mSelector.selectConfigs();
+
+        CsConfig csConfig = (CsConfig) Iterators.getOnlyElement(configs.first.iterator());
+        assertEquals(CS_SECURITY_LEVEL_FOUR, csConfig.getRangingParams().getSecurityLevel());
+    }
+
+    @Test
+    public void selectConfigs_selectsFrequentUpdateRate_whenConfigured()
+            throws ConfigSelectionException {
+
+        when(mMockOobConfig.getRangingIntervalRange())
+                .thenReturn(Range.create(
+                        CS_UPDATE_RATE_DURATIONS.get(UPDATE_RATE_FREQUENT),
+                        CS_UPDATE_RATE_DURATIONS.get(UPDATE_RATE_FREQUENT)));
+
+        mSelector = new CsConfigSelector(
+                mMockSessionConfig, mMockOobConfig, mMockCapabilities);
+        mSelector.addPeerCapabilities(mMockPeerDevice, mMockCapabilityResponse);
+
+        Pair<ImmutableSet<TechnologyConfig>, ImmutableMap<RangingDevice, TechnologyOobConfig>>
+                configs = mSelector.selectConfigs();
+        CsConfig csConfig = (CsConfig) Iterators.getOnlyElement(configs.first.iterator());
+
+        assertEquals(UPDATE_RATE_FREQUENT, csConfig.getRangingParams().getRangingUpdateRate());
+    }
+
+    @Test
+    public void selectConfigs_selectsInfrequentUpdateRate_whenConfigured()
+            throws ConfigSelectionException {
+
+        when(mMockOobConfig.getRangingIntervalRange()).thenReturn(
+                Range.create(
+                        CS_UPDATE_RATE_DURATIONS.get(UPDATE_RATE_INFREQUENT),
+                        CS_UPDATE_RATE_DURATIONS.get(UPDATE_RATE_INFREQUENT)));
+
+        mSelector = new CsConfigSelector(
+                mMockSessionConfig, mMockOobConfig, mMockCapabilities);
+        mSelector.addPeerCapabilities(mMockPeerDevice, mMockCapabilityResponse);
+
+        Pair<ImmutableSet<TechnologyConfig>, ImmutableMap<RangingDevice, TechnologyOobConfig>>
+                configs = mSelector.selectConfigs();
+        CsConfig csConfig = (CsConfig) configs.first.iterator().next();
+
+        assertEquals(UPDATE_RATE_INFREQUENT, csConfig.getRangingParams().getRangingUpdateRate());
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsConfigTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsConfigTest.java
new file mode 100644
index 00000000..7a19441b
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/cs/CsConfigTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.cs;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+import static android.ranging.ble.cs.BleCsRangingCapabilities.CS_SECURITY_LEVEL_FOUR;
+import static android.ranging.ble.cs.BleCsRangingParams.LOCATION_TYPE_INDOOR;
+import static android.ranging.ble.cs.BleCsRangingParams.SIGHT_TYPE_LINE_OF_SIGHT;
+
+import static junit.framework.Assert.assertEquals;
+
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.ble.cs.BleCsRangingParams;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.cs.CsConfig;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class CsConfigTest {
+
+    @Test
+    public void testCsConfig() {
+        BleCsRangingParams bleCsRangingParams = new BleCsRangingParams.Builder("AA:BB:CC:AA:BB:CC")
+                .setSightType(SIGHT_TYPE_LINE_OF_SIGHT)
+                .setLocationType(LOCATION_TYPE_INDOOR)
+                .setSecurityLevel(CS_SECURITY_LEVEL_FOUR)
+                .build();
+
+        SessionConfig sessionConfig = new SessionConfig.Builder().build();
+        RangingDevice rangingDevice = new RangingDevice.Builder().build();
+
+        CsConfig config = new CsConfig(
+                bleCsRangingParams,
+                sessionConfig,
+                rangingDevice);
+
+        assertEquals(config.getDeviceRole(), DEVICE_ROLE_INITIATOR);
+        assertEquals(config.getRangingParams(), bleCsRangingParams);
+        assertEquals(config.getSessionConfig(), sessionConfig);
+        assertEquals(config.getPeerDevice(), rangingDevice);
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/fusion/DataFusersTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/fusion/DataFusersTest.java
new file mode 100644
index 00000000..cdc3fded
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/fusion/DataFusersTest.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.fusion;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.ranging.RangingData;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.fusion.DataFusers;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.experimental.runners.Enclosed;
+import org.junit.runner.RunWith;
+
+import java.util.Optional;
+import java.util.Set;
+
+@RunWith(Enclosed.class)
+public class DataFusersTest {
+    @SmallTest
+    public static class PassthroughDataFuserTest {
+        private DataFusers.PassthroughDataFuser mFuser;
+
+        @Before
+        public void setup() {
+            mFuser = new DataFusers.PassthroughDataFuser();
+        }
+
+        @Test
+        public void fuse_reportsProvidedData() {
+            RangingData mockData = mock(RangingData.class);
+            Optional<RangingData> fused = mFuser.fuse(mockData, Set.of(RangingTechnology.UWB));
+            assertThat(fused).isPresent();
+            assertThat(fused.get()).isEqualTo(mockData);
+        }
+    }
+
+    @SmallTest
+    public static class PreferentialDataFuserTest {
+        private DataFusers.PreferentialDataFuser mFuser;
+
+        @Before
+        public void setup() {
+            mFuser = new DataFusers.PreferentialDataFuser(RangingTechnology.UWB);
+        }
+
+        @Test
+        public void fuse_reportsDataFromPreferredTechnologyWhenPreferredActive() {
+            RangingData mockData = mock(RangingData.class);
+            when(mockData.getRangingTechnology()).thenReturn(RangingTechnology.UWB.getValue());
+            Optional<RangingData> fused =
+                    mFuser.fuse(mockData, Set.of(RangingTechnology.UWB, RangingTechnology.CS));
+            assertThat(fused).isPresent();
+            assertThat(fused.get()).isEqualTo(mockData);
+        }
+
+        @Test
+        public void fuse_ignoresDataFromOtherTechnologiesWhenPreferredActive() {
+            RangingData mockData = mock(RangingData.class);
+            when(mockData.getRangingTechnology()).thenReturn(RangingTechnology.CS.getValue());
+            Optional<RangingData> fused =
+                    mFuser.fuse(mockData, Set.of(RangingTechnology.UWB, RangingTechnology.CS));
+            assertThat(fused).isEmpty();
+        }
+
+        @Test
+        public void fuse_reportsDataFromAnyTechnologyWhenPreferredInactive() {
+            Set<RangingTechnology> active = Set.of(
+                    RangingTechnology.CS, RangingTechnology.RTT, RangingTechnology.RSSI);
+
+            RangingData mockCsData = mock(RangingData.class);
+            when(mockCsData.getRangingTechnology()).thenReturn(RangingTechnology.CS.getValue());
+            Optional<RangingData> fused1 = mFuser.fuse(mockCsData, active);
+            assertThat(fused1).isPresent();
+            assertThat(fused1.get()).isEqualTo(mockCsData);
+
+            RangingData mockRttData = mock(RangingData.class);
+            when(mockRttData.getRangingTechnology()).thenReturn(RangingTechnology.RTT.getValue());
+            Optional<RangingData> fused2 = mFuser.fuse(mockRttData, active);
+            assertThat(fused2).isPresent();
+            assertThat(fused2.get()).isEqualTo(mockRttData);
+
+            RangingData mockRssiData = mock(RangingData.class);
+            when(mockRssiData.getRangingTechnology()).thenReturn(RangingTechnology.CS.getValue());
+            Optional<RangingData> fused3 = mFuser.fuse(mockRssiData, active);
+            assertThat(fused3).isPresent();
+            assertThat(fused3.get()).isEqualTo(mockRssiData);
+        }
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/fusion/FilteringFusionEngineTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/fusion/FilteringFusionEngineTest.java
new file mode 100644
index 00000000..b6ae6c65
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/fusion/FilteringFusionEngineTest.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.fusion;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.ranging.RangingData;
+import android.ranging.RangingManager;
+import android.ranging.RangingMeasurement;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.fusion.FilteringFusionEngine;
+import com.android.server.ranging.fusion.FusionEngine;
+import com.android.uwb.fusion.UwbFilterEngine;
+import com.android.uwb.fusion.math.SphericalVector;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Answers;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class FilteringFusionEngineTest {
+    @Rule
+    public final MockitoRule mMockito = MockitoJUnit.rule();
+
+    private @Mock(answer = Answers.RETURNS_DEEP_STUBS) RangingInjector mMockInjector;
+    private @Mock FusionEngine.DataFuser mMockDataFuser;
+    private @Mock FusionEngine.Callback mMockCallback;
+
+    private FilteringFusionEngine mSpyEngine;
+
+    private Map<RangingTechnology, UwbFilterEngine> mockFiltersForTechnologies(
+            Set<RangingTechnology> technologies
+    ) {
+        Map<RangingTechnology, UwbFilterEngine> mockFilters = new HashMap<>();
+        for (RangingTechnology technology : technologies) {
+            UwbFilterEngine mockEngine = mock(UwbFilterEngine.class, RETURNS_DEEP_STUBS);
+            mockFilters.put(technology, mockEngine);
+            when(mSpyEngine.createFilter(eq(technology))).thenReturn(mockEngine);
+        }
+        return mockFilters;
+    }
+
+    @Before
+    public void setup() {
+        mSpyEngine = spy(new FilteringFusionEngine(mMockDataFuser, true, mMockInjector));
+    }
+
+    @Test
+    public void addDataSource_createsFilterForTechnology() {
+        mockFiltersForTechnologies(Set.of(RangingTechnology.UWB));
+        mSpyEngine.addDataSource(RangingTechnology.UWB);
+
+        verify(mSpyEngine).createFilter(eq(RangingTechnology.UWB));
+    }
+
+    @Test
+    public void removeDataSource_closesFilterForTechnology() {
+        Map<RangingTechnology, UwbFilterEngine> filters =
+                mockFiltersForTechnologies(Set.of(RangingTechnology.UWB));
+
+        mSpyEngine.addDataSource(RangingTechnology.UWB);
+        mSpyEngine.removeDataSource(RangingTechnology.UWB);
+
+        verify(filters.get(RangingTechnology.UWB)).close();
+    }
+
+    @Test
+    public void getDataSources_containsExactlyTechnologiesThatWereAdded() {
+        Set<RangingTechnology> technologies = Set.of(
+                RangingTechnology.UWB,
+                RangingTechnology.CS,
+                RangingTechnology.RTT);
+
+        mockFiltersForTechnologies(technologies);
+
+        for (RangingTechnology technology : technologies) {
+            mSpyEngine.addDataSource(technology);
+        }
+
+        assertThat(mSpyEngine.getDataSources()).containsExactlyElementsIn(technologies);
+    }
+
+    @Test
+    public void feed_filtersDataAndComputesNewPosition() {
+        Map<RangingTechnology, UwbFilterEngine> mockFilters =
+                mockFiltersForTechnologies(Set.of(RangingTechnology.UWB));
+
+        RangingData data = new RangingData.Builder()
+                .setRangingTechnology(RangingManager.UWB)
+                .setDistance(new RangingMeasurement.Builder().setMeasurement(1.2).build())
+                .setAzimuth(new RangingMeasurement.Builder().setMeasurement(2.3).build())
+                .setElevation(new RangingMeasurement.Builder().setMeasurement(3.4).build())
+                .setRssi(1)
+                .setTimestampMillis(1234)
+                .build();
+
+        mSpyEngine.addDataSource(RangingTechnology.UWB);
+        mSpyEngine.feed(data);
+
+        verify(mockFilters.get(RangingTechnology.UWB))
+                .add(any(SphericalVector.Annotated.class), eq(data.getTimestampMillis()));
+        verify(mockFilters.get(RangingTechnology.UWB))
+                .compute(eq(data.getTimestampMillis()));
+    }
+
+    @Test
+    public void feed_fusesDataFromMultipleTechnologies() {
+        Set<RangingTechnology> technologies = Set.of(RangingTechnology.UWB, RangingTechnology.CS);
+        mockFiltersForTechnologies(technologies);
+
+        for (RangingTechnology technology : technologies) {
+            mSpyEngine.addDataSource(technology);
+        }
+
+        mSpyEngine.start(mMockCallback);
+
+        // Feed some UWB data
+        RangingData mockFusedUwbData = mock(RangingData.class);
+        when(mMockDataFuser.fuse(any(), any())).thenReturn(Optional.of(mockFusedUwbData));
+
+        RangingData inputUwbData = new RangingData.Builder()
+                .setRangingTechnology(RangingManager.UWB)
+                .setDistance(new RangingMeasurement.Builder().setMeasurement(1.2).build())
+                .setAzimuth(new RangingMeasurement.Builder().setMeasurement(2.3).build())
+                .setElevation(new RangingMeasurement.Builder().setMeasurement(3.4).build())
+                .setRssi(1)
+                .setTimestampMillis(1234)
+                .build();
+        mSpyEngine.feed(inputUwbData);
+
+        verify(mMockDataFuser).fuse(
+                argThat(data -> data.getRangingTechnology() == RangingTechnology.UWB.getValue()
+                        && data.getTimestampMillis() == inputUwbData.getTimestampMillis()),
+                eq(technologies));
+        verify(mMockCallback).onData(eq(mockFusedUwbData));
+
+        // Feed some CS data
+        RangingData mockFusedCsData = mock(RangingData.class);
+        when(mMockDataFuser.fuse(any(), any())).thenReturn(Optional.of(mockFusedCsData));
+
+        RangingData inputCsData = new RangingData.Builder()
+                .setRangingTechnology(RangingManager.BLE_CS)
+                .setDistance(new RangingMeasurement.Builder().setMeasurement(4.5).build())
+                .setRssi(2)
+                .setTimestampMillis(2345)
+                .build();
+        mSpyEngine.feed(inputCsData);
+
+        verify(mMockDataFuser).fuse(
+                argThat(data -> data.getRangingTechnology() == RangingTechnology.CS.getValue()
+                        && data.getTimestampMillis() == inputCsData.getTimestampMillis()),
+                eq(technologies));
+        verify(mMockCallback).onData(eq(mockFusedCsData));
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CapabilityRequestMessageTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CapabilityRequestMessageTest.java
new file mode 100644
index 00000000..26e2b377
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CapabilityRequestMessageTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.CapabilityRequestMessage;
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobHeader;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class CapabilityRequestMessageTest {
+
+    private static final ImmutableSet<RangingTechnology> UWB_CS_TECH_LIST =
+            ImmutableSet.of(RangingTechnology.UWB, RangingTechnology.CS);
+    private static final ImmutableSet<RangingTechnology> UWB_TECH_ONLY_LIST =
+            ImmutableSet.of(RangingTechnology.UWB);
+    private static final byte[] uwbCsTechBitmap = new byte[]{0x3, 0x00};
+    private static final byte[] uwbTechOnlyBitmap = new byte[]{0x01, 0x00};
+    private static final OobHeader OOB_HEADER =
+            OobHeader.builder().setVersion(1).setMessageType(
+                    MessageType.CAPABILITY_REQUEST).build();
+    private static final byte[] headerBytes = new byte[]{0x1, 0x0};
+    private static final byte[] uwbCsTechMessage = Bytes.concat(headerBytes, uwbCsTechBitmap);
+    private static final byte[] uwbOnlyMessage = Bytes.concat(headerBytes, uwbTechOnlyBitmap);
+    private static final byte[] noTechsMessage = Bytes.concat(headerBytes, new byte[]{0x0, 0x0});
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        CapabilityRequestMessage capabilityRequestUwbCs =
+                CapabilityRequestMessage.builder()
+                        .setHeader(OOB_HEADER)
+                        .setRequestedRangingTechnologies(UWB_CS_TECH_LIST)
+                        .build();
+
+        CapabilityRequestMessage capabilityRequestUwbOnly =
+                CapabilityRequestMessage.builder()
+                        .setHeader(OOB_HEADER)
+                        .setRequestedRangingTechnologies(UWB_TECH_ONLY_LIST)
+                        .build();
+
+        assertThat(capabilityRequestUwbCs.toBytes()).isEqualTo(uwbCsTechMessage);
+        assertThat(capabilityRequestUwbOnly.toBytes()).isEqualTo(uwbOnlyMessage);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        CapabilityRequestMessage capabilityRequestUwbCs =
+                CapabilityRequestMessage.parseBytes(uwbCsTechMessage);
+        CapabilityRequestMessage capabilityRequestUwbOnly =
+                CapabilityRequestMessage.parseBytes(uwbOnlyMessage);
+
+        assertThat(capabilityRequestUwbCs.getRequestedRangingTechnologies())
+                .isEqualTo(UWB_CS_TECH_LIST);
+        assertThat(capabilityRequestUwbCs.getHeader()).isEqualTo(OOB_HEADER);
+        assertThat(capabilityRequestUwbOnly.getRequestedRangingTechnologies())
+                .isEqualTo(UWB_TECH_ONLY_LIST);
+        assertThat(capabilityRequestUwbOnly.getHeader()).isEqualTo(OOB_HEADER);
+    }
+
+    @Test
+    public void parseBytes_invalidSize_throwsException() throws Exception {
+        byte[] shortMessage = new byte[]{0x1};
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> CapabilityRequestMessage.parseBytes(shortMessage));
+    }
+
+    @Test
+    public void parseBytes_invalidMessageType_throwsException() throws Exception {
+        byte[] invalidMessageTypeMessageBytes =
+                CapabilityRequestMessage.builder()
+                        .setHeader(
+                                OobHeader.builder()
+                                        .setVersion(1)
+                                        .setMessageType(MessageType.SET_CONFIGURATION)
+                                        .build())
+                        .setRequestedRangingTechnologies(UWB_CS_TECH_LIST)
+                        .build()
+                        .toBytes();
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> CapabilityRequestMessage.parseBytes(invalidMessageTypeMessageBytes));
+    }
+
+    @Test
+    public void parseBytes_noTechs() throws Exception {
+        CapabilityRequestMessage capabilityRequestEmpty =
+                CapabilityRequestMessage.parseBytes(noTechsMessage);
+
+        assertThat(capabilityRequestEmpty.getRequestedRangingTechnologies()).isEmpty();
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CapabilityResponseMessageTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CapabilityResponseMessageTest.java
new file mode 100644
index 00000000..a8cbd542
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CapabilityResponseMessageTest.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import android.ranging.uwb.UwbAddress;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobHeader;
+import com.android.server.ranging.uwb.UwbOobCapabilities;
+import com.android.server.ranging.uwb.UwbOobConfig;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class CapabilityResponseMessageTest {
+
+    private static final OobHeader OOB_HEADER =
+            OobHeader.builder().setVersion(1).setMessageType(
+                    MessageType.CAPABILITY_RESPONSE).build();
+    private static final UwbAddress UWB_ADDRESS = UwbAddress.fromBytes(new byte[]{8, 9});
+    private static final ImmutableList<RangingTechnology> SUPPORTED_RANGING_TECHNOLOGIES =
+            ImmutableList.of(RangingTechnology.UWB);
+    private static final ImmutableList<RangingTechnology> RANGING_TECHNOLOGY_PRIORITY_LIST =
+            ImmutableList.of(RangingTechnology.UWB);
+    private static final UwbOobCapabilities UWB_CAPABILITIES =
+            UwbOobCapabilities.builder()
+                    .setUwbAddress(UWB_ADDRESS)
+                    .setSupportedChannels(ImmutableList.of(5, 9))
+                    .setSupportedPreambleIndexes(ImmutableList.of(1, 32))
+                    .setSupportedConfigIds(ImmutableList.of(7, 15))
+                    .setMinimumRangingIntervalMs(1000)
+                    .setMinimumSlotDurationMs(20)
+                    .setSupportedDeviceRole(
+                            ImmutableList.of(
+                                    UwbOobConfig.OobDeviceRole.INITIATOR,
+                                    UwbOobConfig.OobDeviceRole.RESPONDER))
+                    .build();
+    private static final CapabilityResponseMessage CAPABILITY_RESPONSE_MESSAGE =
+            CapabilityResponseMessage.builder()
+                    .setSupportedRangingTechnologies(SUPPORTED_RANGING_TECHNOLOGIES)
+                    .setHeader(OOB_HEADER)
+                    .setUwbCapabilities(UWB_CAPABILITIES)
+                    .setRangingTechnologiesPriority(RANGING_TECHNOLOGY_PRIORITY_LIST)
+                    .build();
+
+    private static final byte[] oobHeaderBytes =
+            new byte[]{
+                    // Version
+                    0x01,
+                    // Message type
+                    0x01,
+            };
+
+    private static final byte[] rangingTechBitmapUwb =
+            new byte[]{
+                    // No technologies set
+                    0x01, 0x00
+            };
+
+    private static final byte[] rangingTechsBitmapUnknown =
+            new byte[]{
+                    // Unknown technology set
+                    (byte) 0x80, 0x00
+            };
+
+    private static final byte[] rangingTechsBitmapUnknownAndUwb =
+            new byte[]{
+                    // Unknown and Uwb technology set
+                    (byte) 0x81, 0x00
+            };
+
+    private static final byte[] uwbCapabilityBytes =
+            new byte[]{
+                    // Ranging technology Id (UWB)
+                    0x00,
+                    // Size
+                    0x14,
+                    // Uwb Address
+                    0x08,
+                    0x09,
+                    // Supported channels bitmap
+                    0x20,
+                    0x02,
+                    0x00,
+                    0x00,
+                    // Supported preamble indexes bitmap
+                    0x01,
+                    0x00,
+                    0x00,
+                    (byte) 0x80,
+                    // Supported config ids bitmap
+                    (byte) 0x80,
+                    (byte) 0x80,
+                    0x00,
+                    0x00,
+                    // Minimum ranging interval ms
+                    (byte) 0xE8,
+                    0x03,
+                    // Minimum slot duration ms
+                    0x14,
+                    // Supported device role bitmap
+                    0x03,
+            };
+
+    private static final byte[] unknownTechnologyCapabilityBytes =
+            new byte[]{
+                    // Invalid ranging tech id
+                    0x07,
+                    // Size
+                    0x02
+            };
+
+    private static final byte[] capabilityResponseMessageUwbBytes =
+            Bytes.concat(oobHeaderBytes, rangingTechBitmapUwb, uwbCapabilityBytes);
+
+    private static final byte[] capabilityResponseMessageUnknownBytes =
+            Bytes.concat(oobHeaderBytes, rangingTechsBitmapUnknown,
+                    unknownTechnologyCapabilityBytes);
+
+    private static final byte[] capabilityResponseMessageUnknownAndUwbBytes =
+            Bytes.concat(
+                    oobHeaderBytes,
+                    rangingTechsBitmapUnknownAndUwb,
+                    unknownTechnologyCapabilityBytes,
+                    uwbCapabilityBytes);
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        assertThat(CAPABILITY_RESPONSE_MESSAGE.toBytes()).isEqualTo(
+                capabilityResponseMessageUwbBytes);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        assertThat(CapabilityResponseMessage.parseBytes(capabilityResponseMessageUwbBytes))
+                .isEqualTo(CAPABILITY_RESPONSE_MESSAGE);
+    }
+
+    @Test
+    public void toBytes_noTechnologiesSet_convertsCorrectly() throws Exception {
+        CapabilityResponseMessage capabilityResponseNoTechnologiesSet =
+                CapabilityResponseMessage.builder()
+                        .setHeader(OOB_HEADER)
+                        .setSupportedRangingTechnologies(ImmutableList.of())
+                        .build();
+        byte[] nothingSetBytes = new byte[]{0x1, 0x1, 0x0, 0x0};
+        assertThat(capabilityResponseNoTechnologiesSet.toBytes()).isEqualTo(nothingSetBytes);
+    }
+
+    @Test
+    public void parseBytes_invalidMessageSize_throws() throws Exception {
+        byte[] data = new byte[]{};
+
+        assertThrows(IllegalArgumentException.class,
+                () -> CapabilityResponseMessage.parseBytes(data));
+    }
+
+    @Test
+    public void parseBytes_invalidMessageType_throws() throws Exception {
+        byte[] invalidMessageTypeMessageBytes =
+                CapabilityResponseMessage.builder()
+                        .setHeader(
+                                OobHeader.builder()
+                                        .setVersion(1)
+                                        .setMessageType(MessageType.SET_CONFIGURATION)
+                                        .build())
+                        .setSupportedRangingTechnologies(ImmutableList.of())
+                        .build()
+                        .toBytes();
+
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> CapabilityResponseMessage.parseBytes(invalidMessageTypeMessageBytes));
+    }
+
+    @Test
+    public void parseBytes_unknownRangingTechnologyId_throwsException() throws Exception {
+        assertThrows(IllegalArgumentException.class,
+                () -> CapabilityResponseMessage
+                        .parseBytes(capabilityResponseMessageUnknownBytes));
+    }
+
+    @Test
+    public void parseBytes_unknownAndUwbRangingTechnologyIds_throwsException() throws Exception {
+        assertThrows(IllegalArgumentException.class,
+                () -> CapabilityResponseMessage
+                        .parseBytes(capabilityResponseMessageUnknownAndUwbBytes));
+    }
+
+
+    @Test
+    public void builder_invalidPriorityList_duplicates_throws() throws Exception {
+        ImmutableList<RangingTechnology> priorityList =
+                ImmutableList.of(RangingTechnology.UWB, RangingTechnology.UWB);
+
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        CapabilityResponseMessage.builder()
+                                .setHeader(OOB_HEADER)
+                                .setUwbCapabilities(UWB_CAPABILITIES)
+                                .setSupportedRangingTechnologies(SUPPORTED_RANGING_TECHNOLOGIES)
+                                .setRangingTechnologiesPriority(priorityList)
+                                .build());
+    }
+
+    @Test
+    public void builder_invalidPriorityList_mismatch_throws() throws Exception {
+        ImmutableList<RangingTechnology> priorityList = ImmutableList.of(RangingTechnology.CS);
+
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        CapabilityResponseMessage.builder()
+                                .setHeader(OOB_HEADER)
+                                .setUwbCapabilities(UWB_CAPABILITIES)
+                                .setSupportedRangingTechnologies(SUPPORTED_RANGING_TECHNOLOGIES)
+                                .setRangingTechnologiesPriority(priorityList)
+                                .build());
+    }
+
+    @Test
+    public void builder_invalidPriorityList_shouldBeEmpty_throws() throws Exception {
+        ImmutableList<RangingTechnology> priorityList = ImmutableList.of(RangingTechnology.UWB);
+
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        CapabilityResponseMessage.builder()
+                                .setHeader(OOB_HEADER)
+                                .setSupportedRangingTechnologies(SUPPORTED_RANGING_TECHNOLOGIES)
+                                .setRangingTechnologiesPriority(priorityList)
+                                .build());
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CsOobCapabilitiesTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CsOobCapabilitiesTest.java
new file mode 100644
index 00000000..001f2b7f
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CsOobCapabilitiesTest.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import com.android.server.ranging.cs.CsOobCapabilities;
+import com.android.server.ranging.cs.CsOobConfig;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class CsOobCapabilitiesTest {
+
+    private static final CsOobCapabilities CS_CAPABILITIES =
+            CsOobCapabilities.builder()
+                    .setSupportedSecurityTypes(ImmutableList.of(
+                            CsOobConfig.CsSecurityType.LEVEL_TWO,
+                            CsOobConfig.CsSecurityType.LEVEL_FOUR))
+                    .setBluetoothAddress("AC:37:43:BC:A9:28")
+                    .build();
+
+    private static final byte[] csTechHeaderBytes =
+            new byte[]{
+                    // Technology Id
+                    0x01,
+                    // Size
+                    0x09,
+            };
+
+    private static final byte[] unknownTechHeaderBytes =
+            new byte[]{
+                    // Technology Id
+                    0x09,
+                    // Size
+                    0x09,
+            };
+
+    private static final byte[] csCapabilityBytes =
+            new byte[]{
+                    // Supported Security Types
+                    0x14,
+                    // Bluetooth Address
+                    (byte) 0xAC,
+                    0x37,
+                    0x43,
+                    (byte) 0xBC,
+                    (byte) 0xA9,
+                    0x28,
+            };
+
+    private static final byte[] csCapabilityBytesUnknownSecurityType =
+            new byte[]{
+                    // Supported Security Types
+                    (byte) 0x80,
+                    // Bluetooth Address
+                    (byte) 0xAC,
+                    0x37,
+                    0x43,
+                    (byte) 0xBC,
+                    (byte) 0xA9,
+                    0x28,
+            };
+
+    private static final byte[] csCapabilityWithHeaderBytes =
+            Bytes.concat(csTechHeaderBytes, csCapabilityBytes);
+
+    private static final byte[] csCapabilityWithUnknownSecurityTypeBytes =
+            Bytes.concat(csTechHeaderBytes, csCapabilityBytesUnknownSecurityType);
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        assertThat(CS_CAPABILITIES.toBytes()).isEqualTo(csCapabilityWithHeaderBytes);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        assertThat(CsOobCapabilities.parseBytes(csCapabilityWithHeaderBytes))
+                .isEqualTo(CS_CAPABILITIES);
+    }
+
+    @Test
+    public void parseBytes_invalidSize_throws() throws Exception {
+        byte[] shortMessage = new byte[]{0x0A};
+        assertThrows(IllegalArgumentException.class,
+                () -> CsOobCapabilities.parseBytes(shortMessage));
+    }
+
+    @Test
+    public void parseBytes_mismatchedHeaderSize_throws() throws Exception {
+        byte[] mismatchedHeaderSizeBytes = Bytes.concat(csTechHeaderBytes, new byte[]{0x00, 0x05});
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> CsOobCapabilities.parseBytes(mismatchedHeaderSizeBytes));
+    }
+
+    @Test
+    public void parseBytes_invalidTechnologyId_throws() throws Exception {
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> CsOobCapabilities.parseBytes(unknownTechHeaderBytes));
+    }
+
+    @Test
+    public void constructor_invalidBluetoothAddress_throws() throws Exception {
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        CsOobCapabilities.builder()
+                                .setSupportedSecurityTypes(ImmutableList.of(
+                                        CsOobConfig.CsSecurityType.LEVEL_TWO,
+                                        CsOobConfig.CsSecurityType.LEVEL_FOUR))
+                                .setBluetoothAddress("AC:37:43BC:A9:28")
+                                .build());
+
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        CsOobCapabilities.builder()
+                                .setSupportedSecurityTypes(ImmutableList.of(
+                                        CsOobConfig.CsSecurityType.LEVEL_TWO,
+                                        CsOobConfig.CsSecurityType.LEVEL_FOUR))
+                                .setBluetoothAddress("AC:37:43:BC:A9:")
+                                .build());
+    }
+
+    @Test
+    public void parseBytes_invalidSecurityType_returnsUnknownSecurityType() throws Exception {
+        CsOobCapabilities csCapabilities =
+                CsOobCapabilities.parseBytes(csCapabilityWithUnknownSecurityTypeBytes);
+
+        assertThat(csCapabilities.getSupportedSecurityTypes()).containsExactly(
+                CsOobConfig.CsSecurityType.UNKNOWN);
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CsOobConfigTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CsOobConfigTest.java
new file mode 100644
index 00000000..620f9ae9
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/CsOobConfigTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import com.android.server.ranging.cs.CsOobConfig;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class CsOobConfigTest {
+
+    private static final CsOobConfig CS_CONFIG = CsOobConfig.builder().build();
+
+    private static final byte[] csConfigBytes =
+            new byte[]{
+                    // CS Technology Id
+                    0x01,
+                    // Size
+                    0x02,
+            };
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        assertThat(CS_CONFIG.toBytes()).isEqualTo(csConfigBytes);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        assertThat(CsOobConfig.parseBytes(csConfigBytes)).isEqualTo(CS_CONFIG);
+    }
+
+    @Test
+    public void parseBytes_invalidSize_throws() throws Exception {
+        byte[] shortMessage = new byte[]{0x0A};
+        assertThrows(IllegalArgumentException.class, () -> CsOobConfig.parseBytes(shortMessage));
+    }
+
+    @Test
+    public void parseBytes_invalidTechnologyId_throws() throws Exception {
+        byte[] unknownConfigBytes = new byte[]{0x09, 0x02};
+
+        assertThrows(IllegalArgumentException.class,
+                () -> CsOobConfig.parseBytes(unknownConfigBytes));
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/OobControllerTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/OobControllerTest.java
new file mode 100644
index 00000000..f57e74ac
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/OobControllerTest.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertThrows;
+import static org.mockito.AdditionalMatchers.aryEq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.AlarmManager;
+import android.content.Context;
+import android.os.RemoteException;
+import android.ranging.oob.IOobSendDataListener;
+import android.ranging.oob.OobHandle;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.oob.OobController;
+import com.android.server.ranging.oob.OobController.OobConnection;
+
+import com.google.common.util.concurrent.FluentFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+
+@SuppressWarnings("ConstantConditions")
+@RunWith(JUnit4.class)
+@SmallTest
+public class OobControllerTest {
+    @Rule
+    public final MockitoRule mMockito = MockitoJUnit.rule();
+
+    private @Mock RangingInjector mMockInjector;
+    private @Mock AlarmManager mMockAlarmManager;
+    private @Mock IOobSendDataListener mMockDataSender;
+    private OobController mController;
+
+    @Before
+    public void setup() {
+        Context mockContext = mock(Context.class);
+        when(mockContext.getSystemService(AlarmManager.class)).thenReturn(mMockAlarmManager);
+        when(mMockInjector.getContext()).thenReturn(mockContext);
+        mController = new OobController(mMockInjector);
+        mController.registerDataSender(mMockDataSender);
+    }
+
+    @Test
+    public void handleOobClosed_closesConnection() {
+        OobHandle mockHandle = mock(OobHandle.class);
+        OobConnection connection = mController.createConnection(mockHandle);
+        mController.handleOobClosed(mockHandle);
+
+        assertThat(connection.isClosed()).isTrue();
+    }
+
+    @Test
+    public void handleOobDeviceDisconnected_disconnects() {
+        OobHandle mockHandle = mock(OobHandle.class);
+        OobConnection connection = mController.createConnection(mockHandle);
+        mController.handleOobDeviceDisconnected(mockHandle);
+
+        assertThat(connection.isConnected()).isFalse();
+    }
+
+    @Test
+    public void shouldPreventSendsAndReceives_whenClosed() {
+        OobConnection connection = mController.createConnection(mock(OobHandle.class));
+        connection.close();
+
+        assertThat(connection.isClosed()).isTrue();
+
+        ListenableFuture<Void> pendingSend = connection.sendData(new byte[]{1, 2});
+        ListenableFuture<byte[]> pendingReceive = connection.receiveData();
+
+        assertThat(pendingSend.isDone()).isTrue();
+        assertThat(pendingReceive.isDone()).isTrue();
+        assertThrows(ExecutionException.class, pendingSend::get);
+        assertThrows(ExecutionException.class, pendingReceive::get);
+    }
+
+    @Test
+    public void shouldClose_whenDisconnectTimeoutExpires() {
+        OobHandle mockHandle = mock(OobHandle.class);
+
+        OobConnection connection = mController.createConnection(mockHandle);
+        mController.handleOobDeviceDisconnected(mockHandle);
+
+
+        ArgumentCaptor<AlarmManager.OnAlarmListener> alarmCaptor =
+                ArgumentCaptor.forClass(AlarmManager.OnAlarmListener.class);
+        verify(mMockAlarmManager)
+                .setExact(anyInt(), anyLong(), anyString(), alarmCaptor.capture(), any());
+        alarmCaptor.getValue().onAlarm();
+
+        assertThat(connection.isClosed()).isTrue();
+    }
+
+    @Test
+    public void sendData_notifiesDataSendListener()
+            throws ExecutionException, InterruptedException, RemoteException {
+
+        OobHandle mockHandle = mock(OobHandle.class);
+        byte[] data = new byte[]{1, 2};
+
+        try (OobConnection connection = mController.createConnection(mockHandle)) {
+
+            FluentFuture<Void> pendingSend = connection.sendData(data);
+            assertThat(pendingSend.isDone()).isTrue();
+            pendingSend.get();
+            verify(mMockDataSender).sendOobData(eq(mockHandle), aryEq(data));
+        }
+    }
+
+    @Test
+    public void sendData_notifiesSendDataListenerWithDataFromMultipleConnections()
+            throws ExecutionException, InterruptedException, RemoteException {
+
+        List<OobHandle> mockHandles = List.of(mock(OobHandle.class), mock(OobHandle.class));
+        List<byte[]> data = List.of(new byte[]{1, 2}, new byte[]{3, 4});
+
+        try (
+                OobConnection connection0 = mController.createConnection(mockHandles.get(0));
+                OobConnection connection1 = mController.createConnection(mockHandles.get(1))
+        ) {
+            List<FluentFuture<Void>> pendingSends = List.of(
+                    connection0.sendData(data.get(0)),
+                    connection1.sendData(data.get(1)));
+
+            assertThat(pendingSends.get(0).isDone()).isTrue();
+            pendingSends.get(0).get();
+            verify(mMockDataSender).sendOobData(eq(mockHandles.get(0)), aryEq(data.get(0)));
+
+            assertThat(pendingSends.get(1).isDone()).isTrue();
+            pendingSends.get(1).get();
+            verify(mMockDataSender).sendOobData(eq(mockHandles.get(1)), aryEq(data.get(1)));
+        }
+    }
+
+    @Test
+    public void sendData_queuesDataForSend_whenDisconnected()
+            throws ExecutionException, InterruptedException, RemoteException {
+
+        OobHandle mockHandle = mock(OobHandle.class);
+        byte[] data = new byte[]{1, 2};
+
+        try (OobConnection connection = mController.createConnection(mockHandle)) {
+            mController.handleOobDeviceDisconnected(mockHandle);
+
+            ListenableFuture<Void> pendingSend = connection.sendData(data);
+            assertThat(pendingSend.isDone()).isFalse();
+
+            mController.handleOobDeviceReconnected(mockHandle);
+
+            assertThat(pendingSend.isDone()).isTrue();
+            pendingSend.get();
+
+            verify(mMockDataSender).sendOobData(eq(mockHandle), aryEq(data));
+        }
+    }
+
+    @Test
+    public void receiveData_getsLastDataReceived_whenAvailable()
+            throws ExecutionException, InterruptedException {
+
+        OobHandle mockHandle = mock(OobHandle.class);
+        byte[] data = new byte[]{1, 2};
+
+        try (OobConnection connection = mController.createConnection(mockHandle)) {
+            mController.handleOobDataReceived(mockHandle, data);
+
+            ListenableFuture<byte[]> pendingReceive = connection.receiveData();
+            assertThat(pendingReceive.isDone()).isTrue();
+            assertArrayEquals(data, pendingReceive.get());
+        }
+    }
+
+    @Test
+    public void receiveData_waitsForNewData_whenNoneAvailable()
+            throws ExecutionException, InterruptedException {
+
+        OobHandle mockHandle = mock(OobHandle.class);
+        byte[] data = new byte[]{1, 2};
+
+        try (OobConnection connection = mController.createConnection(mockHandle)) {
+            ListenableFuture<byte[]> pendingReceive = connection.receiveData();
+            assertThat(pendingReceive.isDone()).isFalse();
+
+            mController.handleOobDataReceived(mockHandle, data);
+            assertThat(pendingReceive.isDone()).isTrue();
+            assertArrayEquals(data, pendingReceive.get());
+        }
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/OobHeaderTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/OobHeaderTest.java
new file mode 100644
index 00000000..91807a15
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/OobHeaderTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobHeader;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class OobHeaderTest {
+
+    @Test
+    public void parseBytes_validHeader_parsesCorrectly() throws Exception {
+        byte[] requestMessageHeader1 = new byte[]{0x1, 0x0};
+        byte[] requestMessageHeader2 = new byte[]{0x5, 0x3};
+
+        assertThat(OobHeader.parseBytes(requestMessageHeader1))
+                .isEqualTo(
+                        OobHeader.builder()
+                                .setVersion(1)
+                                .setMessageType(MessageType.CAPABILITY_REQUEST)
+                                .build());
+        assertThat(OobHeader.parseBytes(requestMessageHeader2))
+                .isEqualTo(
+                        OobHeader.builder()
+                                .setVersion(5)
+                                .setMessageType(MessageType.SET_CONFIGURATION_RESPONSE)
+                                .build());
+    }
+
+    @Test
+    public void parseBytes_headerWithAdditionalBytes_parsesCorrectly() throws Exception {
+        byte[] requestMessageHeader = new byte[]{0x2, 0x2, 0x0B, 0x33};
+        assertThat(OobHeader.parseBytes(requestMessageHeader))
+                .isEqualTo(
+                        OobHeader.builder()
+                                .setVersion(2)
+                                .setMessageType(MessageType.SET_CONFIGURATION)
+                                .build());
+    }
+
+    @Test
+    public void parseBytes_tooShortPayload_throwsException() throws Exception {
+        byte[] requestMessageHeader = new byte[]{0x2};
+        assertThrows(IllegalArgumentException.class,
+                () -> OobHeader.parseBytes(requestMessageHeader));
+    }
+
+    @Test
+    public void parseBytes_unknownMessageType_parsesCorrectly() throws Exception {
+        byte[] requestMessageHeader = new byte[]{0x2, 0x9};
+        assertThat(OobHeader.parseBytes(requestMessageHeader))
+                .isEqualTo(OobHeader.builder().setVersion(2).setMessageType(
+                        MessageType.UNKNOWN).build());
+    }
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        OobHeader header1 =
+                OobHeader.builder().setVersion(1).setMessageType(
+                        MessageType.SET_CONFIGURATION).build();
+        OobHeader header2 =
+                OobHeader.builder().setVersion(7).setMessageType(
+                        MessageType.STOP_RANGING_RESPONSE).build();
+
+        assertThat(header1.toBytes()).isEqualTo(new byte[]{0x1, 0x2});
+        assertThat(header2.toBytes()).isEqualTo(new byte[]{0x7, 0x7});
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/RttOobCapabilitiesTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/RttOobCapabilitiesTest.java
new file mode 100644
index 00000000..1488af7b
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/RttOobCapabilitiesTest.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import android.ranging.wifi.rtt.RttRangingCapabilities;
+
+import com.android.server.ranging.rtt.RttOobCapabilities;
+
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.Arrays;
+
+@RunWith(JUnit4.class)
+public class RttOobCapabilitiesTest {
+
+    private static final RttOobCapabilities RTT_OOB_CAPABILITIES =
+            RttOobCapabilities.builder()
+                    .setHasPeriodicRangingSupport(false)
+                    .setMaxSupportedBandwidth(20)
+                    .setMaxSupportedRxChain(3)
+                    .build();
+
+
+    private final byte[] mRttTechHeaderBytes =
+            new byte[]{
+                    // Technology Id
+                    0x02,
+                    // Size
+                    0x06,
+            };
+
+    private final byte[] mRttCapabilityBytes =
+            new byte[]{
+                    // 11mc or 11az
+                    0x1,
+                    // Has periodic ranging support
+                    0x00,
+                    // Max bandwidth,
+                    0x14,
+                    // Max supported Rx chain,
+                    0x03
+            };
+
+    private final byte[] mRttCapabilityWithHeaderBytes =
+            Bytes.concat(mRttTechHeaderBytes, mRttCapabilityBytes);
+
+    @Test
+    public void testGetRttOobCapabilities() {
+        RttRangingCapabilities rangingCapabilities = new RttRangingCapabilities.Builder()
+                .setMaxSupportedBandwidth(20)
+                .setMaxSupportedRxChain(3)
+                .setPeriodicRangingHardwareFeature(false)
+                .build();
+
+        assertThat(RttOobCapabilities.fromRangingCapabilities(rangingCapabilities)).isEqualTo(
+                RTT_OOB_CAPABILITIES);
+    }
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        assertThat(RTT_OOB_CAPABILITIES.toBytes()).isEqualTo(mRttCapabilityWithHeaderBytes);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        assertThat(RttOobCapabilities.parseBytes(mRttCapabilityWithHeaderBytes))
+                .isEqualTo(RTT_OOB_CAPABILITIES);
+    }
+
+    @Test
+    public void testInvalidBytes() {
+        byte[] invalidCapabilities = new byte[]{0};
+
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> RttOobCapabilities.parseBytes(invalidCapabilities)
+        );
+
+        byte[] invalidTechnology = Arrays.copyOf(mRttCapabilityWithHeaderBytes,
+                mRttCapabilityWithHeaderBytes.length);
+        invalidTechnology[0] = 0x00;
+
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> RttOobCapabilities.parseBytes(invalidTechnology)
+        );
+    }
+
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/RttOobConfigTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/RttOobConfigTest.java
new file mode 100644
index 00000000..4004754c
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/RttOobConfigTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import com.android.server.ranging.rtt.RttOobConfig;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class RttOobConfigTest {
+
+    private static final RttOobConfig RTT_OOB_CONFIG = RttOobConfig.builder()
+            .setUsePeriodicRanging(false)
+            .setServiceName("rttConfigTest")
+            .setDeviceRole(1)
+            .build();
+
+    private final byte[] mRttConfigBytes =
+            new byte[]{
+                    // Ranging technology Id
+                    (byte) 0x02,
+                    // Size
+                    (byte) 0x12,
+                    // Service name length
+                    (byte) 0x0d,
+                    // Service name
+                    (byte) 0x72, (byte) 0x74, (byte) 0x74, (byte) 0x43, (byte) 0x6f, (byte) 0x6e,
+                    (byte) 0x66, (byte) 0x69, (byte) 0x67, (byte) 0x54, (byte) 0x65,
+                    (byte) 0x73, (byte) 0x74,
+                    // Device role
+                    (byte) 0x01,
+                    //Periodic ranging
+                    (byte) 0x00};
+
+    @Test
+    public void rttOobConfigValidate_tests() throws Exception {
+        assertThat(RTT_OOB_CONFIG.toBytes()).isEqualTo(mRttConfigBytes);
+
+        assertThat(RttOobConfig.parseBytes(mRttConfigBytes)).isEqualTo(RTT_OOB_CONFIG);
+
+        byte[] shortMessage = new byte[]{0x0A};
+        assertThrows(IllegalArgumentException.class, () -> RttOobConfig.parseBytes(shortMessage));
+
+        byte[] unknownConfigBytes = new byte[]{0x09, 0x02};
+
+        assertThrows(IllegalArgumentException.class,
+                () -> RttOobConfig.parseBytes(unknownConfigBytes));
+    }
+
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/SetConfigurationMessageTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/SetConfigurationMessageTest.java
new file mode 100644
index 00000000..140a20c1
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/SetConfigurationMessageTest.java
@@ -0,0 +1,314 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+
+import static com.android.server.ranging.RangingUtils.Conversions.hexStringToByteArray;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import android.ranging.uwb.UwbAddress;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobHeader;
+import com.android.server.ranging.oob.SetConfigurationMessage;
+import com.android.server.ranging.uwb.UwbOobConfig;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class SetConfigurationMessageTest {
+
+    private static final OobHeader OOB_HEADER =
+            OobHeader.builder().setVersion(1).setMessageType(MessageType.SET_CONFIGURATION).build();
+    private static final UwbOobConfig UWB_CONFIG =
+            UwbOobConfig.builder()
+                    .setUwbAddress(UwbAddress.fromBytes(new byte[]{0x2, 0x4}))
+                    .setSessionId(672)
+                    .setSelectedConfigId(12)
+                    .setSelectedChannel(3)
+                    .setSelectedPreambleIndex(4)
+                    .setSelectedRangingIntervalMs(500)
+                    .setSelectedSlotDurationMs(15)
+                    .setSessionKey(hexStringToByteArray("0102030405060708"))
+                    .setCountryCode("US")
+                    .setDeviceRole(UwbOobConfig.OobDeviceRole.INITIATOR)
+                    .setDeviceMode(UwbOobConfig.OobDeviceMode.CONTROLLER)
+                    .build();
+    private static final SetConfigurationMessage SET_CONFIGURATION_MESSAGE =
+            SetConfigurationMessage.builder()
+                    .setHeader(OOB_HEADER)
+                    .setRangingTechnologiesSet(ImmutableList.of(RangingTechnology.UWB))
+                    .setStartRangingList(ImmutableList.of(RangingTechnology.UWB))
+                    .setUwbConfig(UWB_CONFIG)
+                    .build();
+
+    private static final byte[] oobHeaderBytes =
+            new byte[]{
+                    // Version
+                    0x01,
+                    // Message type
+                    0x02,
+            };
+
+    private static final byte[] setConfigurationMessageMissingConfigBytes =
+            new byte[]{
+                    // Ranging technologies set bitmap
+                    0x1,
+                    0x0,
+                    // Ranging technologies to start ranging
+                    0x1,
+                    0x0
+            };
+
+    private static final byte[] setConfigurationMessageUnknownBytes =
+            new byte[]{
+                    // Ranging technologies set bitmap
+                    (byte) 0x80,
+                    0x0,
+                    // Ranging technologies to start ranging
+                    0x0,
+                    0x0
+            };
+
+    private static final byte[] unknownConfigBytes =
+            new byte[]{
+                    // Id
+                    0x7,
+                    // Size
+                    0x2,
+            };
+
+    private static final byte[] uwbConfigBytes =
+            new byte[]{
+                    // Ranging technology Id (0 for UWB)
+                    0x0,
+                    // Size
+                    (byte) 0x1B,
+                    // Uwb address
+                    0x2,
+                    0x4,
+                    // Session Id int little endian
+                    (byte) 0xA0,
+                    0x2,
+                    0x0,
+                    0x0,
+                    // Selected Config Id
+                    0xC,
+                    // Selected Channel
+                    0x3,
+                    // Selected Preamble Index
+                    0x4,
+                    // Selected ranging interval int little endian
+                    (byte) 0xF4,
+                    0x1,
+                    // Selected slot duration 1 byte
+                    0xF,
+                    // Session key length
+                    0x8,
+                    // Session key
+                    0x1,
+                    0x2,
+                    0x3,
+                    0x4,
+                    0x5,
+                    0x6,
+                    0x7,
+                    0x8,
+                    // Country code (US ascii)
+                    0x55,
+                    0x53,
+                    // Device role
+                    0x1,
+                    // Device mode
+                    0x1,
+            };
+
+    private static final byte[] setConfigurationMessageBytes =
+            Bytes.concat(oobHeaderBytes, setConfigurationMessageMissingConfigBytes, uwbConfigBytes);
+
+    private static final byte[] setConfigurationMessageUnknownSetBytes =
+            Bytes.concat(oobHeaderBytes, setConfigurationMessageUnknownBytes, unknownConfigBytes);
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        assertThat(SET_CONFIGURATION_MESSAGE.toBytes()).isEqualTo(setConfigurationMessageBytes);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        assertThat(SetConfigurationMessage.parseBytes(setConfigurationMessageBytes))
+                .isEqualTo(SET_CONFIGURATION_MESSAGE);
+    }
+
+    @Test
+    public void toBytes_noConfigPresent_convertsCorrectly() throws Exception {
+        SetConfigurationMessage message =
+                SetConfigurationMessage.builder()
+                        .setHeader(OOB_HEADER)
+                        .setRangingTechnologiesSet(ImmutableList.of())
+                        .build();
+        byte[] expectedBytes = new byte[]{0x1, 0x2, 0x0, 0x0, 0x0, 0x0};
+
+        assertThat(message.toBytes()).isEqualTo(expectedBytes);
+    }
+
+    @Test
+    public void parseBytes_invalidMessageSize_throws() throws Exception {
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> SetConfigurationMessage.parseBytes(new byte[]{0x01}));
+    }
+
+    @Test
+    public void parseBytes_invalidMessageType_throws() throws Exception {
+        byte[] invalidMessageTypeMessageBytes =
+                SetConfigurationMessage.builder()
+                        .setHeader(
+                                OobHeader.builder()
+                                        .setVersion(1)
+                                        .setMessageType(MessageType.CAPABILITY_REQUEST)
+                                        .build())
+                        .setRangingTechnologiesSet(ImmutableList.of())
+                        .build()
+                        .toBytes();
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> SetConfigurationMessage.parseBytes(invalidMessageTypeMessageBytes));
+    }
+
+    @Test
+    public void parseBytes_unknownRangingTechnologyId_throwsException() throws Exception {
+        assertThrows(IllegalArgumentException.class,
+                () -> SetConfigurationMessage.parseBytes(setConfigurationMessageUnknownSetBytes));
+    }
+
+    @Test
+    public void uwbConfigBuilder_invalidCountryAddress_throwsException() throws Exception {
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        UwbOobConfig.builder()
+                                .setUwbAddress(UwbAddress.fromBytes(new byte[]{0x2, 0x4}))
+                                .setSessionId(672)
+                                .setSelectedConfigId(12)
+                                .setSelectedChannel(3)
+                                .setSelectedPreambleIndex(4)
+                                .setSelectedRangingIntervalMs(500)
+                                .setSelectedSlotDurationMs(15)
+                                .setSessionKey(hexStringToByteArray("0102030405060708"))
+                                .setCountryCode("CLDN")
+                                .setDeviceRole(UwbOobConfig.OobDeviceRole.INITIATOR)
+                                .setDeviceMode(UwbOobConfig.OobDeviceMode.CONTROLLER)
+                                .build());
+
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        UwbOobConfig.builder()
+                                .setUwbAddress(UwbAddress.fromBytes(new byte[]{0x2, 0x4}))
+                                .setSessionId(672)
+                                .setSelectedConfigId(12)
+                                .setSelectedChannel(3)
+                                .setSelectedPreambleIndex(4)
+                                .setSelectedRangingIntervalMs(500)
+                                .setSelectedSlotDurationMs(15)
+                                .setSessionKey(hexStringToByteArray("0102030405060708"))
+                                .setCountryCode("B")
+                                .setDeviceRole(UwbOobConfig.OobDeviceRole.INITIATOR)
+                                .setDeviceMode(UwbOobConfig.OobDeviceMode.CONTROLLER)
+                                .build());
+    }
+
+    @Test
+    public void uwbConfigBuilder_invalidSessionKeySize_throws() throws Exception {
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        UwbOobConfig.builder()
+                                .setUwbAddress(UwbAddress.fromBytes(new byte[]{0x2, 0x4}))
+                                .setSessionId(672)
+                                .setSelectedConfigId(12)
+                                .setSelectedChannel(3)
+                                .setSelectedPreambleIndex(4)
+                                .setSelectedRangingIntervalMs(500)
+                                .setSelectedSlotDurationMs(15)
+                                .setSessionKey(hexStringToByteArray("010203"))
+                                .setCountryCode("US")
+                                .setDeviceRole(UwbOobConfig.OobDeviceRole.INITIATOR)
+                                .setDeviceMode(UwbOobConfig.OobDeviceMode.CONTROLLER)
+                                .build());
+    }
+
+    @Test
+    public void builder_rangingTechnologiesSetAndConfigMismatch_throws() throws Exception {
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        SetConfigurationMessage.builder()
+                                .setHeader(OOB_HEADER)
+                                .setRangingTechnologiesSet(ImmutableList.of(RangingTechnology.CS))
+                                .setUwbConfig(UWB_CONFIG)
+                                .build());
+    }
+
+    @Test
+    public void builder_rangingTechnologiesSetAndStartRangingListMismatch_throws()
+            throws Exception {
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        SetConfigurationMessage.builder()
+                                .setHeader(OOB_HEADER)
+                                .setStartRangingList(ImmutableList.of(RangingTechnology.CS))
+                                .build());
+    }
+
+    @Test
+    public void uwbConfig_parseBytes_invalidRangingTechId_throws() throws Exception {
+        byte[] uwbConfigBytesInvalidId = uwbConfigBytes;
+        uwbConfigBytesInvalidId[0] = 0x6;
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> UwbOobConfig.parseBytes(uwbConfigBytesInvalidId));
+    }
+
+    @Test
+    public void uwbConfig_parseBytes_invalidSessionKeyLength_throws() throws Exception {
+        byte[] uwbConfigBytesInvalidSessionKeyLength = uwbConfigBytes;
+        uwbConfigBytesInvalidSessionKeyLength[14] = 0x20;
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> UwbOobConfig.parseBytes(uwbConfigBytesInvalidSessionKeyLength));
+    }
+
+    @Test
+    public void uwbConfig_parseBytes_sizeLowerThanMinSize_throws() throws Exception {
+        byte[] uwbConfigBytesTooSmall = new byte[]{0x01};
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> UwbOobConfig.parseBytes(uwbConfigBytesTooSmall));
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/StartRangingMessageTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/StartRangingMessageTest.java
new file mode 100644
index 00000000..dc9749ea
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/StartRangingMessageTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobHeader;
+import com.android.server.ranging.oob.StartRangingMessage;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class StartRangingMessageTest {
+
+    private static final OobHeader OOB_HEADER =
+            OobHeader.builder().setVersion(1).setMessageType(MessageType.START_RANGING).build();
+    private static final ImmutableList<RangingTechnology> UWB_CS_TECH_LIST =
+            ImmutableList.of(RangingTechnology.UWB, RangingTechnology.CS);
+    private static final ImmutableList<RangingTechnology> UWB_TECH_ONLY_LIST =
+            ImmutableList.of(RangingTechnology.UWB);
+
+    private static final byte[] uwbCsTechBitmap = new byte[]{0x3, 0x00};
+    private static final byte[] uwbTechOnlyBitmap = new byte[]{0x01, 0x00};
+    private static final byte[] headerBytes = new byte[]{0x1, 0x4};
+    private static final byte[] uwbCsTechMessage = Bytes.concat(headerBytes, uwbCsTechBitmap);
+    private static final byte[] uwbOnlyMessage = Bytes.concat(headerBytes, uwbTechOnlyBitmap);
+    private static final byte[] noTechsMessage = Bytes.concat(headerBytes, new byte[]{0x0, 0x0});
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        StartRangingMessage startRangingMessageUwbCs =
+                StartRangingMessage.builder()
+                        .setOobHeader(OOB_HEADER)
+                        .setRangingTechnologiesToStart(UWB_CS_TECH_LIST)
+                        .build();
+        StartRangingMessage startRangingMessageUwbOnly =
+                StartRangingMessage.builder()
+                        .setOobHeader(OOB_HEADER)
+                        .setRangingTechnologiesToStart(UWB_TECH_ONLY_LIST)
+                        .build();
+
+        assertThat(startRangingMessageUwbCs.toBytes()).isEqualTo(uwbCsTechMessage);
+        assertThat(startRangingMessageUwbOnly.toBytes()).isEqualTo(uwbOnlyMessage);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        StartRangingMessage uwbCsMessage = StartRangingMessage.parseBytes(uwbCsTechMessage);
+        StartRangingMessage uwbTechMessage = StartRangingMessage.parseBytes(uwbOnlyMessage);
+
+        assertThat(uwbCsMessage)
+                .isEqualTo(
+                        StartRangingMessage.builder()
+                                .setOobHeader(OOB_HEADER)
+                                .setRangingTechnologiesToStart(
+                                        ImmutableList.of(RangingTechnology.UWB,
+                                                RangingTechnology.CS))
+                                .build());
+        assertThat(uwbTechMessage)
+                .isEqualTo(
+                        StartRangingMessage.builder()
+                                .setOobHeader(OOB_HEADER)
+                                .setRangingTechnologiesToStart(
+                                        ImmutableList.of(RangingTechnology.UWB))
+                                .build());
+    }
+
+    @Test
+    public void parseBytes_invalidSize_throws() throws Exception {
+        byte[] shortMessage = new byte[]{0x0A};
+        assertThrows(
+                IllegalArgumentException.class, () -> StartRangingMessage.parseBytes(shortMessage));
+    }
+
+    @Test
+    public void parseBytes_invalidMessageType_throws() throws Exception {
+        byte[] invalidMessageTypeMessageBytes =
+                StartRangingMessage.builder()
+                        .setOobHeader(
+                                OobHeader.builder()
+                                        .setVersion(1)
+                                        .setMessageType(MessageType.SET_CONFIGURATION)
+                                        .build())
+                        .setRangingTechnologiesToStart(UWB_TECH_ONLY_LIST)
+                        .build()
+                        .toBytes();
+
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> StartRangingMessage.parseBytes(invalidMessageTypeMessageBytes));
+    }
+
+    @Test
+    public void parseBytes_noTechsSet_parsesCorrectlyToEmpty() throws Exception {
+        assertThat(StartRangingMessage.parseBytes(noTechsMessage))
+                .isEqualTo(
+                        StartRangingMessage.builder()
+                                .setOobHeader(OOB_HEADER)
+                                .setRangingTechnologiesToStart(ImmutableList.of())
+                                .build());
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/StatusResponseMessageTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/StatusResponseMessageTest.java
new file mode 100644
index 00000000..d57dcf82
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/StatusResponseMessageTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobHeader;
+import com.android.server.ranging.oob.StatusResponseMessage;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class StatusResponseMessageTest {
+
+    private static final OobHeader OOB_HEADER =
+            OobHeader.builder().setVersion(1).setMessageType(
+                    MessageType.START_RANGING_RESPONSE).build();
+    private static final ImmutableList<RangingTechnology> UWB_CS_TECH_LIST =
+            ImmutableList.of(RangingTechnology.UWB, RangingTechnology.CS);
+    private static final ImmutableList<RangingTechnology> UWB_TECH_ONLY_LIST =
+            ImmutableList.of(RangingTechnology.UWB);
+
+    private static final byte[] uwbCsTechBitmap = new byte[]{0x3, 0x00};
+    private static final byte[] uwbTechOnlyBitmap = new byte[]{0x01, 0x00};
+    private static final byte[] headerBytes = new byte[]{0x1, 0x5};
+    private static final byte[] uwbCsTechMessage = Bytes.concat(headerBytes, uwbCsTechBitmap);
+    private static final byte[] uwbOnlyMessage = Bytes.concat(headerBytes, uwbTechOnlyBitmap);
+    private static final byte[] noTechsMessage = Bytes.concat(headerBytes, new byte[]{0x0, 0x0});
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        StatusResponseMessage statusResponseMessageUwbCs =
+                StatusResponseMessage.builder()
+                        .setOobHeader(OOB_HEADER)
+                        .setSuccessfulRangingTechnologies(UWB_CS_TECH_LIST)
+                        .build();
+        StatusResponseMessage statusResponseMessageUwb =
+                StatusResponseMessage.builder()
+                        .setOobHeader(OOB_HEADER)
+                        .setSuccessfulRangingTechnologies(UWB_TECH_ONLY_LIST)
+                        .build();
+        StatusResponseMessage statusResponseMessageEmpty =
+                StatusResponseMessage.builder()
+                        .setOobHeader(OOB_HEADER)
+                        .setSuccessfulRangingTechnologies(ImmutableList.of())
+                        .build();
+
+        assertThat(statusResponseMessageUwbCs.toBytes()).isEqualTo(uwbCsTechMessage);
+        assertThat(statusResponseMessageUwb.toBytes()).isEqualTo(uwbOnlyMessage);
+        assertThat(statusResponseMessageEmpty.toBytes()).isEqualTo(noTechsMessage);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        assertThat(StatusResponseMessage.parseBytes(uwbCsTechMessage))
+                .isEqualTo(
+                        StatusResponseMessage.builder()
+                                .setOobHeader(OOB_HEADER)
+                                .setSuccessfulRangingTechnologies(
+                                        ImmutableList.of(RangingTechnology.UWB,
+                                                RangingTechnology.CS))
+                                .build());
+        assertThat(StatusResponseMessage.parseBytes(uwbOnlyMessage))
+                .isEqualTo(
+                        StatusResponseMessage.builder()
+                                .setOobHeader(OOB_HEADER)
+                                .setSuccessfulRangingTechnologies(
+                                        ImmutableList.of(RangingTechnology.UWB))
+                                .build());
+        assertThat(StatusResponseMessage.parseBytes(noTechsMessage))
+                .isEqualTo(
+                        StatusResponseMessage.builder()
+                                .setOobHeader(OOB_HEADER)
+                                .setSuccessfulRangingTechnologies(ImmutableList.of())
+                                .build());
+    }
+
+    @Test
+    public void parseBytes_invalidSize_throws() throws Exception {
+        byte[] tooShortMessage = new byte[]{0x0A};
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> StatusResponseMessage.parseBytes(tooShortMessage));
+    }
+
+    @Test
+    public void parseBytes_invalidMessageType_throws() throws Exception {
+        byte[] invalidMessageTypeMessageBytes =
+                StatusResponseMessage.builder()
+                        .setOobHeader(
+                                OobHeader.builder()
+                                        .setVersion(1)
+                                        .setMessageType(MessageType.SET_CONFIGURATION)
+                                        .build())
+                        .setSuccessfulRangingTechnologies(UWB_CS_TECH_LIST)
+                        .build()
+                        .toBytes();
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> StatusResponseMessage.parseBytes(invalidMessageTypeMessageBytes));
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/StopRangingMessageTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/StopRangingMessageTest.java
new file mode 100644
index 00000000..1e57c61a
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/StopRangingMessageTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.MessageType;
+import com.android.server.ranging.oob.OobHeader;
+import com.android.server.ranging.oob.StopRangingMessage;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class StopRangingMessageTest {
+
+    private static final OobHeader OOB_HEADER =
+            OobHeader.builder().setVersion(1).setMessageType(MessageType.STOP_RANGING).build();
+    private static final ImmutableList<RangingTechnology> UWB_CS_TECH_LIST =
+            ImmutableList.of(RangingTechnology.UWB, RangingTechnology.CS);
+    private static final ImmutableList<RangingTechnology> UWB_TECH_ONLY_LIST =
+            ImmutableList.of(RangingTechnology.UWB);
+
+    private static final byte[] uwbCsTechBitmap = new byte[]{0x3, 0x00};
+    private static final byte[] uwbTechOnlyBitmap = new byte[]{0x01, 0x00};
+    private static final byte[] headerBytes = new byte[]{0x1, 0x6};
+    private static final byte[] uwbCsTechMessage = Bytes.concat(headerBytes, uwbCsTechBitmap);
+    private static final byte[] uwbOnlyMessage = Bytes.concat(headerBytes, uwbTechOnlyBitmap);
+    private static final byte[] noTechsMessage = Bytes.concat(headerBytes, new byte[]{0x0, 0x0});
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        StopRangingMessage stopRangingMessageUwbCs =
+                StopRangingMessage.builder()
+                        .setOobHeader(OOB_HEADER)
+                        .setRangingTechnologiesToStop(UWB_CS_TECH_LIST)
+                        .build();
+        StopRangingMessage stopRangingMessageUwbOnly =
+                StopRangingMessage.builder()
+                        .setOobHeader(OOB_HEADER)
+                        .setRangingTechnologiesToStop(UWB_TECH_ONLY_LIST)
+                        .build();
+
+        assertThat(stopRangingMessageUwbCs.toBytes()).isEqualTo(uwbCsTechMessage);
+        assertThat(stopRangingMessageUwbOnly.toBytes()).isEqualTo(uwbOnlyMessage);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        assertThat(StopRangingMessage.parseBytes(uwbCsTechMessage))
+                .isEqualTo(
+                        StopRangingMessage.builder()
+                                .setOobHeader(OOB_HEADER)
+                                .setRangingTechnologiesToStop(UWB_CS_TECH_LIST)
+                                .build());
+        assertThat(StopRangingMessage.parseBytes(uwbOnlyMessage))
+                .isEqualTo(
+                        StopRangingMessage.builder()
+                                .setOobHeader(OOB_HEADER)
+                                .setRangingTechnologiesToStop(UWB_TECH_ONLY_LIST)
+                                .build());
+    }
+
+    @Test
+    public void parseBytes_invalidSize_throws() throws Exception {
+        byte[] tooShortMessage = new byte[]{0x0A};
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> StopRangingMessage.parseBytes(tooShortMessage));
+    }
+
+    @Test
+    public void parseBytes_invalidMessageType_throws() throws Exception {
+        byte[] invalidMessageTypeMessageBytes =
+                StopRangingMessage.builder()
+                        .setOobHeader(
+                                OobHeader.builder()
+                                        .setVersion(1)
+                                        .setMessageType(MessageType.SET_CONFIGURATION)
+                                        .build())
+                        .setRangingTechnologiesToStop(UWB_CS_TECH_LIST)
+                        .build()
+                        .toBytes();
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> StopRangingMessage.parseBytes(invalidMessageTypeMessageBytes));
+    }
+
+    @Test
+    public void parseBytes_noTechsSet_parsesToEmpty() throws Exception {
+        assertThat(StopRangingMessage.parseBytes(noTechsMessage))
+                .isEqualTo(
+                        StopRangingMessage.builder()
+                                .setOobHeader(OOB_HEADER)
+                                .setRangingTechnologiesToStop(ImmutableList.of())
+                                .build());
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/TechnologyHeaderTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/TechnologyHeaderTest.java
new file mode 100644
index 00000000..573b0474
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/TechnologyHeaderTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.TechnologyHeader;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class TechnologyHeaderTest {
+
+    @Test
+    public void parseBytes_validHeader_parsesCorrectly() throws Exception {
+        byte[] header1 = new byte[]{0x3, 0x0A};
+        byte[] header2 = new byte[]{0x0, 0x3};
+
+        assertThat(TechnologyHeader.parseBytes(header1))
+                .isEqualTo(
+                        TechnologyHeader.builder()
+                                .setRangingTechnology(RangingTechnology.RSSI)
+                                .setSize(10)
+                                .build());
+        assertThat(TechnologyHeader.parseBytes(header2))
+                .isEqualTo(
+                        TechnologyHeader.builder()
+                                .setRangingTechnology(RangingTechnology.UWB)
+                                .setSize(3)
+                                .build());
+    }
+
+    @Test
+    public void parseBytes_headerWithAdditionalBytes_parsesCorrectly() throws Exception {
+        byte[] header = new byte[]{0x1, 0x4, 0x0B, 0x33};
+        assertThat(TechnologyHeader.parseBytes(header))
+                .isEqualTo(
+                        TechnologyHeader.builder()
+                                .setRangingTechnology(RangingTechnology.CS)
+                                .setSize(4)
+                                .build());
+    }
+
+    @Test
+    public void parseBytes_tooShortPayload_throwsException() throws Exception {
+        byte[] header = new byte[]{0x2};
+        assertThrows(IllegalArgumentException.class, () -> TechnologyHeader.parseBytes(header));
+    }
+
+    @Test
+    public void parseBytes_unknownTechnology_throwsException() throws Exception {
+        byte[] header = new byte[]{0x0B, 0x5};
+        assertThrows(IllegalArgumentException.class, () -> TechnologyHeader.parseBytes(header));
+    }
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        TechnologyHeader header1 =
+                TechnologyHeader.builder().setRangingTechnology(RangingTechnology.UWB).setSize(
+                        55).build();
+        TechnologyHeader header2 =
+                TechnologyHeader.builder()
+                        .setRangingTechnology(RangingTechnology.RTT)
+                        .setSize(10)
+                        .build();
+
+        assertThat(header1.toBytes()).isEqualTo(new byte[]{0x0, 0x37});
+        assertThat(header2.toBytes()).isEqualTo(new byte[]{0x2, 0xA});
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/UtilsTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/UtilsTest.java
new file mode 100644
index 00000000..4207dbae
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/UtilsTest.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.android.server.ranging.RangingUtils;
+
+import com.google.common.collect.ImmutableList;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.Arrays;
+
+@RunWith(JUnit4.class)
+public final class UtilsTest {
+
+    private static final ImmutableList<Integer> INT_LIST = ImmutableList.of(3, 4, 8);
+
+    @Test
+    public void intListToByteArrayBitmap_success() throws Exception {
+        byte[] resultShift2Size3 = new byte[]{0x46, 0x00, 0x00};
+        assertThat(
+                Arrays.equals(
+                        resultShift2Size3,
+                        RangingUtils.Conversions.intListToByteArrayBitmap(
+                                INT_LIST, /* expectedSizeBytes= */ 3, /* shift= */ 2)))
+                .isTrue();
+
+        byte[] resultShift2Size1 = new byte[]{0x46};
+        assertThat(
+                Arrays.equals(
+                        resultShift2Size1,
+                        RangingUtils.Conversions.intListToByteArrayBitmap(
+                                INT_LIST, /* expectedSizeBytes= */ 1, /* shift= */ 2)))
+                .isTrue();
+
+        byte[] resultShift0Size2 = new byte[]{0x18, 0x01};
+        assertThat(
+                Arrays.equals(
+                        resultShift0Size2,
+                        RangingUtils.Conversions.intListToByteArrayBitmap(
+                                INT_LIST, /* expectedSizeBytes= */ 2, /* shift= */ 0)))
+                .isTrue();
+    }
+
+    @Test
+    public void byteArrayToIntList_success() throws Exception {
+        byte[] intList1Shift2Size2 = new byte[]{0x46, 0x00};
+        assertThat(RangingUtils.Conversions.byteArrayToIntList(intList1Shift2Size2, /* shift= */ 2))
+                .isEqualTo(INT_LIST);
+
+        byte[] intList1Shit2Size1 = new byte[]{0x46};
+        assertThat(RangingUtils.Conversions.byteArrayToIntList(intList1Shit2Size1, /* shift= */ 2))
+                .isEqualTo(INT_LIST);
+
+        byte[] intList1Shift0Size4 = new byte[]{0x18, 0x01, 0x00, 0x00};
+        assertThat(RangingUtils.Conversions.byteArrayToIntList(intList1Shift0Size4, /* shift= */ 0))
+                .isEqualTo(INT_LIST);
+    }
+
+    @Test
+    public void intToByteArray_success() throws Exception {
+        byte[] resultValue1Size4 = new byte[]{0x01, 0x00, 0x00, 0x00};
+        assertThat(
+                Arrays.equals(
+                        resultValue1Size4,
+                        RangingUtils.Conversions
+                                .intToByteArray(/* value= */ 1, /* expectedSizeBytes= */ 4)))
+                .isTrue();
+
+        byte[] resultValue256Size3 = new byte[]{0x00, 0x01, 0x00};
+        assertThat(
+                Arrays.equals(
+                        resultValue256Size3,
+                        RangingUtils.Conversions.intToByteArray(/* value= */
+                                256, /* expectedSizeBytes= */ 3)))
+                .isTrue();
+
+        byte[] resultValue257Size3 = new byte[]{0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00};
+        assertThat(
+                Arrays.equals(
+                        resultValue257Size3,
+                        RangingUtils.Conversions
+                                .intToByteArray(/* value= */ 257, /* expectedSizeBytes= */ 7)))
+                .isTrue();
+    }
+
+    @Test
+    public void byteArrayToInt_success() throws Exception {
+        byte[] byteArrayValue8Size1 = new byte[]{0x08};
+
+        assertThat(RangingUtils.Conversions.byteArrayToInt(byteArrayValue8Size1)).isEqualTo(8);
+
+        byte[] byteArrayValue256Size3 = new byte[]{0x00, 0x01, 0x00};
+        assertThat(RangingUtils.Conversions.byteArrayToInt(byteArrayValue256Size3)).isEqualTo(256);
+
+        byte[] byteArrayValue23456Size4 = new byte[]{(byte) 0xA0, 0x5B, 0x00, 0x00};
+        assertThat(RangingUtils.Conversions.byteArrayToInt(byteArrayValue23456Size4)).isEqualTo(
+                23456);
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/UwbOobCapabilitiesTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/UwbOobCapabilitiesTest.java
new file mode 100644
index 00000000..16cb78ca
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/UwbOobCapabilitiesTest.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import android.ranging.uwb.UwbAddress;
+
+import com.android.server.ranging.uwb.UwbOobCapabilities;
+import com.android.server.ranging.uwb.UwbOobConfig;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class UwbOobCapabilitiesTest {
+
+    private static final UwbOobCapabilities UWB_CAPABILITIES =
+            UwbOobCapabilities.builder()
+                    .setUwbAddress(UwbAddress.fromBytes(new byte[]{8, 9}))
+                    .setSupportedChannels(ImmutableList.of(5, 9))
+                    .setSupportedPreambleIndexes(ImmutableList.of(1, 32))
+                    .setSupportedConfigIds(ImmutableList.of(7, 15))
+                    .setMinimumRangingIntervalMs(1000)
+                    .setMinimumSlotDurationMs(20)
+                    .setSupportedDeviceRole(
+                            ImmutableList.of(
+                                    UwbOobConfig.OobDeviceRole.INITIATOR,
+                                    UwbOobConfig.OobDeviceRole.RESPONDER))
+                    .build();
+
+    private static final byte[] uwbTechHeaderBytes =
+            new byte[]{
+                    // Technology Id
+                    0x00,
+                    // Size
+                    0x14,
+            };
+
+    private static final byte[] unknownTechHeaderBytes =
+            new byte[]{
+                    // Technology Id
+                    0x07,
+                    // Size
+                    0x14,
+            };
+
+    private static final byte[] uwbCapabilityBytes =
+            new byte[]{
+                    // Uwb Address
+                    0x08,
+                    0x09,
+                    // Supported channels bitmap
+                    0x20,
+                    0x02,
+                    0x00,
+                    0x00,
+                    // Supported preamble indexes bitmap
+                    0x01,
+                    0x00,
+                    0x00,
+                    (byte) 0x80,
+                    // Supported config ids bitmap
+                    (byte) 0x80,
+                    (byte) 0x80,
+                    0x00,
+                    0x00,
+                    // Minimum ranging interval ms
+                    (byte) 0xE8,
+                    0x03,
+                    // Minimum slot duration ms
+                    0x14,
+                    // Supported device role bitmap
+                    0x03,
+            };
+
+    private static final byte[] uwbCapabilityWithHeaderBytes =
+            Bytes.concat(uwbTechHeaderBytes, uwbCapabilityBytes);
+
+    private static final byte[] uwbCapabilityWithUnknownHeaderBytes =
+            Bytes.concat(unknownTechHeaderBytes, uwbCapabilityBytes);
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        assertThat(UWB_CAPABILITIES.toBytes()).isEqualTo(uwbCapabilityWithHeaderBytes);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        assertThat(UwbOobCapabilities.parseBytes(uwbCapabilityWithHeaderBytes))
+                .isEqualTo(UWB_CAPABILITIES);
+    }
+
+    @Test
+    public void parseBytes_invalidSize_throws() throws Exception {
+        byte[] shortMessage = new byte[]{0x0A};
+        assertThrows(IllegalArgumentException.class,
+                () -> UwbOobCapabilities.parseBytes(shortMessage));
+    }
+
+    @Test
+    public void parseBytes_mismatchedHeaderSize_throws() throws Exception {
+        byte[] mismatchedHeaderSizeBytes = Bytes.concat(uwbTechHeaderBytes, new byte[]{0x00, 0x01});
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> UwbOobCapabilities.parseBytes(mismatchedHeaderSizeBytes));
+    }
+
+    @Test
+    public void parseBytes_invalidTechnologyId_throws() throws Exception {
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> UwbOobCapabilities.parseBytes(uwbCapabilityWithUnknownHeaderBytes));
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/UwbOobConfigTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/UwbOobConfigTest.java
new file mode 100644
index 00000000..11ee7692
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/oob/UwbOobConfigTest.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.oob;
+
+
+import static com.android.server.ranging.RangingUtils.Conversions.hexStringToByteArray;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import android.ranging.uwb.UwbAddress;
+
+import com.android.server.ranging.uwb.UwbOobConfig;
+
+import com.google.common.primitives.Bytes;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class UwbOobConfigTest {
+
+    private static final UwbOobConfig UWB_CONFIG =
+            UwbOobConfig.builder()
+                    .setUwbAddress(UwbAddress.fromBytes(new byte[]{0x2, 0x4}))
+                    .setSessionId(672)
+                    .setSelectedConfigId(12)
+                    .setSelectedChannel(3)
+                    .setSelectedPreambleIndex(4)
+                    .setSelectedRangingIntervalMs(500)
+                    .setSelectedSlotDurationMs(15)
+                    .setSessionKey(hexStringToByteArray("0102030405060708"))
+                    .setCountryCode("US")
+                    .setDeviceRole(UwbOobConfig.OobDeviceRole.INITIATOR)
+                    .setDeviceMode(UwbOobConfig.OobDeviceMode.CONTROLLER)
+                    .build();
+
+    private static final byte[] uwbTechHeaderBytes =
+            new byte[]{
+                    // Technology Id
+                    0x00,
+                    // Size
+                    (byte) 0x1B,
+            };
+
+    private static final byte[] unknownTechHeaderBytes =
+            new byte[]{
+                    // Technology Id
+                    0x07,
+                    // Size
+                    (byte) 0x1B,
+            };
+
+    private static final byte[] uwbConfigBytes =
+            new byte[]{
+                    // Uwb address
+                    0x2,
+                    0x4,
+                    // Session Id int little endian
+                    (byte) 0xA0,
+                    0x2,
+                    0x0,
+                    0x0,
+                    // Selected Config Id
+                    0xC,
+                    // Selected Channel
+                    0x3,
+                    // Selected Preamble Index
+                    0x4,
+                    // Selected ranging interval int little endian
+                    (byte) 0xF4,
+                    0x1,
+                    // Selected slot duration 1 byte
+                    0xF,
+                    // Session key length
+                    0x8,
+                    // Session key
+                    0x1,
+                    0x2,
+                    0x3,
+                    0x4,
+                    0x5,
+                    0x6,
+                    0x7,
+                    0x8,
+                    // Country code (US ascii)
+                    0x55,
+                    0x53,
+                    // Device role
+                    0x1,
+                    // Device mode
+                    0x1,
+            };
+
+    private static final byte[] uwbConfigWithHeaderBytes =
+            Bytes.concat(uwbTechHeaderBytes, uwbConfigBytes);
+
+    private static final byte[] uwbConfigWithUnknownHeaderBytes =
+            Bytes.concat(unknownTechHeaderBytes, uwbConfigBytes);
+
+    @Test
+    public void toBytes_convertsCorrectly() throws Exception {
+        assertThat(UWB_CONFIG.toBytes()).isEqualTo(uwbConfigWithHeaderBytes);
+    }
+
+    @Test
+    public void parseBytes_parsesCorrectly() throws Exception {
+        assertThat(UwbOobConfig.parseBytes(uwbConfigWithHeaderBytes)).isEqualTo(UWB_CONFIG);
+    }
+
+    @Test
+    public void parseBytes_invalidSize_throws() throws Exception {
+        byte[] shortMessage = new byte[]{0x0A};
+        assertThrows(IllegalArgumentException.class, () -> UwbOobConfig.parseBytes(shortMessage));
+    }
+
+    @Test
+    public void parseBytes_mismatchedHeaderSize_throws() throws Exception {
+        byte[] mismatchedHeaderSizeBytes = Bytes.concat(uwbTechHeaderBytes, new byte[]{0x00, 0x01});
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> UwbOobConfig.parseBytes(mismatchedHeaderSizeBytes));
+    }
+
+    @Test
+    public void parseBytes_invalidTechnologyId_throws() throws Exception {
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> UwbOobConfig.parseBytes(uwbConfigWithUnknownHeaderBytes));
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/rtt/RttAdapterTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/rtt/RttAdapterTest.java
new file mode 100644
index 00000000..8c75ef04
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/rtt/RttAdapterTest.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.rtt;
+
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_DISABLE;
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_ENABLE;
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+
+import static junit.framework.Assert.assertEquals;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.AlarmManager;
+import android.content.AttributionSource;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.net.wifi.aware.WifiAwareManager;
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.wifi.rtt.RttRangingParams;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.ranging.rtt.backend.RttRangingDevice;
+import com.android.ranging.rtt.backend.RttRangingParameters;
+import com.android.ranging.rtt.backend.RttService;
+import com.android.server.ranging.DeviceConfigFacade;
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.rtt.RttAdapter;
+import com.android.server.ranging.rtt.RttConfig;
+
+import com.google.common.util.concurrent.MoreExecutors;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class RttAdapterTest {
+
+    @Mock
+    private Context mMockContext;
+    @Mock
+    private RangingInjector mMockRangingInjector;
+
+    @Mock
+    private RangingDevice mMockRangingDevice;
+    @Mock
+    private com.android.server.ranging.RangingAdapter.Callback mMockCallback;
+    @Mock
+    private AlarmManager mMockAlarmManager;
+
+    @Mock
+    private PackageManager mMockPackageManager;
+
+    @Mock
+    private WifiAwareManager mMockWifiAwareManager;
+    @Mock
+    private AttributionSource mMockAttributionSource;
+    @Mock
+    private SessionConfig mMockSessionConfig;
+
+    private RttRangingParams mRttRangingParams = new RttRangingParams.Builder("unit_test_rtt")
+            .setMatchFilter(new byte[]{0, 1})
+            .build();
+
+    @Mock
+    private RttService mMockRttService;
+
+    @Mock
+    private RttRangingDevice mMockRttRangingDevice;
+
+    @Mock
+    private RttRangingParameters mMockRttRangingParameters;
+
+    @Mock
+    private DeviceConfigFacade mMockDeviceConfigFacade;
+
+    private final DataNotificationConfig mDataNotificationConfig =
+            new DataNotificationConfig.Builder().build();
+
+    private RttAdapter mRttAdapter;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getSystemService(AlarmManager.class)).thenReturn(mMockAlarmManager);
+        when(mMockContext.getSystemService(PackageManager.class)).thenReturn(mMockPackageManager);
+        when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
+        when(mMockPackageManager.hasSystemFeature(
+                PackageManager.FEATURE_WIFI_AWARE)).thenReturn(true);
+        when(mMockPackageManager.hasSystemFeature(
+                PackageManager.FEATURE_WIFI_RTT)).thenReturn(true);
+        when(mMockContext.getSystemService(WifiAwareManager.class)).thenReturn(
+                mMockWifiAwareManager);
+        when(mMockSessionConfig.getDataNotificationConfig()).thenReturn(mDataNotificationConfig);
+        when(mMockAttributionSource.getUid()).thenReturn(100);
+        when(mMockAttributionSource.getPackageName()).thenReturn("TestPkgName");
+        when(mMockRangingInjector.isForegroundAppOrService(anyInt(), anyString())).thenReturn(true);
+        when(mMockRttService.getPublisher(mMockContext)).thenReturn(mMockRttRangingDevice);
+        when(mMockRttService.getSubscriber(mMockContext)).thenReturn(mMockRttRangingDevice);
+        when(mMockRangingInjector.getDeviceConfigFacade()).thenReturn(mMockDeviceConfigFacade);
+        when(mMockDeviceConfigFacade.getRttRangingRequestDelay()).thenReturn(0);
+        RangingInjector.setInstance(mMockRangingInjector);
+        when(mMockRangingInjector.isRangingTechnologyEnabled(any())).thenReturn(true);
+        mRttAdapter = new RttAdapter(mMockContext, mMockRangingInjector,
+                MoreExecutors.newDirectExecutorService(),
+                mMockRttService, DEVICE_ROLE_INITIATOR);
+    }
+
+    @Test
+    public void testStartWithValidConfig() {
+        RttConfig config = new RttConfig(
+                DEVICE_ROLE_INITIATOR,
+                mRttRangingParams,
+                mMockSessionConfig,
+                mMockRangingDevice
+        );
+        mRttAdapter.start(config, null, mMockCallback);
+
+        verify(mMockRttRangingDevice, times(1)).startRanging(any(), any());
+        verify(mMockSessionConfig).getRangingMeasurementsLimit();
+
+        mRttAdapter.stop();
+        verify(mMockRttRangingDevice, times(1)).stopRanging();
+    }
+
+    @Test
+    public void testStartWithMeasurementsLimits() {
+        RttConfig config = new RttConfig(
+                DEVICE_ROLE_INITIATOR,
+                mRttRangingParams,
+                new SessionConfig.Builder().setRangingMeasurementsLimit(100).build(),
+                mMockRangingDevice
+        );
+        when(mMockRttRangingDevice.getRttRangingParameters()).thenReturn(mMockRttRangingParameters);
+        when(mMockRttRangingParameters.getUpdateRate()).thenReturn(1);
+        mRttAdapter.start(config, null, mMockCallback);
+
+        verify(mMockRttRangingDevice, times(1)).startRanging(any(), any());
+
+        mRttAdapter.stop();
+        verify(mMockRttRangingDevice, times(1)).stopRanging();
+    }
+
+    @Test
+    public void testStop_WhenNotStarted() {
+        mRttAdapter.stop();
+        verify(mMockRttRangingDevice, never()).stopRanging();
+    }
+
+    @Test
+    public void testAppMovingBackgroundForeground() {
+        RttConfig config = new RttConfig(
+                DEVICE_ROLE_INITIATOR,
+                mRttRangingParams,
+                mMockSessionConfig,
+                mMockRangingDevice
+        );
+        mRttAdapter.start(config, mMockAttributionSource, mMockCallback);
+
+        verify(mMockRttRangingDevice, times(1)).startRanging(any(), any());
+
+        mRttAdapter.appMovedToBackground();
+
+        assertEquals(mRttAdapter.getDataNotificationManager().getCurrentConfig()
+                .getNotificationConfigType(), NOTIFICATION_CONFIG_DISABLE);
+
+        mRttAdapter.appMovedToForeground();
+
+        assertEquals(mRttAdapter.getDataNotificationManager().getCurrentConfig()
+                .getNotificationConfigType(), NOTIFICATION_CONFIG_ENABLE);
+
+        mRttAdapter.stop();
+        verify(mMockRttRangingDevice, times(1)).stopRanging();
+    }
+
+    @Test
+    public void testAppInBackgroundTimeout() {
+        RttConfig config = new RttConfig(
+                DEVICE_ROLE_RESPONDER,
+                mRttRangingParams,
+                mMockSessionConfig,
+                mMockRangingDevice
+        );
+        mRttAdapter.start(config, mMockAttributionSource, mMockCallback);
+
+        mRttAdapter.appInBackgroundTimeout();
+        verify(mMockRttRangingDevice, times(1)).stopRanging();
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/rtt/RttCapabilitiesAdapterTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/rtt/RttCapabilitiesAdapterTest.java
new file mode 100644
index 00000000..bade0341
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/rtt/RttCapabilitiesAdapterTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.rtt;
+
+import static android.ranging.RangingCapabilities.DISABLED_USER;
+import static android.ranging.RangingCapabilities.ENABLED;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static junit.framework.Assert.assertEquals;
+
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.net.wifi.aware.WifiAwareManager;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.CapabilitiesProvider;
+import com.android.server.ranging.rtt.RttCapabilitiesAdapter;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class RttCapabilitiesAdapterTest {
+    @Mock
+    private Context mMockContext;
+    @Mock
+    private PackageManager mMockPackageManager;
+
+    @Mock
+    private WifiAwareManager mMockWifiAwareManager;
+
+    @Mock
+    private CapabilitiesProvider.TechnologyAvailabilityListener mMockListener;
+
+    private RttCapabilitiesAdapter mAdapter;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mMockContext.getSystemService(PackageManager.class)).thenReturn(mMockPackageManager);
+        when(mMockContext.getPackageManager()).thenReturn(mMockPackageManager);
+        when(mMockPackageManager.hasSystemFeature(
+                PackageManager.FEATURE_WIFI_AWARE)).thenReturn(true);
+        when(mMockPackageManager.hasSystemFeature(
+                PackageManager.FEATURE_WIFI_RTT)).thenReturn(true);
+        when(mMockContext.getSystemService(WifiAwareManager.class)).thenReturn(
+                mMockWifiAwareManager);
+        mAdapter = new RttCapabilitiesAdapter(mMockContext, mMockListener);
+    }
+
+    @Test
+    public void testRttCapabilitiesAdapter_enabled() {
+        when(mMockWifiAwareManager.isAvailable()).thenReturn(true);
+        assertEquals(mAdapter.getAvailability(), ENABLED);
+    }
+
+    @Test
+    public void testRttCapabilitiesAdapter_disabled() {
+        assertEquals(mAdapter.getAvailability(), DISABLED_USER);
+    }
+
+    @Test
+    public void testRttGetCapabilities() {
+        when(mMockWifiAwareManager.isAvailable()).thenReturn(true);
+        assertThat(mAdapter.getCapabilities()).isNotNull();
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/rtt/RttConfigTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/rtt/RttConfigTest.java
new file mode 100644
index 00000000..bf2e4d21
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/rtt/RttConfigTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.rtt;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static junit.framework.Assert.assertEquals;
+
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.wifi.rtt.RttRangingParams;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.ranging.rtt.backend.RttRangingParameters;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.rtt.RttConfig;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class RttConfigTest {
+
+    @Test
+    public void testRttConfig() {
+        int deviceRole = DEVICE_ROLE_INITIATOR;
+        RttRangingParams rttRangingParams = new RttRangingParams.Builder("unit_test_rtt")
+                .setMatchFilter(new byte[]{0, 1})
+                .build();
+        SessionConfig sessionConfig = new SessionConfig.Builder().build();
+        RangingDevice peerDevice = new RangingDevice.Builder().build();
+
+        RttConfig config = new RttConfig(deviceRole,
+                rttRangingParams,
+                sessionConfig,
+                peerDevice);
+
+        assertEquals(config.getTechnology(), RangingTechnology.RTT);
+        assertEquals(config.getRangingParams(), rttRangingParams);
+        assertEquals(config.getDeviceRole(), deviceRole);
+        assertEquals(config.getSessionConfig(), sessionConfig);
+        assertEquals(config.getPeerDevice(), peerDevice);
+
+        RttRangingParameters params = config.asBackendParameters();
+        assertThat(params).isNotNull();
+        assertThat(params.toString()).isNotNull();
+    }
+}
+
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/session/BaseRangingSessionTest.java
similarity index 58%
rename from ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionTest.java
rename to ranging/service/tests/unittests/src/com/android/ranging/tests/session/BaseRangingSessionTest.java
index 6628194c..894966d7 100644
--- a/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionTest.java
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/session/BaseRangingSessionTest.java
@@ -14,36 +14,41 @@
  * limitations under the License.
  */
 
-package com.android.server.ranging.tests;
+package com.android.server.ranging.tests.session;
 
 import static com.android.server.ranging.RangingTechnology.CS;
 import static com.android.server.ranging.RangingTechnology.RTT;
 import static com.android.server.ranging.RangingTechnology.UWB;
 
 import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.AlarmManager;
 import android.content.AttributionSource;
+import android.content.Context;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
 import android.ranging.RangingMeasurement;
 import android.ranging.SensorFusionParams;
 import android.ranging.SessionHandle;
-import android.ranging.raw.RawInitiatorRangingParams;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.raw.RawResponderRangingConfig;
+import android.ranging.uwb.UwbRangingParams;
 
 import androidx.test.filters.SmallTest;
 
 import com.android.server.ranging.RangingAdapter;
-import com.android.server.ranging.RangingAdapter.Callback.ClosedReason;
 import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingServiceManager;
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.InternalReason;
+import com.android.server.ranging.session.BaseRangingSession;
 import com.android.server.ranging.session.RangingSessionConfig;
 import com.android.server.ranging.session.RangingSessionConfig.MulticastTechnologyConfig;
 import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
@@ -73,7 +78,7 @@ import java.util.Set;
 @SuppressWarnings("ConstantConditions")
 @RunWith(JUnit4.class)
 @SmallTest
-public class RangingSessionTest {
+public class BaseRangingSessionTest {
     @Rule
     public final MockitoRule mMockito = MockitoJUnit.rule();
 
@@ -81,17 +86,20 @@ public class RangingSessionTest {
     private @Mock SessionHandle mMockSessionHandle;
     private @Mock(answer = Answers.RETURNS_DEEP_STUBS) RangingInjector mMockInjector;
     private @Mock(answer = Answers.RETURNS_DEEP_STUBS) RangingSessionConfig mMockConfig;
-    private @Mock(answer = Answers.RETURNS_DEEP_STUBS) RawInitiatorRangingParams mMockParams;
     private @Mock RangingServiceManager.SessionListener mMockSessionListener;
     private Map<TechnologyConfig, RangingAdapter> mMockAdapters;
-    private RawInitiatorRangingSession mSession;
+    private BaseRangingSession mSession;
+    private @Mock Context mMockContext;
+    private @Mock AlarmManager mMockAlarmManager;
 
     private void configureSession(Set<TechnologyConfig> technologyConfigs) {
         // Create some mock adapters for this session.
         for (TechnologyConfig config : technologyConfigs) {
             RangingAdapter adapter = mock(RangingAdapter.class);
+            when(adapter.isDynamicUpdatePeersSupported()).thenReturn(true);
             mMockAdapters.put(config, adapter);
-            when(mMockInjector.createAdapter(eq(config), anyInt(), any())).thenReturn(adapter);
+            when(mMockInjector.createAdapter(any(), eq(config), any())).thenReturn(
+                    adapter);
         }
 
         // Start the session
@@ -117,12 +125,12 @@ public class RangingSessionTest {
             ArgumentCaptor<RangingAdapter.Callback> callbackCaptor =
                     ArgumentCaptor.forClass(RangingAdapter.Callback.class);
 
-            verify(mMockAdapters.get(config)).start(eq(config), callbackCaptor.capture());
+            verify(mMockAdapters.get(config)).start(eq(config), any(), callbackCaptor.capture());
 
             if (config instanceof MulticastTechnologyConfig c) {
-                c.getPeerDevices().forEach(callbackCaptor.getValue()::onStarted);
+                callbackCaptor.getValue().onStarted(c.getPeerDevices());
             } else if (config instanceof UnicastTechnologyConfig c) {
-                callbackCaptor.getValue().onStarted(c.getPeerDevice());
+                callbackCaptor.getValue().onStarted(ImmutableSet.of(c.getPeerDevice()));
             }
 
             adapterCallbacks.put(config, callbackCaptor.getValue());
@@ -135,11 +143,12 @@ public class RangingSessionTest {
         for (TechnologyConfig config : callbacks.keySet()) {
             verify(mMockAdapters.get(config)).stop();
 
-            callbacks.get(config).onClosed(ClosedReason.REQUESTED);
+            callbacks.get(config).onClosed(InternalReason.LOCAL_REQUEST);
             if (config instanceof MulticastTechnologyConfig c) {
-                c.getPeerDevices().forEach(callbacks.get(config)::onStopped);
+                callbacks.get(config).onStopped(c.getPeerDevices(), InternalReason.LOCAL_REQUEST);
             } else if (config instanceof UnicastTechnologyConfig c) {
-                callbacks.get(config).onStopped(c.getPeerDevice());
+                callbacks.get(config).onStopped(
+                        ImmutableSet.of(c.getPeerDevice()), InternalReason.LOCAL_REQUEST);
             }
         }
     }
@@ -174,9 +183,11 @@ public class RangingSessionTest {
 
     @Before
     public void setup() {
-        when(mMockConfig.getSensorFusionConfig()).thenReturn(
+        when(mMockConfig.getSessionConfig().getSensorFusionParams()).thenReturn(
                 new SensorFusionParams.Builder().setSensorFusionEnabled(true).build()
         );
+        when(mMockInjector.getContext()).thenReturn(mMockContext);
+        when(mMockContext.getSystemService(AlarmManager.class)).thenReturn(mMockAlarmManager);
 
         mSession = new RawInitiatorRangingSession(
                 mMockAttributionSource, mMockSessionHandle, mMockInjector, mMockConfig,
@@ -188,157 +199,164 @@ public class RangingSessionTest {
     @Test
     public void start_startsUnicastTechnology() {
         RangingDevice peer = mock(RangingDevice.class);
-        Set<TechnologyConfig> configs = Set.of(mockTechnologyConfig(UWB, peer));
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(mockTechnologyConfig(UWB, peer));
 
         configureSession(configs);
-        mSession.start(mMockParams);
+        mSession.start(configs);
         mockStartAdapters(configs);
 
-        verify(mMockSessionListener).onTechnologyStarted(eq(peer), eq(UWB));
+        verify(mMockSessionListener).onTechnologyStarted(eq(UWB), eq(Set.of(peer)));
     }
 
     @Test
     public void start_startsMultipleUnicastTechnologies() {
         RangingDevice peer = mock(RangingDevice.class);
-        Set<TechnologyConfig> configs = Set.of(
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(
                 mockTechnologyConfig(UWB, peer),
                 mockTechnologyConfig(RTT, peer));
 
         configureSession(configs);
-        mSession.start(mMockParams);
+        mSession.start(configs);
         mockStartAdapters(configs);
 
-        verify(mMockSessionListener).onTechnologyStarted(eq(peer), eq(UWB));
-        verify(mMockSessionListener).onTechnologyStarted(eq(peer), eq(RTT));
+        verify(mMockSessionListener).onTechnologyStarted(eq(UWB), eq(Set.of(peer)));
+        verify(mMockSessionListener).onTechnologyStarted(eq(RTT), eq(Set.of(peer)));
     }
 
     @Test
     public void start_startsMultipleOfTheSameTechnology() {
         List<RangingDevice> peers = List.of(mock(RangingDevice.class), mock(RangingDevice.class));
-        Set<TechnologyConfig> configs = Set.of(
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(
                 mockTechnologyConfig(UWB, peers.get(0)),
                 mockTechnologyConfig(UWB, peers.get(1)));
 
         configureSession(configs);
-        mSession.start(mMockParams);
+        mSession.start(configs);
         mockStartAdapters(configs);
 
-        verify(mMockSessionListener).onTechnologyStarted(eq(peers.get(0)), eq(UWB));
-        verify(mMockSessionListener).onTechnologyStarted(eq(peers.get(1)), eq(UWB));
+        verify(mMockSessionListener).onTechnologyStarted(eq(UWB), eq(Set.of(peers.get(0))));
+        verify(mMockSessionListener).onTechnologyStarted(eq(UWB), eq(Set.of(peers.get(1))));
     }
 
     @Test
     public void start_startsMulticastTechnology() {
-        List<RangingDevice> peers = List.of(mock(RangingDevice.class), mock(RangingDevice.class));
-        Set<TechnologyConfig> configs = Set.of(mockTechnologyConfig(UWB, Set.copyOf(peers)));
+        Set<RangingDevice> peers = Set.of(mock(RangingDevice.class), mock(RangingDevice.class));
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(
+                mockTechnologyConfig(UWB, peers));
 
         configureSession(configs);
-        mSession.start(mMockParams);
+        mSession.start(configs);
         mockStartAdapters(configs);
 
-        verify(mMockSessionListener).onTechnologyStarted(eq(peers.get(0)), eq(UWB));
-        verify(mMockSessionListener).onTechnologyStarted(eq(peers.get(1)), eq(UWB));
+        verify(mMockSessionListener).onTechnologyStarted(eq(UWB), eq(peers));
     }
 
     @Test
     public void start_doesNotStartUnusedTechnology() {
-        Set<TechnologyConfig> configs = Set.of(
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(
                 mockTechnologyConfig(UWB, mock(RangingDevice.class)));
 
         configureSession(configs);
-        mSession.start(mMockParams);
+        mSession.start(configs);
         mockStartAdapters(configs);
 
-        verify(mMockSessionListener, never()).onTechnologyStarted(any(), eq(CS));
+        verify(mMockSessionListener, never()).onTechnologyStarted(eq(CS), any());
     }
 
     @Test
     public void stop_stopsUnicastTechnology() {
         RangingDevice peer = mock(RangingDevice.class);
-        Set<TechnologyConfig> configs = Set.of(mockTechnologyConfig(UWB, peer));
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(mockTechnologyConfig(UWB, peer));
 
         configureSession(configs);
-        mSession.start(mMockParams);
+        mSession.start(configs);
         Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
                 mockStartAdapters(configs);
 
         mSession.stop();
         mockStopAdapters(adapterCallbacks);
 
-        verify(mMockSessionListener).onTechnologyStopped(eq(peer), eq(UWB));
-        verify(mMockSessionListener).onSessionStopped(ClosedReason.REQUESTED);
+        verify(mMockSessionListener).onTechnologyStopped(
+                eq(UWB), eq(Set.of(peer)), eq(InternalReason.LOCAL_REQUEST));
+        verify(mMockSessionListener).onSessionClosed(InternalReason.LOCAL_REQUEST);
     }
 
     @Test
     public void stop_stopsMultipleUnicastTechnologies() {
         RangingDevice peer = mock(RangingDevice.class);
-        Set<TechnologyConfig> configs = Set.of(
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(
                 mockTechnologyConfig(UWB, peer),
                 mockTechnologyConfig(RTT, peer));
 
         configureSession(configs);
-        mSession.start(mMockParams);
+        mSession.start(configs);
         Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
                 mockStartAdapters(configs);
 
         mSession.stop();
         mockStopAdapters(adapterCallbacks);
 
-        verify(mMockSessionListener).onTechnologyStopped(eq(peer), eq(UWB));
-        verify(mMockSessionListener).onTechnologyStopped(eq(peer), eq(UWB));
-        verify(mMockSessionListener).onSessionStopped(eq(ClosedReason.REQUESTED));
+        verify(mMockSessionListener).onTechnologyStopped(
+                eq(UWB), eq(Set.of(peer)), eq(InternalReason.LOCAL_REQUEST));
+        verify(mMockSessionListener).onTechnologyStopped(
+                eq(UWB), eq(Set.of(peer)), eq(InternalReason.LOCAL_REQUEST));
+        verify(mMockSessionListener).onSessionClosed(eq(InternalReason.LOCAL_REQUEST));
     }
 
     @Test
     public void stop_stopsMulticastTechnology() {
-        List<RangingDevice> peers = List.of(mock(RangingDevice.class), mock(RangingDevice.class));
-        Set<TechnologyConfig> configs = Set.of(mockTechnologyConfig(UWB, Set.copyOf(peers)));
+        Set<RangingDevice> peers = Set.of(mock(RangingDevice.class), mock(RangingDevice.class));
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(mockTechnologyConfig(UWB, peers));
 
         configureSession(configs);
-        mSession.start(mMockParams);
+        mSession.start(configs);
         Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
                 mockStartAdapters(configs);
 
         mSession.stop();
         mockStopAdapters(adapterCallbacks);
 
-        verify(mMockSessionListener).onTechnologyStopped(eq(peers.get(0)), eq(UWB));
-        verify(mMockSessionListener).onTechnologyStopped(eq(peers.get(1)), eq(UWB));
-        verify(mMockSessionListener).onSessionStopped(eq(ClosedReason.REQUESTED));
+        verify(mMockSessionListener).onTechnologyStopped(
+                eq(UWB), eq(peers), eq(InternalReason.LOCAL_REQUEST));
+        verify(mMockSessionListener).onSessionClosed(eq(InternalReason.LOCAL_REQUEST));
     }
 
     @Test
     public void shouldStop_whenTechnologyStops() {
         RangingDevice peer = mock(RangingDevice.class);
         UnicastTechnologyConfig config = mockTechnologyConfig(UWB, peer);
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(config);
 
-        configureSession(Set.of(config));
-        mSession.start(mMockParams);
+        configureSession(configs);
+        mSession.start(configs);
         Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
-                mockStartAdapters(Set.of(config));
+                mockStartAdapters(configs);
 
-        adapterCallbacks.get(config).onStopped(peer);
-        adapterCallbacks.get(config).onClosed(ClosedReason.LOST_CONNECTION);
+        adapterCallbacks.get(config).onStopped(
+                ImmutableSet.of(peer), InternalReason.NO_PEERS_FOUND);
+        adapterCallbacks.get(config).onClosed(InternalReason.NO_PEERS_FOUND);
 
-        verify(mMockSessionListener).onTechnologyStopped(eq(peer), eq(UWB));
-        verify(mMockSessionListener).onSessionStopped(eq(ClosedReason.LOST_CONNECTION));
+        verify(mMockSessionListener).onTechnologyStopped(
+                eq(UWB), eq(Set.of(peer)), eq(InternalReason.NO_PEERS_FOUND));
+        verify(mMockSessionListener).onSessionClosed(eq(InternalReason.NO_PEERS_FOUND));
     }
 
     @Test
     public void shouldStop_whenTechnologyFailsToStart() {
         RangingDevice peer = mock(RangingDevice.class);
         UnicastTechnologyConfig config = mockTechnologyConfig(UWB, peer);
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(config);
 
-        configureSession(Set.of(config));
-        mSession.start(mMockParams);
+        configureSession(configs);
+        mSession.start(configs);
 
         ArgumentCaptor<RangingAdapter.Callback> adapterCallbacks =
                 ArgumentCaptor.forClass(RangingAdapter.Callback.class);
-        verify(mMockAdapters.get(config)).start(eq(config), adapterCallbacks.capture());
+        verify(mMockAdapters.get(config)).start(eq(config), any(), adapterCallbacks.capture());
 
-        adapterCallbacks.getValue().onClosed(ClosedReason.FAILED_TO_START);
+        adapterCallbacks.getValue().onClosed(InternalReason.UNSUPPORTED);
 
-        verify(mMockSessionListener).onSessionStopped(eq(ClosedReason.FAILED_TO_START));
+        verify(mMockSessionListener).onSessionClosed(eq(InternalReason.UNSUPPORTED));
     }
 
     @Test
@@ -347,17 +365,69 @@ public class RangingSessionTest {
         RangingData data = generateData(UWB);
 
         UnicastTechnologyConfig config = mockTechnologyConfig(UWB, peer);
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(config);
 
-        configureSession(Set.of(config));
-        mSession.start(mMockParams);
+        configureSession(configs);
+        mSession.start(configs);
         Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
-                mockStartAdapters(Set.of(config));
+                mockStartAdapters(configs);
 
         adapterCallbacks.get(config).onRangingData(peer, data);
         verify(mMockSessionListener).onResults(
                 eq(peer),
                 argThat((arg) -> arg.getRangingTechnology() == UWB.getValue())
         );
-        verify(mMockSessionListener).onTechnologyStarted(eq(peer), eq(UWB));
+        verify(mMockSessionListener).onTechnologyStarted(eq(UWB), eq(Set.of(peer)));
+    }
+
+    @Test
+    public void dynamicAddOrRemovePeer_callsAdapterAddOrRemovePeer() {
+        RangingDevice peer = mock(RangingDevice.class);
+        UnicastTechnologyConfig config = mockTechnologyConfig(UWB, peer);
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(config);
+
+        configureSession(configs);
+        mSession.start(configs);
+        verify(mMockAdapters.get(config)).start(eq(config), any(), any());
+
+        RangingDevice peerToAdd = mock(RangingDevice.class);
+        RawResponderRangingConfig configToAdd = mock(RawResponderRangingConfig.class);
+        when(configToAdd.getRawRangingDevice()).thenReturn(
+                new RawRangingDevice.Builder()
+                        .setRangingDevice(peerToAdd)
+                        .setUwbRangingParams(mock(UwbRangingParams.class, RETURNS_DEEP_STUBS))
+                        .build());
+
+        mSession.addPeer(configToAdd);
+        verify(mMockAdapters.get(config)).addPeer(eq(configToAdd));
+
+        mSession.removePeer(peerToAdd);
+        verify(mMockAdapters.get(config)).removePeer(peerToAdd);
+
+        mSession.stop();
+        verify(mMockAdapters.get(config)).stop();
+    }
+
+    @Test
+    public void fgStateUpdate_callsAdapterFgStateUpdate() {
+        RangingDevice peer = mock(RangingDevice.class);
+        UnicastTechnologyConfig config = mockTechnologyConfig(UWB, peer);
+        ImmutableSet<TechnologyConfig> configs = ImmutableSet.of(config);
+
+        configureSession(configs);
+        mSession.start(configs);
+        verify(mMockAdapters.get(config)).start(eq(config), any(), any());
+
+        mSession.appForegroundStateUpdated(true);
+        verify(mMockAdapters.get(config)).appForegroundStateUpdated(eq(true));
+
+        mSession.appForegroundStateUpdated(false);
+        verify(mMockAdapters.get(config)).appForegroundStateUpdated(eq(false));
+
+        mSession.appInBackgroundTimeout();
+        verify(mMockAdapters.get(config)).appInBackgroundTimeout();
+
+        mSession.stop();
+        verify(mMockAdapters.get(config)).stop();
     }
 }
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/UwbAdapterTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/uwb/UwbAdapterTest.java
similarity index 80%
rename from ranging/service/tests/unittests/src/com/android/ranging/tests/UwbAdapterTest.java
rename to ranging/service/tests/unittests/src/com/android/ranging/tests/uwb/UwbAdapterTest.java
index 89954704..3d2fab81 100644
--- a/ranging/service/tests/unittests/src/com/android/ranging/tests/UwbAdapterTest.java
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/uwb/UwbAdapterTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,13 +14,14 @@
  * limitations under the License.
  */
 
-package com.android.server.ranging.tests;
+package com.android.server.ranging.tests.uwb;
 
 import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
 import static android.ranging.uwb.UwbRangingParams.CONFIG_MULTICAST_DS_TWR;
 import static android.ranging.uwb.UwbRangingParams.CONFIG_UNICAST_DS_TWR;
 
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.mock;
@@ -28,6 +29,7 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.content.AttributionSource;
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.ranging.RangingDevice;
@@ -42,12 +44,15 @@ import com.android.ranging.uwb.backend.internal.RangingPosition;
 import com.android.ranging.uwb.backend.internal.RangingSessionCallback;
 import com.android.ranging.uwb.backend.internal.UwbDevice;
 import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingInjector;
 import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.InternalReason;
 import com.android.server.ranging.cs.CsConfig;
 import com.android.server.ranging.uwb.UwbAdapter;
 import com.android.server.ranging.uwb.UwbConfig;
 
 import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.MoreExecutors;
 
 import org.junit.Assert;
@@ -77,10 +82,17 @@ public class UwbAdapterTest {
     @Mock
     private RangingController mMockUwbClient;
 
+    @Mock
+    private AttributionSource mMockAttributionSource;
+
+    @Mock
+    private RangingInjector mMockRangingInjector;
+
     @Mock
     private RangingAdapter.Callback mMockCallback;
 
-    @Mock private UwbDevice mMockLocalDevice;
+    @Mock
+    private UwbDevice mMockLocalDevice;
 
     /** Class under test */
     private UwbAdapter mUwbAdapter;
@@ -99,7 +111,6 @@ public class UwbAdapterTest {
                                         .build())
                         .setRangingUpdateRate(UPDATE_RATE_NORMAL)
                         .build())
-                .setCountryCode("US")
                 .setPeerAddresses(ImmutableBiMap.copyOf(peers))
                 .build();
     }
@@ -108,7 +119,9 @@ public class UwbAdapterTest {
     public void setup() {
         when(mMockContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_UWB))
                 .thenReturn(true);
-        mUwbAdapter = new UwbAdapter(mMockContext, MoreExecutors.newDirectExecutorService(),
+        RangingInjector.setInstance(mMockRangingInjector);
+        when(mMockRangingInjector.isRangingTechnologyEnabled(any())).thenReturn(true);
+        mUwbAdapter = new UwbAdapter(mMockContext, mMockRangingInjector, mMockAttributionSource,
                 MoreExecutors.newDirectExecutorService(), mMockUwbClient);
     }
 
@@ -119,10 +132,10 @@ public class UwbAdapterTest {
 
     @Test
     public void start_failsWhenParamsInvalid() {
-        mUwbAdapter.start(mock(CsConfig.class), mMockCallback);
+        mUwbAdapter.start(mock(CsConfig.class), null, mMockCallback);
         verify(mMockCallback, never()).onStarted(any());
-        verify(mMockCallback).onClosed(eq(RangingAdapter.Callback.ClosedReason.FAILED_TO_START));
-        verify(mMockCallback, never()).onStopped(any());
+        verify(mMockCallback).onClosed(eq(InternalReason.INTERNAL_ERROR));
+        verify(mMockCallback, never()).onStopped(any(), anyInt());
     }
 
     @Test
@@ -130,14 +143,15 @@ public class UwbAdapterTest {
         RangingDevice peer = mock(RangingDevice.class);
         mUwbAdapter.start(
                 generateConfig(Map.of(peer, UwbAddress.fromBytes(new byte[]{1, 2}))),
+                null,
                 mMockCallback);
 
         ArgumentCaptor<RangingSessionCallback> callback =
                 ArgumentCaptor.forClass(RangingSessionCallback.class);
-        verify(mMockUwbClient).startRanging(callback.capture(), any());
+        verify(mMockUwbClient).startRanging(callback.capture());
 
         callback.getValue().onRangingInitialized(mMockLocalDevice);
-        verify(mMockCallback).onStarted(eq(peer));
+        verify(mMockCallback).onStarted(eq(ImmutableSet.of(peer)));
     }
 
     @Test
@@ -147,15 +161,15 @@ public class UwbAdapterTest {
                 generateConfig(Map.of(
                         peers.get(0), UwbAddress.fromBytes(new byte[]{1, 2}),
                         peers.get(1), UwbAddress.fromBytes(new byte[]{3, 4}))),
+                null,
                 mMockCallback);
 
         ArgumentCaptor<RangingSessionCallback> callback =
                 ArgumentCaptor.forClass(RangingSessionCallback.class);
-        verify(mMockUwbClient).startRanging(callback.capture(), any());
+        verify(mMockUwbClient).startRanging(callback.capture());
 
         callback.getValue().onRangingInitialized(mMockLocalDevice);
-        verify(mMockCallback).onStarted(eq(peers.get(0)));
-        verify(mMockCallback).onStarted(eq(peers.get(1)));
+        verify(mMockCallback).onStarted(eq(ImmutableSet.copyOf(peers)));
     }
 
     @Test
@@ -165,11 +179,12 @@ public class UwbAdapterTest {
                 generateConfig(Map.of(
                         peers.get(0), UwbAddress.fromBytes(new byte[]{1, 2}),
                         peers.get(1), UwbAddress.fromBytes(new byte[]{3, 4}))),
+                null,
                 mMockCallback);
 
         ArgumentCaptor<RangingSessionCallback> callback =
                 ArgumentCaptor.forClass(RangingSessionCallback.class);
-        verify(mMockUwbClient).startRanging(callback.capture(), any());
+        verify(mMockUwbClient).startRanging(callback.capture());
 
         callback.getValue().onRangingInitialized(mMockLocalDevice);
 
@@ -179,9 +194,10 @@ public class UwbAdapterTest {
         callback.getValue().onRangingSuspended(
                 mMockLocalDevice,
                 RangingSessionCallback.REASON_STOP_RANGING_CALLED);
-        verify(mMockCallback).onStopped(eq(peers.get(0)));
-        verify(mMockCallback).onStopped(eq(peers.get(1)));
-        verify(mMockCallback).onClosed(RangingAdapter.Callback.ClosedReason.REQUESTED);
+        verify(mMockCallback).onStopped(
+                eq(ImmutableSet.copyOf(peers)),
+                eq(InternalReason.LOCAL_REQUEST));
+        verify(mMockCallback).onClosed(eq(InternalReason.LOCAL_REQUEST));
     }
 
     @Test
@@ -191,11 +207,12 @@ public class UwbAdapterTest {
 
         mUwbAdapter.start(
                 generateConfig(Map.of(peerDevice, UwbAddress.fromBytes(peerAddress))),
+                null,
                 mMockCallback);
 
         ArgumentCaptor<RangingSessionCallback> callback =
                 ArgumentCaptor.forClass(RangingSessionCallback.class);
-        verify(mMockUwbClient).startRanging(callback.capture(), any());
+        verify(mMockUwbClient).startRanging(callback.capture());
 
         callback.getValue().onRangingInitialized(mMockLocalDevice);
         callback.getValue().onPeerDisconnected(
@@ -206,8 +223,10 @@ public class UwbAdapterTest {
                 UwbDevice.createForAddress(peerAddress),
                 RangingSessionCallback.REASON_MAX_RANGING_ROUND_RETRY_REACHED);
 
-        verify(mMockCallback).onStopped(eq(peerDevice));
-        verify(mMockCallback).onClosed(eq(RangingAdapter.Callback.ClosedReason.LOST_CONNECTION));
+        verify(mMockCallback).onStopped(
+                eq(ImmutableSet.of(peerDevice)),
+                eq(InternalReason.SYSTEM_POLICY));
+        verify(mMockCallback).onClosed(eq(InternalReason.NO_PEERS_FOUND));
     }
 
     @Test
@@ -217,11 +236,12 @@ public class UwbAdapterTest {
 
         mUwbAdapter.start(
                 generateConfig(Map.of(peerDevice, UwbAddress.fromBytes(peerAddress))),
+                null,
                 mMockCallback);
 
         ArgumentCaptor<RangingSessionCallback> callback =
                 ArgumentCaptor.forClass(RangingSessionCallback.class);
-        verify(mMockUwbClient).startRanging(callback.capture(), any());
+        verify(mMockUwbClient).startRanging(callback.capture());
 
         callback.getValue().onRangingInitialized(mMockLocalDevice);
 
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/uwb/UwbConfigSelectorTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/uwb/UwbConfigSelectorTest.java
new file mode 100644
index 00000000..6f8b4423
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/uwb/UwbConfigSelectorTest.java
@@ -0,0 +1,608 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests.uwb;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+import static android.ranging.oob.OobInitiatorRangingConfig.SECURITY_LEVEL_BASIC;
+import static android.ranging.oob.OobInitiatorRangingConfig.SECURITY_LEVEL_SECURE;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+import static android.ranging.uwb.UwbComplexChannel.UWB_CHANNEL_5;
+import static android.ranging.uwb.UwbComplexChannel.UWB_CHANNEL_9;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_10;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_12;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_27;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_29;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_32;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_9;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_MULTICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_PROVISIONED_MULTICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_PROVISIONED_UNICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_UNICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.DURATION_1_MS;
+import static android.ranging.uwb.UwbRangingParams.DURATION_2_MS;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.ranging.RangingDevice;
+import android.ranging.SessionConfig;
+import android.ranging.SessionHandle;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingCapabilities;
+import android.ranging.uwb.UwbRangingParams;
+import android.util.Pair;
+import android.util.Range;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.ranging.uwb.backend.internal.Utils;
+import com.android.server.ranging.RangingEngine.ConfigSelectionException;
+import com.android.server.ranging.oob.CapabilityResponseMessage;
+import com.android.server.ranging.oob.SetConfigurationMessage.TechnologyOobConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+import com.android.server.ranging.uwb.UwbConfig;
+import com.android.server.ranging.uwb.UwbConfigSelector;
+import com.android.server.ranging.uwb.UwbOobCapabilities;
+import com.android.server.ranging.uwb.UwbOobConfig;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Answers;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import java.time.Duration;
+import java.util.List;
+import java.util.stream.IntStream;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class UwbConfigSelectorTest {
+    @Rule
+    public final MockitoRule mMockito = MockitoJUnit.rule();
+
+    private static final ImmutableList<@UwbRangingParams.ConfigId Integer>
+            DEFAULT_SUPPORTED_CONFIG_IDS = ImmutableList.copyOf(IntStream.rangeClosed(
+                    CONFIG_UNICAST_DS_TWR, CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST)
+            .boxed().toList());
+    private static final ImmutableList<@UwbComplexChannel.UwbChannel Integer>
+            DEFAULT_SUPPORTED_CHANNELS = ImmutableList.of(UWB_CHANNEL_9, UWB_CHANNEL_5);
+    private static final ImmutableList<@UwbComplexChannel.UwbPreambleCodeIndex Integer>
+            DEFAULT_SUPPORTED_PREAMBLE_INDEXES = ImmutableList.copyOf(IntStream.rangeClosed(
+                    UWB_PREAMBLE_CODE_INDEX_9, UWB_PREAMBLE_CODE_INDEX_32)
+            .boxed().toList());
+    private static final ImmutableList<@RawRangingDevice.RangingUpdateRate Integer>
+            DEFAULT_SUPPORTED_UPDATE_RATES = ImmutableList.of(
+            UPDATE_RATE_FREQUENT, UPDATE_RATE_NORMAL, UPDATE_RATE_INFREQUENT);
+    private static final ImmutableList<@RawRangingDevice.RangingUpdateRate Integer>
+            DEFAULT_SUPPORTED_SLOT_DURATIONS = ImmutableList.of(DURATION_1_MS, DURATION_2_MS);
+
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
+    private SessionConfig mMockSessionConfig;
+
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
+    private OobInitiatorRangingConfig mMockOobConfig;
+
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
+    private UwbRangingCapabilities mMockLocalCapabilities;
+
+
+    private void mockConfiguredRangingIntervalRange(Range<Duration> range) {
+        when(mMockOobConfig.getRangingIntervalRange()).thenReturn(range);
+        when(mMockOobConfig.getFastestRangingInterval()).thenReturn(range.getLower());
+        when(mMockOobConfig.getSlowestRangingInterval()).thenReturn(range.getUpper());
+    }
+
+    /** Create class under test */
+    private UwbConfigSelector createConfigSelector() throws ConfigSelectionException {
+        return new UwbConfigSelector(
+                mMockSessionConfig, mMockOobConfig,
+                mock(SessionHandle.class, Answers.RETURNS_DEEP_STUBS), mMockLocalCapabilities);
+    }
+
+    private UwbOobCapabilities.Builder createCapabilities() {
+        return UwbOobCapabilities.builder()
+                .setUwbAddress(mock(UwbAddress.class, Answers.RETURNS_DEEP_STUBS))
+                .setSupportedConfigIds(DEFAULT_SUPPORTED_CONFIG_IDS)
+                .setSupportedChannels(DEFAULT_SUPPORTED_CHANNELS)
+                .setSupportedPreambleIndexes(DEFAULT_SUPPORTED_PREAMBLE_INDEXES)
+                .setMinimumRangingIntervalMs(0)
+                .setMinimumSlotDurationMs(DEFAULT_SUPPORTED_SLOT_DURATIONS
+                        .stream().min(Integer::compareTo).get())
+                .setSupportedDeviceRole(ImmutableList.of(UwbOobConfig.OobDeviceRole.INITIATOR));
+    }
+
+    private CapabilityResponseMessage mockCapabilitiesResponse(UwbOobCapabilities uwbCapabilities) {
+        CapabilityResponseMessage response = mock(CapabilityResponseMessage.class);
+        when(response.getUwbCapabilities()).thenReturn(uwbCapabilities);
+        return response;
+    }
+
+    @Before
+    public void setup() {
+        when(mMockSessionConfig.isAngleOfArrivalNeeded()).thenReturn(false);
+
+        when(mMockOobConfig.getSecurityLevel()).thenReturn(SECURITY_LEVEL_BASIC);
+        mockConfiguredRangingIntervalRange(Range.create(Duration.ZERO, Duration.ofDays(1)));
+
+        when(mMockLocalCapabilities.getSupportedConfigIds())
+                .thenReturn(DEFAULT_SUPPORTED_CONFIG_IDS);
+        when(mMockLocalCapabilities.getSupportedChannels()).thenReturn(DEFAULT_SUPPORTED_CHANNELS);
+        when(mMockLocalCapabilities.getSupportedPreambleIndexes())
+                .thenReturn(DEFAULT_SUPPORTED_PREAMBLE_INDEXES);
+        when(mMockLocalCapabilities.getMinimumRangingInterval()).thenReturn(Duration.ZERO);
+        when(mMockLocalCapabilities.getSupportedRangingUpdateRates())
+                .thenReturn(DEFAULT_SUPPORTED_UPDATE_RATES);
+        when(mMockLocalCapabilities.getSupportedSlotDurations())
+                .thenReturn(DEFAULT_SUPPORTED_SLOT_DURATIONS);
+        when(mMockLocalCapabilities.isAzimuthalAngleSupported()).thenReturn(true);
+        when(mMockLocalCapabilities.getCountryCode()).thenReturn("US");
+    }
+
+    @Test(expected = ConfigSelectionException.class)
+    public void newUwbConfigSelector_failsWhenSecurityLevelIncompatible()
+            throws ConfigSelectionException {
+
+        when(mMockOobConfig.getSecurityLevel()).thenReturn(SECURITY_LEVEL_SECURE);
+
+        when(mMockLocalCapabilities.getSupportedConfigIds())
+                .thenReturn(List.of(CONFIG_UNICAST_DS_TWR, CONFIG_MULTICAST_DS_TWR));
+
+        createConfigSelector();
+    }
+
+    @Test(expected = ConfigSelectionException.class)
+    public void addPeerCapabilities_failsWhenPeerIncapableOfInitiatorRole()
+            throws ConfigSelectionException {
+
+        UwbConfigSelector configSelector = createConfigSelector();
+
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setSupportedDeviceRole(
+                                ImmutableList.of(UwbOobConfig.OobDeviceRole.RESPONDER))
+                        .build()));
+    }
+
+    @Test
+    public void shouldUseProvisionedSts_whenSecurityLevelSecure()
+            throws ConfigSelectionException {
+
+        when(mMockOobConfig.getSecurityLevel()).thenReturn(SECURITY_LEVEL_SECURE);
+
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setSupportedConfigIds(ImmutableList.copyOf(IntStream.rangeClosed(
+                                        CONFIG_UNICAST_DS_TWR, CONFIG_PROVISIONED_MULTICAST_DS_TWR)
+                                .boxed()
+                                .toList()))
+                        .build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        UwbConfig localConfig = (UwbConfig) Iterables.getOnlyElement(configs.first);
+        assertThat(localConfig.getParameters().getConfigId())
+                .isEqualTo(CONFIG_PROVISIONED_UNICAST_DS_TWR);
+        assertThat(localConfig.getParameters().getSessionKeyInfo()).hasLength(16);
+
+        UwbOobConfig peerConfig = (UwbOobConfig) Iterables.getOnlyElement(configs.second.values());
+        assertThat(peerConfig.getSelectedConfigId()).isEqualTo(CONFIG_PROVISIONED_UNICAST_DS_TWR);
+        assertThat(peerConfig.getSessionKeyLength()).isEqualTo(16);
+        assertThat(peerConfig.getSessionKey()).hasLength(16);
+    }
+
+    @Test
+    public void shouldUseVeryFastConfigId_whenSupported() throws ConfigSelectionException {
+        when(mMockOobConfig.getSecurityLevel()).thenReturn(SECURITY_LEVEL_SECURE);
+
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setSupportedConfigIds(ImmutableList.of(
+                                CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST,
+                                CONFIG_PROVISIONED_UNICAST_DS_TWR))
+                        .build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        UwbConfig localConfig = (UwbConfig) Iterables.getOnlyElement(configs.first);
+        assertThat(localConfig.getParameters().getConfigId())
+                .isEqualTo(CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST);
+        assertThat(localConfig.getParameters().getRangingUpdateRate())
+                .isEqualTo(UPDATE_RATE_FREQUENT);
+
+        UwbOobConfig peerConfig = (UwbOobConfig) Iterables.getOnlyElement(configs.second.values());
+        assertThat(peerConfig.getSelectedConfigId())
+                .isEqualTo(CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST);
+        assertThat(peerConfig.getSelectedRangingIntervalMs())
+                .isEqualTo(Utils.getRangingTimingParams(CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST)
+                        .getRangingInterval(UPDATE_RATE_FREQUENT));
+    }
+
+    @Test
+    public void shouldConfigureOneSession_whenOnePeerAdded() throws ConfigSelectionException {
+        RangingDevice peer = new RangingDevice.Builder().build();
+
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(peer,
+                mockCapabilitiesResponse(createCapabilities().build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        assertThat(configs.first).hasSize(1);
+        UwbConfig localConfig = (UwbConfig) Iterables.getOnlyElement(configs.first);
+        assertThat(localConfig.getPeerDevices()).containsExactly(peer);
+        assertThat(localConfig.getParameters().getConfigId()).isEqualTo(CONFIG_UNICAST_DS_TWR);
+        assertThat(localConfig.getDeviceRole()).isEqualTo(DEVICE_ROLE_RESPONDER);
+
+        assertThat(configs.second.keySet()).containsExactly(peer);
+        UwbOobConfig peerConfig = (UwbOobConfig) Iterables.getOnlyElement(configs.second.values());
+        assertThat(peerConfig.getDeviceRole()).isEqualTo(UwbOobConfig.OobDeviceRole.INITIATOR);
+        assertThat(peerConfig.getSelectedConfigId()).isEqualTo(CONFIG_UNICAST_DS_TWR);
+    }
+
+    @Test
+    public void shouldConfigureMultipleSessions_whenMultiplePeersAdded()
+            throws ConfigSelectionException {
+
+        List<RangingDevice> peers = List.of(
+                new RangingDevice.Builder().build(),
+                new RangingDevice.Builder().build());
+
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(peers.get(0),
+                mockCapabilitiesResponse(createCapabilities().build()));
+        configSelector.addPeerCapabilities(peers.get(1),
+                mockCapabilitiesResponse(createCapabilities().build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        assertThat(configs.second.keySet()).hasSize(2);
+        for (TechnologyConfig c : configs.first) {
+            UwbConfig localConfig = (UwbConfig) c;
+            assertThat(localConfig.getPeerDevices()).hasSize(1);
+            assertThat(localConfig.getPeerDevices()).containsAnyIn(peers);
+            assertThat(localConfig.getParameters().getConfigId()).isEqualTo(CONFIG_UNICAST_DS_TWR);
+            assertThat(localConfig.getDeviceRole()).isEqualTo(DEVICE_ROLE_RESPONDER);
+        }
+
+        assertThat(configs.second.keySet()).containsExactlyElementsIn(peers);
+        for (TechnologyOobConfig c : configs.second.values()) {
+            UwbOobConfig peerConfig = (UwbOobConfig) c;
+            assertThat(peerConfig.getDeviceRole()).isEqualTo(UwbOobConfig.OobDeviceRole.INITIATOR);
+            assertThat(peerConfig.getSelectedConfigId()).isEqualTo(CONFIG_UNICAST_DS_TWR);
+        }
+    }
+
+    @Test
+    public void shouldSelectFastestUpdateRate_whenConfiguredIntervalOverlapsCapabilities()
+            throws ConfigSelectionException {
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setMinimumRangingIntervalMs(
+                                Utils.getRangingTimingParams(CONFIG_UNICAST_DS_TWR)
+                                        .getRangingIntervalFast())
+                        .build()));
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setMinimumRangingIntervalMs(
+                                Utils.getRangingTimingParams(
+                                                CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST)
+                                        .getRangingIntervalFast())
+                        .build()));
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setMinimumRangingIntervalMs(
+                                Utils.getRangingTimingParams(CONFIG_UNICAST_DS_TWR)
+                                        .getRangingIntervalNormal())
+                        .build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        for (TechnologyConfig c : configs.first) {
+            UwbConfig localConfig = (UwbConfig) c;
+            assertThat(localConfig.getParameters().getRangingUpdateRate())
+                    .isEqualTo(UPDATE_RATE_NORMAL);
+        }
+        for (TechnologyOobConfig c : configs.second.values()) {
+            UwbOobConfig peerConfig = (UwbOobConfig) c;
+            assertThat(peerConfig.getSelectedRangingIntervalMs())
+                    .isEqualTo(Utils.getRangingTimingParams(CONFIG_UNICAST_DS_TWR)
+                            .getRangingIntervalNormal());
+        }
+    }
+
+    @Test
+    public void shouldSelectInfrequentUpdateRate_whenConfiguredIntervalSlowerThanCapabilities()
+            throws ConfigSelectionException {
+
+        mockConfiguredRangingIntervalRange(Range.create(Duration.ofDays(1), Duration.ofDays(2)));
+        when(mMockLocalCapabilities.getMinimumRangingInterval()).thenReturn(Duration.ofMillis(3));
+
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setMinimumRangingIntervalMs(4)
+                        .build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        for (TechnologyConfig c : configs.first) {
+            UwbConfig localConfig = (UwbConfig) c;
+            assertThat(localConfig.getParameters().getRangingUpdateRate())
+                    .isEqualTo(UPDATE_RATE_INFREQUENT);
+        }
+        for (TechnologyOobConfig c : configs.second.values()) {
+            UwbOobConfig peerConfig = (UwbOobConfig) c;
+            assertThat(peerConfig.getSelectedRangingIntervalMs())
+                    .isEqualTo(Utils.getRangingTimingParams(CONFIG_UNICAST_DS_TWR)
+                            .getRangingIntervalInfrequent());
+        }
+    }
+
+    @Test
+    public void shouldSelectFastestUpdateRate_whenConfiguredIntervalFasterThanCapabilities()
+            throws ConfigSelectionException {
+
+        mockConfiguredRangingIntervalRange(Range.create(Duration.ofNanos(1), Duration.ofNanos(2)));
+        when(mMockLocalCapabilities.getMinimumRangingInterval())
+                .thenReturn(Duration.ofMillis(Utils.getRangingTimingParams(CONFIG_UNICAST_DS_TWR)
+                        .getRangingIntervalInfrequent()));
+
+        UwbConfigSelector configSelector = createConfigSelector();
+
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setMinimumRangingIntervalMs(
+                                Utils.getRangingTimingParams(CONFIG_UNICAST_DS_TWR)
+                                        .getRangingIntervalFast())
+                        .build()));
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setMinimumRangingIntervalMs(
+                                Utils.getRangingTimingParams(
+                                                CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST)
+                                        .getRangingIntervalFast())
+                        .build()));
+
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        for (TechnologyConfig c : configs.first) {
+            UwbConfig localConfig = (UwbConfig) c;
+            assertThat(localConfig.getParameters().getRangingUpdateRate())
+                    .isEqualTo(UPDATE_RATE_INFREQUENT);
+        }
+        for (TechnologyOobConfig c : configs.second.values()) {
+            UwbOobConfig peerConfig = (UwbOobConfig) c;
+            assertThat(peerConfig.getSelectedRangingIntervalMs())
+                    .isEqualTo(Utils.getRangingTimingParams(CONFIG_UNICAST_DS_TWR)
+                            .getRangingIntervalInfrequent());
+        }
+    }
+
+    @Test
+    public void shouldPrioritizeChannel9() throws ConfigSelectionException {
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setSupportedChannels(ImmutableList.of(UWB_CHANNEL_5, UWB_CHANNEL_9))
+                        .build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        UwbConfig localConfig = (UwbConfig) Iterables.getOnlyElement(configs.first);
+        assertThat(localConfig.getParameters().getComplexChannel().getChannel())
+                .isEqualTo(UWB_CHANNEL_9);
+        UwbOobConfig peerConfig = (UwbOobConfig) Iterables.getOnlyElement(configs.second.values());
+        assertThat(peerConfig.getSelectedChannel()).isEqualTo(UWB_CHANNEL_9);
+    }
+
+    @Test
+    public void shouldFallbackToChannel5_whenNotAllPeersSupport9()
+            throws ConfigSelectionException {
+
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setSupportedChannels(ImmutableList.of(UWB_CHANNEL_5, UWB_CHANNEL_9))
+                        .build()));
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setSupportedChannels(ImmutableList.of(UWB_CHANNEL_5))
+                        .build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        for (TechnologyConfig c : configs.first) {
+            UwbConfig localConfig = (UwbConfig) c;
+            assertThat(localConfig.getParameters().getComplexChannel().getChannel())
+                    .isEqualTo(UWB_CHANNEL_5);
+        }
+        for (TechnologyOobConfig c : configs.second.values()) {
+            UwbOobConfig peerConfig = (UwbOobConfig) c;
+            assertThat(peerConfig.getSelectedChannel()).isEqualTo(UWB_CHANNEL_5);
+        }
+    }
+
+    @Test
+    public void shouldPrioritizeHprfPreambleIndex() throws ConfigSelectionException {
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setSupportedPreambleIndexes(ImmutableList.of(
+                                UWB_PREAMBLE_CODE_INDEX_29,
+                                UWB_PREAMBLE_CODE_INDEX_10))
+                        .build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        UwbConfig localConfig = (UwbConfig) Iterables.getOnlyElement(configs.first);
+        assertThat(localConfig.getParameters().getComplexChannel().getPreambleIndex())
+                .isEqualTo(UWB_PREAMBLE_CODE_INDEX_29);
+
+        UwbOobConfig peerConfig = (UwbOobConfig) Iterables.getOnlyElement(configs.second.values());
+        assertThat(peerConfig.getSelectedPreambleIndex()).isEqualTo(UWB_PREAMBLE_CODE_INDEX_29);
+    }
+
+    @Test
+    public void shouldFallbackToBprfPreambleIndex_whenNotAllPeersShareAnHprfIndex()
+            throws ConfigSelectionException {
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setSupportedPreambleIndexes(ImmutableList.of(
+                                UWB_PREAMBLE_CODE_INDEX_9,
+                                UWB_PREAMBLE_CODE_INDEX_12,
+                                UWB_PREAMBLE_CODE_INDEX_27))
+                        .build()));
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities()
+                        .setSupportedPreambleIndexes(ImmutableList.of(
+                                UWB_PREAMBLE_CODE_INDEX_12,
+                                UWB_PREAMBLE_CODE_INDEX_32))
+                        .build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        for (TechnologyConfig c : configs.first) {
+            UwbConfig localConfig = (UwbConfig) c;
+            assertThat(localConfig.getParameters().getComplexChannel().getPreambleIndex())
+                    .isEqualTo(UWB_PREAMBLE_CODE_INDEX_12);
+        }
+        for (TechnologyOobConfig c : configs.second.values()) {
+            UwbOobConfig peerConfig = (UwbOobConfig) c;
+            assertThat(peerConfig.getSelectedPreambleIndex()).isEqualTo(UWB_PREAMBLE_CODE_INDEX_12);
+        }
+    }
+
+    @Test
+    public void shouldRespectLocalCapabilities_whenMoreRestrictiveThanPeers()
+            throws ConfigSelectionException {
+        when(mMockLocalCapabilities.getMinimumRangingInterval()).thenReturn(
+                Duration.ofMillis(Utils.getRangingTimingParams(CONFIG_MULTICAST_DS_TWR)
+                        .getRangingIntervalInfrequent()));
+        when(mMockLocalCapabilities.getSupportedRangingUpdateRates())
+                .thenReturn(List.of(UPDATE_RATE_INFREQUENT));
+        when(mMockLocalCapabilities.getSupportedChannels()).thenReturn(List.of(UWB_CHANNEL_5));
+        when(mMockLocalCapabilities.getSupportedPreambleIndexes())
+                .thenReturn(List.of(UWB_PREAMBLE_CODE_INDEX_10));
+        when(mMockLocalCapabilities.getSupportedSlotDurations()).thenReturn(List.of(DURATION_2_MS));
+
+        UwbConfigSelector configSelector = createConfigSelector();
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities().build()));
+        configSelector.addPeerCapabilities(
+                new RangingDevice.Builder().build(),
+                mockCapabilitiesResponse(createCapabilities().build()));
+
+        Pair<
+                ImmutableSet<TechnologyConfig>,
+                ImmutableMap<RangingDevice, TechnologyOobConfig>
+        > configs = configSelector.selectConfigs();
+
+        for (TechnologyConfig c : configs.first) {
+            UwbConfig localConfig = (UwbConfig) c;
+            assertThat(localConfig.getParameters().getRangingUpdateRate())
+                    .isEqualTo(UPDATE_RATE_INFREQUENT);
+            assertThat(localConfig.getParameters().getComplexChannel().getChannel())
+                    .isEqualTo(UWB_CHANNEL_5);
+            assertThat(localConfig.getParameters().getComplexChannel().getPreambleIndex())
+                    .isEqualTo(UWB_PREAMBLE_CODE_INDEX_10);
+            assertThat(localConfig.getParameters().getSlotDuration())
+                    .isEqualTo(DURATION_2_MS);
+        }
+
+        for (TechnologyOobConfig c : configs.second.values()) {
+            UwbOobConfig peerConfig = (UwbOobConfig) c;
+            assertThat(peerConfig.getSelectedRangingIntervalMs())
+                    .isEqualTo(Utils.getRangingTimingParams(CONFIG_UNICAST_DS_TWR)
+                            .getRangingIntervalInfrequent());
+            assertThat(peerConfig.getSelectedChannel()).isEqualTo(UWB_CHANNEL_5);
+            assertThat(peerConfig.getSelectedPreambleIndex()).isEqualTo(UWB_PREAMBLE_CODE_INDEX_10);
+            assertThat(peerConfig.getSelectedSlotDurationMs()).isEqualTo(DURATION_2_MS);
+        }
+    }
+}
diff --git a/ranging/test_app/Android.bp b/ranging/test_app/Android.bp
new file mode 100644
index 00000000..27fa302f
--- /dev/null
+++ b/ranging/test_app/Android.bp
@@ -0,0 +1,30 @@
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+android_app {
+    name: "RangingTestApp",
+    certificate: ":com.android.ranging.rangingtestapp.certificate",
+    min_sdk_version: "36",
+    target_sdk_version: "36",
+    sdk_version: "current",
+    srcs: ["app/src/main/**/*.java"],
+    resource_dirs: ["app/src/main/res"],
+    manifest: "app/src/main/AndroidManifest.xml",
+
+    static_libs: [
+        "androidx-constraintlayout_constraintlayout",
+        "androidx.appcompat_appcompat",
+        "androidx.lifecycle_lifecycle-extensions",
+        "androidx.navigation_navigation-fragment",
+        "androidx.navigation_navigation-runtime",
+        "androidx.navigation_navigation-ui",
+        "com.google.android.material_material",
+        "truth",
+    ],
+}
+
+android_app_certificate {
+    name: "com.android.ranging.rangingtestapp.certificate",
+    certificate: "com.android.ranging.rangingtestapp",
+}
diff --git a/ranging/test_app/README b/ranging/test_app/README
new file mode 100644
index 00000000..a20a7deb
--- /dev/null
+++ b/ranging/test_app/README
@@ -0,0 +1,9 @@
+1. Build the app
+make RangingTestApp
+2. Load the app
+adb install -r -g ${ANDROID_PRODUCT_OUT}/system/app/RangingTestApp.apk
+3. Launch APK and Run tests
+
+Note:
+1. If you want to use channel sounding, pair devices from settings.
+2. One device works as 'Initiator', Another device works as 'Responder'.
diff --git a/ranging/test_app/app/.gitignore b/ranging/test_app/app/.gitignore
new file mode 100644
index 00000000..42afabfd
--- /dev/null
+++ b/ranging/test_app/app/.gitignore
@@ -0,0 +1 @@
+/build
\ No newline at end of file
diff --git a/ranging/test_app/app/build.gradle.kts b/ranging/test_app/app/build.gradle.kts
new file mode 100644
index 00000000..4a8ccebd
--- /dev/null
+++ b/ranging/test_app/app/build.gradle.kts
@@ -0,0 +1,63 @@
+plugins {
+  alias(libs.plugins.androidApplication)
+}
+
+android {
+  namespace = "com.android.ranging.rangingtestapp"
+  compileSdkVersion = "android-Baklava"
+
+  defaultConfig {
+    applicationId = "com.android.ranging.rangingtestapp"
+    minSdk = 35
+    targetSdk = 35
+    versionCode = 1
+    versionName = "1.0"
+
+    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+  }
+
+  signingConfigs {
+    create("config") {
+      storeFile = file("com.android.ranging.rangingtestapp.keystore")
+      storePassword =  "RangingTestApp"
+      keyAlias = "com.android.ranging.rangingtestapp"
+      keyPassword = "RangingTestApp"
+    }
+  }
+
+  buildTypes {
+    release {
+      isMinifyEnabled = false
+      proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
+      signingConfig = signingConfigs.findByName("config")
+    }
+    debug {
+      isMinifyEnabled = false
+      proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
+      signingConfig = signingConfigs.findByName("config")
+    }
+  }
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+  buildFeatures {
+    viewBinding = true
+  }
+  buildToolsVersion = "35.0.0"
+}
+
+dependencies {
+
+  implementation(libs.appcompat)
+  implementation(libs.material)
+  implementation(libs.constraintlayout)
+  implementation(libs.navigation.fragment)
+  implementation(libs.navigation.ui)
+  implementation(libs.legacy.support.v4)
+  implementation(libs.lifecycle.livedata.ktx)
+  implementation(libs.lifecycle.viewmodel.ktx)
+  testImplementation(libs.junit)
+  androidTestImplementation(libs.ext.junit)
+  androidTestImplementation(libs.espresso.core)
+}
diff --git a/ranging/test_app/app/proguard-rules.pro b/ranging/test_app/app/proguard-rules.pro
new file mode 100644
index 00000000..481bb434
--- /dev/null
+++ b/ranging/test_app/app/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
\ No newline at end of file
diff --git a/ranging/test_app/app/src/androidTest/java/com/android/bluetooth/channelsoundingtestapp/ExampleInstrumentedTest.java b/ranging/test_app/app/src/androidTest/java/com/android/bluetooth/channelsoundingtestapp/ExampleInstrumentedTest.java
new file mode 100644
index 00000000..ad44c2b5
--- /dev/null
+++ b/ranging/test_app/app/src/androidTest/java/com/android/bluetooth/channelsoundingtestapp/ExampleInstrumentedTest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+
+    @Test
+    public void useAppContext() {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        assertThat(appContext.getPackageName())
+                .isEqualto("com.android.ranging.rangingtestapp");
+    }
+}
diff --git a/ranging/test_app/app/src/main/AndroidManifest.xml b/ranging/test_app/app/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..f923cbef
--- /dev/null
+++ b/ranging/test_app/app/src/main/AndroidManifest.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.android.ranging.rangingtestapp">
+    <uses-feature android:name="android.hardware.bluetooth" android:required="true"/>
+    <uses-feature android:name="android.hardware.uwb" android:required="false"/>
+    <uses-feature android:name="android.hardware.wifi.aware" android:required="false"/>
+
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+    <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
+    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
+    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
+    <uses-permission android:name="android.permission.RANGING" />
+
+  <application
+      android:allowBackup="true"
+      android:dataExtractionRules="@xml/data_extraction_rules"
+      android:fullBackupContent="@xml/backup_rules"
+      android:icon="@mipmap/ic_launcher"
+      android:label="@string/app_name"
+      android:roundIcon="@mipmap/ic_launcher_round"
+      android:supportsRtl="true"
+      android:theme="@style/Theme.RangingTestApp"
+      tools:targetApi="35">
+    <activity
+        android:name=".MainActivity"
+        android:exported="true"
+        android:theme="@style/Theme.RangingTestApp">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN" />
+
+        <category android:name="android.intent.category.LAUNCHER" />
+      </intent-filter>
+    </activity>
+  </application>
+
+</manifest>
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnection.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnection.java
new file mode 100644
index 00000000..520e2f9f
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnection.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+public interface BleConnection {
+    default int waitForPsm() {
+        throw new UnsupportedOperationException("waitForPsm not implemented");
+    }
+
+    default void notifyPsm(int psm) {
+        throw new UnsupportedOperationException("notifyPsm not implemented");
+    }
+}
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionCentralFragment.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionCentralFragment.java
new file mode 100644
index 00000000..d0eb6391
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionCentralFragment.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemSelectedListener;
+import android.widget.ArrayAdapter;
+import android.widget.Button;
+import android.widget.Spinner;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.fragment.app.Fragment;
+import androidx.lifecycle.ViewModelProvider;
+
+import java.util.ArrayList;
+
+/** Child fragment to handle BLE GATT connection. */
+@SuppressWarnings("SetTextI18n")
+public class BleConnectionCentralFragment extends Fragment {
+
+    private BleConnectionCentralViewModel mViewModel;
+    private ArrayAdapter<String> mConnectedBtDevicesArrayAdapterCentral;
+    private Button mButtonScanConnect;
+    private Spinner mSpinnerBtAddressCentral;
+
+    public static BleConnectionCentralFragment newInstance() {
+        return new BleConnectionCentralFragment();
+    }
+
+    @Override
+    public View onCreateView(
+            @NonNull LayoutInflater inflater,
+            @Nullable ViewGroup container,
+            @Nullable Bundle savedInstanceState) {
+
+        View root = inflater.inflate(R.layout.fragment_ble_connection_central, container, false);
+        mButtonScanConnect = (Button) root.findViewById(R.id.btn_scan_connect);
+        mSpinnerBtAddressCentral = (Spinner) root.findViewById(R.id.spinner_bt_address_central);
+        return root;
+    }
+
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+
+        mConnectedBtDevicesArrayAdapterCentral =
+                new ArrayAdapter<String>(
+                        getContext(), android.R.layout.simple_spinner_item, new ArrayList<>());
+        mConnectedBtDevicesArrayAdapterCentral.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mSpinnerBtAddressCentral.setAdapter(mConnectedBtDevicesArrayAdapterCentral);
+
+        mViewModel =
+                new ViewModelProvider(requireParentFragment()).get(BleConnectionCentralViewModel.class);
+        mViewModel
+                .getGattState()
+                .observe(
+                        getActivity(),
+                        gattSate -> {
+                            switch (gattSate) {
+                                case SCANNING:
+                                    mButtonScanConnect.setText("Stop Scan");
+                                    break;
+                                case CONNECTED:
+                                    mButtonScanConnect.setText("Disconnect Gatt");
+                                    break;
+                                case DISCONNECTED:
+                                default:
+                                    mButtonScanConnect.setText("Scan and Connect");
+                            }
+                        });
+        mViewModel
+                .getConnectedDeviceAddresses()
+                .observe(
+                        getActivity(),
+                        deviceList -> {
+                            mConnectedBtDevicesArrayAdapterCentral.clear();
+                            mConnectedBtDevicesArrayAdapterCentral.addAll(deviceList);
+                            if (mSpinnerBtAddressCentral.getSelectedItem() != null) {
+                                String selectedBtAddress =
+                                        mSpinnerBtAddressCentral.getSelectedItem().toString();
+                                mViewModel.setTargetDevice(selectedBtAddress);
+                            }
+                        });
+        mSpinnerBtAddressCentral.setOnItemSelectedListener(
+                new OnItemSelectedListener() {
+                    @Override
+                    public void onItemSelected(
+                            AdapterView<?> adapterView, View view, int i, long l) {
+                        String btAddress = mSpinnerBtAddressCentral.getSelectedItem().toString();
+                        mViewModel.setTargetDevice(btAddress);
+                    }
+
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+                        mViewModel.setTargetDevice("");
+                    }
+                });
+        mButtonScanConnect.setOnClickListener(
+                v -> {
+                    mViewModel.toggleScanConnect();
+                });
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionCentralViewModel.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionCentralViewModel.java
new file mode 100644
index 00000000..3225b60e
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionCentralViewModel.java
@@ -0,0 +1,297 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.annotation.SuppressLint;
+import android.app.Application;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCallback;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattService;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanCallback;
+import android.bluetooth.le.ScanFilter;
+import android.bluetooth.le.ScanResult;
+import android.bluetooth.le.ScanSettings;
+import android.os.ParcelUuid;
+import android.text.TextUtils;
+import android.util.ArraySet;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.lifecycle.AndroidViewModel;
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
+import androidx.lifecycle.ViewModel;
+import androidx.lifecycle.ViewModelProvider;
+
+import com.android.ranging.rangingtestapp.Constants.GattState;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+
+/** The ViewModel for the BLE GATT connection. */
+@SuppressLint("MissingPermission") // permissions are checked upfront
+public class BleConnectionCentralViewModel extends AndroidViewModel implements BleConnection {
+    private static final int GATT_MTU_SIZE = 512;
+    private final BluetoothAdapter mBluetoothAdapter;
+    private final BluetoothManager mBluetoothManager;
+    private final LoggingListener mLoggingListener;
+    @Nullable private Set<BluetoothDevice> mConnectedDevices = new ArraySet<>();
+    @Nullable private Set<BluetoothGatt> mConnectedGatts = new ArraySet<>();
+    private MutableLiveData<BluetoothDevice> mTargetDevice = new MutableLiveData<>();
+    // scanner
+    private final MutableLiveData<List<String>> mConnectedDeviceAddresses = new MutableLiveData<>();
+    private final MutableLiveData<GattState> mGattState = new MutableLiveData<>(GattState.DISCONNECTED);
+    private String mTargetBtAddress = "";
+    private CountDownLatch mPsmCountDownLatch = new CountDownLatch(1);
+    private int mPsm = -1;
+
+    public static class Factory implements ViewModelProvider.Factory {
+        private Application mApplication;
+        private LoggingListener mLoggingListener;
+
+        public Factory(Application application,
+                       LoggingListener loggingListener) {
+            mApplication = application;
+            mLoggingListener = loggingListener;
+        }
+
+
+        @Override
+        public <T extends ViewModel> T create(Class<T> modelClass) {
+            return (T) new BleConnectionCentralViewModel(
+                    mApplication, mLoggingListener);
+        }
+    }
+
+    /** Constructor */
+    public BleConnectionCentralViewModel(@NonNull Application application,
+                                         LoggingListener loggingListener) {
+        super(application);
+        mBluetoothManager = application.getSystemService(BluetoothManager.class);
+        mBluetoothAdapter = mBluetoothManager.getAdapter();
+        mLoggingListener = loggingListener;
+    }
+
+    LiveData<GattState> getGattState() {
+        return mGattState;
+    }
+
+    LiveData<List<String>> getConnectedDeviceAddresses() {
+        return mConnectedDeviceAddresses;
+    }
+
+    LiveData<BluetoothDevice> getTargetDevice() {
+        return mTargetDevice;
+    }
+
+    private void updateConnectedDevices() {
+        List<String> connectedDevices =
+                // Append name to the address for better readability
+                mConnectedDevices.stream()
+                        .map(d -> d.getAddress() + "(" + d.getName() + ")")
+                        .collect(Collectors.toList());
+        mConnectedDeviceAddresses.postValue(connectedDevices);
+    }
+
+    void setTargetDevice(String deviceAddressAndName) {
+        printLog("set target address: " + deviceAddressAndName);
+        if (!TextUtils.isEmpty(deviceAddressAndName)) {
+            mTargetBtAddress = deviceAddressAndName.substring(0, 17); // Remove the name appended
+            mTargetDevice.postValue(mBluetoothAdapter.getRemoteDevice(mTargetBtAddress));
+        } else {
+            mTargetBtAddress = "";
+            mTargetDevice.postValue(null);
+        }
+    }
+
+    @Override
+    public int waitForPsm() {
+        boolean success = false;
+        try {
+            success = mPsmCountDownLatch.await(1, TimeUnit.MINUTES);
+        } catch (InterruptedException e) {
+            printLog("Failed to wait for PSM" + e);
+        }
+        if (!success) printLog("Timed out waiting for PSM");
+        return mPsm;
+    }
+
+    void toggleScanConnect() {
+        if (mGattState.getValue() == GattState.DISCONNECTED) {
+            connectGattByScanning();
+        } else if (mGattState.getValue() == GattState.SCANNING) {
+            stopScanning();
+        } else if (mGattState.getValue() == GattState.CONNECTED) {
+            disconnectGatt();
+        }
+    }
+
+    private BluetoothGattCallback mGattCallback =
+            new BluetoothGattCallback() {
+                @Override
+                public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
+                    printLog("onConnectionStateChange status:" + status + ", newState:" + newState);
+                    BluetoothDevice device = gatt.getDevice();
+                    if (newState == BluetoothProfile.STATE_CONNECTED) {
+                        printLog(device.getName() + " is connected");
+                        gatt.requestMtu(GATT_MTU_SIZE);
+                        gatt.discoverServices();
+                        if (mTargetBtAddress.equals(device.getAddress())) {
+                            mTargetDevice.postValue(device);
+                        }
+                        mConnectedDevices.add(device);
+                        mConnectedGatts.add(gatt);
+                        mGattState.postValue(GattState.CONNECTED);
+                    } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
+                        printLog("disconnected from " + device.getName());
+                        gatt.close();
+                        if (mTargetBtAddress.equals(device.getAddress())) {
+                            mTargetDevice.postValue(null);
+                        }
+                        mConnectedDevices.remove(device);
+                        mConnectedGatts.remove(gatt);
+                        if (mConnectedDevices.isEmpty()) {
+                            mGattState.postValue(GattState.DISCONNECTED);
+                        }
+                    }
+                    updateConnectedDevices();
+                }
+
+                @Override
+                public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {
+                    if (status == BluetoothGatt.GATT_SUCCESS) {
+                        printLog("MTU changed to: " + mtu);
+                    } else {
+                        printLog("MTU change failed: " + status);
+                    }
+                }
+
+                @Override
+                public void onServicesDiscovered(BluetoothGatt gatt, int status) {
+                    if (status == BluetoothGatt.GATT_SUCCESS) {
+                        for (BluetoothGattService service : gatt.getServices()) {
+                            if (service.getUuid().equals(Constants.OOB_SERVICE)) {
+                                printLog("Listening for PSM characteristics change");
+                                BluetoothGattCharacteristic characteristic =
+                                        service.getCharacteristic(
+                                                Constants.OOB_PSM_CHARACTERISTICS);
+                                if (characteristic == null) {
+                                    printLog("Failed to get PSM characteristic");
+                                    return;
+                                }
+                                gatt.setCharacteristicNotification(characteristic, true);
+                            }
+                        }
+                    } else {
+                        printLog("Service discovery failed: " + status);
+                    }
+                }
+
+                @Override
+                public void onCharacteristicChanged(BluetoothGatt gatt,
+                        BluetoothGattCharacteristic characteristic, byte[] data) {
+                    printLog("GATT characteristics changed: " + characteristic + ", data: "
+                                 + Arrays.toString(data));
+                    if (characteristic.getUuid().equals(Constants.OOB_PSM_CHARACTERISTICS)) {
+                        mPsm = ByteBuffer.wrap(data).getInt();
+                        printLog("Received PSM value " + mPsm);
+                        mPsmCountDownLatch.countDown();
+                    }
+                }
+            };
+
+    private ScanCallback mScanCallback =
+            new ScanCallback() {
+                @Override
+                public void onScanResult(int callbackType, ScanResult result) {
+                    List<ParcelUuid> serviceUuids = result.getScanRecord().getServiceUuids();
+                    if (serviceUuids != null) {
+                        for (ParcelUuid parcelUuid : serviceUuids) {
+                            BluetoothDevice btDevice = result.getDevice();
+                            printLog("found device - " + btDevice.getName());
+                            if (parcelUuid.getUuid().equals(Constants.RANGING_TEST_SERVICE_UUID)) {
+                                stopScanning();
+                                printLog("connect GATT to: " + btDevice.getName());
+                                // Connect to the GATT server
+                                btDevice.connectGatt(
+                                        getApplication().getApplicationContext(),
+                                        false,
+                                        mGattCallback,
+                                        BluetoothDevice.TRANSPORT_LE);
+                            }
+                        }
+                    }
+                }
+            };
+
+    private void connectGattByScanning() {
+        BluetoothLeScanner bluetoothLeScanner = mBluetoothAdapter.getBluetoothLeScanner();
+
+        List<ScanFilter> filters = new ArrayList<>();
+        ScanFilter filter =
+                new ScanFilter.Builder()
+                        .setServiceUuid(
+                                new ParcelUuid(Constants.RANGING_TEST_SERVICE_UUID))
+                        .build();
+        filters.add(filter);
+
+        ScanSettings settings =
+                new ScanSettings.Builder()
+                        .setLegacy(false)
+                        .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES)
+                        .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
+                        .setReportDelay(0)
+                        .build();
+
+        printLog("start scanning...");
+
+        // Start scanning
+        bluetoothLeScanner.startScan(filters, settings, mScanCallback);
+        mGattState.setValue(GattState.SCANNING);
+    }
+
+    private void stopScanning() {
+        BluetoothLeScanner bluetoothLeScanner = mBluetoothAdapter.getBluetoothLeScanner();
+        if (bluetoothLeScanner != null) {
+            bluetoothLeScanner.stopScan(mScanCallback);
+            mGattState.setValue(GattState.DISCONNECTED);
+        }
+    }
+
+    private void disconnectGatt() {
+        for (BluetoothGatt gatt: mConnectedGatts) {
+            printLog("disconnect from " + gatt.getDevice().getName());
+            gatt.disconnect();
+        }
+    }
+
+    private void printLog(@NonNull String logMsg) {
+        mLoggingListener.log(logMsg);
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionPeripheralFragment.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionPeripheralFragment.java
new file mode 100644
index 00000000..ba8eab11
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionPeripheralFragment.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemSelectedListener;
+import android.widget.ArrayAdapter;
+import android.widget.Button;
+import android.widget.Spinner;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.fragment.app.Fragment;
+import androidx.lifecycle.ViewModelProvider;
+
+import java.util.ArrayList;
+
+/** Child fragment to handle BLE GATT connection. */
+@SuppressWarnings("SetTextI18n")
+public class BleConnectionPeripheralFragment extends Fragment {
+
+    private BleConnectionPeripheralViewModel mViewModel;
+    private Button mBtnAdvertising;
+
+    private ArrayAdapter<String> mConnectedBtDevicesArrayAdapterPeripheral;
+    private Spinner mSpinnerBtAddressPeripheral;
+
+    public static BleConnectionPeripheralFragment newInstance() {
+        return new BleConnectionPeripheralFragment();
+    }
+
+    @Override
+    public View onCreateView(
+            @NonNull LayoutInflater inflater,
+            @Nullable ViewGroup container,
+            @Nullable Bundle savedInstanceState) {
+
+        View root = inflater.inflate(R.layout.fragment_ble_connection_peripheral, container, false);
+        mBtnAdvertising = root.findViewById(R.id.btn_advertising);
+        mSpinnerBtAddressPeripheral = (Spinner) root.findViewById(R.id.spinner_bt_address_peripheral);
+        return root;
+    }
+
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+
+        mConnectedBtDevicesArrayAdapterPeripheral =
+                new ArrayAdapter<String>(
+                        getContext(), android.R.layout.simple_spinner_item, new ArrayList<>());
+        mConnectedBtDevicesArrayAdapterPeripheral.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mSpinnerBtAddressPeripheral.setAdapter(mConnectedBtDevicesArrayAdapterPeripheral);
+
+        mViewModel =
+                new ViewModelProvider(requireParentFragment()).get(BleConnectionPeripheralViewModel.class);
+        mViewModel
+                .getConnectedDeviceAddresses()
+                .observe(
+                        getActivity(),
+                        deviceList -> {
+                            mConnectedBtDevicesArrayAdapterPeripheral.clear();
+                            mConnectedBtDevicesArrayAdapterPeripheral.addAll(deviceList);
+                            if (mSpinnerBtAddressPeripheral.getSelectedItem() != null) {
+                                String selectedBtAddress =
+                                        mSpinnerBtAddressPeripheral.getSelectedItem().toString();
+                                mViewModel.setTargetDevice(selectedBtAddress);
+                            }
+                        });
+        mSpinnerBtAddressPeripheral.setOnItemSelectedListener(
+                new OnItemSelectedListener() {
+                    @Override
+                    public void onItemSelected(
+                            AdapterView<?> adapterView, View view, int i, long l) {
+                        String btAddress = mSpinnerBtAddressPeripheral.getSelectedItem().toString();
+                        mViewModel.setTargetDevice(btAddress);
+                    }
+
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+                        mViewModel.setTargetDevice("");
+                    }
+                });
+        mViewModel
+                .getIsAdvertising()
+                .observe(
+                        getActivity(),
+                        isAdvertising -> {
+                            if (isAdvertising) {
+                                mBtnAdvertising.setText("Stop Advertising");
+                            } else {
+                                mBtnAdvertising.setText("Start Advertising");
+                            }
+                        });
+
+        mBtnAdvertising.setOnClickListener(
+                new OnClickListener() {
+                    @Override
+                    public void onClick(View view) {
+                        mViewModel.toggleAdvertising();
+                    }
+                });
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionPeripheralViewModel.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionPeripheralViewModel.java
new file mode 100644
index 00000000..b070485c
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/BleConnectionPeripheralViewModel.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.annotation.SuppressLint;
+import android.app.Application;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattServer;
+import android.bluetooth.BluetoothGattServerCallback;
+import android.bluetooth.BluetoothGattService;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothStatusCodes;
+import android.bluetooth.le.AdvertiseData;
+import android.bluetooth.le.AdvertisingSet;
+import android.bluetooth.le.AdvertisingSetCallback;
+import android.bluetooth.le.AdvertisingSetParameters;
+import android.bluetooth.le.BluetoothLeAdvertiser;
+import android.os.ParcelUuid;
+import android.text.TextUtils;
+import android.util.ArraySet;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.lifecycle.AndroidViewModel;
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
+import androidx.lifecycle.ViewModel;
+import androidx.lifecycle.ViewModelProvider;
+
+import java.nio.ByteBuffer;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/** The ViewModel for the BLE GATT connection. */
+@SuppressLint("MissingPermission") // permissions are checked upfront
+public class BleConnectionPeripheralViewModel extends AndroidViewModel implements BleConnection {
+    private final BluetoothAdapter mBluetoothAdapter;
+    private final BluetoothManager mBluetoothManager;
+    private final LoggingListener mLoggingListener;
+    @Nullable private Set<BluetoothDevice> mConnectedDevices = new ArraySet<>();
+    private BluetoothGattServer mBluetoothGattServer = null;
+    private MutableLiveData<Boolean> mIsAdvertising = new MutableLiveData<>(false);
+    private MutableLiveData<BluetoothDevice> mTargetDevice = new MutableLiveData<>();
+    // scanner
+    private final MutableLiveData<List<String>> mConnectedDeviceAddresses = new MutableLiveData<>();
+    private String mTargetBtAddress = "";
+    private int mPsm = -1;
+
+    public static class Factory implements ViewModelProvider.Factory {
+        private Application mApplication;
+        private LoggingListener mLoggingListener;
+
+        public Factory(Application application,
+                       LoggingListener loggingListener) {
+            mApplication = application;
+            mLoggingListener = loggingListener;
+        }
+
+
+        @Override
+        public <T extends ViewModel> T create(Class<T> modelClass) {
+            return (T) new BleConnectionPeripheralViewModel(
+                    mApplication, mLoggingListener);
+        }
+    }
+
+    /** Constructor */
+    public BleConnectionPeripheralViewModel(@NonNull Application application,
+                                            LoggingListener loggingListener) {
+        super(application);
+        mBluetoothManager = application.getSystemService(BluetoothManager.class);
+        mBluetoothAdapter = mBluetoothManager.getAdapter();
+        mLoggingListener = loggingListener;
+    }
+
+    LiveData<Boolean> getIsAdvertising() {
+        return mIsAdvertising;
+    }
+
+    LiveData<List<String>> getConnectedDeviceAddresses() {
+        return mConnectedDeviceAddresses;
+    }
+
+    LiveData<BluetoothDevice> getTargetDevice() {
+        return mTargetDevice;
+    }
+
+    private void updateConnectedDevices() {
+        List<String> connectedDevices =
+                // Append name to the address for better readability
+                mConnectedDevices.stream()
+                        .map(d -> d.getAddress() + "(" + d.getName() + ")")
+                        .collect(Collectors.toList());
+        mConnectedDeviceAddresses.postValue(connectedDevices);
+    }
+
+    void setTargetDevice(String deviceAddressAndName) {
+        printLog("set target address: " + deviceAddressAndName);
+        if (!TextUtils.isEmpty(deviceAddressAndName)) {
+            mTargetBtAddress = deviceAddressAndName.substring(0, 17); // Remove the name appended
+            mTargetDevice.postValue(mBluetoothAdapter.getRemoteDevice(mTargetBtAddress));
+        } else {
+            mTargetBtAddress = "";
+            mTargetDevice.postValue(null);
+        }
+    }
+
+    @Override
+    public void notifyPsm(int psm) {
+        mPsm = psm;
+        printLog("Notify PSM characteristic change");
+        BluetoothGattCharacteristic characteristic =
+                mBluetoothGattServer.getService(Constants.OOB_SERVICE)
+                        .getCharacteristic(Constants.OOB_PSM_CHARACTERISTICS);
+        int status = mBluetoothGattServer.notifyCharacteristicChanged(
+                mTargetDevice.getValue(), characteristic, true,
+                ByteBuffer.allocate(4).putInt(mPsm).array());
+        if (status != BluetoothStatusCodes.SUCCESS) {
+            printLog("Failed to notify PSM characteristics change");
+        }
+    }
+
+    /******** Peripheral functions ********************/
+    void toggleAdvertising() {
+        if (mIsAdvertising.getValue()) {
+            stopAdvertising();
+        } else {
+            startConnectableAdvertising();
+        }
+    }
+
+    AdvertisingSetCallback mAdvertisingSetCallback =
+            new AdvertisingSetCallback() {
+                @Override
+                public void onAdvertisingSetStarted(
+                        AdvertisingSet advertisingSet, int txPower, int status) {
+                    printLog(
+                            "onAdvertisingSetStarted(): txPower:"
+                                    + txPower
+                                    + " , status: "
+                                    + status);
+                    if (status == 0) {
+                        mIsAdvertising.postValue(true);
+                    }
+                }
+
+                @Override
+                public void onAdvertisingDataSet(AdvertisingSet advertisingSet, int status) {
+                    printLog("onAdvertisingDataSet() :status:" + status);
+                }
+
+                @Override
+                public void onScanResponseDataSet(AdvertisingSet advertisingSet, int status) {
+                    printLog("onScanResponseDataSet(): status:" + status);
+                }
+
+                @Override
+                public void onAdvertisingSetStopped(AdvertisingSet advertisingSet) {
+                    printLog("onAdvertisingSetStopped():");
+                    mIsAdvertising.postValue(false);
+                }
+            };
+
+    private void startConnectableAdvertising() {
+        if (mIsAdvertising.getValue()) {
+            return;
+        }
+        BluetoothLeAdvertiser advertiser = mBluetoothAdapter.getBluetoothLeAdvertiser();
+        AdvertisingSetParameters parameters =
+                new AdvertisingSetParameters.Builder()
+                        .setLegacyMode(false) // True by default, but set here as a reminder.
+                        .setConnectable(true)
+                        .setInterval(AdvertisingSetParameters.INTERVAL_LOW)
+                        .setTxPowerLevel(AdvertisingSetParameters.TX_POWER_MEDIUM)
+                        .build();
+
+        BluetoothGattServerCallback gattServerCallback =
+                new BluetoothGattServerCallback() {
+                    @Override
+                    public void onConnectionStateChange(
+                            BluetoothDevice device, int status, int newState) {
+                        super.onConnectionStateChange(device, status, newState);
+                        if (newState == BluetoothProfile.STATE_CONNECTED) {
+                            printLog("Device connected: " + device.getName());
+                            if (mTargetBtAddress.equals(device.getAddress())) {
+                                mTargetDevice.postValue(device);
+                            }
+                            mConnectedDevices.add(device);
+                        } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
+                            printLog("Device disconnected: " + device.getName());
+                            if (mTargetBtAddress.equals(device.getAddress())) {
+                                mTargetDevice.postValue(null);
+                            }
+                            mConnectedDevices.remove(device);
+                        }
+                        updateConnectedDevices();
+                    }
+
+                    @Override
+                    public void onServiceAdded(int status, BluetoothGattService service) {
+                        if (status == BluetoothGatt.GATT_SUCCESS) {
+                            printLog("Service added: " + service);
+                        } else {
+                            printLog("Service add failed: " + status);
+                        }
+
+                    }
+
+                    @Override
+                    public void onCharacteristicReadRequest(
+                            BluetoothDevice device, int requestId, int offset,
+                            BluetoothGattCharacteristic characteristic) {
+                        printLog("Characteristics read request: " + characteristic + " from "
+                                + device);
+                        if (characteristic.getUuid().equals(Constants.OOB_PSM_CHARACTERISTICS)) {
+                            printLog("Sending PSM value: " + mPsm);
+                            boolean sendStatus = mBluetoothGattServer.sendResponse(
+                                    device, requestId, BluetoothGatt.GATT_SUCCESS, offset,
+                                    ByteBuffer.allocate(4).putInt(mPsm).array());
+                            if (!sendStatus) printLog("Failed to send characteristics value");
+                        }
+                    }
+                };
+
+        mBluetoothGattServer =
+                mBluetoothManager.openGattServer(
+                        getApplication().getApplicationContext(), gattServerCallback);
+        BluetoothGattService bluetoothGattService =
+                new BluetoothGattService(
+                        Constants.OOB_SERVICE, BluetoothGattService.SERVICE_TYPE_PRIMARY);
+        boolean success = bluetoothGattService.addCharacteristic(
+                new BluetoothGattCharacteristic(
+                        Constants.OOB_PSM_CHARACTERISTICS,
+                        BluetoothGattCharacteristic.PROPERTY_READ
+                                | BluetoothGattCharacteristic.PROPERTY_NOTIFY,
+                        BluetoothGattCharacteristic.PERMISSION_READ));
+        if (!success) printLog("Failed to add PSM characteristc");
+        mBluetoothGattServer.addService(bluetoothGattService);
+        AdvertiseData advertiseData =
+                new AdvertiseData.Builder()
+                        .setIncludeDeviceName(true)
+                        .addServiceUuid(new ParcelUuid(Constants.RANGING_TEST_SERVICE_UUID))
+                        .build();
+
+        printLog("Start connectable advertising");
+
+        advertiser.startAdvertisingSet(
+                parameters, advertiseData, null, null, null, 0, 0, mAdvertisingSetCallback);
+    }
+
+    private void stopAdvertising() {
+        BluetoothLeAdvertiser advertiser = mBluetoothAdapter.getBluetoothLeAdvertiser();
+        advertiser.stopAdvertisingSet(mAdvertisingSetCallback);
+        printLog("stop advertising");
+    }
+
+    private void printLog(@NonNull String logMsg) {
+        mLoggingListener.log(logMsg);
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/CanvasView.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/CanvasView.java
new file mode 100644
index 00000000..89cd77ab
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/CanvasView.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+
+import java.util.ArrayList;
+
+class CanvasView extends View {
+    private static final String LOG_TAG = "CanvasView";
+    private static final int VIEW_HEIGHT = 750;
+    private static final int VIEW_WIDTH = 1000;
+    private static final int START_X = 100;
+    private static final int END_X = VIEW_WIDTH - 50;
+    private static final int START_Y = 80;
+    private static final int END_Y = VIEW_HEIGHT - 100;
+    private static final int MAX_NODE_SIZE = 20;
+    private static final int INITIAL_MAX_Y = 5;
+
+    private final ArrayList<Node> mDataList;
+    private final Paint mPaint;
+    private final Paint mTextPaint;
+    private final Paint mPointPaint;
+    private final String mTitle;
+
+    private int mMaxYValue = INITIAL_MAX_Y;
+    private int mNodeCount = 1;
+    private int mPreviousY = END_Y;
+
+    CanvasView(Context context, String title) {
+        super(context);
+        setLayoutParams(new ViewGroup.LayoutParams(VIEW_WIDTH, VIEW_WIDTH));
+        mDataList = new ArrayList<Node>();
+        mTitle = title;
+        mPaint = new Paint();
+        mTextPaint = new Paint();
+        mPointPaint = new Paint();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        mTextPaint.setTextSize(24);
+
+        mPaint.setColor(Color.WHITE);
+        canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);
+
+        mPaint.setColor(Color.GRAY);
+        mPaint.setStrokeWidth(3);
+        canvas.drawLine(START_X, START_Y, START_X, END_Y, mPaint);
+        canvas.drawLine(START_X, END_Y, END_X, END_Y, mPaint);
+
+        // Draw line
+        mPaint.setStrokeWidth(1);
+        mPaint.setColor(Color.GRAY);
+        int intervalY = (END_Y - START_Y) / 5;
+        for (int i = 1; i <= 5; i++) {
+            int y = END_Y - intervalY * i;
+            int yValue = mMaxYValue / 5 * i;
+            canvas.drawLine(START_X, y, END_X, y, mPaint);
+            canvas.drawText(yValue + "", 40, y, mTextPaint);
+        }
+        canvas.drawText("0", 40, END_Y, mTextPaint);
+
+        // DrawTitle
+        mTextPaint.setTextSize(32);
+        canvas.drawText(mTitle, getWidth() / 2 - mTitle.length() * 6, START_Y - 30, mTextPaint);
+
+        // DrawNode
+        int intervalX = (END_X - START_X) / MAX_NODE_SIZE;
+        int currentX = START_X + intervalX;
+        mPaint.reset();
+        mPaint.setTextSize(16);
+        mTextPaint.setTextSize(24);
+
+        mPointPaint.setColor(Color.BLUE);
+        mPointPaint.setStrokeWidth(3);
+
+        // Draw first node
+        for (int i = 0; i < mDataList.size(); i++) {
+            if (mDataList.get(i).abort) {
+                mPointPaint.setColor(Color.RED);
+                canvas.drawLine(
+                        currentX - intervalX, mPreviousY, currentX, mPreviousY, mPointPaint);
+                canvas.drawCircle(currentX, mPreviousY, 5, mPointPaint);
+                canvas.drawText("abort", currentX - 15, mPreviousY - 10, mPaint);
+            } else {
+                mPointPaint.setColor(Color.BLUE);
+                double distance = mDataList.get(i).value;
+                int y = END_Y - (int) ((END_Y - START_Y) * (distance / mMaxYValue));
+                canvas.drawLine(currentX - intervalX, mPreviousY, currentX, y, mPointPaint);
+                canvas.drawCircle(currentX, y, 5, mPointPaint);
+                canvas.drawText(distance + "", currentX - 15, y - 10, mPaint);
+                mPreviousY = y;
+            }
+
+            // number text
+            String number = mDataList.get(i).number + "";
+            if (mDataList.get(i).number % (MAX_NODE_SIZE / 20 * 5) == 0) {
+                if (number.length() > 2) {
+                    canvas.rotate(-60, currentX - 15, END_Y + 50);
+                    canvas.drawText(number, currentX - 15, END_Y + 50, mTextPaint);
+                    canvas.rotate(60, currentX - 15, END_Y + 50);
+                } else {
+                    canvas.drawText(number, currentX, END_Y + 30, mTextPaint);
+                }
+            }
+            currentX += intervalX;
+        }
+    }
+
+    void cleanUp() {
+        mDataList.clear();
+        mNodeCount = 0;
+        mMaxYValue = INITIAL_MAX_Y;
+        invalidate();
+    }
+
+    void addNode(double distance, boolean abort) {
+        Log.d(LOG_TAG, "Add Node " + mNodeCount + " with distance:" + distance);
+        if (abort && !mDataList.isEmpty()) {
+            distance = mDataList.get(mDataList.size() - 1).value;
+        }
+        mDataList.add(new Node(distance, mNodeCount++, abort));
+        if (distance > mMaxYValue) {
+            mMaxYValue = ((int) (distance / 10)) * 10 + 10;
+        }
+
+        if (mDataList.size() > MAX_NODE_SIZE) {
+            mPreviousY = END_Y - (int) ((END_Y - START_Y) * (mDataList.get(0).value / mMaxYValue));
+            mDataList.remove(0);
+        } else {
+            mPreviousY = END_Y;
+        }
+        invalidate();
+    }
+
+    static class Node {
+        private final double value;
+        private final int number;
+        private final boolean abort;
+
+        Node(double value, int number, boolean abort) {
+            this.value = value;
+            this.number = number;
+            this.abort = abort;
+        }
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ConfigurationFragment.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ConfigurationFragment.java
new file mode 100644
index 00000000..46ffec3c
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ConfigurationFragment.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import static android.view.View.INVISIBLE;
+
+import android.os.Bundle;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingParams;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.ArrayAdapter;
+import android.widget.Button;
+import android.widget.Spinner;
+
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+
+/** The fragment holds the responder configuration of channel sounding. */
+@SuppressWarnings("SetTextI18n")
+public class ConfigurationFragment extends Fragment {
+    private ArrayAdapter<Boolean> mGlobalSensorFusionAdapter;
+    private Spinner mGlobalSensorFusionSpinner;
+    private ArrayAdapter<Integer> mUwbChannelAdapter;
+    private Spinner mUwbChannelSpinner;
+    private ArrayAdapter<Integer> mUwbPreambleAdapter;
+    private Spinner mUwbPreambleSpinner;
+    private ArrayAdapter<Integer> mUwbConfigIdAdapter;
+    private Spinner mUwbConfigIdSpinner;
+    private ArrayAdapter<Integer> mBleCsSecurityLevelAdapter;
+    private Spinner mBleCsSecurityLevelSpinner;
+    private ArrayAdapter<Boolean> mWifiNanRttPeriodicRangingAdapter;
+    private Spinner mWifiNanRttPeriodicRangingSpinner;
+    private ArrayAdapter<Integer> mOobSecurityLevelAdapter;
+    private Spinner mOobSecurityLevelSpinner;
+    private ArrayAdapter<Integer> mOobModeAdapter;
+    private Spinner mOobModeSpinner;
+    private Button mButtonSave;
+    private Button mButtonReset;
+    private AtomicReference<ConfigurationParameters> mConfigurationParameters = new AtomicReference<>(null);
+    private boolean mIsResponder;
+
+    public void setIsResponder(boolean isResponder) {
+        mIsResponder = isResponder;
+    }
+
+    @Override
+    public View onCreateView(
+            @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View root = inflater.inflate(R.layout.fragment_configuration, container, false);
+        if (mIsResponder) {
+            View oobView = root.findViewById(R.id.layout_oob);
+            oobView.setVisibility(INVISIBLE);
+        }
+        mGlobalSensorFusionSpinner = (Spinner) root.findViewById(R.id.global_sensor_fusion_spinner);
+        mUwbChannelSpinner = (Spinner) root.findViewById(R.id.uwb_channel_spinner);
+        mUwbPreambleSpinner = (Spinner) root.findViewById(R.id.uwb_preamble_spinner);
+        mUwbConfigIdSpinner = (Spinner) root.findViewById(R.id.uwb_config_spinner);
+        mBleCsSecurityLevelSpinner = (Spinner) root.findViewById(R.id.ble_cs_security_spinner);
+        mWifiNanRttPeriodicRangingSpinner =
+                (Spinner) root.findViewById(R.id.wifi_nan_rtt_periodic_ranging_spinner);
+        mOobSecurityLevelSpinner = (Spinner) root.findViewById(R.id.oob_security_level_spinner);
+        mOobModeSpinner = (Spinner) root.findViewById(R.id.oob_mode_spinner);
+        mButtonSave = (Button) root.findViewById(R.id.btn_save);
+        mButtonReset = (Button) root.findViewById(R.id.btn_reset);
+        return root;
+    }
+
+    void populateEditFields() {
+        mGlobalSensorFusionSpinner.setSelection(mGlobalSensorFusionAdapter.getPosition(
+                mConfigurationParameters.get().global.sensorFusionEnabled));
+        mUwbChannelSpinner.setSelection(mUwbChannelAdapter.getPosition(
+                mConfigurationParameters.get().uwb.channel));
+        mUwbPreambleSpinner.setSelection(mUwbPreambleAdapter.getPosition(
+                mConfigurationParameters.get().uwb.preamble));
+        mUwbConfigIdSpinner.setSelection(mUwbConfigIdAdapter.getPosition(
+                mConfigurationParameters.get().uwb.configId));
+        mBleCsSecurityLevelSpinner.setSelection(mBleCsSecurityLevelAdapter.getPosition(
+                mConfigurationParameters.get().bleCs.securityLevel));
+        mWifiNanRttPeriodicRangingSpinner.setSelection(mWifiNanRttPeriodicRangingAdapter.getPosition(
+                mConfigurationParameters.get().wifiNanRtt.isPeriodicRangingEnabled));
+        mOobSecurityLevelSpinner.setSelection(mOobSecurityLevelAdapter.getPosition(
+                mConfigurationParameters.get().oob.securityLevel));
+        mOobModeSpinner.setSelection(mOobModeAdapter.getPosition(
+                mConfigurationParameters.get().oob.mode));
+    }
+
+    @Override
+    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        mGlobalSensorFusionAdapter =
+                new ArrayAdapter<>(
+                        getContext(), android.R.layout.simple_spinner_item, List.of(true, false));
+        mGlobalSensorFusionAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mGlobalSensorFusionSpinner.setAdapter(mGlobalSensorFusionAdapter);
+        mUwbChannelAdapter =
+                new ArrayAdapter<>(
+                        getContext(), android.R.layout.simple_spinner_item, List.of(
+                            UwbComplexChannel.UWB_CHANNEL_5,
+                            UwbComplexChannel.UWB_CHANNEL_9
+                ));
+        mUwbChannelAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mUwbChannelSpinner.setAdapter(mUwbChannelAdapter);
+        mUwbPreambleAdapter =
+                new ArrayAdapter<>(
+                        getContext(), android.R.layout.simple_spinner_item, List.of(
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_9,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_10,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_11,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_12,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_25,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_26,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_27,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_28,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_29,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_30,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_31,
+                        UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_32
+                ));
+        mUwbPreambleAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mUwbPreambleSpinner.setAdapter(mUwbPreambleAdapter);
+        mUwbConfigIdAdapter =
+                new ArrayAdapter<>(
+                        getContext(), android.R.layout.simple_spinner_item, List.of(
+                        UwbRangingParams.CONFIG_UNICAST_DS_TWR,
+                        UwbRangingParams.CONFIG_MULTICAST_DS_TWR,
+                        UwbRangingParams.CONFIG_PROVISIONED_UNICAST_DS_TWR,
+                        UwbRangingParams.CONFIG_PROVISIONED_MULTICAST_DS_TWR,
+                        UwbRangingParams.CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR,
+                        UwbRangingParams.CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST
+                ));
+        mUwbConfigIdAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mUwbConfigIdSpinner.setAdapter(mUwbConfigIdAdapter);
+        mBleCsSecurityLevelAdapter =
+                new ArrayAdapter<>(
+                        getContext(), android.R.layout.simple_spinner_item, List.of(
+                        BleCsRangingCapabilities.CS_SECURITY_LEVEL_ONE,
+                        BleCsRangingCapabilities.CS_SECURITY_LEVEL_FOUR
+                ));
+        mBleCsSecurityLevelAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mBleCsSecurityLevelSpinner.setAdapter(mBleCsSecurityLevelAdapter);
+        mWifiNanRttPeriodicRangingAdapter =
+                new ArrayAdapter<>(
+                        getContext(), android.R.layout.simple_spinner_item, List.of(true, false));
+        mWifiNanRttPeriodicRangingAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mWifiNanRttPeriodicRangingSpinner.setAdapter(mWifiNanRttPeriodicRangingAdapter);
+        mOobSecurityLevelAdapter =
+                new ArrayAdapter<>(
+                        getContext(), android.R.layout.simple_spinner_item, List.of(
+                        OobInitiatorRangingConfig.SECURITY_LEVEL_BASIC,
+                        OobInitiatorRangingConfig.SECURITY_LEVEL_SECURE
+                ));
+        mOobSecurityLevelAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mOobSecurityLevelSpinner.setAdapter(mOobSecurityLevelAdapter);
+        mOobModeAdapter =
+                new ArrayAdapter<>(
+                        getContext(), android.R.layout.simple_spinner_item, List.of(
+                        OobInitiatorRangingConfig.RANGING_MODE_AUTO,
+                        OobInitiatorRangingConfig.RANGING_MODE_HIGH_ACCURACY,
+                        OobInitiatorRangingConfig.RANGING_MODE_HIGH_ACCURACY_PREFERRED,
+                        OobInitiatorRangingConfig.RANGING_MODE_FUSED
+                ));
+        mOobModeAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mOobModeSpinner.setAdapter(mOobModeAdapter);
+
+        mConfigurationParameters.set(
+            ConfigurationParameters.restoreInstance(getContext(), mIsResponder));
+        populateEditFields();
+
+        mGlobalSensorFusionSpinner.setOnItemSelectedListener(
+                new AdapterView.OnItemSelectedListener() {
+                    @Override
+                    public void onItemSelected(AdapterView<?> adapterView, View view, int position, long l) {
+                        mConfigurationParameters.get().global.sensorFusionEnabled =
+                                (boolean) mGlobalSensorFusionSpinner.getItemAtPosition(position);
+                    }
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+                    }
+                });
+        mUwbChannelSpinner.setOnItemSelectedListener(
+                new AdapterView.OnItemSelectedListener() {
+                    @Override
+                    public void onItemSelected(AdapterView<?> adapterView, View view, int position, long l) {
+                        mConfigurationParameters.get().uwb.channel =
+                                (int) mUwbChannelSpinner.getItemAtPosition(position);
+                    }
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+                    }
+                });
+        mUwbPreambleSpinner.setOnItemSelectedListener(
+                new AdapterView.OnItemSelectedListener() {
+                    @Override
+                    public void onItemSelected(AdapterView<?> adapterView, View view, int position, long l) {
+                        mConfigurationParameters.get().uwb.preamble =
+                                (int) mUwbPreambleSpinner.getItemAtPosition(position);
+                    }
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+                    }
+                });
+        mUwbConfigIdSpinner.setOnItemSelectedListener(
+                new AdapterView.OnItemSelectedListener() {
+                    @Override
+                    public void onItemSelected(AdapterView<?> adapterView, View view, int position, long l) {
+                        mConfigurationParameters.get().uwb.configId =
+                                (int) mUwbConfigIdSpinner.getItemAtPosition(position);
+                    }
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+                    }
+                });
+        mBleCsSecurityLevelSpinner.setOnItemSelectedListener(
+                new AdapterView.OnItemSelectedListener() {
+                    @Override
+                    public void onItemSelected(AdapterView<?> adapterView, View view, int position, long l) {
+                        mConfigurationParameters.get().bleCs.securityLevel =
+                                (int) mBleCsSecurityLevelSpinner.getItemAtPosition(position);
+                    }
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+                    }
+                });
+        mWifiNanRttPeriodicRangingSpinner.setOnItemSelectedListener(
+                new AdapterView.OnItemSelectedListener() {
+                    @Override
+                    public void onItemSelected(AdapterView<?> adapterView, View view, int position, long l) {
+                        mConfigurationParameters.get().wifiNanRtt.isPeriodicRangingEnabled =
+                                (boolean) mWifiNanRttPeriodicRangingSpinner.getItemAtPosition(position);
+                    }
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+                    }
+                });
+        mOobModeSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+            @Override
+            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+                mConfigurationParameters.get().oob.mode = (int) mOobModeSpinner.getItemAtPosition(
+                        position);
+            }
+
+            @Override
+            public void onNothingSelected(AdapterView<?> parent) {
+            }
+        });
+        mButtonSave.setOnClickListener(
+                v -> {
+                    mConfigurationParameters.get().saveInstance(getContext());
+                });
+        mButtonReset.setOnClickListener(
+                v -> {
+                    mConfigurationParameters.set(
+                        ConfigurationParameters.resetInstance(getContext(), mIsResponder));
+                    populateEditFields();
+                });
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ConfigurationParameters.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ConfigurationParameters.java
new file mode 100644
index 00000000..5729a45b
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ConfigurationParameters.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import static android.ranging.uwb.UwbComplexChannel.UWB_CHANNEL_9;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_11;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbRangingParams;
+
+/** Utility class to hold ranging params shared across peer devices */
+public class ConfigurationParameters {
+    private static String PREF_CONFIG = "PrefConfig";
+
+    public Global global;
+    public Uwb uwb;
+    public BleCs bleCs;
+    public BleRssi bleRssi;
+    public WifiNanRtt wifiNanRtt;
+    public Oob oob;
+
+    private ConfigurationParameters(Global global, Uwb uwb, BleCs bleCs, BleRssi bleRssi,
+            WifiNanRtt wifiNanRtt, Oob oob) {
+        this.global = global;
+        this.uwb = uwb;
+        this.bleCs = bleCs;
+        this.bleRssi = bleRssi;
+        this.wifiNanRtt = wifiNanRtt;
+        this.oob = oob;
+    }
+
+    private ConfigurationParameters(boolean isResponder) {
+        global = new Global();
+        uwb = new Uwb(isResponder);
+        bleCs = new BleCs();
+        bleRssi = new BleRssi();
+        wifiNanRtt = new WifiNanRtt();
+        oob = new Oob();
+    }
+
+    public void saveInstance(Context context) {
+        SharedPreferences pref = context.getSharedPreferences(PREF_CONFIG, Context.MODE_PRIVATE);
+        SharedPreferences.Editor prefEditor = pref.edit();
+        global.toPref(prefEditor);
+        uwb.toPref(prefEditor);
+        bleCs.toPref(prefEditor);
+        bleRssi.toPref(prefEditor);
+        wifiNanRtt.toPref(prefEditor);
+        oob.toPref(prefEditor);
+        prefEditor.apply();
+    }
+
+    public static ConfigurationParameters resetInstance(Context context, boolean isResponder) {
+        SharedPreferences pref = context.getSharedPreferences(PREF_CONFIG, Context.MODE_PRIVATE);
+        SharedPreferences.Editor prefEditor = pref.edit();
+        prefEditor.clear();
+        prefEditor.apply();
+        return new ConfigurationParameters(isResponder);
+    }
+
+    public static ConfigurationParameters restoreInstance(Context context, boolean isResponder) {
+        SharedPreferences pref = context.getSharedPreferences(PREF_CONFIG, Context.MODE_PRIVATE);
+        return new ConfigurationParameters(
+                Global.fromPref(pref, isResponder),
+                Uwb.fromPref(pref, isResponder),
+                BleCs.fromPref(pref, isResponder),
+                BleRssi.fromPref(pref, isResponder),
+                WifiNanRtt.fromPref(pref, isResponder),
+                Oob.fromPref(pref, isResponder));
+    }
+
+    public static class BaseTechConfig {
+        public RangingParameters.Technology technology;
+
+        public BaseTechConfig(RangingParameters.Technology technology) {
+            this.technology = technology;
+        }
+    }
+
+    public static class Global extends BaseTechConfig {
+        public boolean sensorFusionEnabled = true;
+
+        public Global() {
+            super(RangingParameters.Technology.OOB);
+        }
+
+        public void toPref(SharedPreferences.Editor prefEditor) {
+            prefEditor.putBoolean("sensorFusionEnabled", sensorFusionEnabled);
+        }
+
+        public static Global fromPref(SharedPreferences pref, boolean isResponder) {
+            Global global = new Global();
+            global.sensorFusionEnabled = pref.getBoolean("sensorFusionEnabled",
+                    global.sensorFusionEnabled);
+            return global;
+        }
+
+    }
+
+    public static class Uwb extends BaseTechConfig {
+        private static final UwbAddress[] UWB_ADDRESSES = new UwbAddress[] {
+                UwbAddress.fromBytes(new byte[]{0x5, 0x6}),
+                UwbAddress.fromBytes(new byte[]{0x6, 0x5})
+        };
+        public boolean isResponder;
+        public int channel = UWB_CHANNEL_9;
+        public int preamble = UWB_PREAMBLE_CODE_INDEX_11;
+        public int configId = UwbRangingParams.CONFIG_PROVISIONED_MULTICAST_DS_TWR;
+        public int sessionId = 5;
+        public UwbAddress deviceAddress;
+        public UwbAddress peerDeviceAddress;
+        public byte[] sessionKey = new byte[] {
+                0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8,
+                0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1
+        };
+
+        public Uwb(boolean isResponder, UwbAddress deviceAddress, UwbAddress peerDeviceAddress) {
+            super(RangingParameters.Technology.UWB);
+            this.isResponder = isResponder;
+            this.deviceAddress = deviceAddress;
+            this.peerDeviceAddress = peerDeviceAddress;
+        }
+
+        public Uwb(boolean isResponder) {
+            this(
+                    isResponder,
+                    isResponder ? UWB_ADDRESSES[0] : UWB_ADDRESSES[1],
+                    isResponder ? UWB_ADDRESSES[1] : UWB_ADDRESSES[0]
+            );
+        }
+
+        public void toPref(SharedPreferences.Editor prefEditor) {
+            prefEditor.putBoolean("isResponder", isResponder);
+            prefEditor.putInt("channel", channel);
+            prefEditor.putInt("preamble", preamble);
+            prefEditor.putInt("configId", configId);
+            prefEditor.putInt("sessionId", sessionId);
+            prefEditor.putString("deviceAddress", new String(deviceAddress.getAddressBytes()));
+            prefEditor.putString("peerDeviceAddress", new String(peerDeviceAddress.getAddressBytes()));
+        }
+
+        public static Uwb fromPref(SharedPreferences pref, boolean isResponder) {
+            Boolean isPrefResponder = null;
+            if (pref.contains("isResponder")) {
+                isPrefResponder = pref.getBoolean("isResponder", false);
+            }
+            Uwb uwb = null;
+            if (isPrefResponder == null || isPrefResponder != isResponder) {
+                uwb = new Uwb(isResponder);
+            } else {
+                uwb = new Uwb(
+                        isResponder,
+                        UwbAddress.fromBytes(pref.getString(
+                                "deviceAddress",
+                                new String(UWB_ADDRESSES[0].getAddressBytes())).getBytes()),
+                        UwbAddress.fromBytes(pref.getString(
+                                "peerDeviceAddress",
+                                new String(UWB_ADDRESSES[1].getAddressBytes())).getBytes()));
+
+            }
+            uwb.channel = pref.getInt("channel", uwb.channel);
+            uwb.preamble = pref.getInt("preamble", uwb.preamble);
+            uwb.configId = pref.getInt("configId", uwb.configId);
+            uwb.sessionId = pref.getInt("sessionId", uwb.sessionId);
+            return uwb;
+        }
+    }
+
+    public static class BleCs extends BaseTechConfig {
+        public int securityLevel = BleCsRangingCapabilities.CS_SECURITY_LEVEL_ONE;
+
+        public BleCs() {
+            super(RangingParameters.Technology.BLE_CS);
+        }
+
+        public void toPref(SharedPreferences.Editor prefEditor) {
+            prefEditor.putInt("securityLevel", securityLevel);
+        }
+
+        public static BleCs fromPref(SharedPreferences pref, boolean isResponder) {
+            BleCs bleCs = new BleCs();
+            bleCs.securityLevel = pref.getInt("securityLevel", bleCs.securityLevel);
+            return bleCs;
+        }
+    }
+
+    public static class BleRssi extends BaseTechConfig {
+        public BleRssi() {
+            super(RangingParameters.Technology.BLE_CS);
+        }
+
+        public void toPref(SharedPreferences.Editor prefEditor) {
+        }
+
+        public static BleRssi fromPref(SharedPreferences pref, boolean isResponder) {
+            return new BleRssi();
+        }
+    }
+
+    public static class WifiNanRtt extends BaseTechConfig {
+        public String serviceName = "ranging_service";
+        public boolean isPeriodicRangingEnabled = false;
+        public WifiNanRtt() {
+            super(RangingParameters.Technology.WIFI_NAN_RTT);
+        }
+
+        public void toPref(SharedPreferences.Editor prefEditor) {
+            prefEditor.putString("serviceName", serviceName);
+            prefEditor.putBoolean("isPeriodicRangingEnabled", isPeriodicRangingEnabled);
+        }
+
+        public static WifiNanRtt fromPref(SharedPreferences pref, boolean isResponder) {
+            WifiNanRtt wifiNanRtt = new WifiNanRtt();
+            wifiNanRtt.serviceName = pref.getString("serviceName", wifiNanRtt.serviceName);
+            wifiNanRtt.isPeriodicRangingEnabled = pref.getBoolean("isPeriodicRangingEnabled",
+                    wifiNanRtt.isPeriodicRangingEnabled);
+            return wifiNanRtt;
+        }
+    }
+
+    public static class Oob extends BaseTechConfig {
+        public int securityLevel = OobInitiatorRangingConfig.SECURITY_LEVEL_BASIC;
+        public int mode = OobInitiatorRangingConfig.RANGING_MODE_AUTO;
+
+        public Oob() {
+            super(RangingParameters.Technology.OOB);
+        }
+
+        public void toPref(SharedPreferences.Editor prefEditor) {
+            prefEditor.putInt("securitylevel", securityLevel);
+            prefEditor.putInt("mode", mode);
+        }
+
+        public static Oob fromPref(SharedPreferences pref, boolean isResponder) {
+            Oob oob = new Oob();
+            oob.securityLevel = pref.getInt("securityLevel", oob.securityLevel);
+            oob.mode = pref.getInt("mode", oob.mode);
+            return oob;
+        }
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/Constants.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/Constants.java
new file mode 100644
index 00000000..72a54945
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/Constants.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import java.util.UUID;
+
+abstract class Constants {
+    static final UUID RANGING_TEST_SERVICE_UUID =
+            UUID.fromString("f81d4fae-7ccc-eeee-a765-00aaaaaaaaaa");
+
+    enum GattState {
+        DISCONNECTED,
+        SCANNING,
+        CONNECTED,
+    }
+
+    static final UUID OOB_SERVICE =
+            UUID.fromString("f81d4fae-7ccc-eeee-a765-aaaaaaaaaaaa");
+    static final UUID OOB_PSM_CHARACTERISTICS =
+            UUID.fromString("f81d4fae-7ccc-eeee-a765-0aaaaaaaaaaa");
+
+    enum RangeSessionState {
+        STARTING,
+        STARTED,
+        STOPPING,
+        STOPPED
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/DistanceMeasurementManager.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/DistanceMeasurementManager.java
new file mode 100644
index 00000000..8abf9172
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/DistanceMeasurementManager.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.content.DialogInterface;
+import android.os.CancellationSignal;
+import android.ranging.RangingCapabilities;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.RangingManager;
+import android.ranging.RangingPreference;
+import android.ranging.RangingSession;
+
+import androidx.annotation.Nullable;
+import androidx.appcompat.app.AlertDialog;
+
+import com.android.ranging.rangingtestapp.RangingParameters.Technology;
+import com.google.android.material.dialog.MaterialAlertDialogBuilder;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+class DistanceMeasurementManager {
+    private final RangingManager mRangingManager;
+    private final LoggingListener mLoggingListener;
+
+    private final Activity mActivity;
+    private final BleConnection mBleConnection;
+    private final Executor mExecutor;
+    private final Callback mCallback;
+    private final boolean mIsResponder;
+    @Nullable private RangingSession mSession = null;
+    private AtomicReference<CancellationSignal> mCancellationSignal =
+            new AtomicReference<>(null);
+    private CountDownLatch mCapabilitiesCountDownLatch = new CountDownLatch(1);
+    @Nullable private AtomicReference<RangingCapabilities> mRangingCapabilities =
+            new AtomicReference<>();
+    @Nullable private BluetoothDevice mTargetDevice = null;
+    private AlertDialog mAlertDialog = null;
+
+    DistanceMeasurementManager(
+            Activity activity,
+            BleConnection bleConnection,
+            Callback distanceMeasurementCallback,
+            com.android.ranging.rangingtestapp.LoggingListener loggingListener,
+            boolean isResponder) {
+        mActivity = activity;
+        mBleConnection = bleConnection;
+        mCallback = distanceMeasurementCallback;
+        mLoggingListener = loggingListener;
+        mIsResponder = isResponder;
+
+        mRangingManager = mActivity.getApplication().getSystemService(RangingManager.class);
+        mExecutor = Executors.newSingleThreadExecutor();
+
+        mRangingManager.registerCapabilitiesCallback(mExecutor, (capabilities -> {
+            mRangingCapabilities.set(capabilities);
+            mCapabilitiesCountDownLatch.countDown();
+        }));
+    }
+
+    void setTargetDevice(BluetoothDevice targetDevice) {
+        mTargetDevice = targetDevice;
+        if (mTargetDevice == null) {
+            stop();
+        }
+    }
+
+    private void printLog(String log) {
+        mLoggingListener.log(log);
+    }
+
+    private String getRangingTechnologyName(int technology) {
+        for (Technology tech: Technology.values()) {
+            if (tech.getTechnology() == technology) {
+                return tech.toString();
+            }
+        }
+        throw new IllegalArgumentException("unknown technology " + technology);
+    }
+
+    @SuppressLint("MissingPermission") // permissions are checked upfront
+    List<String> getSupportedTechnologies() {
+        List<String> techs = new ArrayList<>();
+        try {
+            mCapabilitiesCountDownLatch.await(2, TimeUnit.SECONDS);
+        } catch (InterruptedException e) { }
+        if (mRangingCapabilities.get() == null) return techs;
+        Map<Integer, Integer> technologyAvailability =
+                mRangingCapabilities.get().getTechnologyAvailability();
+
+        StringBuilder dbgMessage = new StringBuilder("getRangingTechnologies: ");
+        for (Map.Entry<Integer, Integer> techAvailability : technologyAvailability.entrySet()) {
+            if (techAvailability.getValue().equals(RangingCapabilities.ENABLED)) {
+                String techName = getRangingTechnologyName(techAvailability.getKey());
+                dbgMessage.append(techName).append(", ");
+                techs.add(techName);
+            }
+        }
+        // Always add OOB
+        String techName = Technology.OOB.toString();
+        dbgMessage.append(techName).append(", ");
+        techs.add(techName);
+        printLog(dbgMessage.toString());
+        return techs;
+    }
+
+    List<String> getMeasurementFreqs() {
+        return List.of(RangingParameters.Freq.MEDIUM.toString(),
+                RangingParameters.Freq.HIGH.toString(),
+                RangingParameters.Freq.LOW.toString());
+    }
+
+    List<String> getMeasureDurationsInIntervalRounds() {
+        return List.of("10000", "1000", "100", "10", "5");
+    }
+
+    private void showBondAlertDialog() {
+        DialogInterface.OnDismissListener onDismissListener = (d) -> {
+            mAlertDialog.dismiss();
+        };
+        DialogInterface.OnClickListener onClickListener = (d, b) -> {
+            switch (b) {
+                case DialogInterface.BUTTON_POSITIVE:
+                    printLog("Initiating bond with " + mTargetDevice.getName());
+                    if (!mTargetDevice.createBond()) {
+                        printLog("Failed to initiate bond with " + mTargetDevice.getName());
+                    }
+                    break;
+                default:
+                    break;
+            }
+            mAlertDialog.dismiss();
+        };
+        mAlertDialog = new MaterialAlertDialogBuilder(mActivity, R.style.MaterialAlertDialog_rounded)
+                .setTitle(R.string.bond_title)
+                .setMessage(R.string.bond_message)
+                .setCancelable(false)
+                .setOnDismissListener(onDismissListener)
+                .setNegativeButton(R.string.bond_ignore, onClickListener)
+                .setPositiveButton(R.string.bond_create, onClickListener)
+                .create();
+        mAlertDialog.show();
+    }
+
+    @SuppressLint("MissingPermission") // permissions are checked upfront
+    boolean start(
+            String rangingTechnologyName, String freqName, int duration) {
+        if (mTargetDevice == null) {
+            printLog("Please connect the device over Gatt first");
+            return false;
+        }
+        if (Technology.fromName(rangingTechnologyName).equals(Technology.BLE_CS)
+             || Technology.fromName(rangingTechnologyName).equals(Technology.OOB)) {
+            if (mTargetDevice.getBondState() != BluetoothDevice.BOND_BONDED) {
+                printLog("Please bond the devices for channel sounding");
+                printLog("Bonded Devices: " + mActivity.getApplication()
+                        .getSystemService(BluetoothManager.class)
+                        .getAdapter()
+                        .getBondedDevices());
+                showBondAlertDialog();
+                return false;
+            }
+        }
+        printLog("Start ranging with device: " + mTargetDevice.getName());
+        mSession = mRangingManager.createRangingSession(
+                Executors.newSingleThreadExecutor(), mRangingSessionCallback);
+        // Don't block here to avoid making the UX unresponsive (especially for OOB handshaking)
+        mExecutor.execute(() -> {
+            RangingPreference rangingPreference = null;
+            if (mIsResponder) {
+                rangingPreference =
+                        RangingParameters.createResponderRangingPreference(
+                                mActivity.getApplication(), mBleConnection, mLoggingListener,
+                                rangingTechnologyName, freqName,
+                                ConfigurationParameters.restoreInstance(
+                                        mActivity.getApplication(), mIsResponder),
+                                duration, mTargetDevice);
+            } else {
+                rangingPreference =
+                        RangingParameters.createInitiatorRangingPreference(
+                                mActivity.getApplication(), mBleConnection, mLoggingListener,
+                                rangingTechnologyName, freqName,
+                                ConfigurationParameters.restoreInstance(
+                                        mActivity.getApplication(), mIsResponder),
+                                duration, mTargetDevice);
+            }
+            if (rangingPreference == null) {
+                printLog("Failed to start ranging session");
+                mCallback.onStartFail();
+                return;
+            }
+            mCancellationSignal.set(mSession.start(rangingPreference));
+        });
+        return true;
+    }
+
+    void stop() {
+        if (mCancellationSignal.get() != null) {
+            printLog("Stop ranging with device: " + mTargetDevice.getName());
+            mCancellationSignal.get().cancel();
+            mCancellationSignal.set(null);
+        }
+        if (mAlertDialog != null) {
+            mAlertDialog.dismiss();
+        }
+        mSession = null;
+    }
+
+    private RangingSession.Callback mRangingSessionCallback =
+            new RangingSession.Callback() {
+
+                public void onOpened() {
+                    printLog("DistanceMeasurementManager onOpened! ");
+                }
+
+                public void onOpenFailed(int reason) {
+                    printLog("DistanceMeasurementManager onOpenFailed! " + reason);
+                    mCallback.onStartFail();
+                }
+
+                public void onStarted(RangingDevice peer, int technology) {
+                    printLog("DistanceMeasurementManager onStarted ! ");
+                    mCallback.onStartSuccess();
+                }
+
+                public void onStopped(RangingDevice peer, int technology) {
+                    printLog("DistanceMeasurementManager onStopped! " + technology);
+                    mCallback.onStop();
+                }
+
+                public void onClosed(int reason) {
+                    printLog("DistanceMeasurementManager onClosed! " + reason);
+                    mCallback.onStop();
+                }
+
+                public void onResults(RangingDevice peer, RangingData data) {
+                    printLog(
+                            "DistanceMeasurementManager onResults ! " + peer + ": " + data);
+                    mCallback.onDistanceResult(
+                            data.getDistance().getMeasurement());
+                }
+            };
+
+    interface Callback {
+
+        void onStartSuccess();
+
+        void onStartFail();
+
+        void onStop();
+
+        void onDistanceResult(double distanceMeters);
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/DistanceMeasurementViewModel.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/DistanceMeasurementViewModel.java
new file mode 100644
index 00000000..9a4506c3
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/DistanceMeasurementViewModel.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.app.Activity;
+import android.bluetooth.BluetoothDevice;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.lifecycle.AndroidViewModel;
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
+import androidx.lifecycle.ViewModel;
+import androidx.lifecycle.ViewModelProvider;
+
+import java.util.List;
+
+/** ViewModel for the Initiator/Responder. */
+public class DistanceMeasurementViewModel extends AndroidViewModel {
+
+    private final MutableLiveData<Constants.RangeSessionState> mSessionState =
+            new MutableLiveData<>(Constants.RangeSessionState.STOPPED);
+
+    private final MutableLiveData<Double> mDistanceResult = new MutableLiveData<>();
+
+    private final DistanceMeasurementManager
+            mDistanceMeasurementManager; // mDistanceMeasurementManager;
+
+    public static class Factory implements ViewModelProvider.Factory {
+        private Activity mActivity;
+        private BleConnection mBleConnection;
+        private LoggingListener mLoggingListener;
+        private boolean mIsResponder;
+
+        public Factory(Activity activity,
+                       BleConnection bleConnection,
+                       LoggingListener loggingListener,
+                       boolean isResponder) {
+            mActivity = activity;
+            mBleConnection = bleConnection;
+            mLoggingListener = loggingListener;
+            mIsResponder = isResponder;
+        }
+
+
+        @Override
+        public <T extends ViewModel> T create(Class<T> modelClass) {
+            return (T) new DistanceMeasurementViewModel(
+                    mActivity, mBleConnection, mLoggingListener, mIsResponder);
+        }
+    }
+
+    public DistanceMeasurementViewModel(@NonNull Activity activity,
+                                        BleConnection bleConnection,
+                                        LoggingListener loggingListener,
+                                        boolean isResponder) {
+        super(activity.getApplication());
+        mDistanceMeasurementManager =
+                new DistanceMeasurementManager(
+                        activity,
+                        bleConnection,
+                        mCallback,
+                        loggingListener,
+                        isResponder);
+    }
+
+    void setTargetDevice(BluetoothDevice targetDevice) {
+        mDistanceMeasurementManager.setTargetDevice(targetDevice);
+    }
+
+    LiveData<Constants.RangeSessionState> getSessionState() {
+        return mSessionState;
+    }
+
+    LiveData<Double> getDistanceResult() {
+        return mDistanceResult;
+    }
+
+    List<String> getSupportedTechnologies() {
+        return mDistanceMeasurementManager.getSupportedTechnologies();
+    }
+
+    List<String> getMeasurementFreqs() {
+        return mDistanceMeasurementManager.getMeasurementFreqs();
+    }
+
+    List<String> getMeasurementDurations() {
+        return mDistanceMeasurementManager.getMeasureDurationsInIntervalRounds();
+    }
+
+    void toggleStartStop(String technology, String freq, int duration) {
+        if (mSessionState.getValue() == Constants.RangeSessionState.STOPPED) {
+            boolean success =
+                    mDistanceMeasurementManager.start(
+                            technology, freq, duration);
+            if (success) {
+                mSessionState.postValue(Constants.RangeSessionState.STARTING);
+            } else {
+                mSessionState.postValue(Constants.RangeSessionState.STOPPED);
+            }
+        } else {
+            mDistanceMeasurementManager.stop();
+            mSessionState.postValue(Constants.RangeSessionState.STOPPING);
+        }
+    }
+
+    private DistanceMeasurementManager.Callback mCallback =
+            new DistanceMeasurementManager.Callback() {
+                @Override
+                public void onStartSuccess() {
+                    mSessionState.postValue(Constants.RangeSessionState.STARTED);
+                }
+
+                @Override
+                public void onStartFail() {
+                    mSessionState.postValue(Constants.RangeSessionState.STOPPED);
+                }
+
+                @Override
+                public void onStop() {
+                    mSessionState.postValue(Constants.RangeSessionState.STOPPED);
+                }
+
+                @Override
+                public void onDistanceResult(double distanceMeters) {
+                    mDistanceResult.postValue(distanceMeters);
+                }
+            };
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/InitiatorConfigurationFragment.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/InitiatorConfigurationFragment.java
new file mode 100644
index 00000000..85f0a2e8
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/InitiatorConfigurationFragment.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import androidx.annotation.NonNull;
+
+/** The fragment holds the initiator configuration of channel sounding. */
+@SuppressWarnings("SetTextI18n")
+public class InitiatorConfigurationFragment extends ConfigurationFragment {
+    @Override
+    public View onCreateView(
+            @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        setIsResponder(false);
+        return super.onCreateView(inflater, container, savedInstanceState);
+    }
+}
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/InitiatorFragment.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/InitiatorFragment.java
new file mode 100644
index 00000000..b7276c8f
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/InitiatorFragment.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.Button;
+import android.widget.LinearLayout;
+import android.widget.Spinner;
+import android.widget.TextView;
+
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentTransaction;
+import androidx.lifecycle.ViewModelProvider;
+
+import java.text.DecimalFormat;
+import java.util.ArrayList;
+
+/** The fragment holds the initiator of channel sounding. */
+@SuppressWarnings("SetTextI18n")
+public class InitiatorFragment extends Fragment {
+
+    private static final DecimalFormat DISTANCE_DECIMAL_FMT = new DecimalFormat("0.00");
+
+    private ArrayAdapter<String> mTechnologyArrayAdapter;
+    private ArrayAdapter<String> mFreqArrayAdapter;
+    private ArrayAdapter<String> mDurationArrayAdapter;
+    private TextView mDistanceText;
+    private CanvasView mDistanceCanvasView;
+    private Spinner mSpinnerTechnology;
+    private Spinner mSpinnerFreq;
+    private Spinner mSpinnerDuration;
+    private Button mButton;
+    private LinearLayout mDistanceViewLayout;
+    private TextView mLogText;
+
+    private BleConnectionCentralViewModel mBleConnectionViewModel;
+    private DistanceMeasurementViewModel mDistanceMeasurementViewModel;
+    private LoggingListener mLoggingListener;
+
+    @Override
+    public View onCreateView(
+            @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View root = inflater.inflate(R.layout.fragment_initiator, container, false);
+        Fragment bleConnectionFragment = new BleConnectionCentralFragment();
+        FragmentTransaction transaction = getChildFragmentManager().beginTransaction();
+        transaction.replace(R.id.init_ble_connection_container, bleConnectionFragment).commit();
+
+        mButton = (Button) root.findViewById(R.id.btn_measure);
+        mSpinnerTechnology = (Spinner) root.findViewById(R.id.spinner_dm_tech);
+        mSpinnerFreq = (Spinner) root.findViewById(R.id.spinner_freq);
+        mSpinnerDuration = (Spinner) root.findViewById(R.id.spinner_duration);
+        mDistanceViewLayout = (LinearLayout) root.findViewById(R.id.layout_distance_view);
+        mDistanceText = new TextView(getContext());
+        mDistanceViewLayout.addView(mDistanceText);
+        mDistanceText.setText("0.00 m");
+        mDistanceText.setTextSize(96);
+        mDistanceText.setGravity(Gravity.END);
+        mDistanceCanvasView = new CanvasView(getContext(), "Distance");
+        mDistanceViewLayout.addView(mDistanceCanvasView);
+        mDistanceViewLayout.setPadding(0, 0, 0, 600);
+        mLoggingListener = new LoggingListener(getActivity().getApplicationContext(), false);
+        mLogText = (TextView) root.findViewById(R.id.text_log);
+        return root;
+    }
+
+    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+
+        mTechnologyArrayAdapter =
+                new ArrayAdapter<String>(
+                        getContext(), android.R.layout.simple_spinner_item, new ArrayList<>());
+        mTechnologyArrayAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mSpinnerTechnology.setAdapter(mTechnologyArrayAdapter);
+        mFreqArrayAdapter =
+                new ArrayAdapter<String>(
+                        getContext(), android.R.layout.simple_spinner_item, new ArrayList<>());
+        mFreqArrayAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+        mSpinnerFreq.setAdapter(mFreqArrayAdapter);
+        mDurationArrayAdapter =
+                new ArrayAdapter<String>(
+                        getContext(), android.R.layout.simple_spinner_item, new ArrayList<>());
+        mDurationArrayAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mSpinnerDuration.setAdapter(mDurationArrayAdapter);
+        mLoggingListener
+                .getLogText()
+                .observe(
+                        getActivity(),
+                        log -> {
+                            mLogText.setText(log);
+                        });
+        mBleConnectionViewModel =
+                new ViewModelProvider(this,
+                        new BleConnectionCentralViewModel.Factory(
+                                getActivity().getApplication(), mLoggingListener))
+                        .get(BleConnectionCentralViewModel.class);
+        mDistanceMeasurementViewModel = new ViewModelProvider(
+                this,
+                new DistanceMeasurementViewModel.Factory(
+                        getActivity(), mBleConnectionViewModel,
+                        mLoggingListener, false))
+                .get(DistanceMeasurementViewModel.class);
+        mBleConnectionViewModel
+                .getTargetDevice()
+                .observe(
+                        getActivity(),
+                        targetDevice -> {
+                            mDistanceMeasurementViewModel.setTargetDevice(targetDevice);
+                        });
+
+        mDistanceMeasurementViewModel
+                .getSessionState()
+                .observe(
+                        getActivity(),
+                        state-> {
+                            switch (state) {
+                                case STARTED:
+                                    mButton.setText(R.string.stop_measurement);
+                                    mDistanceCanvasView.cleanUp();
+                                    mButton.setClickable(true);
+                                    break;
+                                case STOPPED:
+                                    mButton.setText(R.string.start_measurement);
+                                    mButton.setClickable(true);
+                                    break;
+                                case STARTING:
+                                    mButton.setText(R.string.starting_measurement);
+                                    mButton.setClickable(false);
+                                    break;
+                                case STOPPING:
+                                    mButton.setText(R.string.stopping_measurement);
+                                    mButton.setClickable(false);
+                                    break;
+                            }
+                        });
+        mDistanceMeasurementViewModel
+                .getDistanceResult()
+                .observe(
+                        getActivity(),
+                        distanceMeters -> {
+                            mDistanceCanvasView.addNode(distanceMeters, /* abort= */ false);
+                            mDistanceText.setText(
+                                    DISTANCE_DECIMAL_FMT.format(distanceMeters) + " m");
+                        });
+
+        mTechnologyArrayAdapter.addAll(mDistanceMeasurementViewModel.getSupportedTechnologies());
+        mFreqArrayAdapter.addAll(mDistanceMeasurementViewModel.getMeasurementFreqs());
+        mDurationArrayAdapter.addAll(mDistanceMeasurementViewModel.getMeasurementDurations());
+        mButton.setOnClickListener(
+                v -> {
+                    String methodName = mSpinnerTechnology.getSelectedItem().toString();
+                    String freq = mSpinnerFreq.getSelectedItem().toString();
+                    int duration = Integer.parseInt(mSpinnerDuration.getSelectedItem().toString());
+
+                    if (TextUtils.isEmpty(methodName)) {
+                        printLog("the device doesn't support any distance measurement methods.");
+                    }
+
+                    mDistanceMeasurementViewModel.toggleStartStop(methodName, freq, duration);
+                });
+    }
+
+    private void printLog(String logMessage) {
+        mLoggingListener.log(logMessage);
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/LoggingListener.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/LoggingListener.java
new file mode 100644
index 00000000..6c154180
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/LoggingListener.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static androidx.core.content.ContextCompat.startActivity;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.util.Log;
+import android.widget.Toast;
+
+import androidx.lifecycle.MutableLiveData;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+
+public class LoggingListener {
+    private static String LOG_FILE_NAME = "logs.txt";
+
+    private final Context mContext;
+    private final File mLogFile;
+    private final boolean mIsResponder;
+    private final MutableLiveData<String> mLogText = new MutableLiveData<>();
+
+    private static LoggingListener sInstance;
+    public static LoggingListener getInstance() {
+        return sInstance;
+    }
+
+    public LoggingListener(Context context, boolean isResponder) {
+        mContext = context;
+        mIsResponder = isResponder;
+        mLogFile = new File(context.getFilesDir(), LOG_FILE_NAME);
+        sInstance = this;
+    }
+
+    public void log(String log) {
+        mLogText.postValue(log);
+        Log.i(mIsResponder ? "Responder" : "Initiator", log);
+        FileWriter fw = null;
+        try {
+            fw = new FileWriter(mLogFile);
+            fw.write(log);
+        } catch (IOException e) {
+        } finally {
+            try {
+                if (fw != null) fw.close();
+            } catch (IOException e) {}
+        }
+    }
+
+    public MutableLiveData<String> getLogText() {
+        return mLogText;
+    }
+
+    public void openLogFile() {
+        Uri path = Uri.fromFile(mLogFile);
+        Intent intent = new Intent(Intent.ACTION_VIEW);
+        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_NEW_TASK);
+        intent.setAction(Intent.ACTION_VIEW);
+        intent.setData(path);
+        intent.setType("text/plain");
+        try {
+            mContext.startActivity(intent);
+        } catch (ActivityNotFoundException e) {
+            Toast.makeText(mContext, "No application found", Toast.LENGTH_SHORT).show();
+        }
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/MainActivity.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/MainActivity.java
new file mode 100644
index 00000000..6d3522c1
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/MainActivity.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.Manifest.permission;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.core.app.ActivityCompat;
+import androidx.drawerlayout.widget.DrawerLayout;
+import androidx.navigation.NavController;
+import androidx.navigation.Navigation;
+import androidx.navigation.fragment.NavHostFragment;
+import androidx.navigation.ui.AppBarConfiguration;
+import androidx.navigation.ui.NavigationUI;
+
+import com.google.android.material.navigation.NavigationView;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class MainActivity extends AppCompatActivity {
+
+    private static final int REQUEST_CODE_PERMISSIONS = 100;
+    AppBarConfiguration mAppBarConfiguration;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        // Passing each menu ID as a set of Ids because each
+        DrawerLayout drawerLayout = findViewById(R.id.drawer_layout);
+        // to make the Navigation drawer icon always appear on the action bar
+        getSupportActionBar().setDisplayHomeAsUpEnabled(false);
+
+        NavHostFragment navHostFragment =
+                (NavHostFragment) getSupportFragmentManager()
+                        .findFragmentById(R.id.nav_host_fragment);
+        NavController navController = navHostFragment.getNavController();
+        NavigationView navView = findViewById(R.id.nav_view);
+        mAppBarConfiguration = new AppBarConfiguration.Builder(
+                R.id.navigation_initiator, R.id.navigation_initiator_configuration,
+                R.id.navigation_responder, R.id.navigation_responder_configuration)
+                .setOpenableLayout(drawerLayout)
+                .build();
+        NavigationUI.setupWithNavController(navView, navController);
+        NavigationUI.setupActionBarWithNavController(this, navController, mAppBarConfiguration);
+
+        requestPermissions();
+    }
+
+    @Override
+    public boolean onSupportNavigateUp() {
+        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment);
+        return NavigationUI.navigateUp(navController, mAppBarConfiguration)
+                || super.onSupportNavigateUp();
+    }
+
+    private void requestPermissions() {
+        String[] requiredPermissions =
+                new String[] {
+                    permission.ACCESS_COARSE_LOCATION,
+                    permission.ACCESS_FINE_LOCATION,
+                    permission.BLUETOOTH_ADVERTISE,
+                    permission.BLUETOOTH_CONNECT,
+                    permission.BLUETOOTH_SCAN,
+                    permission.RANGING
+                };
+        List<String> permissionsToRequest = new ArrayList<>();
+
+        for (String permission : requiredPermissions) {
+            if (ActivityCompat.checkSelfPermission(this, permission)
+                    != PackageManager.PERMISSION_GRANTED) {
+                permissionsToRequest.add(permission);
+            }
+        }
+        if (!permissionsToRequest.isEmpty()) {
+            ActivityCompat.requestPermissions(
+                    MainActivity.this,
+                    permissionsToRequest.toArray(new String[0]),
+                    REQUEST_CODE_PERMISSIONS);
+        }
+    }
+
+    @Override
+    public void onRequestPermissionsResult(
+            int requestCode, String[] permissions, int[] grantResults) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        if (requestCode == REQUEST_CODE_PERMISSIONS) {
+            boolean allGranted = true;
+            for (int r : grantResults) {
+                if (r != PackageManager.PERMISSION_GRANTED) {
+                    allGranted = false;
+                    break;
+                }
+            }
+            if (!allGranted) {
+                finish();
+            }
+        }
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/OobBleClient.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/OobBleClient.java
new file mode 100644
index 00000000..d64036de
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/OobBleClient.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothSocket;
+import android.content.Context;
+import android.ranging.oob.TransportHandle;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * OOB BLE client.
+ */
+public class OobBleClient implements TransportHandle {
+    private static final String TAG = "OobBleClient";
+    private final BleConnection mBleConnection;
+    private final LoggingListener mLoggingListener;
+    private final BluetoothDevice mBluetoothDevice;
+    private final BluetoothManager mBluetoothManager;
+    private final BluetoothAdapter mBluetoothAdapter;
+    private final OobBleClientConnectionThread mOobBleClientConnectionThread;
+    private CountDownLatch mSocketCountDownLatch = new CountDownLatch(1);
+    private BluetoothSocket mSocket;
+    private ReceiveCallback mReceiveCallback;
+    private Executor mReceiveExecutor;
+
+    public OobBleClient(
+            Context context, BleConnection bleConnection,
+            BluetoothDevice device, LoggingListener loggingListener) {
+        mBleConnection = bleConnection;
+        mLoggingListener = loggingListener;
+        mBluetoothDevice = device;
+        mBluetoothManager = context.getSystemService(BluetoothManager.class);
+        mBluetoothAdapter = mBluetoothManager.getAdapter();
+        mOobBleClientConnectionThread = new OobBleClientConnectionThread();
+        mOobBleClientConnectionThread.start();
+    }
+
+    @Override
+    public void sendData(byte[] data) {
+        try {
+            mSocket.getOutputStream().write(data);
+        } catch (IOException e) {
+            printLog("Failed to send data " + e);
+            mReceiveExecutor.execute(() -> {
+                mReceiveCallback.onSendFailed();
+            });
+        }
+    }
+
+    @Override
+    public void registerReceiveCallback(Executor executor, ReceiveCallback callback) {
+        mReceiveExecutor = executor;
+        mReceiveCallback = callback;
+    }
+
+    public boolean waitForSocketCreation() {
+        boolean success = false;
+        try {
+            success = mSocketCountDownLatch.await(1, TimeUnit.MINUTES);
+        } catch (InterruptedException e) {
+            printLog("Failed to wait for socket " + e);
+        }
+        if (!success) printLog("Timed out waiting for socket creation");
+        return success;
+    }
+
+    public class OobBleClientConnectionThread extends Thread {
+        private static final int MAX_DATA_SIZE = 1024;
+        @Override
+        public void run() {
+            try {
+                int psm = mBleConnection.waitForPsm();
+                if (psm == -1) return;
+                printLog("Creating L2cap socket on " + psm);
+                OobBleClient.this.mSocket =
+                        OobBleClient.this.mBluetoothDevice.createInsecureL2capChannel(psm);
+                printLog("Connecting on L2cap socket");
+                OobBleClient.this.mSocket.connect();
+                mSocketCountDownLatch.countDown();
+                printLog("Connected on L2cap socket " + mSocket.getRemoteDevice().getAddress());
+            } catch (IOException e) {
+                printLog("Failed to connect on L2cap" + e);
+            }
+            while (!isInterrupted()) {
+                try {
+                    byte[] data = new byte[MAX_DATA_SIZE];
+                    int dataSize = OobBleClient.this.mSocket.getInputStream().read(data);
+                    printLog("Received data size: " + dataSize);
+                    if (dataSize > 0) {
+                        mReceiveExecutor.execute(() -> {
+                            mReceiveCallback.onReceiveData(Arrays.copyOf(data, dataSize));
+                        });
+                    }
+                } catch (IOException e) {
+                    printLog("Failed to read data " + e);
+                }
+            }
+            printLog("Server connection thread interrupted");
+            try {
+                OobBleClient.this.mSocket.close();
+            } catch (IOException e) {
+                printLog("Failed to close socket " + e);
+            }
+            mReceiveExecutor.execute(() -> {
+                mReceiveCallback.onClose();
+            });
+        }
+    }
+
+    @Override
+    public void close() {
+        mOobBleClientConnectionThread.interrupt();
+    }
+
+    private void printLog(String log) {
+        mLoggingListener.log(log);
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/OobBleServer.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/OobBleServer.java
new file mode 100644
index 00000000..2ff78638
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/OobBleServer.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothServerSocket;
+import android.bluetooth.BluetoothSocket;
+import android.content.Context;
+import android.ranging.oob.TransportHandle;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * OOB BLE server.
+ */
+public class OobBleServer implements TransportHandle {
+    private static final String TAG = "OobBleServer";
+    private final BleConnection mBleConnection;
+    private final LoggingListener mLoggingListener;
+    private final BluetoothDevice mBluetoothDevice;
+    private final BluetoothManager mBluetoothManager;
+    private final BluetoothAdapter mBluetoothAdapter;
+    private final OobBleServerThread mOobBleServerThread;
+    private CountDownLatch mSocketCountDownLatch = new CountDownLatch(1);
+    private BluetoothSocket mSocket;
+    private ReceiveCallback mReceiveCallback;
+    private Executor mReceiveExecutor;
+
+    public OobBleServer(
+            Context context, BleConnection bleConnection,
+            BluetoothDevice device, LoggingListener loggingListener) {
+        mBleConnection = bleConnection;
+        mLoggingListener = loggingListener;
+        mBluetoothDevice = device;
+        mBluetoothManager = context.getSystemService(BluetoothManager.class);
+        mBluetoothAdapter = mBluetoothManager.getAdapter();
+        mOobBleServerThread = new OobBleServerThread();
+        mOobBleServerThread.start();
+    }
+
+    @Override
+    public void sendData(byte[] data) {
+        try {
+            mSocket.getOutputStream().write(data);
+        } catch (IOException e) {
+            printLog("Failed to send data " + e);
+            mReceiveExecutor.execute(() -> {
+                mReceiveCallback.onSendFailed();
+            });
+        }
+    }
+
+    @Override
+    public void registerReceiveCallback(Executor executor, ReceiveCallback callback) {
+        mReceiveExecutor = executor;
+        mReceiveCallback = callback;
+    }
+
+    public boolean waitForSocketCreation() {
+        boolean success = false;
+        try {
+            success = mSocketCountDownLatch.await(1, TimeUnit.MINUTES);
+        } catch (InterruptedException e) {
+            printLog("Failed to wait for socket " + e);
+        }
+        if (!success) printLog("Timed out waiting for socket creation");
+        return success;
+    }
+
+
+    public class OobBleServerThread extends Thread {
+        private BluetoothServerSocket mServerSocket;
+        private OobBleServerConnectionThread mOobBleServerConnectionThread;
+
+        @Override
+        public void run() {
+            while (!isInterrupted()) {
+                try {
+                    mServerSocket =
+                        OobBleServer.this.mBluetoothAdapter.listenUsingInsecureL2capChannel();
+                    printLog("Listening on l2cap socket for "
+                            + OobBleServer.this.mBluetoothDevice.getAddress()
+                            + " on "
+                            + mServerSocket.getPsm());
+                    mBleConnection.notifyPsm(mServerSocket.getPsm());
+                    BluetoothSocket socket = mServerSocket.accept();
+                    printLog("Accepted connection from " + socket.getRemoteDevice().getAddress());
+                    if (OobBleServer.this.mBluetoothDevice.equals(socket.getRemoteDevice())) {
+                        mOobBleServerConnectionThread = new OobBleServerConnectionThread(socket);
+                        mOobBleServerConnectionThread.start();
+                        mSocketCountDownLatch.countDown();
+                    }
+                } catch (IOException e) {
+                    printLog("Failed to accept connection " + e);
+                    return;
+                }
+            }
+            printLog("Server thread interrupted");
+            if (mOobBleServerConnectionThread != null) mOobBleServerConnectionThread.interrupt();
+        }
+    }
+
+    public class OobBleServerConnectionThread extends Thread {
+        private static final int MAX_DATA_SIZE = 1024;
+        public OobBleServerConnectionThread(BluetoothSocket socket) {
+            OobBleServer.this.mSocket = socket;
+        }
+
+
+        @Override
+        public void run() {
+            while (!isInterrupted()) {
+                try {
+                    byte[] data = new byte[MAX_DATA_SIZE];
+                    int dataSize = OobBleServer.this.mSocket.getInputStream().read(data);
+                    printLog("Received data size: " + dataSize);
+                    if (dataSize > 0) {
+                        mReceiveExecutor.execute(() -> {
+                            mReceiveCallback.onReceiveData(Arrays.copyOf(data, dataSize));
+                        });
+                    }
+                } catch (IOException e) {
+                    printLog("Failed to read data " + e);
+                }
+            }
+            printLog("Server connection thread interrupted");
+            try {
+                OobBleServer.this.mSocket.close();
+            } catch (IOException e) {
+                printLog("Failed to close socket " + e);
+            }
+            mReceiveExecutor.execute(() -> {
+                mReceiveCallback.onClose();
+            });
+        }
+    }
+
+    @Override
+    public void close() {
+        mOobBleServerThread.interrupt();
+    }
+
+    private void printLog(String log) {
+        mLoggingListener.log(log);
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/RangingParameters.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/RangingParameters.java
new file mode 100644
index 00000000..32d8786b
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/RangingParameters.java
@@ -0,0 +1,325 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import static android.ranging.uwb.UwbComplexChannel.UWB_CHANNEL_9;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_11;
+
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.ranging.RangingConfig;
+import android.ranging.RangingDevice;
+import android.ranging.RangingManager;
+import android.ranging.RangingPreference;
+import android.ranging.SensorFusionParams;
+import android.ranging.SessionConfig;
+import android.ranging.ble.cs.BleCsRangingParams;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+import android.ranging.oob.DeviceHandle;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.oob.OobResponderRangingConfig;
+import android.ranging.raw.RawInitiatorRangingConfig;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.raw.RawResponderRangingConfig;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingParams;
+import android.ranging.wifi.rtt.RttRangingParams;
+
+import java.time.Duration;
+import java.util.UUID;
+
+/** Utility class to hold ranging params shared across peer devices */
+public class RangingParameters {
+    public enum Freq {
+        HIGH(RawRangingDevice.UPDATE_RATE_FREQUENT),
+        MEDIUM(RawRangingDevice.UPDATE_RATE_NORMAL),
+        LOW(RawRangingDevice.UPDATE_RATE_INFREQUENT);
+        public final int freq;
+        Freq(int freq) {
+            this.freq = freq;
+        }
+        int getFreq() {
+            return freq;
+        }
+
+        Duration getSlowestIntervalDuration() {
+            switch (this) {
+                case HIGH:
+                    return Duration.ofMillis(1000);
+                case MEDIUM:
+                    return Duration.ofMillis(5000);
+                case LOW:
+                    return Duration.ofMillis(10000);
+                default:
+                    return Duration.ofMillis(100000);
+            }
+        }
+
+        Duration getFastestIntervalDuration() {
+            switch (this) {
+                case HIGH:
+                    return Duration.ofMillis(100);
+                case MEDIUM:
+                    return Duration.ofMillis(1000);
+                case LOW:
+                    return Duration.ofMillis(5000);
+                default:
+                    return Duration.ofMillis(10000);
+            }
+        }
+
+        @Override
+        public String toString() {
+            return name();
+        }
+        public static Freq fromName(String name) {
+            try {
+                return Freq.valueOf(name);
+            } catch (IllegalArgumentException e) {
+                return MEDIUM;
+            }
+        }
+    }
+
+    public enum Technology {
+        UWB(RangingManager.UWB),
+        BLE_RSSI(RangingManager.BLE_RSSI),
+        BLE_CS(RangingManager.BLE_CS),
+        WIFI_NAN_RTT(RangingManager.WIFI_NAN_RTT),
+        OOB(1000);
+        public final int technology;
+        Technology(int technology) {
+            this.technology = technology;
+        }
+        int getTechnology() {
+            return technology;
+        }
+        @Override
+        public String toString() {
+            return name();
+        }
+        public static Technology fromName(String name) {
+            try {
+                return Technology.valueOf(name);
+            } catch (IllegalArgumentException e) {
+                return BLE_RSSI;
+            }
+        }
+    }
+
+    private static RawInitiatorRangingConfig createRawInitiatorConfig(
+            String rangingTechnologyName, String freqName,
+            ConfigurationParameters configParams,
+            BluetoothDevice targetBtDevice) {
+        RawRangingDevice.Builder rawRangingDeviceBuilder = new RawRangingDevice.Builder()
+                .setRangingDevice(
+                        new RangingDevice.Builder()
+                                .setUuid(UUID.nameUUIDFromBytes(
+                                        targetBtDevice.getAddress().getBytes()))
+                                .build());
+        if (Technology.fromName(rangingTechnologyName).equals(Technology.UWB)) {
+            rawRangingDeviceBuilder.setUwbRangingParams(
+                    new UwbRangingParams.Builder(
+                            configParams.uwb.sessionId,
+                            configParams.uwb.configId,
+                            configParams.uwb.deviceAddress,
+                            configParams.uwb.peerDeviceAddress)
+                            .setComplexChannel(new UwbComplexChannel.Builder()
+                                    .setChannel(configParams.uwb.channel)
+                                    .setPreambleIndex(configParams.uwb.preamble)
+                                    .build())
+                            .setRangingUpdateRate(Freq.fromName(freqName).freq)
+                            .setSessionKeyInfo(configParams.uwb.sessionKey)
+                            .build());
+        } else if (Technology.fromName(rangingTechnologyName).equals(Technology.BLE_CS)) {
+            rawRangingDeviceBuilder.setCsRangingParams(
+                    new BleCsRangingParams.Builder(targetBtDevice.getAddress())
+                            .setRangingUpdateRate(Freq.fromName(freqName).freq)
+                            .setSecurityLevel(configParams.bleCs.securityLevel)
+                            .build());
+        } else if (Technology.fromName(rangingTechnologyName).equals(Technology.BLE_RSSI)) {
+            rawRangingDeviceBuilder.setBleRssiRangingParams(
+                    new BleRssiRangingParams.Builder(targetBtDevice.getAddress())
+                            .setRangingUpdateRate(Freq.fromName(freqName).freq)
+                            .build());
+        } else if (Technology.fromName(rangingTechnologyName).equals(Technology.WIFI_NAN_RTT)) {
+            rawRangingDeviceBuilder.setRttRangingParams(
+                    new RttRangingParams.Builder(configParams.wifiNanRtt.serviceName)
+                            .setRangingUpdateRate(Freq.fromName(freqName).freq)
+                            .setPeriodicRangingHwFeatureEnabled(
+                                    configParams.wifiNanRtt.isPeriodicRangingEnabled)
+                            .build());
+        }
+        return new RawInitiatorRangingConfig.Builder()
+            .addRawRangingDevice(rawRangingDeviceBuilder.build())
+            .build();
+    }
+
+    private static OobInitiatorRangingConfig createOobInitiatorConfig(
+            Context context, BleConnection bleConnection,
+            LoggingListener loggingListener, String freqName,
+            ConfigurationParameters configParams,
+            BluetoothDevice targetBtDevice) {
+        OobBleClient oobBleClient =
+                new OobBleClient(context, bleConnection, targetBtDevice,
+                        loggingListener);
+        if (!oobBleClient.waitForSocketCreation()) {
+            oobBleClient.close();
+            return null;
+        }
+        return new OobInitiatorRangingConfig.Builder()
+            .addDeviceHandle(
+                new DeviceHandle.Builder(
+                        new RangingDevice.Builder()
+                                .setUuid(UUID.nameUUIDFromBytes(
+                                        targetBtDevice.getAddress().getBytes()))
+                                .build(),
+                        oobBleClient)
+                    .build())
+            .setSecurityLevel(configParams.oob.securityLevel)
+            .setRangingMode(configParams.oob.mode)
+            .setSlowestRangingInterval(Freq.fromName(freqName).getSlowestIntervalDuration())
+            .setFastestRangingInterval(Freq.fromName(freqName).getFastestIntervalDuration())
+            .build();
+    }
+
+    public static RangingPreference createInitiatorRangingPreference(
+            Context context, BleConnection bleConnection,
+            LoggingListener loggingListener, String rangingTechnologyName, String freqName,
+            ConfigurationParameters configParams, int duration, BluetoothDevice targetBtDevice) {
+        RangingConfig initiatorRangingConfig = null;
+        if (Technology.fromName(rangingTechnologyName).equals(Technology.OOB)) {
+            initiatorRangingConfig =
+                    createOobInitiatorConfig(context, bleConnection,
+                            loggingListener, freqName, configParams, targetBtDevice);
+        } else {
+            initiatorRangingConfig =
+                createRawInitiatorConfig(
+                        rangingTechnologyName, freqName, configParams, targetBtDevice);
+        }
+        if (initiatorRangingConfig == null) return null;
+        SessionConfig sessionConfig = new SessionConfig.Builder()
+                .setSensorFusionParams(new SensorFusionParams.Builder()
+                        .setSensorFusionEnabled(configParams.global.sensorFusionEnabled)
+                        .build())
+                .setRangingMeasurementsLimit(duration)
+                .build();
+        RangingPreference rangingPreference = new RangingPreference.Builder(
+                RangingPreference.DEVICE_ROLE_INITIATOR, initiatorRangingConfig)
+                .setSessionConfig(sessionConfig)
+                .build();
+        return rangingPreference;
+    }
+
+    private static RawResponderRangingConfig createRawResponderConfig(
+            String rangingTechnologyName, String freqName,
+            ConfigurationParameters configParams,
+            BluetoothDevice targetBtDevice) {
+        RawRangingDevice.Builder rawRangingDeviceBuilder = new RawRangingDevice.Builder()
+                .setRangingDevice(
+                        new RangingDevice.Builder()
+                                .setUuid(UUID.nameUUIDFromBytes(
+                                        targetBtDevice.getAddress().getBytes()))
+                                .build());
+        if (Technology.fromName(rangingTechnologyName).equals(Technology.UWB)) {
+            rawRangingDeviceBuilder.setUwbRangingParams(
+                    new UwbRangingParams.Builder(
+                            configParams.uwb.sessionId,
+                            configParams.uwb.configId,
+                            configParams.uwb.deviceAddress,
+                            configParams.uwb.peerDeviceAddress)
+                            .setComplexChannel(new UwbComplexChannel.Builder()
+                                    .setChannel(configParams.uwb.channel)
+                                    .setPreambleIndex(configParams.uwb.preamble)
+                                    .build())
+                            .setRangingUpdateRate(Freq.fromName(freqName).freq)
+                            .setSessionKeyInfo(configParams.uwb.sessionKey)
+                            .build());
+        } else if (Technology.fromName(rangingTechnologyName).equals(Technology.BLE_CS)) {
+            rawRangingDeviceBuilder.setCsRangingParams(
+                    new BleCsRangingParams.Builder(targetBtDevice.getAddress())
+                            .setRangingUpdateRate(Freq.fromName(freqName).freq)
+                            .setSecurityLevel(configParams.bleCs.securityLevel)
+                            .build());
+        } else if (Technology.fromName(rangingTechnologyName).equals(Technology.BLE_RSSI)) {
+            rawRangingDeviceBuilder.setBleRssiRangingParams(
+                    new BleRssiRangingParams.Builder(targetBtDevice.getAddress())
+                            .setRangingUpdateRate(Freq.fromName(freqName).freq)
+                            .build());
+        } else if (Technology.fromName(rangingTechnologyName).equals(Technology.WIFI_NAN_RTT)) {
+            rawRangingDeviceBuilder.setRttRangingParams(
+                    new RttRangingParams.Builder(configParams.wifiNanRtt.serviceName)
+                            .setRangingUpdateRate(Freq.fromName(freqName).freq)
+                            .setPeriodicRangingHwFeatureEnabled(
+                                    configParams.wifiNanRtt.isPeriodicRangingEnabled)
+                            .build());
+        }
+        return new RawResponderRangingConfig.Builder()
+            .setRawRangingDevice(rawRangingDeviceBuilder.build())
+            .build();
+    }
+
+    private static OobResponderRangingConfig createOobResponderConfig(
+            Context context, BleConnection bleConnection,
+            LoggingListener loggingListener, String freqName,
+            ConfigurationParameters configParams,
+            BluetoothDevice targetBtDevice) {
+        OobBleServer oobBleServer =
+                new OobBleServer(context, bleConnection, targetBtDevice,
+                        loggingListener);
+        if (!oobBleServer.waitForSocketCreation()) {
+            oobBleServer.close();
+            return null;
+        }
+        return new OobResponderRangingConfig.Builder(
+                new DeviceHandle.Builder(
+                        new RangingDevice.Builder()
+                                .setUuid(UUID.nameUUIDFromBytes(
+                                        targetBtDevice.getAddress().getBytes()))
+                                .build(),
+                        oobBleServer).build())
+            .build();
+    }
+
+    public static RangingPreference createResponderRangingPreference(
+            Context context, BleConnection bleConnection,
+            LoggingListener loggingListener, String rangingTechnologyName, String freqName,
+            ConfigurationParameters configParams, int duration, BluetoothDevice targetBtDevice) {
+        RangingConfig responderRangingConfig = null;
+        if (Technology.fromName(rangingTechnologyName).equals(Technology.OOB)) {
+            responderRangingConfig =
+                    createOobResponderConfig(context, bleConnection,
+                            loggingListener, freqName, configParams, targetBtDevice);
+        } else {
+            responderRangingConfig =
+                createRawResponderConfig(rangingTechnologyName, freqName, configParams, targetBtDevice);
+        }
+        if (responderRangingConfig == null) return null;
+        SessionConfig sessionConfig = new SessionConfig.Builder()
+                .setSensorFusionParams(new SensorFusionParams.Builder()
+                        .setSensorFusionEnabled(configParams.global.sensorFusionEnabled)
+                        .build())
+                .setRangingMeasurementsLimit(duration)
+                .build();
+        RangingPreference rangingPreference = new RangingPreference.Builder(
+                RangingPreference.DEVICE_ROLE_RESPONDER, responderRangingConfig)
+                .setSessionConfig(sessionConfig)
+                .build();
+        return rangingPreference;
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ResponderConfigurationFragment.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ResponderConfigurationFragment.java
new file mode 100644
index 00000000..a9923da9
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ResponderConfigurationFragment.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import static android.view.View.INVISIBLE;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import androidx.annotation.NonNull;
+import androidx.constraintlayout.widget.ConstraintLayout;
+import androidx.fragment.app.Fragment;
+import androidx.navigation.fragment.NavHostFragment;
+
+/** The fragment holds the responder configuration of channel sounding. */
+@SuppressWarnings("SetTextI18n")
+public class ResponderConfigurationFragment extends ConfigurationFragment {
+    @Override
+    public View onCreateView(
+            @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        setIsResponder(true);
+        return super.onCreateView(inflater, container, savedInstanceState);
+    }
+}
diff --git a/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ResponderFragment.java b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ResponderFragment.java
new file mode 100644
index 00000000..436af842
--- /dev/null
+++ b/ranging/test_app/app/src/main/java/com/android/ranging/rangingtestapp/ResponderFragment.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rangingtestapp;
+
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.Button;
+import android.widget.LinearLayout;
+import android.widget.Spinner;
+import android.widget.TextView;
+
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentTransaction;
+import androidx.lifecycle.ViewModelProvider;
+
+import java.text.DecimalFormat;
+import java.util.ArrayList;
+
+/** The fragment holds the initiator of channel sounding. */
+@SuppressWarnings("SetTextI18n")
+public class ResponderFragment extends Fragment {
+
+    private static final DecimalFormat DISTANCE_DECIMAL_FMT = new DecimalFormat("0.00");
+
+    private ArrayAdapter<String> mTechnologyArrayAdapter;
+    private ArrayAdapter<String> mFreqArrayAdapter;
+    private ArrayAdapter<String> mDurationArrayAdapter;
+    private TextView mDistanceText;
+    private CanvasView mDistanceCanvasView;
+    private Spinner mSpinnerTechnology;
+    private Spinner mSpinnerFreq;
+    private Spinner mSpinnerDuration;
+    private Button mButton;
+    private LinearLayout mDistanceViewLayout;
+    private TextView mLogText;
+
+    private BleConnectionPeripheralViewModel mBleConnectionViewModel;
+    private DistanceMeasurementViewModel mDistanceMeasurementViewModel;
+    private LoggingListener mLoggingListener;
+
+    @Override
+    public View onCreateView(
+            @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View root = inflater.inflate(R.layout.fragment_initiator, container, false);
+        Fragment bleConnectionFragment = new BleConnectionPeripheralFragment();
+        FragmentTransaction transaction = getChildFragmentManager().beginTransaction();
+        transaction.replace(R.id.init_ble_connection_container, bleConnectionFragment).commit();
+
+        mButton = (Button) root.findViewById(R.id.btn_measure);
+        mSpinnerTechnology = (Spinner) root.findViewById(R.id.spinner_dm_tech);
+        mSpinnerFreq = (Spinner) root.findViewById(R.id.spinner_freq);
+        mSpinnerDuration = (Spinner) root.findViewById(R.id.spinner_duration);
+        mDistanceViewLayout = (LinearLayout) root.findViewById(R.id.layout_distance_view);
+        mDistanceText = new TextView(getContext());
+        mDistanceViewLayout.addView(mDistanceText);
+        mDistanceText.setText("0.00 m");
+        mDistanceText.setTextSize(96);
+        mDistanceText.setGravity(Gravity.END);
+        mDistanceCanvasView = new CanvasView(getContext(), "Distance");
+        mDistanceViewLayout.addView(mDistanceCanvasView);
+        mDistanceViewLayout.setPadding(0, 0, 0, 600);
+        mLoggingListener = new LoggingListener(getActivity().getApplicationContext(), true);
+        mLogText = (TextView) root.findViewById(R.id.text_log);
+        return root;
+    }
+
+    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+
+        mTechnologyArrayAdapter =
+                new ArrayAdapter<String>(
+                        getContext(), android.R.layout.simple_spinner_item, new ArrayList<>());
+        mTechnologyArrayAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mSpinnerTechnology.setAdapter(mTechnologyArrayAdapter);
+        mFreqArrayAdapter =
+                new ArrayAdapter<String>(
+                        getContext(), android.R.layout.simple_spinner_item, new ArrayList<>());
+        mFreqArrayAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+        mSpinnerFreq.setAdapter(mFreqArrayAdapter);
+        mDurationArrayAdapter =
+                new ArrayAdapter<String>(
+                        getContext(), android.R.layout.simple_spinner_item, new ArrayList<>());
+        mDurationArrayAdapter.setDropDownViewResource(
+                android.R.layout.simple_spinner_dropdown_item);
+        mSpinnerDuration.setAdapter(mDurationArrayAdapter);
+        mLoggingListener
+                .getLogText()
+                .observe(
+                        getActivity(),
+                        log -> {
+                            mLogText.setText(log);
+                        });
+        mBleConnectionViewModel =
+                new ViewModelProvider(this,
+                        new BleConnectionPeripheralViewModel.Factory(
+                                getActivity().getApplication(), mLoggingListener))
+                        .get(BleConnectionPeripheralViewModel.class);
+        mDistanceMeasurementViewModel = new ViewModelProvider(
+                this,
+                new DistanceMeasurementViewModel.Factory(
+                        getActivity(), mBleConnectionViewModel,
+                        mLoggingListener, true))
+                .get(DistanceMeasurementViewModel.class);
+        mBleConnectionViewModel
+                .getTargetDevice()
+                .observe(
+                        getActivity(),
+                        targetDevice -> {
+                            mDistanceMeasurementViewModel.setTargetDevice(targetDevice);
+                        });
+        mDistanceMeasurementViewModel
+                .getSessionState()
+                .observe(
+                        getActivity(),
+                        state-> {
+                            switch (state) {
+                                case STARTED:
+                                    mButton.setText(R.string.stop_measurement);
+                                    mDistanceCanvasView.cleanUp();
+                                    mButton.setClickable(true);
+                                    break;
+                                case STOPPED:
+                                    mButton.setText(R.string.start_measurement);
+                                    mButton.setClickable(true);
+                                    break;
+                                case STARTING:
+                                    mButton.setText(R.string.starting_measurement);
+                                    mButton.setClickable(false);
+                                    break;
+                                case STOPPING:
+                                    mButton.setText(R.string.stopping_measurement);
+                                    mButton.setClickable(false);
+                                    break;
+                            }
+                        });
+        mDistanceMeasurementViewModel
+                .getDistanceResult()
+                .observe(
+                        getActivity(),
+                        distanceMeters -> {
+                            mDistanceCanvasView.addNode(distanceMeters, /* abort= */ false);
+                            mDistanceText.setText(
+                                    DISTANCE_DECIMAL_FMT.format(distanceMeters) + " m");
+                        });
+
+        mTechnologyArrayAdapter.addAll(mDistanceMeasurementViewModel.getSupportedTechnologies());
+        mFreqArrayAdapter.addAll(mDistanceMeasurementViewModel.getMeasurementFreqs());
+        mDurationArrayAdapter.addAll(mDistanceMeasurementViewModel.getMeasurementDurations());
+        mButton.setOnClickListener(
+                v -> {
+                    String methodName = mSpinnerTechnology.getSelectedItem().toString();
+                    String freq = mSpinnerFreq.getSelectedItem().toString();
+                    int duration = Integer.parseInt(mSpinnerDuration.getSelectedItem().toString());
+
+                    if (TextUtils.isEmpty(methodName)) {
+                        printLog("the device doesn't support any distance measurement methods.");
+                    }
+
+                    mDistanceMeasurementViewModel.toggleStartStop(methodName, freq, duration);
+                });
+    }
+
+    private void printLog(String logMessage) {
+        mLoggingListener.log(logMessage);
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+    }
+}
diff --git a/ranging/test_app/app/src/main/res/drawable/ic_configuration.xml b/ranging/test_app/app/src/main/res/drawable/ic_configuration.xml
new file mode 100644
index 00000000..4bcd4aae
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/drawable/ic_configuration.xml
@@ -0,0 +1,10 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="960"
+    android:viewportHeight="960"
+    android:tint="?attr/colorControlNormal">
+  <path
+      android:fillColor="@android:color/white"
+      android:pathData="M370,880L354,752Q341,747 329.5,740Q318,733 307,725L188,775L78,585L181,507Q180,500 180,493.5Q180,487 180,480Q180,473 180,466.5Q180,460 181,453L78,375L188,185L307,235Q318,227 330,220Q342,213 354,208L370,80L590,80L606,208Q619,213 630.5,220Q642,227 653,235L772,185L882,375L779,453Q780,460 780,466.5Q780,473 780,480Q780,487 780,493.5Q780,500 778,507L881,585L771,775L653,725Q642,733 630,740Q618,747 606,752L590,880L370,880ZM440,800L519,800L533,694Q564,686 590.5,670.5Q617,655 639,633L738,674L777,606L691,541Q696,527 698,511.5Q700,496 700,480Q700,464 698,448.5Q696,433 691,419L777,354L738,286L639,328Q617,305 590.5,289.5Q564,274 533,266L520,160L441,160L427,266Q396,274 369.5,289.5Q343,305 321,327L222,286L183,354L269,418Q264,433 262,448Q260,463 260,480Q260,496 262,511Q264,526 269,541L183,606L222,674L321,632Q343,655 369.5,670.5Q396,686 427,694L440,800ZM482,620Q540,620 581,579Q622,538 622,480Q622,422 581,381Q540,340 482,340Q423,340 382.5,381Q342,422 342,480Q342,538 382.5,579Q423,620 482,620ZM480,480L480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480L480,480Z"/>
+</vector>
diff --git a/ranging/test_app/app/src/main/res/drawable/ic_controlee.xml b/ranging/test_app/app/src/main/res/drawable/ic_controlee.xml
new file mode 100644
index 00000000..a6a042a7
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/drawable/ic_controlee.xml
@@ -0,0 +1,10 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="960"
+    android:viewportHeight="960"
+    android:tint="?attr/colorControlNormal">
+  <path
+      android:fillColor="@android:color/white"
+      android:pathData="M40,480Q40,388 74.5,308Q109,228 169,168.5Q229,109 309,74.5Q389,40 480,40Q571,40 651,74.5Q731,109 791,168.5Q851,228 885.5,308Q920,388 920,480L840,480Q840,405 811.5,339.5Q783,274 734,225Q685,176 619.5,148Q554,120 480,120Q406,120 340.5,148Q275,176 226,225Q177,274 148.5,339.5Q120,405 120,480L40,480ZM200,480Q200,362 282,281Q364,200 480,200Q596,200 678,281Q760,362 760,480L680,480Q680,397 621.5,338.5Q563,280 480,280Q397,280 338.5,338.5Q280,397 280,480L200,480ZM360,896L304,840L440,704L440,572Q413,560 396.5,535Q380,510 380,480Q380,438 409,409Q438,380 480,380Q522,380 551,409Q580,438 580,480Q580,510 563.5,535Q547,560 520,572L520,704L656,840L600,896L480,776L360,896Z"/>
+</vector>
diff --git a/ranging/test_app/app/src/main/res/drawable/ic_controller.xml b/ranging/test_app/app/src/main/res/drawable/ic_controller.xml
new file mode 100644
index 00000000..40d20c5e
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/drawable/ic_controller.xml
@@ -0,0 +1,10 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="960"
+    android:viewportHeight="960"
+    android:tint="?attr/colorControlNormal">
+  <path
+      android:fillColor="@android:color/white"
+      android:pathData="M198,682Q141,625 110.5,552.5Q80,480 80,400Q80,320 110.5,247.5Q141,175 198,118L246,166Q199,213 173.5,273.5Q148,334 148,400Q148,466 173.5,526.5Q199,587 246,634L198,682ZM290,590Q252,552 232,503Q212,454 212,400Q212,346 232,297Q252,248 290,210L338,258Q309,287 294.5,323.5Q280,360 280,400Q280,440 294.5,476.5Q309,513 338,542L290,590ZM440,840L440,492Q413,480 396.5,455Q380,430 380,400Q380,358 409,329Q438,300 480,300Q522,300 551,329Q580,358 580,400Q580,430 563.5,455Q547,480 520,492L520,840L440,840ZM670,590L622,542Q651,513 665.5,476.5Q680,440 680,400Q680,360 665.5,323.5Q651,287 622,258L670,210Q708,248 728,297Q748,346 748,400Q748,454 728,503Q708,552 670,590ZM762,682L714,634Q761,587 786.5,526.5Q812,466 812,400Q812,334 786.5,273.5Q761,213 714,166L762,118Q819,175 849.5,247.5Q880,320 880,400Q880,480 849.5,552.5Q819,625 762,682Z"/>
+</vector>
diff --git a/ranging/test_app/app/src/main/res/drawable/ic_launcher_background.xml b/ranging/test_app/app/src/main/res/drawable/ic_launcher_background.xml
new file mode 100644
index 00000000..61bb79ed
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/drawable/ic_launcher_background.xml
@@ -0,0 +1,170 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportHeight="108"
+    android:viewportWidth="108">
+  <path
+      android:fillColor="#3DDC84"
+      android:pathData="M0,0h108v108h-108z" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M9,0L9,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M19,0L19,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M29,0L29,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M39,0L39,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M49,0L49,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M59,0L59,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M69,0L69,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M79,0L79,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M89,0L89,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M99,0L99,108"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,9L108,9"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,19L108,19"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,29L108,29"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,39L108,39"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,49L108,49"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,59L108,59"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,69L108,69"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,79L108,79"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,89L108,89"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M0,99L108,99"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M19,29L89,29"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M19,39L89,39"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M19,49L89,49"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M19,59L89,59"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M19,69L89,69"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M19,79L89,79"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M29,19L29,89"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M39,19L39,89"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M49,19L49,89"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M59,19L59,89"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M69,19L69,89"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+  <path
+      android:fillColor="#00000000"
+      android:pathData="M79,19L79,89"
+      android:strokeColor="#33FFFFFF"
+      android:strokeWidth="0.8" />
+</vector>
diff --git a/ranging/test_app/app/src/main/res/drawable/ic_launcher_foreground.xml b/ranging/test_app/app/src/main/res/drawable/ic_launcher_foreground.xml
new file mode 100644
index 00000000..966abaff
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/drawable/ic_launcher_foreground.xml
@@ -0,0 +1,30 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:aapt="http://schemas.android.com/aapt"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportHeight="108"
+    android:viewportWidth="108">
+  <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
+    <aapt:attr name="android:fillColor">
+      <gradient
+          android:endX="85.84757"
+          android:endY="92.4963"
+          android:startX="42.9492"
+          android:startY="49.59793"
+          android:type="linear">
+        <item
+            android:color="#44000000"
+            android:offset="0.0" />
+        <item
+            android:color="#00000000"
+            android:offset="1.0" />
+      </gradient>
+    </aapt:attr>
+  </path>
+  <path
+      android:fillColor="#FFFFFF"
+      android:fillType="nonZero"
+      android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
+      android:strokeColor="#00000000"
+      android:strokeWidth="1" />
+</vector>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/layout/activity_main.xml b/ranging/test_app/app/src/main/res/layout/activity_main.xml
new file mode 100644
index 00000000..30657b54
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/layout/activity_main.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.drawerlayout.widget.DrawerLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/drawer_layout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context=".MainActivity"
+    tools:ignore="HardcodedText">
+
+  <!-- Layout to contain contents of main body of screen (drawer will slide over this) -->
+  <androidx.fragment.app.FragmentContainerView
+      android:name="androidx.navigation.fragment.NavHostFragment"
+      android:id="@+id/nav_host_fragment"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      app:defaultNavHost="true"
+      app:navGraph="@navigation/nav_graph" />
+
+  <!-- this the navigation view which draws and shows the navigation drawer -->
+  <!-- include the menu created in the menu folder -->
+  <com.google.android.material.navigation.NavigationView
+      android:id="@+id/nav_view"
+      android:layout_width="wrap_content"
+      android:layout_height="match_parent"
+      android:layout_gravity="start"
+      app:menu="@menu/nav_menu"
+      android:fitsSystemWindows="true" />
+</androidx.drawerlayout.widget.DrawerLayout>
diff --git a/ranging/test_app/app/src/main/res/layout/fragment_ble_connection_central.xml b/ranging/test_app/app/src/main/res/layout/fragment_ble_connection_central.xml
new file mode 100644
index 00000000..f5bdc9a5
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/layout/fragment_ble_connection_central.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/ble_connection_fragment_central"
+    android:layout_marginTop="?attr/actionBarSize"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context=".BleConnectionCentralFragment"
+    tools:ignore="HardcodedText">
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+        <TextView
+            android:id="@+id/central_text"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/ble_central"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+        <Spinner
+            android:id="@+id/spinner_bt_address_central"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_margin="5dp"
+            android:padding="5dp"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/central_text" />
+        <Button
+            android:id="@+id/btn_scan_connect"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_margin="5dp"
+            android:layout_marginTop="12dp"
+            android:padding="5dp"
+            android:text="Scan and connect"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/spinner_bt_address_central" />
+        <View
+            android:id="@+id/divider"
+            android:layout_width="wrap_content"
+            android:layout_height="2dp"
+            android:background="?android:attr/listDivider"
+            android:foreground="@color/design_default_color_error"
+            app:layout_constraintTop_toBottomOf="@+id/btn_scan_connect"
+            tools:layout_editor_absoluteX="1dp" />
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</FrameLayout>
diff --git a/ranging/test_app/app/src/main/res/layout/fragment_ble_connection_peripheral.xml b/ranging/test_app/app/src/main/res/layout/fragment_ble_connection_peripheral.xml
new file mode 100644
index 00000000..7996040c
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/layout/fragment_ble_connection_peripheral.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/ble_connection_fragment_peripheral"
+    android:layout_marginTop="?attr/actionBarSize"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context=".BleConnectionPeripheralFragment"
+    tools:ignore="HardcodedText">
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+        <TextView
+            android:id="@+id/peripheral_text"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/ble_peripheral"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+        <Spinner
+            android:id="@+id/spinner_bt_address_peripheral"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_margin="5dp"
+            android:padding="5dp"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/peripheral_text" />
+        <Button
+            android:id="@+id/btn_advertising"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="Start Advertising"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintHorizontal_bias="0.498"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/spinner_bt_address_peripheral" />
+        <View
+            android:id="@+id/divider"
+            android:layout_width="wrap_content"
+            android:layout_height="2dp"
+            android:background="?android:attr/listDivider"
+            android:foreground="@color/design_default_color_error"
+            app:layout_constraintTop_toBottomOf="@+id/btn_advertising"
+            tools:layout_editor_absoluteX="1dp" />
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</FrameLayout>
diff --git a/ranging/test_app/app/src/main/res/layout/fragment_configuration.xml b/ranging/test_app/app/src/main/res/layout/fragment_configuration.xml
new file mode 100644
index 00000000..1908ca2a
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/layout/fragment_configuration.xml
@@ -0,0 +1,342 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/fragment_configuration"
+    android:fillViewport="true"
+    tools:context=".ResponderConfigurationFragment"
+    tools:ignore="HardcodedText"
+    android:layout_marginTop="?attr/actionBarSize"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <androidx.constraintlayout.widget.ConstraintLayout android:id="@+id/layout_global"
+        android:layout_marginTop="?attr/actionBarSize"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintBottom_toTopOf="@id/layout_uwb"
+        android:orientation="horizontal">
+        <LinearLayout android:id="@+id/global_header"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintBottom_toTopOf="@id/global_params"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/global_header_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:textStyle="bold"
+                android:text="Global parameters"/>
+        </LinearLayout>
+        <LinearLayout android:id="@+id/global_params"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/global_header"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintWidth_default="percent"
+            app:layout_constraintWidth_percent=".5"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/global_sensor_fusion_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Sensor Fusion"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/global_sensor_fusion_spinner"/>
+            <Spinner
+                android:id="@+id/global_sensor_fusion_spinner"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/global_sensor_fusion_text"
+                app:layout_constraintEnd_toEndOf="parent"/>
+        </LinearLayout>
+    </androidx.constraintlayout.widget.ConstraintLayout>
+    <androidx.constraintlayout.widget.ConstraintLayout android:id="@+id/layout_uwb"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toBottomOf="@id/layout_global"
+        app:layout_constraintBottom_toTopOf="@id/layout_ble_cs"
+        android:orientation="horizontal">
+        <LinearLayout android:id="@+id/uwb_header"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintBottom_toTopOf="@id/uwb_params"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/uwb_header_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:textStyle="bold"
+                android:text="UWB parameters"/>
+        </LinearLayout>
+        <LinearLayout android:id="@+id/uwb_params"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/uwb_header"
+            app:layout_constraintBottom_toTopOf="@id/uwb_params_2"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/uwb_channel_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Channel"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/uwb_channel_spinner"/>
+            <Spinner
+                android:id="@+id/uwb_channel_spinner"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/uwb_channel_text"
+                app:layout_constraintEnd_toEndOf="parent"/>
+            <TextView
+                android:id="@+id/uwb_preamble_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Preamble"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/uwb_preamble_spinner"/>
+            <Spinner
+                android:id="@+id/uwb_preamble_spinner"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/uwb_preamble_text"
+                app:layout_constraintEnd_toEndOf="parent"/>
+        </LinearLayout>
+        <LinearLayout android:id="@+id/uwb_params_2"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/uwb_params_2"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintWidth_default="percent"
+            app:layout_constraintWidth_percent=".5"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/uwb_config_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Config ID"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/uwb_config_spinner"/>
+            <Spinner
+                android:id="@+id/uwb_config_spinner"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/uwb_config_text"
+                app:layout_constraintEnd_toEndOf="parent"/>
+        </LinearLayout>
+    </androidx.constraintlayout.widget.ConstraintLayout>
+    <androidx.constraintlayout.widget.ConstraintLayout android:id="@+id/layout_ble_cs"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toBottomOf="@id/layout_uwb"
+        app:layout_constraintBottom_toTopOf="@id/layout_ble_rssi"
+        android:orientation="horizontal">
+        <LinearLayout android:id="@+id/ble_cs_header"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintBottom_toTopOf="@id/ble_cs_params"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/ble_cs_header_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:textStyle="bold"
+                android:text="BLE CS parameters"/>
+        </LinearLayout>
+        <LinearLayout android:id="@+id/ble_cs_params"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/ble_cs_header"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintWidth_default="percent"
+            app:layout_constraintWidth_percent=".5"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/ble_cs_security_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Security Level"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/ble_cs_security_spinner"/>
+            <Spinner
+                android:id="@+id/ble_cs_security_spinner"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/ble_cs_security_text"
+                app:layout_constraintEnd_toEndOf="parent"/>
+        </LinearLayout>
+    </androidx.constraintlayout.widget.ConstraintLayout>
+    <androidx.constraintlayout.widget.ConstraintLayout android:id="@+id/layout_ble_rssi"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toBottomOf="@id/layout_ble_cs"
+        app:layout_constraintBottom_toTopOf="@id/layout_wifi_nan_rtt"
+        android:orientation="horizontal">
+        <LinearLayout android:id="@+id/ble_rssi_header"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintBottom_toBottomOf="parent"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/blr_rssi_header_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:textStyle="bold"
+                android:text="BLE RSSI parameters"/>
+        </LinearLayout>
+    </androidx.constraintlayout.widget.ConstraintLayout>
+    <androidx.constraintlayout.widget.ConstraintLayout android:id="@+id/layout_wifi_nan_rtt"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toBottomOf="@id/layout_ble_rssi"
+        app:layout_constraintBottom_toTopOf="@id/layout_oob"
+        android:orientation="horizontal">
+        <LinearLayout android:id="@+id/wifi_nan_rtt_header"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintBottom_toBottomOf="parent"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/wifi_nan_rtt_header_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:textStyle="bold"
+                android:text="Wifi NAN RTT parameters"/>
+        </LinearLayout>
+        <LinearLayout android:id="@+id/wifi_nan_rtt_params"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/wifi_nan_rtt_header"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintWidth_default="percent"
+            app:layout_constraintWidth_percent=".5"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/wifi_nan_rtt_periodic_ranging_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Periodic Ranging"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/wifi_nan_rtt_periodic_ranging_spinner"/>
+            <Spinner
+                android:id="@+id/wifi_nan_rtt_periodic_ranging_spinner"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/wifi_nan_rtt_periodic_ranging_text"
+                app:layout_constraintEnd_toEndOf="parent"/>
+        </LinearLayout>
+    </androidx.constraintlayout.widget.ConstraintLayout>
+    <androidx.constraintlayout.widget.ConstraintLayout android:id="@+id/layout_oob"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toBottomOf="@id/layout_wifi_nan_rtt"
+        app:layout_constraintBottom_toTopOf="@id/layout_button"
+        android:orientation="horizontal">
+        <LinearLayout android:id="@+id/oob_header"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintBottom_toBottomOf="parent"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/oob_header_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:textStyle="bold"
+                android:text="OOB parameters"/>
+        </LinearLayout>
+        <LinearLayout android:id="@+id/oob_params"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/oob_header"
+            app:layout_constraintBottom_toBottomOf="parent"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/oob_security_level_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Security Level"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/oob_security_level_spinner"/>
+            <Spinner
+                android:id="@+id/oob_security_level_spinner"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/oob_security_level_text"
+                app:layout_constraintEnd_toEndOf="parent"/>
+            <TextView
+                android:id="@+id/oob_mode_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Mode"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/oob_mode_spinner"/>
+            <Spinner
+                android:id="@+id/oob_mode_spinner"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/oob_mode_text"
+                app:layout_constraintEnd_toEndOf="parent"/>
+        </LinearLayout>
+    </androidx.constraintlayout.widget.ConstraintLayout>
+    <LinearLayout android:id="@+id/layout_button"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toBottomOf="@id/layout_oob"
+        app:layout_constraintBottom_toBottomOf="parent"
+        android:orientation="horizontal">
+        <Button
+            android:id="@+id/btn_save"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_margin="5dp"
+            android:padding="5dp"
+            android:text="Save"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintEnd_toStartOf="@id/btn_reset"/>
+        <Button
+            android:id="@+id/btn_reset"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_margin="5dp"
+            android:padding="5dp"
+            android:text="Reset"
+            app:layout_constraintStart_toEndOf="@id/btn_save"
+            app:layout_constraintEnd_toEndOf="parent"/>
+    </LinearLayout>
+</androidx.constraintlayout.widget.ConstraintLayout>
diff --git a/ranging/test_app/app/src/main/res/layout/fragment_initiator.xml b/ranging/test_app/app/src/main/res/layout/fragment_initiator.xml
new file mode 100644
index 00000000..ae8b187d
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/layout/fragment_initiator.xml
@@ -0,0 +1,138 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/fragment_initiator"
+    android:layout_marginTop="?attr/actionBarSize"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fillViewport="true"
+    tools:context=".InitiatorFragment"
+    tools:ignore="HardcodedText">
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:layout_marginTop="?attr/actionBarSize"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+        <FrameLayout
+            android:id="@+id/init_ble_connection_container"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:gravity="center_vertical"
+            app:layout_constraintBottom_toTopOf="@id/layout_techs"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+
+        <LinearLayout android:id="@+id/layout_techs"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/init_ble_connection_container"
+            app:layout_constraintBottom_toTopOf="@id/layout_parameters"
+            android:weightSum="4"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/dm_tech_label"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Tech"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/spinner_dm_tech"
+                />
+            <Spinner
+                android:id="@+id/spinner_dm_tech"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/dm_tech_label"
+                app:layout_constraintEnd_toEndOf="parent"
+                />
+        </LinearLayout>
+        <LinearLayout android:id="@+id/layout_parameters"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/layout_techs"
+            app:layout_constraintBottom_toTopOf="@id/btn_measure"
+            android:weightSum="4"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/freq_label"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Freq"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/spinner_freq"
+                />
+            <Spinner
+                android:id="@+id/spinner_freq"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/freq_label"
+                app:layout_constraintEnd_toStartOf="@id/duration_label"
+                />
+            <TextView
+                android:id="@+id/duration_label"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.7"
+                android:text= "Duration"
+                app:layout_constraintStart_toEndOf="@id/spinner_freq"
+                app:layout_constraintEnd_toStartOf="@id/spinner_duration"
+                />
+            <Spinner
+                android:id="@+id/spinner_duration"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.3"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/duration_label"
+                app:layout_constraintEnd_toEndOf="parent"
+                />
+        </LinearLayout>
+        <Button
+            android:id="@+id/btn_measure"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_margin="10dp"
+            android:layout_marginTop="84dp"
+            android:padding="10dp"
+            android:text="Start Distance Measurement"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/layout_parameters" />
+        <TextView
+            android:id="@+id/text_log"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:paddingTop="10dp"
+            android:paddingBottom="20dp"
+            android:text="Test log: "
+            android:textSize="18sp"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/btn_measure"/>
+        <ScrollView
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="2"
+            android:fillViewport="true"
+            android:paddingTop="20dp"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/text_log">
+
+            <LinearLayout
+                android:id="@+id/layout_distance_view"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical"></LinearLayout>
+        </ScrollView>
+
+
+
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</androidx.core.widget.NestedScrollView>
diff --git a/ranging/test_app/app/src/main/res/layout/fragment_responder.xml b/ranging/test_app/app/src/main/res/layout/fragment_responder.xml
new file mode 100644
index 00000000..994e8b63
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/layout/fragment_responder.xml
@@ -0,0 +1,137 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/fragment_responder"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:layout_marginTop="?attr/actionBarSize"
+    android:fillViewport="true"
+    tools:context=".ResponderFragment"
+    tools:ignore="HardcodedText">
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:layout_marginTop="?attr/actionBarSize"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+        <FrameLayout
+            android:id="@+id/init_ble_connection_container"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:gravity="center_vertical"
+            app:layout_constraintBottom_toTopOf="@id/layout_techs"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+
+        <LinearLayout android:id="@+id/layout_techs"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/init_ble_connection_container"
+            app:layout_constraintBottom_toTopOf="@id/layout_parameters"
+            android:weightSum="4"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/dm_tech_label"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Tech"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/spinner_dm_tech"
+                />
+            <Spinner
+                android:id="@+id/spinner_dm_tech"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/dm_tech_label"
+                app:layout_constraintEnd_toEndOf="parent"
+                />
+        </LinearLayout>
+        <LinearLayout android:id="@+id/layout_parameters"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            app:layout_constraintTop_toBottomOf="@id/layout_techs"
+            app:layout_constraintBottom_toTopOf="@id/btn_measure"
+            android:weightSum="4"
+            android:orientation="horizontal">
+            <TextView
+                android:id="@+id/freq_label"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.6"
+                android:text= "Freq"
+                app:layout_constraintStart_toStartOf="parent"
+                app:layout_constraintEnd_toStartOf="@id/spinner_freq"
+                />
+            <Spinner
+                android:id="@+id/spinner_freq"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.4"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/freq_label"
+                app:layout_constraintEnd_toStartOf="@id/duration_label"
+                />
+            <TextView
+                android:id="@+id/duration_label"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="0.7"
+                android:text= "Duration"
+                app:layout_constraintStart_toEndOf="@id/spinner_freq"
+                app:layout_constraintEnd_toStartOf="@id/spinner_duration"
+                />
+            <Spinner
+                android:id="@+id/spinner_duration"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.3"
+                android:padding="10dp"
+                app:layout_constraintStart_toEndOf="@id/duration_label"
+                app:layout_constraintEnd_toEndOf="parent"
+                />
+        </LinearLayout>
+        <Button
+            android:id="@+id/btn_measure"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_margin="10dp"
+            android:layout_marginTop="84dp"
+            android:padding="10dp"
+            android:text="Start Distance Measurement"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/layout_parameters" />
+        <TextView
+            android:id="@+id/text_log"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:paddingTop="10dp"
+            android:paddingBottom="20dp"
+            android:text="Test log: "
+            android:textSize="18sp"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/btn_measure"/>
+        <ScrollView
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="2"
+            android:fillViewport="true"
+            android:paddingTop="20dp"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/text_log">
+
+            <LinearLayout
+                android:id="@+id/layout_distance_view"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical">
+            </LinearLayout>
+        </ScrollView>
+
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</androidx.core.widget.NestedScrollView>
diff --git a/ranging/test_app/app/src/main/res/menu/nav_menu.xml b/ranging/test_app/app/src/main/res/menu/nav_menu.xml
new file mode 100644
index 00000000..718b6681
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/menu/nav_menu.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+     <item android:title="@string/initiator">
+          <menu>
+               <item android:id="@+id/navigation_initiator"
+                   android:icon="@drawable/ic_controller"
+                   android:title="@string/initiator"/>
+               <item android:id="@+id/navigation_initiator_configuration"
+                   android:icon="@drawable/ic_configuration"
+                   android:title="@string/initiator_configuration"/>
+          </menu>
+     </item>
+     <item android:title="@string/responder">
+          <menu>
+               <item android:id="@+id/navigation_responder"
+                   android:icon="@drawable/ic_controlee"
+                   android:title="@string/responder" />
+               <item android:id="@+id/navigation_responder_configuration"
+                   android:icon="@drawable/ic_configuration"
+                   android:title="@string/responder_configuration"/>
+          </menu>
+     </item>
+</menu>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/mipmap-anydpi/ic_launcher.xml b/ranging/test_app/app/src/main/res/mipmap-anydpi/ic_launcher.xml
new file mode 100644
index 00000000..5ad9ce15
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/mipmap-anydpi/ic_launcher.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+  <background android:drawable="@drawable/ic_launcher_background" />
+  <foreground android:drawable="@drawable/ic_launcher_foreground" />
+  <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+</adaptive-icon>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml b/ranging/test_app/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
new file mode 100644
index 00000000..5ad9ce15
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+  <background android:drawable="@drawable/ic_launcher_background" />
+  <foreground android:drawable="@drawable/ic_launcher_foreground" />
+  <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+</adaptive-icon>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/mipmap-hdpi/ic_launcher.webp b/ranging/test_app/app/src/main/res/mipmap-hdpi/ic_launcher.webp
new file mode 100644
index 00000000..c209e78e
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-hdpi/ic_launcher.webp differ
diff --git a/ranging/test_app/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp b/ranging/test_app/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp
new file mode 100644
index 00000000..b2dfe3d1
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp differ
diff --git a/ranging/test_app/app/src/main/res/mipmap-mdpi/ic_launcher.webp b/ranging/test_app/app/src/main/res/mipmap-mdpi/ic_launcher.webp
new file mode 100644
index 00000000..4f0f1d64
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-mdpi/ic_launcher.webp differ
diff --git a/ranging/test_app/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp b/ranging/test_app/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp
new file mode 100644
index 00000000..62b611da
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp differ
diff --git a/ranging/test_app/app/src/main/res/mipmap-xhdpi/ic_launcher.webp b/ranging/test_app/app/src/main/res/mipmap-xhdpi/ic_launcher.webp
new file mode 100644
index 00000000..948a3070
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-xhdpi/ic_launcher.webp differ
diff --git a/ranging/test_app/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp b/ranging/test_app/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp
new file mode 100644
index 00000000..1b9a6956
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp differ
diff --git a/ranging/test_app/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp b/ranging/test_app/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp
new file mode 100644
index 00000000..28d4b77f
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp differ
diff --git a/ranging/test_app/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp b/ranging/test_app/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp
new file mode 100644
index 00000000..9287f508
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp differ
diff --git a/ranging/test_app/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp b/ranging/test_app/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp
new file mode 100644
index 00000000..aa7d6427
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp differ
diff --git a/ranging/test_app/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp b/ranging/test_app/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp
new file mode 100644
index 00000000..9126ae37
Binary files /dev/null and b/ranging/test_app/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp differ
diff --git a/ranging/test_app/app/src/main/res/navigation/nav_graph.xml b/ranging/test_app/app/src/main/res/navigation/nav_graph.xml
new file mode 100644
index 00000000..a8aacd93
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/navigation/nav_graph.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<navigation xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/nav_graph"
+    app:startDestination="@id/navigation_initiator">
+
+  <fragment
+      android:id="@+id/navigation_initiator"
+      android:name="com.android.ranging.rangingtestapp.InitiatorFragment"
+      android:label="@string/initiator"
+      tools:layout="@layout/fragment_initiator" />
+
+  <fragment
+      android:id="@+id/navigation_initiator_configuration"
+      android:name="com.android.ranging.rangingtestapp.InitiatorConfigurationFragment"
+      android:label="@string/initiator_configuration"
+      tools:layout="@layout/fragment_configuration" />
+
+  <fragment
+      android:id="@+id/navigation_responder"
+      android:name="com.android.ranging.rangingtestapp.ResponderFragment"
+      android:label="@string/responder"
+      tools:layout="@layout/fragment_responder" />
+
+  <fragment
+      android:id="@+id/navigation_responder_configuration"
+      android:name="com.android.ranging.rangingtestapp.ResponderConfigurationFragment"
+      android:label="@string/responder_configuration"
+      tools:layout="@layout/fragment_configuration" />
+</navigation>
diff --git a/ranging/test_app/app/src/main/res/values-land/dimens.xml b/ranging/test_app/app/src/main/res/values-land/dimens.xml
new file mode 100644
index 00000000..855a4229
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/values-land/dimens.xml
@@ -0,0 +1,3 @@
+<resources>
+  <dimen name="fab_margin">48dp</dimen>
+</resources>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/values-night/themes.xml b/ranging/test_app/app/src/main/res/values-night/themes.xml
new file mode 100644
index 00000000..6a703ca4
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/values-night/themes.xml
@@ -0,0 +1,16 @@
+<resources xmlns:tools="http://schemas.android.com/tools">
+  <!-- Base application theme. -->
+  <style name="Base.Theme.RangingTestApp" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
+    <!-- Customize your dark theme here. -->
+    <!-- Customize your light theme here. -->
+    <item name="colorPrimary">@color/teal_200</item>
+    <item name="colorPrimaryVariant">@color/teal_700</item>
+    <item name="colorOnPrimary">@color/white</item>
+    <!-- Secondary brand color. -->
+    <item name="colorSecondary">@color/purple_200</item>
+    <item name="colorSecondaryVariant">@color/purple_700</item>
+    <item name="colorOnSecondary">@color/black</item>
+    <!-- Status bar color. -->
+    <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
+  </style>
+</resources>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/values-v23/themes.xml b/ranging/test_app/app/src/main/res/values-v23/themes.xml
new file mode 100644
index 00000000..fcd2a0ed
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/values-v23/themes.xml
@@ -0,0 +1,9 @@
+<resources xmlns:tools="http://schemas.android.com/tools">
+
+  <style name="Theme.RangingTestApp" parent="Base.Theme.RangingTestApp">
+    <!-- Transparent system bars for edge-to-edge. -->
+    <item name="android:navigationBarColor">@android:color/transparent</item>
+    <item name="android:statusBarColor">@android:color/transparent</item>
+    <item name="android:windowLightStatusBar">?attr/isLightTheme</item>
+  </style>
+</resources>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/values-w1240dp/dimens.xml b/ranging/test_app/app/src/main/res/values-w1240dp/dimens.xml
new file mode 100644
index 00000000..811ce9bf
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/values-w1240dp/dimens.xml
@@ -0,0 +1,3 @@
+<resources>
+  <dimen name="fab_margin">200dp</dimen>
+</resources>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/values-w600dp/dimens.xml b/ranging/test_app/app/src/main/res/values-w600dp/dimens.xml
new file mode 100644
index 00000000..855a4229
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/values-w600dp/dimens.xml
@@ -0,0 +1,3 @@
+<resources>
+  <dimen name="fab_margin">48dp</dimen>
+</resources>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/values/colors.xml b/ranging/test_app/app/src/main/res/values/colors.xml
new file mode 100644
index 00000000..e3878e1f
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/values/colors.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <color name="black">#FF000000</color>
+  <color name="white">#FFFFFFFF</color>
+  <color name="purple_200">#FFBB86FC</color>
+  <color name="purple_500">#FF6200EE</color>
+  <color name="purple_700">#FF3700B3</color>
+  <color name="teal_200">#FF03DAC5</color>
+  <color name="teal_700">#FF018786</color>
+</resources>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/values/dimens.xml b/ranging/test_app/app/src/main/res/values/dimens.xml
new file mode 100644
index 00000000..431e7d7e
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/values/dimens.xml
@@ -0,0 +1,3 @@
+<resources>
+  <dimen name="fab_margin">16dp</dimen>
+</resources>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/values/strings.xml b/ranging/test_app/app/src/main/res/values/strings.xml
new file mode 100644
index 00000000..ba0f2b52
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/values/strings.xml
@@ -0,0 +1,19 @@
+<resources>
+  <string name="app_name">RangingTestApp</string>
+  <string name="initiator">Initiator</string>
+  <string name="responder">Responder</string>
+  <string name="initiator_fragment_label">Initiator Fragment</string>
+  <string name="responder_fragment_label">Responder Fragment</string>
+  <string name="ble_central">BLE Central</string>
+  <string name="ble_peripheral">BLE Peripheral</string>
+  <string name="stop_measurement">Stop Distance Measurement</string>
+  <string name="start_measurement">Start Distance Measurement</string>
+  <string name="starting_measurement">Starting...</string>
+  <string name="stopping_measurement">Stopping...</string>
+  <string name="initiator_configuration">Initiator Config</string>
+  <string name="responder_configuration">Responder Config</string>
+  <string name="bond_title">Devices are not bonded</string>
+  <string name="bond_message">Devices should be bonded for Channel Sounding</string>
+  <string name="bond_create">Create bond</string>
+  <string name="bond_ignore">Ignore</string>
+</resources>
diff --git a/ranging/test_app/app/src/main/res/values/themes.xml b/ranging/test_app/app/src/main/res/values/themes.xml
new file mode 100644
index 00000000..36850088
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/values/themes.xml
@@ -0,0 +1,23 @@
+<resources xmlns:tools="http://schemas.android.com/tools">
+  <!-- Base application theme. -->
+  <style name="Base.Theme.RangingTestApp" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
+    <!-- Customize your light theme here. -->
+    <item name="colorPrimary">@color/purple_200</item>
+    <item name="colorPrimaryVariant">@color/purple_700</item>
+    <item name="colorOnPrimary">@color/white</item>
+    <!-- Secondary brand color. -->
+    <item name="colorSecondary">@color/teal_200</item>
+    <item name="colorSecondaryVariant">@color/teal_700</item>
+    <item name="colorOnSecondary">@color/black</item>
+    <!-- Status bar color. -->
+    <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
+  </style>
+
+  <style name="Theme.RangingTestApp" parent="Base.Theme.RangingTestApp" />
+  <style name="MaterialAlertDialog_rounded" parent="@style/ThemeOverlay.MaterialComponents.MaterialAlertDialog">
+    <item name="shapeAppearanceOverlay">@style/DialogCorners</item>
+  </style>
+  <style name="DialogCorners">
+    <item name="cornerFamily">rounded</item>
+  </style>
+</resources>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/xml/backup_rules.xml b/ranging/test_app/app/src/main/res/xml/backup_rules.xml
new file mode 100644
index 00000000..9b42d90d
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/xml/backup_rules.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample backup rules file; uncomment and customize as necessary.
+   See https://developer.android.com/guide/topics/data/autobackup
+   for details.
+   Note: This file is ignored for devices older that API 31
+   See https://developer.android.com/about/versions/12/backup-restore
+-->
+<full-backup-content>
+  <!--
+   <include domain="sharedpref" path="."/>
+   <exclude domain="sharedpref" path="device.xml"/>
+-->
+</full-backup-content>
\ No newline at end of file
diff --git a/ranging/test_app/app/src/main/res/xml/data_extraction_rules.xml b/ranging/test_app/app/src/main/res/xml/data_extraction_rules.xml
new file mode 100644
index 00000000..c6c3bb05
--- /dev/null
+++ b/ranging/test_app/app/src/main/res/xml/data_extraction_rules.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample data extraction rules file; uncomment and customize as necessary.
+   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
+   for details.
+-->
+<data-extraction-rules>
+  <cloud-backup>
+    <!-- TODO: Use <include> and <exclude> to control what is backed up.
+        <include .../>
+        <exclude .../>
+        -->
+  </cloud-backup>
+  <!--
+    <device-transfer>
+        <include .../>
+        <exclude .../>
+    </device-transfer>
+    -->
+</data-extraction-rules>
\ No newline at end of file
diff --git a/ranging/service/java/com/android/server/ranging/oob/OobHandler.java b/ranging/test_app/app/src/test/java/com/android/bluetooth/channelsoundingtestapp/ExampleUnitTest.java
similarity index 59%
rename from ranging/service/java/com/android/server/ranging/oob/OobHandler.java
rename to ranging/test_app/app/src/test/java/com/android/bluetooth/channelsoundingtestapp/ExampleUnitTest.java
index 3b0210f2..07f64527 100644
--- a/ranging/service/java/com/android/server/ranging/oob/OobHandler.java
+++ b/ranging/test_app/app/src/test/java/com/android/bluetooth/channelsoundingtestapp/ExampleUnitTest.java
@@ -14,16 +14,21 @@
  * limitations under the License.
  */
 
-package com.android.server.ranging.oob;
+package com.android.ranging.rangingtestapp;
 
-import android.ranging.oob.OobHandle;
+import static com.google.common.truth.Truth.assertThat;
 
-public interface OobHandler {
-    void handleOobMessage(OobHandle oobHandle, byte[] data);
+import org.junit.Test;
 
-    void handleOobDeviceDisconnected(OobHandle oobHandle);
-
-    void handleOobDeviceReconnected(OobHandle oobHandle);
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
 
-    void handleOobClosed(OobHandle oobHandle);
+    @Test
+    public void addition_isCorrect() {
+        assertThat(2 + 2).isEqualTo(4);
+    }
 }
diff --git a/ranging/test_app/build.gradle.kts b/ranging/test_app/build.gradle.kts
new file mode 100644
index 00000000..293a1d90
--- /dev/null
+++ b/ranging/test_app/build.gradle.kts
@@ -0,0 +1,4 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+plugins {
+  alias(libs.plugins.androidApplication) apply false
+}
\ No newline at end of file
diff --git a/ranging/test_app/com.android.ranging.rangingtestapp.key b/ranging/test_app/com.android.ranging.rangingtestapp.key
new file mode 100644
index 00000000..ed838134
--- /dev/null
+++ b/ranging/test_app/com.android.ranging.rangingtestapp.key
@@ -0,0 +1,52 @@
+-----BEGIN PRIVATE KEY-----
+MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQCyO5bLG/VcW/Ge
+/Z+ImpO8UOBn6TGH6eEN0InPhMs4jX9GKVWx5UR1ZDuNylfj1z5VMwlFRGd5N4m5
+Fb9oQCGRvRxoL2tMeVBxLlRna9xRTZJLXxrnlYi0c6hg0EB1INOYiddIWpHYja6U
+vgchUpCHhklLiRK2MJlp3aBLa2z/3XGnW66/6jIRjV3jpiIcxh2dc9Jb8x3hWF93
+Hc6rcTzLLzqhqnPzMrvkcbPp/6VuL9jSVeFtTNKIiGaek3/+eeoJpcp8FnowG5VR
+Z1fkEnXT4SlD+km+SBF3+x1kFbIaS+VLc95+di11+92dbQ6v7yQwaGMOyitMFqjX
++LPwMu52cDkWol20UAQWCa4dz2vkf4a4C/a1ZhbyyKG6zXqGu2rF3/wfBi8KQRNQ
+I1s8FE0vtkG91aV5syudUISs4JTp6dOi1bGPw/9e6No5oitPIf7ZKIdUzVe7fFqm
+fTC6ATvEsS1KvZg0/XNBj0Cuqkgef+ewlaZ6KMVr0I9whEbZLawL1rQeUwhkSvVx
+Nfqx1M0BNezNLH3mW/PIwSKICk4tWD0xNaLczNZLXlGocM0/7gaeiUBZT/+LIS6w
+fzXfJseVhor/ZlcteTrvjzCrdLqIPbebWxK9BerIBDvljxRdv4t5CbuKsyjxHPAZ
+W++spLIJm5c6I1bDMn16sRNghsNzZQIDAQABAoICABKMKPESA8KMvuQwuH1auK0M
+LY4iskjWidkKLo0t4IgOEYSXoJdWqH0e5SOoPuUy7QWovfo7WBlBMk/Ud4q9wcCM
+0Xv2E1Bt/3UHwTjR/KdpTyQQzZfz87nznz4T7eFCfUKOdZzN8Ad9FwHblJpfITM5
+Qj9eEFhtTkm6CohOsZUe0kj8PX8zO+qfr3mVPE+KPmK4PtfawO1GaQjYTT2CFzV9
+wLg6KL7SNMNdIb/kHq8Mw59/2GmraO1UZHl0GAm/Xh+K5Ttsi2KePDewbXEKisB1
+2fl8/leS4F5//1r+9v3NkBr9/9VhLvHsN++9/Z1JYZa4BjbvyvmsEf4Hn5ILes0j
+6nuFqe3nl/ArqOWBQPNjVhUMGFfZ0mGrTFBHW/UkJEGbYXl+25xLqE7lImy4GViU
+iLIdvFly7BD1Cro7iPakcyAn97VjopNulSb+rysbjVQgcf+BSwk4dhOc8GP9+52q
+Cso9TSEN2f61es6VToN4tgrx5FmpAjJNgCtjU8QgixZewVZc3PqffLzByZon72G1
+BKynTsoWxAiXEozEH7IzyAuwNQqqZhIB9PRSyvVRunZJfieSgKQkiPQmros/2Kka
+s2c/CfLr1xIJXbQax1pxmoxu3C9mmBaVLDjLS7uvPRrPIowk27eO1avSskZ3E2X5
+zvS+i9z1tER7UDmwCxUxAoIBAQDkM04yJgV52um+8gVwOPRw4KI3yfQHi9dX2AU1
+QZx4umP+k/cYQ9yjkgekSg+hZIWo8wxo2/S2LKAK8jPbyYojg8c04gNTSY3VS/Si
+wjFgS/l+YVZ3nl34RzMOjg7neJ1FBEpCoZumgVKwAI7vENLp2hAuzN3lSfYBHpSz
+9twsU0cEBMPKyZVyhoYFfLSPaWKbGgSkCDSsUEyvWMhD3fZbHtTkmgGvTIKMU7rh
+1QQvgUkSmfAnP7EQwGHSIFWx4+BL9BNl0b5HkUjKl7pS1Zi6PMgxTkDMRNjgwVFr
+lWsOMEdbfFFAhI1OwbtYQsUK+lZs6xvtUMY240Ptrr4CMIajAoIBAQDH8fwVUwad
+fINkXqkIUnHF7DB5Ij9C1SYJtoGn+pXf1w32T8ygs6fcsa9K6qqgoESh55fPCmnW
+zUubUVYZi3rl7TBYS4TOtAzKkAMW5wWhjQx97PCMSDXlZbp9DKMNw+sAVnxZDciG
+IHUfdNKzquEC2koR5LzxztFCz5FcIXacxyragOqXInMWnjSqn3lidbnELKiNb3xT
+XnD+AEIm9xv7YfJNtDctIDdTwe8Rxjr3vCMEElODbhKgFH5vuR/QVQhvHy6TUdxI
+j3SaRA3K1F+jH5wBp7juJMOMeed89qc1J8RdastDM3bHOm3qhaw96HVGz5tgfflS
+CnEJL0uSqKZXAoIBAQDUosXrTqhtmkGSLhxJLJkBER+20lS0L2byMJTxwfhWOn/w
+eNmW360ZMXozaNtVrMAq5IacstA8bCqY6ITP+OTiIOmfajZlBjXGGaeTfVXbABAz
+5elXPtcbAOUfW9mhcC9DXzL/EW1i4kA1Rd/p/Yg6ZXoM0dK104wKEP/JDW6tUs/q
+e7IhJGNAOv9o34Gz3CQImF7YpdjG82/xN84sBwiGcZ04ghStzqIate5+fioPRe3c
+ClrPh7arAEhmLsELKGYZAA6PIrimIUdtl6IDi4prhzWXU+5nKIPaMeh3UdxWdUAY
+jCd98cVmLHkwTc8jYo7joNP99vUrsera76eXjLX3AoIBAQCm2W8T2Gnfx8TZYAjM
+MghRMqysmQCTY81PM6Z0p66j0REMp0DKJcGBcCEocjUav0MmnF1ZX4Y8wqpCHRit
+TnCrKEg8liBoYWV/L7f0R6qySkLPXobJeYTIPiDmM0JpvUEA0isIIXFhQ/qY2mLt
+nT4RpFlFH0zwuDZ1+0KA0EfrwmQnXIbmwc+qYzDt5RBlMnpnkyDAjfUAmQHPZCXP
+4EvQdca+QxH8LTMeSOqYOYSBsNTDlAtu1M7kGNX9o01CC4NzP2EdfKVHQ7b4+KtN
+w/Ve6YTE+NJgn/sy4ZNj+2xC9kFt9y1RkcOfs0l/+DZonvAmvB4b4mPIq3/yOy5k
+XyoXAoIBAE2L5DjmT+Hr3CBOdzBF5sZ3m1X1tuqk0fWNxA6biN6FC8H7lG780RUt
+0ojI01ortmGlV+uLto7JHDSMPsdUvM8tPnBoUBh3HlKpS1GIs7bfV7hw0r47bYHY
+YvABhkpeGJ2utNgMqmrtZkBWJNaJKdGD7UQJHa126r+5VDlRaVyiif2wPK7QmieF
+JsDLrmnbutflu0erQcpQhw3fQm5c7OQurWU3ubXW14p44G93Ixzx8XT9/ENwJoWN
+rLnIyEUNDklaYO2gFsAgHBf4ra7/wyjCdb0ZnkfqHLi/ru8HtNI6FYKota+pqi92
+6+Xkq3S3hFIlZ6gJQYZL8ol+WxSmqpg=
+-----END PRIVATE KEY-----
diff --git a/ranging/test_app/com.android.ranging.rangingtestapp.keystore b/ranging/test_app/com.android.ranging.rangingtestapp.keystore
new file mode 100644
index 00000000..c3793177
Binary files /dev/null and b/ranging/test_app/com.android.ranging.rangingtestapp.keystore differ
diff --git a/ranging/test_app/com.android.ranging.rangingtestapp.pem b/ranging/test_app/com.android.ranging.rangingtestapp.pem
new file mode 100644
index 00000000..4a8620e8
Binary files /dev/null and b/ranging/test_app/com.android.ranging.rangingtestapp.pem differ
diff --git a/ranging/test_app/com.android.ranging.rangingtestapp.pk8 b/ranging/test_app/com.android.ranging.rangingtestapp.pk8
new file mode 100644
index 00000000..66d8fa8e
Binary files /dev/null and b/ranging/test_app/com.android.ranging.rangingtestapp.pk8 differ
diff --git a/ranging/test_app/com.android.ranging.rangingtestapp.x509.pem b/ranging/test_app/com.android.ranging.rangingtestapp.x509.pem
new file mode 100644
index 00000000..6e6d6eff
--- /dev/null
+++ b/ranging/test_app/com.android.ranging.rangingtestapp.x509.pem
@@ -0,0 +1,34 @@
+-----BEGIN CERTIFICATE-----
+MIIF9TCCA92gAwIBAgIUEwiHmhAWr2yOnXaGUpwn4xbMM/swDQYJKoZIhvcNAQEL
+BQAwgYgxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMQ8w
+DQYDVQQKDAZHb29nbGUxEDAOBgNVBAsMB0FuZHJvaWQxFzAVBgNVBAMMDlJhbmdp
+bmdUZXN0QXBwMSIwIAYJKoZIhvcNAQkBFhNhbmRyb2lkQGFuZHJvaWQuY29tMCAX
+DTI1MDEwMjIxNTkwNFoYDzQ3NjIxMTI5MjE1OTA0WjCBiDELMAkGA1UEBhMCVVMx
+CzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxDzANBgNVBAoMBkdvb2dsZTEQMA4G
+A1UECwwHQW5kcm9pZDEXMBUGA1UEAwwOUmFuZ2luZ1Rlc3RBcHAxIjAgBgkqhkiG
+9w0BCQEWE2FuZHJvaWRAYW5kcm9pZC5jb20wggIiMA0GCSqGSIb3DQEBAQUAA4IC
+DwAwggIKAoICAQCyO5bLG/VcW/Ge/Z+ImpO8UOBn6TGH6eEN0InPhMs4jX9GKVWx
+5UR1ZDuNylfj1z5VMwlFRGd5N4m5Fb9oQCGRvRxoL2tMeVBxLlRna9xRTZJLXxrn
+lYi0c6hg0EB1INOYiddIWpHYja6UvgchUpCHhklLiRK2MJlp3aBLa2z/3XGnW66/
+6jIRjV3jpiIcxh2dc9Jb8x3hWF93Hc6rcTzLLzqhqnPzMrvkcbPp/6VuL9jSVeFt
+TNKIiGaek3/+eeoJpcp8FnowG5VRZ1fkEnXT4SlD+km+SBF3+x1kFbIaS+VLc95+
+di11+92dbQ6v7yQwaGMOyitMFqjX+LPwMu52cDkWol20UAQWCa4dz2vkf4a4C/a1
+ZhbyyKG6zXqGu2rF3/wfBi8KQRNQI1s8FE0vtkG91aV5syudUISs4JTp6dOi1bGP
+w/9e6No5oitPIf7ZKIdUzVe7fFqmfTC6ATvEsS1KvZg0/XNBj0Cuqkgef+ewlaZ6
+KMVr0I9whEbZLawL1rQeUwhkSvVxNfqx1M0BNezNLH3mW/PIwSKICk4tWD0xNaLc
+zNZLXlGocM0/7gaeiUBZT/+LIS6wfzXfJseVhor/ZlcteTrvjzCrdLqIPbebWxK9
+BerIBDvljxRdv4t5CbuKsyjxHPAZW++spLIJm5c6I1bDMn16sRNghsNzZQIDAQAB
+o1MwUTAdBgNVHQ4EFgQUqY7wPiv5arTme/aSUkk/etr86X8wHwYDVR0jBBgwFoAU
+qY7wPiv5arTme/aSUkk/etr86X8wDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0B
+AQsFAAOCAgEAa339mezgJHJ8XKPbSaXJx61A5rIz8qcDlujkZ12W88MYN9HZwRUS
+Xe/lSYlBtEgFxnb2hfmccp8Uki8O+Th+gh6Tn+2N3VED9WxTTX64FWw7nRRWfDX5
+KTFr2mCJF6iEdx1OumA66V3pbgY3BDVyB11Hmm2793W3U+bwtVCeEBrM2+9YrAKP
+mvy6XIgiqNxeQ9lJ/iJelZrhr4x4u9d1PUq9nl+NkZmYNsmCAzn3Wvpdl2WOV6ER
+ERbqa94CXaWSUklxhy7uT9cMhHLCnfuxnkppzGryOBmJQki0EbhlGLlDDh1VphqK
+3b+Lo23JnTkvf83PtAQb1Lj0J9TPF6IGsxQqiNeNbvnBfd7ZM92brbah5KEXbsH6
+zKkd/We6HxfZ8QO+msDbvcA7KlR5+ZHSRci+2UXSwhlov58hU8sD4bArvV9o+XeK
+I45TvWBsemy62KxL96CVVYhlgy5C6phlGRFOpUzQ8y6Qe70AqEmDHzCp/LPFylpd
+4yD8/AF7vGf/hhlOmgDa6jJBM0yclvEVYKgiFWEdsxtg61b8Y9n0FFy7xzc6Bnfl
+LHwIdSE9fh+grug9K5MAZRCjkx4G0hVgY+K1jpFHReq8xkZt2bQp+qCByLq+Ak0W
+XQ3lfxvD6X2V+CgG1A25xB8I0KHl7ujE9GMbV5smZCWCGnclOa7e9CA=
+-----END CERTIFICATE-----
diff --git a/ranging/test_app/gradle.properties b/ranging/test_app/gradle.properties
new file mode 100644
index 00000000..4387edc2
--- /dev/null
+++ b/ranging/test_app/gradle.properties
@@ -0,0 +1,21 @@
+# Project-wide Gradle settings.
+# IDE (e.g. Android Studio) users:
+# Gradle settings configured through the IDE *will override*
+# any settings specified in this file.
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. For more details, visit
+# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
+# org.gradle.parallel=true
+# AndroidX package structure to make it clearer which packages are bundled with the
+# Android operating system, and which are packaged with your app's APK
+# https://developer.android.com/topic/libraries/support-library/androidx-rn
+android.useAndroidX=true
+# Enables namespacing of each library's R class so that its R class includes only the
+# resources declared in the library itself and none from the library's dependencies,
+# thereby reducing the size of the R class for that library
+android.nonTransitiveRClass=true
\ No newline at end of file
diff --git a/ranging/test_app/gradle/libs.versions.toml b/ranging/test_app/gradle/libs.versions.toml
new file mode 100644
index 00000000..adeb0edc
--- /dev/null
+++ b/ranging/test_app/gradle/libs.versions.toml
@@ -0,0 +1,30 @@
+[versions]
+agp = "8.7.3"
+junit = "4.13.2"
+junitVersion = "1.1.5"
+espressoCore = "3.5.1"
+appcompat = "1.6.1"
+material = "1.11.0"
+constraintlayout = "2.1.4"
+navigationFragment = "2.7.7"
+navigationUi = "2.7.7"
+legacySupportV4 = "1.0.0"
+lifecycleLivedataKtx = "2.7.0"
+lifecycleViewmodelKtx = "2.7.0"
+
+[libraries]
+junit = { group = "junit", name = "junit", version.ref = "junit" }
+ext-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
+espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
+appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
+material = { group = "com.google.android.material", name = "material", version.ref = "material" }
+constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }
+navigation-fragment = { group = "androidx.navigation", name = "navigation-fragment", version.ref = "navigationFragment" }
+navigation-ui = { group = "androidx.navigation", name = "navigation-ui", version.ref = "navigationUi" }
+legacy-support-v4 = { group = "androidx.legacy", name = "legacy-support-v4", version.ref = "legacySupportV4" }
+lifecycle-livedata-ktx = { group = "androidx.lifecycle", name = "lifecycle-livedata-ktx", version.ref = "lifecycleLivedataKtx" }
+lifecycle-viewmodel-ktx = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-ktx", version.ref = "lifecycleViewmodelKtx" }
+
+[plugins]
+androidApplication = { id = "com.android.application", version.ref = "agp" }
+
diff --git a/ranging/test_app/gradle/wrapper/gradle-wrapper.jar b/ranging/test_app/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..e708b1c0
Binary files /dev/null and b/ranging/test_app/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/ranging/test_app/gradle/wrapper/gradle-wrapper.properties b/ranging/test_app/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..c19b3f14
--- /dev/null
+++ b/ranging/test_app/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Mon Apr 22 19:05:34 UTC 2024
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-bin.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/ranging/test_app/gradlew b/ranging/test_app/gradlew
new file mode 100755
index 00000000..4f906e0c
--- /dev/null
+++ b/ranging/test_app/gradlew
@@ -0,0 +1,185 @@
+#!/usr/bin/env sh
+
+#
+# Copyright 2015 the original author or authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=`expr $i + 1`
+    done
+    case $i in
+        0) set -- ;;
+        1) set -- "$args0" ;;
+        2) set -- "$args0" "$args1" ;;
+        3) set -- "$args0" "$args1" "$args2" ;;
+        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=`save "$@"`
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+exec "$JAVACMD" "$@"
diff --git a/ranging/test_app/gradlew.bat b/ranging/test_app/gradlew.bat
new file mode 100644
index 00000000..ac1b06f9
--- /dev/null
+++ b/ranging/test_app/gradlew.bat
@@ -0,0 +1,89 @@
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/ranging/test_app/local.properties b/ranging/test_app/local.properties
new file mode 100644
index 00000000..937f07c7
--- /dev/null
+++ b/ranging/test_app/local.properties
@@ -0,0 +1,8 @@
+## This file must *NOT* be checked into Version Control Systems,
+# as it contains information specific to your local configuration.
+#
+# Location of the SDK. This is only used by Gradle.
+# For customization when using a Version Control System, please read the
+# header note.
+#Thu Dec 26 14:57:07 PST 2024
+sdk.dir=/usr/local/google/home/rpius/Android/Sdk
diff --git a/ranging/test_app/settings.gradle.kts b/ranging/test_app/settings.gradle.kts
new file mode 100644
index 00000000..4a98afbd
--- /dev/null
+++ b/ranging/test_app/settings.gradle.kts
@@ -0,0 +1,23 @@
+pluginManagement {
+  repositories {
+    google {
+      content {
+        includeGroupByRegex("com\\.android.*")
+        includeGroupByRegex("com\\.google.*")
+        includeGroupByRegex("androidx.*")
+      }
+    }
+    mavenCentral()
+    gradlePluginPortal()
+  }
+}
+dependencyResolutionManagement {
+  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
+  repositories {
+    google()
+    mavenCentral()
+  }
+}
+
+rootProject.name = "RangingTestApp"
+include(":app")
diff --git a/ranging/tests/cts/tests/Android.bp b/ranging/tests/cts/tests/Android.bp
index d2efc433..deb34816 100644
--- a/ranging/tests/cts/tests/Android.bp
+++ b/ranging/tests/cts/tests/Android.bp
@@ -47,7 +47,6 @@ custom_android_test {
         "cts",
         "general-tests",
         "mts-uwb",
-        "mcts-uwb",
     ],
     libs: ["android.test.runner.stubs.system"],
     static_libs: [
@@ -67,5 +66,5 @@ custom_android_test {
     srcs: ["src/**/*.java"],
     platform_apis: true,
     sdk_version: "module_current",
-    min_sdk_version: "35",
+    target_sdk_version: "36",
 }
diff --git a/ranging/tests/cts/tests/AndroidTest.xml b/ranging/tests/cts/tests/AndroidTest.xml
index 5d5892fc..7cd0792c 100644
--- a/ranging/tests/cts/tests/AndroidTest.xml
+++ b/ranging/tests/cts/tests/AndroidTest.xml
@@ -26,10 +26,18 @@
         <option name="cleanup-apks" value="true" />
         <option name="test-file-name" value="CtsRangingTestCases.apk" />
     </target_preparer>
+    <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
+        <option name="throw-if-cmd-fail" value="true" />
+        <!-- Disable ble services to allow Bluetooth to go full OFF vs BLE_ON -->
+        <option name="run-command" value="settings put system nearby_scanning_enabled 0"/>
+        <option name="run-command" value="settings put system spen_air_action 0"/>
+        <option name="run-command" value="settings put global ble_scan_always_enabled 0"/>
+    </target_preparer>
     <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
         <option name="package" value="android.ranging.cts" />
     </test>
     <object type="module_controller" class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
         <option name="mainline-module-package-name" value="com.google.android.uwb" />
     </object>
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk36ModuleController" />
 </configuration>
\ No newline at end of file
diff --git a/ranging/tests/cts/tests/src/android/ranging/cts/RangingManagerTest.java b/ranging/tests/cts/tests/src/android/ranging/cts/RangingManagerTest.java
index 2d1a3631..f59d49e1 100644
--- a/ranging/tests/cts/tests/src/android/ranging/cts/RangingManagerTest.java
+++ b/ranging/tests/cts/tests/src/android/ranging/cts/RangingManagerTest.java
@@ -16,26 +16,42 @@
 
 package android.ranging.cts;
 
+import static android.ranging.DataNotificationConfig.NOTIFICATION_CONFIG_PROXIMITY_LEVEL;
+import static android.ranging.RangingCapabilities.ENABLED;
+import static android.ranging.RangingCapabilities.NOT_SUPPORTED;
+import static android.ranging.RangingConfig.RANGING_SESSION_OOB;
+import static android.ranging.RangingConfig.RANGING_SESSION_RAW;
 import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
 import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+import static android.ranging.ble.cs.BleCsRangingCapabilities.CS_SECURITY_LEVEL_ONE;
+import static android.ranging.ble.cs.BleCsRangingParams.LOCATION_TYPE_INDOOR;
+import static android.ranging.ble.cs.BleCsRangingParams.SIGHT_TYPE_LINE_OF_SIGHT;
+import static android.ranging.oob.OobInitiatorRangingConfig.RANGING_MODE_FUSED;
+import static android.ranging.oob.OobInitiatorRangingConfig.SECURITY_LEVEL_BASIC;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
 import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
-import static android.ranging.uwb.UwbRangingParams.CONFIG_UNICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_MULTICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_PROVISIONED_MULTICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.DURATION_2_MS;
 import static android.uwb.UwbManager.AdapterStateCallback.STATE_ENABLED_INACTIVE;
 
 import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeTrue;
 
+import android.annotation.SuppressLint;
 import android.app.UiAutomation;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.test_utils.BlockingBluetoothAdapter;
 import android.content.BroadcastReceiver;
 import android.content.Context;
+import android.content.ContextParams;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
@@ -45,6 +61,7 @@ import android.net.wifi.WifiManager;
 import android.net.wifi.aware.WifiAwareManager;
 import android.platform.test.annotations.AppModeFull;
 import android.platform.test.annotations.RequiresFlagsEnabled;
+import android.ranging.DataNotificationConfig;
 import android.ranging.RangingCapabilities;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
@@ -53,17 +70,25 @@ import android.ranging.RangingManager.RangingCapabilitiesCallback;
 import android.ranging.RangingPreference;
 import android.ranging.RangingSession;
 import android.ranging.SensorFusionParams;
-import android.ranging.SessionConfiguration;
-import android.ranging.ble.cs.CsRangingParams;
+import android.ranging.SessionConfig;
+import android.ranging.ble.cs.BleCsRangingCapabilities;
+import android.ranging.ble.cs.BleCsRangingParams;
 import android.ranging.ble.rssi.BleRssiRangingParams;
-import android.ranging.raw.RawInitiatorRangingParams;
+import android.ranging.oob.DeviceHandle;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.oob.OobResponderRangingConfig;
+import android.ranging.oob.TransportHandle;
+import android.ranging.raw.RawInitiatorRangingConfig;
 import android.ranging.raw.RawRangingDevice;
-import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.raw.RawResponderRangingConfig;
 import android.ranging.uwb.UwbAddress;
 import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingCapabilities;
 import android.ranging.uwb.UwbRangingParams;
+import android.ranging.wifi.rtt.RttRangingCapabilities;
 import android.ranging.wifi.rtt.RttRangingParams;
 import android.util.Log;
+import android.util.Range;
 import android.uwb.UwbManager;
 
 import androidx.annotation.NonNull;
@@ -81,9 +106,14 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.time.Duration;
+import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
+import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
@@ -100,23 +130,35 @@ public class RangingManagerTest {
     @Before
     public void setup() throws Exception {
         assumeTrue(Flags.rangingStackEnabled());
-        mRangingManager = mContext.getSystemService(RangingManager.class);
-        assertThat(mRangingManager).isNotNull();
         PackageManager packageManager = mContext.getPackageManager();
         assertThat(packageManager).isNotNull();
-        if (packageManager.hasSystemFeature(PackageManager.FEATURE_UWB)) {
+        mRangingManager = mContext.getSystemService(RangingManager.class);
+        assertThat(mRangingManager).isNotNull();
+        CapabilitiesCallback callback = new CapabilitiesCallback(new CountDownLatch(1));
+        mRangingManager.registerCapabilitiesCallback(Executors.newSingleThreadExecutor(),
+                callback);
+
+        assertThat(callback.mCountDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnCapabilitiesReceived).isTrue();
+        assertThat(callback.mRangingCapabilities).isNotNull();
+
+        if (callback.mRangingCapabilities.getTechnologyAvailability().get(RangingManager.UWB)
+                != NOT_SUPPORTED) {
             mSupportedTechnologies.add(RangingManager.UWB);
         }
-        if (packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE)) {
+        if (callback.mRangingCapabilities.getTechnologyAvailability().get(
+                RangingManager.WIFI_NAN_RTT) != NOT_SUPPORTED) {
             mSupportedTechnologies.add(RangingManager.WIFI_NAN_RTT);
         }
-        if (packageManager.hasSystemFeature(
-                PackageManager.FEATURE_BLUETOOTH_LE_CHANNEL_SOUNDING)) {
+        if (callback.mRangingCapabilities.getTechnologyAvailability().get(RangingManager.BLE_CS)
+                != NOT_SUPPORTED) {
             mSupportedTechnologies.add(RangingManager.BLE_CS);
         }
-        if (packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+        if (callback.mRangingCapabilities.getTechnologyAvailability().get(RangingManager.BLE_RSSI)
+                != NOT_SUPPORTED) {
             mSupportedTechnologies.add(RangingManager.BLE_RSSI);
         }
+        assumeTrue(!mSupportedTechnologies.isEmpty());
     }
 
     @After
@@ -126,6 +168,7 @@ public class RangingManagerTest {
         uiAutomation.dropShellPermissionIdentity();
     }
 
+    @SuppressLint({"CheckResult", "CheckReturnValue"})
     private void enableUwb() {
         UwbManager uwbManager = mContext.getSystemService(UwbManager.class);
         UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
@@ -144,24 +187,10 @@ public class RangingManagerTest {
                 try {
                     uwbManager.setUwbEnabled(true);
                     assertThat(countDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
-                    assertThat(uwbManager.isUwbEnabled()).isEqualTo(true);
-                    assertThat(adapterStateCallback.state).isEqualTo(adapterState);
-                } finally {
-                    uwbManager.unregisterAdapterStateCallback(adapterStateCallback);
-                }
-            }
-            if (uwbManager.isUwbHwIdleTurnOffEnabled()) {
-                // If HW idle mode is turned on, vote for the UWB hardware for tests to pass.
-                CountDownLatch countDownLatch = new CountDownLatch(1);
-                int adapterState = STATE_ENABLED_INACTIVE;
-                AdapterStateCallback adapterStateCallback =
-                        new AdapterStateCallback(countDownLatch, adapterState);
-                try {
-                    uwbManager.registerAdapterStateCallback(
-                            Executors.newSingleThreadExecutor(), adapterStateCallback);
-                    uwbManager.requestUwbHwEnabled(true);
-                    assertThat(countDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
-                    assertThat(adapterStateCallback.state).isEqualTo(adapterState);
+                    if (!uwbManager.isUwbHwIdleTurnOffEnabled()) {
+                        assertThat(uwbManager.isUwbEnabled()).isEqualTo(true);
+                        assertThat(adapterStateCallback.state).isEqualTo(adapterState);
+                    }
                 } finally {
                     uwbManager.unregisterAdapterStateCallback(adapterStateCallback);
                 }
@@ -215,26 +244,38 @@ public class RangingManagerTest {
         assertThat(BlockingBluetoothAdapter.enable()).isTrue();
     }
 
-    private RangingPreference getGenericRangingPreference(int deviceRole) {
+    private UwbRangingParams getUwbRangingParams(int sessionId, int deviceRole,
+            byte[] peerAddress) {
+        return new UwbRangingParams.Builder(sessionId,
+                CONFIG_MULTICAST_DS_TWR,
+                UwbAddress.createRandomShortAddress(),
+                UwbAddress.fromBytes(peerAddress))
+                .setComplexChannel(
+                        new UwbComplexChannel.Builder().setChannel(
+                                9).setPreambleIndex(11).build())
+                .setSessionKeyInfo(
+                        new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
+                                2, 1})
+                .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                .setSlotDuration(DURATION_2_MS)
+                .build();
+    }
+
+    private RangingPreference getGenericUwbRangingPreference(int sessionId) {
         // Generic ranging preference, Improve this method based on future needs.
-        return new RangingPreference.Builder(deviceRole,
-                new RawInitiatorRangingParams.Builder()
+        return new RangingPreference.Builder(RangingPreference.DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingConfig.Builder()
                         .addRawRangingDevice(new RawRangingDevice.Builder()
                                 .setRangingDevice(new RangingDevice.Builder().build())
-                                .setUwbRangingParams(new UwbRangingParams.Builder(10,
-                                        CONFIG_UNICAST_DS_TWR,
-                                        UwbAddress.fromBytes(new byte[]{1, 2}),
-                                        UwbAddress.fromBytes(new byte[]{3, 4}))
-                                        .setComplexChannel(
-                                                new UwbComplexChannel.Builder().setChannel(
-                                                        9).setPreambleIndex(11).build())
-                                        .setSessionKeyInfo(
-                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
-                                                        2, 1})
-                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
-                                        .build())
+                                .setUwbRangingParams(
+                                        getUwbRangingParams(sessionId,
+                                                RangingPreference.DEVICE_ROLE_INITIATOR,
+                                                new byte[]{3, 4}))
                                 .build())
                         .build())
+                .setSessionConfig(new SessionConfig.Builder()
+                        .setRangingMeasurementsLimit(100)
+                        .build())
                 .build();
     }
 
@@ -248,7 +289,7 @@ public class RangingManagerTest {
                 MoreExecutors.directExecutor(), callback);
         assertThat(rangingSession).isNotNull();
 
-        RangingPreference preference = getGenericRangingPreference(DEVICE_ROLE_INITIATOR);
+        RangingPreference preference = getGenericUwbRangingPreference(10);
 
         try {
             rangingSession.start(preference);
@@ -280,10 +321,82 @@ public class RangingManagerTest {
             Log.i(TAG, "Failed with expected security exception: " + e);
         }
     }
+
+    private void testUwbRangingSessionInternal(RangingManager rangingManager) throws Exception {
+        int sessionId = 10;
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+
+        RangingSession rangingSession = rangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingConfig.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setUwbRangingParams(getUwbRangingParams(
+                                        sessionId, DEVICE_ROLE_INITIATOR,
+                                        new byte[]{3, 4}))
+                                .build())
+                        .build())
+                .setSessionConfig(new SessionConfig.Builder()
+                        .setRangingMeasurementsLimit(1000)
+                        .setAngleOfArrivalNeeded(true)
+                        .setSensorFusionParams(
+                                new SensorFusionParams.Builder()
+                                        .setSensorFusionEnabled(false)
+                                        .build())
+                        .setDataNotificationConfig(new DataNotificationConfig.Builder()
+                                .setNotificationConfigType(NOTIFICATION_CONFIG_PROXIMITY_LEVEL)
+                                .setProximityNearCm(100)
+                                .setProximityFarCm(200)
+                                .build())
+                        .build())
+                .build();
+
+        assertEquals(preference.getRangingParams().getRangingSessionType(), RANGING_SESSION_RAW);
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(4, TimeUnit.SECONDS)).isTrue();
+
+        rangingSession.close();
+        assertThat(callback.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
     @Test
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
     @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
     public void testUwbRangingSession() throws Exception {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB));
+        enableUwb();
+        testUwbRangingSessionInternal(mRangingManager);
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testUwbRangingSession_withHwIdleOff() throws Exception {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB));
+        enableUwb();
+        Context contextWithTag = mContext.createContext(
+                new ContextParams.Builder()
+                        .setAttributionTag("Custom_cts_tag")
+                        .build()
+        );
+        RangingManager rangingManager = contextWithTag.getSystemService(RangingManager.class);
+        assertThat(rangingManager).isNotNull();
+        testUwbRangingSessionInternal(rangingManager);
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testUwbProvisionedStsRangingSession() throws Exception {
         assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB));
         enableUwb();
         int sessionId = 10;
@@ -297,35 +410,33 @@ public class RangingManagerTest {
         assertThat(rangingSession).isNotNull();
 
         RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
-                new RawInitiatorRangingParams.Builder()
+                new RawInitiatorRangingConfig.Builder()
                         .addRawRangingDevice(new RawRangingDevice.Builder()
                                 .setRangingDevice(new RangingDevice.Builder().build())
                                 .setUwbRangingParams(new UwbRangingParams.Builder(
-                                        sessionId, CONFIG_UNICAST_DS_TWR,
-                                        UwbAddress.fromBytes(new byte[]{1, 2}),
-                                        UwbAddress.fromBytes(new byte[]{3, 4}))
+                                        sessionId, CONFIG_PROVISIONED_MULTICAST_DS_TWR,
+                                        UwbAddress.createRandomShortAddress(),
+                                        UwbAddress.createRandomShortAddress())
                                         .setComplexChannel(
                                                 new UwbComplexChannel.Builder().setChannel(
                                                         9).setPreambleIndex(11).build())
-                                        .setSessionKeyInfo(
-                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
-                                                        2, 1})
-                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
-                                        .build())
+                                        .setSubSessionId(50)
+                                        .setSessionKeyInfo(new byte[]{
+                                                0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8,
+                                                0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8
+                                        })
+                                        .setSubSessionKeyInfo(new byte[]{
+                                                0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8,
+                                                0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8
+                                        }).build())
                                 .build())
                         .build())
-                .setSessionConfiguration(new SessionConfiguration.Builder()
-                        .setRangingMeasurementsLimit(1000)
-                        .setAngleOfArrivalNeeded(true)
-                        .setSensorFusionParameters(
-                                new SensorFusionParams.Builder()
-                                        .setSensorFusionEnabled(false)
-                                        .build())
-                        .build())
                 .build();
 
+        assertEquals(preference.getRangingParams().getRangingSessionType(), RANGING_SESSION_RAW);
+
         rangingSession.start(preference);
-        assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnOpenedCalled.await(4, TimeUnit.SECONDS)).isTrue();
 
         rangingSession.stop();
         assertThat(callback.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
@@ -333,6 +444,82 @@ public class RangingManagerTest {
         uiAutomation.dropShellPermissionIdentity();
     }
 
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testRawAddRemoverPeer() throws Exception {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB));
+        enableUwb();
+        int sessionId = 10;
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        RangingPreference preference = getGenericUwbRangingPreference(sessionId
+        );
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(4, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnPeerAdded.await(2, TimeUnit.SECONDS)).isTrue();
+        RangingDevice device = new RangingDevice.Builder().build();
+        RawResponderRangingConfig peerParams = new RawResponderRangingConfig.Builder()
+                .setRawRangingDevice(
+                        new RawRangingDevice.Builder()
+                                .setRangingDevice(device)
+                                .setUwbRangingParams(getUwbRangingParams(sessionId,
+                                        DEVICE_ROLE_RESPONDER, new byte[]{5, 6}))
+                                .build())
+                .build();
+
+        callback.replaceOnPeerAddedLatch(new CountDownLatch(1));
+        rangingSession.addDeviceToRangingSession(peerParams);
+        assertThat(callback.mOnPeerAdded.await(2, TimeUnit.SECONDS)).isTrue();
+
+        // Intentional sleep here so that there are few ranging rounds with newly added controlee
+        // before removing it.
+        Thread.sleep(1000);
+
+        callback.replaceOnPeerRemovedLatch(new CountDownLatch(1));
+        rangingSession.removeDeviceFromRangingSession(device);
+        assertThat(callback.mOnPeerRemoved.await(4, TimeUnit.SECONDS)).isTrue();
+
+        rangingSession.stop();
+        assertThat(callback.mOnClosedCalled.await(3, TimeUnit.SECONDS)).isTrue();
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testRawReconfigureRangingInterval() throws Exception {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB));
+        enableUwb();
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        RangingPreference preference = getGenericUwbRangingPreference(10);
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(4, TimeUnit.SECONDS)).isTrue();
+        rangingSession.reconfigureRangingInterval(3);
+        rangingSession.stop();
+        assertThat(callback.mOnClosedCalled.await(3, TimeUnit.SECONDS)).isTrue();
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
     @Test
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
     @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
@@ -355,41 +542,23 @@ public class RangingManagerTest {
                 MoreExecutors.directExecutor(), callback2);
         assertThat(rangingSession2).isNotNull();
         RangingPreference preference1 = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
-                new RawInitiatorRangingParams.Builder()
+                new RawInitiatorRangingConfig.Builder()
                         .addRawRangingDevice(new RawRangingDevice.Builder()
                                 .setRangingDevice(new RangingDevice.Builder().build())
-                                .setUwbRangingParams(new UwbRangingParams.Builder(sessionId1,
-                                        CONFIG_UNICAST_DS_TWR,
-                                        UwbAddress.fromBytes(new byte[]{1, 2}),
-                                        UwbAddress.fromBytes(new byte[]{3, 4}))
-                                        .setComplexChannel(
-                                                new UwbComplexChannel.Builder().setChannel(
-                                                        9).setPreambleIndex(11).build())
-                                        .setSessionKeyInfo(
-                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
-                                                        2, 1})
-                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
-                                        .build())
+                                .setUwbRangingParams(getUwbRangingParams(sessionId1,
+                                        DEVICE_ROLE_INITIATOR, new byte[]{3, 4}))
                                 .build())
                         .build())
                 .build();
 
         RangingPreference preference2 = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
-                new RawInitiatorRangingParams.Builder()
+                new RawInitiatorRangingConfig.Builder()
                         .addRawRangingDevice(new RawRangingDevice.Builder()
-                                .setRangingDevice(new RangingDevice.Builder().build())
-                                .setUwbRangingParams(new UwbRangingParams.Builder(sessionId2,
-                                        CONFIG_UNICAST_DS_TWR,
-                                        UwbAddress.fromBytes(new byte[]{3, 5}),
-                                        UwbAddress.fromBytes(new byte[]{1, 2}))
-                                        .setComplexChannel(
-                                                new UwbComplexChannel.Builder().setChannel(
-                                                        9).setPreambleIndex(11).build())
-                                        .setSessionKeyInfo(
-                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
-                                                        2, 1})
-                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                .setRangingDevice(new RangingDevice.Builder()
+                                        .setUuid(UUID.randomUUID())
                                         .build())
+                                .setUwbRangingParams(getUwbRangingParams(sessionId2,
+                                        DEVICE_ROLE_INITIATOR, new byte[]{3, 4}))
                                 .build())
                         .build())
                 .build();
@@ -397,8 +566,8 @@ public class RangingManagerTest {
         rangingSession1.start(preference1);
         rangingSession2.start(preference2);
 
-        assertThat(callback1.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
-        assertThat(callback2.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback1.mOnOpenedCalled.await(4, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback2.mOnOpenedCalled.await(4, TimeUnit.SECONDS)).isTrue();
 
         rangingSession1.stop();
         rangingSession2.stop();
@@ -412,7 +581,22 @@ public class RangingManagerTest {
     private static class RangingSessionCallback implements RangingSession.Callback {
 
         private final CountDownLatch mOnOpenedCalled = new CountDownLatch(1);
-        private final CountDownLatch mOnClosedCalled = new CountDownLatch(1);
+        private CountDownLatch mOnClosedCalled = new CountDownLatch(1);
+        private CountDownLatch mOnPeerAdded = new CountDownLatch(1);
+        private CountDownLatch mOnPeerRemoved = new CountDownLatch(1);
+        private CountDownLatch mOnOpenFailed = new CountDownLatch(1);
+
+        public void replaceOnPeerAddedLatch(CountDownLatch countDownLatch) {
+            mOnPeerAdded = countDownLatch;
+        }
+
+        public void replaceOnPeerRemovedLatch(CountDownLatch countDownLatch) {
+            mOnPeerRemoved = countDownLatch;
+        }
+
+        public void replaceOnClosedCalled(CountDownLatch countDownLatch) {
+            mOnClosedCalled = countDownLatch;
+        }
 
         @Override
         public void onOpened() {
@@ -421,11 +605,13 @@ public class RangingManagerTest {
 
         @Override
         public void onOpenFailed(int reason) {
+            mOnOpenFailed.countDown();
         }
 
         @Override
         public void onStarted(@NonNull RangingDevice peer,
                 @RangingManager.RangingTechnology int technology) {
+            mOnPeerAdded.countDown();
         }
 
         @Override
@@ -435,6 +621,7 @@ public class RangingManagerTest {
         @Override
         public void onStopped(@NonNull RangingDevice peer,
                 @RangingManager.RangingTechnology int technology) {
+            mOnPeerRemoved.countDown();
         }
 
         @Override
@@ -448,6 +635,7 @@ public class RangingManagerTest {
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
     @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
     public void testCapabilitiesListener() throws InterruptedException {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB));
         UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
         uiAutomation.adoptShellPermissionIdentity();
 
@@ -461,9 +649,11 @@ public class RangingManagerTest {
 
         callback.reset(new CountDownLatch(1));
         UwbManager uwbManager = mContext.getSystemService(UwbManager.class);
+        // This test is not suitable if hw idle is enabled
+        assumeTrue(!uwbManager.isUwbHwIdleTurnOffEnabled());
         uwbManager.setUwbEnabled(!uwbManager.isUwbEnabled());
 
-        assertThat(callback.mCountDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mCountDownLatch.await(4, TimeUnit.SECONDS)).isTrue();
         assertThat(callback.mOnCapabilitiesReceived).isTrue();
         assertThat(callback.mRangingCapabilities).isNotNull();
 
@@ -476,6 +666,70 @@ public class RangingManagerTest {
         uiAutomation.dropShellPermissionIdentity();
     }
 
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testAllCapabilities() throws InterruptedException {
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        if (mSupportedTechnologies.contains(RangingManager.UWB)) {
+            enableUwb();
+        }
+        if (mSupportedTechnologies.contains(RangingManager.BLE_RSSI)) {
+            enableBluetooth();
+        }
+        if (mSupportedTechnologies.contains(RangingManager.WIFI_NAN_RTT)) {
+            enableWifiNanRtt();
+        }
+
+        CapabilitiesCallback callback = new CapabilitiesCallback(new CountDownLatch(1));
+        mRangingManager.registerCapabilitiesCallback(Executors.newSingleThreadExecutor(),
+                callback);
+
+        assertThat(callback.mCountDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnCapabilitiesReceived).isTrue();
+        assertThat(callback.mRangingCapabilities).isNotNull();
+
+        if (callback.mRangingCapabilities.getTechnologyAvailability().get(RangingManager.UWB)
+                == ENABLED) {
+            UwbRangingCapabilities uwbRangingCapabilities =
+                    callback.mRangingCapabilities.getUwbCapabilities();
+            assertThat(uwbRangingCapabilities).isNotNull();
+            assertThat(uwbRangingCapabilities.getSupportedChannels()).isNotNull();
+            assertThat(uwbRangingCapabilities.getMinimumRangingInterval()).isNotNull();
+            assertThat(uwbRangingCapabilities.getSupportedPreambleIndexes()).isNotNull();
+            assertThat(uwbRangingCapabilities.getSupportedNotificationConfigurations()).isNotNull();
+            assertThat(uwbRangingCapabilities.getSupportedConfigIds()).isNotNull();
+            assertThat(uwbRangingCapabilities.getSupportedSlotDurations()).isNotNull();
+            assertThat(uwbRangingCapabilities.getSupportedRangingUpdateRates()).isNotNull();
+            assertTrue(uwbRangingCapabilities.isDistanceMeasurementSupported());
+
+            boolean unused = uwbRangingCapabilities.isAzimuthalAngleSupported();
+            unused = uwbRangingCapabilities.isElevationAngleSupported();
+            unused = uwbRangingCapabilities.isRangingIntervalReconfigurationSupported();
+            unused = uwbRangingCapabilities.isBackgroundRangingSupported();
+        }
+
+        if (callback.mRangingCapabilities.getTechnologyAvailability().get(RangingManager.BLE_CS)
+                == ENABLED) {
+            BleCsRangingCapabilities csRangingCapabilities =
+                    callback.mRangingCapabilities.getCsCapabilities();
+            assertThat(csRangingCapabilities.getSupportedSecurityLevels()).isNotNull();
+        }
+
+        if (callback.mRangingCapabilities.getTechnologyAvailability().get(
+                RangingManager.WIFI_NAN_RTT) == ENABLED) {
+            RttRangingCapabilities rttRangingCapabilities =
+                    callback.mRangingCapabilities.getRttRangingCapabilities();
+            boolean unused = rttRangingCapabilities.hasPeriodicRangingHardwareFeature();
+        }
+
+        mRangingManager.unregisterCapabilitiesCallback(callback);
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
     @Test
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
     @RequiresFlagsEnabled("com.android.ranging.flags.ranging_rtt_enabled")
@@ -496,16 +750,82 @@ public class RangingManagerTest {
                 capabilitiesCallback.mRangingCapabilities.getTechnologyAvailability())
                 .isNotNull();
 
+        List<RawRangingDevice> rawRangingDevices = new ArrayList<>();
+        rawRangingDevices.add(new RawRangingDevice.Builder()
+                .setRangingDevice(new RangingDevice.Builder().build())
+                .setRttRangingParams(new RttRangingParams.Builder("test_rtt_initiator_1").build())
+                .build());
+        rawRangingDevices.add(new RawRangingDevice.Builder()
+                .setRangingDevice(new RangingDevice.Builder().build())
+                .setRttRangingParams(new RttRangingParams.Builder("test_rtt_initiator_2").build())
+                .build());
+
         RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
-                new RawInitiatorRangingParams.Builder()
-                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                new RawInitiatorRangingConfig.Builder()
+                        .addRawRangingDevices(rawRangingDevices)
+                        .build())
+                .build();
+
+        RawInitiatorRangingConfig config = (RawInitiatorRangingConfig)
+                preference.getRangingParams();
+        RawRangingDevice rawRangingDevice = config.getRawRangingDevices().getFirst();
+        assertThat(rawRangingDevice).isNotNull();
+        assertThat(rawRangingDevice.getRangingDevice()).isNotNull();
+
+        RttRangingParams params = rawRangingDevice.getRttRangingParams();
+        assertThat(params).isNotNull();
+        assertThat(params.getServiceName()).isNotNull();
+        assertThat(params.getMatchFilter()).isNull();
+        assertEquals(params.getRangingUpdateRate(), UPDATE_RATE_NORMAL);
+        boolean unused = params.isPeriodicRangingHwFeatureEnabled();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        // OnOpened can be successful for test_rtt_1 and not be successful yet for test_rtt_2,
+        // calling stop before it was initialized will result in not getting onClosed. So, sleep for
+        // 1 second here.
+        Thread.sleep(1000);
+        rangingSession.stop();
+        assertThat(callback.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        // Intentional sleep for NAN interface to clean up.
+        Thread.sleep(1000);
+
+        mRangingManager.unregisterCapabilitiesCallback(capabilitiesCallback);
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_rtt_enabled")
+    public void testRttRangingResponder() throws InterruptedException {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.WIFI_NAN_RTT));
+        enableWifiNanRtt();
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+        CapabilitiesCallback capabilitiesCallback = new CapabilitiesCallback(new CountDownLatch(1));
+        mRangingManager.registerCapabilitiesCallback(Executors.newSingleThreadExecutor(),
+                capabilitiesCallback);
+
+        assertThat(capabilitiesCallback.mCountDownLatch.await(3, TimeUnit.SECONDS)).isTrue();
+        assertThat(capabilitiesCallback.mOnCapabilitiesReceived).isTrue();
+        assertThat(capabilitiesCallback.mRangingCapabilities).isNotNull();
+        assertThat(
+                capabilitiesCallback.mRangingCapabilities.getTechnologyAvailability())
+                .isNotNull();
+
+        RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_RESPONDER,
+                new RawResponderRangingConfig.Builder()
+                        .setRawRangingDevice(new RawRangingDevice.Builder()
                                 .setRangingDevice(new RangingDevice.Builder().build())
                                 .setRttRangingParams(new RttRangingParams.Builder("test_rtt_1")
-                                        .build())
-                                .build())
-                        .addRawRangingDevice(new RawRangingDevice.Builder()
-                                .setRangingDevice(new RangingDevice.Builder().build())
-                                .setRttRangingParams(new RttRangingParams.Builder("test_rtt_2")
+                                        .setMatchFilter(new byte[]{})
                                         .build())
                                 .build())
                         .build())
@@ -517,9 +837,12 @@ public class RangingManagerTest {
         assertThat(rangingSession).isNotNull();
 
         rangingSession.start(preference);
-        assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnOpenedCalled.await(2, TimeUnit.SECONDS)).isTrue();
         rangingSession.stop();
-        assertThat(callback.mOnClosedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        // Intentional sleep for NAN interface to clean up.
+        Thread.sleep(1000);
 
         mRangingManager.unregisterCapabilitiesCallback(capabilitiesCallback);
         uiAutomation.dropShellPermissionIdentity();
@@ -528,7 +851,7 @@ public class RangingManagerTest {
     @Test
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
     @RequiresFlagsEnabled("com.android.ranging.flags.ranging_rtt_enabled")
-    public void testRttRangingResponder() throws InterruptedException {
+    public void testRttRangingResponder_WithMeasurementLimit() throws InterruptedException {
         assumeTrue(mSupportedTechnologies.contains(RangingManager.WIFI_NAN_RTT));
         enableWifiNanRtt();
         UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
@@ -545,13 +868,16 @@ public class RangingManagerTest {
                 .isNotNull();
 
         RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_RESPONDER,
-                new RawResponderRangingParams.Builder()
+                new RawResponderRangingConfig.Builder()
                         .setRawRangingDevice(new RawRangingDevice.Builder()
                                 .setRangingDevice(new RangingDevice.Builder().build())
                                 .setRttRangingParams(new RttRangingParams.Builder("test_rtt_1")
+                                        .setRangingUpdateRate(UPDATE_RATE_FREQUENT)
                                         .build())
                                 .build())
                         .build())
+                .setSessionConfig(
+                        new SessionConfig.Builder().setRangingMeasurementsLimit(6).build())
                 .build();
 
         RangingSessionCallback callback = new RangingSessionCallback();
@@ -561,8 +887,9 @@ public class RangingManagerTest {
 
         rangingSession.start(preference);
         assertThat(callback.mOnOpenedCalled.await(2, TimeUnit.SECONDS)).isTrue();
-        rangingSession.stop();
-        assertThat(callback.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        // Session should close after measurement limit.
+        assertThat(callback.mOnClosedCalled.await(4, TimeUnit.SECONDS)).isTrue();
 
         mRangingManager.unregisterCapabilitiesCallback(capabilitiesCallback);
         uiAutomation.dropShellPermissionIdentity();
@@ -591,23 +918,13 @@ public class RangingManagerTest {
                 .isNotNull();
 
         RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_RESPONDER,
-                new RawResponderRangingParams.Builder()
+                new RawResponderRangingConfig.Builder()
                         .setRawRangingDevice(new RawRangingDevice.Builder()
                                 .setRangingDevice(new RangingDevice.Builder().build())
                                 .setRttRangingParams(new RttRangingParams.Builder("test_rtt_multi")
                                         .build())
-                                .setUwbRangingParams(new UwbRangingParams.Builder(
-                                        sessionId, CONFIG_UNICAST_DS_TWR,
-                                        UwbAddress.fromBytes(new byte[]{3, 5}),
-                                        UwbAddress.fromBytes(new byte[]{1, 2}))
-                                        .setComplexChannel(
-                                                new UwbComplexChannel.Builder().setChannel(
-                                                        9).setPreambleIndex(11).build())
-                                        .setSessionKeyInfo(
-                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
-                                                        2, 1})
-                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
-                                        .build())
+                                .setUwbRangingParams(getUwbRangingParams(sessionId,
+                                        DEVICE_ROLE_INITIATOR, new byte[]{3, 4}))
                                 .build())
                         .build())
                 .build();
@@ -618,8 +935,12 @@ public class RangingManagerTest {
         assertThat(rangingSession).isNotNull();
 
         rangingSession.start(preference);
-        assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnOpenedCalled.await(2, TimeUnit.SECONDS)).isTrue();
 
+        // OnOpened can be successful for uwb and not be successful yet for rtt session,
+        // calling stop before it was initialized will result in not getting onClosed. So, sleep for
+        // 1 second here.
+        Thread.sleep(1000);
         rangingSession.stop();
         assertThat(callback.mOnClosedCalled.await(4, TimeUnit.SECONDS)).isTrue();
 
@@ -643,24 +964,34 @@ public class RangingManagerTest {
         assertThat(rangingSession).isNotNull();
 
         RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
-                new RawInitiatorRangingParams.Builder()
+                new RawInitiatorRangingConfig.Builder()
                         .addRawRangingDevice(new RawRangingDevice.Builder()
                                 .setRangingDevice(new RangingDevice.Builder().build())
                                 .setBleRssiRangingParams(
                                         new BleRssiRangingParams.Builder("00:11:22:33:AA:BB")
+                                                .setRangingUpdateRate(UPDATE_RATE_NORMAL)
                                                 .build())
                                 .build())
                         .build())
-                .setSessionConfiguration(new SessionConfiguration.Builder()
+                .setSessionConfig(new SessionConfig.Builder()
                         .setRangingMeasurementsLimit(1000)
                         .setAngleOfArrivalNeeded(true)
-                        .setSensorFusionParameters(
+                        .setSensorFusionParams(
                                 new SensorFusionParams.Builder()
                                         .setSensorFusionEnabled(false)
                                         .build())
                         .build())
                 .build();
 
+        assertThat(preference.getRangingParams() instanceof RawInitiatorRangingConfig).isTrue();
+        RawInitiatorRangingConfig config =
+                (RawInitiatorRangingConfig) preference.getRangingParams();
+        RawRangingDevice device = config.getRawRangingDevices().get(0);
+        assertThat(device.getBleRssiRangingParams()).isNotNull();
+        assertThat(device.getBleRssiRangingParams().getPeerBluetoothAddress()).isNotNull();
+        assertThat(device.getBleRssiRangingParams().getRangingUpdateRate()).isEqualTo(
+                UPDATE_RATE_NORMAL);
+
         rangingSession.start(preference);
         assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
 
@@ -670,6 +1001,50 @@ public class RangingManagerTest {
         uiAutomation.dropShellPermissionIdentity();
     }
 
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testBleRssiRangingSession_whenDisabled() throws Exception {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.BLE_RSSI));
+        BluetoothAdapter adapter = BlockingBluetoothAdapter.getAdapter();
+        assertThat(adapter).isNotNull();
+        assertThat(BlockingBluetoothAdapter.disable(true)).isTrue();
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingConfig.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setBleRssiRangingParams(
+                                        new BleRssiRangingParams.Builder("00:11:22:33:AA:BB")
+                                                .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                                .build())
+                                .build())
+                        .build())
+                .build();
+
+        assertThat(preference.getRangingParams() instanceof RawInitiatorRangingConfig).isTrue();
+        RawInitiatorRangingConfig config =
+                (RawInitiatorRangingConfig) preference.getRangingParams();
+        RawRangingDevice device = config.getRawRangingDevices().get(0);
+        assertThat(device.getBleRssiRangingParams()).isNotNull();
+        assertThat(device.getBleRssiRangingParams().getPeerBluetoothAddress()).isNotNull();
+        assertThat(device.getBleRssiRangingParams().getRangingUpdateRate()).isEqualTo(
+                UPDATE_RATE_NORMAL);
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenFailed.await(1, TimeUnit.SECONDS)).isTrue();
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
     @Test
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
     @RequiresFlagsEnabled("com.android.ranging.flags.ranging_cs_enabled")
@@ -686,24 +1061,44 @@ public class RangingManagerTest {
         assertThat(rangingSession).isNotNull();
 
         RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
-                new RawInitiatorRangingParams.Builder()
+                new RawInitiatorRangingConfig.Builder()
                         .addRawRangingDevice(new RawRangingDevice.Builder()
                                 .setRangingDevice(new RangingDevice.Builder().build())
                                 .setCsRangingParams(new
-                                        CsRangingParams.Builder("00:11:22:33:AA:BB")
+                                        BleCsRangingParams.Builder("00:11:22:33:AA:BB")
+                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                        .setLocationType(LOCATION_TYPE_INDOOR)
+                                        .setSecurityLevel(CS_SECURITY_LEVEL_ONE)
+                                        .setSightType(SIGHT_TYPE_LINE_OF_SIGHT)
                                         .build())
                                 .build())
                         .build())
-                .setSessionConfiguration(new SessionConfiguration.Builder()
+                .setSessionConfig(new SessionConfig.Builder()
                         .setRangingMeasurementsLimit(1000)
                         .setAngleOfArrivalNeeded(true)
-                        .setSensorFusionParameters(
+                        .setSensorFusionParams(
                                 new SensorFusionParams.Builder()
                                         .setSensorFusionEnabled(false)
                                         .build())
                         .build())
                 .build();
 
+
+        RawInitiatorRangingConfig config = (RawInitiatorRangingConfig)
+                preference.getRangingParams();
+        RawRangingDevice rawRangingDevice = config.getRawRangingDevices().getFirst();
+        assertThat(rawRangingDevice).isNotNull();
+        assertThat(rawRangingDevice.getRangingDevice()).isNotNull();
+
+        BleCsRangingParams params = rawRangingDevice.getCsRangingParams();
+        assertThat(params).isNotNull();
+        assertThat(params.getPeerBluetoothAddress()).isNotNull();
+        assertEquals(params.getRangingUpdateRate(), UPDATE_RATE_NORMAL);
+        assertEquals(params.getLocationType(), LOCATION_TYPE_INDOOR);
+        assertEquals(params.getSecurityLevel(), CS_SECURITY_LEVEL_ONE);
+        assertEquals(params.getSightType(), SIGHT_TYPE_LINE_OF_SIGHT);
+
+
         rangingSession.start(preference);
         assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
 
@@ -713,6 +1108,85 @@ public class RangingManagerTest {
         uiAutomation.dropShellPermissionIdentity();
     }
 
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testStartOobInitiatorRangingSession() throws InterruptedException {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB)
+                || mSupportedTechnologies.contains(RangingManager.BLE_CS));
+
+        if (mSupportedTechnologies.contains(RangingManager.BLE_CS)) {
+            enableBluetooth();
+        }
+
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        RangingSession session = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), new RangingSessionCallback());
+        assertThat(session).isNotNull();
+
+        OobTransport oobTransport = new OobTransport();
+
+        List<DeviceHandle> deviceHandles = List.of(
+                new DeviceHandle.Builder(
+                        new RangingDevice.Builder().build(), oobTransport).build(),
+                new DeviceHandle.Builder(
+                        new RangingDevice.Builder().build(), oobTransport).build(),
+                new DeviceHandle.Builder(
+                        new RangingDevice.Builder().build(), oobTransport).build());
+
+        OobInitiatorRangingConfig config = new OobInitiatorRangingConfig.Builder()
+                .setFastestRangingInterval(Duration.ofMillis(100))
+                .setSlowestRangingInterval(Duration.ofMillis(5000))
+                .setRangingMode(RANGING_MODE_FUSED)
+                .setSecurityLevel(SECURITY_LEVEL_BASIC)
+                .addDeviceHandle(deviceHandles.get(0))
+                .addDeviceHandles(deviceHandles.subList(1, deviceHandles.size()))
+                .build();
+
+        assertEquals(Duration.ofMillis(100), config.getFastestRangingInterval());
+        assertEquals(Duration.ofMillis(5000), config.getSlowestRangingInterval());
+        assertEquals(Range.create(Duration.ofMillis(100), Duration.ofMillis(5000)),
+                config.getRangingIntervalRange());
+        assertEquals(RANGING_MODE_FUSED, config.getRangingMode());
+        assertEquals(SECURITY_LEVEL_BASIC, config.getSecurityLevel());
+        assertThat(
+                config.getDeviceHandles().stream().map(DeviceHandle::getRangingDevice)
+        ).containsExactlyElementsIn(
+                deviceHandles.stream().map(DeviceHandle::getRangingDevice).toList()
+        );
+
+        RangingPreference preference =
+                new RangingPreference.Builder(DEVICE_ROLE_INITIATOR, config).build();
+
+        assertEquals(RANGING_SESSION_OOB, preference.getRangingParams().getRangingSessionType());
+
+        session.start(preference);
+        assertThat(oobTransport.mSendDataCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        session.stop();
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testConfigureOobResponderRangingSession() {
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        OobTransport oobTransport = new OobTransport();
+
+        DeviceHandle handle = new DeviceHandle.Builder(
+                new RangingDevice.Builder().build(), oobTransport).build();
+
+        OobResponderRangingConfig config = new OobResponderRangingConfig.Builder(handle).build();
+
+        assertEquals(handle.getRangingDevice(), config.getDeviceHandle().getRangingDevice());
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
 
     private static class CapabilitiesCallback implements RangingCapabilitiesCallback {
 
@@ -790,4 +1264,23 @@ public class RangingManagerTest {
         }
     }
 
+    private static class OobTransport implements TransportHandle {
+        private final CountDownLatch mSendDataCalled = new CountDownLatch(1);
+
+        @Override
+        public void sendData(@NonNull byte[] data) {
+            mSendDataCalled.countDown();
+        }
+
+        @Override
+        public void registerReceiveCallback(
+                @NonNull Executor executor, @NonNull ReceiveCallback callback
+        ) {
+        }
+
+        @Override
+        public void close() throws Exception {
+        }
+    }
+
 }
diff --git a/ranging/tests/multidevices/Android.bp b/ranging/tests/multidevices/Android.bp
index 23f69e9e..c4bef2b5 100644
--- a/ranging/tests/multidevices/Android.bp
+++ b/ranging/tests/multidevices/Android.bp
@@ -21,16 +21,14 @@ python_defaults {
     name: "RangingMultiDevicePythonDefaults",
     libs: [
         "mobly",
+        "platform-test-py-annotations",
     ],
     test_suites: [
-        //"cts",
+        "cts",
         "general-tests",
+        "mts-uwb",
+        "mcts-uwb",
     ],
-    version: {
-        py3: {
-            embedded_launcher: true,
-        },
-    },
 }
 
 python_test_host {
@@ -53,3 +51,29 @@ python_test_host {
     ],
     defaults: ["RangingMultiDevicePythonDefaults"],
 }
+
+// Modules for CTS-Verifier (cts-v-host)
+python_test_host {
+    name: "CtsMultiDeviceGenericRangingTests",
+    main: "RangingManagerTests/ranging_manager_tests.py",
+    srcs: [
+        "RangingManagerTests/ranging_manager_tests.py",
+        "lib/*.py",
+    ],
+    test_suites: [
+        "cts-v-host",
+    ],
+    test_config: "RangingManagerTests/AndroidTestV2.xml",
+    test_options: {
+        runner: "mobly",
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":bluetooth_multi_devices_snippet",
+        ":ranging_snippet",
+        ":uwb_snippet",
+        "README.md",
+    ],
+    defaults: ["RangingMultiDevicePythonDefaults"],
+}
diff --git a/ranging/tests/multidevices/RangingManagerTests/AndroidTest.xml b/ranging/tests/multidevices/RangingManagerTests/AndroidTest.xml
index ef2fa25f..5ea3469e 100644
--- a/ranging/tests/multidevices/RangingManagerTests/AndroidTest.xml
+++ b/ranging/tests/multidevices/RangingManagerTests/AndroidTest.xml
@@ -22,6 +22,10 @@
     <option name="config-descriptor:metadata" key="parameter" value="not_secondary_user" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.uwb.apex" />
 
+    <!-- Do not run the tests on automotive variant-->
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.DeviceFeatureModuleController">
+        <option name="forbidden-feature" value="android.hardware.type.automotive"/>
+    </object>
 
     <device name="device1">
         <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
@@ -37,6 +41,13 @@
             <option name="run-command" value="input keyevent KEYCODE_WAKEUP" />
             <option name="run-command" value="wm dismiss-keyguard" />
         </target_preparer>
+        <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
+            <option name="throw-if-cmd-fail" value="true" />
+            <!-- Disable ble services to allow Bluetooth to go full OFF vs BLE_ON -->
+            <option name="run-command" value="settings put system nearby_scanning_enabled 0"/>
+            <option name="run-command" value="settings put system spen_air_action 0"/>
+            <option name="run-command" value="settings put global ble_scan_always_enabled 0"/>
+        </target_preparer>
     </device>
     <device name="device2">
         <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
@@ -52,6 +63,13 @@
             <option name="run-command" value="input keyevent KEYCODE_WAKEUP" />
             <option name="run-command" value="wm dismiss-keyguard" />
         </target_preparer>
+        <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
+            <option name="throw-if-cmd-fail" value="true" />
+            <!-- Disable ble services to allow Bluetooth to go full OFF vs BLE_ON -->
+            <option name="run-command" value="settings put system nearby_scanning_enabled 0"/>
+            <option name="run-command" value="settings put system spen_air_action 0"/>
+            <option name="run-command" value="settings put global ble_scan_always_enabled 0"/>
+        </target_preparer>
     </device>
 
     <test class="com.android.tradefed.testtype.mobly.MoblyBinaryHostTest">
diff --git a/ranging/tests/multidevices/RangingManagerTests/AndroidTestV2.xml b/ranging/tests/multidevices/RangingManagerTests/AndroidTestV2.xml
new file mode 100644
index 00000000..e6733293
--- /dev/null
+++ b/ranging/tests/multidevices/RangingManagerTests/AndroidTestV2.xml
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<configuration description="CTS UWB multi-device tests for Ranging APIs.">
+    <option name="test-suite-tag" value="cts-v-host" />
+    <option name="config-descriptor:metadata" key="component" value="uwb" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_instant_app" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_secondary_user" />
+    <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.uwb.apex" />
+
+    <device name="AndroidDevice">
+        <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+            <option name="required_feature" value="android.hardware.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidMainlineModulesCheckDecorator">
+            <option name="mainline_module_package_name" value="com.google.android.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidInstallAppsDecorator" />
+    </device>
+    <device name="AndroidDevice">
+        <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+            <option name="required_feature" value="android.hardware.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidMainlineModulesCheckDecorator">
+            <option name="mainline_module_package_name" value="com.google.android.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidInstallAppsDecorator" />
+    </device>
+
+    <test class="MoblyAospPackageTest" />
+
+    <option name="mobly_pkg" key="file" value="CtsMultiDeviceGenericRangingTests" />
+    <option name="build_apk" key="file" value="ranging_snippet.apk" />
+    <option name="build_apk" key="file" value="uwb_snippet.apk" />
+    <option name="build_apk" key="file" value="bluetooth_multi_devices_snippet.apk" />
+</configuration>
diff --git a/ranging/tests/multidevices/RangingManagerTests/ranging_manager_tests.py b/ranging/tests/multidevices/RangingManagerTests/ranging_manager_tests.py
index 4f431962..1c93dbc0 100644
--- a/ranging/tests/multidevices/RangingManagerTests/ranging_manager_tests.py
+++ b/ranging/tests/multidevices/RangingManagerTests/ranging_manager_tests.py
@@ -11,8 +11,11 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
+
+import random
 import sys
 import time
+import logging
 from typing import Set
 from lib import cs
 from lib import ranging_base_test
@@ -20,21 +23,35 @@ from lib import rssi
 from lib import rtt
 from lib import utils
 from lib import uwb
+from lib.session import RangingSession
 from lib.params import *
 from lib.ranging_decorator import *
 from mobly import asserts
 from mobly import config_parser
+from mobly import signals
 from mobly import suite_runner
+from mobly.controllers import android_device
+from android.platform.test.annotations import ApiTest
 
 
-_TEST_CASES = (
-    "test_one_to_one_uwb_ranging",
-    "test_one_to_one_uwb_ranging_provisioned_sts",
+_TEST_CASES = [
+    "test_one_to_one_uwb_ranging_unicast_static_sts",
+    "test_one_to_one_uwb_ranging_multicast_provisioned_sts",
+    "test_one_to_one_uwb_ranging_unicast_provisioned_sts",
     "test_one_to_one_uwb_ranging_disable_range_data_ntf",
-    "test_one_to_one_rtt_ranging",
+    "test_one_to_one_wifi_rtt_ranging",
+    "test_one_to_one_wifi_periodic_rtt_ranging",
     "test_one_to_one_ble_rssi_ranging",
     "test_one_to_one_ble_cs_ranging",
-)
+    "test_one_to_one_uwb_ranging_with_oob",
+    "test_one_to_one_ble_cs_ranging_with_oob",
+    "test_uwb_ranging_measurement_limit",
+    "test_ble_rssi_ranging_measurement_limit",
+    "test_one_to_one_wifi_rtt_ranging_with_oob",
+    "test_one_to_one_ble_rssi_ranging_with_oob",
+    "test_oob_responder_persists_until_explicitly_stopped",
+]
+
 
 SERVICE_UUID = "0000fffb-0000-1000-8000-00805f9b34fc"
 
@@ -56,22 +73,45 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
     super().__init__(configs)
     self.tests = _TEST_CASES
 
+  def _is_cuttlefish_device(self, ad: android_device.AndroidDevice) -> bool:
+    product_name = ad.adb.getprop("ro.product.name")
+    return "cf_x86" in product_name
+
   def setup_class(self):
     super().setup_class()
     self.devices = [RangingDecorator(ad) for ad in self.android_devices]
     self.initiator, self.responder = self.devices
 
+    for device in self.devices:
+      utils.set_airplane_mode(device.ad, state=False)
+      time.sleep(1)
+      if device.is_ranging_technology_supported(RangingTechnology.UWB):
+        utils.initialize_uwb_country_code(device.ad)
+        utils.request_hw_idle_vote(device.ad, True)
+
     self.initiator.uwb_address = [1, 2]
     self.responder.uwb_address = [3, 4]
 
+  def teardown_class(self):
+      super().teardown_class()
+      for device in self.devices:
+        if device.is_ranging_technology_supported(RangingTechnology.UWB):
+            utils.request_hw_idle_vote(device.ad, False)
+        if device.is_ranging_technology_supported(RangingTechnology.WIFI_RTT):
+            utils.set_wifi_state_and_verify(device.ad, True)
+        if device.is_ranging_technology_supported(RangingTechnology.BLE_CS) or \
+            device.is_ranging_technology_supported(RangingTechnology.BLE_RSSI):
+            utils.set_bt_state_and_verify(device.ad, True)
+
   def setup_test(self):
     super().setup_test()
     for device in self.devices:
-      utils.set_airplane_mode(device.ad, state=False)
       if device.is_ranging_technology_supported(RangingTechnology.UWB):
         utils.set_uwb_state_and_verify(device.ad, state=True)
-      utils.set_snippet_foreground_state(device.ad, isForeground=True)
+        utils.set_snippet_foreground_state(device.ad, isForeground=True)
       utils.set_screen_state(device.ad, on=True)
+    self.initiator.bt_addr = None
+    self.responder.bt_addr = None
 
   def teardown_test(self):
     super().teardown_test()
@@ -118,10 +158,21 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
             f"Responder did not find initiator",
         )
 
-  def _reset_bt_state(self):
-    utils.reset_bt_state(self.initiator.ad)
-    utils.reset_bt_state(self.responder.ad)
+  def _enable_bt(self):
+    utils.set_bt_state_and_verify(self.initiator.ad, True)
+    utils.set_bt_state_and_verify(self.responder.ad, True)
+
+  def _disable_bt(self):
+    utils.set_bt_state_and_verify(self.initiator.ad, False)
+    utils.set_bt_state_and_verify(self.responder.ad, False)
+
+  def _reset_wifi_state(self):
+    utils.reset_wifi_state(self.initiator.ad)
+    utils.reset_wifi_state(self.responder.ad)
 
+  def _disable_wifi(self):
+      utils.set_wifi_state_and_verify(self.initiator.ad, False)
+      utils.set_wifi_state_and_verify(self.responder.ad, False)
 
   def _ble_connect(self):
     """Create BLE GATT connection between initiator and responder.
@@ -132,15 +183,13 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
     # Connect to the advertisement
     self.responder.bt_addr = self.initiator.ad.bluetooth.connectGatt(SERVICE_UUID)
     asserts.assert_true(self.responder.bt_addr, "Server not connected")
-    # Check the target UUID is present
-    asserts.assert_true(self.initiator.ad.bluetooth.containsService(SERVICE_UUID), "Service not found")
     connected_devices = self.responder.ad.bluetooth.getConnectedDevices()
     asserts.assert_true(connected_devices, "No clients found connected to server")
     self.initiator.bt_addr = connected_devices[0]
 
   def _ble_disconnect(self):
-    asserts.assert_true(
-        self.initiator.ad.bluetooth.connectGatt(SERVICE_UUID), "Server not disconnected")
+    if self.responder.bt_addr and self.initiator.ad.bluetooth.disconnectGatt(SERVICE_UUID) is False:
+            logging.error("Server did not disconnect %s", self.initiator.bt_addr)
 
   def _ble_bond(self):
     """Create BLE GATT connection and bonding between initiator and responder.
@@ -152,25 +201,128 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
     asserts.assert_true(oob_data, "OOB data not generated")
     # Connect to the advertisement using OOB data generated on responder.
     self.responder.bt_addr = self.initiator.ad.bluetooth.createBondOob(SERVICE_UUID, oob_data)
-    # Check the target UUID is present
-    asserts.assert_true(self.initiator.ad.bluetooth.containsService(SERVICE_UUID), "Service not found")
     asserts.assert_true(self.responder.bt_addr, "Server not bonded")
     connected_devices = self.responder.ad.bluetooth.getConnectedDevices()
     asserts.assert_true(connected_devices, "No clients found connected to server")
     self.initiator.bt_addr = connected_devices[0]
 
   def _ble_unbond(self):
-    asserts.assert_true(
-        self.initiator.ad.bluetooth.removeBond(SERVICE_UUID), "Server not unbonded")
+    if self.responder.bt_addr and self.initiator.ad.bluetooth.removeBond(self.responder.bt_addr) is False:
+        logging.error("Server not unbonded %s", self.responder.bt_addr)
+    if self.initiator.bt_addr and self.responder.ad.bluetooth.removeBond(self.initiator.bt_addr) is False:
+        logging.error("Client not unbonded %s", self.initiator.bt_addr)
 
   ### Test Cases ###
 
-  def test_one_to_one_uwb_ranging(self):
-    """Verifies uwb ranging with peer device, devices range for 10 seconds."""
+  def _test_one_to_one_uwb_ranging(self, config_id: int):
+      """Verifies uwb ranging with peer device, devices range for 10 seconds."""
+      SESSION_HANDLE = str(uuid4())
+      UWB_SESSION_ID = 5
+      TECHNOLOGIES = {RangingTechnology.UWB}
+
+      asserts.skip_if(
+          not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
+          f"UWB not supported by responder",
+      )
+      asserts.skip_if(
+          not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
+          f"UWB not supported by initiator",
+      )
+
+      initiator_preference = RangingPreference(
+          device_role=DeviceRole.INITIATOR,
+          ranging_params=RawInitiatorRangingParams(
+              peer_params=[
+                  DeviceParams(
+                      peer_id=self.responder.id,
+                      uwb_params=uwb.UwbRangingParams(
+                          session_id=UWB_SESSION_ID,
+                          config_id=uwb.ConfigId.UNICAST_DS_TWR,
+                          device_address=self.initiator.uwb_address,
+                          peer_address=self.responder.uwb_address,
+                      ),
+                  )
+              ],
+          ),
+      )
+
+      responder_preference = RangingPreference(
+          device_role=DeviceRole.RESPONDER,
+          ranging_params=RawResponderRangingParams(
+              peer_params=DeviceParams(
+                  peer_id=self.initiator.id,
+                  uwb_params=uwb.UwbRangingParams(
+                      session_id=UWB_SESSION_ID,
+                      config_id=uwb.ConfigId.UNICAST_DS_TWR,
+                      device_address=self.responder.uwb_address,
+                      peer_address=self.initiator.uwb_address,
+                  ),
+              ),
+          ),
+      )
+
+      self._start_mutual_ranging_and_assert_started(
+          SESSION_HANDLE,
+          initiator_preference,
+          responder_preference,
+          TECHNOLOGIES,
+      )
+
+      time.sleep(10)
+
+      asserts.assert_true(
+          self.initiator.verify_received_data_from_peer_using_technologies(
+              SESSION_HANDLE, self.responder.id, TECHNOLOGIES
+          ),
+          "Initiator did not find responder",
+      )
+      asserts.assert_true(
+          self.responder.verify_received_data_from_peer_using_technologies(
+              SESSION_HANDLE,
+              self.initiator.id,
+              TECHNOLOGIES,
+          ),
+          "Responder did not find initiator",
+      )
+
+      self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
+      self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
+
+
+  @ApiTest(apis=[
+    'android.ranging.RangingData#getDistance',
+    'android.ranging.RangingData#getAzimuth',
+    'android.ranging.RangingData#getElevation',
+    'android.ranging.RangingData#getRangingTechnology',
+    'android.ranging.RangingData#getRssi',
+    'android.ranging.RangingData#hasRssi',
+    'android.ranging.RangingData#getTimestampMillis',
+    'android.ranging.RangingMeasurement#getMeasurement',
+    'android.ranging.RangingMeasurement#getConfidence',
+    'android.ranging.RangingSession.Callback#onOpened()',
+    'android.ranging.RangingSession.Callback#onOpenFailed(int)',
+    'android.ranging.RangingSession.Callback#onClosed(int)',
+    'android.ranging.RangingSession.Callback#onResults(android.ranging.RangingDevice, android.ranging.RangingData)',
+    'android.ranging.RangingSession.Callback#onStarted(android.ranging.RangingDevice, int)',
+    'android.ranging.RangingSession.Callback#onStopped(android.ranging.RangingDevice, int)',
+    'android.os.Parcel#writeBlob(byte[])',
+  ])
+  def test_one_to_one_uwb_ranging_unicast_static_sts(self):
+    """Verifies uwb ranging with peer device using unicast static sts"""
+    self._test_one_to_one_uwb_ranging(uwb.ConfigId.UNICAST_DS_TWR)
+
+  def test_one_to_one_uwb_ranging_multicast_provisioned_sts(self):
+    """Verifies uwb ranging with peer device using multicast provisioned sts"""
+    self._test_one_to_one_uwb_ranging(uwb.ConfigId.PROVISIONED_MULTICAST_DS_TWR)
+
+  def test_one_to_one_uwb_ranging_unicast_provisioned_sts(self):
+      """Verifies uwb ranging with peer device using unicast provisioned sts"""
+      self._test_one_to_one_uwb_ranging(uwb.ConfigId.PROVISIONED_UNICAST_DS_TWR)
+
+  def test_one_to_one_uwb_ranging_disable_range_data_ntf(self):
+    """Verifies device does not receive range data after disabling range data notifications"""
     SESSION_HANDLE = str(uuid4())
     UWB_SESSION_ID = 5
-    TECHNOLOGIES = {RangingTechnology.UWB}
-
     asserts.skip_if(
         not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
         f"UWB not supported by responder",
@@ -179,7 +331,6 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
         not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
         f"UWB not supported by initiator",
     )
-
     initiator_preference = RangingPreference(
         device_role=DeviceRole.INITIATOR,
         ranging_params=RawInitiatorRangingParams(
@@ -188,13 +339,14 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
                     peer_id=self.responder.id,
                     uwb_params=uwb.UwbRangingParams(
                         session_id=UWB_SESSION_ID,
-                        config_id=uwb.ConfigId.UNICAST_DS_TWR,
+                        config_id=uwb.ConfigId.MULTICAST_DS_TWR,
                         device_address=self.initiator.uwb_address,
                         peer_address=self.responder.uwb_address,
                     ),
                 )
             ],
         ),
+        enable_range_data_notifications=False,
     )
 
     responder_preference = RangingPreference(
@@ -204,123 +356,181 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
                 peer_id=self.initiator.id,
                 uwb_params=uwb.UwbRangingParams(
                     session_id=UWB_SESSION_ID,
-                    config_id=uwb.ConfigId.UNICAST_DS_TWR,
+                    config_id=uwb.ConfigId.MULTICAST_DS_TWR,
                     device_address=self.responder.uwb_address,
                     peer_address=self.initiator.uwb_address,
                 ),
             ),
         ),
+        enable_range_data_notifications=True,
     )
 
-    self._start_mutual_ranging_and_assert_started(
-        SESSION_HANDLE,
-        initiator_preference,
-        responder_preference,
-        TECHNOLOGIES,
+    self.initiator.start_ranging_and_assert_opened(
+        SESSION_HANDLE, initiator_preference
+    )
+    self.responder.start_ranging_and_assert_opened(
+        SESSION_HANDLE, responder_preference
     )
 
-    time.sleep(10)
-
-    asserts.assert_true(
-        self.initiator.verify_received_data_from_peer_using_technologies(
-            SESSION_HANDLE, self.responder.id, TECHNOLOGIES
+    asserts.assert_false(
+        self.initiator.verify_received_data_from_peer(
+            SESSION_HANDLE, self.responder.id
         ),
-        "Initiator did not find responder",
+        "Initiator found responder but initiator has range data"
+        " notifications disabled",
     )
     asserts.assert_true(
-        self.responder.verify_received_data_from_peer_using_technologies(
-            SESSION_HANDLE,
-            self.initiator.id,
-            TECHNOLOGIES,
+        self.responder.verify_received_data_from_peer(
+            SESSION_HANDLE, self.initiator.id
         ),
-        "Responder did not find initiator",
+        "Responder did not find initiator but responder has range data"
+        " notifications enabled",
     )
 
     self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
     self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
 
-  def test_one_to_one_uwb_ranging_provisioned_sts(self):
-    """Verifies uwb ranging with peer device using provisioned sts"""
-    SESSION_HANDLE = str(uuid4())
-    UWB_SESSION_ID = 5
-    TECHNOLOGIES = {RangingTechnology.UWB}
+  def test_uwb_ranging_measurement_limit(self):
+      """Verifies device does not receive range data after measurement limit"""
+      SESSION_HANDLE = str(uuid4())
+      UWB_SESSION_ID = 5
+      asserts.skip_if(
+          not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
+          f"UWB not supported by responder",
+      )
+      asserts.skip_if(
+          not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
+          f"UWB not supported by initiator",
+      )
 
-    asserts.skip_if(
-        not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
-        f"UWB not supported by responder",
-    )
-    asserts.skip_if(
-      not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
-      f"UWB not supported by initiator",
-  )
+      asserts.skip_if(self.initiator.ad.uwb.getSpecificationInfo()["fira"]["uci_version"] < 2,
+          f"Measurements limit is supported from Fira 2.0",
+      )
+      asserts.skip_if(self.responder.ad.uwb.getSpecificationInfo()["fira"]["uci_version"] < 2,
+         f"Measurements limit in supported from Fira 2.0",
+      )
 
-    initiator_preference = RangingPreference(
-        device_role=DeviceRole.INITIATOR,
-        ranging_params=RawInitiatorRangingParams(
-            peer_params=[
-                DeviceParams(
-                    peer_id=self.responder.id,
-                    uwb_params=uwb.UwbRangingParams(
-                        session_id=UWB_SESSION_ID,
-                        config_id=uwb.ConfigId.PROVISIONED_UNICAST_DS_TWR,
-                        device_address=self.initiator.uwb_address,
-                        peer_address=self.responder.uwb_address,
-                    ),
-                )
-            ],
-        ),
-    )
+      initiator_preference = RangingPreference(
+          device_role=DeviceRole.INITIATOR,
+          ranging_params=RawInitiatorRangingParams(
+              peer_params=[
+                  DeviceParams(
+                      peer_id=self.responder.id,
+                      uwb_params=uwb.UwbRangingParams(
+                          session_id=UWB_SESSION_ID,
+                          config_id=uwb.ConfigId.MULTICAST_DS_TWR,
+                          device_address=self.initiator.uwb_address,
+                          peer_address=self.responder.uwb_address,
+                      ),
+                  )
+              ],
+          ),
+          measurement_limit=2,
+      )
 
-    responder_preference = RangingPreference(
-        device_role=DeviceRole.RESPONDER,
-        ranging_params=RawResponderRangingParams(
-            peer_params=DeviceParams(
-                peer_id=self.initiator.id,
-                uwb_params=uwb.UwbRangingParams(
-                    session_id=UWB_SESSION_ID,
-                    config_id=uwb.ConfigId.PROVISIONED_UNICAST_DS_TWR,
-                    device_address=self.responder.uwb_address,
-                    peer_address=self.initiator.uwb_address,
-                ),
-            ),
-        ),
-    )
+      responder_preference = RangingPreference(
+          device_role=DeviceRole.RESPONDER,
+          ranging_params=RawResponderRangingParams(
+              peer_params=DeviceParams(
+                  peer_id=self.initiator.id,
+                  uwb_params=uwb.UwbRangingParams(
+                      session_id=UWB_SESSION_ID,
+                      config_id=uwb.ConfigId.MULTICAST_DS_TWR,
+                      device_address=self.responder.uwb_address,
+                      peer_address=self.initiator.uwb_address,
+                  ),
+              ),
+          ),
+          measurement_limit=2,
+      )
 
-    self._start_mutual_ranging_and_assert_started(
-        SESSION_HANDLE, initiator_preference, responder_preference, TECHNOLOGIES
-    )
+      self.initiator.start_ranging_and_assert_opened(
+          SESSION_HANDLE, initiator_preference
+      )
+      self.responder.start_ranging_and_assert_opened(
+          SESSION_HANDLE, responder_preference
+      )
 
-    self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
-    self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
+      time.sleep(2)
 
-  def test_one_to_one_uwb_ranging_disable_range_data_ntf(self):
-    """Verifies device does not receive range data after disabling range data notifications"""
+      self.initiator.assert_close_ranging_event_received(SESSION_HANDLE)
+      self.responder.assert_close_ranging_event_received(SESSION_HANDLE)
+
+  def test_ble_rssi_ranging_measurement_limit(self):
+      """Verifies ble rssi ranging with measurement limit."""
+      asserts.skip_if(self._is_cuttlefish_device(self.initiator.ad),
+                      "Skipping BLE RSSI test on Cuttlefish")
+      SESSION_HANDLE = str(uuid4())
+
+      asserts.skip_if(
+          not self.responder.is_ranging_technology_supported(RangingTechnology.BLE_RSSI),
+          f"BLE RSSI not supported by responder",
+      )
+      asserts.skip_if(
+          not self.initiator.is_ranging_technology_supported(RangingTechnology.BLE_RSSI),
+          f"BLE RSSI not supported by initiator",
+      )
+      self._enable_bt()
+
+      try:
+          self._ble_connect()
+      except Exception as e:
+          asserts.skip("Failed to create ble connection", str(e))
+
+      try:
+          initiator_preference = RangingPreference(
+              device_role=DeviceRole.INITIATOR,
+              ranging_params=RawInitiatorRangingParams(
+                  peer_params=[
+                      DeviceParams(
+                          peer_id=self.responder.id,
+                          rssi_params=rssi.BleRssiRangingParams(
+                              peer_address=self.responder.bt_addr,
+                              ranging_update_rate=rssi.RangingUpdateRate.FREQUENT,
+                          ),
+                      )
+                  ],
+              ),
+              measurement_limit=4,
+          )
+          self.initiator.start_ranging_and_assert_opened(
+              SESSION_HANDLE, initiator_preference
+          )
+          self.initiator.assert_close_ranging_event_received(SESSION_HANDLE)
+      finally:
+          self._ble_disconnect()
+
+  def test_one_to_one_wifi_rtt_ranging(self):
+    """Verifies wifi rtt ranging with peer device, devices range for 10 seconds."""
+    asserts.skip_if(self._is_cuttlefish_device(self.initiator.ad),
+                    "Skipping WiFi RTT test on Cuttlefish")
     SESSION_HANDLE = str(uuid4())
-    UWB_SESSION_ID = 5
+    TECHNOLOGIES = {RangingTechnology.WIFI_RTT}
+
     asserts.skip_if(
-        not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
-        f"UWB not supported by responder",
+        not self.responder.is_ranging_technology_supported(RangingTechnology.WIFI_RTT),
+        f"Wifi nan rtt not supported by responder",
     )
     asserts.skip_if(
-        not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
-        f"UWB not supported by initiator",
+        not self.initiator.is_ranging_technology_supported(RangingTechnology.WIFI_RTT),
+        f"Wifi nan rtt not supported by initiator",
     )
+    # TODO(rpius): Remove this once the technology is stable.
+    self._reset_wifi_state()
+    test_service_name = "test_service_name" + str(random.randint(1,100))
     initiator_preference = RangingPreference(
         device_role=DeviceRole.INITIATOR,
         ranging_params=RawInitiatorRangingParams(
             peer_params=[
                 DeviceParams(
                     peer_id=self.responder.id,
-                    uwb_params=uwb.UwbRangingParams(
-                        session_id=UWB_SESSION_ID,
-                        config_id=uwb.ConfigId.UNICAST_DS_TWR,
-                        device_address=self.initiator.uwb_address,
-                        peer_address=self.responder.uwb_address,
+                    rtt_params=rtt.RttRangingParams(
+                        service_name=test_service_name,
                     ),
                 )
             ],
         ),
-        enable_range_data_notifications=False,
+        enable_range_data_notifications=True,
     )
 
     responder_preference = RangingPreference(
@@ -328,17 +538,15 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
         ranging_params=RawResponderRangingParams(
             peer_params=DeviceParams(
                 peer_id=self.initiator.id,
-                uwb_params=uwb.UwbRangingParams(
-                    session_id=UWB_SESSION_ID,
-                    config_id=uwb.ConfigId.UNICAST_DS_TWR,
-                    device_address=self.responder.uwb_address,
-                    peer_address=self.initiator.uwb_address,
+                rtt_params=rtt.RttRangingParams(
+                    service_name=test_service_name,
                 ),
             ),
         ),
-        enable_range_data_notifications=True,
+        enable_range_data_notifications=False,
     )
 
+    # Should be able to call _start_mutual_ranging_and_assert_started once we get consistent data.
     self.initiator.start_ranging_and_assert_opened(
         SESSION_HANDLE, initiator_preference
     )
@@ -346,26 +554,29 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
         SESSION_HANDLE, responder_preference
     )
 
-    asserts.assert_false(
-        self.initiator.verify_received_data_from_peer(
-            SESSION_HANDLE, self.responder.id
-        ),
-        "Initiator found responder but initiator has range data"
-        " notifications disabled",
-    )
+    time.sleep(10)
     asserts.assert_true(
-        self.responder.verify_received_data_from_peer(
-            SESSION_HANDLE, self.initiator.id
+        self.initiator.verify_received_data_from_peer_using_technologies(
+            SESSION_HANDLE, self.responder.id, TECHNOLOGIES
         ),
-        "Responder did not find initiator but responder has range data"
-        " notifications enabled",
+        "Initiator did not find responder",
     )
 
+    # Enable when this is supported.
+    # asserts.assert_true(
+    #    self.responder.verify_received_data_from_peer_using_technologies(
+    #        SESSION_HANDLE, self.initiator.id, TECHNOLOGIES
+    #    ),
+    #    "Responder did not find initiator",
+    #)
+
     self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
     self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
 
-  def test_one_to_one_rtt_ranging(self):
-    """Verifies uwb ranging with peer device, devices range for 10 seconds."""
+  def test_one_to_one_wifi_periodic_rtt_ranging(self):
+    """Verifies wifi periodic rtt ranging with peer device, devices range for 10 seconds."""
+    asserts.skip_if(self._is_cuttlefish_device(self.initiator.ad),
+                    "Skipping WiFi periodic RTT test on Cuttlefish")
     SESSION_HANDLE = str(uuid4())
     TECHNOLOGIES = {RangingTechnology.WIFI_RTT}
 
@@ -373,11 +584,22 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
         not self.responder.is_ranging_technology_supported(RangingTechnology.WIFI_RTT),
         f"Wifi nan rtt not supported by responder",
     )
+    asserts.skip_if(
+        not self.responder.ad.ranging.hasPeriodicRangingHwFeature(),
+        f"Wifi nan periodic rtt not supported by responder",
+    )
     asserts.skip_if(
         not self.initiator.is_ranging_technology_supported(RangingTechnology.WIFI_RTT),
         f"Wifi nan rtt not supported by initiator",
     )
+    asserts.skip_if(
+        not self.initiator.ad.ranging.hasPeriodicRangingHwFeature(),
+        f"Wifi nan periodic rtt not supported by initiator",
+    )
+    # TODO(rpius): Remove this once the technology is stable.
+    self._reset_wifi_state()
 
+    test_service_name = "test_periodic_service_name" + str(random.randint(1,100))
     initiator_preference = RangingPreference(
         device_role=DeviceRole.INITIATOR,
         ranging_params=RawInitiatorRangingParams(
@@ -385,11 +607,13 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
                 DeviceParams(
                     peer_id=self.responder.id,
                     rtt_params=rtt.RttRangingParams(
-                        service_name="test_service_name1",
+                        service_name=test_service_name,
+                        enable_periodic_ranging_hw_feature=True,
                     ),
                 )
             ],
         ),
+        enable_range_data_notifications=True,
     )
 
     responder_preference = RangingPreference(
@@ -398,10 +622,12 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
             peer_params=DeviceParams(
                 peer_id=self.initiator.id,
                 rtt_params=rtt.RttRangingParams(
-                    service_name="test_service_name1",
+                    service_name=test_service_name,
+                    enable_periodic_ranging_hw_feature=True,
                 ),
             ),
         ),
+        enable_range_data_notifications=False,
     )
 
     # Should be able to call _start_mutual_ranging_and_assert_started once we get consistent data.
@@ -420,21 +646,26 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
         "Initiator did not find responder",
     )
 
-    # Enable when this is supported.
-    # asserts.assert_true(
-    #     self.responder.verify_peer_found_with_technologies(
-    #         SESSION_HANDLE,
-    #         self.initiator.id,
-    #         TECHNOLOGIES,
-    #     ),
-    #     "Responder did not find initiator",
-    # )
+    asserts.assert_true(
+        self.responder.verify_received_data_from_peer_using_technologies(
+            SESSION_HANDLE, self.initiator.id, TECHNOLOGIES
+        ),
+        "Responder did not find initiator",
+    )
 
     self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
     self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
 
+  @ApiTest(apis=[
+      'android.bluetooth.le.DistanceMeasurementSession#stopSession',
+      'android.content.AttributionSource#checkCallingUid',
+      'java.util#copyOf(byte[], int)',
+      'java.util#copyOfRange(byte[], int, int)',
+  ])
   def test_one_to_one_ble_rssi_ranging(self):
     """Verifies cs ranging with peer device, devices range for 10 seconds."""
+    asserts.skip_if(self._is_cuttlefish_device(self.initiator.ad),
+                    "Skipping BLE RSSI test on Cuttlefish")
     SESSION_HANDLE = str(uuid4())
     TECHNOLOGIES = {RangingTechnology.BLE_RSSI}
 
@@ -446,37 +677,40 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
         not self.initiator.is_ranging_technology_supported(RangingTechnology.BLE_RSSI),
         f"BLE RSSI not supported by initiator",
     )
-    self._reset_bt_state()
+    self._enable_bt()
 
-    self._ble_connect()
+    try:
+        self._ble_connect()
+    except Exception as e:
+        asserts.skip("Failed to create ble connection", str(e))
 
-    initiator_preference = RangingPreference(
-        device_role=DeviceRole.INITIATOR,
-        ranging_params=RawInitiatorRangingParams(
-            peer_params=[
-                DeviceParams(
-                    peer_id=self.responder.id,
-                    rssi_params=rssi.BleRssiRangingParams(
+    try:
+      initiator_preference = RangingPreference(
+          device_role=DeviceRole.INITIATOR,
+          ranging_params=RawInitiatorRangingParams(
+              peer_params=[
+                  DeviceParams(
+                      peer_id=self.responder.id,
+                      rssi_params=rssi.BleRssiRangingParams(
                       peer_address=self.responder.bt_addr,
-                    ),
-                )
-            ],
-        ),
-    )
+                      ),
+                  )
+              ],
+          ),
+      )
 
-    responder_preference = RangingPreference(
-        device_role=DeviceRole.RESPONDER,
-        ranging_params=RawResponderRangingParams(
-            peer_params=DeviceParams(
-                peer_id=self.initiator.id,
-                rssi_params=rssi.BleRssiRangingParams(
+      responder_preference = RangingPreference(
+          device_role=DeviceRole.RESPONDER,
+          ranging_params=RawResponderRangingParams(
+              peer_params=DeviceParams(
+                  peer_id=self.initiator.id,
+                  rssi_params=rssi.BleRssiRangingParams(
                   peer_address=self.initiator.bt_addr,
-                ),
-            ),
-        ),
-    )
+                  ),
+              ),
+          ),
+      )
 
-    try:
       self._start_mutual_ranging_and_assert_started(
           SESSION_HANDLE,
           initiator_preference,
@@ -508,11 +742,17 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
 
       self._ble_disconnect()
 
+  @ApiTest(apis=[
+      'android.bluetooth.le.DistanceMeasurementSession#stopSession',
+      'android.bluetooth.le.DistanceMeasurementParams#getMaxDurationSeconds',
+  ])
   def test_one_to_one_ble_cs_ranging(self):
     """
     Verifies cs ranging with peer device, devices range for 10 seconds.
     This test is only one way since we don't test if responder also can simultaneously get the data.
     """
+    asserts.skip_if(self._is_cuttlefish_device(self.initiator.ad),
+                    "Skipping BLE CS test on Cuttlefish")
     SESSION_HANDLE = str(uuid4())
     TECHNOLOGIES = {RangingTechnology.BLE_CS}
 
@@ -524,25 +764,28 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
         not self.initiator.is_ranging_technology_supported(RangingTechnology.BLE_CS),
         f"BLE CS not supported by initiator",
     )
-    self._reset_bt_state()
-
-    self._ble_bond()
+    self._enable_bt()
 
-    initiator_preference = RangingPreference(
-        device_role=DeviceRole.INITIATOR,
-        ranging_params=RawInitiatorRangingParams(
-            peer_params=[
-                DeviceParams(
-                    peer_id=self.responder.id,
-                    cs_params=cs.CsRangingParams(
-                      peer_address=self.responder.bt_addr,
-                    ),
-                )
-            ],
-        ),
-    )
+    try:
+        self._ble_bond()
+    except Exception as e:
+        asserts.skip("Failed to create ble bond", str(e))
 
     try:
+      initiator_preference = RangingPreference(
+          device_role=DeviceRole.INITIATOR,
+          ranging_params=RawInitiatorRangingParams(
+              peer_params=[
+                  DeviceParams(
+                      peer_id=self.responder.id,
+                      cs_params=cs.CsRangingParams(
+                        peer_address=self.responder.bt_addr,
+                      ),
+                  )
+              ],
+          ),
+      )
+
       self._start_mutual_ranging_and_assert_started(
           SESSION_HANDLE,
           initiator_preference,
@@ -565,6 +808,220 @@ class RangingManagerTest(ranging_base_test.RangingBaseTest):
 
       self._ble_unbond()
 
+  @ApiTest(apis=[
+    'android.ranging.oob.TransportHandle#sendData(byte[])',
+    'android.ranging.oob.TransportHandle#registerReceiveCallback(java.util.concurrent.Executor, android.ranging.oob.TransportHandle.ReceiveCallback)',
+    'android.ranging.oob.TransportHandle.ReceiveCallback#onSendFailed()',
+  ])
+  def test_one_to_one_uwb_ranging_with_oob(self):
+    asserts.skip_if(
+        not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
+        f"UWB not supported by responder",
+    )
+    asserts.skip_if(
+        not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
+        f"UWB not supported by initiator",
+    )
+
+    initiator_preference = RangingPreference(
+        device_role=DeviceRole.INITIATOR,
+        ranging_params=OobInitiatorRangingParams(peer_ids=[self.responder.id], ranging_mode=RangingMode.HIGH_ACCURACY),
+    )
+
+    responder_preference = RangingPreference(
+        device_role=DeviceRole.RESPONDER,
+        ranging_params=OobResponderRangingParams(peer_id=self.initiator.id),
+    )
+
+    session = RangingSession()
+    session.set_initiator(self.initiator, initiator_preference)
+    session.add_responder(self.responder, responder_preference)
+
+    session.start_and_assert_opened()
+    session.assert_received_data()
+    session.stop_and_assert_closed()
+
+  def test_one_to_one_ble_cs_ranging_with_oob(self):
+    asserts.skip_if(
+        not self.responder.is_ranging_technology_supported(RangingTechnology.BLE_CS),
+        f"BLE_CS not supported by responder",
+    )
+    asserts.skip_if(
+        not self.initiator.is_ranging_technology_supported(RangingTechnology.BLE_CS),
+        f"BLE_CS not supported by initiator",
+    )
+
+    if self.initiator.is_ranging_technology_supported(RangingTechnology.UWB):
+      utils.set_uwb_state_and_verify(self.initiator.ad, state=False)
+    if self.responder.is_ranging_technology_supported(RangingTechnology.UWB):
+      utils.set_uwb_state_and_verify(self.responder.ad, state=False)
+
+    initiator_preference = RangingPreference(
+        device_role=DeviceRole.INITIATOR,
+        ranging_params=OobInitiatorRangingParams(
+          peer_ids=[self.responder.id],
+          # HIGH_ACCURACY_PREFERRED mode with UWB disabled should fallback to CS
+          ranging_mode=RangingMode.HIGH_ACCURACY_PREFERRED
+        ),
+    )
+
+    responder_preference = RangingPreference(
+        device_role=DeviceRole.RESPONDER,
+        ranging_params=OobResponderRangingParams(peer_id=self.initiator.id),
+    )
+
+    session = RangingSession()
+    session.set_initiator(self.initiator, initiator_preference)
+    session.add_responder(self.responder, responder_preference)
+
+    self._enable_bt()
+
+    try:
+        self._ble_bond()
+    except Exception as e:
+        asserts.skip("Failed to create ble bond", str(e))
+
+    try:
+      session.start_and_assert_opened(check_responders=False)
+      session.assert_received_data(technologies=[RangingTechnology.BLE_CS], check_responders=False)
+    finally:
+      session.stop_and_assert_closed(check_responders=False)
+      self._ble_unbond()
+
+  def test_one_to_one_wifi_rtt_ranging_with_oob(self):
+      asserts.skip_if(
+          not self.responder.is_ranging_technology_supported(RangingTechnology.WIFI_RTT),
+          f"WIFI_RTT not supported by responder",
+      )
+      asserts.skip_if(
+          not self.initiator.is_ranging_technology_supported(RangingTechnology.WIFI_RTT),
+          f"WIFI_RTT not supported by initiator",
+      )
+
+      if self.initiator.is_ranging_technology_supported(RangingTechnology.UWB):
+          utils.set_uwb_state_and_verify(self.initiator.ad, state=False)
+      if self.responder.is_ranging_technology_supported(RangingTechnology.UWB):
+          utils.set_uwb_state_and_verify(self.responder.ad, state=False)
+
+      if self.initiator.is_ranging_technology_supported(RangingTechnology.BLE_CS) and \
+             self.responder.is_ranging_technology_supported(RangingTechnology.BLE_CS):
+          self._disable_bt()
+
+      self._reset_wifi_state()
+
+      initiator_preference = RangingPreference(
+          device_role=DeviceRole.INITIATOR,
+          ranging_params=OobInitiatorRangingParams(
+              peer_ids=[self.responder.id],
+              # HIGH_ACCURACY_PREFERRED mode with UWB and CS disabled should fallback to RTT
+              ranging_mode=RangingMode.HIGH_ACCURACY_PREFERRED
+          ),
+          enable_range_data_notifications=True,
+      )
+
+      responder_preference = RangingPreference(
+          device_role=DeviceRole.RESPONDER,
+          ranging_params=OobResponderRangingParams(peer_id=self.initiator.id),
+          enable_range_data_notifications=False,
+      )
+
+      session = RangingSession()
+      session.set_initiator(self.initiator, initiator_preference)
+      session.add_responder(self.responder, responder_preference)
+
+      session.start_and_assert_opened(check_responders=False)
+      session.assert_received_data(technologies=[RangingTechnology.WIFI_RTT], check_responders=False)
+
+  def test_one_to_one_ble_rssi_ranging_with_oob(self):
+
+    """ Skip if BLE CS is supported by both devices. """
+    asserts.skip_if(
+        self.initiator.is_ranging_technology_supported(RangingTechnology.BLE_CS) and
+        self.responder.is_ranging_technology_supported(RangingTechnology.BLE_CS),
+        f"BLE_CS is supported, skip running BLE_RSSI tests",
+    )
+
+    asserts.skip_if(
+        self.initiator.is_ranging_technology_supported(RangingTechnology.BLE_RSSI) or
+        self.responder.is_ranging_technology_supported(RangingTechnology.BLE_RSSI),
+        f"BLE_RSSI is not supported",
+        )
+
+    if self.initiator.is_ranging_technology_supported(RangingTechnology.UWB):
+        utils.set_uwb_state_and_verify(self.initiator.ad, state=False)
+    if self.responder.is_ranging_technology_supported(RangingTechnology.UWB):
+        utils.set_uwb_state_and_verify(self.responder.ad, state=False)
+
+    if self.initiator.is_ranging_technology_supported(RangingTechnology.WIFI_RTT) and \
+        self.responder.is_ranging_technology_supported(RangingTechnology.WIFI_RTT):
+      self._disable_wifi()
+
+    self._enable_bt()
+
+    try:
+        self._ble_connect()
+    except Exception as e:
+        asserts.skip("Failed to create ble connection", str(e))
+
+    try:
+      initiator_preference = RangingPreference(
+          device_role=DeviceRole.INITIATOR,
+          ranging_params=OobInitiatorRangingParams(
+            peer_ids=[self.responder.id],
+            ranging_mode=RangingMode.AUTO
+          ),
+      )
+
+      responder_preference = RangingPreference(
+          device_role=DeviceRole.RESPONDER,
+          ranging_params=OobResponderRangingParams(peer_id=self.initiator.id),
+      )
+
+      session = RangingSession()
+      session.set_initiator(self.initiator, initiator_preference)
+      session.add_responder(self.responder, responder_preference)
+
+      session.start_and_assert_opened(check_responders=False)
+      session.assert_received_data(technologies=[RangingTechnology.BLE_RSSI], check_responders=False)
+
+    finally:
+        self._ble_disconnect()
+
+
+  def test_oob_responder_persists_until_explicitly_stopped(self):
+    asserts.skip_if(
+        not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
+        f"UWB not supported by responder",
+    )
+    asserts.skip_if(
+        not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
+        f"UWB not supported by initiator",
+    )
+
+    initiator_preference = RangingPreference(
+        device_role=DeviceRole.INITIATOR,
+        ranging_params=OobInitiatorRangingParams(peer_ids=[self.responder.id], ranging_mode=RangingMode.HIGH_ACCURACY),
+    )
+
+    responder_preference = RangingPreference(
+        device_role=DeviceRole.RESPONDER,
+        ranging_params=OobResponderRangingParams(peer_id=self.initiator.id),
+    )
+
+    session = RangingSession()
+    session.set_initiator(self.initiator, initiator_preference)
+    session.add_responder(self.responder, responder_preference)
+
+    session.start_and_assert_opened()
+    session.assert_received_data()
+    session.stop_and_assert_closed(stop_responders=False, check_responders=False)
+
+    time.sleep(1)
+
+    session.start_and_assert_opened(start_responders=False, check_responders=False)
+    session.assert_received_data()
+    session.stop_and_assert_closed()
+
 if __name__ == "__main__":
   if "--" in sys.argv:
     index = sys.argv.index("--")
diff --git a/ranging/tests/multidevices/lib/params.py b/ranging/tests/multidevices/lib/params.py
index 3023be26..654f6d6e 100644
--- a/ranging/tests/multidevices/lib/params.py
+++ b/ranging/tests/multidevices/lib/params.py
@@ -1,7 +1,7 @@
 from abc import ABC, abstractmethod
 import dataclasses
 from enum import IntEnum
-from typing import List, Optional
+from typing import Tuple, List, Optional
 from lib.cs import CsRangingParams
 from lib.rtt import RttRangingParams
 from lib.uwb import UwbRangingParams
@@ -17,6 +17,15 @@ class RangingSessionType(IntEnum):
   RAW = 0
   OOB = 1
 
+class SecurityLevel(IntEnum):
+  BASIC = 0
+  SECURE = 1
+
+class RangingMode(IntEnum):
+  AUTO = 0
+  HIGH_ACCURACY = 1
+  HIGH_ACCURACY_PREFERRED = 2
+  FUSED = 3
 
 @dataclasses.dataclass(kw_only=True, frozen=True)
 class DeviceParams:
@@ -31,6 +40,18 @@ class DeviceParams:
 class RangingParams(ABC):
   session_type: RangingSessionType
 
+@dataclasses.dataclass(kw_only=True, frozen=True)
+class OobInitiatorRangingParams(RangingParams):
+  session_type: RangingSessionType = RangingSessionType.OOB
+  ranging_interval_ms: Tuple[int, int] = (100, 5000)
+  security_level: SecurityLevel = SecurityLevel.BASIC
+  ranging_mode: RangingMode = RangingMode.AUTO
+  peer_ids: List[str]
+
+@dataclasses.dataclass(kw_only=True, frozen=True)
+class OobResponderRangingParams(RangingParams):
+  session_type: RangingSessionType = RangingSessionType.OOB
+  peer_id: str
 
 @dataclasses.dataclass(kw_only=True, frozen=True)
 class RawInitiatorRangingParams(RangingParams):
@@ -57,3 +78,4 @@ class RangingPreference:
       default_factory=SensorFusionParams
   )
   enable_range_data_notifications: bool = True
+  measurement_limit: int = 0
diff --git a/ranging/tests/multidevices/lib/ranging_base_test.py b/ranging/tests/multidevices/lib/ranging_base_test.py
index 51d61db7..e4ed6f3d 100644
--- a/ranging/tests/multidevices/lib/ranging_base_test.py
+++ b/ranging/tests/multidevices/lib/ranging_base_test.py
@@ -35,7 +35,6 @@ class RangingBaseTest(base_test.BaseTestClass):
     )
     for ad in self.android_devices:
       ad.load_snippet("ranging", "com.google.snippet.ranging")
-      utils.initialize_uwb_country_code_if_necessary(ad)
       ad.load_snippet("uwb", "com.google.snippet.uwb")
       ad.load_snippet("bluetooth", "com.google.snippet.bluetooth")
 
diff --git a/ranging/tests/multidevices/lib/ranging_decorator.py b/ranging/tests/multidevices/lib/ranging_decorator.py
index 50c3eef1..c22db84e 100644
--- a/ranging/tests/multidevices/lib/ranging_decorator.py
+++ b/ranging/tests/multidevices/lib/ranging_decorator.py
@@ -1,13 +1,17 @@
 import copy
 import dataclasses
 from enum import IntEnum, StrEnum
-from typing import Set
+from typing import Set, Dict
 from uuid import uuid4
 from lib.params import RangingPreference
-from mobly.controllers import android_device
+from mobly.controllers.android_device import AndroidDevice
+from mobly.controllers.android_device_lib.callback_handler_v2 import (
+    CallbackHandlerV2,
+)
+from mobly.snippet.callback_event import CallbackEvent
 
 
-CALLBACK_WAIT_TIME_SEC = 5
+CALLBACK_WAIT_TIME_SEC = 5.0
 
 
 class RangingTechnology(IntEnum):
@@ -24,11 +28,17 @@ class Event(StrEnum):
   DATA = "DATA"
   STOPPED = "STOPPED"
   CLOSED = "CLOSED"
+  OOB_SEND_CAPABILITIES_REQUEST = "OOB_SEND_CAPABILITIES_REQUEST",
+  OOB_SEND_CAPABILITIES_RESPONSE = "OOB_SEND_CAPABILITIES_RESPONSE",
+  OOB_SEND_SET_CONFIGURATION = "OOB_SEND_SET_CONFIGURATION",
+  OOB_SEND_STOP_RANGING = "OOB_SEND_STOP_RANGING",
+  OOB_SEND_UNKNOWN = "OOB_SEND_UNKNOWN",
+  OOB_CLOSED = "OOB_CLOSED"
 
 
 class RangingDecorator:
 
-  def __init__(self, ad: android_device.AndroidDevice):
+  def __init__(self, ad: AndroidDevice):
     """Initialize the ranging device.
 
     Args:
@@ -36,11 +46,20 @@ class RangingDecorator:
     """
     self.id = str(uuid4())
     self.ad = ad
-    self._event_handlers = {}
+    self._callback_events: Dict[str, CallbackHandlerV2] = {}
     self.log = self.ad.log
     self.uwb_address = None
     self.bt_addr = None
 
+  def start_ranging(
+      self, session_handle: str, preference: RangingPreference
+  ):
+    """Start ranging with the specified preference. """
+    handler = self.ad.ranging.startRanging(
+        session_handle, dataclasses.asdict(preference)
+    )
+    self._callback_events[session_handle] = handler
+
   def start_ranging_and_assert_opened(
       self, session_handle: str, preference: RangingPreference
   ):
@@ -49,17 +68,21 @@ class RangingDecorator:
     Throws:
       CallbackHandlerTimeoutError if ranging does not successfully start.
     """
-    handler = self.ad.ranging.startRanging(
-        session_handle, dataclasses.asdict(preference)
-    )
-    self._event_handlers[session_handle] = handler
+    self.start_ranging(session_handle, preference)
     self.assert_ranging_event_received(session_handle, Event.OPENED)
 
-  def is_ranging_technology_supported(self, ranging_technology : RangingTechnology) -> bool:
-
+  def is_ranging_technology_supported(
+      self, ranging_technology: RangingTechnology
+  ) -> bool:
     """Checks whether a specific ranging technology is supported by the device"""
     return self.ad.ranging.isTechnologySupported(ranging_technology)
 
+  def stop_ranging(self, session_handle: str):
+    self.ad.ranging.stopRanging(session_handle)
+
+  def assert_closed(self, session_handle: str):
+    self.assert_close_ranging_event_received(session_handle)
+    self._callback_events.pop(session_handle)
 
   def stop_ranging_and_assert_closed(self, session_handle: str):
     """Stop ranging and wait for onStopped event.
@@ -67,16 +90,18 @@ class RangingDecorator:
     Throws:
       CallbackHandlerTimeoutError if ranging was not successfully stopped.
     """
-    self.ad.ranging.stopRanging(session_handle)
+    self.stop_ranging(session_handle)
+    self.assert_closed(session_handle)
+
+  def assert_close_ranging_event_received(self, session_handle: str):
     self.assert_ranging_event_received(session_handle, Event.CLOSED)
-    self._event_handlers.pop(session_handle)
 
   def assert_ranging_event_received(
       self,
       session_handle: str,
       event: Event,
-      timeout_s: int = CALLBACK_WAIT_TIME_SEC,
-  ):
+      timeout_s: float = CALLBACK_WAIT_TIME_SEC,
+  ) -> CallbackEvent:
     """Asserts that the expected event is received before a timeout.
 
     Args:
@@ -84,18 +109,21 @@ class RangingDecorator:
       event: expected ranging event.
       timeout_s: timeout in seconds.
 
+    Returns:
+      The event
+
     Throws:
       CallbackHandlerTimeoutError if the expected event was not received.
     """
-    handler = self._event_handlers[session_handle]
-    handler.waitAndGet(event, timeout=timeout_s)
+    handler = self._callback_events[session_handle]
+    return handler.waitAndGet(event, timeout=timeout_s)
 
   def verify_received_data_from_peer_using_technologies(
       self,
       session_handle: str,
       peer_id: str,
       technologies: Set[RangingTechnology],
-      timeout_s: int = CALLBACK_WAIT_TIME_SEC,
+      timeout_s: float = CALLBACK_WAIT_TIME_SEC,
   ) -> bool:
     """Verifies that the peer sends us data from all provided technologies before a timeout.
 
@@ -112,17 +140,16 @@ class RangingDecorator:
     remaining_technologies = copy.deepcopy(technologies)
 
     def predicate(event):
-      peer = event.data["peer"]
       technology = event.data["technology"]
 
-      if peer == peer_id and technology in copy.deepcopy(
+      if event.data["peer_id"] == peer_id and technology in copy.deepcopy(
           remaining_technologies
       ):
         remaining_technologies.remove(technology)
 
       return not bool(remaining_technologies)
 
-    handler = self._event_handlers[session_handle]
+    handler = self._callback_events[session_handle]
     try:
       handler.waitForEvent(Event.DATA, predicate, timeout=timeout_s)
       return True
@@ -133,7 +160,7 @@ class RangingDecorator:
       self,
       session_handle: str,
       peer_id: str,
-      timeout_s: int = CALLBACK_WAIT_TIME_SEC,
+      timeout_s: float = CALLBACK_WAIT_TIME_SEC,
   ) -> bool:
     """Verifies that the peer sends us data using any technology before a timeout.
 
@@ -147,9 +174,9 @@ class RangingDecorator:
     """
 
     def predicate(event):
-      return event.data["peer"] == peer_id
+      return event.data["peer_id"] == peer_id
 
-    handler = self._event_handlers[session_handle]
+    handler = self._callback_events[session_handle]
     try:
       handler.waitForEvent(Event.DATA, predicate, timeout=timeout_s)
       return True
@@ -158,7 +185,12 @@ class RangingDecorator:
 
   def clear_ranging_sessions(self):
     """Stop all ranging sessions and clear callback events"""
-    for session_handle in self._event_handlers.keys():
+    for session_handle in self._callback_events.keys():
       self.ad.ranging.stopRanging(session_handle)
 
-    self._event_handlers.clear()
+    self._callback_events.clear()
+
+  def get_callback_handler(self, session_handle: str) -> CallbackHandlerV2:
+    """Get the mobly CallbackHandler associated with the provided session"""
+    return self._callback_events.get(session_handle, None)
+
diff --git a/ranging/tests/multidevices/lib/rtt.py b/ranging/tests/multidevices/lib/rtt.py
index b7034b3b..386ab3e4 100644
--- a/ranging/tests/multidevices/lib/rtt.py
+++ b/ranging/tests/multidevices/lib/rtt.py
@@ -16,3 +16,4 @@ class RttRangingParams:
 
   service_name: str
   ranging_update_rate: RangingUpdateRate = RangingUpdateRate.AUTOMATIC
+  enable_periodic_ranging_hw_feature: bool = False
diff --git a/ranging/tests/multidevices/lib/session.py b/ranging/tests/multidevices/lib/session.py
new file mode 100644
index 00000000..b4ec0401
--- /dev/null
+++ b/ranging/tests/multidevices/lib/session.py
@@ -0,0 +1,177 @@
+from typing import Dict, List
+from lib.params import *
+from lib.ranging_decorator import *
+from mobly import asserts
+from mobly.controllers.android_device_lib.callback_handler_v2 import CallbackHandlerV2
+
+
+class RangingSession:
+  handle: str
+  initiator_id: str
+  responder_ids: Set[str]
+  devices: Dict[str, RangingDecorator]
+  preferences: Dict[str, RangingPreference]
+
+  def __init__(self):
+    self.handle = str(uuid4())
+    self.responder_ids = set()
+    self.devices = {}
+    self.preferences = {}
+
+  def set_initiator(
+      self, initiator: RangingDecorator, preference: RangingPreference
+  ):
+    asserts.assert_true(
+        preference.device_role == DeviceRole.INITIATOR,
+        "Expected preference with initiator role",
+    )
+
+    self.initiator_id = initiator.id
+    self.devices[initiator.id] = initiator
+    self.preferences[initiator.id] = preference
+    return self
+
+  def add_responder(
+      self, responder: RangingDecorator, preference: RangingPreference
+  ):
+    asserts.assert_true(
+        preference.device_role == DeviceRole.RESPONDER,
+        "Expected preference with responder role",
+    )
+
+    self.responder_ids.add(responder.id)
+    self.devices[responder.id] = responder
+    self.preferences[responder.id] = preference
+    return self
+
+  def start_and_assert_opened(self, start_responders: bool = True, check_responders: bool = True):
+    self.devices[self.initiator_id].start_ranging(self.handle, self.preferences[self.initiator_id])
+
+    if start_responders:
+      for id in self.responder_ids:
+        self.devices[id].start_ranging(self.handle, self.preferences[id])
+
+    if self._is_using_oob():
+      self._handle_oob_start_ranging()
+
+    self.devices[self.initiator_id].assert_ranging_event_received(self.handle, Event.OPENED)
+
+    if check_responders:
+      for id in self.responder_ids:
+        self.devices[id].assert_ranging_event_received(self.handle, Event.OPENED)
+
+    return self
+
+  def assert_received_data(self, technologies: Set[RangingTechnology] = None, check_responders: bool = True):
+    if technologies is None:
+      self._assert_received_data_using_any_technologies(check_responders)
+    else:
+      self._assert_received_data_using_technologies(technologies, check_responders)
+
+    return self
+
+  def stop_and_assert_closed(self, stop_responders: bool = True, check_responders: bool = True):
+    self.devices[self.initiator_id].stop_ranging(self.handle)
+
+    if self._is_using_oob():
+      self._handle_oob_stop_ranging()
+
+    if stop_responders:
+      for id in self.responder_ids:
+        self.devices[id].stop_ranging(self.handle)
+
+
+    self.devices[self.initiator_id].assert_closed(self.handle)
+    if check_responders:
+      for responder_id in self.responder_ids:
+        self.devices[responder_id].assert_closed(self.handle)
+
+  def _assert_received_data_using_any_technologies(self, check_responders: bool = True):
+    for responder_id in self.responder_ids:
+      self.devices[self.initiator_id].verify_received_data_from_peer(
+          self.handle, responder_id
+      )
+      if check_responders:
+        self.devices[responder_id].verify_received_data_from_peer(
+            self.handle, self.initiator_id
+        )
+
+  def _assert_received_data_using_technologies(
+      self, technologies: Set[RangingTechnology] = None, check_responders: bool = True
+  ):
+    for responder_id in self.responder_ids:
+      self.devices[
+          self.initiator_id
+      ].verify_received_data_from_peer_using_technologies(
+          self.handle, responder_id, technologies
+      )
+      if check_responders:
+        self.devices[
+            responder_id
+        ].verify_received_data_from_peer_using_technologies(
+            self.handle, self.initiator_id, technologies
+        )
+
+  def _is_using_oob(self):
+    return (
+        self.preferences[self.initiator_id].ranging_params.session_type
+        == RangingSessionType.OOB
+    )
+
+  def _handle_oob_start_ranging(self):
+    self._oob_initiator_broadcast_to_responders(
+        Event.OOB_SEND_CAPABILITIES_REQUEST
+    )
+    self._oob_responders_all_send_to_initiator(
+        Event.OOB_SEND_CAPABILITIES_RESPONSE
+    )
+    self._oob_initiator_broadcast_to_responders(
+        Event.OOB_SEND_SET_CONFIGURATION
+    )
+
+  def _handle_oob_stop_ranging(self):
+    self._oob_initiator_broadcast_to_responders(Event.OOB_SEND_STOP_RANGING)
+
+  def _oob_initiator_broadcast_to_responders(self, event: Event):
+    responders_yet_to_receive_message = copy.deepcopy(self.responder_ids)
+
+    for _ in self.responder_ids:
+      event = self.devices[self.initiator_id].assert_ranging_event_received(
+          self.handle, event
+      )
+      receiver_id = event.data["peer_id"]
+      oob_message = event.data["data"]
+
+      responders_yet_to_receive_message.remove(receiver_id)
+      self.devices[receiver_id].ad.ranging.handleOobDataReceived(
+          self.handle, self.initiator_id, oob_message
+      )
+
+    asserts.assert_equal(
+        0,
+        len(responders_yet_to_receive_message),
+        f"Some responders did not receive message: {event}"
+        f" {responders_yet_to_receive_message}",
+    )
+
+  def _oob_responders_all_send_to_initiator(self, event: Event):
+    for responder_id in self.responder_ids:
+
+      event = self.devices[responder_id].assert_ranging_event_received(
+          self.handle, event
+      )
+
+      receiver_id = event.data["peer_id"]
+      oob_message = event.data["data"]
+      asserts.assert_equal(
+          self.initiator_id,
+          receiver_id,
+          f"Responder sent {event} to another responder with id {receiver_id}",
+      )
+      self.devices[receiver_id].ad.ranging.handleOobDataReceived(
+          self.handle, responder_id, oob_message
+      )
+
+  def _log_to_all(self, message):
+    for device in self.devices.values():
+      device.ad.ranging.logInfo(message)
diff --git a/ranging/tests/multidevices/lib/utils.py b/ranging/tests/multidevices/lib/utils.py
index cd50e7ab..d3ef71c4 100644
--- a/ranging/tests/multidevices/lib/utils.py
+++ b/ranging/tests/multidevices/lib/utils.py
@@ -21,7 +21,7 @@ from mobly.controllers import android_device
 WAIT_TIME_SEC = 3
 
 
-def initialize_uwb_country_code_if_necessary(ad: android_device.AndroidDevice):
+def initialize_uwb_country_code(ad: android_device.AndroidDevice):
   """Sets UWB country code to US if the device does not have it set.
 
   Note: This intentionally relies on an unstable API (shell command) since we
@@ -32,22 +32,22 @@ def initialize_uwb_country_code_if_necessary(ad: android_device.AndroidDevice):
     ad: android device object.
     handler: callback handler.
   """
-  # Wait to see if UWB state is reported as enabled. If not, this could be
-  # because the country code is not set. Try forcing the country code in that
-  # case.
-  if is_technology_enabled(ad, RangingTechnology.UWB, timeout_s=60):
+  if not ad.ranging.isTechnologySupported(RangingTechnology.UWB) and \
+    ad.ranging.isTechnologyEnabled(RangingTechnology.UWB):
     return
 
   try:
     ad.adb.shell(["cmd", "uwb", "force-country-code", "enabled", "US"])
-  except ad.adb.AdbError:
+  except Exception as e:
     ad.log.warning("Unable to force uwb country code")
 
-  # Unable to get UWB enabled even after setting country code, abort!
-  asserts.assert_true(
-      is_technology_enabled(ad, RangingTechnology.UWB, timeout_s=60),
-      "Uwb was not enabled after setting country code",
-  )
+  #For Wear OS, this call will not enable uwb. So ignore verification whether the stack was enabled.
+  time.sleep(1)
+
+
+def request_hw_idle_vote(ad: android_device.AndroidDevice, enabled : bool):
+  if ad.uwb.isUwbHwIdleTurnOffEnabled():
+    ad.uwb.requestUwbHwEnabled(enabled)
 
 def _is_technology_state(
     ad: android_device.AndroidDevice,
@@ -126,49 +126,67 @@ def set_uwb_state_and_verify(
   """
   failure_msg = "enabled" if state else "disabled"
   ad.uwb.setUwbEnabled(state)
-  asserts.assert_true(_is_technology_state(ad, RangingTechnology.UWB, state, timeout_s=60),
+  asserts.assert_true(_is_technology_state(ad, RangingTechnology.UWB, state, timeout_s=10),
                       "Uwb is not %s" % failure_msg)
 
-def reset_bt_state(
-    ad: android_device.AndroidDevice
+def set_bt_state_and_verify(
+    ad: android_device.AndroidDevice,
+    state: bool
 ):
-  """Reset BT state to off and then on before each test.
+  """Sets BT state to on or off and verifies it.
 
   Args:
     ad: android device object.
+    state: bool, True for BT on, False for off.
   """
-  ad.bluetooth.disableBluetooth()
-  time.sleep(3)
-  asserts.assert_false(ad.bluetooth.isBluetoothOn(), 'Bluetooth did not stop')
-  ad.bluetooth.enableBluetooth()
-  time.sleep(3)
-  asserts.assert_true(ad.bluetooth.isBluetoothOn(), 'Bluetooth did not stop')
+  failure_msg = "enabled" if state else "disabled"
+  if state and not ad.bluetooth.isBluetoothOn():
+    ad.bluetooth.enableBluetooth()
+    time.sleep(3)
+  elif not state and ad.bluetooth.isBluetoothOn() :
+    ad.bluetooth.disableBluetooth()
+    time.sleep(3)
+  asserts.assert_equal(ad.bluetooth.isBluetoothOn(), state, 'Bluetooth state change failed')
   # Check for BLE RSSI or BLE CS availability
-  asserts.assert_true(_is_technology_state(ad, RangingTechnology.BLE_RSSI, True, timeout_s=60),
-                      "BT is not enabled in ranging API")
+  asserts.assert_true(_is_technology_state(ad, RangingTechnology.BLE_RSSI, state, timeout_s=60),
+                      "BT is not %s in ranging API" % failure_msg)
   ad.bluetooth.reset()
 
+def reset_wifi_state(
+    ad: android_device.AndroidDevice
+):
+  """Reset Wifi state to off and then on before each test.
 
-def set_bt_state_and_verify(
+  Args:
+    ad: android device object.
+  """
+  ad.ranging.setWifiEnabled(False)
+  time.sleep(2)
+  asserts.assert_false(ad.ranging.isWifiEnabled(), 'Wifi did not stop')
+  ad.ranging.setWifiEnabled(True)
+  time.sleep(2)
+  asserts.assert_true(ad.ranging.isWifiEnabled(), 'Wifi did not stop')
+  # Check for WIFI RTT availability
+  asserts.assert_true(_is_technology_state(ad, RangingTechnology.WIFI_RTT, True, timeout_s=60),
+                      "Wifi RTT is not enabled in ranging API")
+
+def set_wifi_state_and_verify(
     ad: android_device.AndroidDevice,
     state: bool
 ):
-  """Sets BT state to on or off and verifies it.
+  """Sets Wifi state to on or off and verifies it.
 
   Args:
     ad: android device object.
     state: bool, True for BT on, False for off.
   """
   failure_msg = "enabled" if state else "disabled"
-  if state:
-    ad.bluetooth.enableBluetooth()
-  else:
-    ad.bluetooth.disableBluetooth()
-  time.sleep(3)
-  asserts.assert_equal(ad.bluetooth.isBluetoothOn(), state, 'Bluetooth did not stop')
-  # Check for BLE RSSI or BLE CS availability
-  asserts.assert_true(_is_technology_state(ad, RangingTechnology.BLE_RSSI, state, timeout_s=60),
-                      "BT is not %s in ranging API" % failure_msg)
+  ad.ranging.setWifiEnabled(state)
+  time.sleep(1)
+  asserts.assert_equal(ad.ranging.isWifiEnabled(), state, 'Wifi state change failed')
+  # Check for WIFI RTT availability
+  asserts.assert_true(_is_technology_state(ad, RangingTechnology.WIFI_RTT, state, timeout_s=60),
+                      "Wifi RTT is not %s in ranging API" % failure_msg)
 
 
 def set_screen_rotation_landscape(
diff --git a/ranging/tests/multidevices/lib/uwb.py b/ranging/tests/multidevices/lib/uwb.py
index 687236e2..fd3b02cf 100644
--- a/ranging/tests/multidevices/lib/uwb.py
+++ b/ranging/tests/multidevices/lib/uwb.py
@@ -8,9 +8,10 @@ from typing import List, Optional
 class ConfigId(IntEnum):
   UNICAST_DS_TWR = 1
   MULTICAST_DS_TWR = 2
-  PROVISIONED_UNICAST_DS_TWR = 4
-  PROVISIONED_MULTICAST_DS_TWR = 5
-  PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR = 7
+  PROVISIONED_UNICAST_DS_TWR = 3
+  PROVISIONED_MULTICAST_DS_TWR = 4
+  PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR = 5
+  PROVISIONED_UNICAST_DS_TWR_VERY_FAST = 6
 
 
 class RangingUpdateRate(IntEnum):
diff --git a/ranging/tests/multidevices/snippet/bluetooth/Android.bp b/ranging/tests/multidevices/snippet/bluetooth/Android.bp
new file mode 100644
index 00000000..52b71509
--- /dev/null
+++ b/ranging/tests/multidevices/snippet/bluetooth/Android.bp
@@ -0,0 +1,31 @@
+// Copyright (C) 2023 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+android_test {
+    name: "bluetooth_multi_devices_snippet",
+    srcs: ["*.java"],
+    manifest: "AndroidManifest.xml",
+    static_libs: [
+        "androidx.test.runner",
+        "guava",
+        "mobly-snippet-lib",
+    ],
+    platform_apis: true,
+    sdk_version: "system_current",
+    min_sdk_version: "UpsideDownCake",
+}
diff --git a/ranging/tests/multidevices/snippet/bluetooth/AndroidManifest.xml b/ranging/tests/multidevices/snippet/bluetooth/AndroidManifest.xml
new file mode 100644
index 00000000..b932ff34
--- /dev/null
+++ b/ranging/tests/multidevices/snippet/bluetooth/AndroidManifest.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2023 The Android Open Source Project
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+          http://www.apache.org/licenses/LICENSE-2.0
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.snippet.bluetooth">
+  <!-- Declare the minimum Android SDK version and internet permission,
+       which are required by Mobly Snippet Lib since it uses network socket. -->
+  <uses-sdk android:minSdkVersion="34" />
+  <uses-permission android:name="android.permission.INTERNET" />
+  <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
+  <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
+  <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
+  <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+  <application>
+    <!-- Add any classes that implement the Snippet interface as meta-data, whose
+         value is a comma-separated string, each section being the package path
+         of a snippet class -->
+    <meta-data
+        android:name="mobly-snippets"
+        android:value="com.google.snippet.bluetooth.BluetoothGattMultiDevicesSnippet" />
+  </application>
+  <!-- Add an instrumentation tag so that the app can be launched through an
+       instrument command. The runner `com.google.android.mobly.snippet.SnippetRunner`
+       is derived from `AndroidJUnitRunner`, and is required to use the
+       Mobly Snippet Lib. -->
+  <instrumentation
+      android:name="com.google.android.mobly.snippet.SnippetRunner"
+      android:targetPackage="com.google.snippet.bluetooth" />
+</manifest>
diff --git a/ranging/tests/multidevices/snippet/bluetooth/BluetoothGattMultiDevicesClient.java b/ranging/tests/multidevices/snippet/bluetooth/BluetoothGattMultiDevicesClient.java
new file mode 100644
index 00000000..33aa6ee9
--- /dev/null
+++ b/ranging/tests/multidevices/snippet/bluetooth/BluetoothGattMultiDevicesClient.java
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.snippet.bluetooth;
+
+import static android.bluetooth.BluetoothDevice.BOND_BONDED;
+import static android.bluetooth.BluetoothDevice.TRANSPORT_LE;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCallback;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.OobData;
+import android.bluetooth.le.ScanCallback;
+import android.bluetooth.le.ScanResult;
+import android.bluetooth.le.ScanSettings;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.IntentFilter;
+import android.os.ParcelUuid;
+import android.util.Log;
+
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+
+public final class BluetoothGattMultiDevicesClient {
+    private static final String TAG = "BluetoothGattMultiDevicesClient";
+
+    private Context mContext;
+    private BluetoothAdapter mBluetoothAdapter;
+    private BluetoothGatt mBluetoothGatt;
+
+    private CountDownLatch mConnectionBlocker = null;
+    private CountDownLatch mServicesDiscovered = null;
+    private Integer mWaitForConnectionState = null;
+
+    private static final int CALLBACK_TIMEOUT_SEC = 5;
+
+    private BluetoothDevice mServer;
+
+    private final BluetoothGattCallback mGattCallback =
+            new BluetoothGattCallback() {
+                @Override
+                public void onConnectionStateChange(
+                        BluetoothGatt device, int status, int newState) {
+                    Log.i(TAG, "onConnectionStateChange: newState=" + newState);
+                    if (newState == mWaitForConnectionState && mConnectionBlocker != null) {
+                        Log.v(TAG, "Connected");
+                        mConnectionBlocker.countDown();
+                    }
+                }
+
+                @Override
+                public void onServicesDiscovered(BluetoothGatt gatt, int status) {
+                    mServicesDiscovered.countDown();
+                }
+            };
+
+    public BluetoothGattMultiDevicesClient(Context context, BluetoothManager manager) {
+        mContext = context;
+        mBluetoothAdapter = manager.getAdapter();
+    }
+
+    public BluetoothDevice connect(String uuid) {
+        // Scan for the peer
+        var serverFoundBlocker = new CountDownLatch(1);
+        var scanner = mBluetoothAdapter.getBluetoothLeScanner();
+        var callback =
+                new ScanCallback() {
+                    @Override
+                    public void onScanResult(int callbackType, ScanResult result) {
+                        var uuids = result.getScanRecord().getServiceUuids();
+                        Log.v(TAG, "Found uuids " + uuids);
+                        if (uuids != null
+                                && uuids.contains(new ParcelUuid(UUID.fromString(uuid)))) {
+                            mServer = result.getDevice();
+                            serverFoundBlocker.countDown();
+                        }
+                    }
+                };
+        scanner.startScan(
+            null,
+            new ScanSettings.Builder()
+                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
+                .setLegacy(false)
+                .build(),
+            callback);
+        boolean timeout = false;
+        try {
+            timeout = !serverFoundBlocker.await(CALLBACK_TIMEOUT_SEC, SECONDS);
+        } catch (InterruptedException e) {
+            Log.e(TAG, "", e);
+            timeout = true;
+        }
+        scanner.stopScan(callback);
+        if (timeout) {
+            Log.e(TAG, "Did not discover server");
+            return null;
+        }
+
+        // Connect to the peer
+        mConnectionBlocker = new CountDownLatch(1);
+        mWaitForConnectionState = BluetoothProfile.STATE_CONNECTED;
+        mBluetoothGatt = mServer.connectGatt(mContext, false, mGattCallback, TRANSPORT_LE);
+        timeout = false;
+        try {
+            timeout = !mConnectionBlocker.await(CALLBACK_TIMEOUT_SEC, SECONDS);
+        } catch (InterruptedException e) {
+            Log.e(TAG, "", e);
+            timeout = true;
+        }
+        if (timeout) {
+            Log.e(TAG, "Did not connect to server");
+            return null;
+        }
+        return mServer;
+    }
+
+    public boolean containsService(String uuid) {
+        mServicesDiscovered = new CountDownLatch(1);
+        mBluetoothGatt.discoverServices();
+        try {
+            mServicesDiscovered.await(CALLBACK_TIMEOUT_SEC, SECONDS);
+        } catch (InterruptedException e) {
+            Log.e(TAG, "", e);
+            return false;
+        }
+
+        return mBluetoothGatt.getService(UUID.fromString(uuid)) != null;
+    }
+
+    public boolean disconnect(String uuid) {
+        if (!containsService(uuid)) {
+            Log.e(TAG, "Connected server does not contain the service with UUID: " + uuid);
+            return false;
+        }
+        // Connect to the peer
+        mConnectionBlocker = new CountDownLatch(1);
+        mWaitForConnectionState = BluetoothProfile.STATE_DISCONNECTED;
+        mBluetoothGatt.disconnect();
+        boolean timeout = false;
+        try {
+            timeout = !mConnectionBlocker.await(CALLBACK_TIMEOUT_SEC, SECONDS);
+        } catch (InterruptedException e) {
+            Log.e(TAG, "", e);
+            timeout = true;
+        }
+        if (timeout) {
+            Log.e(TAG, "Did not disconnect from server");
+            return false;
+        }
+        return true;
+    }
+
+    public BluetoothDevice createBondOob(String uuid, OobData oobData) {
+        if (connect(uuid) == null) {
+            Log.e(TAG, "Failed to connect with server");
+            return null;
+        }
+        if (!containsService(uuid)) {
+            Log.e(TAG, "Connected server does not contain the service with UUID: " + uuid);
+            return null;
+        }
+        if (oobData == null) {
+            Log.e(TAG, "createBondOob: No oob data received");
+            return null;
+        }
+        if (mServer == null) {
+            Log.e(TAG, "createBondOob: Device not already connected");
+            return null;
+        }
+        // Bond with the peer (this will block until the bond is complete)
+        CountDownLatch bondingBlocker = new CountDownLatch(1);
+        IntentFilter bondIntentFilter = new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+        BroadcastReceiver bondBroadcastReceiver =
+                new Utils.BondStateBroadcastReceiverImpl(BOND_BONDED, mServer, bondingBlocker);
+        mContext.registerReceiver(bondBroadcastReceiver, bondIntentFilter);
+        if (!mServer.createBondOutOfBand(TRANSPORT_LE, oobData, null)) {
+            Log.e(TAG, "createBondOob: Failed to trigger bonding");
+            return null;
+        }
+        boolean timeout = false;
+        try {
+            timeout = !bondingBlocker.await(CALLBACK_TIMEOUT_SEC, SECONDS);
+        } catch (InterruptedException e) {
+            Log.e(TAG, "Failed to wait for bonding", e);
+            timeout = true;
+        }
+        mContext.unregisterReceiver(bondBroadcastReceiver);
+        if (timeout) {
+            Log.e(TAG, "Did not bond with server");
+            return null;
+        }
+        return mServer;
+    }
+
+}
diff --git a/ranging/tests/multidevices/snippet/bluetooth/BluetoothGattMultiDevicesServer.java b/ranging/tests/multidevices/snippet/bluetooth/BluetoothGattMultiDevicesServer.java
new file mode 100644
index 00000000..91cec839
--- /dev/null
+++ b/ranging/tests/multidevices/snippet/bluetooth/BluetoothGattMultiDevicesServer.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.snippet.bluetooth;
+
+import static android.bluetooth.BluetoothDevice.TRANSPORT_LE;
+import static android.bluetooth.BluetoothGattService.SERVICE_TYPE_PRIMARY;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGattServer;
+import android.bluetooth.BluetoothGattServerCallback;
+import android.bluetooth.BluetoothGattService;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.OobData;
+import android.bluetooth.le.AdvertiseData;
+import android.bluetooth.le.AdvertisingSetCallback;
+import android.bluetooth.le.AdvertisingSetParameters;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.ParcelUuid;
+import android.util.Log;
+
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+
+public final class BluetoothGattMultiDevicesServer {
+    private static final String TAG = "BluetoothGattMultiDevicesServer";
+    private static final int CALLBACK_TIMEOUT_SEC = 1;
+
+    private Context mContext;
+    private BluetoothManager mBluetoothManager;
+    private BluetoothAdapter mBluetoothAdapter;
+    private OobData mOobData;
+
+    public BluetoothGattMultiDevicesServer(Context context, BluetoothManager manager) {
+        mContext = context;
+        mBluetoothManager = manager;
+        mBluetoothAdapter = manager.getAdapter();
+    }
+
+    public BluetoothGattServer createGattServer(String uuid) {
+        var bluetoothGattServer =
+                mBluetoothManager.openGattServer(mContext, new BluetoothGattServerCallback() {});
+        var service = new BluetoothGattService(UUID.fromString(uuid), SERVICE_TYPE_PRIMARY);
+        bluetoothGattServer.addService(service);
+        return bluetoothGattServer;
+    }
+
+    public List<BluetoothDevice> getConnectedDevices() {
+        return mBluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER);
+    }
+
+    public void createAndAdvertiseServer(String uuid) {
+        createGattServer(uuid);
+
+        var bluetoothLeAdvertiser = mBluetoothAdapter.getBluetoothLeAdvertiser();
+        var params = new AdvertisingSetParameters.Builder().setConnectable(true).build();
+        var data =
+                new AdvertiseData.Builder()
+                        .addServiceUuid(new ParcelUuid(UUID.fromString(uuid)))
+                        .build();
+
+        bluetoothLeAdvertiser.startAdvertisingSet(
+                params, data, null, null, null, new AdvertisingSetCallback() {});
+    }
+
+    public void createAndAdvertiseIsolatedServer(String uuid) {
+        var gattServer = createGattServer(uuid);
+
+        var bluetoothLeAdvertiser = mBluetoothAdapter.getBluetoothLeAdvertiser();
+        var params =
+                new AdvertisingSetParameters.Builder()
+                        .setConnectable(true)
+                        .setOwnAddressType(
+                                AdvertisingSetParameters.ADDRESS_TYPE_RANDOM_NON_RESOLVABLE)
+                        .build();
+        var data =
+                new AdvertiseData.Builder()
+                        .addServiceUuid(new ParcelUuid(UUID.fromString(uuid)))
+                        .build();
+
+        bluetoothLeAdvertiser.startAdvertisingSet(
+                params,
+                data,
+                null,
+                null,
+                null,
+                0,
+                0,
+                gattServer,
+                new AdvertisingSetCallback() {},
+                new Handler(Looper.getMainLooper()));
+    }
+
+    private class OobDataCallbackImpl implements BluetoothAdapter.OobDataCallback {
+        private final CountDownLatch mCountDownLatch;
+
+        OobDataCallbackImpl(CountDownLatch countDownLatch) {
+            mCountDownLatch = countDownLatch;
+        }
+
+        @Override
+        public void onOobData(int transport, OobData oobData) {
+            Log.i(TAG, "OobDataCallback: onOobData: " + transport + ", " + oobData);
+            mOobData = oobData;
+            mCountDownLatch.countDown();
+
+        }
+
+        @Override
+        public void onError(int errorCode) {
+            Log.i(TAG, "OobDataCallback: onError: " + errorCode);
+            mOobData = null;
+            mCountDownLatch.countDown();
+
+        }
+    }
+
+    public OobData generateLocalOObData() {
+        CountDownLatch oobLatch = new CountDownLatch(1);
+        mBluetoothAdapter.generateLocalOobData(
+                TRANSPORT_LE,
+                Executors.newSingleThreadExecutor(),
+                new OobDataCallbackImpl(oobLatch));
+        boolean timeout;
+        try {
+            timeout = !oobLatch.await(CALLBACK_TIMEOUT_SEC, SECONDS);
+        } catch (InterruptedException e) {
+            Log.e(TAG, "", e);
+            timeout = true;
+        }
+        if (timeout || mOobData == null) {
+            Log.e(TAG, "Did not generate local oob data");
+            return null;
+        }
+        return mOobData;
+    }
+
+}
diff --git a/ranging/tests/multidevices/snippet/bluetooth/BluetoothGattMultiDevicesSnippet.java b/ranging/tests/multidevices/snippet/bluetooth/BluetoothGattMultiDevicesSnippet.java
new file mode 100644
index 00000000..c9a3ea97
--- /dev/null
+++ b/ranging/tests/multidevices/snippet/bluetooth/BluetoothGattMultiDevicesSnippet.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.snippet.bluetooth;
+
+import static android.bluetooth.BluetoothDevice.BOND_NONE;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.IntentFilter;
+import android.util.Log;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.google.android.mobly.snippet.Snippet;
+import com.google.android.mobly.snippet.rpc.Rpc;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.function.Supplier;
+
+public class BluetoothGattMultiDevicesSnippet implements Snippet {
+    private static final String TAG = "BluetoothGattMultiDevicesSnippet";
+
+    private BluetoothGattMultiDevicesServer mGattServer;
+    private BluetoothGattMultiDevicesClient mGattClient;
+
+    private Context mContext;
+    private BluetoothManager mBluetoothManager;
+
+    public BluetoothGattMultiDevicesSnippet() {
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        mBluetoothManager = mContext.getSystemService(BluetoothManager.class);
+    }
+
+    @Rpc(description = "Reset the state of client + server")
+    public void reset() throws Throwable {
+        mGattServer = new BluetoothGattMultiDevicesServer(mContext, mBluetoothManager);
+        mGattClient = new BluetoothGattMultiDevicesClient(mContext, mBluetoothManager);
+        // Reset all bonded devices to clear device state.
+        runWithShellPermission(
+                () -> {
+                    for (BluetoothDevice bluetoothDevice :
+                            mBluetoothManager.getAdapter().getBondedDevices()) {
+                        removeBondImplBtDevice(bluetoothDevice);
+                    }
+                });
+    }
+
+    @Rpc(description = "Creates Bluetooth GATT server with a given UUID and advertises it.")
+    public void createAndAdvertiseServer(String uuid) throws Throwable {
+        runWithShellPermission(() -> mGattServer.createAndAdvertiseServer(uuid));
+    }
+
+    @Rpc(
+            description =
+                    "Creates Bluetooth GATT server with a given UUID and ties it to an"
+                            + " advertisement.")
+    public void createAndAdvertiseIsolatedServer(String uuid) throws Throwable {
+        runWithShellPermission(() -> mGattServer.createAndAdvertiseIsolatedServer(uuid));
+    }
+
+    @Rpc(description = "Connect to the peer device advertising the specified UUID")
+    public String connectGatt(String uuid) throws Throwable {
+        return runWithShellPermission(() -> Utils.convertBtDeviceToJson(mGattClient.connect(uuid)));
+    }
+
+    @Rpc(description = "Disconnect to the peer device advertising the specified UUID")
+    public boolean disconnectGatt(String uuid) throws Throwable {
+        return runWithShellPermission(() -> mGattClient.disconnect(uuid));
+    }
+
+    @Rpc(description = "Get all the devices connected to the GATT server")
+    public JSONArray getConnectedDevices() throws Throwable {
+        return runWithShellPermission(
+                () -> Utils.convertBtDevicesToJson(mGattServer.getConnectedDevices()));
+    }
+
+    @Rpc(description = "Generate local OOB data to used for bonding with the server")
+    public JSONObject generateServerLocalOobData() throws Throwable {
+        return runWithShellPermission(
+                () -> Utils.convertOobDataToJson(mGattServer.generateLocalOObData()));
+    }
+
+    @Rpc(description = "Create a bond with the server using local OOB data generated on the server")
+    public String createBondOob(String uuid, JSONObject jsonObject) throws Throwable {
+        return runWithShellPermission(
+                () ->
+                        Utils.convertBtDeviceToJson(
+                                mGattClient.createBondOob(
+                                        uuid, Utils.convertJsonToOobData(jsonObject))));
+    }
+
+    @Rpc(description = "Remove bond with the remote device")
+    public boolean removeBond(String remoteAddress) throws Throwable {
+        return runWithShellPermission(() -> removeBondImpl(remoteAddress));
+    }
+
+    @Rpc(description = "Enables Bluetooth")
+    public void enableBluetooth() throws Throwable {
+        runWithShellPermission(() -> mBluetoothManager.getAdapter().enable());
+    }
+
+    @Rpc(description = "Disable Bluetooth")
+    public void disableBluetooth() throws Throwable {
+        runWithShellPermission(() -> mBluetoothManager.getAdapter().disable());
+    }
+
+    @Rpc(description = "Checks Bluetooth state")
+    public boolean isBluetoothOn() {
+        return mBluetoothManager.getAdapter().isEnabled();
+    }
+
+    @Rpc(description = "Whether the connected peer has a service of the given UUID")
+    public boolean containsService(String uuid) throws Throwable {
+        return runWithShellPermission(() -> mGattClient.containsService(uuid));
+    }
+
+    private boolean removeBondImpl(String remoteAddress) {
+        BluetoothDevice bluetoothDevice =
+                mBluetoothManager.getAdapter().getRemoteDevice(remoteAddress);
+        if (bluetoothDevice == null) {
+            Log.e(TAG, "Failed to find remove device: " + bluetoothDevice);
+            return false;
+        }
+        return removeBondImplBtDevice(bluetoothDevice);
+    }
+
+    private static final int BOND_REMOVAL_CALLBACK_TIMEOUT_SEC = 5;
+
+    private boolean removeBondImplBtDevice(BluetoothDevice bluetoothDevice) {
+        CountDownLatch bondingBlocker = new CountDownLatch(1);
+        IntentFilter bondIntentFilter = new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+        BroadcastReceiver bondBroadcastReceiver =
+                new Utils.BondStateBroadcastReceiverImpl(
+                        BOND_NONE, bluetoothDevice, bondingBlocker);
+        mContext.registerReceiver(bondBroadcastReceiver, bondIntentFilter);
+        if (!bluetoothDevice.removeBond()) {
+            Log.e(TAG, "Failed to remove bond");
+            return false;
+        }
+        boolean timeout = false;
+        try {
+            timeout = !bondingBlocker.await(BOND_REMOVAL_CALLBACK_TIMEOUT_SEC, SECONDS);
+        } catch (InterruptedException e) {
+            Log.e(TAG, "Failed to wait for bond removal", e);
+            timeout = true;
+        }
+        mContext.unregisterReceiver(bondBroadcastReceiver);
+        if (timeout) {
+            Log.e(TAG, "Did not remove bond");
+            return false;
+        }
+        return true;
+    }
+
+    private void runWithShellPermission(Runnable action) throws Throwable {
+        Utils.adoptShellPermission();
+        try {
+            action.run();
+        } finally {
+            Utils.dropShellPermission();
+        }
+    }
+
+    private <T> T runWithShellPermission(ThrowingSupplier<T> action) throws Throwable {
+        Utils.adoptShellPermission();
+        try {
+            return action.get();
+        } finally {
+            Utils.dropShellPermission();
+        }
+    }
+
+    /**
+     * Similar to {@link Supplier} but has {@code throws Exception}.
+     *
+     * @param <T> type of the value produced
+     */
+    private interface ThrowingSupplier<T> {
+        /** Similar to {@link Supplier#get} but has {@code throws Exception}. */
+        T get() throws Exception;
+    }
+}
diff --git a/ranging/tests/multidevices/snippet/bluetooth/Utils.java b/ranging/tests/multidevices/snippet/bluetooth/Utils.java
new file mode 100644
index 00000000..325581e7
--- /dev/null
+++ b/ranging/tests/multidevices/snippet/bluetooth/Utils.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.snippet.bluetooth;
+
+import android.app.UiAutomation;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.OobData;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.Method;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+public class Utils {
+    private static final String TAG = "Utils";
+
+    private Utils() {}
+
+    public static void adoptShellPermission() {
+        UiAutomation uia = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        uia.adoptShellPermissionIdentity();
+        // Need to drop the UI Automation to allow other snippets to get access
+        // to global UI automation.
+        // Using reflection here since the method is not public.
+        try {
+            Class<?> cls = Class.forName("android.app.UiAutomation");
+            Method destroyMethod = cls.getDeclaredMethod("destroy");
+            destroyMethod.invoke(uia);
+        } catch (ReflectiveOperationException e) {
+            throw new IllegalStateException("Failed to cleaup Ui Automation", e);
+        }
+    }
+
+    public static void dropShellPermission() {
+        UiAutomation uia = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        uia.dropShellPermissionIdentity();
+        // Need to drop the UI Automation to allow other snippets to get access
+        // to global UI automation.
+        // Using reflection here since the method is not public.
+        try {
+            Class<?> cls = Class.forName("android.app.UiAutomation");
+            Method destroyMethod = cls.getDeclaredMethod("destroy");
+            destroyMethod.invoke(uia);
+        } catch (ReflectiveOperationException e) {
+            throw new IllegalStateException("Failed to cleaup Ui Automation", e);
+        }
+    }
+
+    private static byte[] convertJSONArrayToByteArray(JSONArray jArray) throws JSONException {
+        if (jArray == null) {
+            return null;
+        }
+        byte[] bArray = new byte[jArray.length()];
+        for (int i = 0; i < jArray.length(); i++) {
+            bArray[i] = (byte) jArray.getInt(i);
+        }
+        return bArray;
+    }
+
+    private static JSONArray convertByteArrayToJSONArray(byte[] array) throws JSONException {
+        if (array == null) {
+            return null;
+        }
+        return new JSONArray(array);
+    }
+
+    public static JSONObject convertOobDataToJson(OobData oobData) throws JSONException {
+        if (oobData == null) return null;
+        return new JSONObject()
+                .put("device_address_with_type",
+                convertByteArrayToJSONArray(oobData.getDeviceAddressWithType()))
+                .put("confirmation_hash",
+                        convertByteArrayToJSONArray(oobData.getConfirmationHash()))
+                .put("randomizer_hash",
+                        convertByteArrayToJSONArray(oobData.getRandomizerHash()))
+                .put("device_name", convertByteArrayToJSONArray(oobData.getDeviceName()))
+                .put("classic_length",
+                        convertByteArrayToJSONArray(oobData.getClassicLength()))
+                .put("class_of_device",
+                        convertByteArrayToJSONArray(oobData.getClassOfDevice()))
+                .put("le_temporary_key",
+                        convertByteArrayToJSONArray(oobData.getLeTemporaryKey()))
+                .put("le_temporary_appearance",
+                        convertByteArrayToJSONArray(oobData.getLeAppearance()))
+                .put("le_flags", oobData.getLeFlags())
+                .put("le_device_role", oobData.getLeDeviceRole());
+    }
+
+    public static OobData convertJsonToOobData(JSONObject jsonObj) throws JSONException {
+        if (jsonObj == null) return null;
+        return new OobData.LeBuilder(
+                convertJSONArrayToByteArray(
+                        jsonObj.getJSONArray("confirmation_hash")),
+                convertJSONArrayToByteArray(
+                        jsonObj.getJSONArray("device_address_with_type")),
+                jsonObj.getInt("le_device_role"))
+                .setLeTemporaryKey(convertJSONArrayToByteArray(
+                        jsonObj.getJSONArray("le_temporary_key")))
+                .setRandomizerHash(convertJSONArrayToByteArray(
+                        jsonObj.getJSONArray("randomizer_hash")))
+                .setLeFlags(jsonObj.getInt("le_flags"))
+                .setDeviceName(convertJSONArrayToByteArray(
+                        jsonObj.getJSONArray("device_name")))
+                .build();
+    }
+
+    public static String convertBtDeviceToJson(BluetoothDevice btDevice) throws JSONException {
+        if (btDevice == null) return null;
+        return btDevice.getAddress();
+    }
+
+    public static JSONArray convertBtDevicesToJson(List<BluetoothDevice> btDevices) throws JSONException {
+        if (btDevices == null) return null;
+        JSONArray jsonArray = new JSONArray();
+        for (BluetoothDevice device: btDevices) {
+            jsonArray.put(device.getAddress());
+        }
+        return jsonArray;
+    }
+
+    // Helper class to wait for bond state changed intents.
+    public static class BondStateBroadcastReceiverImpl extends BroadcastReceiver {
+        private final int mWaitForBondState;
+        private final BluetoothDevice mRemoteAddress;
+        private final CountDownLatch mBondingBlocker;
+
+        BondStateBroadcastReceiverImpl(
+                int waitForBondState,
+                BluetoothDevice remoteAddress,
+                CountDownLatch bondingBlocker) {
+            mWaitForBondState = waitForBondState;
+            mRemoteAddress = remoteAddress;
+            mBondingBlocker = bondingBlocker;
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Log.i(TAG, "onReceive: " + intent.getAction());
+            if (intent.getAction().equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) {
+                int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, 0);
+                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                Log.i(TAG, "onReceive: bondState=" + bondState);
+                if (device.equals(mRemoteAddress)
+                        && bondState == mWaitForBondState
+                        && mBondingBlocker != null) {
+                    mBondingBlocker.countDown();
+                }
+            }
+        }
+    }
+    ;
+}
diff --git a/ranging/tests/multidevices/snippet/Android.bp b/ranging/tests/multidevices/snippet/uwb/Android.bp
similarity index 100%
rename from ranging/tests/multidevices/snippet/Android.bp
rename to ranging/tests/multidevices/snippet/uwb/Android.bp
diff --git a/ranging/tests/multidevices/snippet/AndroidManifest.xml b/ranging/tests/multidevices/snippet/uwb/AndroidManifest.xml
similarity index 92%
rename from ranging/tests/multidevices/snippet/AndroidManifest.xml
rename to ranging/tests/multidevices/snippet/uwb/AndroidManifest.xml
index 9a638891..5dc583cf 100644
--- a/ranging/tests/multidevices/snippet/AndroidManifest.xml
+++ b/ranging/tests/multidevices/snippet/uwb/AndroidManifest.xml
@@ -24,9 +24,6 @@
         <meta-data
             android:name="mobly-snippets"
             android:value="com.google.snippet.ranging.RangingSnippet" />
-        <meta-data
-            android:name="mobly-object-converter"
-            android:value="com.google.snippet.ranging.RangingPreferenceConverter" />
     </application>
     <instrumentation
         android:name="com.google.android.mobly.snippet.SnippetRunner"
diff --git a/ranging/tests/multidevices/snippet/RangingPreferenceConverter.java b/ranging/tests/multidevices/snippet/uwb/RangingPreferenceConverter.java
similarity index 63%
rename from ranging/tests/multidevices/snippet/RangingPreferenceConverter.java
rename to ranging/tests/multidevices/snippet/uwb/RangingPreferenceConverter.java
index fb52a6b6..d6b2d3fb 100644
--- a/ranging/tests/multidevices/snippet/RangingPreferenceConverter.java
+++ b/ranging/tests/multidevices/snippet/uwb/RangingPreferenceConverter.java
@@ -21,16 +21,19 @@ import static android.ranging.uwb.UwbComplexChannel.UWB_CHANNEL_9;
 import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_11;
 
 import android.ranging.DataNotificationConfig;
+import android.ranging.RangingConfig;
 import android.ranging.RangingDevice;
-import android.ranging.RangingParams;
 import android.ranging.RangingPreference;
 import android.ranging.SensorFusionParams;
-import android.ranging.SessionConfiguration;
-import android.ranging.ble.cs.CsRangingParams;
+import android.ranging.SessionConfig;
+import android.ranging.ble.cs.BleCsRangingParams;
 import android.ranging.ble.rssi.BleRssiRangingParams;
-import android.ranging.raw.RawInitiatorRangingParams;
+import android.ranging.oob.DeviceHandle;
+import android.ranging.oob.OobInitiatorRangingConfig;
+import android.ranging.oob.OobResponderRangingConfig;
+import android.ranging.raw.RawInitiatorRangingConfig;
 import android.ranging.raw.RawRangingDevice;
-import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.raw.RawResponderRangingConfig;
 import android.ranging.uwb.UwbAddress;
 import android.ranging.uwb.UwbComplexChannel;
 import android.ranging.uwb.UwbRangingParams;
@@ -43,24 +46,31 @@ import org.json.JSONException;
 import org.json.JSONObject;
 
 import java.lang.reflect.Type;
+import java.time.Duration;
 import java.util.UUID;
 
 public class RangingPreferenceConverter implements SnippetObjectConverter {
 
+    RangingSnippet.OobTransportFactory mTransportHandleFactory;
+
+    RangingPreferenceConverter(RangingSnippet.OobTransportFactory transportHandleFactory) {
+        mTransportHandleFactory = transportHandleFactory;
+    }
+
     @Override
     public JSONObject serialize(Object object) {
         throw new UnsupportedOperationException("Not implemented");
     }
 
     @Override
-    public Object deserialize(JSONObject j, Type type) throws JSONException {
+    public RangingPreference deserialize(JSONObject j, Type type) throws JSONException {
         if (type != RangingPreference.class) return null;
 
         return new RangingPreference.Builder(j.getInt("device_role"),
                 getRangingParams(j.getJSONObject("ranging_params"), j.getInt("device_role")))
-                .setSessionConfiguration(
-                        new SessionConfiguration.Builder()
-                                .setSensorFusionParameters(
+                .setSessionConfig(
+                        new SessionConfig.Builder()
+                                .setSensorFusionParams(
                                         getSensorFusionParams(
                                                 j.getJSONObject("sensor_fusion_params"))
                                 )
@@ -68,33 +78,74 @@ public class RangingPreferenceConverter implements SnippetObjectConverter {
                                         getDataNotificationConfig(
                                                 j.getBoolean("enable_range_data_notifications"))
                                 )
+                                .setRangingMeasurementsLimit(j.getInt("measurement_limit"))
                                 .build()
                 )
                 .build();
     }
 
-    private RangingParams getRangingParams(
+    private RangingConfig getRangingParams(
             JSONObject j, @RangingPreference.DeviceRole int role
     ) throws JSONException {
-        RangingParams params;
+        RangingConfig params;
 
-        if (j.getInt("session_type") == RangingParams.RANGING_SESSION_RAW) {
+        if (j.getInt("session_type") == RangingConfig.RANGING_SESSION_RAW) {
             if (role == DEVICE_ROLE_INITIATOR) {
-                params = getRawInitiatorRangingParams(j);
+                params = getRawInitiatorRangingConfig(j);
             } else {
-                params = getRawResponderRangingParams(j);
+                params = getRawResponderRangingConfig(j);
             }
         } else {
-            throw new UnsupportedOperationException("OOB ranging not implemented");
+            if (role == DEVICE_ROLE_INITIATOR) {
+                params = getOobInitiatorRangingConfig(j);
+            } else {
+                params = getOobResponderRangingConfig(j);
+            }
         }
 
         return params;
     }
 
-    private RawInitiatorRangingParams getRawInitiatorRangingParams(
+    private OobInitiatorRangingConfig getOobInitiatorRangingConfig(
             JSONObject j
     ) throws JSONException {
-        RawInitiatorRangingParams.Builder builder = new RawInitiatorRangingParams.Builder();
+        OobInitiatorRangingConfig.Builder builder = new OobInitiatorRangingConfig.Builder();
+        JSONArray jPeers = j.getJSONArray("peer_ids");
+        for (int i = 0; i < jPeers.length(); i++) {
+            RangingDevice device = new RangingDevice.Builder()
+                    .setUuid(UUID.fromString(jPeers.getString(i)))
+                    .build();
+            builder.addDeviceHandle(new DeviceHandle.Builder(
+                    device,
+                    mTransportHandleFactory.createOobTransport(device)
+            ).build());
+        }
+        return builder
+                .setFastestRangingInterval(
+                        Duration.ofMillis(j.getJSONArray("ranging_interval_ms").getInt(0)))
+                .setSlowestRangingInterval(
+                        Duration.ofMillis(j.getJSONArray("ranging_interval_ms").getInt(1)))
+                .setSecurityLevel(j.getInt("security_level"))
+                .setRangingMode(j.getInt("ranging_mode"))
+                .build();
+    }
+
+    private OobResponderRangingConfig getOobResponderRangingConfig(
+            JSONObject j
+    ) throws JSONException {
+        RangingDevice device = new RangingDevice.Builder()
+                .setUuid(UUID.fromString(j.getString("peer_id")))
+                .build();
+        return new OobResponderRangingConfig.Builder(
+                new DeviceHandle.Builder(
+                        device, mTransportHandleFactory.createOobTransport(device)).build())
+                .build();
+    }
+
+    private RawInitiatorRangingConfig getRawInitiatorRangingConfig(
+            JSONObject j
+    ) throws JSONException {
+        RawInitiatorRangingConfig.Builder builder = new RawInitiatorRangingConfig.Builder();
         JSONArray jPeerParams = j.getJSONArray("peer_params");
         for (int i = 0; i < jPeerParams.length(); i++) {
             builder.addRawRangingDevice(getRawRangingDevice(jPeerParams.getJSONObject(i)));
@@ -102,10 +153,10 @@ public class RangingPreferenceConverter implements SnippetObjectConverter {
         return builder.build();
     }
 
-    private RawResponderRangingParams getRawResponderRangingParams(
+    private RawResponderRangingConfig getRawResponderRangingConfig(
             JSONObject j
     ) throws JSONException {
-        return new RawResponderRangingParams.Builder()
+        return new RawResponderRangingConfig.Builder()
                 .setRawRangingDevice(getRawRangingDevice(j.getJSONObject("peer_params")))
                 .build();
     }
@@ -156,10 +207,10 @@ public class RangingPreferenceConverter implements SnippetObjectConverter {
     }
 
     private RttRangingParams getRttParams(JSONObject j) throws JSONException {
-        RttRangingParams.Builder builder = new RttRangingParams.Builder(
-                j.getString("service_name"));
-
-        return builder.setRangingUpdateRate(j.getInt("ranging_update_rate"))
+        return new RttRangingParams.Builder(j.getString("service_name"))
+                .setPeriodicRangingHwFeatureEnabled(
+                        j.getBoolean("enable_periodic_ranging_hw_feature"))
+                .setRangingUpdateRate(j.getInt("ranging_update_rate"))
                 .build();
     }
 
@@ -169,8 +220,8 @@ public class RangingPreferenceConverter implements SnippetObjectConverter {
                 .build();
     }
 
-    private CsRangingParams getCsParams(JSONObject j) throws JSONException {
-        return new CsRangingParams.Builder(j.getString("peer_address"))
+    private BleCsRangingParams getCsParams(JSONObject j) throws JSONException {
+        return new BleCsRangingParams.Builder(j.getString("peer_address"))
                 .setRangingUpdateRate(j.getInt("ranging_update_rate"))
                 .setSecurityLevel(j.getInt("security_level"))
                 .build();
@@ -186,8 +237,8 @@ public class RangingPreferenceConverter implements SnippetObjectConverter {
         return new DataNotificationConfig.Builder()
                 .setNotificationConfigType(
                         enableRangeDataNotifications
-                                ? DataNotificationConfig.ENABLE
-                                : DataNotificationConfig.DISABLE
+                                ? DataNotificationConfig.NOTIFICATION_CONFIG_ENABLE
+                                : DataNotificationConfig.NOTIFICATION_CONFIG_DISABLE
                 )
                 .build();
     }
diff --git a/ranging/tests/multidevices/snippet/RangingSnippet.java b/ranging/tests/multidevices/snippet/uwb/RangingSnippet.java
similarity index 50%
rename from ranging/tests/multidevices/snippet/RangingSnippet.java
rename to ranging/tests/multidevices/snippet/uwb/RangingSnippet.java
index 8b052300..d01399ae 100644
--- a/ranging/tests/multidevices/snippet/RangingSnippet.java
+++ b/ranging/tests/multidevices/snippet/uwb/RangingSnippet.java
@@ -19,13 +19,16 @@ package com.google.snippet.ranging;
 import android.app.UiAutomation;
 import android.content.Context;
 import android.net.ConnectivityManager;
+import android.net.wifi.WifiManager;
 import android.ranging.RangingCapabilities;
 import android.ranging.RangingData;
 import android.ranging.RangingDevice;
 import android.ranging.RangingManager;
 import android.ranging.RangingManager.RangingTechnology;
+import android.ranging.RangingMeasurement;
 import android.ranging.RangingPreference;
 import android.ranging.RangingSession;
+import android.ranging.oob.TransportHandle;
 import android.util.Log;
 
 import androidx.annotation.NonNull;
@@ -37,12 +40,18 @@ import com.google.android.mobly.snippet.event.SnippetEvent;
 import com.google.android.mobly.snippet.rpc.AsyncRpc;
 import com.google.android.mobly.snippet.rpc.Rpc;
 
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import java.lang.reflect.Method;
 import java.util.Map;
+import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Supplier;
 
 public class RangingSnippet implements Snippet {
     private static final String TAG = "GenericRangingSnippet";
@@ -52,12 +61,16 @@ public class RangingSnippet implements Snippet {
     private final Executor mExecutor = Executors.newSingleThreadExecutor();
     private final EventCache mEventCache = EventCache.getInstance();
     private final ConnectivityManager mConnectivityManager;
+    private final WifiManager mWifiManager;
     private final ConcurrentMap<String, RangingSessionInfo> mSessions;
     private final ConcurrentMap<Integer, Integer> mTechnologyAvailability;
+    private final AtomicReference<RangingCapabilities> mRangingCapabilities =
+            new AtomicReference<>();
 
     public RangingSnippet() {
         mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
         mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
+        mWifiManager = mContext.getSystemService(WifiManager.class);
         mRangingManager = mContext.getSystemService(RangingManager.class);
 
         mSessions = new ConcurrentHashMap<>();
@@ -95,7 +108,13 @@ public class RangingSnippet implements Snippet {
         STARTED,
         DATA,
         STOPPED,
-        CLOSED
+        CLOSED,
+        OOB_SEND_CAPABILITIES_REQUEST,
+        OOB_SEND_CAPABILITIES_RESPONSE,
+        OOB_SEND_SET_CONFIGURATION,
+        OOB_SEND_STOP_RANGING,
+        OOB_SEND_UNKNOWN,
+        OOB_CLOSED
     }
 
     private class RangingSessionCallback implements RangingSession.Callback {
@@ -122,16 +141,29 @@ public class RangingSnippet implements Snippet {
         public void onStarted(@NonNull RangingDevice peer, @RangingTechnology int technology) {
             Log.d(TAG, "onStarted");
             SnippetEvent event = new SnippetEvent(mCallbackId, Event.STARTED.toString());
-            event.getData().putString("peer", peer.getUuid().toString());
+            event.getData().putString("peer_id", peer.getUuid().toString());
             event.getData().putInt("technology", technology);
             mEventCache.postEvent(event);
         }
 
         @Override
         public void onResults(@NonNull RangingDevice peer, @NonNull RangingData data) {
-            Log.d(TAG, "onData");
+            Log.d(TAG, "onData { peer: " + peer.getUuid()
+                    + " Distance: " + data.getDistance()
+                    + " Azimuth: " + data.getAzimuth()
+                    + " Elevation: " + data.getElevation()
+                    + " RangingTechnology: " + data.getRangingTechnology()
+                    + " Timestamp: " + data.getTimestampMillis()
+                    + " hasRssi: " + data.hasRssi()
+                    + " getRssi: " + (data.hasRssi() ? data.getRssi() : "null")
+                    + " }");
+            RangingMeasurement distance = data.getDistance();
+            if (distance != null) {
+                Log.d(TAG, " Distance: " + distance.getMeasurement()
+                        + "  Confidence: " + distance.getConfidence());
+            }
             SnippetEvent event = new SnippetEvent(mCallbackId, Event.DATA.toString());
-            event.getData().putString("peer", peer.getUuid().toString());
+            event.getData().putString("peer_id", peer.getUuid().toString());
             event.getData().putInt("technology", data.getRangingTechnology());
             mEventCache.postEvent(event);
         }
@@ -140,7 +172,7 @@ public class RangingSnippet implements Snippet {
         public void onStopped(@NonNull RangingDevice peer, @RangingTechnology int technology) {
             Log.d(TAG, "onStopped");
             SnippetEvent event = new SnippetEvent(mCallbackId, Event.STOPPED.toString());
-            event.getData().putString("peer", peer.getUuid().toString());
+            event.getData().putString("peer_id", peer.getUuid().toString());
             event.getData().putInt("technology", technology);
             mEventCache.postEvent(event);
         }
@@ -152,13 +184,15 @@ public class RangingSnippet implements Snippet {
         }
     }
 
-    private static class RangingSessionInfo {
+    static class RangingSessionInfo {
         private final RangingSession mSession;
         private final RangingSessionCallback mCallback;
+        private final ConcurrentMap<RangingDevice, OobTransportImpl> mOobTransports;
 
         RangingSessionInfo(RangingSession session, RangingSessionCallback callback) {
             mSession = session;
             mCallback = callback;
+            mOobTransports = new ConcurrentHashMap<>();
         }
 
         public RangingSession getSession() {
@@ -168,24 +202,109 @@ public class RangingSnippet implements Snippet {
         public RangingSessionCallback getCallback() {
             return mCallback;
         }
+
     }
 
     private class AvailabilityListener implements RangingManager.RangingCapabilitiesCallback {
         @Override
         public void onRangingCapabilities(@NonNull RangingCapabilities capabilities) {
+            Log.d(TAG, " Ranging capabilities " + capabilities);
             Map<Integer, Integer> availabilities = capabilities.getTechnologyAvailability();
             mTechnologyAvailability.putAll(availabilities);
+            mRangingCapabilities.set(capabilities);
+        }
+    }
+
+
+    class OobTransportFactory {
+        private final String mCallbackId;
+        private final RangingSessionInfo mSessionInfo;
+
+        OobTransportFactory(String callbackId, RangingSessionInfo sessionInfo) {
+            mCallbackId = callbackId;
+            mSessionInfo = sessionInfo;
+        }
+
+        public OobTransportImpl createOobTransport(RangingDevice peer) {
+            OobTransportImpl transport = new OobTransportImpl(mCallbackId, peer);
+            mSessionInfo.mOobTransports.put(peer, transport);
+            return transport;
         }
     }
 
+    class OobTransportImpl implements TransportHandle {
+        private final String mCallbackId;
+        private final RangingDevice mPeer;
+        private ReceiveCallback mReceiveCallback;
+
+        OobTransportImpl(String callbackId, RangingDevice peer) {
+            mCallbackId = callbackId;
+            mPeer = peer;
+        }
+
+        private SnippetEvent getOobEvent(@NonNull byte[] data) {
+            int messageType = data[1];
+            switch (messageType) {
+                case 0:
+                    return new SnippetEvent(
+                            mCallbackId,
+                            Event.OOB_SEND_CAPABILITIES_REQUEST.toString());
+                case 1:
+                    return new SnippetEvent(
+                            mCallbackId,
+                            Event.OOB_SEND_CAPABILITIES_RESPONSE.toString());
+                case 2:
+                    return new SnippetEvent(
+                            mCallbackId,
+                            Event.OOB_SEND_SET_CONFIGURATION.toString());
+                case 6:
+                    return new SnippetEvent(
+                            mCallbackId,
+                            Event.OOB_SEND_STOP_RANGING.toString());
+                default:
+                    return new SnippetEvent(
+                            mCallbackId,
+                            Event.OOB_SEND_UNKNOWN.toString());
+            }
+        }
+        @Override
+        public void sendData(@NonNull byte[] data) {
+            SnippetEvent event = getOobEvent(data);
+            event.getData().putString("peer_id", mPeer.getUuid().toString());
+            event.getData().putByteArray("data", data);
+            mEventCache.postEvent(event);
+        }
+
+        @Override
+        public void registerReceiveCallback(
+                @NonNull Executor executor, @NonNull ReceiveCallback callback
+        ) {
+            mReceiveCallback = callback;
+        }
+
+        @Override
+        public void close() throws Exception {
+            Log.d(TAG, "TransportHandle close");
+            SnippetEvent event = new SnippetEvent(mCallbackId, Event.OOB_CLOSED.toString());
+            event.getData().putString("peer_id", mPeer.getUuid().toString());
+            mEventCache.postEvent(event);
+        }
+    }
 
     @AsyncRpc(description = "Start a ranging session")
     public void startRanging(
-            String callbackId, String sessionHandle, RangingPreference preference
-    ) {
+            String callbackId, String sessionHandle, JSONObject j
+    ) throws JSONException {
+
         RangingSessionCallback callback = new RangingSessionCallback(callbackId);
         RangingSession session = mRangingManager.createRangingSession(mExecutor, callback);
-        mSessions.put(sessionHandle, new RangingSessionInfo(session, callback));
+        RangingSessionInfo sessionInfo = new RangingSessionInfo(session, callback);
+        mSessions.put(sessionHandle, sessionInfo);
+
+        RangingPreference preference =
+                new RangingPreferenceConverter(new OobTransportFactory(callbackId, sessionInfo))
+                        .deserialize(j, RangingPreference.class);
+
         session.start(preference);
     }
 
@@ -198,6 +317,42 @@ public class RangingSnippet implements Snippet {
         }
     }
 
+    @Rpc(description = "Handle data received from a peer via OOB")
+    public void handleOobDataReceived(String sessionHandle, String peerId, byte[] data) {
+        mSessions.get(sessionHandle)
+                .mOobTransports.get(new RangingDevice.Builder()
+                        .setUuid(UUID.fromString(peerId))
+                        .build())
+                .mReceiveCallback.onReceiveData(data);
+    }
+
+    @Rpc(description = "Handle an OOB peer disconnecting")
+    public void handleOobPeerDisconnected(String sessionHandle, String peerId) {
+        mSessions.get(sessionHandle)
+                .mOobTransports.get(new RangingDevice.Builder()
+                        .setUuid(UUID.fromString(peerId))
+                        .build())
+                .mReceiveCallback.onDisconnect();
+    }
+
+    @Rpc(description = "Handle an OOB peer reconnecting")
+    public void handleOobPeerReconnect(String sessionHandle, String peerId) {
+        mSessions.get(sessionHandle)
+                .mOobTransports.get(new RangingDevice.Builder()
+                        .setUuid(UUID.fromString(peerId))
+                        .build())
+                .mReceiveCallback.onReconnect();
+    }
+
+    @Rpc(description = "Handle an OOB transport closing")
+    public void handleOobClosed(String sessionHandle, String peerId) {
+        mSessions.get(sessionHandle)
+                .mOobTransports.get(new RangingDevice.Builder()
+                        .setUuid(UUID.fromString(peerId))
+                        .build())
+                .mReceiveCallback.onClose();
+    }
+
     @Rpc(description = "Check whether the provided ranging technology is enabled")
     public boolean isTechnologyEnabled(int technology) {
         Integer availability = mTechnologyAvailability.get(technology);
@@ -212,11 +367,30 @@ public class RangingSnippet implements Snippet {
                 && availability != RangingCapabilities.NOT_SUPPORTED;
     }
 
+    @Rpc(description = "Check whether periodic RTT ranging technology is supported")
+    public boolean hasPeriodicRangingHwFeature() {
+        RangingCapabilities capabilities = mRangingCapabilities.get();
+        if (capabilities == null) {
+            return false;
+        }
+        return capabilities.getRttRangingCapabilities().hasPeriodicRangingHardwareFeature();
+    }
+
     @Rpc(description = "Set airplane mode")
     public void setAirplaneMode(boolean enabled) throws Throwable {
         runWithShellPermission(() -> mConnectivityManager.setAirplaneMode(enabled));
     }
 
+    @Rpc(description = "Set wifi mode")
+    public void setWifiEnabled(boolean enabled) throws Throwable {
+        runWithShellPermission(() -> mWifiManager.setWifiEnabled(enabled));
+    }
+
+    @Rpc(description = "Return wifi mode")
+    public boolean isWifiEnabled() throws Throwable {
+        return runWithShellPermission(() -> mWifiManager.isWifiEnabled());
+    }
+
     @Rpc(description = "Log info level message to device logcat")
     public void logInfo(String message) {
         Log.i(TAG, message);
@@ -230,4 +404,25 @@ public class RangingSnippet implements Snippet {
             dropShellPermission();
         }
     }
+
+    public <T> T runWithShellPermission(ThrowingSupplier<T> action) throws Throwable {
+        adoptShellPermission();
+        try {
+            return action.get();
+        } finally {
+            dropShellPermission();
+        }
+    }
+
+    /**
+     * Similar to {@link Supplier} but has {@code throws Exception}.
+     *
+     * @param <T> type of the value produced
+     */
+    public interface ThrowingSupplier<T> {
+        /**
+         * Similar to {@link Supplier#get} but has {@code throws Exception}.
+         */
+        T get() throws Exception;
+    }
 }
diff --git a/ranging/uwb_backend/Android.bp b/ranging/uwb_backend/Android.bp
index 105f1666..37fd70de 100644
--- a/ranging/uwb_backend/Android.bp
+++ b/ranging/uwb_backend/Android.bp
@@ -19,14 +19,16 @@ package {
 
 java_library {
     name: "ranging_uwb_backend",
-    sdk_version: "system_UpsideDownCake",
+    sdk_version: "system_current",
     min_sdk_version: "33",
     installable: false,
     srcs: [
         "src/**/*.java",
     ],
-    static_libs: [
+    libs: [
         "androidx.annotation_annotation",
+    ],
+    static_libs: [
         "androidx.concurrent_concurrent-futures",
         "com.uwb.support.fira",
         "com.uwb.support.multichip",
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java
index 097e07ec..2221b6ed 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java
@@ -22,6 +22,7 @@ import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_UNICAST_DS_TWR;
+import static com.android.ranging.uwb.backend.internal.Utils.RANGE_DATA_NTF_DISABLE;
 import static com.android.ranging.uwb.backend.internal.Utils.STATIC_STS_SESSION_KEY_INFO_SIZE;
 import static com.android.ranging.uwb.backend.internal.Utils.SUPPORTED_HPRF_PREAMBLE_INDEX;
 import static com.android.ranging.uwb.backend.internal.Utils.VENDOR_ID_SIZE;
@@ -356,8 +357,17 @@ public final class ConfigurationManager {
                         .setInBandTerminationAttemptCount(3)
                         .setStsConfig(configuration.getStsConfig())
                         .setRangingErrorStreakTimeoutMs(10_000L)
-                        .setHasRangingResultReportMessage(false)
-                        .setFilterType(FILTER_TYPE_NONE);
+                        .setFilterType(FILTER_TYPE_NONE)
+                        .setMaxNumberOfMeasurements(rangingParameters
+                                .getUwbRangeLimitsConfig().getRangeMaxNumberOfMeasurements())
+                        .setMaxRangingRoundRetries(rangingParameters
+                                .getUwbRangeLimitsConfig().getRangeMaxRangingRoundRetries());
+        // Turn off RRRM if the client does not want data notification.
+        if (rangingParameters
+                .getUwbRangeDataNtfConfig()
+                .getRangeDataNtfConfigType() == RANGE_DATA_NTF_DISABLE) {
+             builder.setHasRangingResultReportMessage(false);
+        }
 
         if (configuration.getStsConfig() == FiraParams.STS_CONFIG_STATIC) {
             byte[] staticStsIv =
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java
index d5de477a..ff20bb27 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java
@@ -25,7 +25,6 @@ import androidx.annotation.IntRange;
 
 import com.google.common.collect.ImmutableList;
 
-import java.util.ArrayList;
 import java.util.List;
 
 /** Describes UWB ranging capabilities for the current device. */
@@ -61,24 +60,27 @@ public class RangingCapabilities {
     private final List<Integer> mSupportedRangingUpdateRates;
     private final List<Integer> mSupportedPreambleIndexes;
     private final boolean mHasBackgroundRangingSupport;
+    private final String mCountryCode;
 
     public RangingCapabilities(
             boolean supportsDistance,
             boolean supportsAzimuthalAngle,
-            boolean supportsElevationAngle) {
+            boolean supportsElevationAngle,
+            String countryCode) {
         this(
                 supportsDistance,
                 supportsAzimuthalAngle,
                 supportsElevationAngle,
                 DEFAULT_SUPPORTS_RANGING_INTERVAL_RECONFIGURE,
                 FIRA_DEFAULT_RANGING_INTERVAL_MS,
-                new ArrayList<>(FIRA_DEFAULT_SUPPORTED_CHANNEL),
-                new ArrayList<>(RANGE_DATA_NTF_ENABLE),
+                List.of(FIRA_DEFAULT_SUPPORTED_CHANNEL),
+                List.of(RANGE_DATA_NTF_ENABLE),
                 FIRA_DEFAULT_SUPPORTED_CONFIG_IDS,
                 DEFAULT_SUPPORTED_SLOT_DURATIONS,
                 DEFAULT_SUPPORTED_RANGING_UPDATE_RATE,
                 SUPPORTED_BPRF_PREAMBLE_INDEX,
-                false);
+                false,
+                countryCode);
     }
 
     public RangingCapabilities(
@@ -93,7 +95,8 @@ public class RangingCapabilities {
             ImmutableList<Integer> supportedSlotDurations,
             ImmutableList<Integer> supportedRangingUpdateRates,
             ImmutableList<Integer> supportedPreambleIndexes,
-            boolean hasBackgroundRangingSupport) {
+            boolean hasBackgroundRangingSupport,
+            String countryCode) {
         this.mSupportsDistance = supportsDistance;
         this.mSupportsAzimuthalAngle = supportsAzimuthalAngle;
         this.mSupportsElevationAngle = supportsElevationAngle;
@@ -106,6 +109,7 @@ public class RangingCapabilities {
         this.mSupportedRangingUpdateRates = supportedRangingUpdateRates;
         this.mSupportedPreambleIndexes = supportedPreambleIndexes;
         this.mHasBackgroundRangingSupport = hasBackgroundRangingSupport;
+        this.mCountryCode = countryCode;
     }
 
     /** Whether distance ranging is supported. */
@@ -170,4 +174,9 @@ public class RangingCapabilities {
     public boolean hasBackgroundRangingSupport() {
         return mHasBackgroundRangingSupport;
     }
+
+    /** 2-letter ISO 3166 country code currently being used */
+    public String getCountryCode() {
+        return mCountryCode;
+    }
 }
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControlee.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControlee.java
index 18c17aa1..0a6b191e 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControlee.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControlee.java
@@ -26,13 +26,13 @@ import androidx.annotation.RequiresApi;
 import com.google.uwb.support.fira.FiraOpenSessionParams;
 import com.google.uwb.support.fira.FiraParams;
 
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 
 /** Represents a UWB ranging controlee. */
 @RequiresApi(api = VERSION_CODES.S)
 public class RangingControlee extends RangingDevice {
 
-    RangingControlee(UwbManager manager, Executor executor,
+    RangingControlee(UwbManager manager, ExecutorService executor,
             OpAsyncCallbackRunner<Boolean> opAsyncCallbackRunner, UwbFeatureFlags uwbFeatureFlags) {
         super(manager, executor, opAsyncCallbackRunner, uwbFeatureFlags);
     }
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java
index c4638a3b..a04c4d3d 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java
@@ -16,8 +16,8 @@
 
 package com.android.ranging.uwb.backend.internal;
 
-import static com.android.ranging.uwb.backend.internal.RangingSessionCallback.REASON_FAILED_TO_START;
-import static com.android.ranging.uwb.backend.internal.RangingSessionCallback.REASON_STOP_RANGING_CALLED;
+import static com.android.ranging.uwb.backend.internal.RangingSessionCallback.PeerDisconnectedReason.FAILED_TO_ADD_CONTROLEE;
+import static com.android.ranging.uwb.backend.internal.RangingSessionCallback.PeerDisconnectedReason.LOCAL_DEVICE_REQUEST;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR;
 import static com.android.ranging.uwb.backend.internal.Utils.INVALID_API_CALL;
 import static com.android.ranging.uwb.backend.internal.Utils.STATUS_OK;
@@ -45,7 +45,6 @@ import com.google.uwb.support.fira.FiraParams;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
-import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 
 /** Represents a UWB ranging controller */
@@ -57,7 +56,7 @@ public class RangingController extends RangingDevice {
     @Nullable
     private RangingSessionCallback mRangingSessionCallback;
 
-    RangingController(UwbManager manager, Executor executor,
+    RangingController(UwbManager manager, ExecutorService executor,
             OpAsyncCallbackRunner<Boolean> opAsyncCallbackRunner, UwbFeatureFlags uwbFeatureFlags) {
         super(manager, executor, opAsyncCallbackRunner, uwbFeatureFlags);
     }
@@ -118,8 +117,7 @@ public class RangingController extends RangingDevice {
     }
 
     @Override
-    public synchronized int startRanging(
-            RangingSessionCallback callback, ExecutorService backendCallbackExecutor) {
+    public synchronized int startRanging(RangingSessionCallback callback) {
         requireNonNull(mRangingParameters);
         if (mComplexChannel == null) {
             Log.w(TAG, "Need to call getComplexChannel() first");
@@ -136,7 +134,7 @@ public class RangingController extends RangingDevice {
             return INVALID_API_CALL;
         }
 
-        int status = super.startRanging(callback, backendCallbackExecutor);
+        int status = super.startRanging(callback);
         if (isAlive()) {
             mRangingSessionCallback = callback;
         }
@@ -189,7 +187,7 @@ public class RangingController extends RangingDevice {
             if (callback != null) {
                 runOnBackendCallbackThread(
                         () ->
-                                callback.onRangingInitialized(
+                                callback.onPeerConnected(
                                         UwbDevice.createForAddress(controleeAddress.toBytes())));
             }
             mDynamicallyAddedPeers.add(controleeAddress);
@@ -197,9 +195,9 @@ public class RangingController extends RangingDevice {
             if (callback != null) {
                 runOnBackendCallbackThread(
                         () ->
-                                callback.onRangingSuspended(
+                                callback.onPeerDisconnected(
                                         UwbDevice.createForAddress(controleeAddress.toBytes()),
-                                        REASON_FAILED_TO_START));
+                                        FAILED_TO_ADD_CONTROLEE));
             }
         }
 
@@ -245,7 +243,7 @@ public class RangingController extends RangingDevice {
             if (callback != null) {
                 runOnBackendCallbackThread(
                         () ->
-                                callback.onRangingInitialized(
+                                callback.onPeerConnected(
                                         UwbDevice.createForAddress(controleeAddress.toBytes())));
             }
             mDynamicallyAddedPeers.add(controleeAddress);
@@ -253,9 +251,9 @@ public class RangingController extends RangingDevice {
             if (callback != null) {
                 runOnBackendCallbackThread(
                         () ->
-                                callback.onRangingSuspended(
+                                callback.onPeerDisconnected(
                                         UwbDevice.createForAddress(controleeAddress.toBytes()),
-                                        REASON_FAILED_TO_START));
+                                        FAILED_TO_ADD_CONTROLEE));
             }
         }
 
@@ -324,9 +322,9 @@ public class RangingController extends RangingDevice {
         if (callback != null) {
             runOnBackendCallbackThread(
                     () ->
-                            callback.onRangingSuspended(
+                            callback.onPeerDisconnected(
                                     UwbDevice.createForAddress(controleeAddress.toBytes()),
-                                    REASON_STOP_RANGING_CALLED));
+                                    LOCAL_DEVICE_REQUEST));
         }
         mDynamicallyAddedPeers.remove(controleeAddress);
         return STATUS_OK;
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java
index 9dd32411..cd6698a4 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java
@@ -79,11 +79,10 @@ public abstract class RangingDevice {
     protected RangingParameters mRangingParameters;
 
     /** A serial thread used by System API to handle session callbacks. */
-    private Executor mSystemCallbackExecutor;
+    private final Executor mSystemCallbackExecutor;
 
     /** A serial thread used in system API callbacks to handle Backend callbacks */
-    @Nullable
-    private ExecutorService mBackendCallbackExecutor;
+    private final ExecutorService mBackendCallbackExecutor;
 
     /** NotNull when session opening is successful. Set to Null when session is closed. */
     @Nullable
@@ -107,15 +106,29 @@ public abstract class RangingDevice {
 
     private final HashMap<String, UwbAddress> mMultiChipMap;
 
-    RangingDevice(UwbManager manager, Executor executor,
+    private UwbRangeDataNtfConfig mLastNtfConfig;
+    private final boolean mIsHwTurnOffEnabled;
+
+    RangingDevice(UwbManager manager, ExecutorService executor,
             OpAsyncCallbackRunner<Boolean> opAsyncCallbackRunner, UwbFeatureFlags uwbFeatureFlags) {
         mUwbManager = manager;
         this.mSystemCallbackExecutor = executor;
         mOpAsyncCallbackRunner = opAsyncCallbackRunner;
         mOpAsyncCallbackRunner.setOperationTimeoutMillis(RANGING_START_TIMEOUT_MILLIS);
+        mBackendCallbackExecutor = executor;
         mUwbFeatureFlags = uwbFeatureFlags;
         this.mMultiChipMap = new HashMap<>();
         initializeUwbAddress();
+        mLastNtfConfig = new UwbRangeDataNtfConfig.Builder().build();
+        if (VERSION.SDK_INT < VERSION_CODES.VANILLA_ICE_CREAM) {
+            mIsHwTurnOffEnabled = false;
+        } else {
+            mIsHwTurnOffEnabled = manager.isUwbHwIdleTurnOffEnabled();
+        }
+    }
+
+    public boolean isHwTurnOffEnabled() {
+        return mIsHwTurnOffEnabled;
     }
 
     /** Sets the chip ID. By default, the default chip is used. */
@@ -196,7 +209,8 @@ public abstract class RangingDevice {
                             rangingParameters.getRangingUpdateRate(),
                             rangingParameters.getUwbRangeDataNtfConfig(),
                             rangingParameters.getSlotDuration(),
-                            rangingParameters.isAoaDisabled());
+                            rangingParameters.isAoaDisabled(),
+                            rangingParameters.getUwbRangeLimitsConfig());
         } else {
             mRangingParameters = rangingParameters;
         }
@@ -289,7 +303,7 @@ public abstract class RangingDevice {
             @Override
             public void onOpened(RangingSession session) {
                 mRangingSession = session;
-                mOpAsyncCallbackRunner.complete(true);
+                mOpAsyncCallbackRunner.completeIfActive(true);
             }
 
             @WorkerThread
@@ -404,7 +418,7 @@ public abstract class RangingDevice {
             @WorkerThread
             @Override
             public void onControleeAdded(PersistableBundle params) {
-                mOpAsyncCallbackRunner.complete(true);
+                mOpAsyncCallbackRunner.completeIfActive(true);
             }
 
             @WorkerThread
@@ -474,8 +488,7 @@ public abstract class RangingDevice {
      * RangingSessionCallback#REASON_FAILED_TO_START}
      */
     @Utils.UwbStatusCodes
-    public synchronized int startRanging(
-            RangingSessionCallback callback, ExecutorService backendCallbackExecutor) {
+    public synchronized int startRanging(RangingSessionCallback callback) {
         if (isAlive()) {
             return RANGING_ALREADY_STARTED;
         }
@@ -484,9 +497,9 @@ public abstract class RangingDevice {
             return INVALID_API_CALL;
         }
 
+        mLastNtfConfig = mRangingParameters.getUwbRangeDataNtfConfig();
         FiraOpenSessionParams openSessionParams = getOpenSessionParams();
         printStartRangingParameters(openSessionParams.toBundle());
-        mBackendCallbackExecutor = backendCallbackExecutor;
         boolean success =
                 mOpAsyncCallbackRunner.execOperation(
                         () -> {
@@ -507,9 +520,6 @@ public abstract class RangingDevice {
 
         Boolean result = mOpAsyncCallbackRunner.getResult();
         if (!success || result == null || !result) {
-            requireNonNull(mBackendCallbackExecutor);
-            mBackendCallbackExecutor.shutdown();
-            mBackendCallbackExecutor = null;
             // onRangingSuspended should have been called in the callback.
             return STATUS_OK;
         }
@@ -535,11 +545,7 @@ public abstract class RangingDevice {
                         () -> mRangingSession.start(new PersistableBundle()), "Start ranging");
 
         result = mOpAsyncCallbackRunner.getResult();
-        requireNonNull(mBackendCallbackExecutor);
-        if (!success || result == null || !result) {
-            mBackendCallbackExecutor.shutdown();
-            mBackendCallbackExecutor = null;
-        } else {
+        if (success && result != null && result) {
             mRangingReportedAllowed = true;
         }
         return STATUS_OK;
@@ -563,10 +569,6 @@ public abstract class RangingDevice {
                 mOpAsyncCallbackRunner.execOperation(
                         () -> requireNonNull(mRangingSession).close(), "Close Session");
 
-        if (mBackendCallbackExecutor != null) {
-            mBackendCallbackExecutor.shutdown();
-            mBackendCallbackExecutor = null;
-        }
         mLocalAddress = null;
         mComplexChannel = null;
         Boolean result = mOpAsyncCallbackRunner.getResult();
@@ -637,6 +639,10 @@ public abstract class RangingDevice {
             return INVALID_API_CALL;
         }
 
+        if (mLastNtfConfig.equals(config)) {
+            return STATUS_OK;
+        }
+
         boolean success =
                 reconfigureRanging(
                         ConfigurationManager.createReconfigureParamsRangeDataNtf(
@@ -646,6 +652,7 @@ public abstract class RangingDevice {
             Log.w(TAG, "Reconfiguring range data notification config failed.");
             return UWB_RECONFIGURATION_FAILURE;
         }
+        mLastNtfConfig = config;
         return STATUS_OK;
     }
 
@@ -660,9 +667,4 @@ public abstract class RangingDevice {
             @Nullable RangingRoundFailureCallback rangingRoundFailureCallback) {
         this.mRangingRoundFailureCallback = rangingRoundFailureCallback;
     }
-
-    /** Sets the system callback executor. */
-    public void setSystemCallbackExecutor(Executor executor) {
-        this.mSystemCallbackExecutor = executor;
-    }
 }
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingParameters.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingParameters.java
index 1955d8cf..68527b0d 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingParameters.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingParameters.java
@@ -17,6 +17,7 @@
 package com.android.ranging.uwb.backend.internal;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import com.google.common.collect.ImmutableList;
 
@@ -39,6 +40,8 @@ public class RangingParameters {
     @Utils.SlotDuration
     private final int mSlotDuration;
     private final boolean mIsAoaDisabled;
+    @Nullable
+    private final UwbRangeLimitsConfig mRangeLimitsConfig;
 
     public RangingParameters(
             @Utils.UwbConfigId int uwbConfigId,
@@ -51,7 +54,8 @@ public class RangingParameters {
             @Utils.RangingUpdateRate int rangingUpdateRate,
             @NonNull UwbRangeDataNtfConfig uwbRangeDataNtfConfig,
             @Utils.SlotDuration int slotDuration,
-            boolean isAoaDisabled) {
+            boolean isAoaDisabled,
+            @Nullable UwbRangeLimitsConfig rangeLimitsConfig) {
         mUwbConfigId = uwbConfigId;
         mSessionId = sessionId;
         mSubSessionId = subSessionId;
@@ -63,6 +67,7 @@ public class RangingParameters {
         mUwbRangeDataNtfConfig = uwbRangeDataNtfConfig;
         mSlotDuration = slotDuration;
         mIsAoaDisabled = isAoaDisabled;
+        mRangeLimitsConfig = rangeLimitsConfig;
     }
 
     public int getSessionId() {
@@ -110,4 +115,9 @@ public class RangingParameters {
     public boolean isAoaDisabled() {
         return mIsAoaDisabled;
     }
+
+    @Nullable
+    public UwbRangeLimitsConfig getUwbRangeLimitsConfig() {
+        return mRangeLimitsConfig;
+    }
 }
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java
index 2934b08c..3889fb4a 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java
@@ -33,6 +33,9 @@ public interface RangingSessionCallback {
     /** Callback when a peer disconnects from the session. */
     void onPeerDisconnected(UwbDevice peer, @PeerDisconnectedReason int reason);
 
+    /** Callback when a peer was added to the session. */
+    void onPeerConnected(UwbDevice peer);
+
     /** Reason why ranging was stopped. */
     @IntDef({
             REASON_UNKNOWN,
@@ -57,10 +60,14 @@ public interface RangingSessionCallback {
     /** Reason why peer disconnected. */
     @IntDef({
             PeerDisconnectedReason.UNKNOWN,
+            PeerDisconnectedReason.LOCAL_DEVICE_REQUEST,
             PeerDisconnectedReason.SYSTEM_POLICY,
+            PeerDisconnectedReason.FAILED_TO_ADD_CONTROLEE,
     })
     @interface PeerDisconnectedReason {
         int UNKNOWN = 0;
-        int SYSTEM_POLICY = 1;
+        int LOCAL_DEVICE_REQUEST = 1;
+        int SYSTEM_POLICY = 2;
+        int FAILED_TO_ADD_CONTROLEE = 3;
     }
 }
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java
index a3ce196f..b5b8adb5 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java
@@ -299,7 +299,7 @@ public final class Utils {
     // Preamble index used by HPRF (high pulse repetition frequency) mode. HPRF supports bitrate up
     // to 31.2 Mbps.
     public static final ImmutableList<Integer> SUPPORTED_HPRF_PREAMBLE_INDEX =
-            ImmutableList.of(25, 26, 27, 28, 19, 30, 31, 32);
+            ImmutableList.of(25, 26, 27, 28, 29, 30, 31, 32);
 
     /** Converts millisecond to RSTU. */
     public static int convertMsToRstu(int value) {
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAddress.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAddress.java
index 72ab9fe1..418dc18e 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAddress.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAddress.java
@@ -22,6 +22,7 @@ import androidx.annotation.Nullable;
 import com.google.common.base.Objects;
 import com.google.common.primitives.Longs;
 import com.google.common.primitives.Shorts;
+import com.google.uwb.support.fira.FiraParams;
 
 import java.security.SecureRandom;
 import java.util.Arrays;
@@ -96,7 +97,9 @@ public class UwbAddress {
 
     private static byte[] generateRandomByteArray(int len, SecureRandom secureRandom) {
         byte[] bytes = new byte[len];
-        secureRandom.nextBytes(bytes);
+        do {
+            secureRandom.nextBytes(bytes);
+        } while (isForbiddenAddress(bytes));
         return bytes;
     }
 
@@ -112,6 +115,14 @@ public class UwbAddress {
         return fromBytes(generateRandomByteArray(EXTENDED_ADDRESS_LENGTH, secureRandom));
     }
 
+    private static boolean isForbiddenAddress(byte[] address) {
+        if (address.length == SHORT_ADDRESS_LENGTH) {
+            return Arrays.equals(address, FiraParams.getShortForbiddenAddress());
+        } else {
+            return Arrays.equals(address, FiraParams.getExtendedForbiddenAddress());
+        }
+    }
+
     public AddressingMode getAddressingMode() {
         return mAddressingMode;
     }
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbHwSwitchHelper.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbHwSwitchHelper.java
new file mode 100644
index 00000000..53269274
--- /dev/null
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbHwSwitchHelper.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.uwb.backend.internal;
+
+import static android.uwb.UwbManager.AdapterStateCallback.STATE_ENABLED_HW_IDLE;
+
+import android.annotation.SuppressLint;
+import android.content.AttributionSource;
+import android.content.Context;
+import android.content.ContextParams;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.util.Log;
+import android.uwb.UwbManager;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Helper class for enabling or disabling UWB hardware. Each client can vote to have the UWB
+ * hardware enabled or disabled. If there are no enable votes from any client, then the hardware
+ * will be disabled to conserve power.
+ *
+ * <p>Since most of the clients are coming directly from GMSCore, a distinct attribution tag has to
+ * be provided to correctly identify between different callers.
+ */
+public final class UwbHwSwitchHelper {
+
+    private UwbHwSwitchHelper() {
+    }
+
+    private static final String TAG = UwbHwSwitchHelper.class.getSimpleName();
+    private static final long TIMEOUT_MS = 2_000;
+
+    private static ExecutorService sHwToggleExecutorService;
+
+    /**
+     * Requests UWB hardware to be enabled.
+     *
+     * <p>Note: This call will block if the UWB hardware needs to be brought up from "hw_idle"
+     * state.
+     *
+     * @param attributionSource attribution tag used to identify the caller setting the enable vote.
+     * @return true if vote was successful, false otherwise.
+     */
+    public static boolean enable(Context context, AttributionSource attributionSource) {
+        return toggleUwbHw(context, attributionSource, true);
+    }
+
+    /**
+     * Requests UWB hardware to be disabled.
+     *
+     * @param attributionSource attribution tag used to identify the caller setting the disable
+     *                          vote.
+     * @return true if vote was successful, false otherwise.
+     */
+    public static boolean disable(Context context, AttributionSource attributionSource) {
+        return toggleUwbHw(context, attributionSource, false);
+    }
+
+    private static class AdapterStateCallback implements UwbManager.AdapterStateCallback {
+        private final CountDownLatch mCountDownLatch;
+        private final Integer mWaitForState;
+
+        AdapterStateCallback(CountDownLatch countDownLatch, Integer waitForState) {
+            mCountDownLatch = countDownLatch;
+            mWaitForState = waitForState;
+        }
+
+        @Override
+        public void onStateChanged(int state, int reason) {
+            Log.v(TAG, "Uwb adapter state = " + state + " reason = " + reason);
+            if (mWaitForState != null) {
+                if (mWaitForState == state) {
+                    mCountDownLatch.countDown();
+                }
+            } else {
+                mCountDownLatch.countDown();
+            }
+        }
+    }
+
+    @SuppressLint("MissingPermission")
+    private static boolean toggleUwbHw(Context context, AttributionSource attributionSource,
+            boolean enable) {
+        if (sHwToggleExecutorService == null) {
+            sHwToggleExecutorService = Executors.newSingleThreadExecutor();
+        }
+        // TODO: Remove after updating min version to 35
+        if (VERSION.SDK_INT < VERSION_CODES.VANILLA_ICE_CREAM) {
+            return true;
+        }
+        Context contextWithAttrSource =
+                context.createContext(
+                        new ContextParams.Builder()
+                                .setNextAttributionSource(attributionSource)
+                                .build());
+        UwbManager uwbManagerWithAttrSource =
+                contextWithAttrSource.getSystemService(UwbManager.class);
+        int prevState = uwbManagerWithAttrSource.getAdapterState();
+        if (prevState == UwbManager.AdapterStateCallback.STATE_DISABLED) {
+            Log.w(TAG, "User has disabled UWB");
+            return false;
+        }
+        AdapterStateCallback adapterStateCallback = null;
+        CountDownLatch countDownLatch = new CountDownLatch(1);
+        try {
+            boolean isHwIdleTurnOffEnabled = uwbManagerWithAttrSource
+                    .isUwbHwIdleTurnOffEnabled();
+            if (!isHwIdleTurnOffEnabled) {
+                Log.w(TAG, "Device does not support hw_idle turn off");
+                return false;
+            }
+            // If the state is in hw_idle, then wait for the request to turn the hardware on.
+            if (prevState == STATE_ENABLED_HW_IDLE) {
+                adapterStateCallback =
+                        new AdapterStateCallback(
+                                countDownLatch,
+                                UwbManager.AdapterStateCallback.STATE_ENABLED_INACTIVE);
+                uwbManagerWithAttrSource.registerAdapterStateCallback(
+                        sHwToggleExecutorService, adapterStateCallback);
+            }
+            uwbManagerWithAttrSource.requestUwbHwEnabled(enable);
+            if (prevState == STATE_ENABLED_HW_IDLE) {
+                if (!countDownLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
+                    Log.w(TAG, "Failed to toggle UWB hardware");
+                    return false;
+                }
+            }
+        } catch (IllegalArgumentException
+                 | InterruptedException e) {
+            Log.w(TAG, "Failed to toggle UWB hardware");
+            return false;
+        } finally {
+            if (prevState == STATE_ENABLED_HW_IDLE) {
+                final AdapterStateCallback finalAdapterStateCb = adapterStateCallback;
+                sHwToggleExecutorService.execute(() ->
+                        uwbManagerWithAttrSource.unregisterAdapterStateCallback(
+                                finalAdapterStateCb));
+            }
+        }
+        return true;
+    }
+}
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbRangeLimitsConfig.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbRangeLimitsConfig.java
new file mode 100644
index 00000000..038c4f34
--- /dev/null
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbRangeLimitsConfig.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.uwb.backend.internal;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import java.util.Objects;
+
+import javax.annotation.Nonnegative;
+
+/** Configurable range duration limits for a UWB session. */
+public final class UwbRangeLimitsConfig {
+
+    public static final int UWB_PARAM_DISABLED = 0;
+    public static final int UWB_PARAM_UPPER_LIMIT = 65535;
+
+    private final int mRangeMaxNumberOfMeasurements;
+    private final int mRangeMaxRangingRoundRetries;
+
+    private UwbRangeLimitsConfig(
+            @Nonnegative int rangeMaxNumberOfMeasurements,
+            @Nonnegative int rangeMaxRangingRoundRetries) {
+        checkArgument(
+                rangeMaxNumberOfMeasurements <= UWB_PARAM_UPPER_LIMIT,
+                "Uwb Range Max Number of Measurements %s should be less than %s",
+                rangeMaxNumberOfMeasurements,
+                UWB_PARAM_UPPER_LIMIT);
+        checkArgument(
+                rangeMaxRangingRoundRetries <= UWB_PARAM_UPPER_LIMIT,
+                "UWB Range Max Ranging Round Retries should be less than and %s",
+                UWB_PARAM_UPPER_LIMIT);
+
+        this.mRangeMaxNumberOfMeasurements = rangeMaxNumberOfMeasurements;
+        this.mRangeMaxRangingRoundRetries = rangeMaxRangingRoundRetries;
+    }
+
+    public int getRangeMaxNumberOfMeasurements() {
+        return mRangeMaxNumberOfMeasurements;
+    }
+
+    public int getRangeMaxRangingRoundRetries() {
+        return mRangeMaxRangingRoundRetries;
+    }
+
+    /** Creates a new instance of {@link UwbRangeLimitsConfig}. */
+    public static class Builder {
+        private int mRangeMaxNumberOfMeasurements = UWB_PARAM_DISABLED;
+        private int mRangeMaxRangingRoundRetries = UWB_PARAM_DISABLED;
+
+        public Builder setRangeMaxNumberOfMeasurements(int rangeMaxNumberOfMeasurements) {
+            mRangeMaxNumberOfMeasurements = rangeMaxNumberOfMeasurements;
+            return this;
+        }
+
+        public Builder setRangeMaxRangingRoundRetries(int rangeMaxRangingRoundRetries) {
+            mRangeMaxRangingRoundRetries = rangeMaxRangingRoundRetries;
+            return this;
+        }
+
+        public UwbRangeLimitsConfig build() {
+            return new UwbRangeLimitsConfig(mRangeMaxNumberOfMeasurements,
+                    mRangeMaxRangingRoundRetries);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "UwbRangeLimitsConfig{"
+                + "rangeMaxNumberOfMeasurements="
+                + mRangeMaxNumberOfMeasurements
+                + ", rangeMaxRangingRoundRetries="
+                + mRangeMaxRangingRoundRetries
+                + '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof UwbRangeLimitsConfig)) {
+            return false;
+        }
+        UwbRangeLimitsConfig that = (UwbRangeLimitsConfig) o;
+        return mRangeMaxNumberOfMeasurements == that.mRangeMaxNumberOfMeasurements
+                && mRangeMaxRangingRoundRetries == that.mRangeMaxRangingRoundRetries;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mRangeMaxNumberOfMeasurements, mRangeMaxRangingRoundRetries);
+    }
+}
+
diff --git a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java
index 96dd027c..e904e836 100644
--- a/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java
@@ -38,6 +38,7 @@ import android.content.Context;
 import android.os.Build.VERSION;
 import android.os.Build.VERSION_CODES;
 import android.os.PersistableBundle;
+import android.util.Log;
 import android.uwb.UwbManager;
 
 import androidx.annotation.NonNull;
@@ -54,12 +55,12 @@ import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
-import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 /** Implements UWB session creation, adaptor state tracking and ranging capability reporting. */
 public class UwbServiceImpl {
+    private static final String TAG = UwbServiceImpl.class.getSimpleName();
 
     private static final String FIRA_SPECIFICATION_BUNDLE_KEY = "fira";
 
@@ -115,14 +116,14 @@ public class UwbServiceImpl {
     }
 
     /** Gets a Ranging Controller session with given context. */
-    public static RangingController getController(Context context, Executor executor) {
+    public static RangingController getController(Context context, ExecutorService executor) {
         UwbManager uwbManagerWithContext = context.getSystemService(UwbManager.class);
         return new RangingController(uwbManagerWithContext, executor,
                 new OpAsyncCallbackRunner<>(), FEATURE_FLAGS);
     }
 
     /** Gets a Ranging Controlee session with given context. */
-    public static RangingControlee getControlee(Context context, Executor executor) {
+    public static RangingControlee getControlee(Context context, ExecutorService executor) {
         UwbManager uwbManagerWithContext = context.getSystemService(UwbManager.class);
         return new RangingControlee(uwbManagerWithContext, executor,
                 new OpAsyncCallbackRunner<>(), FEATURE_FLAGS);
@@ -176,19 +177,22 @@ public class UwbServiceImpl {
             bundle = mUwbManager.getSpecificationInfo();
         }
         if (bundle.isEmpty()) {
+            Log.e(TAG, "Received empty bundle from uwb framework get specification info. Setting "
+                    + "capabilities to default that may be incomplete/incorrect");
             return new RangingCapabilities(
                     /* supportsDistance= */ true,
                     mUwbFeatureFlags.hasAzimuthSupport(),
                     mUwbFeatureFlags.hasElevationSupport(),
                     /* supportsRangingIntervalReconfigure */ false,
                     /* minRangingInterval= */ RangingCapabilities.FIRA_DEFAULT_RANGING_INTERVAL_MS,
-                    new ArrayList<Integer>(RangingCapabilities.FIRA_DEFAULT_SUPPORTED_CHANNEL),
-                    new ArrayList<>(RANGE_DATA_NTF_ENABLE),
+                    List.of(RangingCapabilities.FIRA_DEFAULT_SUPPORTED_CHANNEL),
+                    List.of(RANGE_DATA_NTF_ENABLE),
                     FIRA_DEFAULT_SUPPORTED_CONFIG_IDS,
                     DEFAULT_SUPPORTED_SLOT_DURATIONS,
                     DEFAULT_SUPPORTED_RANGING_UPDATE_RATE,
                     SUPPORTED_BPRF_PREAMBLE_INDEX,
-                    /* hasBackgroundRangingSupport */ false);
+                    /* hasBackgroundRangingSupport */ false,
+                    "00");
         }
 
         if (bundle.keySet().contains(FIRA_SPECIFICATION_BUNDLE_KEY)) {
@@ -207,9 +211,9 @@ public class UwbServiceImpl {
         if (minRangingInterval <= 120) {
             supportedRangingUpdateRates.add(Utils.FAST);
         }
+
         if (supportedChannels == null || supportedChannels.isEmpty()) {
-            supportedChannels =
-                    new ArrayList<>(RangingCapabilities.FIRA_DEFAULT_SUPPORTED_CHANNEL);
+            supportedChannels = List.of(RangingCapabilities.FIRA_DEFAULT_SUPPORTED_CHANNEL);
         }
 
         Set<Integer> supportedNtfConfigsSet = new TreeSet<>();
@@ -260,16 +264,8 @@ public class UwbServiceImpl {
                 ImmutableList.copyOf(supportedSlotDurations),
                 ImmutableList.copyOf(supportedRangingUpdateRates),
                 ImmutableList.copyOf(supportedPreambleIndexes),
-                specificationParams.hasBackgroundRangingSupport()
+                specificationParams.hasBackgroundRangingSupport(),
+                specificationParams.getCountryCode()
         );
     }
-
-    /**
-     * Update the callback executor of the given ranging device.
-     *
-     * <p>If previous service is shut down, the ranging device may hold a stale serial executor.
-     */
-    public void updateRangingDevice(RangingDevice device) {
-        device.setSystemCallbackExecutor(mSerialExecutor);
-    }
 }
diff --git a/ranging/uwb_backend/tests/Android.bp b/ranging/uwb_backend/tests/Android.bp
index 292d7b33..0136b004 100644
--- a/ranging/uwb_backend/tests/Android.bp
+++ b/ranging/uwb_backend/tests/Android.bp
@@ -20,12 +20,13 @@ package {
 }
 
 android_test {
-    name: "GenericRangingUwbBackendTests",
+    name: "RangingUwbBackendTests",
 
     srcs: [
         "**/*.java",
     ],
-
+    sdk_version: "system_server_current",
+    target_sdk_version: "36",
     dxflags: ["--multi-dex"],
 
     java_version: "1.9",
@@ -42,6 +43,7 @@ android_test {
         "com.uwb.support.multichip",
         "guava",
         "ranging_uwb_backend",
+        "framework-uwb.stubs.module_lib",
     ],
 
     libs: [
@@ -58,9 +60,8 @@ android_test {
     ],
     compile_multilib: "both",
 
-    min_sdk_version: "Tiramisu",
-
     test_suites: [
         "general-tests",
+        "mts-uwb",
     ],
 }
diff --git a/ranging/uwb_backend/tests/AndroidTest.xml b/ranging/uwb_backend/tests/AndroidTest.xml
index 1b3d722a..ac9475f8 100644
--- a/ranging/uwb_backend/tests/AndroidTest.xml
+++ b/ranging/uwb_backend/tests/AndroidTest.xml
@@ -16,14 +16,21 @@
   -->
 <configuration description="Tests for the generic ranging UWB backend">
     <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
-        <option name="test-file-name" value="GenericRangingUwbBackendTests.apk" />
+        <option name="test-file-name" value="RangingUwbBackendTests.apk" />
     </target_preparer>
 
     <option name="test-suite-tag" value="apct" />
-    <option name="test-tag" value="GenericRangingUwbBackendTests" />
+    <option name="test-tag" value="RangingUwbBackendTests" />
     <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
         <option name="package" value="com.android.ranging.uwb.backend" />
         <option name="runner" value="androidx.test.runner.AndroidJUnitRunner" />
         <option name="hidden-api-checks" value="false"/>
     </test>
+
+    <!-- Only run the tests in MTS if the Uwb Mainline module is installed. -->
+    <object type="module_controller"
+            class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.uwb" />
+    </object>
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk36ModuleController" />
 </configuration>
\ No newline at end of file
diff --git a/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/ConfigurationManagerTest.java b/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/ConfigurationManagerTest.java
index bc33086a..dd5abaff 100644
--- a/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/ConfigurationManagerTest.java
+++ b/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/ConfigurationManagerTest.java
@@ -87,7 +87,8 @@ public class ConfigurationManagerTest {
                         INFREQUENT,
                         mUwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
         when(mComplexChannel.getChannel()).thenReturn(1);
         when(mComplexChannel.getPreambleIndex()).thenReturn(1);
     }
@@ -118,7 +119,8 @@ public class ConfigurationManagerTest {
                         INFREQUENT,
                         mUwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
         FiraOpenSessionParams params =
                 ConfigurationManager.createOpenSessionParams(
                         TEST_DEVICE_TYPE, TEST_LOCAL_ADDRESS, rangingParameters,
diff --git a/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControleeTest.java b/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControleeTest.java
index 373f7bad..291b6de4 100644
--- a/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControleeTest.java
+++ b/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControleeTest.java
@@ -43,6 +43,7 @@ import android.uwb.UwbManager;
 import androidx.test.filters.SmallTest;
 import androidx.test.runner.AndroidJUnit4;
 
+import com.google.common.util.concurrent.MoreExecutors;
 import com.google.uwb.support.fira.FiraOpenSessionParams;
 import com.google.uwb.support.fira.FiraParams;
 
@@ -75,15 +76,6 @@ public class RangingControleeTest {
     private ArgumentCaptor<PersistableBundle> mBundleArgumentCaptor;
     private RangingControlee mRangingControlee;
 
-    private static Executor getExecutor() {
-        return new Executor() {
-            @Override
-            public void execute(Runnable command) {
-                command.run();
-            }
-        };
-    }
-
     private static class Mutable<E> {
         public E value;
     }
@@ -102,8 +94,8 @@ public class RangingControleeTest {
                 .execute(any(Runnable.class));
 
         mRangingControlee =
-                new RangingControlee(mUwbManager, getExecutor(), mOpAsyncCallbackRunner,
-                        new UwbFeatureFlags.Builder().build());
+                new RangingControlee(mUwbManager, MoreExecutors.newDirectExecutorService(),
+                        mOpAsyncCallbackRunner, new UwbFeatureFlags.Builder().build());
         UwbRangeDataNtfConfig uwbRangeDataNtfConfig =
                 new UwbRangeDataNtfConfig.Builder()
                         .setRangeDataConfigType(RANGE_DATA_NTF_DISABLE)
@@ -120,7 +112,8 @@ public class RangingControleeTest {
                         INFREQUENT,
                         uwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
         mRangingControlee.setRangingParameters(rangingParameters);
     }
 
@@ -142,12 +135,13 @@ public class RangingControleeTest {
                         INFREQUENT,
                         uwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
 
         mRangingControlee.setRangingParameters(rangingParameters);
 
         final RangingSessionCallback rangingSessionCallback = mock(RangingSessionCallback.class);
-        mRangingControlee.startRanging(rangingSessionCallback, mBackendCallbackExecutor);
+        mRangingControlee.startRanging(rangingSessionCallback);
 
         verify(mUwbManager).openRangingSession(mBundleArgumentCaptor.capture(), any(), any());
         assertEquals(
@@ -192,7 +186,7 @@ public class RangingControleeTest {
                 .start(any(PersistableBundle.class));
 
         assertEquals(
-                mRangingControlee.startRanging(rangingSessionCallback, mBackendCallbackExecutor),
+                mRangingControlee.startRanging(rangingSessionCallback),
                 STATUS_OK);
         verify(mUwbManager).openRangingSession(any(), any(), any());
         verify(pfRangingSession).start(any());
@@ -221,7 +215,7 @@ public class RangingControleeTest {
                         any(RangingSession.Callback.class));
 
         assertEquals(
-                mRangingControlee.startRanging(rangingSessionCallback, mBackendCallbackExecutor),
+                mRangingControlee.startRanging(rangingSessionCallback),
                 STATUS_OK);
         verify(rangingSessionCallback)
                 .onRangingSuspended(UwbDevice.createForAddress(deviceAddress.toBytes()),
@@ -258,7 +252,7 @@ public class RangingControleeTest {
                 .start(any(PersistableBundle.class));
 
         assertEquals(
-                mRangingControlee.startRanging(rangingSessionCallback, mBackendCallbackExecutor),
+                mRangingControlee.startRanging(rangingSessionCallback),
                 STATUS_OK);
         verify(mUwbManager).openRangingSession(any(), any(), any());
         verify(pfRangingSession).start(any());
@@ -315,8 +309,12 @@ public class RangingControleeTest {
                 .when(pfRangingSession)
                 .close();
 
-        mRangingControlee.startRanging(rangingSessionCallback, mBackendCallbackExecutor);
-        assertEquals(mRangingControlee.stopRanging(), STATUS_OK);
+        mRangingControlee.startRanging(rangingSessionCallback);
+        verify(mUwbManager).openRangingSession(any(), any(), any());
+        verify(pfRangingSession).start(any());
+        verify(rangingSessionCallback)
+                .onRangingInitialized(UwbDevice.createForAddress(deviceAddress.toBytes()));
+        mRangingControlee.stopRanging();
         verify(pfRangingSession).stop();
         verify(pfRangingSession).close();
         verify(rangingSessionCallback)
@@ -359,7 +357,7 @@ public class RangingControleeTest {
                 .when(pfRangingSession)
                 .reconfigure(any(PersistableBundle.class));
 
-        mRangingControlee.startRanging(rangingSessionCallback, mBackendCallbackExecutor);
+        mRangingControlee.startRanging(rangingSessionCallback);
         UwbRangeDataNtfConfig params = new UwbRangeDataNtfConfig.Builder()
                 .setRangeDataConfigType(RANGE_DATA_NTF_ENABLE_PROXIMITY_EDGE_TRIG)
                 .setNtfProximityNear(50)
diff --git a/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControllerTest.java b/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControllerTest.java
index a26213b3..11429ca2 100644
--- a/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControllerTest.java
+++ b/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControllerTest.java
@@ -16,6 +16,7 @@
 
 package com.android.ranging.uwb.backend.internal;
 
+import static com.android.ranging.uwb.backend.internal.RangingSessionCallback.PeerDisconnectedReason.LOCAL_DEVICE_REQUEST;
 import static com.android.ranging.uwb.backend.internal.RangingSessionCallback.REASON_FAILED_TO_START;
 import static com.android.ranging.uwb.backend.internal.RangingSessionCallback.REASON_STOP_RANGING_CALLED;
 import static com.android.ranging.uwb.backend.internal.RangingSessionCallback.REASON_UNKNOWN;
@@ -44,6 +45,7 @@ import android.uwb.UwbManager;
 import androidx.test.filters.SmallTest;
 import androidx.test.runner.AndroidJUnit4;
 
+import com.google.common.util.concurrent.MoreExecutors;
 import com.google.uwb.support.fira.FiraOpenSessionParams;
 import com.google.uwb.support.fira.FiraParams;
 
@@ -79,15 +81,6 @@ public class RangingControllerTest {
     private RangingController mRangingController;
     private UwbAddress mRangingParamsKnownPeerAddress;
 
-    private static Executor getExecutor() {
-        return new Executor() {
-            @Override
-            public void execute(Runnable command) {
-                command.run();
-            }
-        };
-    }
-
     private static class Mutable<E> {
         public E value;
     }
@@ -122,10 +115,11 @@ public class RangingControllerTest {
                         INFREQUENT,
                         uwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
         mRangingController =
-                new RangingController(mUwbManager, getExecutor(), mOpAsyncCallbackRunner,
-                        new UwbFeatureFlags.Builder().build());
+                new RangingController(mUwbManager, MoreExecutors.newDirectExecutorService(),
+                        mOpAsyncCallbackRunner, new UwbFeatureFlags.Builder().build());
         mRangingController.setRangingParameters(rangingParameters);
         mRangingController.setForTesting(true);
     }
@@ -171,12 +165,13 @@ public class RangingControllerTest {
                         INFREQUENT,
                         uwbRangeDataNtfConfig,
                         Utils.DURATION_2_MS,
-                        false);
+                        false,
+                        new UwbRangeLimitsConfig.Builder().build());
 
         mRangingController.setRangingParameters(rangingParameters);
 
         final RangingSessionCallback rangingSessionCallback = mock(RangingSessionCallback.class);
-        mRangingController.startRanging(rangingSessionCallback, mBackendCallbackExecutor);
+        mRangingController.startRanging(rangingSessionCallback);
 
         verify(mUwbManager).openRangingSession(mBundleArgumentCaptor.capture(), any(), any());
         assertEquals(
@@ -220,7 +215,7 @@ public class RangingControllerTest {
                 .start(any(PersistableBundle.class));
 
         assertEquals(
-                mRangingController.startRanging(rangingSessionCallback, mBackendCallbackExecutor),
+                mRangingController.startRanging(rangingSessionCallback),
                 STATUS_OK);
         verify(mUwbManager).openRangingSession(any(), any(), any());
         verify(pfRangingSession).start(any());
@@ -250,7 +245,7 @@ public class RangingControllerTest {
                         any(RangingSession.Callback.class));
 
         assertEquals(
-                mRangingController.startRanging(rangingSessionCallback, mBackendCallbackExecutor),
+                mRangingController.startRanging(rangingSessionCallback),
                 STATUS_OK);
         verify(rangingSessionCallback)
                 .onRangingSuspended(UwbDevice.createForAddress(deviceAddress.toBytes()),
@@ -288,7 +283,7 @@ public class RangingControllerTest {
                 .start(any(PersistableBundle.class));
 
         assertEquals(
-                mRangingController.startRanging(rangingSessionCallback, mBackendCallbackExecutor),
+                mRangingController.startRanging(rangingSessionCallback),
                 STATUS_OK);
         verify(mUwbManager).openRangingSession(any(), any(), any());
         verify(pfRangingSession).start(any());
@@ -347,8 +342,12 @@ public class RangingControllerTest {
                 .when(pfRangingSession)
                 .close();
 
-        mRangingController.startRanging(rangingSessionCallback, mBackendCallbackExecutor);
-        assertEquals(mRangingController.stopRanging(), STATUS_OK);
+        mRangingController.startRanging(rangingSessionCallback);
+        verify(mUwbManager).openRangingSession(any(), any(), any());
+        verify(pfRangingSession).start(any());
+        verify(rangingSessionCallback)
+                .onRangingInitialized(UwbDevice.createForAddress(deviceAddress.toBytes()));
+        mRangingController.stopRanging();
         verify(pfRangingSession).stop();
         verify(pfRangingSession).close();
         verify(rangingSessionCallback)
@@ -394,13 +393,13 @@ public class RangingControllerTest {
                 .when(pfRangingSession)
                 .addControlee(any(PersistableBundle.class));
 
-        mRangingController.startRanging(rangingSessionCallback, mBackendCallbackExecutor);
+        mRangingController.startRanging(rangingSessionCallback);
         assertEquals(mRangingController.addControleeWithSessionParams(
                 new RangingControleeParameters(
                         peerAddress, 0, null)), STATUS_OK);
         verify(pfRangingSession).addControlee(any(PersistableBundle.class));
         verify(rangingSessionCallback)
-                .onRangingInitialized(UwbDevice.createForAddress(peerAddress.toBytes()));
+                .onPeerConnected(UwbDevice.createForAddress(peerAddress.toBytes()));
     }
 
     @Test
@@ -448,19 +447,22 @@ public class RangingControllerTest {
                 .when(pfRangingSession)
                 .removeControlee(any(PersistableBundle.class));
 
-        mRangingController.startRanging(rangingSessionCallback, mBackendCallbackExecutor);
+        mRangingController.startRanging(rangingSessionCallback);
         mRangingController.addControleeWithSessionParams(
                 new RangingControleeParameters(peerAddress, 0, null));
+        verify(rangingSessionCallback)
+                .onPeerConnected(UwbDevice.createForAddress(peerAddress.toBytes()));
+
         assertEquals(mRangingController.removeControlee(peerAddress), STATUS_OK);
+        verify(rangingSessionCallback)
+                .onPeerDisconnected(
+                        UwbDevice.createForAddress(peerAddress.toBytes()),
+                        LOCAL_DEVICE_REQUEST);
         assertEquals(mRangingController.removeControlee(mRangingParamsKnownPeerAddress), STATUS_OK);
         assertEquals(mRangingController.removeControlee(UwbAddress.getRandomizedShortAddress()),
                 INVALID_API_CALL);
         verify(pfRangingSession, times(1)).addControlee(any(PersistableBundle.class));
         verify(pfRangingSession, times(2)).removeControlee(any(PersistableBundle.class));
-        verify(rangingSessionCallback)
-                .onRangingSuspended(
-                        UwbDevice.createForAddress(peerAddress.toBytes()),
-                        REASON_STOP_RANGING_CALLED);
     }
 
     @Test
@@ -499,7 +501,7 @@ public class RangingControllerTest {
                 .when(pfRangingSession)
                 .reconfigure(any(PersistableBundle.class));
 
-        mRangingController.startRanging(rangingSessionCallback, mBackendCallbackExecutor);
+        mRangingController.startRanging(rangingSessionCallback);
         assertEquals(mRangingController.setBlockStriding(5), STATUS_OK);
 
         verify(pfRangingSession, times(1)).reconfigure(any(PersistableBundle.class));
@@ -541,7 +543,7 @@ public class RangingControllerTest {
                 .when(pfRangingSession)
                 .reconfigure(any(PersistableBundle.class));
 
-        mRangingController.startRanging(rangingSessionCallback, mBackendCallbackExecutor);
+        mRangingController.startRanging(rangingSessionCallback);
         UwbRangeDataNtfConfig params = new UwbRangeDataNtfConfig.Builder()
                 .setRangeDataConfigType(RANGE_DATA_NTF_ENABLE_PROXIMITY_EDGE_TRIG)
                 .setNtfProximityNear(50)
diff --git a/service/Android.bp b/service/Android.bp
index e6abd5e0..dc28c7a8 100644
--- a/service/Android.bp
+++ b/service/Android.bp
@@ -35,6 +35,13 @@ filegroup {
     ],
 }
 
+filegroup {
+    name: "service-uwb-shared-with-ranging-srcs",
+    srcs: [
+        "java/com/android/server/uwb/UwbContext.java",
+    ],
+}
+
 // pre-jarjar version of service-uwb that builds against pre-jarjar version of framework-uwb
 java_library {
     name: "service-uwb-pre-jarjar",
diff --git a/service/ServiceUwbResources/res/values/config.xml b/service/ServiceUwbResources/res/values/config.xml
index 49ff69d8..7f74c52a 100644
--- a/service/ServiceUwbResources/res/values/config.xml
+++ b/service/ServiceUwbResources/res/values/config.xml
@@ -21,6 +21,7 @@
      entries do not follow the convention, but all new entries should. -->
 
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- ===== Start of UWB stack overlay definitions ===== -->
     <!-- boolean indicating whether or not the system supports multiple UWB chips -->
     <bool name="config_isMultichip">false</bool>
 
@@ -245,4 +246,26 @@
     <!-- Whether when hopmode doesn't set, the hopmodekey shall be set randomly.
     If false, never sets hopmodekey randomly-->
     <bool name = "enable_random_hopmodekey">false</bool>
+
+    <!-- Whether FIRa CCC capability UCI Specification applied or not.
+    If enabled, FIRa CCC capability UCI Specification used -->
+    <bool name = "fira_supported_extension_ccc">false</bool>
+    <!-- ===== End of UWB stack overlay definitions ===== -->
+
+    <!-- ===== Start of ranging stack overlay definitions ===== -->
+    <!-- Priority list of ranging technologies on a device. OEM can add, remove or modify the order
+     of technology in device specific overlay.-->
+    <string-array name="technology_preference_list">
+        <item>UWB</item>
+        <item>CS</item>
+        <!-- RTT is disabled by default, OEM should copy the full list and uncomment RTT too add.-->
+        <!--item>RTT</item-->
+        <item>RSSI</item>
+    </string-array>
+
+    <!-- The minimum guaranteed delay in milliseconds between a received Rtt ranging result and the
+    next Rtt ranging request. (This does not apply on periodic Nan-Rtt ranging)-->
+    <integer name="rtt_ranging_request_delay">500</integer>
+
+    <!-- ===== End of ranging stack overlay definitions ===== -->
 </resources>
diff --git a/service/ServiceUwbResources/res/values/overlayable.xml b/service/ServiceUwbResources/res/values/overlayable.xml
index b662004f..bb6788ce 100644
--- a/service/ServiceUwbResources/res/values/overlayable.xml
+++ b/service/ServiceUwbResources/res/values/overlayable.xml
@@ -20,6 +20,7 @@
         <policy type="product|system|vendor">
 
           <!-- Params from config.xml that can be overlaid -->
+          <!-- ===== Start of UWB stack overlay definitions ===== -->
             <item name="config_isMultichip" type="bool" />
             <item name="config_multichipConfigPath" type="string" />
             <item name="enable_filters" type="bool" />
@@ -36,6 +37,8 @@
             <item name="mirror_detection_window" type="integer" />
             <item name="front_mirror_dps" type="integer" />
             <item name="back_mirror_dps" type="integer" />
+            <item name="mirror_score_std_degrees" type="integer" />
+            <item name="back_noise_influence_percent" type="integer" />
             <item name="prediction_timeout_seconds" type="integer" />
             <item name="advertise_aoa_criteria_angle" type="integer" />
             <item name="advertise_time_threshold_millis" type="integer" />
@@ -47,6 +50,7 @@
             <item name="background_ranging_enabled" type="bool" />
             <item name="ranging_error_streak_timer_enabled" type="bool" />
             <item name="ccc_ranging_stopped_params_send_enabled" type="bool" />
+            <item name="ccc_absolute_uwb_initiation_time_enabled" type="bool" />
             <item name="location_use_for_country_code_enabled" type="bool" />
             <item name="uwb_disabled_until_first_toggle" type="bool" />
             <item name="ccc_supported_sync_codes_little_endian" type="bool" />
@@ -60,6 +64,14 @@
             <item name="mcc_mcc_oem_override_list" type="array" />
             <item name="ccc_two_byte_config_id_little_endian_supported" type="bool" />
             <item name="enable_random_hopmodekey" type="bool" />
+            <item name="fira_supported_extension_ccc" type="bool" />
+          <!-- ===== End of UWB stack overlay definitions ===== -->
+
+          <!-- ===== Start of ranging stack overlay definitions ===== -->
+          <item name="technology_preference_list" type="array" />
+          <item name="rtt_ranging_request_delay" type="integer" />
+          <!-- ===== End of ranging stack overlay definitions ===== -->
+
           <!-- Params from config.xml that can be overlaid -->
 
           <!-- Params from strings.xml that can be overlaid -->
diff --git a/service/fusion_lib/tests/Android.bp b/service/fusion_lib/tests/Android.bp
index 16e102e2..58a99b3d 100644
--- a/service/fusion_lib/tests/Android.bp
+++ b/service/fusion_lib/tests/Android.bp
@@ -22,6 +22,7 @@ package {
 android_test {
     name: "UwbFusionLibTests",
     srcs: ["**/*.java"],
+    sdk_version: "system_server_current",
     certificate: "platform",
     static_libs: [
         "com.uwb.fusion",
@@ -32,5 +33,8 @@ android_test {
         "truth",
         "platform-test-annotations",
     ],
-    test_suites: ["device-tests"],
+    test_suites: [
+        "general-tests",
+        "mts-uwb",
+    ],
 }
diff --git a/service/fusion_lib/tests/AndroidTest.xml b/service/fusion_lib/tests/AndroidTest.xml
index 52192022..62fec11e 100644
--- a/service/fusion_lib/tests/AndroidTest.xml
+++ b/service/fusion_lib/tests/AndroidTest.xml
@@ -19,6 +19,11 @@
 <configuration description="Configuration for UWB Fusion Lib unit tests">
     <option name="test-suite-tag" value="apct" />
     <option name="test-suite-tag" value="apct-instrumentation" />
+    <option name="config-descriptor:metadata" key="parameter" value="instant_app" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+    <option name="config-descriptor:metadata" key="parameter" value="secondary_user" />
+    <option name="config-descriptor:metadata" key="parameter" value="secondary_user_on_secondary_display" />
+    <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.uwb.apex" />
 
     <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
         <option name="cleanup-apks" value="true" />
@@ -32,4 +37,8 @@
         <option name="hidden-api-checks" value="false"/>
         <option name="runner" value="androidx.test.runner.AndroidJUnitRunner"/>
     </test>
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.uwb" />
+    </object>
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk36ModuleController" />
 </configuration>
\ No newline at end of file
diff --git a/service/java/com/android/server/uwb/DeviceConfigFacade.java b/service/java/com/android/server/uwb/DeviceConfigFacade.java
index 8b8871de..797d1f57 100644
--- a/service/java/com/android/server/uwb/DeviceConfigFacade.java
+++ b/service/java/com/android/server/uwb/DeviceConfigFacade.java
@@ -105,6 +105,7 @@ public class DeviceConfigFacade {
     private boolean mIsAntennaModeConfigSupported;
     private String[] mMccMncOemOverrideList;
     private boolean mIsRandomHopmodekeySupported;
+    private boolean mFiraExtensionForCCCSupported;
 
     public DeviceConfigFacade(Handler handler, Context context) {
         mContext = context;
@@ -350,6 +351,10 @@ public class DeviceConfigFacade {
                     + "overlay file is invalid. Defaulting to " + mPoseSourceType.name());
         }
         mEnablePrimerFov = mPrimerFovDegree > 0 && mPrimerFovDegree < MAX_FOV;
+
+        // device config override with array is not supported, so just read the resource.
+        mFiraExtensionForCCCSupported = mContext.getResources()
+                .getBoolean(R.bool.fira_supported_extension_ccc);
     }
 
     /**
@@ -668,4 +673,11 @@ public class DeviceConfigFacade {
     public boolean isRandomHopmodekeySupported() {
         return mIsRandomHopmodekeySupported;
     }
+
+    /**
+     * Returns whether FiRa CCC capability UCI Specification applied or not.
+     */
+    public boolean isFiraSupportedExtensionForCCC() {
+        return mFiraExtensionForCCCSupported;
+    }
 }
diff --git a/service/java/com/android/server/uwb/UwbContext.java b/service/java/com/android/server/uwb/UwbContext.java
index a274df52..28626850 100644
--- a/service/java/com/android/server/uwb/UwbContext.java
+++ b/service/java/com/android/server/uwb/UwbContext.java
@@ -20,12 +20,14 @@ import android.annotation.NonNull;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.content.Intent;
+import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
 import android.util.Log;
 
+import java.io.File;
 import java.util.List;
 import java.util.stream.Collectors;
 
@@ -41,6 +43,13 @@ public class UwbContext extends ContextWrapper {
 
     /** Since service-uwb runs within system_server, its package name is "android". */
     private static final String SERVICE_UWB_PACKAGE_NAME = "android";
+    private static final String UWB_APEX_NAME = "com.android.uwb";
+    /**
+     * The path where the Uwb apex is mounted.
+     * Current value = "/apex/com.android.uwb"
+     */
+    private static final String UWB_APEX_PATH =
+            new File("/apex", UWB_APEX_NAME).getAbsolutePath();
 
     private String mUwbOverlayApkPkgName;
 
@@ -53,6 +62,14 @@ public class UwbContext extends ContextWrapper {
         super(contextBase);
     }
 
+    /**
+     * Returns true if the app is in the Uwb apex, false otherwise.
+     * Checks if the app's path starts with "/apex/com.android.uwb".
+     */
+    private static boolean isAppInUwbApex(ApplicationInfo appInfo) {
+        return appInfo.sourceDir.startsWith(UWB_APEX_PATH);
+    }
+
     /** Get the package name of ServiceUwbResources.apk */
     public String getUwbOverlayApkPkgName() {
         if (mUwbOverlayApkPkgName != null) {
@@ -65,7 +82,7 @@ public class UwbContext extends ContextWrapper {
 
         // remove apps that don't live in the Uwb apex
         resolveInfos.removeIf(info ->
-                !UwbInjector.isAppInUwbApex(info.activityInfo.applicationInfo));
+                !isAppInUwbApex(info.activityInfo.applicationInfo));
 
         if (resolveInfos.isEmpty()) {
             // Resource APK not loaded yet, print a stack trace to see where this is called from
diff --git a/service/java/com/android/server/uwb/UwbInjector.java b/service/java/com/android/server/uwb/UwbInjector.java
index 3654d7aa..86d1b327 100644
--- a/service/java/com/android/server/uwb/UwbInjector.java
+++ b/service/java/com/android/server/uwb/UwbInjector.java
@@ -88,13 +88,6 @@ public class UwbInjector {
     private static final String APEX_NAME = "com.android.uwb";
     private static final String VENDOR_SERVICE_NAME = "uwb_vendor";
     private static final String BOOT_DEFAULT_UWB_COUNTRY_CODE = "ro.boot.uwbcountrycode";
-
-    /**
-     * The path where the Uwb apex is mounted.
-     * Current value = "/apex/com.android.uwb"
-     */
-    private static final String UWB_APEX_PATH =
-            new File("/apex", APEX_NAME).getAbsolutePath();
     private static final int APP_INFO_FLAGS_SYSTEM_APP =
             ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
 
@@ -347,14 +340,6 @@ public class UwbInjector {
                 .getCredentialProtectedDataDirForUser(UserHandle.of(userId));
     }
 
-    /**
-     * Returns true if the app is in the Uwb apex, false otherwise.
-     * Checks if the app's path starts with "/apex/com.android.uwb".
-     */
-    public static boolean isAppInUwbApex(ApplicationInfo appInfo) {
-        return appInfo.sourceDir.startsWith(UWB_APEX_PATH);
-    }
-
     /**
      * Get the current time of the clock in milliseconds.
      *
@@ -516,6 +501,30 @@ public class UwbInjector {
         );
     }
 
+    private boolean isPrivilegedApp(int uid, String packageName) {
+        return isSystemApp(uid, packageName) || isAppSignedWithPlatformKey(uid);
+    }
+
+    /**
+     * Check the attribution source chain to check if there are any 3p apps.
+     * @return AttributionSource of first non-system app found in the chain, null otherwise.
+     */
+    @Nullable
+    public AttributionSource getAnyNonPrivilegedAppInAttributionSource(
+            AttributionSource attributionSource) {
+        // Iterate attribution source chain to ensure that there is no non-fg 3p app in the
+        // request.
+        while (attributionSource != null) {
+            int uid = attributionSource.getUid();
+            String packageName = attributionSource.getPackageName();
+            if (!isPrivilegedApp(uid, packageName)) {
+                return attributionSource;
+            }
+            attributionSource = attributionSource.getNext();
+        }
+        return null;
+    }
+
     /**
      * Gets the configured pose source, which is reference counted. If there are no references
      * to the pose source, one will be created based on the device configuration. This may
diff --git a/service/java/com/android/server/uwb/UwbMetrics.java b/service/java/com/android/server/uwb/UwbMetrics.java
index 831503b5..c1769f68 100644
--- a/service/java/com/android/server/uwb/UwbMetrics.java
+++ b/service/java/com/android/server/uwb/UwbMetrics.java
@@ -459,7 +459,7 @@ public class UwbMetrics {
             UwbStatsLog.write(UwbStatsLog.UWB_RANGING_START, uwbSession.getProfileType(),
                     session.mStsType, session.mIsInitiator,
                     session.mIsController, session.mIsDiscoveredByFramework, session.mIsOutOfBand,
-                    session.mRangingStatus);
+                    session.mRangingStatus, uwbSession.getAttributionSource().getUid());
             if (status != UwbUciConstants.STATUS_CODE_OK) {
                 session.mStartFailureCount++;
                 session.mStartTimeSinceBootMs = 0;
@@ -532,7 +532,8 @@ public class UwbMetrics {
                     session.mStartFailureCount,
                     session.mStartNoValidReportCount,
                     session.mRxPacketCount, session.mTxPacketCount, session.mRxErrorCount,
-                    session.mTxErrorCount, session.mRxToUpperLayerCount, session.mRangingType);
+                    session.mTxErrorCount, session.mRxToUpperLayerCount, session.mRangingType,
+                    uwbSession.getAttributionSource().getUid());
             mOpenedSessionMap.delete(uwbSession.getSessionId());
         }
     }
@@ -582,7 +583,7 @@ public class UwbMetrics {
     /**
      * Log the ranging measurement result
      */
-    public void logRangingResult(int profileType, UwbRangingData rawRangingData,
+    public void logRangingResult(UwbSession uwbSession, UwbRangingData rawRangingData,
             RangingMeasurement filteredRangingMeasurement) {
         synchronized (mLock) {
             int rangingMeasuresType = rawRangingData.getRangingMeasuresType();
@@ -593,11 +594,14 @@ public class UwbMetrics {
 
             int sessionId = (int) rawRangingData.getSessionId();
             RangingSessionStats session = mOpenedSessionMap.get(sessionId);
+
             if (session == null) {
                 return;
             }
             session.mRangingCount++;
 
+            int profileType = uwbSession.getProfileType();
+
             RangingReportEvent report = getRangingReport(rangingMeasuresType, rawRangingData);
             if (report == null) {
                 return;
@@ -641,7 +645,8 @@ public class UwbMetrics {
                     isElevationValid, report.mElevationDegree, elevation10Degree,
                     report.mElevationFom, session.mRangingType, report.mFilteredDistanceCm,
                     report.mFilteredAzimuthDegree, report.mFilteredAzimuthFom,
-                    report.mFilteredElevationDegree, report.mFilteredElevationFom);
+                    report.mFilteredElevationDegree, report.mFilteredElevationFom,
+                    uwbSession.getAttributionSource().getUid());
         }
     }
 
@@ -650,7 +655,7 @@ public class UwbMetrics {
         int latencyMs = (int) (mUwbInjector.getElapsedSinceBootMillis()
                 - session.mStartTimeSinceBootMs);
         UwbStatsLog.write(UwbStatsLog.UWB_FIRST_RANGING_RECEIVED,
-                profileType, latencyMs, latencyMs / 200);
+                profileType, latencyMs, latencyMs / 200, session.mAttributionSource.getUid());
     }
 
     private int convertNlos(int nlos) {
diff --git a/service/java/com/android/server/uwb/UwbServiceCore.java b/service/java/com/android/server/uwb/UwbServiceCore.java
index a8db6f6c..202e23cc 100644
--- a/service/java/com/android/server/uwb/UwbServiceCore.java
+++ b/service/java/com/android/server/uwb/UwbServiceCore.java
@@ -241,6 +241,11 @@ public class UwbServiceCore implements INativeUwbManager.DeviceNotification,
          */
         public AttributionSourceHolder getOrCreate(
                 AttributionSource attributionSource, IBinder binder) {
+            // Check if attribution source is chained and has a 3p app in it, if so then
+            // use that attribution source to check for hw enable state.
+            AttributionSource nonPrivilegedAppAttrSource =
+                    mUwbInjector.getAnyNonPrivilegedAppInAttributionSource(attributionSource);
+            if (nonPrivilegedAppAttrSource != null) attributionSource = nonPrivilegedAppAttrSource;
             for (AttributionSourceHolder k : mMap.keySet()) {
                 if (Objects.equals(k.getAttributionSource(), attributionSource)) {
                     return k;
@@ -604,13 +609,15 @@ public class UwbServiceCore implements INativeUwbManager.DeviceNotification,
             return new PersistableBundle();
         }
         if (specificationParams.second.getFiraSpecificationParams() != null) {
+            int uciVersion = Objects.requireNonNull(getCachedDeviceInfoResponse(
+                    mUwbInjector.getMultichipData().getDefaultChipId())).mUciVersion;
             FiraSpecificationParams firaSpecificationParams =
                     new FiraSpecificationParams.Builder(
                             specificationParams.second.getFiraSpecificationParams())
                             .setBackgroundRangingSupport(mUwbInjector.getDeviceConfigFacade()
                                     .isBackgroundRangingEnabled())
-                            .setUciVersionSupported(getCachedDeviceInfoResponse(
-                                    mUwbInjector.getMultichipData().getDefaultChipId()).mUciVersion)
+                            .setUciVersionSupported(uciVersion > 100 ? 1 : uciVersion)
+                            .setCountryCode(mUwbCountryCode.getCountryCode())
                             .build();
             specificationParams.second.setFiraSpecificationParams(firaSpecificationParams);
         }
diff --git a/service/java/com/android/server/uwb/UwbSessionManager.java b/service/java/com/android/server/uwb/UwbSessionManager.java
index eda3feb6..741260c2 100644
--- a/service/java/com/android/server/uwb/UwbSessionManager.java
+++ b/service/java/com/android/server/uwb/UwbSessionManager.java
@@ -38,6 +38,8 @@ import static com.google.uwb.support.fira.FiraParams.MULTICAST_LIST_UPDATE_ACTIO
 import static com.google.uwb.support.fira.FiraParams.PROTOCOL_NAME;
 import static com.google.uwb.support.fira.FiraParams.P_STS_MULTICAST_LIST_UPDATE_ACTION_ADD_16_BYTE;
 import static com.google.uwb.support.fira.FiraParams.P_STS_MULTICAST_LIST_UPDATE_ACTION_ADD_32_BYTE;
+import static com.google.uwb.support.fira.FiraParams.RANGE_DATA_NTF_CONFIG_ENABLE_PROXIMITY_EDGE_TRIG;
+import static com.google.uwb.support.fira.FiraParams.RANGE_DATA_NTF_CONFIG_ENABLE_PROXIMITY_LEVEL_TRIG;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -59,6 +61,7 @@ import android.uwb.RangingChangeReason;
 import android.uwb.SessionHandle;
 import android.uwb.UwbAddress;
 
+import androidx.annotation.GuardedBy;
 import androidx.annotation.VisibleForTesting;
 
 import com.android.modules.utils.build.SdkLevel;
@@ -85,6 +88,7 @@ import com.android.uwb.fusion.UwbFilterEngine;
 import com.android.uwb.fusion.pose.ApplicationPoseSource;
 import com.android.uwb.fusion.pose.IPoseSource;
 
+import com.google.common.collect.Sets;
 import com.google.uwb.support.aliro.AliroOpenRangingParams;
 import com.google.uwb.support.aliro.AliroParams;
 import com.google.uwb.support.aliro.AliroRangingStartedParams;
@@ -126,6 +130,7 @@ import java.io.PrintWriter;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.List;
@@ -150,9 +155,8 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
 
     private static final String TAG = "UwbSessionManager";
     private static final byte OPERATION_TYPE_INIT_SESSION = 0;
-    private static final int UWB_HUS_CONTROLLER_PHASE_LIST_SHORT_MAC_ADDRESS_SIZE = 11;
     private static final int UWB_HUS_CONTROLLER_PHASE_LIST_EXTENDED_MAC_ADDRESS_SIZE = 17;
-    private static final int UWB_HUS_CONTROLEE_PHASE_LIST_SIZE = 5;
+    private static final int UWB_HUS_CONTROLEE_PHASE_LIST_SIZE = 4;
 
     @VisibleForTesting
     public static final int SESSION_OPEN_RANGING = 1;
@@ -888,6 +892,10 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                         status = mNativeUwbManager.testPeriodicTx(params.getPsduData(),
                                 uwbSession.getChipId());
                         break;
+                    case RfTestParams.TEST_PER_RX:
+                        status = mNativeUwbManager.testPerRx(params.getPsduData(),
+                                uwbSession.getChipId());
+                        break;
                     default:
                         Log.i(TAG, "Unknown RF command: " + rfTestOperationType);
                 }
@@ -1581,8 +1589,7 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         int sessionType = uwbSession.getSessionType();
         if (UwbUciConstants.DEVICE_TYPE_CONTROLLER != deviceType
                 || UwbUciConstants.HYBRID_SCHEDULED_RANGING != scheduleMode
-                || (UwbUciConstants.SESSION_TYPE_RANGING != sessionType
-                        && UwbUciConstants.SESSION_TYPE_DATA_TRANSFER != sessionType)) {
+                || UwbUciConstants.SESSION_TYPE_HUS_PRIMARY_SESSION != sessionType) {
             Log.e(TAG, "SetHybridSessionControllerConfiguration() failed: device type: "
                     + deviceType + " schedule mode: "
                     + scheduleMode + " sessionType: " + sessionType);
@@ -1594,49 +1601,49 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         FiraHybridSessionControllerConfig husConfig =
                 FiraHybridSessionControllerConfig.fromBundle(info.params);
         int numberOfPhases = husConfig.getNumberOfPhases();
-        byte messageControl = husConfig.getMessageControl();
-        byte macAddressMode = (byte) (messageControl & 0x01);
 
         Log.i(TAG, "handleSetHybridSessionControllerConfiguration() - sessionId: " + sessionId
                 + ", sessionHandle: " + sessionHandle
                 + ", numberOfPhases: " + numberOfPhases);
 
         ByteBuffer buffer = ByteBuffer.allocate(numberOfPhases
-                * ((macAddressMode == UwbUciConstants.MAC_ADDRESSING_MODE_SHORT)
-                ? UWB_HUS_CONTROLLER_PHASE_LIST_SHORT_MAC_ADDRESS_SIZE :
-                    UWB_HUS_CONTROLLER_PHASE_LIST_EXTENDED_MAC_ADDRESS_SIZE));
+                * UWB_HUS_CONTROLLER_PHASE_LIST_EXTENDED_MAC_ADDRESS_SIZE);
         buffer.order(ByteOrder.LITTLE_ENDIAN);
 
         for (FiraHybridSessionControllerConfig.FiraHybridSessionPhaseList phaseList :
                 husConfig.getPhaseList()) {
-            buffer.putInt(mNativeUwbManager.getSessionToken(phaseList.getSessionHandle(),
-                    uwbSession.getChipId()));
+            buffer.putInt(phaseList.getSessionId());
             buffer.putShort(phaseList.getStartSlotIndex());
             buffer.putShort(phaseList.getEndSlotIndex());
-            buffer.put(phaseList.getPhaseParticipation());
+
+            byte messageControl = phaseList.getMessageControl();
+            buffer.put(messageControl);
+
             // validate the MacAddress
+            byte macAddressMode = (byte) (messageControl & 0x01);
             int addressByteLength = (macAddressMode
                         == UwbUciConstants.SHORT_MAC_ADDRESS)
                     ? UwbAddress.SHORT_ADDRESS_BYTE_LENGTH
                     : UwbAddress.EXTENDED_ADDRESS_BYTE_LENGTH;
             UwbAddress uwbAddress = phaseList.getMacAddress();
             if (uwbAddress == null || uwbAddress.size() != addressByteLength) {
-                Log.e(TAG, "handleSetHybridSessionControllerConfiguration() invalid address");
+                Log.e(TAG, "handleSetHybridSessionControllerConfiguration() invalid UWB address");
                 mSessionNotificationManager.onHybridSessionControllerConfigurationFailed(
                          uwbSession, UwbUciConstants.STATUS_CODE_FAILED);
                 return;
             }
+
             buffer.put(getComputedMacAddress(uwbAddress));
         }
 
+        byte[] phaseListArray = Arrays.copyOf(buffer.array(), buffer.position());
         // create session set hus controller configuration task
         FutureTask<Integer> sessionsetHybridControllerConfigTask = new FutureTask<>(
                 (Callable<Integer>) () -> {
                     int status = UwbUciConstants.STATUS_CODE_FAILED;
                     synchronized (uwbSession.getWaitObj()) {
                         status = mNativeUwbManager.setHybridSessionControllerConfiguration(
-                                sessionId, messageControl, numberOfPhases,
-                                husConfig.getUpdateTime(), buffer.array(),
+                                sessionId, numberOfPhases, phaseListArray,
                                 uwbSession.getChipId());
                     }
                     return status;
@@ -1683,8 +1690,7 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         int sessionType = uwbSession.getSessionType();
         if (UwbUciConstants.DEVICE_TYPE_CONTROLEE != deviceType
                 || UwbUciConstants.HYBRID_SCHEDULED_RANGING != scheduleMode
-                || (UwbUciConstants.SESSION_TYPE_RANGING != sessionType
-                        && UwbUciConstants.SESSION_TYPE_DATA_TRANSFER != sessionType)) {
+                || UwbUciConstants.SESSION_TYPE_HUS_PRIMARY_SESSION != sessionType) {
             Log.e(TAG, "handleSetHybridSessionControleeConfiguration() failed: device type: "
                     + deviceType + " schedule mode: " + scheduleMode
                     + " sessionType: " + sessionType);
@@ -1709,7 +1715,6 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                 controleeConfig.getPhaseList()) {
             phaseListBuffer.putInt(mNativeUwbManager.getSessionToken(phaseList.getSessionHandle(),
                     uwbSession.getChipId()));
-            phaseListBuffer.put(phaseList.getPhaseParticipation());
         }
 
         // create session set hus controlee configuration task
@@ -1756,11 +1761,18 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         UwbSession uwbSession = getUwbSession(sessionHandle);
 
         int sessionType = uwbSession.getSessionType();
-        if (sessionType != FiraParams.SESSION_TYPE_RANGING_AND_IN_BAND_DATA
-                && sessionType != FiraParams.SESSION_TYPE_DATA_TRANSFER
-                && sessionType !=  FiraParams.SESSION_TYPE_IN_BAND_DATA_PHASE) {
-            Log.e(TAG, "SetDataTransferPhaseConfig not applicable for session type: "
-                    + sessionType);
+        int deviceType = uwbSession.getDeviceType();
+        int sessionState = uwbSession.getSessionState();
+        if (UwbUciConstants.DEVICE_TYPE_CONTROLLER != deviceType
+                || (sessionType != FiraParams.SESSION_TYPE_DATA_TRANSFER
+                        && sessionType !=  FiraParams.SESSION_TYPE_IN_BAND_DATA_PHASE)
+                || (sessionState != UwbUciConstants.UWB_SESSION_STATE_IDLE
+                        && sessionState != UwbUciConstants.UWB_SESSION_STATE_ACTIVE)) {
+            Log.e(TAG, "SetDataTransferPhaseConfig failed: session type:" + sessionType
+                    + " device type:" + deviceType + " sessionState:" + sessionState);
+
+            mSessionNotificationManager.onDataTransferPhaseConfigFailed(uwbSession,
+                    UwbUciConstants.STATUS_CODE_REJECTED);
             return;
         }
 
@@ -1777,6 +1789,7 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         ByteBuffer slotBitmapByteBuffer = ByteBuffer.allocate(dataTransferManagementListSize
                 * slotBitmapSizeInBytes);
         slotBitmapByteBuffer.order(ByteOrder.LITTLE_ENDIAN);
+        ByteBuffer stopDataTransferByteBuffer = ByteBuffer.allocate(dataTransferManagementListSize);
 
         int addressByteLength = ((dataTransferControl & 0x01)
                        == UwbUciConstants.SHORT_MAC_ADDRESS)
@@ -1786,10 +1799,13 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                 mDataTransferPhaseManagementList) {
             UwbAddress uwbAddress = dataTransferPhaseManagementList.getUwbAddress();
             byte[] slotBitMap = dataTransferPhaseManagementList.getSlotBitMap();
+            byte stopDataTransfer = dataTransferPhaseManagementList.getStopDataTransfer();
+
             if (uwbAddress != null && uwbAddress.size() == addressByteLength
                     && slotBitMap.length == slotBitmapSizeInBytes) {
                 macAddressList.add(getComputedMacAddress(uwbAddress));
                 slotBitmapByteBuffer.put(slotBitMap);
+                stopDataTransferByteBuffer.put(stopDataTransfer);
             } else {
                 Log.e(TAG, "handleSetDataTransferPhaseConfig: slot bitmap size "
                             + "or address is not matching");
@@ -1817,6 +1833,7 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                                 (byte) dataTransferManagementListSize,
                                 ArrayUtils.toPrimitive(macAddressList),
                                 slotBitmapByteBuffer.array(),
+                                stopDataTransferByteBuffer.array(),
                                 uwbSession.getChipId());
                     }
                     return status;
@@ -2501,7 +2518,7 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                                         i++;
                                     }
                                     if (getUwbsFiraProtocolVersion(uwbSession.getChipId())
-                                                .getMajor() != FIRA_VERSION_MAJOR_2
+                                                .getMajor() < FIRA_VERSION_MAJOR_2
                                             || (uwbSession.getSessionState()
                                                 == UwbUciConstants.UWB_SESSION_STATE_IDLE)
                                             || (multicastListUpdateStatus.getNumOfControlee()
@@ -2512,7 +2529,7 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                                 //Fira 2.0
                                 if (getUwbsFiraProtocolVersion(
                                         uwbSession.getChipId()).getMajor()
-                                            == FIRA_VERSION_MAJOR_2) {
+                                            >= FIRA_VERSION_MAJOR_2) {
                                     // Action - Add, Status - STATUS_OK
                                     if (isMulticastActionAdd(action)) {
                                         for (UwbAddress address : addrList) {
@@ -2915,9 +2932,21 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         // reasonCode from the last received SESSION_STATUS_NTF for this session.
         private int mLastSessionStatusNtfReasonCode = -1;
 
-        // Keeps track of all controlees in the session.
+        /**
+         * Acquire to synchronized changes in controlee count
+         * Guards mControlees and mControleesPendingDisconnection
+         */
+        private final Object mControleeCountLock = new Object();
+
+        /**
+         * Keeps track of all controlees in the session.
+         */
         public Map<UwbAddress, UwbControlee> mControlees;
 
+        /** Number of controlees pending disconnection due to error streak timeout */
+        @GuardedBy("mControleeCountLock")
+        private final Set<UwbAddress> mControleesPendingDisconnection;
+
         // Keep track of RF Test start session params
         private RfTestStartSessionParams mRfTestStartSessionParams = null;
 
@@ -2937,9 +2966,10 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
             this.mProfileType = convertProtolNameToProfileType(protocolName);
             this.mChipId = chipId;
             this.mNonPrivilegedAppInAttributionSource =
-                    getAnyNonPrivilegedAppInAttributionSourceInternal();
+                    mUwbInjector.getAnyNonPrivilegedAppInAttributionSource(mAttributionSource);
             this.mStackSessionPriority = calculateSessionPriority();
             this.mControlees = new ConcurrentHashMap<>();
+            this.mControleesPendingDisconnection = Sets.newConcurrentHashSet();
 
             if (params instanceof FiraOpenSessionParams) {
                 FiraOpenSessionParams firaParams = (FiraOpenSessionParams) params;
@@ -3025,31 +3055,6 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
             return BG_SESSION_PRIORITY;
         }
 
-        private boolean isPrivilegedApp(int uid, String packageName) {
-            return mUwbInjector.isSystemApp(uid, packageName)
-                    || mUwbInjector.isAppSignedWithPlatformKey(uid);
-        }
-
-        /**
-         * Check the attribution source chain to check if there are any 3p apps.
-         * @return AttributionSource of first non-system app found in the chain, null otherwise.
-         */
-        @Nullable
-        private AttributionSource getAnyNonPrivilegedAppInAttributionSourceInternal() {
-            // Iterate attribution source chain to ensure that there is no non-fg 3p app in the
-            // request.
-            AttributionSource attributionSource = mAttributionSource;
-            while (attributionSource != null) {
-                int uid = attributionSource.getUid();
-                String packageName = attributionSource.getPackageName();
-                if (!isPrivilegedApp(uid, packageName)) {
-                    return attributionSource;
-                }
-                attributionSource = attributionSource.getNext();
-            }
-            return null;
-        }
-
         /**
          * Check the attribution source chain to check if there are any 3p apps.
          * @return AttributionSource of first non-system app found in the chain, null otherwise.
@@ -3174,7 +3179,10 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
             if (mControlees.containsKey(address)) {
                 return;
             }
-            mControlees.put(address, new UwbControlee(address, createFilterEngine(), mUwbInjector));
+            synchronized (mControleeCountLock) {
+                mControlees.put(address,
+                        new UwbControlee(address, createFilterEngine(), mUwbInjector));
+            }
         }
 
         /**
@@ -3208,7 +3216,11 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
             Log.d(TAG, "Removing controlee.");
             stopRangingResultErrorStreakTimerIfSet(address);
             mControlees.get(address).close();
-            mControlees.remove(address);
+
+            synchronized (mControleeCountLock) {
+                mControlees.remove(address);
+                mControleesPendingDisconnection.remove(address);
+            }
         }
 
         public AttributionSource getAttributionSource() {
@@ -3703,15 +3715,19 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
             AlarmManager.OnAlarmListener onAlarm = () -> {
                 Log.w(TAG, "Continuous errors or no ranging results detected from controlee "
                         + address + " for " + mRangingErrorStreakTimeoutMs + " ms.");
-                if (mControlees.size() == 1) {
-                    Log.w(TAG, "No active controlees, stopping session");
-                    if (getSessionState() == UwbUciConstants.UWB_SESSION_STATE_ACTIVE) {
-                        stopRangingInternal(mSessionHandle, true /* triggeredBySystemPolicy */);
+
+                synchronized (mControleeCountLock) {
+                    if (mControlees.size() - mControleesPendingDisconnection.size() == 1) {
+                        Log.w(TAG, "Last controlee in session has disconnected, stopping session");
+                        if (getSessionState() == UwbUciConstants.UWB_SESSION_STATE_ACTIVE) {
+                            stopRangingInternal(mSessionHandle, true /* triggeredBySystemPolicy */);
+                        } else {
+                            Log.i(TAG, "Session is not in an active state");
+                        }
                     } else {
-                        Log.i(TAG, "Session is not in an active state");
+                        mControleesPendingDisconnection.add(address);
+                        removeControleeDueToErrorStreakTimeout(address);
                     }
-                } else {
-                    removeControleeDueToErrorStreakTimeout(address);
                 }
             };
 
@@ -3791,9 +3807,14 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
             // If app is in fg, use the configured ntf control, else disable.
             if (mHasNonPrivilegedFgAppOrService) {
                 FiraOpenSessionParams params = (FiraOpenSessionParams) mParams;
-                builder.setRangeDataNtfConfig(params.getRangeDataNtfConfig())
+                int rangeDataNtfConfig = params.getRangeDataNtfConfig();
+                builder.setRangeDataNtfConfig(rangeDataNtfConfig);
+                if (rangeDataNtfConfig == RANGE_DATA_NTF_CONFIG_ENABLE_PROXIMITY_LEVEL_TRIG
+                        || rangeDataNtfConfig == RANGE_DATA_NTF_CONFIG_ENABLE_PROXIMITY_EDGE_TRIG) {
+                    builder
                         .setRangeDataProximityNear(params.getRangeDataNtfProximityNear())
                         .setRangeDataProximityFar(params.getRangeDataNtfProximityFar());
+                }
             } else {
                 builder.setRangeDataNtfConfig(FiraParams.RANGE_DATA_NTF_CONFIG_DISABLE);
             }
@@ -3886,7 +3907,10 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                 for (UwbControlee controlee : mControlees.values()) {
                     controlee.close();
                 }
-                mControlees.clear();
+                synchronized (mControleeCountLock) {
+                    mControlees.clear();
+                    mControleesPendingDisconnection.clear();
+                }
 
                 this.mAcquiredDefaultPose = false;
                 mUwbInjector.releasePoseSource();
diff --git a/service/java/com/android/server/uwb/UwbSessionNotificationManager.java b/service/java/com/android/server/uwb/UwbSessionNotificationManager.java
index a100d584..b6afaab4 100644
--- a/service/java/com/android/server/uwb/UwbSessionNotificationManager.java
+++ b/service/java/com/android/server/uwb/UwbSessionNotificationManager.java
@@ -101,7 +101,7 @@ public class UwbSessionNotificationManager {
 
         try {
             RangingMeasurement filteredRangingMeasurement = rangingReport.getMeasurements().get(0);
-            mUwbInjector.getUwbMetrics().logRangingResult(uwbSession.getProfileType(), rangingData,
+            mUwbInjector.getUwbMetrics().logRangingResult(uwbSession, rangingData,
                     filteredRangingMeasurement);
         } catch (Exception e) {
             Log.e(TAG, "logRangingResult Failed.");
@@ -809,6 +809,8 @@ public class UwbSessionNotificationManager {
                     rangingMeasurementBuilder.setRssiDbm(rssi);
                 }
 
+                rangingMeasurementBuilder.setHusPrimarySessionId(
+                        rangingData.getHusPrimarySessionId());
                 if (uwbTwoWayMeasurement[i].isStatusCodeOk()) {
                     // Distance measurement is mandatory
                     rangingMeasurementBuilder.setDistanceMeasurement(
@@ -938,26 +940,22 @@ public class UwbSessionNotificationManager {
     private static AngleOfArrivalMeasurement computeAngleOfArrivalMeasurement(
             boolean isAoaAzimuthEnabled, boolean isAoaElevationEnabled, float aoaAzimuth,
             int aoaAzimuthFom, float aoaElevation, int aoaElevationFom) {
-        // Azimuth is required field (and elevation is an optional field), to build the
-        // AngleOfArrivalMeasurement.
-        if (isAoaAzimuthEnabled) {
-            AngleMeasurement azimuthAngleMeasurement = new AngleMeasurement(
-                    UwbUtil.degreeToRadian(aoaAzimuth), 0, aoaAzimuthFom / (double) 100);
-            // AngleOfArrivalMeasurement
-            AngleOfArrivalMeasurement.Builder angleOfArrivalMeasurementBuilder =
-                    new AngleOfArrivalMeasurement.Builder(azimuthAngleMeasurement);
-
-            // Elevation is optional field, to build the AngleOfArrivalMeasurement.
-            if (isAoaElevationEnabled) {
-                AngleMeasurement altitudeAngleMeasurement = new AngleMeasurement(
-                        UwbUtil.degreeToRadian(aoaElevation), 0, aoaElevationFom / (double) 100);
-                angleOfArrivalMeasurementBuilder.setAltitude(altitudeAngleMeasurement);
-            }
-
-            return angleOfArrivalMeasurementBuilder.build();
+        if (!isAoaAzimuthEnabled && !isAoaElevationEnabled) {
+            return null;
+        }
+        AngleMeasurement azimuthAngleMeasurement = isAoaAzimuthEnabled
+                ? new AngleMeasurement(UwbUtil.degreeToRadian(aoaAzimuth), 0,
+                        aoaAzimuthFom / (double) 100)
+                : new AngleMeasurement(0, 0, 0);
+        AngleOfArrivalMeasurement.Builder angleOfArrivalMeasurementBuilder =
+                new AngleOfArrivalMeasurement.Builder(azimuthAngleMeasurement);
+        if (isAoaElevationEnabled) {
+            AngleMeasurement altitudeAngleMeasurement = new AngleMeasurement(
+                    UwbUtil.degreeToRadian(aoaElevation), 0, aoaElevationFom / (double) 100);
+            angleOfArrivalMeasurementBuilder.setAltitude(altitudeAngleMeasurement);
         }
 
-        return null;
+        return angleOfArrivalMeasurementBuilder.build();
     }
 
     private static RangingMeasurement.Builder buildRangingMeasurement(
diff --git a/service/java/com/android/server/uwb/UwbSettingsStore.java b/service/java/com/android/server/uwb/UwbSettingsStore.java
index f079b04d..b74a43a3 100644
--- a/service/java/com/android/server/uwb/UwbSettingsStore.java
+++ b/service/java/com/android/server/uwb/UwbSettingsStore.java
@@ -17,6 +17,7 @@
 package com.android.server.uwb;
 
 import static android.uwb.UwbManager.AdapterStateCallback.STATE_ENABLED_ACTIVE;
+import static android.uwb.UwbManager.AdapterStateCallback.STATE_ENABLED_INACTIVE;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -144,7 +145,9 @@ public class UwbSettingsStore {
             try {
                 boolean toggleEnabled =
                         mUwbInjector.getGlobalSettingsInt(SETTINGS_TOGGLE_STATE_KEY_FOR_MIGRATION)
-                                == STATE_ENABLED_ACTIVE;
+                                == STATE_ENABLED_ACTIVE
+                                || mUwbInjector.getGlobalSettingsInt(
+                                SETTINGS_TOGGLE_STATE_KEY_FOR_MIGRATION) == STATE_ENABLED_INACTIVE;
                 Log.i(TAG, "Migrate settings toggle from older release: " + toggleEnabled);
                 put(SETTINGS_TOGGLE_STATE, toggleEnabled);
             } catch (Settings.SettingNotFoundException e) {
diff --git a/service/java/com/android/server/uwb/UwbTestUtils.java b/service/java/com/android/server/uwb/UwbTestUtils.java
index e29bf0d5..d10ffd66 100644
--- a/service/java/com/android/server/uwb/UwbTestUtils.java
+++ b/service/java/com/android/server/uwb/UwbTestUtils.java
@@ -87,6 +87,7 @@ public class UwbTestUtils {
     private static final int TEST_RCR_INDICATION = 7;
     private static final long TEST_CURR_RANGING_INTERVAL = 100;
     private static final int TEST_RANGING_MEASURES_TYPE = RANGING_MEASUREMENT_TYPE_TWO_WAY;
+    private static final long TEST_HUS_PRIMARY_SESSION_ID = 0;
     private static final int TEST_MAC_ADDRESS_MODE = 1;
     public static final int TEST_STATUS = FiraParams.STATUS_CODE_OK;
     private static final int TEST_LOS = 0;
@@ -165,8 +166,8 @@ public class UwbTestUtils {
                 TEST_AOA_DEST_ELEVATION_FOM, TEST_SLOT_IDX, TEST_RSSI);
         return new UwbRangingData(TEST_SEQ_COUNTER, TEST_SESSION_ID,
                 TEST_RCR_INDICATION, TEST_CURR_RANGING_INTERVAL, RANGING_MEASUREMENT_TYPE_TWO_WAY,
-                TEST_MAC_ADDRESS_MODE, noOfRangingMeasures, uwbTwoWayMeasurements,
-                TEST_RAW_NTF_DATA);
+                TEST_HUS_PRIMARY_SESSION_ID, TEST_MAC_ADDRESS_MODE, noOfRangingMeasures,
+                uwbTwoWayMeasurements, TEST_RAW_NTF_DATA);
     }
 
     private static UwbRangingData generateOwrAoaMeasurementRangingData(
@@ -179,8 +180,8 @@ public class UwbTestUtils {
                 convertFloatToQFormat(TEST_AOA_ELEVATION, 9, 7), TEST_AOA_ELEVATION_FOM);
         return new UwbRangingData(TEST_SEQ_COUNTER, TEST_SESSION_ID,
                 TEST_RCR_INDICATION, TEST_CURR_RANGING_INTERVAL, RANGING_MEASUREMENT_TYPE_OWR_AOA,
-                macAddressingMode, noOfRangingMeasures, uwbOwrAoaMeasurement,
-                TEST_RAW_NTF_DATA);
+                TEST_HUS_PRIMARY_SESSION_ID, macAddressingMode, noOfRangingMeasures,
+                uwbOwrAoaMeasurement, TEST_RAW_NTF_DATA);
     }
 
     /** Generate an OWR ranging data with a bad AoA Azimuth FOM */
@@ -194,8 +195,8 @@ public class UwbTestUtils {
                 convertFloatToQFormat(TEST_AOA_ELEVATION, 9, 7), TEST_AOA_ELEVATION_FOM);
         return new UwbRangingData(TEST_SEQ_COUNTER, TEST_SESSION_ID,
                 TEST_RCR_INDICATION, TEST_CURR_RANGING_INTERVAL, RANGING_MEASUREMENT_TYPE_OWR_AOA,
-                macAddressingMode, noOfRangingMeasures, uwbOwrAoaMeasurement,
-                TEST_RAW_NTF_DATA);
+                TEST_HUS_PRIMARY_SESSION_ID, macAddressingMode, noOfRangingMeasures,
+                uwbOwrAoaMeasurement, TEST_RAW_NTF_DATA);
     }
 
     private static UwbRangingData generateDlTDoAMeasurementRangingData(
@@ -217,8 +218,8 @@ public class UwbTestUtils {
 
         return new UwbRangingData(TEST_SEQ_COUNTER, TEST_SESSION_ID,
                 TEST_RCR_INDICATION, TEST_CURR_RANGING_INTERVAL, RANGING_MEASUREMENT_TYPE_DL_TDOA,
-                macAddressingMode, noOfRangingMeasures, uwbDlTDoAMeasurements,
-                TEST_RAW_NTF_DATA);
+                TEST_HUS_PRIMARY_SESSION_ID, macAddressingMode, noOfRangingMeasures,
+                uwbDlTDoAMeasurements, TEST_RAW_NTF_DATA);
     }
 
     // Create a UwbRangingData with no measurements, for negative test cases (example: incorrect
@@ -229,8 +230,8 @@ public class UwbTestUtils {
                 new UwbTwoWayMeasurement[noOfRangingMeasures];
         return new UwbRangingData(TEST_SEQ_COUNTER, TEST_SESSION_ID,
                 TEST_RCR_INDICATION, TEST_CURR_RANGING_INTERVAL, RANGING_MEASUREMENT_TYPE_UNDEFINED,
-                TEST_MAC_ADDRESS_MODE, noOfRangingMeasures, uwbEmptyTwoWayMeasurements,
-                TEST_RAW_NTF_DATA);
+                TEST_HUS_PRIMARY_SESSION_ID, TEST_MAC_ADDRESS_MODE, noOfRangingMeasures,
+                uwbEmptyTwoWayMeasurements, TEST_RAW_NTF_DATA);
     }
 
     // Helper method to generate a UwbRangingData instance and corresponding RangingMeasurement
@@ -251,45 +252,38 @@ public class UwbTestUtils {
         AngleOfArrivalMeasurement aoaMeasurement = null;
         AngleOfArrivalMeasurement aoaDestMeasurement = null;
         if (isAoaAzimuthEnabled || isAoaElevationEnabled) {
-            AngleMeasurement aoaAzimuth = null;
-            AngleMeasurement aoaElevation = null;
-            AngleOfArrivalMeasurement.Builder aoaBuilder = null;
-
-            if (isAoaAzimuthEnabled) {
-                aoaAzimuth = new AngleMeasurement(
-                        degreeToRadian(TEST_AOA_AZIMUTH), 0,
-                        TEST_AOA_AZIMUTH_FOM / (double) 100);
-                aoaBuilder = new AngleOfArrivalMeasurement.Builder(aoaAzimuth);
-            }
-            if (isAoaElevationEnabled && aoaBuilder != null) {
-                aoaElevation = new AngleMeasurement(
+            AngleMeasurement aoaAzimuth = isAoaAzimuthEnabled
+                    ? new AngleMeasurement(degreeToRadian(TEST_AOA_AZIMUTH), 0,
+                    TEST_AOA_AZIMUTH_FOM / (double) 100)
+                    : new AngleMeasurement(0, 0, 0);
+            AngleOfArrivalMeasurement.Builder aoaBuilder =
+                    new AngleOfArrivalMeasurement.Builder(aoaAzimuth);
+
+            if (isAoaElevationEnabled) {
+                AngleMeasurement aoaElevation = new AngleMeasurement(
                         degreeToRadian(TEST_AOA_ELEVATION), 0,
                         TEST_AOA_ELEVATION_FOM / (double) 100);
                 aoaBuilder.setAltitude(aoaElevation);
             }
 
-            aoaMeasurement = (aoaBuilder != null) ? aoaBuilder.build() : null;
+            aoaMeasurement = aoaBuilder.build();
         }
         if (isDestAoaAzimuthEnabled || isDestAoaElevationEnabled) {
-            AngleMeasurement aoaDestAzimuth = null;
-            AngleMeasurement aoaDestElevation = null;
-            AngleOfArrivalMeasurement.Builder aoaBuilder = null;
-
-            if (isDestAoaAzimuthEnabled) {
-                aoaDestAzimuth =
-                        new AngleMeasurement(
-                                degreeToRadian(TEST_AOA_DEST_AZIMUTH), 0,
-                                TEST_AOA_DEST_AZIMUTH_FOM / (double) 100);
-                aoaBuilder = new AngleOfArrivalMeasurement.Builder(aoaDestAzimuth);
-            }
-            if (isDestAoaElevationEnabled && aoaBuilder != null) {
-                aoaDestElevation =
-                        new AngleMeasurement(
-                                degreeToRadian(TEST_AOA_DEST_ELEVATION), 0,
-                                TEST_AOA_DEST_ELEVATION_FOM / (double) 100);
-                aoaBuilder.setAltitude(aoaDestElevation);
+            AngleMeasurement aoaAzimuth = isDestAoaAzimuthEnabled
+                    ? new AngleMeasurement(degreeToRadian(TEST_AOA_DEST_AZIMUTH), 0,
+                    TEST_AOA_DEST_AZIMUTH_FOM / (double) 100)
+                    : new AngleMeasurement(0, 0, 0);
+            AngleOfArrivalMeasurement.Builder aoaBuilder =
+                    new AngleOfArrivalMeasurement.Builder(aoaAzimuth);
+
+            if (isDestAoaElevationEnabled) {
+                AngleMeasurement aoaElevation = new AngleMeasurement(
+                        degreeToRadian(TEST_AOA_DEST_ELEVATION), 0,
+                        TEST_AOA_DEST_ELEVATION_FOM / (double) 100);
+                aoaBuilder.setAltitude(aoaElevation);
             }
-            aoaDestMeasurement = (aoaBuilder != null) ? aoaBuilder.build() : null;
+
+            aoaDestMeasurement = aoaBuilder.build();
         }
 
         RangingReport rangingReport = buildRangingReport(macAddress, rangingMeasurementType,
diff --git a/service/java/com/android/server/uwb/config/CapabilityParam.java b/service/java/com/android/server/uwb/config/CapabilityParam.java
index b3019a3c..d81af868 100644
--- a/service/java/com/android/server/uwb/config/CapabilityParam.java
+++ b/service/java/com/android/server/uwb/config/CapabilityParam.java
@@ -254,6 +254,13 @@ public class CapabilityParam {
     public static final int ANTENNA_MODE_DIRECTIONAL =
             (int) UwbVendorCapabilityTlvValues.ANTENNA_MODE_DIRECTIONAL;
 
+    /* Fira Extension Device Capability Parameters */
+    public static final int CCC_EXTENSION_HOPPING_SEQUENCE_AES_BITMASK = 1;
+    public static final int CCC_EXTENSION_HOPPING_SEQUENCE_DEFAULT_BITMASK = 2;
+    public static final int CCC_EXTENSION_HOPPING_MODE_ADAPTIVE_BITMASK = 4;
+    public static final int CCC_EXTENSION_HOPPING_MODE_CONTINUOUS_BITMASK = 8;
+    public static final int CCC_EXTENSION_HOPPING_MODE_NONE_BITMASK = 16;
+
     public static final int RANGE_DATA_NTF_CONFIG_ENABLE = 1 << 0;
     public static final int RANGE_DATA_NTF_CONFIG_DISABLE = 1 << 1;
     public static final int RANGE_DATA_NTF_CONFIG_ENABLE_PROXIMITY_LEVEL_TRIG = 1 << 2;
@@ -267,4 +274,7 @@ public class CapabilityParam {
     public static final int RADAR_SUPPORT = (int) UwbVendorCapabilityTlvTypes.RADAR_SUPPORT;
     public static final int RADAR_SWEEP_SAMPLES_SUPPORTED =
             (int) UwbVendorCapabilityTlvValues.RADAR_SWEEP_SAMPLES_SUPPORTED;
+
+    // Aliro specific
+    public static final int ALIRO_SUPPORTED_MAC_MODES = 0xAC;
 }
diff --git a/service/java/com/android/server/uwb/config/ConfigParam.java b/service/java/com/android/server/uwb/config/ConfigParam.java
index 15e3e2f8..e1e01324 100644
--- a/service/java/com/android/server/uwb/config/ConfigParam.java
+++ b/service/java/com/android/server/uwb/config/ConfigParam.java
@@ -158,6 +158,9 @@ public class ConfigParam {
     public static final int NUMBER_OF_BURSTS_KEY = NUMBER_OF_BURSTS;
     public static final int RADAR_DATA_TYPE_KEY = RADAR_DATA_TYPE;
 
+    // Aliro
+    public static final int ALIRO_MAC_MODE = 0xA9;
+
     //Rf test related config IDs
     public static final int NUMBER_OF_PACKETS = 0x00;
     public static final int T_GAP = 0x01;
diff --git a/service/java/com/android/server/uwb/data/UwbAliroConstants.java b/service/java/com/android/server/uwb/data/UwbAliroConstants.java
index 9d35c9f2..bed40724 100644
--- a/service/java/com/android/server/uwb/data/UwbAliroConstants.java
+++ b/service/java/com/android/server/uwb/data/UwbAliroConstants.java
@@ -22,9 +22,15 @@ public class UwbAliroConstants {
     public static final int HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT = 0X03;
     public static final int HOPPING_CONFIG_MODE_CONTINUOUS_AES = 0X05;
 
-    public static final int HOPPING_CONFIG_MODE_MODE_ADAPTIVE_DEFAULT = 0X02;
-    public static final int HOPPING_CONFIG_MODE_MODE_ADAPTIVE_AES = 0X04;
+    public static final int HOPPING_CONFIG_MODE_ADAPTIVE_DEFAULT = 0X02;
+    public static final int HOPPING_CONFIG_MODE_ADAPTIVE_AES = 0X04;
 
+    /* Fira Extension Application Configuration Parameters*/
+    public static final int ALIRO_EXTENSION_HOPPING_CONFIG_MODE_NONE = 0X00;
+    public static final int ALIRO_EXTENSION_HOPPING_CONFIG_MODE_CONTINUOUS_AES = 0XA0;
+    public static final int ALIRO_EXTENSION_HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT = 0XA1;
+    public static final int ALIRO_EXTENSION_HOPPING_CONFIG_MODE_ADAPTIVE_AES = 0XA2;
+    public static final int ALIRO_EXTENSION_HOPPING_CONFIG_MODE_ADAPTIVE_DEFAULT = 0XA3;
 
     public static final String KEY_STARTING_STS_INDEX = "starting_sts_index";
     public static final String KEY_UWB_TIME_0 = "uwb_time_0";
diff --git a/service/java/com/android/server/uwb/data/UwbCccConstants.java b/service/java/com/android/server/uwb/data/UwbCccConstants.java
index 9deffac1..45d4df8a 100644
--- a/service/java/com/android/server/uwb/data/UwbCccConstants.java
+++ b/service/java/com/android/server/uwb/data/UwbCccConstants.java
@@ -22,10 +22,17 @@ public class UwbCccConstants {
     public static final int HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT = 0X03;
     public static final int HOPPING_CONFIG_MODE_CONTINUOUS_AES = 0X05;
 
-    public static final int HOPPING_CONFIG_MODE_MODE_ADAPTIVE_DEFAULT = 0X02;
-    public static final int HOPPING_CONFIG_MODE_MODE_ADAPTIVE_AES = 0X04;
+    public static final int HOPPING_CONFIG_MODE_ADAPTIVE_DEFAULT = 0X02;
+    public static final int HOPPING_CONFIG_MODE_ADAPTIVE_AES = 0X04;
 
 
+    /* Fira Extension Application Configuration Parameters*/
+    public static final int CCC_EXTENSION_HOPPING_CONFIG_MODE_NONE = 0X00;
+    public static final int CCC_EXTENSION_HOPPING_CONFIG_MODE_CONTINUOUS_AES = 0XA0;
+    public static final int CCC_EXTENSION_HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT = 0XA1;
+    public static final int CCC_EXTENSION_HOPPING_CONFIG_MODE_ADAPTIVE_AES = 0XA2;
+    public static final int CCC_EXTENSION_HOPPING_CONFIG_MODE_ADAPTIVE_DEFAULT = 0XA3;
+
     public static final String KEY_STARTING_STS_INDEX = "starting_sts_index";
     public static final String KEY_UWB_TIME_0 = "uwb_time_0";
     public static final String KEY_HOP_MODE_KEY = "hop_mode_key";
diff --git a/service/java/com/android/server/uwb/data/UwbRangingData.java b/service/java/com/android/server/uwb/data/UwbRangingData.java
index 78b6dafb..57d4174d 100644
--- a/service/java/com/android/server/uwb/data/UwbRangingData.java
+++ b/service/java/com/android/server/uwb/data/UwbRangingData.java
@@ -23,6 +23,7 @@ public class UwbRangingData {
     public int mRcrIndication;
     public long mCurrRangingInterval;
     public int mRangingMeasuresType;
+    public long mHusPrimarySessionId;
     public int mMacAddressMode;
     public int mNoOfRangingMeasures;
     public UwbTwoWayMeasurement[] mRangingTwoWayMeasures;
@@ -31,14 +32,15 @@ public class UwbRangingData {
     public UwbDlTDoAMeasurement[] mUwbDlTDoAMeasurements;
 
     public UwbRangingData(long seqCounter, long sessionId, int rcrIndication,
-            long currRangingInterval, int rangingMeasuresType, int macAddressMode,
-            int noOfRangingMeasures, UwbTwoWayMeasurement[] rangingTwoWayMeasures,
-            byte[] rawNtfData) {
+            long currRangingInterval, int rangingMeasuresType, long husPrimarySessionId,
+            int macAddressMode, int noOfRangingMeasures,
+            UwbTwoWayMeasurement[] rangingTwoWayMeasures, byte[] rawNtfData) {
         this.mSeqCounter = seqCounter;
         this.mSessionId = sessionId;
         this.mRcrIndication = rcrIndication;
         this.mCurrRangingInterval = currRangingInterval;
         this.mRangingMeasuresType = rangingMeasuresType;
+        this.mHusPrimarySessionId = husPrimarySessionId;
         this.mMacAddressMode = macAddressMode;
         this.mNoOfRangingMeasures = noOfRangingMeasures;
         this.mRangingTwoWayMeasures = rangingTwoWayMeasures;
@@ -46,14 +48,15 @@ public class UwbRangingData {
     }
 
     public UwbRangingData(long seqCounter, long sessionId, int rcrIndication,
-            long currRangingInterval, int rangingMeasuresType, int macAddressMode,
-            int noOfRangingMeasures, UwbOwrAoaMeasurement rangingOwrAoaMeasure,
+            long currRangingInterval, int rangingMeasuresType, long husPrimarySessionId,
+            int macAddressMode, int noOfRangingMeasures, UwbOwrAoaMeasurement rangingOwrAoaMeasure,
             byte[] rawNtfData) {
         this.mSeqCounter = seqCounter;
         this.mSessionId = sessionId;
         this.mRcrIndication = rcrIndication;
         this.mCurrRangingInterval = currRangingInterval;
         this.mRangingMeasuresType = rangingMeasuresType;
+        this.mHusPrimarySessionId = husPrimarySessionId;
         this.mMacAddressMode = macAddressMode;
         this.mNoOfRangingMeasures = noOfRangingMeasures;
         this.mRangingOwrAoaMeasure = rangingOwrAoaMeasure;
@@ -61,14 +64,15 @@ public class UwbRangingData {
     }
 
     public UwbRangingData(long seqCounter, long sessionId, int rcrIndication,
-            long currRangingInterval, int rangingMeasuresType, int macAddressMode,
-            int noOfRangingMeasures, UwbDlTDoAMeasurement[] uwbDlTDoAMeasurements,
-            byte[] rawNtfData) {
+            long currRangingInterval, int rangingMeasuresType, long husPrimarySessionId,
+            int macAddressMode, int noOfRangingMeasures,
+            UwbDlTDoAMeasurement[] uwbDlTDoAMeasurements, byte[] rawNtfData) {
         this.mSeqCounter = seqCounter;
         this.mSessionId = sessionId;
         this.mRcrIndication = rcrIndication;
         this.mCurrRangingInterval = currRangingInterval;
         this.mRangingMeasuresType = rangingMeasuresType;
+        this.mHusPrimarySessionId = husPrimarySessionId;
         this.mMacAddressMode = macAddressMode;
         this.mNoOfRangingMeasures = noOfRangingMeasures;
         this.mUwbDlTDoAMeasurements = uwbDlTDoAMeasurements;
@@ -95,6 +99,10 @@ public class UwbRangingData {
         return mRangingMeasuresType;
     }
 
+    public long getHusPrimarySessionId() {
+        return mHusPrimarySessionId;
+    }
+
     public int getMacAddressMode() {
         return mMacAddressMode;
     }
@@ -127,6 +135,7 @@ public class UwbRangingData {
                     + ", RcrIndication = " + mRcrIndication
                     + ", CurrRangingInterval = " + mCurrRangingInterval
                     + ", RangingMeasuresType = " + mRangingMeasuresType
+                    + ", HusPrimarySessionId = " + mHusPrimarySessionId
                     + ", MacAddressMode = " + mMacAddressMode
                     + ", NoOfRangingMeasures = " + mNoOfRangingMeasures
                     + ", RangingTwoWayMeasures = " + Arrays.toString(mRangingTwoWayMeasures)
@@ -139,6 +148,7 @@ public class UwbRangingData {
                     + ", RcrIndication = " + mRcrIndication
                     + ", CurrRangingInterval = " + mCurrRangingInterval
                     + ", RangingMeasuresType = " + mRangingMeasuresType
+                    + ", HusPrimarySessionId = " + mHusPrimarySessionId
                     + ", MacAddressMode = " + mMacAddressMode
                     + ", NoOfRangingMeasures = " + mNoOfRangingMeasures
                     + ", RangingOwrAoaMeasure = " + mRangingOwrAoaMeasure.toString()
@@ -151,6 +161,7 @@ public class UwbRangingData {
                     + ", RcrIndication = " + mRcrIndication
                     + ", CurrRangingInterval = " + mCurrRangingInterval
                     + ", RangingMeasuresType = " + mRangingMeasuresType
+                    + ", HusPrimarySessionId = " + mHusPrimarySessionId
                     + ", MacAddressMode = " + mMacAddressMode
                     + ", NoOfRangingMeasures = " + mNoOfRangingMeasures
                     + ", RangingDlTDoAMeasure = " + Arrays.toString(mUwbDlTDoAMeasurements)
diff --git a/service/java/com/android/server/uwb/data/UwbUciConstants.java b/service/java/com/android/server/uwb/data/UwbUciConstants.java
index 2b179702..8d89dc08 100644
--- a/service/java/com/android/server/uwb/data/UwbUciConstants.java
+++ b/service/java/com/android/server/uwb/data/UwbUciConstants.java
@@ -49,6 +49,8 @@ public class UwbUciConstants {
             FiraParams.SESSION_TYPE_RANGING_AND_IN_BAND_DATA;
     public static final byte SESSION_TYPE_ALIRO = (byte) AliroParams.SESSION_TYPE_ALIRO;
     public static final byte SESSION_TYPE_CCC = (byte) CccParams.SESSION_TYPE_CCC;
+    public static final byte SESSION_TYPE_HUS_PRIMARY_SESSION =
+            (byte) FiraParams.SESSION_TYPE_HUS_PRIMARY_SESSION;
     public static final byte SESSION_TYPE_DEVICE_TEST_MODE =
             (byte) FiraParams.SESSION_TYPE_DEVICE_TEST_MODE;
 
@@ -118,6 +120,8 @@ public class UwbUciConstants {
     public static final int DEVICE_TYPE_CONTROLEE = FiraParams.RANGING_DEVICE_TYPE_CONTROLEE;
     public static final int DEVICE_TYPE_CONTROLLER = FiraParams.RANGING_DEVICE_TYPE_CONTROLLER;
 
+    public static final int CCC_DEVICE_TYPE_CONTROLLER = CccParams.CCC_DEVICE_TYPE_CONTROLLER;
+
     public static final int ROUND_USAGE_SS_TWR_DEFERRED_MODE =
             FiraParams.RANGING_ROUND_USAGE_SS_TWR_DEFERRED_MODE;
     public static final int ROUND_USAGE_DS_TWR_DEFERRED_MODE =
@@ -138,8 +142,7 @@ public class UwbUciConstants {
 
     public static final int CONTENTION_BASED_RANGING = FiraParams.CONTENTION_BASED_RANGING;
     public static final int TIME_SCHEDULED_RANGING = FiraParams.TIME_SCHEDULED_RANGING;
-    public static final int HYBRID_SCHEDULED_RANGING =
-            FiraParams.HYBRID_SCHEDULED_RANGING;
+    public static final int HYBRID_SCHEDULED_RANGING = FiraParams.HYBRID_SCHEDULED_RANGING;
 
     public static final int CONSTRAINT_LENGTH_3 = FiraParams.CONSTRAINT_LENGTH_3;
     public static final int CONSTRAINT_LENGTH_7 = FiraParams.CONSTRAINT_LENGTH_7;
diff --git a/service/java/com/android/server/uwb/jni/NativeUwbManager.java b/service/java/com/android/server/uwb/jni/NativeUwbManager.java
index 90ed32e6..2da1d028 100644
--- a/service/java/com/android/server/uwb/jni/NativeUwbManager.java
+++ b/service/java/com/android/server/uwb/jni/NativeUwbManager.java
@@ -33,6 +33,7 @@ import com.android.server.uwb.data.UwbUciConstants;
 import com.android.server.uwb.data.UwbVendorUciResponse;
 import com.android.server.uwb.info.UwbPowerStats;
 import com.android.server.uwb.multchip.UwbMultichipData;
+import com.android.server.uwb.rftest.UwbTestPerRxResult;
 import com.android.server.uwb.rftest.UwbTestPeriodicTxResult;
 
 import java.util.Arrays;
@@ -137,6 +138,11 @@ public class NativeUwbManager {
         mSessionListener.onRfTestNotificationReceived(periodicTx);
     }
 
+    public void onPerRxDataNotificationReceived(UwbTestPerRxResult perRxResult) {
+        Log.d(TAG, "onPerRxDataNotificationReceived : " + perRxResult);
+        mSessionListener.onRfTestNotificationReceived(perRxResult);
+    }
+
     /**
      * Enable UWB hardware.
      *
@@ -339,6 +345,19 @@ public class NativeUwbManager {
         }
     }
 
+    /**
+     * Starts a Per Rx test
+     *
+     * @param psduData : PSDU data
+     * @param chipId   : Identifier of UWB chip for multi-HAL devices
+     * @return : {@link UwbUciConstants}  Status code
+     */
+    public byte testPerRx(byte[] psduData, String chipId) {
+        synchronized (mNativeLock) {
+            return nativeTestPerRx(psduData, chipId);
+        }
+    }
+
     /*
      * Stops the ongoing Rf test session.
      *
@@ -496,10 +515,10 @@ public class NativeUwbManager {
      */
     public byte setDataTransferPhaseConfig(int sessionId, byte dtpcmRepetition,
             byte dataTransferControl, byte dtpmlSize, byte[] macAddress, byte[] slotBitmap,
-            String chipId) {
+                    byte[] stopDataTransfer, String chipId) {
         synchronized (mNativeLock) {
             return nativeSessionDataTransferPhaseConfig(sessionId, dtpcmRepetition,
-                dataTransferControl, dtpmlSize, macAddress, slotBitmap, chipId);
+                dataTransferControl, dtpmlSize, macAddress, slotBitmap, stopDataTransfer, chipId);
         }
     }
 
@@ -572,17 +591,16 @@ public class NativeUwbManager {
      *
      * @param sessionId : Primary session ID
      * @param numberOfPhases : Number of secondary sessions
-     * @param updateTime : Absolute time in UWBS Time domain
      * @param phaseList : list of secondary sessions which have been previously initialized and
      *                  configured
      * @param chipId : Identifier of UWB chip for multi-HAL devices
      * @return Byte representing the status of the operation
      */
-    public byte setHybridSessionControllerConfiguration(int sessionId, byte messageControl,
-            int numberOfPhases, byte[] updateTime, byte[] phaseList, String chipId) {
+    public byte setHybridSessionControllerConfiguration(int sessionId, int numberOfPhases,
+                byte[] phaseList, String chipId) {
         synchronized (mNativeLock) {
-            return nativeSetHybridSessionControllerConfigurations(sessionId, messageControl,
-                numberOfPhases, updateTime, phaseList, chipId);
+            return nativeSetHybridSessionControllerConfigurations(sessionId, numberOfPhases,
+                phaseList, chipId);
         }
     }
 
@@ -608,7 +626,7 @@ public class NativeUwbManager {
 
     private native byte nativeSessionDataTransferPhaseConfig(int sessionId, byte dtpcmRepetition,
             byte dataTransferControl, byte dtpmlSize, byte[] macAddress, byte[] slotBitmap,
-            String chipId);
+            byte[] stopDataTransfer, String chipId);
 
     private native long nativeDispatcherNew(Object[] chipIds);
 
@@ -671,8 +689,7 @@ public class NativeUwbManager {
     private native int nativeGetSessionToken(int sessionId, String chipId);
 
     private native byte nativeSetHybridSessionControllerConfigurations(int sessionId,
-            byte messageControl, int noOfPhases, byte[] updateTime, byte[] phaseList,
-                String chipId);
+            int noOfPhases, byte[] phaseList, String chipId);
 
     private native byte nativeSetHybridSessionControleeConfigurations(int sessionId,
             int noOfPhases, byte[] phaseList, String chipId);
@@ -682,5 +699,7 @@ public class NativeUwbManager {
 
     private native byte nativeTestPeriodicTx(byte[] psduData, String chipId);
 
+    private native byte nativeTestPerRx(byte[] psduData, String chipId);
+
     private native byte nativeStopRfTest(String chipId);
 }
diff --git a/service/java/com/android/server/uwb/params/AliroDecoder.java b/service/java/com/android/server/uwb/params/AliroDecoder.java
index d7aab3b2..79e81a07 100644
--- a/service/java/com/android/server/uwb/params/AliroDecoder.java
+++ b/service/java/com/android/server/uwb/params/AliroDecoder.java
@@ -16,6 +16,7 @@
 
 package com.android.server.uwb.params;
 
+import static com.android.server.uwb.config.CapabilityParam.ALIRO_SUPPORTED_MAC_MODES;
 import static com.android.server.uwb.config.CapabilityParam.CCC_CHANNEL_5;
 import static com.android.server.uwb.config.CapabilityParam.CCC_CHANNEL_9;
 import static com.android.server.uwb.config.CapabilityParam.CCC_CHAPS_PER_SLOT_12;
@@ -25,6 +26,11 @@ import static com.android.server.uwb.config.CapabilityParam.CCC_CHAPS_PER_SLOT_4
 import static com.android.server.uwb.config.CapabilityParam.CCC_CHAPS_PER_SLOT_6;
 import static com.android.server.uwb.config.CapabilityParam.CCC_CHAPS_PER_SLOT_8;
 import static com.android.server.uwb.config.CapabilityParam.CCC_CHAPS_PER_SLOT_9;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_MODE_ADAPTIVE_BITMASK;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_MODE_CONTINUOUS_BITMASK;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_MODE_NONE_BITMASK;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_SEQUENCE_AES_BITMASK;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_SEQUENCE_DEFAULT_BITMASK;
 import static com.android.server.uwb.config.CapabilityParam.CCC_HOPPING_CONFIG_MODE_ADAPTIVE;
 import static com.android.server.uwb.config.CapabilityParam.CCC_HOPPING_CONFIG_MODE_CONTINUOUS;
 import static com.android.server.uwb.config.CapabilityParam.CCC_HOPPING_CONFIG_MODE_NONE;
@@ -214,21 +220,39 @@ public class AliroDecoder extends TlvDecoder {
                 builder.addChannel(UWB_CHANNEL_9);
             }
         }
+
+        boolean isFiraExtensionSupported =
+                mUwbInjector.getDeviceConfigFacade().isFiraSupportedExtensionForCCC();
         byte hoppingConfigModesAndSequences =
                 tlvs.getByte(CCC_SUPPORTED_HOPPING_CONFIG_MODES_AND_SEQUENCES);
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_CONFIG_MODE_NONE)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_MODE_NONE_BITMASK :
+                        CCC_HOPPING_CONFIG_MODE_NONE)) {
             builder.addHoppingConfigMode(HOPPING_CONFIG_MODE_NONE);
         }
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_CONFIG_MODE_CONTINUOUS)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_MODE_CONTINUOUS_BITMASK :
+                        CCC_HOPPING_CONFIG_MODE_CONTINUOUS)) {
             builder.addHoppingConfigMode(HOPPING_CONFIG_MODE_CONTINUOUS);
         }
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_CONFIG_MODE_ADAPTIVE)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_MODE_ADAPTIVE_BITMASK :
+                        CCC_HOPPING_CONFIG_MODE_ADAPTIVE)) {
             builder.addHoppingConfigMode(HOPPING_CONFIG_MODE_ADAPTIVE);
         }
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_SEQUENCE_AES)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_SEQUENCE_AES_BITMASK :
+                        CCC_HOPPING_SEQUENCE_AES)) {
             builder.addHoppingSequence(HOPPING_SEQUENCE_AES);
         }
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_SEQUENCE_DEFAULT)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_SEQUENCE_DEFAULT_BITMASK :
+                        CCC_HOPPING_SEQUENCE_DEFAULT)) {
             builder.addHoppingSequence(HOPPING_SEQUENCE_DEFAULT);
         }
 
@@ -254,6 +278,14 @@ public class AliroDecoder extends TlvDecoder {
         } catch (IllegalArgumentException e) {
             Log.w(TAG, "CCC_SUPPORTED_UWBS_MAX_PPM not found");
         }
+        try {
+            byte[] modes = tlvs.getByteArray(ALIRO_SUPPORTED_MAC_MODES);
+            for (int i = 0; i < modes.length; i++) {
+                builder.addMacMode(modes[i]);
+            }
+        } catch (IllegalArgumentException e) {
+            Log.w(TAG, "ALIRO_SUPPORTED_MAC_MODES not found");
+        }
 
         return builder.build();
     }
diff --git a/service/java/com/android/server/uwb/params/AliroEncoder.java b/service/java/com/android/server/uwb/params/AliroEncoder.java
index 9765d85b..46a6eb2c 100644
--- a/service/java/com/android/server/uwb/params/AliroEncoder.java
+++ b/service/java/com/android/server/uwb/params/AliroEncoder.java
@@ -57,30 +57,52 @@ public class AliroEncoder extends TlvEncoder {
         AliroOpenRangingParams params = (AliroOpenRangingParams) baseParam;
         int hoppingConfig = params.getHoppingConfigMode();
         int hoppingSequence = params.getHoppingSequence();
-
-        int hoppingMode = AliroParams.HOPPING_CONFIG_MODE_NONE;
+        boolean isFiraExtensionSupported =
+                mUwbInjector.getDeviceConfigFacade().isFiraSupportedExtensionForCCC();
+        int hoppingMode = isFiraExtensionSupported
+                ? UwbAliroConstants.ALIRO_EXTENSION_HOPPING_CONFIG_MODE_NONE :
+                AliroParams.HOPPING_CONFIG_MODE_NONE;
         byte[] protocolVer = params.getProtocolVersion().toBytes();
 
         switch (hoppingConfig) {
 
             case AliroParams.HOPPING_CONFIG_MODE_CONTINUOUS:
                 if (hoppingSequence == AliroParams.HOPPING_SEQUENCE_DEFAULT) {
-                    hoppingMode = UwbAliroConstants.HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT;
+                    hoppingMode =
+                            isFiraExtensionSupported
+                                    ? UwbAliroConstants
+                                    .ALIRO_EXTENSION_HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT :
+                                    UwbAliroConstants.HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT;
+
                 } else {
-                    hoppingMode = UwbAliroConstants.HOPPING_CONFIG_MODE_CONTINUOUS_AES;
+                    hoppingMode =
+                            isFiraExtensionSupported
+                                    ? UwbAliroConstants
+                                    .ALIRO_EXTENSION_HOPPING_CONFIG_MODE_CONTINUOUS_AES :
+                                    UwbAliroConstants.HOPPING_CONFIG_MODE_CONTINUOUS_AES;
                 }
                 break;
             case AliroParams.HOPPING_CONFIG_MODE_ADAPTIVE:
                 if (hoppingSequence == AliroParams.HOPPING_SEQUENCE_DEFAULT) {
-                    hoppingMode = UwbAliroConstants.HOPPING_CONFIG_MODE_MODE_ADAPTIVE_DEFAULT;
+                    hoppingMode =
+                            isFiraExtensionSupported
+                                    ? UwbAliroConstants
+                                    .ALIRO_EXTENSION_HOPPING_CONFIG_MODE_ADAPTIVE_DEFAULT :
+                                    UwbAliroConstants.HOPPING_CONFIG_MODE_ADAPTIVE_DEFAULT;
                 } else {
-                    hoppingMode = UwbAliroConstants.HOPPING_CONFIG_MODE_MODE_ADAPTIVE_AES;
+                    hoppingMode =
+                            isFiraExtensionSupported
+                                    ? UwbAliroConstants
+                                    .ALIRO_EXTENSION_HOPPING_CONFIG_MODE_ADAPTIVE_AES :
+                                    UwbAliroConstants.HOPPING_CONFIG_MODE_ADAPTIVE_AES;
                 }
                 break;
         }
 
         TlvBuffer.Builder tlvBufferBuilder = new TlvBuffer.Builder()
                 .putByte(ConfigParam.DEVICE_TYPE,
+                        mUwbInjector.getDeviceConfigFacade().isFiraSupportedExtensionForCCC()
+                        ? (byte) UwbUciConstants.CCC_DEVICE_TYPE_CONTROLLER :
                         (byte) UwbUciConstants.DEVICE_TYPE_CONTROLLER) // DEVICE_TYPE
                 .putByte(ConfigParam.STS_CONFIG,
                         (byte) UwbUciConstants.STS_MODE_DYNAMIC) // STS_CONFIG
@@ -109,7 +131,16 @@ public class AliroEncoder extends TlvEncoder {
                 .putShort(ConfigParam.SLOT_DURATION,
                         (short) (params.getNumChapsPerSlot() * 400)) // SLOT_DURATION
                 .putByte(ConfigParam.PREAMBLE_CODE_INDEX,
-                        (byte) params.getSyncCodeIndex()); // PREAMBLE_CODE_INDEX
+                        (byte) params.getSyncCodeIndex()) // PREAMBLE_CODE_INDEX
+                .putByte(ConfigParam.ALIRO_MAC_MODE,
+                        (byte) (params.getMacModeRound() << 6
+                                | params.getMacModeOffset())); // MAC_MODE
+
+        byte[] sessionKey = params.getSessionKey();
+        if (sessionKey != null) {
+            tlvBufferBuilder.putByteArray(ConfigParam.SESSION_KEY, sessionKey);
+        }
+
         if (params.getStsIndex() != AliroParams.STS_INDEX_UNSET) {
             tlvBufferBuilder.putInt(ConfigParam.STS_INDEX, params.getStsIndex());
         }
diff --git a/service/java/com/android/server/uwb/params/CccDecoder.java b/service/java/com/android/server/uwb/params/CccDecoder.java
index cd64e8bf..037d06ca 100644
--- a/service/java/com/android/server/uwb/params/CccDecoder.java
+++ b/service/java/com/android/server/uwb/params/CccDecoder.java
@@ -25,6 +25,11 @@ import static com.android.server.uwb.config.CapabilityParam.CCC_CHAPS_PER_SLOT_4
 import static com.android.server.uwb.config.CapabilityParam.CCC_CHAPS_PER_SLOT_6;
 import static com.android.server.uwb.config.CapabilityParam.CCC_CHAPS_PER_SLOT_8;
 import static com.android.server.uwb.config.CapabilityParam.CCC_CHAPS_PER_SLOT_9;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_MODE_ADAPTIVE_BITMASK;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_MODE_CONTINUOUS_BITMASK;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_MODE_NONE_BITMASK;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_SEQUENCE_AES_BITMASK;
+import static com.android.server.uwb.config.CapabilityParam.CCC_EXTENSION_HOPPING_SEQUENCE_DEFAULT_BITMASK;
 import static com.android.server.uwb.config.CapabilityParam.CCC_HOPPING_CONFIG_MODE_ADAPTIVE;
 import static com.android.server.uwb.config.CapabilityParam.CCC_HOPPING_CONFIG_MODE_CONTINUOUS;
 import static com.android.server.uwb.config.CapabilityParam.CCC_HOPPING_CONFIG_MODE_NONE;
@@ -232,21 +237,38 @@ public class CccDecoder extends TlvDecoder {
                 builder.addChannel(UWB_CHANNEL_9);
             }
         }
+        boolean isFiraExtensionSupported =
+                mUwbInjector.getDeviceConfigFacade().isFiraSupportedExtensionForCCC();
         byte hoppingConfigModesAndSequences =
                 tlvs.getByte(CCC_SUPPORTED_HOPPING_CONFIG_MODES_AND_SEQUENCES);
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_CONFIG_MODE_NONE)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_MODE_NONE_BITMASK :
+                        CCC_HOPPING_CONFIG_MODE_NONE)) {
             builder.addHoppingConfigMode(HOPPING_CONFIG_MODE_NONE);
         }
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_CONFIG_MODE_CONTINUOUS)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_MODE_CONTINUOUS_BITMASK :
+                        CCC_HOPPING_CONFIG_MODE_CONTINUOUS)) {
             builder.addHoppingConfigMode(HOPPING_CONFIG_MODE_CONTINUOUS);
         }
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_CONFIG_MODE_ADAPTIVE)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_MODE_ADAPTIVE_BITMASK :
+                        CCC_HOPPING_CONFIG_MODE_ADAPTIVE)) {
             builder.addHoppingConfigMode(HOPPING_CONFIG_MODE_ADAPTIVE);
         }
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_SEQUENCE_AES)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_SEQUENCE_AES_BITMASK :
+                        CCC_HOPPING_SEQUENCE_AES)) {
             builder.addHoppingSequence(HOPPING_SEQUENCE_AES);
         }
-        if (isBitSet(hoppingConfigModesAndSequences, CCC_HOPPING_SEQUENCE_DEFAULT)) {
+        if (isBitSet(hoppingConfigModesAndSequences,
+                isFiraExtensionSupported
+                        ? CCC_EXTENSION_HOPPING_SEQUENCE_DEFAULT_BITMASK :
+                        CCC_HOPPING_SEQUENCE_DEFAULT)) {
             builder.addHoppingSequence(HOPPING_SEQUENCE_DEFAULT);
         }
 
diff --git a/service/java/com/android/server/uwb/params/CccEncoder.java b/service/java/com/android/server/uwb/params/CccEncoder.java
index 0daa1c75..c39e7838 100644
--- a/service/java/com/android/server/uwb/params/CccEncoder.java
+++ b/service/java/com/android/server/uwb/params/CccEncoder.java
@@ -57,31 +57,52 @@ public class CccEncoder extends TlvEncoder {
         CccOpenRangingParams params = (CccOpenRangingParams) baseParam;
         int hoppingConfig = params.getHoppingConfigMode();
         int hoppingSequence = params.getHoppingSequence();
-
-        int hoppingMode = CccParams.HOPPING_CONFIG_MODE_NONE;
+        boolean isFiraExtensionSupported =
+                mUwbInjector.getDeviceConfigFacade().isFiraSupportedExtensionForCCC();
+        int hoppingMode = isFiraExtensionSupported
+                ? UwbCccConstants.CCC_EXTENSION_HOPPING_CONFIG_MODE_NONE :
+                CccParams.HOPPING_CONFIG_MODE_NONE;
         byte[] protocolVer = params.getProtocolVersion().toBytes();
 
         switch (hoppingConfig) {
 
             case CccParams.HOPPING_CONFIG_MODE_CONTINUOUS:
                 if (hoppingSequence == CccParams.HOPPING_SEQUENCE_DEFAULT) {
-                    hoppingMode = UwbCccConstants.HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT;
+                    hoppingMode =
+                            isFiraExtensionSupported
+                                    ? UwbCccConstants
+                                            .CCC_EXTENSION_HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT :
+                                    UwbCccConstants.HOPPING_CONFIG_MODE_CONTINUOUS_DEFAULT;
                 } else {
-                    hoppingMode = UwbCccConstants.HOPPING_CONFIG_MODE_CONTINUOUS_AES;
+                    hoppingMode =
+                            isFiraExtensionSupported
+                                    ? UwbCccConstants
+                                            .CCC_EXTENSION_HOPPING_CONFIG_MODE_CONTINUOUS_AES :
+                                    UwbCccConstants.HOPPING_CONFIG_MODE_CONTINUOUS_AES;
                 }
                 break;
             case CccParams.HOPPING_CONFIG_MODE_ADAPTIVE:
                 if (hoppingSequence == CccParams.HOPPING_SEQUENCE_DEFAULT) {
-                    hoppingMode = UwbCccConstants.HOPPING_CONFIG_MODE_MODE_ADAPTIVE_DEFAULT;
+                    hoppingMode =
+                            isFiraExtensionSupported
+                                    ? UwbCccConstants
+                                            .CCC_EXTENSION_HOPPING_CONFIG_MODE_ADAPTIVE_DEFAULT :
+                                    UwbCccConstants.HOPPING_CONFIG_MODE_ADAPTIVE_DEFAULT;
                 } else {
-                    hoppingMode = UwbCccConstants.HOPPING_CONFIG_MODE_MODE_ADAPTIVE_AES;
+                    hoppingMode =
+                            isFiraExtensionSupported
+                                    ? UwbCccConstants
+                                            .CCC_EXTENSION_HOPPING_CONFIG_MODE_ADAPTIVE_AES :
+                                    UwbCccConstants.HOPPING_CONFIG_MODE_ADAPTIVE_AES;
                 }
                 break;
         }
 
         TlvBuffer.Builder tlvBufferBuilder = new TlvBuffer.Builder()
                 .putByte(ConfigParam.DEVICE_TYPE,
-                        (byte) UwbUciConstants.DEVICE_TYPE_CONTROLLER) // DEVICE_TYPE
+                        mUwbInjector.getDeviceConfigFacade().isFiraSupportedExtensionForCCC()
+                                ? (byte) UwbUciConstants.CCC_DEVICE_TYPE_CONTROLLER :
+                                (byte) UwbUciConstants.DEVICE_TYPE_CONTROLLER) // DEVICE_TYPE
                 .putByte(ConfigParam.STS_CONFIG,
                         (byte) UwbUciConstants.STS_MODE_DYNAMIC) // STS_CONFIG
                 .putByte(ConfigParam.CHANNEL_NUMBER, (byte) params.getChannel()) // CHANNEL_ID
diff --git a/service/java/com/android/server/uwb/params/FiraEncoder.java b/service/java/com/android/server/uwb/params/FiraEncoder.java
index e17a28dd..b790ca7d 100644
--- a/service/java/com/android/server/uwb/params/FiraEncoder.java
+++ b/service/java/com/android/server/uwb/params/FiraEncoder.java
@@ -120,11 +120,13 @@ public class FiraEncoder extends TlvEncoder {
                 .putByte(ConfigParam.RESULT_REPORT_CONFIG, (byte) resultReportConfig)
                 .putByte(ConfigParam.IN_BAND_TERMINATION_ATTEMPT_COUNT,
                         (byte) params.getInBandTerminationAttemptCount())
-                .putByte(ConfigParam.BPRF_PHR_DATA_RATE,
-                        (byte) params.getBprfPhrDataRate())
                 .putShort(ConfigParam.MAX_NUMBER_OF_MEASUREMENTS,
                         (short) params.getMaxNumberOfMeasurements())
                 .putByte(ConfigParam.STS_LENGTH, (byte) params.getStsLength());
+        if (params.getPrfMode() == FiraParams.PRF_MODE_BPRF) {
+            tlvBufferBuilder.putByte(
+                ConfigParam.BPRF_PHR_DATA_RATE, (byte) params.getBprfPhrDataRate());
+        }
         if (params.getDeviceRole() != FiraParams.RANGING_DEVICE_UT_TAG) {
             tlvBufferBuilder.putInt(ConfigParam.RANGING_INTERVAL, params.getRangingIntervalMs());
         }
diff --git a/service/java/com/android/server/uwb/params/GenericDecoder.java b/service/java/com/android/server/uwb/params/GenericDecoder.java
index b70b59f8..feb80fab 100644
--- a/service/java/com/android/server/uwb/params/GenericDecoder.java
+++ b/service/java/com/android/server/uwb/params/GenericDecoder.java
@@ -88,7 +88,7 @@ public class GenericDecoder extends TlvDecoder {
                             .getParams(tlvs, RadarSpecificationParams.class, protocolVersion);
             builder.setRadarSpecificationParams(radarSpecificationParams);
         } catch (IllegalArgumentException e) {
-            Log.v(TAG, "Failed to decode Radar capabilities", e);
+            Log.v(TAG, "Failed to decode Radar capabilities");
         }
         try {
             byte supported_power_stats_query = tlvs.getByte(SUPPORTED_POWER_STATS_QUERY);
diff --git a/service/java/com/android/server/uwb/rftest/UwbTestPerRxResult.java b/service/java/com/android/server/uwb/rftest/UwbTestPerRxResult.java
new file mode 100644
index 00000000..6dfd1c49
--- /dev/null
+++ b/service/java/com/android/server/uwb/rftest/UwbTestPerRxResult.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.uwb.rftest;
+
+import android.os.PersistableBundle;
+
+import com.android.server.uwb.util.UwbUtil;
+import com.google.uwb.support.rftest.RfTestParams;
+import com.google.uwb.support.rftest.RfTestPerRxResult;
+
+public class UwbTestPerRxResult implements RfNotificationEvent {
+    private int mStatus;
+    private long mAttempts;
+    private long mAcqDetect;
+    private long mAcqReject;
+    private long mRxFail;
+    private long mSyncCirReady;
+    private long mSfdFail;
+    private long mSfdFound;
+    private long mPhrDecError;
+    private long mPhrBitError;
+    private long mPsduDecError;
+    private long mPsduBitError;
+    private long mStsFound;
+    private long mEof;
+    private byte[] mRawNotificationData;
+
+    public UwbTestPerRxResult(int status, byte[] rawNotificationData) {
+        this.mStatus = status;
+        this.mRawNotificationData = rawNotificationData;
+    }
+
+    public UwbTestPerRxResult(int status, long attempts, long acqDetect, long acqReject,
+                              long rxFail,  long syncCirReady, long sfdFail, long sfdFound,
+                              long phrDecError, long phrBitError,
+                              long psduDecError, long psduBitError, long stsFound, long eof,
+                              byte[] rawNotificationData) {
+        this.mStatus = status;
+        this.mAttempts = attempts;
+        this.mAcqDetect = acqDetect;
+        this.mAcqReject = acqReject;
+        this.mRxFail = rxFail;
+        this.mSyncCirReady = syncCirReady;
+        this.mSfdFail = sfdFail;
+        this.mSfdFound = sfdFound;
+        this.mPhrDecError = phrDecError;
+        this.mPhrBitError = phrBitError;
+        this.mPsduDecError = psduDecError;
+        this.mPsduBitError = psduBitError;
+        this.mStsFound = stsFound;
+        this.mEof = eof;
+        this.mRawNotificationData = rawNotificationData;
+    }
+
+    @Override
+    public int getStatus() {
+        return mStatus;
+    }
+
+    public long getAttempts() {
+        return mAttempts;
+    }
+
+    public long getAcqDetect() {
+        return mAcqDetect;
+    }
+
+    public long getAcqReject() {
+        return mAcqReject;
+    }
+
+    public long getRxFail() {
+        return mRxFail;
+    }
+
+    public long getSyncCirReady() {
+        return mSyncCirReady;
+    }
+
+    public long getSfdFail() {
+        return mSfdFail;
+    }
+
+    public long getSfdFound() {
+        return mSfdFound;
+    }
+
+    public long getPhrDecError() {
+        return mPhrDecError;
+    }
+
+    public long getPhrBitError() {
+        return mPhrBitError;
+    }
+
+    public long getPsduDecError() {
+        return mPsduDecError;
+    }
+
+    public long getPsduBitError() {
+        return mPsduBitError;
+    }
+
+    public long getStsFound() {
+        return mStsFound;
+    }
+
+    public long getEof() {
+        return mEof;
+    }
+
+    @Override
+    public byte[] getRawNotificationData() {
+        return mRawNotificationData;
+    }
+
+    @Override
+    public int getOperationType() {
+        return RfTestParams.TEST_PER_RX;
+    }
+
+    @Override
+    public PersistableBundle toBundle() {
+        RfTestPerRxResult.Builder periodicRxResult = new RfTestPerRxResult.Builder()
+                .setOperationType(getOperationType())
+                .setStatus(mStatus)
+                .setAttempts(mAttempts)
+                .setAcqDetect(mAcqDetect)
+                .setAcqReject(mAcqReject)
+                .setRxFail(mRxFail)
+                .setSyncCirReady(mSyncCirReady)
+                .setSfdFail(mSfdFail)
+                .setSfdFound(mSfdFound)
+                .setPhrDecError(mPhrDecError)
+                .setPhrBitError(mPhrBitError)
+                .setPsduDecError(mPsduDecError)
+                .setPsduBitError(mPsduBitError)
+                .setStsFound(mStsFound)
+                .setRawNtfData(mRawNotificationData)
+                .setEof(mEof);
+        return periodicRxResult.build().toBundle();
+    }
+
+    @Override
+    public String toString() {
+        return "UwbTestPerRxResult { "
+                + " Status = " + mStatus
+                + ", Attempts = " + mAttempts
+                + ", AcqDetect = " + mAcqDetect
+                + ", AcqReject = " + mAcqReject
+                + ", RxFail = " + mRxFail
+                + ", SyncCirReady = " + mSyncCirReady
+                + ", SfdFail = " + mSfdFail
+                + ", SfdFound = " + mSfdFound
+                + ", PhrDecError = " + mPhrDecError
+                + ", PhrBitError = " + mPhrBitError
+                + ", PsduDecError = " + mPsduDecError
+                + ", PsduBitError = " + mPsduBitError
+                + ", StsFound = " + mStsFound
+                + ", Eof = " + mEof
+                + ", RfOperationType = " + getOperationType()
+                + ", RawNotificationData = " + UwbUtil.toHexString(mRawNotificationData)
+                + '}';
+    }
+}
diff --git a/service/java/com/android/server/uwb/rftest/UwbTestPeriodicTxResult.java b/service/java/com/android/server/uwb/rftest/UwbTestPeriodicTxResult.java
index 312e9483..88dc87c9 100644
--- a/service/java/com/android/server/uwb/rftest/UwbTestPeriodicTxResult.java
+++ b/service/java/com/android/server/uwb/rftest/UwbTestPeriodicTxResult.java
@@ -51,6 +51,7 @@ public class UwbTestPeriodicTxResult implements RfNotificationEvent {
     public PersistableBundle toBundle() {
         RfTestPeriodicTxResult.Builder periodicRxResult = new RfTestPeriodicTxResult.Builder()
                 .setOperationType(getOperationType())
+                .setRawNtfData(mRawNotificationData)
                 .setStatus(mStatus);
 
         return periodicRxResult.build().toBundle();
diff --git a/service/support_lib/src/com/google/uwb/support/aliro/AliroOpenRangingParams.java b/service/support_lib/src/com/google/uwb/support/aliro/AliroOpenRangingParams.java
index bd1f0c38..be66087f 100644
--- a/service/support_lib/src/com/google/uwb/support/aliro/AliroOpenRangingParams.java
+++ b/service/support_lib/src/com/google/uwb/support/aliro/AliroOpenRangingParams.java
@@ -18,12 +18,6 @@ package com.google.uwb.support.aliro;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.uwb.support.aliro.AliroParams.RANGE_DATA_NTF_PROXIMITY_NEAR_DEFAULT;
-import static com.google.uwb.support.aliro.AliroParams.RANGE_DATA_NTF_PROXIMITY_FAR_DEFAULT;
-import static com.google.uwb.support.aliro.AliroParams.RANGE_DATA_NTF_AOA_AZIMUTH_LOWER_DEFAULT;
-import static com.google.uwb.support.aliro.AliroParams.RANGE_DATA_NTF_AOA_AZIMUTH_UPPER_DEFAULT;
-import static com.google.uwb.support.aliro.AliroParams.RANGE_DATA_NTF_AOA_ELEVATION_LOWER_DEFAULT;
-import static com.google.uwb.support.aliro.AliroParams.RANGE_DATA_NTF_AOA_ELEVATION_UPPER_DEFAULT;
 
 import android.os.Build.VERSION_CODES;
 import android.os.PersistableBundle;
@@ -74,6 +68,9 @@ public class AliroOpenRangingParams extends AliroParams {
             "range_data_ntf_aoa_elevation_lower";
     private static final String KEY_RANGE_DATA_NTF_AOA_ELEVATION_UPPER =
             "range_data_ntf_aoa_elevation_upper";
+    private static final String KEY_SESSION_KEY = "session_key";
+    private static final String KEY_MAC_MODE_ROUND = "mac_mode_round";
+    private static final String KEY_MAC_MODE_OFFSET = "mac_mode_offset";
 
     private final AliroProtocolVersion mProtocolVersion;
     @UwbConfig private final int mUwbConfig;
@@ -105,6 +102,9 @@ public class AliroOpenRangingParams extends AliroParams {
     private double mRangeDataNtfAoaAzimuthUpper;
     private double mRangeDataNtfAoaElevationLower;
     private double mRangeDataNtfAoaElevationUpper;
+    private final byte[] mSessionKey;
+    private @MacModeRound int mMacModeRound = MAC_MODE_ROUND_DEFAULT;
+    private final int mMacModeOffset;
 
     private AliroOpenRangingParams(
             AliroProtocolVersion protocolVersion,
@@ -130,7 +130,10 @@ public class AliroOpenRangingParams extends AliroParams {
             double rangeDataNtfAoaAzimuthLower,
             double rangeDataNtfAoaAzimuthUpper,
             double rangeDataNtfAoaElevationLower,
-            double rangeDataNtfAoaElevationUpper) {
+            double rangeDataNtfAoaElevationUpper,
+            byte[] sessionKey,
+            @MacModeRound int macModeRound,
+            int macModeOffset) {
         mProtocolVersion = protocolVersion;
         mUwbConfig = uwbConfig;
         mPulseShapeCombo = pulseShapeCombo;
@@ -155,6 +158,9 @@ public class AliroOpenRangingParams extends AliroParams {
         mRangeDataNtfAoaAzimuthUpper = rangeDataNtfAoaAzimuthUpper;
         mRangeDataNtfAoaElevationLower = rangeDataNtfAoaElevationLower;
         mRangeDataNtfAoaElevationUpper = rangeDataNtfAoaElevationUpper;
+        mSessionKey = sessionKey;
+        mMacModeRound = macModeRound;
+        mMacModeOffset = macModeOffset;
     }
 
     @Override
@@ -162,6 +168,29 @@ public class AliroOpenRangingParams extends AliroParams {
         return BUNDLE_VERSION_CURRENT;
     }
 
+    private static int[] byteArrayToIntArray(byte[] bytes) {
+        if (bytes == null) {
+            return null;
+        }
+
+        int[] values = new int[bytes.length];
+        for (int i = 0; i < values.length; i++) {
+            values[i] = bytes[i];
+        }
+        return values;
+    }
+
+    private static byte[] intArrayToByteArray(int[] values) {
+        if (values == null) {
+            return null;
+        }
+        byte[] bytes = new byte[values.length];
+        for (int i = 0; i < values.length; i++) {
+            bytes[i] = (byte) values[i];
+        }
+        return bytes;
+    }
+
     @Override
     public PersistableBundle toBundle() {
         PersistableBundle bundle = super.toBundle();
@@ -189,6 +218,9 @@ public class AliroOpenRangingParams extends AliroParams {
         bundle.putDouble(KEY_RANGE_DATA_NTF_AOA_AZIMUTH_UPPER, mRangeDataNtfAoaAzimuthUpper);
         bundle.putDouble(KEY_RANGE_DATA_NTF_AOA_ELEVATION_LOWER, mRangeDataNtfAoaElevationLower);
         bundle.putDouble(KEY_RANGE_DATA_NTF_AOA_ELEVATION_UPPER, mRangeDataNtfAoaElevationUpper);
+        bundle.putIntArray(KEY_SESSION_KEY, byteArrayToIntArray(mSessionKey));
+        bundle.putInt(KEY_MAC_MODE_ROUND, mMacModeRound);
+        bundle.putInt(KEY_MAC_MODE_OFFSET, mMacModeOffset);
         return bundle;
     }
 
@@ -248,6 +280,9 @@ public class AliroOpenRangingParams extends AliroParams {
                 .setRangeDataNtfAoaElevationUpper(
                         bundle.getDouble(KEY_RANGE_DATA_NTF_AOA_ELEVATION_UPPER,
                                 RANGE_DATA_NTF_AOA_ELEVATION_UPPER_DEFAULT))
+                .setSessionKey(intArrayToByteArray(bundle.getIntArray(KEY_SESSION_KEY)))
+                .setMacModeRound(bundle.getInt(KEY_MAC_MODE_ROUND, MAC_MODE_ROUND_DEFAULT))
+                .setMacModeOffset(bundle.getInt(KEY_MAC_MODE_OFFSET, MAC_MODE_OFFSET_DEFAULT))
                 .build();
     }
 
@@ -360,6 +395,19 @@ public class AliroOpenRangingParams extends AliroParams {
         return new AliroOpenRangingParams.Builder(this);
     }
 
+    public byte[] getSessionKey() {
+        return mSessionKey;
+    }
+
+    public @MacModeRound int getMacModeRound() {
+        return mMacModeRound;
+    }
+
+    public int getMacModeOffset() {
+        return mMacModeOffset;
+    }
+
+
     /** Builder */
     public static final class Builder {
         private RequiredParam<AliroProtocolVersion> mProtocolVersion = new RequiredParam<>();
@@ -405,6 +453,11 @@ public class AliroOpenRangingParams extends AliroParams {
 
         /** UCI spec default: +90 (No upper-bound filtering) */
         private double mRangeDataNtfAoaElevationUpper = RANGE_DATA_NTF_AOA_ELEVATION_UPPER_DEFAULT;
+        /** Similar to PROVISIONED STS only. 128-bit or 256-bit long */
+        private byte[] mSessionKey = null;
+        private @MacModeRound int mMacModeRound = MAC_MODE_ROUND_DEFAULT;
+        private int mMacModeOffset = 0;
+
 
         public Builder() {}
 
@@ -433,6 +486,9 @@ public class AliroOpenRangingParams extends AliroParams {
             mRangeDataNtfAoaAzimuthUpper = builder.mRangeDataNtfAoaAzimuthUpper;
             mRangeDataNtfAoaElevationLower = builder.mRangeDataNtfAoaElevationLower;
             mRangeDataNtfAoaElevationUpper = builder.mRangeDataNtfAoaElevationUpper;
+            mSessionKey = builder.mSessionKey;
+            mMacModeRound = builder.mMacModeRound;
+            mMacModeOffset = builder.mMacModeOffset;
         }
 
         public Builder(@NonNull AliroOpenRangingParams params) {
@@ -457,6 +513,9 @@ public class AliroOpenRangingParams extends AliroParams {
             mRangeDataNtfAoaAzimuthUpper = params.mRangeDataNtfAoaAzimuthUpper;
             mRangeDataNtfAoaElevationLower = params.mRangeDataNtfAoaElevationLower;
             mRangeDataNtfAoaElevationUpper = params.mRangeDataNtfAoaElevationUpper;
+            mSessionKey = params.mSessionKey;
+            mMacModeRound = params.mMacModeRound;
+            mMacModeOffset = params.mMacModeOffset;
         }
 
         public Builder setProtocolVersion(AliroProtocolVersion version) {
@@ -601,6 +660,24 @@ public class AliroOpenRangingParams extends AliroParams {
             return this;
         }
 
+        /** set session key */
+        public Builder setSessionKey(byte[] sessionKey) {
+            mSessionKey = sessionKey;
+            return this;
+        }
+
+        /** set mac mode round */
+        public Builder setMacModeRound(@MacModeRound int macModeRound) {
+            mMacModeRound = macModeRound;
+            return this;
+        }
+
+        /** set mac mode offset */
+        public Builder setMacModeOffset(int macModeOffset) {
+            mMacModeOffset = macModeOffset;
+            return this;
+        }
+
         private void checkRangeDataNtfConfig() {
             if (mRangeDataNtfConfig == RANGE_DATA_NTF_CONFIG_DISABLE) {
                 checkArgument(mRangeDataNtfProximityNear
@@ -661,6 +738,10 @@ public class AliroOpenRangingParams extends AliroParams {
 
         public AliroOpenRangingParams build() {
             checkRangeDataNtfConfig();
+            checkArgument(mSessionKey == null
+                            || (mSessionKey.length == 16 || mSessionKey.length == 32));
+            checkArgument(mMacModeRound == MAC_MODE_ROUND_1 || mMacModeRound == MAC_MODE_ROUND_2);
+            checkArgument(mMacModeOffset == 0 ^ mMacModeRound == MAC_MODE_ROUND_2);
             return new AliroOpenRangingParams(
                     mProtocolVersion.get(),
                     mUwbConfig.get(),
@@ -685,7 +766,10 @@ public class AliroOpenRangingParams extends AliroParams {
                     mRangeDataNtfAoaAzimuthLower,
                     mRangeDataNtfAoaAzimuthUpper,
                     mRangeDataNtfAoaElevationLower,
-                    mRangeDataNtfAoaElevationUpper);
+                    mRangeDataNtfAoaElevationUpper,
+                    mSessionKey,
+                    mMacModeRound,
+                    mMacModeOffset);
         }
     }
 }
diff --git a/service/support_lib/src/com/google/uwb/support/aliro/AliroParams.java b/service/support_lib/src/com/google/uwb/support/aliro/AliroParams.java
index 2690ad7d..77a27b8d 100644
--- a/service/support_lib/src/com/google/uwb/support/aliro/AliroParams.java
+++ b/service/support_lib/src/com/google/uwb/support/aliro/AliroParams.java
@@ -248,4 +248,18 @@ public abstract class AliroParams extends Params {
     public static final int STS_INDEX_UNSET = 0;
 
     public static final int HOP_MODE_KEY_UNSET = 0;
+
+    /** Mac Mode */
+    @IntDef(
+            value = {
+                MAC_MODE_ROUND_1,
+                MAC_MODE_ROUND_2,
+            })
+    public @interface MacModeRound {}
+    public static final int MAC_MODE_ROUND_1 = 0;
+    public static final int MAC_MODE_ROUND_2 = 1;
+
+    public static final int MAC_MODE_ROUND_DEFAULT = MAC_MODE_ROUND_1;
+
+    public static final int MAC_MODE_OFFSET_DEFAULT = 0;
 }
diff --git a/service/support_lib/src/com/google/uwb/support/aliro/AliroSpecificationParams.java b/service/support_lib/src/com/google/uwb/support/aliro/AliroSpecificationParams.java
index 41522c3e..c942ee46 100644
--- a/service/support_lib/src/com/google/uwb/support/aliro/AliroSpecificationParams.java
+++ b/service/support_lib/src/com/google/uwb/support/aliro/AliroSpecificationParams.java
@@ -56,6 +56,8 @@ public class AliroSpecificationParams extends AliroParams {
     @HoppingConfigMode private final List<Integer> mHoppingConfigModes;
     @HoppingSequence private final List<Integer> mHoppingSequences;
     private final int mUwbsMaxPPM;
+    @MacModeRound
+    private final List<Integer> mMacModes;
 
     private static final String KEY_PROTOCOL_VERSIONS = "protocol_versions";
     private static final String KEY_UWB_CONFIGS = "uwb_configs";
@@ -69,6 +71,7 @@ public class AliroSpecificationParams extends AliroParams {
     private static final String KEY_HOPPING_CONFIGS = "hopping_config_modes";
     private static final String KEY_HOPPING_SEQUENCES = "hopping_sequences";
     private static final String KEY_UWBS_MAX_PPM = "uwbs_max_ppm";
+    private static final String KEY_MAC_MODES = "mac_modes";
 
     public static final int DEFAULT_MAX_RANGING_SESSIONS_NUMBER = 1;
 
@@ -84,7 +87,8 @@ public class AliroSpecificationParams extends AliroParams {
             @Channel List<Integer> channels,
             @HoppingConfigMode List<Integer> hoppingConfigModes,
             @HoppingSequence List<Integer> hoppingSequences,
-            int uwbsMaxPPM) {
+            int uwbsMaxPPM,
+            @MacModeRound List<Integer> macModes) {
         mProtocolVersions = protocolVersions;
         mUwbConfigs = uwbConfigs;
         mPulseShapeCombos = pulseShapeCombos;
@@ -97,6 +101,7 @@ public class AliroSpecificationParams extends AliroParams {
         mHoppingConfigModes = hoppingConfigModes;
         mHoppingSequences = hoppingSequences;
         mUwbsMaxPPM = uwbsMaxPPM;
+        mMacModes = macModes;
     }
 
     @Override
@@ -127,6 +132,7 @@ public class AliroSpecificationParams extends AliroParams {
         bundle.putIntArray(KEY_HOPPING_CONFIGS, toIntArray(mHoppingConfigModes));
         bundle.putIntArray(KEY_HOPPING_SEQUENCES, toIntArray(mHoppingSequences));
         bundle.putInt(KEY_UWBS_MAX_PPM, mUwbsMaxPPM);
+        bundle.putIntArray(KEY_MAC_MODES, toIntArray(mMacModes));
         return bundle;
     }
 
@@ -195,6 +201,10 @@ public class AliroSpecificationParams extends AliroParams {
             builder.setUwbsMaxPPM(bundle.getInt(KEY_UWBS_MAX_PPM));
         }
 
+        for (int mode : checkNotNull(bundle.getIntArray(KEY_MAC_MODES))) {
+            builder.addMacMode(mode);
+        }
+
         return builder.build();
     }
 
@@ -261,6 +271,12 @@ public class AliroSpecificationParams extends AliroParams {
         return mUwbsMaxPPM;
     }
 
+
+    @MacModeRound
+    public List<Integer> getMacModes() {
+        return mMacModes;
+    }
+
     @Override
     public boolean equals(@Nullable Object other) {
         if (other instanceof AliroSpecificationParams) {
@@ -276,7 +292,8 @@ public class AliroSpecificationParams extends AliroParams {
                 && otherSpecificationParams.mChannels.equals(mChannels)
                 && otherSpecificationParams.mHoppingConfigModes.equals(mHoppingConfigModes)
                 && otherSpecificationParams.mHoppingSequences.equals(mHoppingSequences)
-                && otherSpecificationParams.mUwbsMaxPPM == mUwbsMaxPPM;
+                && otherSpecificationParams.mUwbsMaxPPM == mUwbsMaxPPM
+                && otherSpecificationParams.mMacModes.equals(mMacModes);
         }
         return false;
     }
@@ -297,6 +314,7 @@ public class AliroSpecificationParams extends AliroParams {
                 mHoppingConfigModes.hashCode(),
                 mHoppingSequences.hashCode(),
                 mUwbsMaxPPM,
+                mMacModes.hashCode(),
             });
     }
 
@@ -314,6 +332,8 @@ public class AliroSpecificationParams extends AliroParams {
         @HoppingSequence private List<Integer> mHoppingSequences = new ArrayList<>();
         @HoppingConfigMode private List<Integer> mHoppingConfigModes = new ArrayList<>();
         private int mUwbsMaxPPM = 0;
+        @MacModeRound
+        private List<Integer> mMacModes = new ArrayList<>();
 
         public Builder addProtocolVersion(@NonNull AliroProtocolVersion version) {
             mProtocolVersions.add(version);
@@ -394,6 +414,16 @@ public class AliroSpecificationParams extends AliroParams {
             return this;
         }
 
+        /** Add supported mac mode round.
+         * @param macMode the mac mode round number defined in
+         * {@link com.google.uwb.support.aliro.AliroParams.MacModeRound}
+         * @return AliroSpecificationParams builder
+         */
+        public Builder addMacMode(@MacModeRound int macMode) {
+            mMacModes.add(macMode);
+            return this;
+        }
+
         public AliroSpecificationParams build() {
             if (mProtocolVersions.size() == 0) {
                 throw new IllegalStateException("No protocol versions set");
@@ -435,7 +465,8 @@ public class AliroSpecificationParams extends AliroParams {
                     mChannels,
                     mHoppingConfigModes,
                     mHoppingSequences,
-                    mUwbsMaxPPM);
+                    mUwbsMaxPPM,
+                    mMacModes);
         }
     }
 }
diff --git a/service/support_lib/src/com/google/uwb/support/ccc/CccParams.java b/service/support_lib/src/com/google/uwb/support/ccc/CccParams.java
index 029f1385..f976aa28 100644
--- a/service/support_lib/src/com/google/uwb/support/ccc/CccParams.java
+++ b/service/support_lib/src/com/google/uwb/support/ccc/CccParams.java
@@ -207,6 +207,20 @@ public abstract class CccParams extends Params {
             value = {SESSION_TYPE_CCC})
     public @interface SessionType {}
 
+    public static final int SESSION_TYPE_CCC = 0xA0;
+
+    /** Device type */
+    @IntDef(
+            value = {
+                    CCC_DEVICE_TYPE_CONTROLLER,
+                    CCC_DEVICE_TYPE_CONTROLEE,
+            })
+    public @interface CccDeviceType {}
+
+    public static final int CCC_DEVICE_TYPE_CONTROLLER = 0xA0;
+
+    public static final int CCC_DEVICE_TYPE_CONTROLEE = 0xA1;
+
     /** Range Data Notification Config */
     @IntDef(
             value = {
@@ -237,8 +251,6 @@ public abstract class CccParams extends Params {
     public static final double RANGE_DATA_NTF_AOA_ELEVATION_LOWER_DEFAULT = -Math.PI / 2;
     public static final double RANGE_DATA_NTF_AOA_ELEVATION_UPPER_DEFAULT = Math.PI / 2;
 
-    public static final int SESSION_TYPE_CCC = 160;
-
     public static final long UWB_INITIATION_TIME_MS_UNSET = 0;
 
     public static final int STS_INDEX_UNSET = 0;
diff --git a/service/support_lib/src/com/google/uwb/support/ccc/CccSpecificationParams.java b/service/support_lib/src/com/google/uwb/support/ccc/CccSpecificationParams.java
index 3fdf23fa..b00af58a 100644
--- a/service/support_lib/src/com/google/uwb/support/ccc/CccSpecificationParams.java
+++ b/service/support_lib/src/com/google/uwb/support/ccc/CccSpecificationParams.java
@@ -305,7 +305,7 @@ public class CccSpecificationParams extends CccParams {
         @UwbConfig private List<Integer> mUwbConfigs = new ArrayList<>();
         private List<CccPulseShapeCombo> mPulseShapeCombos = new ArrayList<>();
         private RequiredParam<Integer> mRanMultiplier = new RequiredParam<>();
-        private int mMinUwbInitiationTimeMs = -1;
+        private int mMinUwbInitiationTimeMs = 0;
         private int mMaxRangingSessionNumber = DEFAULT_MAX_RANGING_SESSIONS_NUMBER;
         @ChapsPerSlot private List<Integer> mChapsPerSlot = new ArrayList<>();
         @SyncCodeIndex private List<Integer> mSyncCodes = new ArrayList<>();
diff --git a/service/support_lib/src/com/google/uwb/support/fira/FiraDataTransferPhaseConfig.java b/service/support_lib/src/com/google/uwb/support/fira/FiraDataTransferPhaseConfig.java
index 72984ef4..85d84127 100644
--- a/service/support_lib/src/com/google/uwb/support/fira/FiraDataTransferPhaseConfig.java
+++ b/service/support_lib/src/com/google/uwb/support/fira/FiraDataTransferPhaseConfig.java
@@ -42,6 +42,7 @@ public class FiraDataTransferPhaseConfig extends FiraParams {
     private static final String KEY_DATA_TRANSFER_CONTROL = "data_transfer_control";
     private static final String KEY_MAC_ADDRESS_LIST = "mac_address";
     private static final String KEY_SLOT_BITMAP = "slot_bitmap";
+    private static final String KEY_STOP_DATA_TRANSFER = "stop_data_transfer";
 
     @Override
     public int getBundleVersion() {
@@ -74,23 +75,28 @@ public class FiraDataTransferPhaseConfig extends FiraParams {
         bundle.putInt(KEY_DTPCM_REPETITION, mDtpcmRepetition);
         bundle.putInt(KEY_DATA_TRANSFER_CONTROL, mDataTransferControl);
 
-        long[] macAddressList = new long[mDataTransferPhaseManagementList.size()];
+        int dataTransferPhaseManagementListSize = mDataTransferPhaseManagementList.size();
+        long[] macAddressList = new long[dataTransferPhaseManagementListSize];
         int i = 0;
-        ByteBuffer slotBitmapByteBuffer = ByteBuffer.allocate(
-                mDataTransferPhaseManagementList.size()
-                        * (1 << ((mDataTransferControl & 0x0F) >> 1)));
+        ByteBuffer slotBitmapByteBuffer = ByteBuffer.allocate(dataTransferPhaseManagementListSize
+                * (1 << ((mDataTransferControl & 0x0F) >> 1)));
 
         slotBitmapByteBuffer.order(ByteOrder.LITTLE_ENDIAN);
+        ByteBuffer stopDataTransferBuffer =
+                ByteBuffer.allocate(dataTransferPhaseManagementListSize);
 
         for (FiraDataTransferPhaseManagementList dataTransferPhaseManagementList :
                 mDataTransferPhaseManagementList) {
             macAddressList[i++] = uwbAddressToLong(
                 dataTransferPhaseManagementList.getUwbAddress());
             slotBitmapByteBuffer.put(dataTransferPhaseManagementList.getSlotBitMap());
+            stopDataTransferBuffer.put(dataTransferPhaseManagementList.getStopDataTransfer());
         }
 
         bundle.putLongArray(KEY_MAC_ADDRESS_LIST, macAddressList);
         bundle.putIntArray(KEY_SLOT_BITMAP, byteArrayToIntArray(slotBitmapByteBuffer.array()));
+        bundle.putIntArray(KEY_STOP_DATA_TRANSFER, byteArrayToIntArray(
+                stopDataTransferBuffer.array()));
 
         return bundle;
     }
@@ -141,7 +147,7 @@ public class FiraDataTransferPhaseConfig extends FiraParams {
                 new ArrayList<>();
         List<UwbAddress> macAddressList = new ArrayList<>();
         List<byte[]> slotBitmapList = new ArrayList<>();
-
+        List<Byte> stopDataTransferList = new ArrayList<>();
         long[] macAddress = bundle.getLongArray(KEY_MAC_ADDRESS_LIST);
         for (int i = 0; i < macAddress.length; i++) {
             macAddressList.add(longToUwbAddress(macAddress[i],
@@ -161,9 +167,15 @@ public class FiraDataTransferPhaseConfig extends FiraParams {
             slotBitmapList.add(data);
         }
 
+        byte[] stopBuffer = intArrayToByteArray(bundle.getIntArray(KEY_STOP_DATA_TRANSFER));
+        for (int i = 0; i < stopBuffer.length; i++) {
+            stopDataTransferList.add(stopBuffer[i]);
+        }
+
+
         for (int i = 0; i < macAddressList.size(); i++) {
             mDataTransferPhaseManagementList.add(new FiraDataTransferPhaseManagementList(
-                    macAddressList.get(i), slotBitmapList.get(i)));
+                    macAddressList.get(i), slotBitmapList.get(i), stopDataTransferList.get(i)));
         }
 
         builder.setDataTransferPhaseManagementList(mDataTransferPhaseManagementList);
@@ -175,10 +187,13 @@ public class FiraDataTransferPhaseConfig extends FiraParams {
     public static class FiraDataTransferPhaseManagementList {
         private final UwbAddress mUwbAddress;
         private final byte[] mSlotBitMap;
+        private final byte mStopDataTransfer;
 
-        public FiraDataTransferPhaseManagementList(UwbAddress uwbAddress, byte[] slotBitmap) {
+        public FiraDataTransferPhaseManagementList(UwbAddress uwbAddress, byte[] slotBitmap,
+                byte stopDataTransfer) {
             mUwbAddress = uwbAddress;
             mSlotBitMap = slotBitmap;
+            mStopDataTransfer = stopDataTransfer;
         }
 
         public UwbAddress getUwbAddress() {
@@ -188,6 +203,9 @@ public class FiraDataTransferPhaseConfig extends FiraParams {
         public byte[] getSlotBitMap() {
             return mSlotBitMap;
         }
+        public byte getStopDataTransfer() {
+            return mStopDataTransfer;
+        }
     }
 
     /** Builder */
diff --git a/service/support_lib/src/com/google/uwb/support/fira/FiraHybridSessionControleeConfig.java b/service/support_lib/src/com/google/uwb/support/fira/FiraHybridSessionControleeConfig.java
index 1a535865..271d1ec9 100644
--- a/service/support_lib/src/com/google/uwb/support/fira/FiraHybridSessionControleeConfig.java
+++ b/service/support_lib/src/com/google/uwb/support/fira/FiraHybridSessionControleeConfig.java
@@ -92,7 +92,6 @@ public class FiraHybridSessionControleeConfig extends FiraParams {
         buffer.order(ByteOrder.LITTLE_ENDIAN);
         for (FiraHybridSessionPhaseList phaseList : mPhaseList) {
             buffer.putInt(phaseList.getSessionHandle());
-            buffer.putInt(phaseList.getPhaseParticipation());
         }
 
         bundle.putIntArray(KEY_PHASE_LIST, byteArrayToIntArray(buffer.array()));
@@ -121,8 +120,7 @@ public class FiraHybridSessionControleeConfig extends FiraParams {
 
         for (int i = 0; i < numberOfPhases; i++) {
             FiraHybridSessionPhaseList mFiraHybridSessionPhaseList = new FiraHybridSessionPhaseList(
-                    buffer.getInt(),
-                    (byte) buffer.getInt());
+                    buffer.getInt());
             builder.addPhaseList(mFiraHybridSessionPhaseList);
         }
         return builder.build();
@@ -157,19 +155,13 @@ public class FiraHybridSessionControleeConfig extends FiraParams {
     /** Defines parameters for hybrid session's secondary phase list */
     public static class FiraHybridSessionPhaseList {
         private final int mSessionHandle;
-        private final byte mPhaseParticipation;
 
-        public FiraHybridSessionPhaseList(int sessionHandle, byte phaseParticipation) {
+        public FiraHybridSessionPhaseList(int sessionHandle) {
             mSessionHandle = sessionHandle;
-            mPhaseParticipation = phaseParticipation;
         }
 
         public int getSessionHandle() {
             return mSessionHandle;
         }
-
-        public byte getPhaseParticipation() {
-            return mPhaseParticipation;
-        }
     }
 }
diff --git a/service/support_lib/src/com/google/uwb/support/fira/FiraHybridSessionControllerConfig.java b/service/support_lib/src/com/google/uwb/support/fira/FiraHybridSessionControllerConfig.java
index 062b7817..b3dede35 100644
--- a/service/support_lib/src/com/google/uwb/support/fira/FiraHybridSessionControllerConfig.java
+++ b/service/support_lib/src/com/google/uwb/support/fira/FiraHybridSessionControllerConfig.java
@@ -38,8 +38,6 @@ public class FiraHybridSessionControllerConfig extends FiraParams {
     private static final int PHASE_LIST_SIZE = 20;
 
     private final int mNumberOfPhases;
-    private final byte[] mUpdateTime;
-    private final byte mMessageControl;
     private final List<FiraHybridSessionPhaseList> mPhaseList;
 
     public static final String KEY_BUNDLE_VERSION = "bundle_version";
@@ -57,23 +55,13 @@ public class FiraHybridSessionControllerConfig extends FiraParams {
         return mNumberOfPhases;
     }
 
-    public byte[] getUpdateTime() {
-        return mUpdateTime;
-    }
-
-    public byte getMessageControl() {
-        return mMessageControl;
-    }
-
     public List<FiraHybridSessionPhaseList> getPhaseList() {
         return mPhaseList;
     }
 
-    private FiraHybridSessionControllerConfig(int numberOfPhases, byte[] updateTime,
-            byte messageControl, List<FiraHybridSessionPhaseList> phaseList) {
+    private FiraHybridSessionControllerConfig(int numberOfPhases,
+            List<FiraHybridSessionPhaseList> phaseList) {
         mNumberOfPhases = numberOfPhases;
-        mUpdateTime = updateTime;
-        mMessageControl = messageControl;
         mPhaseList = phaseList;
     }
 
@@ -106,17 +94,15 @@ public class FiraHybridSessionControllerConfig extends FiraParams {
     public PersistableBundle toBundle() {
         PersistableBundle bundle = super.toBundle();
         bundle.putInt(KEY_BUNDLE_VERSION, getBundleVersion());
-        bundle.putInt(KEY_MESSAGE_CONTROL, mMessageControl);
         bundle.putInt(KEY_NUMBER_OF_PHASES, mNumberOfPhases);
-        bundle.putIntArray(KEY_UPDATE_TIME, byteArrayToIntArray(mUpdateTime));
 
         ByteBuffer buffer = ByteBuffer.allocate(mNumberOfPhases * PHASE_LIST_SIZE);
         buffer.order(ByteOrder.LITTLE_ENDIAN);
         for (FiraHybridSessionPhaseList phaseList : mPhaseList) {
-            buffer.putInt(phaseList.getSessionHandle());
+            buffer.putInt(phaseList.getSessionId());
             buffer.putShort(phaseList.getStartSlotIndex());
             buffer.putShort(phaseList.getEndSlotIndex());
-            buffer.putInt(phaseList.getPhaseParticipation());
+            buffer.putInt(phaseList.getMessageControl());
             buffer.putLong(uwbAddressToLong(phaseList.getMacAddress()));
         }
 
@@ -139,25 +125,28 @@ public class FiraHybridSessionControllerConfig extends FiraParams {
 
         int numberOfPhases = bundle.getInt(KEY_NUMBER_OF_PHASES);
         builder.setNumberOfPhases(numberOfPhases);
-        builder.setUpdateTime(intArrayToByteArray(bundle.getIntArray(KEY_UPDATE_TIME)));
-        int messageControl = bundle.getInt(KEY_MESSAGE_CONTROL);
-        byte macAddressMode = (byte) (messageControl & 0x01);
-        builder.setMacAddressMode(macAddressMode);
 
         byte[] phaseByteArray = intArrayToByteArray(bundle.getIntArray(KEY_PHASE_LIST));
         ByteBuffer buffer = ByteBuffer.wrap(phaseByteArray);
         buffer.order(ByteOrder.LITTLE_ENDIAN);
 
         for (int i = 0; i < numberOfPhases; i++) {
+            final int sessionId = buffer.getInt();
+            final short startSlotIndex = buffer.getShort();
+            final short endSlotIndex = buffer.getShort();
+            final byte messageControl = (byte) buffer.getInt();
+            final int addressLength =  ((messageControl & 0x01) == SHORT_MAC_ADDRESS)
+                    ? UwbAddress.SHORT_ADDRESS_BYTE_LENGTH
+                    : UwbAddress.EXTENDED_ADDRESS_BYTE_LENGTH;
+
             FiraHybridSessionPhaseList mFiraHybridSessionPhaseList = new FiraHybridSessionPhaseList(
-                    buffer.getInt(),
-                    buffer.getShort(),
-                    buffer.getShort(),
-                    (byte) buffer.getInt(),
-                    longToUwbAddress(buffer.getLong(),
-                        (macAddressMode == SHORT_MAC_ADDRESS
-                        ? UwbAddress.SHORT_ADDRESS_BYTE_LENGTH
-                                    : UwbAddress.EXTENDED_ADDRESS_BYTE_LENGTH)));
+                    sessionId,
+                    startSlotIndex,
+                    endSlotIndex,
+                    messageControl,
+                    longToUwbAddress(buffer.getLong(), addressLength)
+            );
+
             builder.addPhaseList(mFiraHybridSessionPhaseList);
         }
         return builder.build();
@@ -166,8 +155,6 @@ public class FiraHybridSessionControllerConfig extends FiraParams {
     /** Builder */
     public static class Builder {
         private int mNumberOfPhases;
-        private byte[] mUpdateTime;
-        private byte mMacAddressMode;
         private final List<FiraHybridSessionPhaseList> mPhaseList = new ArrayList<>();
 
         public FiraHybridSessionControllerConfig.Builder setNumberOfPhases(int numberOfPhases) {
@@ -175,16 +162,6 @@ public class FiraHybridSessionControllerConfig extends FiraParams {
             return this;
         }
 
-        public FiraHybridSessionControllerConfig.Builder setUpdateTime(byte[] updateTime) {
-            mUpdateTime = updateTime;
-            return this;
-        }
-
-        public FiraHybridSessionControllerConfig.Builder setMacAddressMode(byte macAddressMode) {
-            mMacAddressMode = macAddressMode;
-            return this;
-        }
-
         public FiraHybridSessionControllerConfig.Builder addPhaseList(
                 FiraHybridSessionPhaseList phaseList) {
             mPhaseList.add(phaseList);
@@ -197,38 +174,36 @@ public class FiraHybridSessionControllerConfig extends FiraParams {
             }
             return new FiraHybridSessionControllerConfig(
                     mNumberOfPhases,
-                    mUpdateTime,
-                    (byte) (mMacAddressMode & 0x01),
                     mPhaseList);
         }
     }
 
     /** Defines parameters for hybrid session's secondary phase list */
     public static class FiraHybridSessionPhaseList {
-        private final int mSessionHandle;
+        private final int mSessionId;
 
         @IntRange(from = 1, to = 32767)
         private final short mStartSlotIndex;
 
         @IntRange(from = 1, to = 32767)
         private final short mEndSlotIndex;
-        private final byte mPhaseParticipation;
+        private final byte mMessageControl;
         private final UwbAddress mMacAddress;
 
-        public FiraHybridSessionPhaseList(int sessionHandle,
+        public FiraHybridSessionPhaseList(int sessionId,
                 @IntRange(from = 1, to = 32767) short startSlotIndex,
                 @IntRange(from = 1, to = 32767) short endSlotIndex,
-                @PhaseParticipationHybridSessionController byte phaseParticipation,
+                byte messageControl,
                 UwbAddress macAddress) {
-            mSessionHandle = sessionHandle;
+            mSessionId = sessionId;
             mStartSlotIndex = startSlotIndex;
             mEndSlotIndex = endSlotIndex;
-            mPhaseParticipation = phaseParticipation;
+            mMessageControl = messageControl;
             mMacAddress = macAddress;
         }
 
-        public int getSessionHandle() {
-            return mSessionHandle;
+        public int getSessionId() {
+            return mSessionId;
         }
 
         @IntRange(from = 1, to = 32767)
@@ -241,9 +216,8 @@ public class FiraHybridSessionControllerConfig extends FiraParams {
             return mEndSlotIndex;
         }
 
-        @PhaseParticipationHybridSessionController
-        public byte getPhaseParticipation() {
-            return mPhaseParticipation;
+        public byte getMessageControl() {
+            return mMessageControl;
         }
 
         public UwbAddress getMacAddress() {
diff --git a/service/support_lib/src/com/google/uwb/support/fira/FiraOpenSessionParams.java b/service/support_lib/src/com/google/uwb/support/fira/FiraOpenSessionParams.java
index 0f34ac9f..eed9953c 100644
--- a/service/support_lib/src/com/google/uwb/support/fira/FiraOpenSessionParams.java
+++ b/service/support_lib/src/com/google/uwb/support/fira/FiraOpenSessionParams.java
@@ -21,6 +21,7 @@ import static com.google.common.base.Preconditions.checkNotNull;
 
 import static java.util.Objects.requireNonNull;
 
+import android.annotation.SuppressLint;
 import android.os.PersistableBundle;
 import android.uwb.UwbAddress;
 import android.uwb.UwbManager;
@@ -36,6 +37,7 @@ import com.google.uwb.support.base.RequiredParam;
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
@@ -1681,6 +1683,31 @@ public class FiraOpenSessionParams extends FiraParams {
             return this;
         }
 
+        /**
+         * Sets the session priority for the UWB session.
+         *
+         * <p>Once assigned, the priority remains fixed for the session's duration, as UWBS does not
+         * support dynamic updates. Priority updates take effect only when the session is restarted.
+         * </p>
+         *
+         * <p>If the configured priority {@link #setSessionPriority(int)} is same as the UCI default
+         * value {@link FiraOpenSessionParams.Builder#mSessionPriority}, the system uses the
+         * precomputed stack priority.</p>
+         *
+         * Possible values are defined in UwbSessionManager.UwbSession:
+         *  <ul>
+         *    <li>CCC_SESSION_PRIORITY - Highest priority</li>
+         *    <li>ALIRO_SESSION_PRIORITY - Aliro sessions</li>
+         *    <li>SYSTEM_APP_SESSION_PRIORITY - System apps/services</li>
+         *    <li>FG_SESSION_PRIORITY - Foreground apps/services</li>
+         *    <li>BG_SESSION_PRIORITY - Lowest priority</li>
+         *  </ul>
+         *
+         * <p>Otherwise, it overrides the default stack-calculated priority.</p>
+         *
+         * @param sessionPriority The priority level to assign.
+         *
+         */
         public FiraOpenSessionParams.Builder setSessionPriority(int sessionPriority) {
             mSessionPriority = sessionPriority;
             return this;
@@ -2099,6 +2126,7 @@ public class FiraOpenSessionParams extends FiraParams {
             return this;
         }
 
+        @SuppressLint("NewApi") // UwbManager#toBytes is supported from API 31.
         private void checkAddress() {
             checkArgument(
                     mMacAddressMode == MAC_ADDRESS_MODE_2_BYTES
@@ -2118,6 +2146,25 @@ public class FiraOpenSessionParams extends FiraParams {
                             && destAddress.size() == addressByteLength);
                 }
             }
+
+            if (mMacAddressMode == MAC_ADDRESS_MODE_8_BYTES) {
+                checkArgument(!Arrays.equals(mDeviceAddress.toBytes(),
+                        getExtendedForbiddenAddress()));
+                if (isTimeScheduledTwrSession()) {
+                    for (UwbAddress destAddress : mDestAddressList) {
+                        checkArgument(!Arrays.equals(destAddress.toBytes(),
+                                getExtendedForbiddenAddress()));
+                    }
+                }
+            } else {
+                checkArgument(!Arrays.equals(mDeviceAddress.toBytes(), getShortForbiddenAddress()));
+                if (isTimeScheduledTwrSession()) {
+                    for (UwbAddress destAddress : mDestAddressList) {
+                        checkArgument(!Arrays.equals(destAddress.toBytes(),
+                                getShortForbiddenAddress()));
+                    }
+                }
+            }
         }
 
         private void checkStsConfig() {
diff --git a/service/support_lib/src/com/google/uwb/support/fira/FiraParams.java b/service/support_lib/src/com/google/uwb/support/fira/FiraParams.java
index 124e6d4d..f1cafba3 100644
--- a/service/support_lib/src/com/google/uwb/support/fira/FiraParams.java
+++ b/service/support_lib/src/com/google/uwb/support/fira/FiraParams.java
@@ -185,6 +185,7 @@ public abstract class FiraParams extends Params {
                 RANGING_ROUND_USAGE_OWR_AOA_MEASUREMENT,
                 RANGING_ROUND_USAGE_DL_TDOA,
                 RANGING_ROUND_USAGE_DATA_TRANSFER_MODE,
+                RANGING_ROUND_USAGE_HYBRID_RANGING_MODE,
             })
     public @interface RangingRoundUsage {}
 
@@ -212,6 +213,9 @@ public abstract class FiraParams extends Params {
     /** Data transfer mode */
     public static final int RANGING_ROUND_USAGE_DATA_TRANSFER_MODE = 9;
 
+    /** Hybrid ranging mode */
+    public static final int RANGING_ROUND_USAGE_HYBRID_RANGING_MODE = 0x0A;
+
     /** Multi-Node mode */
     @IntDef(
             value = {
@@ -1116,6 +1120,7 @@ public abstract class FiraParams extends Params {
                     SESSION_TYPE_RANGING_ONLY_PHASE,
                     SESSION_TYPE_IN_BAND_DATA_PHASE,
                     SESSION_TYPE_RANGING_WITH_DATA_PHASE,
+                    SESSION_TYPE_HUS_PRIMARY_SESSION,
                     SESSION_TYPE_DEVICE_TEST_MODE,
             })
     public @interface SessionType{}
@@ -1126,6 +1131,7 @@ public abstract class FiraParams extends Params {
     public static final int SESSION_TYPE_RANGING_ONLY_PHASE = 3;
     public static final int SESSION_TYPE_IN_BAND_DATA_PHASE = 4;
     public static final int SESSION_TYPE_RANGING_WITH_DATA_PHASE = 5;
+    public static final int SESSION_TYPE_HUS_PRIMARY_SESSION = 0x9F;
     public static final int SESSION_TYPE_DEVICE_TEST_MODE = 0xD0;
 
     /** Which type of filter to use for filtering AoA/distance readings. */
@@ -1169,6 +1175,26 @@ public abstract class FiraParams extends Params {
     /** The patch antenna is used for both Tx and Rx. **/
     public static final int ANTENNA_MODE_DIRECTIONAL = 1;
 
+    private static final byte[] sShortForbiddenUwbAddress = {(byte) 0xFF, (byte) 0xFF};
+    private static final byte[] sExtendedForbiddenUwbAddress = {
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF,
+            (byte) 0xFF
+    };
+
+    public static byte[] getShortForbiddenAddress() {
+        return sShortForbiddenUwbAddress;
+    }
+
+    public static byte[] getExtendedForbiddenAddress() {
+        return sExtendedForbiddenUwbAddress;
+    }
+
     /** Helper function to covert long value to UwbAddress. */
     public static UwbAddress longToUwbAddress(long value, int length) {
         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
diff --git a/service/support_lib/src/com/google/uwb/support/fira/FiraSpecificationParams.java b/service/support_lib/src/com/google/uwb/support/fira/FiraSpecificationParams.java
index 77afedcd..0b398633 100644
--- a/service/support_lib/src/com/google/uwb/support/fira/FiraSpecificationParams.java
+++ b/service/support_lib/src/com/google/uwb/support/fira/FiraSpecificationParams.java
@@ -113,6 +113,8 @@ public class FiraSpecificationParams extends FiraParams {
 
     private final boolean mHasPsduLengthSupport;
 
+    private final String mCountryCode;
+
     private final int mUciVersion;
 
     private static final String KEY_MIN_PHY_VERSION = "min_phy_version";
@@ -167,6 +169,8 @@ public class FiraSpecificationParams extends FiraParams {
 
     public static final String KEY_PSDU_LENGTH_SUPPORT = "psdu_length_support";
 
+    public static final String KEY_COUNTRY_CODE = "country_code";
+
     public static final String KEY_UCI_VERSION = "uci_version";
 
     public static final int DEFAULT_MAX_RANGING_SESSIONS_NUMBER = 5;
@@ -206,6 +210,7 @@ public class FiraSpecificationParams extends FiraParams {
             int deviceType, boolean suspendRangingSupport, int sessionKeyLength,
             int dtTagMaxActiveRr, boolean hasBackgroundRangingSupport,
             boolean hasDtTagBlockSkippingSupport, boolean hasPsduLengthSupport,
+            String countryCode,
             int uciVersion) {
         mMinPhyVersionSupported = minPhyVersionSupported;
         mMaxPhyVersionSupported = maxPhyVersionSupported;
@@ -245,6 +250,7 @@ public class FiraSpecificationParams extends FiraParams {
         mHasBackgroundRangingSupport = hasBackgroundRangingSupport;
         mHasDtTagBlockSkippingSupport = hasDtTagBlockSkippingSupport;
         mHasPsduLengthSupport = hasPsduLengthSupport;
+        mCountryCode = countryCode;
         mUciVersion = uciVersion;
     }
 
@@ -407,6 +413,10 @@ public class FiraSpecificationParams extends FiraParams {
         return mHasPsduLengthSupport;
     }
 
+    public String getCountryCode() {
+        return mCountryCode;
+    }
+
     public int getUciVersionSupported() {
         return mUciVersion;
     }
@@ -466,6 +476,7 @@ public class FiraSpecificationParams extends FiraParams {
         bundle.putBoolean(KEY_BACKGROUND_RANGING_SUPPORT, mHasBackgroundRangingSupport);
         bundle.putBoolean(KEY_DT_TAG_BLOCK_SKIPPING_SUPPORT, mHasDtTagBlockSkippingSupport);
         bundle.putBoolean(KEY_PSDU_LENGTH_SUPPORT, mHasPsduLengthSupport);
+        bundle.putString(KEY_COUNTRY_CODE, mCountryCode);
         bundle.putInt(KEY_UCI_VERSION, mUciVersion);
         return bundle;
     }
@@ -503,6 +514,7 @@ public class FiraSpecificationParams extends FiraParams {
         builder.setDtTagBlockSkippingSupport(bundle.getBoolean(KEY_DT_TAG_BLOCK_SKIPPING_SUPPORT));
         builder.setPsduLengthSupport(bundle.getBoolean(KEY_PSDU_LENGTH_SUPPORT));
         builder.setUciVersionSupported(bundle.getInt(KEY_UCI_VERSION, 1));
+        builder.setCountryCode(bundle.getString(KEY_COUNTRY_CODE));
         return builder;
     }
 
@@ -640,6 +652,8 @@ public class FiraSpecificationParams extends FiraParams {
 
         private int mMaxRangingSessionNumber = DEFAULT_MAX_RANGING_SESSIONS_NUMBER;
 
+        private String mCountryCode = null;
+
         private int mUciVersion = 1;
 
         // Unicast support is mandatory
@@ -940,6 +954,11 @@ public class FiraSpecificationParams extends FiraParams {
             return this;
         }
 
+        public FiraSpecificationParams.Builder setCountryCode(String value) {
+            mCountryCode = value;
+            return this;
+        }
+
         public FiraSpecificationParams.Builder setUciVersionSupported(
                 int uciVersion) {
             mUciVersion = uciVersion;
@@ -987,6 +1006,7 @@ public class FiraSpecificationParams extends FiraParams {
             mHasBackgroundRangingSupport = params.mHasBackgroundRangingSupport;
             mHasDtTagBlockSkippingSupport = params.mHasDtTagBlockSkippingSupport;
             mHasPsduLengthSupport = params.mHasPsduLengthSupport;
+            mCountryCode = params.mCountryCode;
         }
 
         public FiraSpecificationParams build() {
@@ -1029,6 +1049,7 @@ public class FiraSpecificationParams extends FiraParams {
                     mHasBackgroundRangingSupport,
                     mHasDtTagBlockSkippingSupport,
                     mHasPsduLengthSupport,
+                    mCountryCode,
                     mUciVersion);
         }
     }
diff --git a/service/support_lib/src/com/google/uwb/support/rftest/RfTestPerRxResult.java b/service/support_lib/src/com/google/uwb/support/rftest/RfTestPerRxResult.java
new file mode 100644
index 00000000..4a5738fb
--- /dev/null
+++ b/service/support_lib/src/com/google/uwb/support/rftest/RfTestPerRxResult.java
@@ -0,0 +1,320 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.uwb.support.rftest;
+
+import android.os.PersistableBundle;
+
+import com.google.uwb.support.base.RequiredParam;
+
+public final class RfTestPerRxResult extends RfTestParams {
+    private static final int BUNDLE_VERSION_1 = 1;
+    private static final int BUNDLE_VERSION_CURRENT = BUNDLE_VERSION_1;
+    private static final String KEY_STATUS_CODE = "status_code";
+    private static final String KEY_ATTEMPTS = "attempts";
+    private static final String KEY_ACQ_DETECT = "acq_detect";
+    private static final String KEY_ACQ_REJECT = "acq_reject";
+    private static final String KEY_RX_FAIL = "rx_fail";
+    private static final String KEY_SYNC_CIR_READY = "sync_cir_ready";
+    private static final String KEY_SFD_FAIL = "sfd_fail";
+    private static final String KEY_SFD_FOUND = "sfd_found";
+    private static final String KEY_PHR_DEC_ERROR = "phr_dec_error";
+    private static final String KEY_PHR_BIT_ERROR = "phr_bit_error";
+    private static final String KEY_PSDU_DEC_ERROR = "psdu_dec_error";
+    private static final String KEY_PSDU_BIT_ERROR = "psdu_bit_error";
+    private static final String KEY_STS_FOUND = "sts_found";
+    private static final String KEY_EOF = "eof";
+    public static final String RAW_NTF_DATA = "raw_ntf_data";
+    private static final String KEY_RF_OPERATION_TYPE = "rf_operation_type";
+    private final int mRfTestOperationType;
+    private final int mStatus;
+    private final long mAttempts;
+    private final long mAcqDetect;
+    private final long mAcqReject;
+    private final long mRxFail;
+    private final long mSyncCirReady;
+    private final long mSfdFail;
+    private final long mSfdFound;
+    private final long mPhrDecError;
+    private final long mPhrBitError;
+    private final long mPsduDecError;
+    private final long mPsduBitError;
+    private final long mStsFound;
+    private final long mEof;
+    private final byte[] mRawNtfData;
+
+    private RfTestPerRxResult(int status, long attempts, long acqDetect, long acqReject,
+                              long rxFail,  long syncCirReady, long sfdFail, long sfdFound,
+                              long phrDecError, long phrBitError,
+                              long psduDecError, long psduBitError, long stsFound, long eof,
+                              byte[] rawNtfData, int rfTestOperationType) {
+        this.mStatus = status;
+        this.mAttempts = attempts;
+        this.mAcqDetect = acqDetect;
+        this.mAcqReject = acqReject;
+        this.mRxFail = rxFail;
+        this.mSyncCirReady = syncCirReady;
+        this.mSfdFail = sfdFail;
+        this.mSfdFound = sfdFound;
+        this.mPhrDecError = phrDecError;
+        this.mPhrBitError = phrBitError;
+        this.mPsduDecError = psduDecError;
+        this.mPsduBitError = psduBitError;
+        this.mStsFound = stsFound;
+        this.mEof = eof;
+        this.mRawNtfData = rawNtfData;
+        this.mRfTestOperationType = rfTestOperationType;
+    }
+
+    @Override
+    protected int getBundleVersion() {
+        return BUNDLE_VERSION_CURRENT;
+    }
+
+    @Override
+    public PersistableBundle toBundle() {
+        PersistableBundle bundle = super.toBundle();
+        bundle.putInt(KEY_STATUS_CODE, mStatus);
+        bundle.putLong(KEY_ATTEMPTS, mAttempts);
+        bundle.putLong(KEY_ACQ_DETECT, mAcqDetect);
+        bundle.putLong(KEY_ACQ_REJECT, mAcqReject);
+        bundle.putLong(KEY_RX_FAIL, mRxFail);
+        bundle.putLong(KEY_SYNC_CIR_READY, mSyncCirReady);
+        bundle.putLong(KEY_SFD_FAIL, mSfdFail);
+        bundle.putLong(KEY_SFD_FOUND, mSfdFound);
+        bundle.putLong(KEY_PHR_DEC_ERROR, mPhrDecError);
+        bundle.putLong(KEY_PHR_BIT_ERROR, mPhrBitError);
+        bundle.putLong(KEY_PSDU_DEC_ERROR, mPsduDecError);
+        bundle.putLong(KEY_PSDU_BIT_ERROR, mPsduBitError);
+        bundle.putLong(KEY_STS_FOUND, mStsFound);
+        bundle.putLong(KEY_EOF, mEof);
+        bundle.putIntArray(RAW_NTF_DATA, byteArrayToIntArray(mRawNtfData));
+        bundle.putInt(KEY_RF_OPERATION_TYPE, mRfTestOperationType);
+        return bundle;
+    }
+
+    /** Unpack the {@link PersistableBundle} to a {@link RfTestPerRxResult} */
+    public static RfTestPerRxResult fromBundle(PersistableBundle bundle) {
+        if (!isCorrectProtocol(bundle)) {
+            throw new IllegalArgumentException("Invalid protocol");
+        }
+
+        switch (getBundleVersion(bundle)) {
+            case BUNDLE_VERSION_1:
+                return parseBundleVersion1(bundle);
+
+            default:
+                throw new IllegalArgumentException("unknown bundle version");
+        }
+    }
+
+    private static RfTestPerRxResult parseBundleVersion1(PersistableBundle bundle) {
+        RfTestPerRxResult.Builder builder = new RfTestPerRxResult.Builder()
+                .setStatus(bundle.getInt(KEY_STATUS_CODE))
+                .setAttempts(bundle.getLong(KEY_ATTEMPTS))
+                .setAcqDetect(bundle.getLong(KEY_ACQ_DETECT))
+                .setAcqReject(bundle.getLong(KEY_ACQ_REJECT))
+                .setRxFail(bundle.getLong(KEY_RX_FAIL))
+                .setSyncCirReady(bundle.getLong(KEY_SYNC_CIR_READY))
+                .setSfdFail(bundle.getLong(KEY_SFD_FAIL))
+                .setSfdFound(bundle.getLong(KEY_SFD_FOUND))
+                .setPhrDecError(bundle.getLong(KEY_PHR_DEC_ERROR))
+                .setPhrBitError(bundle.getLong(KEY_PHR_BIT_ERROR))
+                .setPsduDecError(bundle.getLong(KEY_PSDU_DEC_ERROR))
+                .setPsduBitError(bundle.getLong(KEY_PSDU_BIT_ERROR))
+                .setStsFound(bundle.getLong(KEY_STS_FOUND))
+                .setEof(bundle.getLong(KEY_EOF))
+                .setRawNtfData(intArrayToByteArray(bundle.getIntArray(RAW_NTF_DATA)))
+                .setOperationType(bundle.getInt(KEY_RF_OPERATION_TYPE));
+        return builder.build();
+    }
+
+    public int getStatus() {
+        return mStatus;
+    }
+
+    public long getAttempts() {
+        return mAttempts;
+    }
+
+    public long getAcqDetect() {
+        return mAcqDetect;
+    }
+
+    public long getAcqReject() {
+        return mAcqReject;
+    }
+
+    public long getRxFail() {
+        return mRxFail;
+    }
+
+    public long getSyncCirReady() {
+        return mSyncCirReady;
+    }
+
+    public long getSfdFail() {
+        return mSfdFail;
+    }
+
+    public long getSfdFound() {
+        return mSfdFound;
+    }
+
+    public long getPhrDecError() {
+        return mPhrDecError;
+    }
+
+    public long getPhrBitError() {
+        return mPhrBitError;
+    }
+
+    public long getPsduDecError() {
+        return mPsduDecError;
+    }
+
+    public long getPsduBitError() {
+        return mPsduBitError;
+    }
+
+    public long getStsFound() {
+        return mStsFound;
+    }
+
+    public long getEof() {
+        return mEof;
+    }
+
+    public byte[] getRawNtfData() {
+        return mRawNtfData;
+    }
+
+    @RfTestOperationType
+    public int getRfTestOperationType() {
+        return mRfTestOperationType;
+    }
+
+    /**
+     * Builder for a {@link RfTestPerRxResult} object.
+     */
+    public static final class Builder {
+        private RequiredParam<Integer> mRfTestOperationType = new RequiredParam<Integer>();
+        private int mStatus;
+        private long mAttempts;
+        private long mAcqDetect;
+        private long mAcqReject;
+        private long mRxFail;
+        private long mSyncCirReady;
+        private long mSfdFail;
+        private long mSfdFound;
+        private long mPhrDecError;
+        private long mPhrBitError;
+        private long mPsduDecError;
+        private long mPsduBitError;
+        private long mStsFound;
+        private long mEof;
+        private byte[] mRawNtfData;
+
+        public Builder setStatus(int status) {
+            mStatus = status;
+            return this;
+        }
+
+        public Builder setAttempts(long attempts) {
+            mAttempts = attempts;
+            return this;
+        }
+
+        public Builder setAcqDetect(long acqDetect) {
+            mAcqDetect = acqDetect;
+            return this;
+        }
+
+        public Builder setAcqReject(long acqReject) {
+            mAcqReject = acqReject;
+            return this;
+        }
+
+        public Builder setRxFail(long rxFail) {
+            mRxFail = rxFail;
+            return this;
+        }
+
+        public Builder setSyncCirReady(long syncCirReady) {
+            mSyncCirReady = syncCirReady;
+            return this;
+        }
+
+        public Builder setSfdFail(long sfdFail) {
+            mSfdFail = sfdFail;
+            return this;
+        }
+
+        public Builder setSfdFound(long sfdFound) {
+            mSfdFound = sfdFound;
+            return this;
+        }
+
+        public Builder setPhrDecError(long phrDecError) {
+            mPhrDecError = phrDecError;
+            return this;
+        }
+
+        public Builder setPhrBitError(long phrBitError) {
+            mPhrBitError = phrBitError;
+            return this;
+        }
+
+        public Builder setPsduDecError(long psduDecError) {
+            mPsduDecError = psduDecError;
+            return this;
+        }
+
+        public Builder setPsduBitError(long psduBitError) {
+            mPsduBitError = psduBitError;
+            return this;
+        }
+
+        public Builder setStsFound(long stsFound) {
+            mStsFound = stsFound;
+            return this;
+        }
+
+        public Builder setEof(long eof) {
+            mEof = eof;
+            return this;
+        }
+
+        public Builder setRawNtfData(byte[] rawNtfData) {
+            mRawNtfData = rawNtfData;
+            return this;
+        }
+
+        public Builder setOperationType(@RfTestOperationType int rfTestOperationType) {
+            mRfTestOperationType.set(rfTestOperationType);
+            return this;
+        }
+
+        /**
+         * Build the {@link RfTestPerRxResult} object
+         */
+        public RfTestPerRxResult build() {
+            return new RfTestPerRxResult(mStatus, mAttempts, mAcqDetect, mAcqReject,
+                    mRxFail, mSyncCirReady, mSfdFail, mSfdFound, mPhrDecError, mPhrBitError,
+                    mPsduDecError, mPsduBitError, mStsFound, mEof, mRawNtfData, mRfTestOperationType.get());
+        }
+    }
+}
diff --git a/service/support_lib/src/com/google/uwb/support/rftest/RfTestPeriodicTxResult.java b/service/support_lib/src/com/google/uwb/support/rftest/RfTestPeriodicTxResult.java
index 02c0e85f..208f93d2 100644
--- a/service/support_lib/src/com/google/uwb/support/rftest/RfTestPeriodicTxResult.java
+++ b/service/support_lib/src/com/google/uwb/support/rftest/RfTestPeriodicTxResult.java
@@ -24,12 +24,15 @@ public final class RfTestPeriodicTxResult  extends RfTestParams {
     private static final int BUNDLE_VERSION_1 = 1;
     private static final int BUNDLE_VERSION_CURRENT = BUNDLE_VERSION_1;
     private static final String KEY_STATUS_CODE = "status_code";
+    public static final String RAW_NTF_DATA = "raw_ntf_data";
     private static final String KEY_RF_OPERATION_TYPE = "rf_operation_type";
     private final int mRfTestOperationType;
     private final int mStatus;
+    private final byte[] mRawNtfData;
 
-    private RfTestPeriodicTxResult(int status, int rfTestOperationType) {
+    private RfTestPeriodicTxResult(int status, byte[] rawNtfData, int rfTestOperationType) {
         this.mStatus = status;
+        this.mRawNtfData = rawNtfData;
         this.mRfTestOperationType = rfTestOperationType;
     }
 
@@ -42,6 +45,7 @@ public final class RfTestPeriodicTxResult  extends RfTestParams {
     public PersistableBundle toBundle() {
         PersistableBundle bundle = super.toBundle();
         bundle.putInt(KEY_STATUS_CODE, mStatus);
+        bundle.putIntArray(RAW_NTF_DATA, byteArrayToIntArray(mRawNtfData));
         bundle.putInt(KEY_RF_OPERATION_TYPE, mRfTestOperationType);
         return bundle;
     }
@@ -64,6 +68,7 @@ public final class RfTestPeriodicTxResult  extends RfTestParams {
     private static RfTestPeriodicTxResult parseBundleVersion1(PersistableBundle bundle) {
         RfTestPeriodicTxResult.Builder builder = new RfTestPeriodicTxResult.Builder()
                 .setStatus(bundle.getInt(KEY_STATUS_CODE))
+                .setRawNtfData(intArrayToByteArray(bundle.getIntArray(RAW_NTF_DATA)))
                 .setOperationType(bundle.getInt(KEY_RF_OPERATION_TYPE));
         return builder.build();
     }
@@ -94,12 +99,18 @@ public final class RfTestPeriodicTxResult  extends RfTestParams {
     public static final class Builder {
         private RequiredParam<Integer> mRfTestOperationType = new RequiredParam<Integer>();
         private int mStatus;
+        private byte[] mRawNtfData;
 
         public Builder setStatus(int status) {
             mStatus = status;
             return this;
         }
 
+        public Builder setRawNtfData(byte[] rawNtfData) {
+            mRawNtfData = rawNtfData;
+            return this;
+        }
+
         public Builder setOperationType(int rfTestOperationType) {
             mRfTestOperationType.set(rfTestOperationType);
             return this;
@@ -109,7 +120,7 @@ public final class RfTestPeriodicTxResult  extends RfTestParams {
          * Build the {@link RfTestPeriodicTxResult} object
          */
         public RfTestPeriodicTxResult build() {
-            return new RfTestPeriodicTxResult(mStatus, mRfTestOperationType.get());
+            return new RfTestPeriodicTxResult(mStatus, mRawNtfData, mRfTestOperationType.get());
         }
     }
 }
diff --git a/service/support_lib/test/AliroTests.java b/service/support_lib/test/AliroTests.java
index 9a7f9368..07210d3e 100644
--- a/service/support_lib/test/AliroTests.java
+++ b/service/support_lib/test/AliroTests.java
@@ -25,7 +25,6 @@ import android.os.PersistableBundle;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.filters.SmallTest;
 
-import com.google.uwb.support.base.Params;
 import com.google.uwb.support.aliro.AliroOpenRangingParams;
 import com.google.uwb.support.aliro.AliroParams;
 import com.google.uwb.support.aliro.AliroProtocolVersion;
@@ -35,6 +34,7 @@ import com.google.uwb.support.aliro.AliroRangingReconfiguredParams;
 import com.google.uwb.support.aliro.AliroRangingStartedParams;
 import com.google.uwb.support.aliro.AliroSpecificationParams;
 import com.google.uwb.support.aliro.AliroStartRangingParams;
+import com.google.uwb.support.base.Params;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -78,6 +78,8 @@ public class AliroTests {
             };
     private static final Integer[] HOPPING_SEQUENCES =
             new Integer[] {AliroParams.HOPPING_SEQUENCE_AES, AliroParams.HOPPING_SEQUENCE_DEFAULT};
+    private static final  Integer[] MAC_MODES =
+            new Integer[] {AliroParams.MAC_MODE_ROUND_1, AliroParams.MAC_MODE_ROUND_2};
 
     @Test
     public void testOpenRangingParams() {
@@ -105,6 +107,10 @@ public class AliroTests {
         double rangeDataNtfAoaAzimuthUpper = +1.3;
         double rangeDataNtfAoaElevationLower = -1.1;
         double rangeDataNtfAoaElevationUpper = +1.2;
+        @AliroParams.MacModeRound int macModeRound = AliroParams.MAC_MODE_ROUND_1;
+        int macModeOffset = 0;
+        byte[] sessionKey = new byte[] {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
+                0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
 
         AliroOpenRangingParams params =
                 new AliroOpenRangingParams.Builder()
@@ -128,6 +134,9 @@ public class AliroTests {
                         .setRangeDataNtfAoaAzimuthUpper(rangeDataNtfAoaAzimuthUpper)
                         .setRangeDataNtfAoaElevationLower(rangeDataNtfAoaElevationLower)
                         .setRangeDataNtfAoaElevationUpper(rangeDataNtfAoaElevationUpper)
+                        .setSessionKey(sessionKey)
+                        .setMacModeRound(macModeRound)
+                        .setMacModeOffset(macModeOffset)
                         .build();
 
         assertEquals(params.getProtocolVersion(), protocolVersion);
@@ -147,6 +156,9 @@ public class AliroTests {
         assertEquals(params.getHoppingConfigMode(), hoppingConfigMode);
         assertEquals(params.getHoppingSequence(), hoppingSequence);
         assertEquals(params.getAbsoluteInitiationTimeUs(), absoluteInitiationTimeUs);
+        assertEquals(params.getMacModeRound(), macModeRound);
+        assertEquals(params.getMacModeOffset(), macModeOffset);
+        assertArrayEquals(params.getSessionKey(), sessionKey);
 
         AliroOpenRangingParams fromBundle = AliroOpenRangingParams.fromBundle(params.toBundle());
         assertEquals(fromBundle.getProtocolVersion(), protocolVersion);
@@ -176,9 +188,11 @@ public class AliroTests {
                 fromBundle.getRangeDataNtfAoaElevationLower(), rangeDataNtfAoaElevationLower, 0.1d);
         assertEquals(
                 fromBundle.getRangeDataNtfAoaElevationUpper(), rangeDataNtfAoaElevationUpper, 0.1d);
+        assertEquals(fromBundle.getMacModeRound(), macModeRound);
+        assertEquals(fromBundle.getMacModeOffset(), macModeOffset);
+        assertArrayEquals(fromBundle.getSessionKey(), sessionKey);
 
         verifyProtocolPresent(params);
-        verifyBundlesEqual(params, fromBundle);
     }
 
     @Test
@@ -310,6 +324,9 @@ public class AliroTests {
         for (int hoppingSequence : HOPPING_SEQUENCES) {
             paramsBuilder.addHoppingSequence(hoppingSequence);
         }
+        for (int macMode : MAC_MODES) {
+            paramsBuilder.addMacMode(macMode);
+        }
 
         AliroSpecificationParams params = paramsBuilder.build();
         assertArrayEquals(params.getProtocolVersions().toArray(), PROTOCOL_VERSIONS);
@@ -321,6 +338,7 @@ public class AliroTests {
         assertArrayEquals(params.getChannels().toArray(), CHANNELS);
         assertArrayEquals(params.getHoppingConfigModes().toArray(), HOPPING_CONFIG_MODES);
         assertArrayEquals(params.getHoppingSequences().toArray(), HOPPING_SEQUENCES);
+        assertArrayEquals(params.getMacModes().toArray(), MAC_MODES);
 
         AliroSpecificationParams fromBundle =
                 AliroSpecificationParams.fromBundle(params.toBundle());
@@ -333,6 +351,7 @@ public class AliroTests {
         assertArrayEquals(fromBundle.getChannels().toArray(), CHANNELS);
         assertArrayEquals(fromBundle.getHoppingConfigModes().toArray(), HOPPING_CONFIG_MODES);
         assertArrayEquals(fromBundle.getHoppingSequences().toArray(), HOPPING_SEQUENCES);
+        assertArrayEquals(fromBundle.getMacModes().toArray(), MAC_MODES);
 
         verifyProtocolPresent(params);
         assertTrue(params.equals(fromBundle));
@@ -370,6 +389,9 @@ public class AliroTests {
         for (int hoppingSequence : HOPPING_SEQUENCES) {
             paramsBuilder.addHoppingSequence(hoppingSequence);
         }
+        for (int macMode : MAC_MODES) {
+            paramsBuilder.addMacMode(macMode);
+        }
         AliroSpecificationParams params = paramsBuilder.build();
         assertEquals(List.of(), params.getChannels());
 
diff --git a/service/tests/src/com/android/server/uwb/UwbMetricsTest.java b/service/tests/src/com/android/server/uwb/UwbMetricsTest.java
index 14356ffd..44fd6be3 100644
--- a/service/tests/src/com/android/server/uwb/UwbMetricsTest.java
+++ b/service/tests/src/com/android/server/uwb/UwbMetricsTest.java
@@ -232,6 +232,9 @@ public class UwbMetricsTest {
 
     @Test
     public void testLogRangingSessionAllEvents() throws Exception {
+        when(mUwbSession.getProfileType())
+                .thenReturn(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA);
+
         mUwbMetrics.logRangingInitEvent(mUwbSession, UwbUciConstants.STATUS_CODE_OK);
         ExtendedMockito.verify(() -> UwbStatsLog.write(
                 UwbStatsLog.UWB_SESSION_INITED,
@@ -250,12 +253,10 @@ public class UwbMetricsTest {
 
         for (int i = 0; i < VALID_RANGING_COUNT; i++) {
             addElapsedTimeMs(DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS);
-            mUwbMetrics.logRangingResult(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
-                    mRangingData, mFilteredRangingMeasurement);
+            mUwbMetrics.logRangingResult(mUwbSession, mRangingData, mFilteredRangingMeasurement);
         }
         when(mTwoWayMeasurement.isStatusCodeOk()).thenReturn(!IS_STATUS_CODE_OK_DEFAULT);
-        mUwbMetrics.logRangingResult(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
-                mRangingData, mFilteredRangingMeasurement);
+        mUwbMetrics.logRangingResult(mUwbSession, mRangingData, mFilteredRangingMeasurement);
 
         for (int i = 0; i < RX_PACKET_COUNT; i++) {
             mUwbMetrics.logDataRx(mUwbSession, UwbUciConstants.STATUS_CODE_OK);
@@ -276,17 +277,18 @@ public class UwbMetricsTest {
         ExtendedMockito.verify(() -> UwbStatsLog.write(UwbStatsLog.UWB_RANGING_START,
                 UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
                 UwbStatsLog.UWB_SESSION_INITIATED__STS__STATIC, true, true, false, true,
-                UwbStatsLog.UWB_START_RANGING__STATUS__TX_FAILED));
+                UwbStatsLog.UWB_START_RANGING__STATUS__TX_FAILED, UID));
 
         ExtendedMockito.verify(() -> UwbStatsLog.write(UwbStatsLog.UWB_RANGING_START,
                 UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
                 UwbStatsLog.UWB_SESSION_INITIATED__STS__STATIC, true, true, false, true,
-                UwbStatsLog.UWB_START_RANGING__STATUS__RANGING_SUCCESS));
+                UwbStatsLog.UWB_START_RANGING__STATUS__RANGING_SUCCESS, UID));
 
         ExtendedMockito.verify(() -> UwbStatsLog.write(UwbStatsLog.UWB_FIRST_RANGING_RECEIVED,
                 UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
                 DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS * 2,
-                DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS * 2 / 200));
+                DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS * 2 / 200,
+                UID));
 
         ExtendedMockito.verify(() -> UwbStatsLog.write(UwbStatsLog.UWB_SESSION_CLOSED,
                 UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
@@ -299,7 +301,7 @@ public class UwbMetricsTest {
                 UwbStatsLog.UWB_SESSION_CLOSED__RANGING_COUNT_BUCKET__ONE_TO_FIVE,
                 2, 1, 0,
                 RX_PACKET_COUNT, TX_PACKET_COUNT, 1, 1, RX_TO_UPPER_LEVEL_COUNT,
-                UwbStatsLog.UWB_SESSION_CLOSED__RANGING_TYPE__TWO_WAY));
+                UwbStatsLog.UWB_SESSION_CLOSED__RANGING_TYPE__TWO_WAY, UID));
     }
 
     @Test
@@ -323,10 +325,11 @@ public class UwbMetricsTest {
 
     @Test
     public void testLoggingRangingResultValidDistanceAngle() throws Exception {
+        when(mUwbSession.getProfileType())
+                .thenReturn(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA);
         mUwbMetrics.logRangingInitEvent(mUwbSession, UwbUciConstants.STATUS_CODE_OK);
         addElapsedTimeMs(DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS);
-        mUwbMetrics.logRangingResult(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
-                mRangingData, mFilteredRangingMeasurement);
+        mUwbMetrics.logRangingResult(mUwbSession, mRangingData, mFilteredRangingMeasurement);
 
         ExtendedMockito.verify(() -> UwbStatsLog.write(
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED,
@@ -340,15 +343,17 @@ public class UwbMetricsTest {
                 ELEVATION_DEFAULT_DEGREE / 10, ELEVATION_FOM_DEFAULT,
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED__RANGING_TYPE__TWO_WAY,
                 DISTANCE_FILTERED_CM, AZIMUTH_FILTERED_DEGREE, AZIMUTH_FOM_FILTERED,
-                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED
+                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED, UID
         ));
     }
 
     @Test
     public void testLoggingRangingResultSmallLoggingInterval() throws Exception {
+        when(mUwbSession.getProfileType())
+                .thenReturn(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA);
+
         mUwbMetrics.logRangingInitEvent(mUwbSession, UwbUciConstants.STATUS_CODE_OK);
-        mUwbMetrics.logRangingResult(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
-                mRangingData, mFilteredRangingMeasurement);
+        mUwbMetrics.logRangingResult(mUwbSession, mRangingData, mFilteredRangingMeasurement);
 
         ExtendedMockito.verify(() -> UwbStatsLog.write(
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED,
@@ -362,12 +367,14 @@ public class UwbMetricsTest {
                 ELEVATION_DEFAULT_DEGREE / 10, ELEVATION_FOM_DEFAULT,
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED__RANGING_TYPE__TWO_WAY,
                 DISTANCE_FILTERED_CM, AZIMUTH_FILTERED_DEGREE, AZIMUTH_FOM_FILTERED,
-                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED
+                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED, UID
         ), times(0));
     }
 
     @Test
     public void testLoggingRangingResultInvalidDistance() throws Exception {
+        when(mUwbSession.getProfileType())
+                .thenReturn(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__CCC);
         mUwbMetrics.logRangingInitEvent(mUwbSession, UwbUciConstants.STATUS_CODE_OK);
         addElapsedTimeMs(DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS);
         when(mTwoWayMeasurement.getDistance()).thenReturn(UwbMetrics.INVALID_DISTANCE);
@@ -378,8 +385,7 @@ public class UwbMetricsTest {
         when(mTwoWayMeasurement.getNLoS()).thenReturn(0);
         when(mFilteredRangingMeasurement.getDistanceMeasurement()).thenReturn(null);
 
-        mUwbMetrics.logRangingResult(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__CCC,
-                mRangingData, mFilteredRangingMeasurement);
+        mUwbMetrics.logRangingResult(mUwbSession, mRangingData, mFilteredRangingMeasurement);
 
         ExtendedMockito.verify(() -> UwbStatsLog.write(
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED,
@@ -391,20 +397,21 @@ public class UwbMetricsTest {
                 false, -20, 0, 0,
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED__RANGING_TYPE__TWO_WAY,
                 UwbMetrics.INVALID_DISTANCE, AZIMUTH_FILTERED_DEGREE, AZIMUTH_FOM_FILTERED,
-                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED
+                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED, UID
         ));
     }
 
     @Test
     public void testLoggingRangingResultDlTDoAMeasurement() throws Exception {
+        when(mUwbSession.getProfileType())
+                .thenReturn(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA);
         when(mRangingData.getRangingMeasuresType()).thenReturn(
                 (int) UwbUciConstants.RANGING_MEASUREMENT_TYPE_DL_TDOA);
         when(mFilteredRangingMeasurement.getDistanceMeasurement()).thenReturn(null);
 
         mUwbMetrics.logRangingInitEvent(mUwbSession, UwbUciConstants.STATUS_CODE_OK);
         addElapsedTimeMs(DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS);
-        mUwbMetrics.logRangingResult(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
-                mRangingData, mFilteredRangingMeasurement);
+        mUwbMetrics.logRangingResult(mUwbSession, mRangingData, mFilteredRangingMeasurement);
 
         ExtendedMockito.verify(() -> UwbStatsLog.write(
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED,
@@ -418,20 +425,21 @@ public class UwbMetricsTest {
                 ELEVATION_DEFAULT_DEGREE / 10, ELEVATION_FOM_DEFAULT,
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED__RANGING_TYPE__DL_TDOA,
                 UwbMetrics.INVALID_DISTANCE, AZIMUTH_FILTERED_DEGREE, AZIMUTH_FOM_FILTERED,
-                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED
+                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED, UID
         ));
     }
 
     @Test
     public void testLoggingRangingResultOwrAoaMeasurement() throws Exception {
+        when(mUwbSession.getProfileType())
+                .thenReturn(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA);
         when(mRangingData.getRangingMeasuresType()).thenReturn(
                 (int) UwbUciConstants.RANGING_MEASUREMENT_TYPE_OWR_AOA);
         when(mFilteredRangingMeasurement.getDistanceMeasurement()).thenReturn(null);
 
         mUwbMetrics.logRangingInitEvent(mUwbSession, UwbUciConstants.STATUS_CODE_OK);
         addElapsedTimeMs(DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS);
-        mUwbMetrics.logRangingResult(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
-                mRangingData, mFilteredRangingMeasurement);
+        mUwbMetrics.logRangingResult(mUwbSession, mRangingData, mFilteredRangingMeasurement);
 
         ExtendedMockito.verify(() -> UwbStatsLog.write(
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED,
@@ -445,7 +453,7 @@ public class UwbMetricsTest {
                 ELEVATION_DEFAULT_DEGREE / 10, ELEVATION_FOM_DEFAULT,
                 UwbStatsLog.UWB_RANGING_MEASUREMENT_RECEIVED__RANGING_TYPE__OWR_AOA,
                 UwbMetrics.INVALID_DISTANCE, AZIMUTH_FILTERED_DEGREE, AZIMUTH_FOM_FILTERED,
-                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED
+                ELEVATION_FILTERED_DEGREE, ELEVATION_FOM_FILTERED, UID
         ));
     }
 
@@ -470,16 +478,16 @@ public class UwbMetricsTest {
 
     @Test
     public void testDumpStatsNoCrash() throws Exception {
+        when(mUwbSession.getProfileType())
+                .thenReturn(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__CCC);
         mUwbMetrics.logRangingInitEvent(mUwbSession, UwbUciConstants.STATUS_CODE_OK);
         mUwbMetrics.logRangingInitEvent(mUwbSession,
                 UwbUciConstants.STATUS_CODE_INVALID_PARAM);
 
         addElapsedTimeMs(DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS);
-        mUwbMetrics.logRangingResult(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__CCC, mRangingData,
-                mFilteredRangingMeasurement);
+        mUwbMetrics.logRangingResult(mUwbSession, mRangingData, mFilteredRangingMeasurement);
         addElapsedTimeMs(DEFAULT_RANGING_RESULT_LOG_INTERVAL_MS);
-        mUwbMetrics.logRangingResult(UwbStatsLog.UWB_SESSION_INITIATED__PROFILE__FIRA,
-                mRangingData, mFilteredRangingMeasurement);
+        mUwbMetrics.logRangingResult(mUwbSession, mRangingData, mFilteredRangingMeasurement);
 
         ByteArrayOutputStream stream = new ByteArrayOutputStream();
         PrintWriter writer = new PrintWriter(stream);
diff --git a/service/tests/src/com/android/server/uwb/UwbServiceCoreTest.java b/service/tests/src/com/android/server/uwb/UwbServiceCoreTest.java
index 2cf18b64..814934cb 100644
--- a/service/tests/src/com/android/server/uwb/UwbServiceCoreTest.java
+++ b/service/tests/src/com/android/server/uwb/UwbServiceCoreTest.java
@@ -57,7 +57,6 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.validateMockitoUsage;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 import android.content.AttributionSource;
@@ -195,7 +194,11 @@ public class UwbServiceCoreTest {
                     .setNumSlotsPerRound(AliroParams.SLOTS_PER_ROUND_6)
                     .setSyncCodeIndex(1)
                     .setHoppingConfigMode(AliroParams.HOPPING_CONFIG_MODE_NONE)
-                    .setHoppingSequence(AliroParams.HOPPING_SEQUENCE_DEFAULT);
+                    .setHoppingSequence(AliroParams.HOPPING_SEQUENCE_DEFAULT)
+                    .setMacModeRound(AliroParams.MAC_MODE_ROUND_1)
+                    .setMacModeOffset(0)
+                    .setSessionKey(new byte[]{0x5, 0x78, 0x5, 0x78, 0x5, 0x78, 0x5, 0x78, 0x5,
+                            0x78, 0x5, 0x78, 0x5, 0x78, 0x5, 0x78});
     @VisibleForTesting
     private static final CccOpenRangingParams.Builder TEST_CCC_OPEN_RANGING_PARAMS =
             new CccOpenRangingParams.Builder()
@@ -1928,7 +1931,7 @@ public class UwbServiceCoreTest {
 
         mUwbServiceCore.unregisterVendorExtensionCallback(vendorCb);
         mUwbServiceCore.onVendorUciNotificationReceived(gid, oid, payload);
-        verifyZeroInteractions(vendorCb);
+        verifyNoMoreInteractions(vendorCb);
     }
 
     @Test
@@ -2089,6 +2092,8 @@ public class UwbServiceCoreTest {
                 };
 
         Integer[] uwbConfigs = new Integer[] {AliroParams.UWB_CONFIG_0, AliroParams.UWB_CONFIG_1};
+        Integer[] macModes = new Integer[] {AliroParams.MAC_MODE_ROUND_1,
+                AliroParams.MAC_MODE_ROUND_2};
         AliroPulseShapeCombo[] pulseShapeCombos =
                 new AliroPulseShapeCombo[] {
                         new AliroPulseShapeCombo(
@@ -2150,6 +2155,9 @@ public class UwbServiceCoreTest {
         for (int hoppingSequence : hoppingSequences) {
             paramsBuilder.addHoppingSequence(hoppingSequence);
         }
+        for (int macMode : macModes) {
+            paramsBuilder.addMacMode(macMode);
+        }
         return paramsBuilder.build();
     }
 
diff --git a/service/tests/src/com/android/server/uwb/UwbSessionManagerTest.java b/service/tests/src/com/android/server/uwb/UwbSessionManagerTest.java
index 48e1e002..ee5765b1 100644
--- a/service/tests/src/com/android/server/uwb/UwbSessionManagerTest.java
+++ b/service/tests/src/com/android/server/uwb/UwbSessionManagerTest.java
@@ -84,7 +84,6 @@ import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 import android.annotation.NonNull;
@@ -204,7 +203,7 @@ public class UwbSessionManagerTest {
     private static final int DATA_TRANSMISSION_COUNT_3 = 3;
     private static final int UWB_HUS_CONTROLLER_PHASE_LIST_SHORT_MAC_ADDRESS_SIZE = 11;
     private static final int UWB_HUS_CONTROLLER_PHASE_LIST_EXTENDED_MAC_ADDRESS_SIZE = 17;
-    private static final int UWB_HUS_CONTROLEE_PHASE_LIST_SIZE = 5;
+    private static final int UWB_HUS_CONTROLEE_PHASE_LIST_SIZE = 4;
     private static final FiraProtocolVersion FIRA_VERSION_1_0 = new FiraProtocolVersion(1, 0);
     private static final FiraProtocolVersion FIRA_VERSION_1_1 = new FiraProtocolVersion(1, 1);
     private static final FiraProtocolVersion FIRA_VERSION_2_0 = new FiraProtocolVersion(2, 0);
@@ -253,6 +252,10 @@ public class UwbSessionManagerTest {
                     .setSyncCodeIndex(1)
                     .setHoppingConfigMode(AliroParams.HOPPING_CONFIG_MODE_NONE)
                     .setHoppingSequence(AliroParams.HOPPING_SEQUENCE_DEFAULT)
+                    .setMacModeRound(AliroParams.MAC_MODE_ROUND_1)
+                    .setMacModeOffset(0)
+                    .setSessionKey(new byte[]{0x5, 0x78, 0x5, 0x78, 0x5, 0x78, 0x5, 0x78, 0x5,
+                            0x78, 0x5, 0x78, 0x5, 0x78, 0x5, 0x78})
                     .build();
     private static final CccOpenRangingParams CCC_OPEN_RANGING_PARAMS_DEFAULT =
             new CccOpenRangingParams.Builder()
@@ -276,8 +279,6 @@ public class UwbSessionManagerTest {
     private FiraHybridSessionControllerConfig mHybridControllerParams =
             new FiraHybridSessionControllerConfig.Builder()
                 .setNumberOfPhases(2)
-                .setUpdateTime(new byte[8])
-                .setMacAddressMode((byte) 0)
                 .addPhaseList(
                         new FiraHybridSessionControllerConfig.FiraHybridSessionPhaseList(
                                 SESSION_HANDLE.getId(), (short) 0x01, (short) 0x34,
@@ -292,12 +293,10 @@ public class UwbSessionManagerTest {
                 .setNumberOfPhases(2)
                 .addPhaseList(
                         new FiraHybridSessionControleeConfig.FiraHybridSessionPhaseList(
-                                SESSION_HANDLE.getId(),
-                                (byte) PARTICIPATION_AS_DEFINED_DEVICE_ROLE))
+                                SESSION_HANDLE.getId()))
                 .addPhaseList(
                         new FiraHybridSessionControleeConfig.FiraHybridSessionPhaseList(
-                                SESSION_HANDLE_2.getId(),
-                                (byte) PARTICIPATION_AS_DEFINED_DEVICE_ROLE))
+                                SESSION_HANDLE_2.getId()))
                 .build();
 
     private static final long UWBS_TIMESTAMP = 2000000L;
@@ -367,6 +366,9 @@ public class UwbSessionManagerTest {
         when(mUwbMultichipData.getDefaultChipId()).thenReturn("default");
         when(mDeviceConfigFacade.isBackgroundRangingEnabled()).thenReturn(false);
         when(mDeviceConfigFacade.isRangingErrorStreakTimerEnabled()).thenReturn(true);
+        when(mAliroSpecificationParams.getMacModes()).thenReturn(Arrays.asList(
+                AliroParams.MAC_MODE_ROUND_1,
+                AliroParams.MAC_MODE_ROUND_2));
 
         // TODO: Don't use spy.
         mUwbSessionManager = spy(new UwbSessionManager(
@@ -699,7 +701,7 @@ public class UwbSessionManagerTest {
         // Next call onRangeDataNotificationReceived() to process the RANGE_DATA_NTF.
         mUwbSessionManager.onRangeDataNotificationReceived(uwbRangingData);
 
-        verifyZeroInteractions(mUwbAdvertiseManager, mUwbSessionNotificationManager, mUwbMetrics);
+        verifyNoMoreInteractions(mUwbAdvertiseManager, mUwbSessionNotificationManager, mUwbMetrics);
     }
 
     @Test
@@ -724,7 +726,7 @@ public class UwbSessionManagerTest {
 
         verify(mUwbSessionNotificationManager)
                 .onRangingResult(eq(mockUwbSession), eq(uwbRangingData));
-        verifyZeroInteractions(mUwbAdvertiseManager);
+        verifyNoMoreInteractions(mUwbAdvertiseManager);
     }
 
     @Test
@@ -753,7 +755,7 @@ public class UwbSessionManagerTest {
 
         verify(mUwbSessionNotificationManager)
                 .onRangingResult(eq(mockUwbSession), eq(uwbRangingData));
-        verifyZeroInteractions(mUwbAdvertiseManager);
+        verifyNoMoreInteractions(mUwbAdvertiseManager);
     }
 
     @Test
@@ -781,7 +783,7 @@ public class UwbSessionManagerTest {
 
         verify(mUwbSessionNotificationManager)
                 .onRangingResult(eq(mockUwbSession), eq(uwbRangingData));
-        verifyZeroInteractions(mUwbAdvertiseManager);
+        verifyNoMoreInteractions(mUwbAdvertiseManager);
     }
 
     @Test
@@ -808,7 +810,7 @@ public class UwbSessionManagerTest {
         verify(mUwbSessionNotificationManager)
                 .onRangingResult(eq(mockUwbSession), eq(uwbRangingData));
         verify(mUwbAdvertiseManager).updateAdvertiseTarget(uwbRangingData.mRangingOwrAoaMeasure);
-        verifyZeroInteractions(mUwbSessionNotificationManager);
+        verifyNoMoreInteractions(mUwbSessionNotificationManager);
         verify(mUwbMetrics, never()).logDataToUpperLayer(eq(mockUwbSession), anyInt());
     }
 
@@ -842,7 +844,7 @@ public class UwbSessionManagerTest {
         verify(mUwbSessionNotificationManager)
                 .onRangingResult(eq(mockUwbSession), eq(uwbRangingData));
         verify(mUwbAdvertiseManager).updateAdvertiseTarget(uwbRangingData.mRangingOwrAoaMeasure);
-        verifyZeroInteractions(mUwbSessionNotificationManager);
+        verifyNoMoreInteractions(mUwbSessionNotificationManager);
         verify(mUwbMetrics, never()).logDataToUpperLayer(eq(mockUwbSession), anyInt());
     }
 
@@ -883,7 +885,7 @@ public class UwbSessionManagerTest {
         verify(mUwbSessionNotificationManager)
                 .onRangingResult(eq(mockUwbSession), eq(uwbRangingData));
         verify(mUwbAdvertiseManager).updateAdvertiseTarget(uwbRangingData.mRangingOwrAoaMeasure);
-        verifyZeroInteractions(mUwbSessionNotificationManager);
+        verifyNoMoreInteractions(mUwbSessionNotificationManager);
         verify(mUwbMetrics, never()).logDataToUpperLayer(eq(mockUwbSession), anyInt());
     }
 
@@ -910,7 +912,7 @@ public class UwbSessionManagerTest {
         verify(mUwbSessionNotificationManager)
                 .onRangingResult(eq(mockUwbSession), eq(uwbRangingData));
         verify(mUwbAdvertiseManager, never()).removeAdvertiseTarget(isA(Long.class));
-        verifyZeroInteractions(mUwbSessionNotificationManager);
+        verifyNoMoreInteractions(mUwbSessionNotificationManager);
     }
 
     @Test
@@ -1120,7 +1122,7 @@ public class UwbSessionManagerTest {
     }
 
     @Test
-    public void initSessionMaxSessions_lowestPrioritySessionReplaced() throws RemoteException {
+    public void initSessionMaxSessions_lowestPrioritySessionReplaced() throws Exception {
         doReturn(false).when(mUwbInjector).isSystemApp(UID, PACKAGE_NAME);
         doReturn(true).when(mUwbInjector).isSystemApp(UID_2, PACKAGE_NAME_2);
         doReturn(1L).when(mUwbSessionManager).getMaxFiraSessionsNumber(TEST_CHIP_ID);
@@ -1135,9 +1137,14 @@ public class UwbSessionManagerTest {
         when(mUwbConfigurationManager.setAppConfigurations(anyInt(), any(), anyString(), any()))
                 .thenReturn(UwbUciConstants.STATUS_CODE_OK);
 
+        AttributionSource attributionSourceLowPriority = new AttributionSource.Builder(UID)
+                .setPackageName(PACKAGE_NAME).build();
+
+        when(mUwbInjector.getAnyNonPrivilegedAppInAttributionSource(attributionSourceLowPriority))
+                .thenReturn(attributionSourceLowPriority);
         // Init session for 3rd party FG app
         UwbSession lowPrioUwbSession = spy(
-                mUwbSessionManager.new UwbSession(ATTRIBUTION_SOURCE, SESSION_HANDLE,
+                mUwbSessionManager.new UwbSession(attributionSourceLowPriority, SESSION_HANDLE,
                         TEST_SESSION_ID, TEST_SESSION_TYPE, FiraParams.PROTOCOL_NAME, mockParams,
                         mockRangingCallbacks, TEST_CHIP_ID));
         doReturn(lowPrioUwbSession).when(mUwbSessionManager).createUwbSession(any(), any(),
@@ -1259,6 +1266,8 @@ public class UwbSessionManagerTest {
                 .thenReturn(true);
         AttributionSource attributionSourceNonSystemApp =
                 new AttributionSource.Builder(UID).setPackageName(nonSystemPackageName).build();
+        when(mUwbInjector.getAnyNonPrivilegedAppInAttributionSource(any()))
+                .thenReturn(attributionSourceNonSystemApp);
         UwbSession nonSystemFgUwbSession =
                 mUwbSessionManager.new UwbSession(attributionSourceNonSystemApp, mockSessionHandle,
                         TEST_SESSION_ID, TEST_SESSION_TYPE, FiraParams.PROTOCOL_NAME,
@@ -2221,7 +2230,8 @@ public class UwbSessionManagerTest {
     public void testInitSessionWithNonSystemAppNotInFg() throws Exception {
         when(mUwbInjector.isSystemApp(UID, PACKAGE_NAME)).thenReturn(false);
         when(mUwbInjector.isForegroundAppOrService(UID, PACKAGE_NAME)).thenReturn(false);
-
+        when(mUwbInjector.getAnyNonPrivilegedAppInAttributionSource(any()))
+                .thenReturn(ATTRIBUTION_SOURCE);
         UwbSession uwbSession = setUpUwbSessionForExecution(ATTRIBUTION_SOURCE);
         mUwbSessionManager.initSession(ATTRIBUTION_SOURCE, uwbSession.getSessionHandle(),
                 TEST_SESSION_ID, TEST_SESSION_TYPE, FiraParams.PROTOCOL_NAME,
@@ -2271,6 +2281,8 @@ public class UwbSessionManagerTest {
                         .setPackageName(PACKAGE_NAME_2)
                         .build());
         AttributionSource attributionSource = builder.build();
+        when(mUwbInjector.getAnyNonPrivilegedAppInAttributionSource(any()))
+                .thenReturn(attributionSource.getNext());
 
         UwbSession uwbSession = setUpUwbSessionForExecution(attributionSource);
         mUwbSessionManager.initSession(attributionSource, uwbSession.getSessionHandle(),
@@ -2292,6 +2304,8 @@ public class UwbSessionManagerTest {
                         .build())
                 .build();
 
+        when(mUwbInjector.getAnyNonPrivilegedAppInAttributionSource(any()))
+                .thenReturn(attributionSource.getNext());
         UwbSession uwbSession = setUpUwbSessionForExecution(attributionSource);
         mUwbSessionManager.initSession(attributionSource, uwbSession.getSessionHandle(),
                 TEST_SESSION_ID, TEST_SESSION_TYPE, FiraParams.PROTOCOL_NAME,
@@ -2367,6 +2381,8 @@ public class UwbSessionManagerTest {
     public void
             testOpenRangingWithNonSystemAppInFgInChain_MoveToBgAndStayThere_WhenBgRangingEnabled()
             throws Exception {
+        when(mUwbInjector.getAnyNonPrivilegedAppInAttributionSource(
+                any())).thenReturn(ATTRIBUTION_SOURCE);
         when(mDeviceConfigFacade.isBackgroundRangingEnabled()).thenReturn(true);
         UwbSession uwbSession = initUwbSessionForNonSystemAppInFgInChain();
 
@@ -2514,6 +2530,8 @@ public class UwbSessionManagerTest {
                         .setPackageName(PACKAGE_NAME_2)
                         .build());
         AttributionSource attributionSource = builder.build();
+        when(mUwbInjector.getAnyNonPrivilegedAppInAttributionSource(any()))
+                .thenReturn(attributionSource.getNext());
         UwbSession uwbSession = setUpUwbSessionForExecution(attributionSource);
         mUwbSessionManager.initSession(attributionSource, uwbSession.getSessionHandle(),
                 TEST_SESSION_ID, TEST_SESSION_TYPE, FiraParams.PROTOCOL_NAME,
@@ -4680,6 +4698,7 @@ public class UwbSessionManagerTest {
         byte dataTransferControl = 0;
         byte dtpmlSize = 2;
         byte[] slotBitmapBytes = new byte[] { 0x10, 0x20 };
+        byte[] stopDataTransferBytes = new byte[] { 0x01, 0x00 };
 
         List<FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList>
                     firaDataTransferPhaseManagementList =  new ArrayList<>();
@@ -4693,7 +4712,7 @@ public class UwbSessionManagerTest {
         expectedMacAddressBuf.put(getComputedMacAddress(macAddressBytes));
         firaDataTransferPhaseManagementList.add(
                 new FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList(
-                uwbAddress, new byte[] {(byte) 0x10}));
+                uwbAddress, new byte[] {(byte) 0x10}, (byte) 0x01));
 
         // Setup Phase #2
         macAddressBytes = new byte[]{0x44, 0x33};
@@ -4701,7 +4720,7 @@ public class UwbSessionManagerTest {
         expectedMacAddressBuf.put(getComputedMacAddress(macAddressBytes));
         firaDataTransferPhaseManagementList.add(
                 new FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList(
-                uwbAddress, new byte[] {(byte) 0x20}));
+                uwbAddress, new byte[] {(byte) 0x20}, (byte) 0x00));
 
         FiraDataTransferPhaseConfig firaDataTransferPhaseConfig =
                 new FiraDataTransferPhaseConfig.Builder()
@@ -4714,16 +4733,17 @@ public class UwbSessionManagerTest {
         byte[] expectedMacAddressBytes = expectedMacAddressBuf.array();
         when(mNativeUwbManager.setDataTransferPhaseConfig(eq(TEST_SESSION_ID),
                 eq(dtpcmRepetition), eq(dataTransferControl), eq(dtpmlSize),
-                eq(expectedMacAddressBytes), eq(slotBitmapBytes), eq(TEST_CHIP_ID)))
-                .thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
+                eq(expectedMacAddressBytes), eq(slotBitmapBytes), eq(stopDataTransferBytes),
+                eq(TEST_CHIP_ID))).thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
+        doReturn(UwbUciConstants.UWB_SESSION_STATE_IDLE).when(uwbSession).getSessionState();
 
         mUwbSessionManager.setDataTransferPhaseConfig(
                 uwbSession.getSessionHandle(), firaDataTransferPhaseConfig.toBundle());
-        mTestLooper.dispatchNext();
+        mTestLooper.dispatchAll();
 
         verify(mNativeUwbManager).setDataTransferPhaseConfig(TEST_SESSION_ID,
                 dtpcmRepetition, dataTransferControl, dtpmlSize, expectedMacAddressBytes,
-                slotBitmapBytes, TEST_CHIP_ID);
+                slotBitmapBytes, stopDataTransferBytes , TEST_CHIP_ID);
     }
 
     @Test
@@ -4737,7 +4757,7 @@ public class UwbSessionManagerTest {
                         UWB_DEST_ADDRESS))
                 .setProtocolVersion(new FiraProtocolVersion(1, 0))
                 .setSessionId(10)
-                .setSessionType(FiraParams.SESSION_TYPE_RANGING_AND_IN_BAND_DATA)
+                .setSessionType(FiraParams.SESSION_TYPE_DATA_TRANSFER)
                 .setDeviceType(FiraParams.RANGING_DEVICE_TYPE_CONTROLLER)
                 .setDeviceRole(FiraParams.RANGING_DEVICE_ROLE_INITIATOR)
                 .setMultiNodeMode(FiraParams.MULTI_NODE_MODE_UNICAST)
@@ -4745,12 +4765,13 @@ public class UwbSessionManagerTest {
                 .setDataRepetitionCount(0)
                 .build();
         UwbSession uwbSession = prepareExistingUwbSessionWithSessionType(
-                (byte) FiraParams.SESSION_TYPE_RANGING_AND_IN_BAND_DATA, params);
+                (byte) FiraParams.SESSION_TYPE_DATA_TRANSFER, params);
         byte dtpcmRepetition = 0;
         byte dataTransferControl = 4;
         byte dtpmlSize = 2;
         byte[] slotBitmapBytes = new byte[]
                 { 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, (byte) 0x80 };
+        byte[] stopDataTransferBytes = new byte[] { 0x01, 0x00 };
 
         List<FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList>
                     firaDataTransferPhaseManagementList =  new ArrayList<>();
@@ -4763,7 +4784,7 @@ public class UwbSessionManagerTest {
         expectedMacAddressBuf.put(getComputedMacAddress(macAddressBytes));
         firaDataTransferPhaseManagementList.add(
                 new FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList(
-                uwbAddress, new byte[] {0x10, 0x20, 0x30, 0x40}));
+                uwbAddress, new byte[] {0x10, 0x20, 0x30, 0x40}, (byte) 0x01));
 
         // Setup Phase #2
         macAddressBytes = new byte[]{0x44, 0x33};
@@ -4771,7 +4792,7 @@ public class UwbSessionManagerTest {
         expectedMacAddressBuf.put(getComputedMacAddress(macAddressBytes));
         firaDataTransferPhaseManagementList.add(
                 new FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList(
-                uwbAddress, new byte[] {0x50, 0x60, 0x70, (byte) 0x80}));
+                uwbAddress, new byte[] {0x50, 0x60, 0x70, (byte) 0x80}, (byte) 0x00));
 
         FiraDataTransferPhaseConfig firaDataTransferPhaseConfig =
                 new FiraDataTransferPhaseConfig.Builder()
@@ -4784,8 +4805,9 @@ public class UwbSessionManagerTest {
         byte[] expectedMacAddressBytes = expectedMacAddressBuf.array();
         when(mNativeUwbManager.setDataTransferPhaseConfig(eq(TEST_SESSION_ID),
                 eq(dtpcmRepetition), eq(dataTransferControl), eq(dtpmlSize),
-                eq(expectedMacAddressBytes), eq(slotBitmapBytes), eq(TEST_CHIP_ID)))
-                .thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
+                eq(expectedMacAddressBytes), eq(slotBitmapBytes), eq(stopDataTransferBytes),
+                eq(TEST_CHIP_ID))).thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
+        doReturn(UwbUciConstants.UWB_SESSION_STATE_IDLE).when(uwbSession).getSessionState();
 
         mUwbSessionManager.setDataTransferPhaseConfig(
                 uwbSession.getSessionHandle(), firaDataTransferPhaseConfig.toBundle());
@@ -4793,7 +4815,7 @@ public class UwbSessionManagerTest {
 
         verify(mNativeUwbManager).setDataTransferPhaseConfig(TEST_SESSION_ID,
                 dtpcmRepetition, dataTransferControl, dtpmlSize, expectedMacAddressBytes,
-                slotBitmapBytes, TEST_CHIP_ID);
+                slotBitmapBytes, stopDataTransferBytes, TEST_CHIP_ID);
     }
 
     @Test
@@ -4802,6 +4824,7 @@ public class UwbSessionManagerTest {
         byte dataTransferControl = 0;
         byte dtpmlSize = 2;
         byte[] slotBitmapBytes = new byte[] { 0x10, 0x20 };
+        byte[] stopDataTransferBytes = new byte[] { 0x01, 0x00 };
         /** By default SESSION_TYPE_RANGING is used, so testcase is expected to
          *  fail due to Invalid session type for data transfer phase config
          */
@@ -4818,7 +4841,7 @@ public class UwbSessionManagerTest {
         expectedMacAddressBuf.put(getComputedMacAddress(macAddressBytes));
         firaDataTransferPhaseManagementList.add(
                 new FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList(
-                uwbAddress, new byte[] {(byte) 0x10}));
+                        uwbAddress, new byte[] { (byte) 0x10 }, (byte) 0x01));
 
         // Setup Phase #2
         macAddressBytes = new byte[]{0x44, 0x33};
@@ -4826,8 +4849,7 @@ public class UwbSessionManagerTest {
         expectedMacAddressBuf.put(getComputedMacAddress(macAddressBytes));
         firaDataTransferPhaseManagementList.add(
                 new FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList(
-                uwbAddress, new byte[] {(byte) 0x20, 0x30})); //Invalid slot bit map
-
+                uwbAddress, new byte[] {(byte) 0x20, 0x30}, (byte) 0x00)); //Invalid slot bit map
         FiraDataTransferPhaseConfig firaDataTransferPhaseConfig =
                 new FiraDataTransferPhaseConfig.Builder()
                    .setDtpcmRepetition((byte) dtpcmRepetition)
@@ -4843,7 +4865,7 @@ public class UwbSessionManagerTest {
         byte[] expectedMacAddressBytes = expectedMacAddressBuf.array();
         verify(mNativeUwbManager, never()).setDataTransferPhaseConfig(TEST_SESSION_ID,
                 dtpcmRepetition, dataTransferControl, dtpmlSize, expectedMacAddressBytes,
-                slotBitmapBytes, TEST_CHIP_ID);
+                slotBitmapBytes, stopDataTransferBytes, TEST_CHIP_ID);
     }
 
     @Test
@@ -4853,6 +4875,7 @@ public class UwbSessionManagerTest {
         byte dataTransferControl = 0;
         byte dtpmlSize = 2;
         byte[] slotBitmapBytes = new byte[] { 0x10, 0x20 };
+        byte[] stopDataTransferBytes = new byte[] { 0x01, 0x00 };
 
         List<FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList>
                     firaDataTransferPhaseManagementList = new ArrayList<>();
@@ -4865,7 +4888,7 @@ public class UwbSessionManagerTest {
         expectedMacAddressBuf.put(getComputedMacAddress(macAddressBytes));
         firaDataTransferPhaseManagementList.add(
                 new FiraDataTransferPhaseConfig.FiraDataTransferPhaseManagementList(
-                uwbAddress, new byte[] {(byte) 0x10}));
+                uwbAddress, new byte[] {(byte) 0x10}, (byte) 0x01));
 
         // Size of dtpml-Size is 2 but only one set of configs are provided
         FiraDataTransferPhaseConfig firaDataTransferPhaseConfig =
@@ -4883,7 +4906,7 @@ public class UwbSessionManagerTest {
         byte[] expectedMacAddressBytes = expectedMacAddressBuf.array();
         verify(mNativeUwbManager, never()).setDataTransferPhaseConfig(TEST_SESSION_ID,
                 dtpcmRepetition, dataTransferControl, dtpmlSize, expectedMacAddressBytes,
-                slotBitmapBytes, TEST_CHIP_ID);
+                slotBitmapBytes, stopDataTransferBytes, TEST_CHIP_ID);
     }
 
 
@@ -4956,7 +4979,7 @@ public class UwbSessionManagerTest {
                         UWB_DEST_ADDRESS))
                 .setProtocolVersion(new FiraProtocolVersion(1, 0))
                 .setSessionId(10)
-                .setSessionType(FiraParams.SESSION_TYPE_RANGING)
+                .setSessionType(FiraParams.SESSION_TYPE_HUS_PRIMARY_SESSION)
                 .setDeviceType(FiraParams.RANGING_DEVICE_TYPE_CONTROLLER)
                 .setDeviceRole(FiraParams.RANGING_DEVICE_ROLE_INITIATOR)
                 .setMultiNodeMode(FiraParams.MULTI_NODE_MODE_UNICAST)
@@ -4965,12 +4988,10 @@ public class UwbSessionManagerTest {
                 .setDataRepetitionCount(0)
                 .build();
         UwbSession uwbSession = prepareExistingUwbSessionWithSessionType(
-                (byte) FiraParams.SESSION_TYPE_RANGING, params);
+                (byte) FiraParams.SESSION_TYPE_HUS_PRIMARY_SESSION, params);
 
         byte messageControl = 0;
         int noOfPhases = 2;
-        byte phaseParticipation = 0;
-        byte [] updateTime = new byte[8];
         short startSlotIndex1 = 0x01, endSlotIndex1 = 0x34;
         short startSlotIndex2 = 0x37, endSlotIndex2 = 0x64;
 
@@ -4979,20 +5000,20 @@ public class UwbSessionManagerTest {
                 * UWB_HUS_CONTROLLER_PHASE_LIST_SHORT_MAC_ADDRESS_SIZE);
         expectedHybridConfigBytes.order(ByteOrder.LITTLE_ENDIAN);
 
-        expectedHybridConfigBytes.putInt(0); //SessionToken
+        expectedHybridConfigBytes.putInt(TEST_SESSION_ID); //SessionToken
         expectedHybridConfigBytes.putShort(startSlotIndex1);
         expectedHybridConfigBytes.putShort(endSlotIndex1);
-        expectedHybridConfigBytes.put(phaseParticipation);
+        expectedHybridConfigBytes.put(messageControl);
         expectedHybridConfigBytes.put(getComputedMacAddress(UWB_DEST_ADDRESS.toBytes()));
 
-        expectedHybridConfigBytes.putInt(0); //SessionToken
+        expectedHybridConfigBytes.putInt(TEST_SESSION_ID_2); //SessionToken
         expectedHybridConfigBytes.putShort(startSlotIndex2);
         expectedHybridConfigBytes.putShort(endSlotIndex2);
-        expectedHybridConfigBytes.put(phaseParticipation);
+        expectedHybridConfigBytes.put(messageControl);
         expectedHybridConfigBytes.put(getComputedMacAddress(UWB_DEST_ADDRESS_2.toBytes()));
 
         when(mNativeUwbManager.setHybridSessionControllerConfiguration(
-                anyInt(), anyByte(), anyInt(), any(), any(), anyString()))
+                anyInt(), anyInt(), any(), anyString()))
                .thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
 
         // Invoke the method that triggers the 'setHybridSessionControllerConfiguration'
@@ -5001,8 +5022,8 @@ public class UwbSessionManagerTest {
         mTestLooper.dispatchAll();
 
         verify(mNativeUwbManager).setHybridSessionControllerConfiguration(
-                    uwbSession.getSessionId(), messageControl, noOfPhases,
-                    updateTime, expectedHybridConfigBytes.array(), uwbSession.getChipId());
+                    uwbSession.getSessionId(), noOfPhases,
+                    expectedHybridConfigBytes.array(), uwbSession.getChipId());
     }
 
     @Test
@@ -5016,7 +5037,7 @@ public class UwbSessionManagerTest {
                         UWB_DEST_ADDRESS))
                 .setProtocolVersion(new FiraProtocolVersion(1, 0))
                 .setSessionId(10)
-                .setSessionType(FiraParams.SESSION_TYPE_RANGING)
+                .setSessionType(FiraParams.SESSION_TYPE_HUS_PRIMARY_SESSION)
                 .setDeviceType(FiraParams.RANGING_DEVICE_TYPE_CONTROLLER)
                 .setDeviceRole(FiraParams.RANGING_DEVICE_ROLE_INITIATOR)
                 .setMultiNodeMode(FiraParams.MULTI_NODE_MODE_UNICAST)
@@ -5025,14 +5046,12 @@ public class UwbSessionManagerTest {
                 .setDataRepetitionCount(0)
                 .build();
         UwbSession uwbSession = prepareExistingUwbSessionWithSessionType(
-                (byte) FiraParams.SESSION_TYPE_RANGING, params);
+                (byte) FiraParams.SESSION_TYPE_HUS_PRIMARY_SESSION, params);
 
-        byte[] updateTime = new byte[8];
         int noOfPhases = 2;
         short startSlotIndex1 = 0x01, endSlotIndex1 = 0x34;
         short startSlotIndex2 = 0x37, endSlotIndex2 = 0x64;
         byte messageControl = 1;
-        byte phaseParticipation = 0;
         UwbAddress uwbAddress1 = UwbAddress.fromBytes(new byte[] {
                 0x11, 0x22, 0x33, 0x44, 0x55, 0x56, 0x57, 0x66 });
         UwbAddress uwbAddress2 = UwbAddress.fromBytes(new byte[] {
@@ -5041,16 +5060,14 @@ public class UwbSessionManagerTest {
         FiraHybridSessionControllerConfig hybridParams =
                 new FiraHybridSessionControllerConfig.Builder()
                 .setNumberOfPhases(noOfPhases)
-                .setUpdateTime(updateTime)
-                .setMacAddressMode((byte) 1)
                 .addPhaseList(
                         new FiraHybridSessionControllerConfig.FiraHybridSessionPhaseList(
                                 SESSION_HANDLE.getId(), startSlotIndex1, endSlotIndex1,
-                                phaseParticipation, uwbAddress1))
+                                messageControl, uwbAddress1))
                 .addPhaseList(
                         new FiraHybridSessionControllerConfig.FiraHybridSessionPhaseList(
                                 SESSION_HANDLE_2.getId(), startSlotIndex2, endSlotIndex2,
-                                phaseParticipation, uwbAddress2))
+                                messageControl, uwbAddress2))
                 .build();
 
         /* Setup the expected byte-array for the Hybrid configuration. */
@@ -5058,21 +5075,21 @@ public class UwbSessionManagerTest {
                 * UWB_HUS_CONTROLLER_PHASE_LIST_EXTENDED_MAC_ADDRESS_SIZE);
         expectedHybridConfigBytes.order(ByteOrder.LITTLE_ENDIAN);
 
-        expectedHybridConfigBytes.putInt(0); //SessionToken
+        expectedHybridConfigBytes.putInt(TEST_SESSION_ID); //SessionToken
         expectedHybridConfigBytes.putShort(startSlotIndex1);
         expectedHybridConfigBytes.putShort(endSlotIndex1);
-        expectedHybridConfigBytes.put(phaseParticipation);
+        expectedHybridConfigBytes.put(messageControl);
         expectedHybridConfigBytes.put(getComputedMacAddress(uwbAddress1.toBytes()));
 
-        expectedHybridConfigBytes.putInt(0); //SessionToken
+        expectedHybridConfigBytes.putInt(TEST_SESSION_ID_2); //SessionToken
         expectedHybridConfigBytes.putShort(startSlotIndex2);
         expectedHybridConfigBytes.putShort(endSlotIndex2);
-        expectedHybridConfigBytes.put(phaseParticipation);
+        expectedHybridConfigBytes.put(messageControl);
         expectedHybridConfigBytes.put(getComputedMacAddress(uwbAddress2.toBytes()));
 
         when(mNativeUwbManager.setHybridSessionControllerConfiguration(
-            anyInt(), anyByte(), anyInt(),
-            any(), any(), anyString()))
+            anyInt(), anyInt(),
+            any(), anyString()))
             .thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
 
         // Invoke the method that triggers the 'setHybridSessionControllerConfiguration'
@@ -5081,8 +5098,8 @@ public class UwbSessionManagerTest {
         mTestLooper.dispatchAll();
 
         verify(mNativeUwbManager).setHybridSessionControllerConfiguration(
-                uwbSession.getSessionId(), messageControl, noOfPhases,
-                updateTime, expectedHybridConfigBytes.array(), uwbSession.getChipId());
+                uwbSession.getSessionId(), noOfPhases,
+                expectedHybridConfigBytes.array(), uwbSession.getChipId());
     }
 
     @Test
@@ -5096,7 +5113,7 @@ public class UwbSessionManagerTest {
                         UWB_DEST_ADDRESS))
                 .setProtocolVersion(new FiraProtocolVersion(1, 0))
                 .setSessionId(10)
-                .setSessionType(FiraParams.SESSION_TYPE_RANGING_ONLY_PHASE)
+                .setSessionType(FiraParams.SESSION_TYPE_RANGING)
                 .setDeviceType(FiraParams.RANGING_DEVICE_TYPE_CONTROLLER)
                 .setDeviceRole(FiraParams.RANGING_DEVICE_ROLE_INITIATOR)
                 .setMultiNodeMode(FiraParams.MULTI_NODE_MODE_UNICAST)
@@ -5105,7 +5122,7 @@ public class UwbSessionManagerTest {
                 .setDataRepetitionCount(0)
                 .build();
         UwbSession uwbSession = prepareExistingUwbSessionWithSessionType(
-                (byte) FiraParams.SESSION_TYPE_RANGING_ONLY_PHASE, params);
+                (byte) FiraParams.SESSION_TYPE_RANGING, params);
 
 
         // Expected to fail due to invalid session type
@@ -5210,7 +5227,7 @@ public class UwbSessionManagerTest {
                         UWB_DEST_ADDRESS))
                 .setProtocolVersion(new FiraProtocolVersion(1, 0))
                 .setSessionId(10)
-                .setSessionType(FiraParams.SESSION_TYPE_RANGING)
+                .setSessionType(FiraParams.SESSION_TYPE_HUS_PRIMARY_SESSION)
                 .setDeviceType(FiraParams.RANGING_DEVICE_TYPE_CONTROLEE)
                 .setDeviceRole(FiraParams.RANGING_DEVICE_ROLE_INITIATOR)
                 .setMultiNodeMode(FiraParams.MULTI_NODE_MODE_UNICAST)
@@ -5219,19 +5236,16 @@ public class UwbSessionManagerTest {
                 .setDataRepetitionCount(0)
                 .build();
         UwbSession uwbSession = prepareExistingUwbSessionWithSessionType(
-                (byte) FiraParams.SESSION_TYPE_RANGING, params);
+                (byte) FiraParams.SESSION_TYPE_HUS_PRIMARY_SESSION, params);
 
         int noOfPhases = 2;
-        byte phaseParticipation = 0;
        // Setup the expected byte-array for the Hybrid configuration.
         ByteBuffer expectedHybridConfigBytes = ByteBuffer.allocate(noOfPhases
                 * UWB_HUS_CONTROLEE_PHASE_LIST_SIZE);
         expectedHybridConfigBytes.order(ByteOrder.LITTLE_ENDIAN);
 
         expectedHybridConfigBytes.putInt(0); //SessionToken
-        expectedHybridConfigBytes.put(phaseParticipation);
         expectedHybridConfigBytes.putInt(0); //SessionToken
-        expectedHybridConfigBytes.put(phaseParticipation);
         when(mNativeUwbManager.setHybridSessionControleeConfiguration(
             anyInt(), anyInt(), any(), anyString()))
             .thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
@@ -5365,7 +5379,7 @@ public class UwbSessionManagerTest {
 
         assertThat(mTestLooper.nextMessage().what).isEqualTo(5); // SESSION_DEINIT
 
-        verifyZeroInteractions(mUwbAdvertiseManager);
+        verifyNoMoreInteractions(mUwbAdvertiseManager);
     }
 
     @Test
@@ -5424,7 +5438,7 @@ public class UwbSessionManagerTest {
         assertThat(mUwbSessionManager.getAliroSessionCount()).isEqualTo(0L);
         assertThat(mUwbSessionManager.getCccSessionCount()).isEqualTo(0L);
         assertThat(mUwbSessionManager.getFiraSessionCount()).isEqualTo(0L);
-        verifyZeroInteractions(mUwbAdvertiseManager);
+        verifyNoMoreInteractions(mUwbAdvertiseManager);
     }
 
     @Test
@@ -5445,7 +5459,7 @@ public class UwbSessionManagerTest {
         assertThat(mUwbSessionManager.getAliroSessionCount()).isEqualTo(0L);
         assertThat(mUwbSessionManager.getCccSessionCount()).isEqualTo(0L);
         assertThat(mUwbSessionManager.getFiraSessionCount()).isEqualTo(0L);
-        verifyZeroInteractions(mUwbAdvertiseManager);
+        verifyNoMoreInteractions(mUwbAdvertiseManager);
     }
 
     @Test
@@ -5471,7 +5485,7 @@ public class UwbSessionManagerTest {
         assertThat(mUwbSessionManager.getAliroSessionCount()).isEqualTo(0L);
         assertThat(mUwbSessionManager.getCccSessionCount()).isEqualTo(0L);
         assertThat(mUwbSessionManager.getFiraSessionCount()).isEqualTo(0L);
-        verifyZeroInteractions(mUwbAdvertiseManager);
+        verifyNoMoreInteractions(mUwbAdvertiseManager);
     }
 
     @Test
diff --git a/service/tests/src/com/android/server/uwb/UwbSessionNotificationManagerTest.java b/service/tests/src/com/android/server/uwb/UwbSessionNotificationManagerTest.java
index 2e4bd914..8aff124e 100644
--- a/service/tests/src/com/android/server/uwb/UwbSessionNotificationManagerTest.java
+++ b/service/tests/src/com/android/server/uwb/UwbSessionNotificationManagerTest.java
@@ -29,7 +29,6 @@ import static com.android.server.uwb.data.UwbUciConstants.STATUS_CODE_FAILED;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.uwb.support.radar.RadarParams.RADAR_DATA_TYPE_RADAR_SWEEP_SAMPLES;
 
-import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.isA;
@@ -38,7 +37,7 @@ import static org.mockito.Mockito.clearInvocations;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.validateMockitoUsage;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import android.content.AttributionSource;
@@ -163,7 +162,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
 
         verify(mIUwbRangingCallbacks, never()).onRangingResult(any(), any());
-        verify(mUwbMetrics, never()).logRangingResult(anyInt(), any(), any());
+        verify(mUwbMetrics, never()).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), any(), any());
     }
 
     @Test
@@ -177,7 +177,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -194,7 +195,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -211,7 +213,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -228,7 +231,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -250,7 +254,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -272,7 +277,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -294,7 +300,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -316,7 +323,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -338,7 +346,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -360,7 +369,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -375,7 +385,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -390,7 +401,8 @@ public class UwbSessionNotificationManagerTest {
                 mUwbSession, testRangingDataAndRangingReport.first);
         verify(mIUwbRangingCallbacks).onRangingResult(
                 mSessionHandle, testRangingDataAndRangingReport.second);
-        verify(mUwbMetrics).logRangingResult(anyInt(), eq(testRangingDataAndRangingReport.first),
+        verify(mUwbMetrics).logRangingResult(
+                any(UwbSessionManager.UwbSession.class), eq(testRangingDataAndRangingReport.first),
                 eq(testRangingDataAndRangingReport.second.getMeasurements().get(0)));
     }
 
@@ -399,7 +411,7 @@ public class UwbSessionNotificationManagerTest {
         UwbRangingData testRangingData = UwbTestUtils.generateBadOwrAoaMeasurementRangingData(
                 MAC_ADDRESSING_MODE_SHORT, PEER_SHORT_MAC_ADDRESS);
         mUwbSessionNotificationManager.onRangingResult(mUwbSession, testRangingData);
-        verifyZeroInteractions(mIUwbRangingCallbacks);
+        verifyNoMoreInteractions(mIUwbRangingCallbacks);
     }
 
     @Test
diff --git a/service/tests/src/com/android/server/uwb/data/UwbRangingDataTest.java b/service/tests/src/com/android/server/uwb/data/UwbRangingDataTest.java
index 274af6ec..3f77d9d9 100644
--- a/service/tests/src/com/android/server/uwb/data/UwbRangingDataTest.java
+++ b/service/tests/src/com/android/server/uwb/data/UwbRangingDataTest.java
@@ -50,6 +50,7 @@ public class UwbRangingDataTest {
     private static final long TEST_CURR_RANGING_INTERVAL = 100;
     private static final int TEST_MAC_ADDRESS_MODE = 1;
     private static final byte[] TEST_MAC_ADDRESS = {0x1, 0x3};
+    private static final long TEST_HUS_PRIMARY_SESSION_ID = 0;
     private static final int TEST_STATUS = FiraParams.STATUS_CODE_OK;
     private static final int TEST_MESSAGE_TYPE = 1;
     private static final int TEST_MESSAGE_CONTROL = 1331;
@@ -103,14 +104,15 @@ public class UwbRangingDataTest {
                 TEST_AOA_DEST_ELEVATION_FOM, TEST_SLOT_IDX, TEST_RSSI);
         mUwbRangingData = new UwbRangingData(TEST_SEQ_COUNTER, TEST_SESSION_ID,
                 TEST_RCR_INDICATION, TEST_CURR_RANGING_INTERVAL, rangingMeasuresType,
-                TEST_MAC_ADDRESS_MODE, noOfRangingMeasures, uwbTwoWayMeasurements,
-                TEST_RAW_NTF_DATA);
+                TEST_HUS_PRIMARY_SESSION_ID, TEST_MAC_ADDRESS_MODE, noOfRangingMeasures,
+                uwbTwoWayMeasurements, TEST_RAW_NTF_DATA);
 
         assertThat(mUwbRangingData.getSequenceCounter()).isEqualTo(TEST_SEQ_COUNTER);
         assertThat(mUwbRangingData.getSessionId()).isEqualTo(TEST_SESSION_ID);
         assertThat(mUwbRangingData.getRcrIndication()).isEqualTo(TEST_RCR_INDICATION);
         assertThat(mUwbRangingData.getCurrRangingInterval()).isEqualTo(TEST_CURR_RANGING_INTERVAL);
         assertThat(mUwbRangingData.getRangingMeasuresType()).isEqualTo(rangingMeasuresType);
+        assertThat(mUwbRangingData.getHusPrimarySessionId()).isEqualTo(TEST_HUS_PRIMARY_SESSION_ID);
         assertThat(mUwbRangingData.getMacAddressMode()).isEqualTo(TEST_MAC_ADDRESS_MODE);
         assertThat(mUwbRangingData.getNoOfRangingMeasures()).isEqualTo(1);
         assertThat(mUwbRangingData.getRawNtfData()).isEqualTo(TEST_RAW_NTF_DATA);
@@ -121,6 +123,7 @@ public class UwbRangingDataTest {
                 + ", RcrIndication = " + TEST_RCR_INDICATION
                 + ", CurrRangingInterval = " + TEST_CURR_RANGING_INTERVAL
                 + ", RangingMeasuresType = " + rangingMeasuresType
+                + ", HusPrimarySessionId = " + TEST_HUS_PRIMARY_SESSION_ID
                 + ", MacAddressMode = " + TEST_MAC_ADDRESS_MODE
                 + ", NoOfRangingMeasures = " + noOfRangingMeasures
                 + ", RangingTwoWayMeasures = " + Arrays.toString(uwbTwoWayMeasurements)
@@ -140,14 +143,15 @@ public class UwbRangingDataTest {
         final int rangingMeasuresType = RANGING_MEASUREMENT_TYPE_OWR_AOA;
         mUwbRangingData = new UwbRangingData(TEST_SEQ_COUNTER, TEST_SESSION_ID,
                 TEST_RCR_INDICATION, TEST_CURR_RANGING_INTERVAL, rangingMeasuresType,
-                TEST_MAC_ADDRESS_MODE, noOfRangingMeasures, uwbOwrAoaMeasurement,
-                TEST_RAW_NTF_DATA);
+                TEST_HUS_PRIMARY_SESSION_ID, TEST_MAC_ADDRESS_MODE, noOfRangingMeasures,
+                uwbOwrAoaMeasurement, TEST_RAW_NTF_DATA);
 
         assertThat(mUwbRangingData.getSequenceCounter()).isEqualTo(TEST_SEQ_COUNTER);
         assertThat(mUwbRangingData.getSessionId()).isEqualTo(TEST_SESSION_ID);
         assertThat(mUwbRangingData.getRcrIndication()).isEqualTo(TEST_RCR_INDICATION);
         assertThat(mUwbRangingData.getCurrRangingInterval()).isEqualTo(TEST_CURR_RANGING_INTERVAL);
         assertThat(mUwbRangingData.getRangingMeasuresType()).isEqualTo(rangingMeasuresType);
+        assertThat(mUwbRangingData.getHusPrimarySessionId()).isEqualTo(TEST_HUS_PRIMARY_SESSION_ID);
         assertThat(mUwbRangingData.getMacAddressMode()).isEqualTo(TEST_MAC_ADDRESS_MODE);
         assertThat(mUwbRangingData.getNoOfRangingMeasures()).isEqualTo(1);
         assertThat(mUwbRangingData.getRawNtfData()).isEqualTo(TEST_RAW_NTF_DATA);
@@ -158,6 +162,7 @@ public class UwbRangingDataTest {
                 + ", RcrIndication = " + TEST_RCR_INDICATION
                 + ", CurrRangingInterval = " + TEST_CURR_RANGING_INTERVAL
                 + ", RangingMeasuresType = " + rangingMeasuresType
+                + ", HusPrimarySessionId = " + TEST_HUS_PRIMARY_SESSION_ID
                 + ", MacAddressMode = " + TEST_MAC_ADDRESS_MODE
                 + ", NoOfRangingMeasures = " + noOfRangingMeasures
                 + ", RangingOwrAoaMeasure = " + uwbOwrAoaMeasurement.toString()
@@ -184,14 +189,15 @@ public class UwbRangingDataTest {
         final int rangingMeasuresType = RANGING_MEASUREMENT_TYPE_DL_TDOA;
         mUwbRangingData = new UwbRangingData(TEST_SEQ_COUNTER, TEST_SESSION_ID,
                 TEST_RCR_INDICATION, TEST_CURR_RANGING_INTERVAL, rangingMeasuresType,
-                TEST_MAC_ADDRESS_MODE, noOfRangingMeasures, uwbDlTDoAMeasurements,
-                TEST_RAW_NTF_DATA);
+                TEST_HUS_PRIMARY_SESSION_ID, TEST_MAC_ADDRESS_MODE, noOfRangingMeasures,
+                uwbDlTDoAMeasurements, TEST_RAW_NTF_DATA);
 
         assertThat(mUwbRangingData.getSequenceCounter()).isEqualTo(TEST_SEQ_COUNTER);
         assertThat(mUwbRangingData.getSessionId()).isEqualTo(TEST_SESSION_ID);
         assertThat(mUwbRangingData.getRcrIndication()).isEqualTo(TEST_RCR_INDICATION);
         assertThat(mUwbRangingData.getCurrRangingInterval()).isEqualTo(TEST_CURR_RANGING_INTERVAL);
         assertThat(mUwbRangingData.getRangingMeasuresType()).isEqualTo(rangingMeasuresType);
+        assertThat(mUwbRangingData.getHusPrimarySessionId()).isEqualTo(TEST_HUS_PRIMARY_SESSION_ID);
         assertThat(mUwbRangingData.getMacAddressMode()).isEqualTo(TEST_MAC_ADDRESS_MODE);
         assertThat(mUwbRangingData.getNoOfRangingMeasures()).isEqualTo(1);
         assertThat(mUwbRangingData.getRawNtfData()).isEqualTo(TEST_RAW_NTF_DATA);
@@ -204,6 +210,7 @@ public class UwbRangingDataTest {
                 + ", RcrIndication = " + TEST_RCR_INDICATION
                 + ", CurrRangingInterval = " + TEST_CURR_RANGING_INTERVAL
                 + ", RangingMeasuresType = " + rangingMeasuresType
+                + ", HusPrimarySessionId = " + TEST_HUS_PRIMARY_SESSION_ID
                 + ", MacAddressMode = " + TEST_MAC_ADDRESS_MODE
                 + ", NoOfRangingMeasures = " + noOfRangingMeasures
                 + ", RangingDlTDoAMeasure = " + Arrays.toString(uwbDlTDoAMeasurements)
diff --git a/service/tests/src/com/android/server/uwb/discovery/TransportProviderTest.java b/service/tests/src/com/android/server/uwb/discovery/TransportProviderTest.java
index abeda6c5..275a5d20 100644
--- a/service/tests/src/com/android/server/uwb/discovery/TransportProviderTest.java
+++ b/service/tests/src/com/android/server/uwb/discovery/TransportProviderTest.java
@@ -23,7 +23,6 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 
 import androidx.test.filters.SmallTest;
 import androidx.test.runner.AndroidJUnit4;
@@ -133,13 +132,13 @@ public class TransportProviderTest {
         mTransportProvider.onMessageReceived(SECID, MESSAGE);
 
         verify(mMockDataReceiver, times(1)).onDataReceived(MESSAGE_PAYLOAD);
-        verifyZeroInteractions(mMockDataReceiver2);
+        verifyNoMoreInteractions(mMockDataReceiver2);
 
         mTransportProvider.unregisterDataReceiver();
         mTransportProvider.onMessageReceived(SECID, MESSAGE);
 
         verifyNoMoreInteractions(mMockDataReceiver);
-        verifyZeroInteractions(mMockDataReceiver2);
+        verifyNoMoreInteractions(mMockDataReceiver2);
 
         mTransportProvider.registerDataReceiver(mMockDataReceiver2);
         mTransportProvider.onMessageReceived(SECID, MESSAGE);
@@ -183,7 +182,7 @@ public class TransportProviderTest {
         mTransportProvider.registerDataReceiver(mMockDataReceiver);
         mTransportProvider.onMessageReceived(SECID2, MESSAGE);
 
-        verifyZeroInteractions(mMockDataReceiver);
+        verifyNoMoreInteractions(mMockDataReceiver);
     }
 
     private void verifyAdminErrorMessageReceive(ErrorType errorType, TerminationReason reason) {
diff --git a/service/tests/src/com/android/server/uwb/discovery/ble/BleDiscoveryAdvertiseProviderTest.java b/service/tests/src/com/android/server/uwb/discovery/ble/BleDiscoveryAdvertiseProviderTest.java
index d2b27f43..ed0fa86d 100644
--- a/service/tests/src/com/android/server/uwb/discovery/ble/BleDiscoveryAdvertiseProviderTest.java
+++ b/service/tests/src/com/android/server/uwb/discovery/ble/BleDiscoveryAdvertiseProviderTest.java
@@ -24,7 +24,7 @@ import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import android.bluetooth.BluetoothAdapter;
@@ -213,13 +213,13 @@ public class BleDiscoveryAdvertiseProviderTest {
     @Test
     public void teststartAdvertisingSet_success() {
         teststartAdvertisingSet(AdvertisingSetCallback.ADVERTISE_SUCCESS);
-        verifyZeroInteractions(mMockDiscoveryAdvertiseCallback);
+        verifyNoMoreInteractions(mMockDiscoveryAdvertiseCallback);
     }
 
     @Test
     public void teststartAdvertisingSet_failedAlreadyStarted() {
         teststartAdvertisingSet(AdvertisingSetCallback.ADVERTISE_FAILED_ALREADY_STARTED);
-        verifyZeroInteractions(mMockDiscoveryAdvertiseCallback);
+        verifyNoMoreInteractions(mMockDiscoveryAdvertiseCallback);
     }
 
     @Test
@@ -261,7 +261,7 @@ public class BleDiscoveryAdvertiseProviderTest {
     @Test
     public void testStopAdvertise_failedBTUnavailable() {
         teststartAdvertisingSet(AdvertisingSetCallback.ADVERTISE_SUCCESS);
-        verifyZeroInteractions(mMockDiscoveryAdvertiseCallback);
+        verifyNoMoreInteractions(mMockDiscoveryAdvertiseCallback);
 
         when(mMockBluetoothManager.getAdapter()).thenReturn(null);
 
@@ -273,7 +273,7 @@ public class BleDiscoveryAdvertiseProviderTest {
     @Test
     public void testStopAdvertise_failedBTDisabled() {
         teststartAdvertisingSet(AdvertisingSetCallback.ADVERTISE_SUCCESS);
-        verifyZeroInteractions(mMockDiscoveryAdvertiseCallback);
+        verifyNoMoreInteractions(mMockDiscoveryAdvertiseCallback);
 
         when(mMockBluetoothManager.getAdapter()).thenReturn(mMockBluetoothAdapter);
         when(mMockBluetoothAdapter.getBluetoothLeAdvertiser()).thenReturn(null);
@@ -286,7 +286,7 @@ public class BleDiscoveryAdvertiseProviderTest {
     @Test
     public void testStopAdvertise_success() {
         teststartAdvertisingSet(AdvertisingSetCallback.ADVERTISE_SUCCESS);
-        verifyZeroInteractions(mMockDiscoveryAdvertiseCallback);
+        verifyNoMoreInteractions(mMockDiscoveryAdvertiseCallback);
 
         assertThat(mBleDiscoveryAdvertiseProvider.stop()).isTrue();
         verify(mMockBluetoothLeAdvertiser, times(1))
diff --git a/service/tests/src/com/android/server/uwb/discovery/ble/BleDiscoveryScanProviderTest.java b/service/tests/src/com/android/server/uwb/discovery/ble/BleDiscoveryScanProviderTest.java
index 421fc423..a9a8862b 100644
--- a/service/tests/src/com/android/server/uwb/discovery/ble/BleDiscoveryScanProviderTest.java
+++ b/service/tests/src/com/android/server/uwb/discovery/ble/BleDiscoveryScanProviderTest.java
@@ -24,7 +24,7 @@ import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import android.bluetooth.BluetoothAdapter;
@@ -223,7 +223,7 @@ public class BleDiscoveryScanProviderTest {
 
         assertThat(mBleDiscoveryScanProvider.start()).isTrue();
         verify(mMockBluetoothLeScanner, times(1)).startScan(any(), any(), any(ScanCallback.class));
-        verifyZeroInteractions(mMockDiscoveryScanCallback);
+        verifyNoMoreInteractions(mMockDiscoveryScanCallback);
     }
 
     private static ScanRecord parseScanRecord(byte[] bytes) {
@@ -287,7 +287,7 @@ public class BleDiscoveryScanProviderTest {
 
         testBleScanResult(scanResult);
         verify(mMockBluetoothLeScanner, times(1)).startScan(any(), any(), any(ScanCallback.class));
-        verifyZeroInteractions(mMockDiscoveryScanCallback);
+        verifyNoMoreInteractions(mMockDiscoveryScanCallback);
     }
 
     @Test
@@ -327,7 +327,7 @@ public class BleDiscoveryScanProviderTest {
 
         testBleScanResult(scanResult);
         verify(mMockBluetoothLeScanner, times(1)).startScan(any(), any(), any(ScanCallback.class));
-        verifyZeroInteractions(mMockDiscoveryScanCallback);
+        verifyNoMoreInteractions(mMockDiscoveryScanCallback);
     }
 
     @Test
@@ -367,7 +367,7 @@ public class BleDiscoveryScanProviderTest {
                         /*timestampNanos=*/ 0);
         testBleScanResult(scanResult);
         verify(mMockBluetoothLeScanner, times(1)).startScan(any(), any(), any(ScanCallback.class));
-        verifyZeroInteractions(mMockDiscoveryScanCallback);
+        verifyNoMoreInteractions(mMockDiscoveryScanCallback);
     }
 
     @Test
diff --git a/service/tests/src/com/android/server/uwb/discovery/ble/GattTransportClientProviderTest.java b/service/tests/src/com/android/server/uwb/discovery/ble/GattTransportClientProviderTest.java
index b04844a0..81687b1e 100644
--- a/service/tests/src/com/android/server/uwb/discovery/ble/GattTransportClientProviderTest.java
+++ b/service/tests/src/com/android/server/uwb/discovery/ble/GattTransportClientProviderTest.java
@@ -29,7 +29,6 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 import android.bluetooth.BluetoothDevice;
@@ -323,7 +322,7 @@ public class GattTransportClientProviderTest {
         assertThat(mGattTransportClientProvider.start()).isTrue();
         verify(mMockBluetoothDevice, times(1)).connectGatt(any(), anyBoolean(), any(), anyInt());
         verify(mMockBluetoothGatt, times(1)).discoverServices();
-        verifyZeroInteractions(mMockTransportClientCallback);
+        verifyNoMoreInteractions(mMockTransportClientCallback);
     }
 
     @Test
diff --git a/service/tests/src/com/android/server/uwb/discovery/ble/GattTransportServerProviderTest.java b/service/tests/src/com/android/server/uwb/discovery/ble/GattTransportServerProviderTest.java
index 6116d600..5e39e1f4 100644
--- a/service/tests/src/com/android/server/uwb/discovery/ble/GattTransportServerProviderTest.java
+++ b/service/tests/src/com/android/server/uwb/discovery/ble/GattTransportServerProviderTest.java
@@ -26,7 +26,7 @@ import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import android.bluetooth.BluetoothAdapter;
@@ -314,8 +314,8 @@ public class GattTransportServerProviderTest {
                         BluetoothGattCharacteristic.PROPERTY_READ,
                         BluetoothGattCharacteristic.PERMISSION_READ));
 
-        verifyZeroInteractions(mMockBluetoothGattServer);
-        verifyZeroInteractions(mMockTransportServerCallback);
+        verifyNoMoreInteractions(mMockBluetoothGattServer);
+        verifyNoMoreInteractions(mMockTransportServerCallback);
     }
 
     private void setupOutCharactersticRead() {
@@ -441,8 +441,8 @@ public class GattTransportServerProviderTest {
                 /*responseNeeded=*/ true,
                 /*offset=*/ 0,
                 DATA_PACKET.toBytes());
-        verifyZeroInteractions(mMockBluetoothGattServer);
-        verifyZeroInteractions(mMockTransportServerCallback);
+        verifyNoMoreInteractions(mMockBluetoothGattServer);
+        verifyNoMoreInteractions(mMockTransportServerCallback);
     }
 
     @Test
@@ -463,7 +463,7 @@ public class GattTransportServerProviderTest {
                         BluetoothGatt.GATT_FAILURE,
                         /*offset=*/ 0,
                         /*value=*/ null);
-        verifyZeroInteractions(mMockTransportServerCallback);
+        verifyNoMoreInteractions(mMockTransportServerCallback);
     }
 
     @Test
diff --git a/service/tests/src/com/android/server/uwb/params/AliroDecoderTest.java b/service/tests/src/com/android/server/uwb/params/AliroDecoderTest.java
index b4ff4bde..858abc52 100644
--- a/service/tests/src/com/android/server/uwb/params/AliroDecoderTest.java
+++ b/service/tests/src/com/android/server/uwb/params/AliroDecoderTest.java
@@ -75,7 +75,8 @@ public class AliroDecoderTest {
                     + "a60112"
                     + "a7040a000000"
                     + "a80401000000"
-                    + "a90401000000";
+                    + "a90401000000"
+                    + "ac0400000000";
 
     public static final String TEST_ALIRO_SPECIFICATION_TLV_DATA_STRING_PRIORITIZED_CHANNELS =
             "a00111"
@@ -88,7 +89,8 @@ public class AliroDecoderTest {
                     + "a7040a000000"
                     + "a80401000000"
                     + "a90401000000"
-                    + "aa020509";
+                    + "aa020509"
+                    + "ac0400000000";
 
     private static final String TEST_ALIRO_SPECIFICATION_TLV_DATA_STRING_UWBS_MAX_PPM =
             "a00111"
@@ -101,7 +103,8 @@ public class AliroDecoderTest {
                     + "a7040a000000"
                     + "a80401000000"
                     + "a90401000000"
-                    + "ab02012f";
+                    + "ab02012f"
+                    + "ac0400000000";
 
     private static final byte[] TEST_ALIRO_SPECIFICATION_TLV_DATA =
             UwbUtil.getByteArray(TEST_ALIRO_SPECIFICATION_TLV_DATA_STRING);
@@ -111,8 +114,8 @@ public class AliroDecoderTest {
     private static final byte[] TEST_ALIRO_SPECIFICATION_TLV_DATA_UWBS_MAX_PPM =
             UwbUtil.getByteArray(TEST_ALIRO_SPECIFICATION_TLV_DATA_STRING_UWBS_MAX_PPM);
 
-    public static final int TEST_ALIRO_SPECIFICATION_TLV_NUM_PARAMS = 10;
-    public static final int TEST_ALIRO_SPECIFICATION_TLV_DATA_UWBS_MAX_PPM_NUM_PARAMS = 11;
+    public static final int TEST_ALIRO_SPECIFICATION_TLV_NUM_PARAMS = 11;
+    public static final int TEST_ALIRO_SPECIFICATION_TLV_DATA_UWBS_MAX_PPM_NUM_PARAMS = 12;
 
     @Mock
     private UwbInjector mUwbInjector;
diff --git a/service/tests/src/com/android/server/uwb/params/AliroEncoderTest.java b/service/tests/src/com/android/server/uwb/params/AliroEncoderTest.java
index f02aa766..24983c8d 100644
--- a/service/tests/src/com/android/server/uwb/params/AliroEncoderTest.java
+++ b/service/tests/src/com/android/server/uwb/params/AliroEncoderTest.java
@@ -71,7 +71,11 @@ public class AliroEncoderTest {
                     .setSyncCodeIndex(1)
                     .setHoppingConfigMode(HOPPING_CONFIG_MODE_NONE)
                     .setHoppingSequence(HOPPING_SEQUENCE_DEFAULT)
-                    .setInitiationTimeMs(1);
+                    .setInitiationTimeMs(1)
+                    .setMacModeRound(AliroParams.MAC_MODE_ROUND_1)
+                    .setMacModeOffset(0)
+                    .setSessionKey(new byte[]{0x5, 0x78, 0x5, 0x78, 0x5, 0x78, 0x5, 0x78, 0x5,
+                            0x78, 0x5, 0x78, 0x5, 0x78, 0x5, 0x78});
 
     private static final String RANGE_DATA_NTF_CONFIG_DISABLED_TLV = "0E0100";
     private static final String RANGE_DATA_NTF_CONFIG_ENABLED_TLV = "0E0101";
@@ -83,7 +87,7 @@ public class AliroEncoderTest {
     private static final String TEST_ALIRO_OPEN_RANGING_TLV =
             "00010102010104010905010109048001000011010103010"
                     + "11B01062C0100A3020001A4020000A50100A602D0020802B004140101"
-                    + "2B080100000000000000";
+                    + "A901004510057805780578057805780578057805782B080100000000000000";
     private static final String TEST_ALIRO_OPEN_RANGING_TLV_DEFAULT =
             TEST_ALIRO_OPEN_RANGING_TLV + RANGE_DATA_NTF_CONFIG_DISABLED_TLV;
     private static final byte[] TEST_ALIRO_OPEN_RANGING_TLV_DATA =
@@ -109,7 +113,7 @@ public class AliroEncoderTest {
         AliroOpenRangingParams params = TEST_ALIRO_OPEN_RANGING_PARAMS.build();
         TlvBuffer tlvs = mAliroEncoder.getTlvBuffer(params, AliroParams.PROTOCOL_VERSION_1_0);
 
-        assertThat(tlvs.getNoOfParams()).isEqualTo(17);
+        assertThat(tlvs.getNoOfParams()).isEqualTo(19);
         assertThat(tlvs.getByteArray()).isEqualTo(TEST_ALIRO_OPEN_RANGING_TLV_DATA);
     }
 
@@ -119,7 +123,7 @@ public class AliroEncoderTest {
         TlvBuffer tlvs = TlvEncoder.getEncoder(AliroParams.PROTOCOL_NAME, mUwbInjector)
                 .getTlvBuffer(params, AliroParams.PROTOCOL_VERSION_1_0);
 
-        assertThat(tlvs.getNoOfParams()).isEqualTo(17);
+        assertThat(tlvs.getNoOfParams()).isEqualTo(19);
         assertThat(tlvs.getByteArray()).isEqualTo(TEST_ALIRO_OPEN_RANGING_TLV_DATA);
     }
 
@@ -135,9 +139,9 @@ public class AliroEncoderTest {
         byte[] testAliroOpenRangingAbsoluteInitiationTimeTlvData =
                 UwbUtil.getByteArray("00010102010104010905010109048001000011010103010"
                         + "11B01062C0100A3020001A4020000A50100A602D0020802B004140101"
-                        + "2B0810270000000000000E0100");
+                        + "A901004510057805780578057805780578057805782B0810270000000000000E0100");
 
-        assertThat(tlvs.getNoOfParams()).isEqualTo(17);
+        assertThat(tlvs.getNoOfParams()).isEqualTo(19);
         assertThat(tlvs.getByteArray()).isEqualTo(
                 testAliroOpenRangingAbsoluteInitiationTimeTlvData);
     }
@@ -159,7 +163,7 @@ public class AliroEncoderTest {
                 + RANGE_DATA_NTF_PROXIMITY_NEAR_DEFAULT_TLV
                 + RANGE_DATA_NTF_PROXIMITY_FAR_DEFAULT_TLV;
 
-        assertThat(tlvs.getNoOfParams()).isEqualTo(19);
+        assertThat(tlvs.getNoOfParams()).isEqualTo(21);
         assertThat(tlvs.getByteArray()).isEqualTo(UwbUtil.getByteArray(expectedTlvStr));
     }
 
@@ -183,7 +187,7 @@ public class AliroEncoderTest {
                 + RANGE_DATA_NTF_PROXIMITY_NEAR_DEFAULT_TLV
                 + RANGE_DATA_NTF_PROXIMITY_FAR_DEFAULT_TLV;
 
-        assertThat(tlvs.getNoOfParams()).isEqualTo(19);
+        assertThat(tlvs.getNoOfParams()).isEqualTo(21);
         assertThat(tlvs.getByteArray()).isEqualTo(UwbUtil.getByteArray(expectedTlvStr));
     }
 
@@ -209,7 +213,7 @@ public class AliroEncoderTest {
                 + RANGE_DATA_NTF_PROXIMITY_NEAR_TLV
                 + RANGE_DATA_NTF_PROXIMITY_FAR_TLV;
 
-        assertThat(tlvs.getNoOfParams()).isEqualTo(19);
+        assertThat(tlvs.getNoOfParams()).isEqualTo(21);
         assertThat(tlvs.getByteArray()).isEqualTo(UwbUtil.getByteArray(expectedTlvStr));
     }
 }
diff --git a/service/tests/src/com/android/server/uwb/params/FiraEncoderTest.java b/service/tests/src/com/android/server/uwb/params/FiraEncoderTest.java
index 10d4ff5a..fa211811 100644
--- a/service/tests/src/com/android/server/uwb/params/FiraEncoderTest.java
+++ b/service/tests/src/com/android/server/uwb/params/FiraEncoderTest.java
@@ -252,14 +252,14 @@ public class FiraEncoderTest {
                     "01010102010003010004010906020604080260090B01000C01030D01010E01040F02"
                             + "00001002204E11010012010313010014010A1501021601001701011A01011B0119"
                             + "1F01002201012301002401002501322601002901012A0200002C01002D01002E"
-                            + "01012F0101310100320200003501010904C8000000000101050101070206042B0400"
+                            + "01012F0101320200003501013101000904C8000000000101050101070206042B0400"
                             + "0000001C01002702780528061A5577477E7D1D0807D59E4707D56022EA0100");
 
             mFiraOpenSessionTlvUtTag = UwbUtil.getByteArray(
                     "01010002010003010004010906020604080260090B01000C01030D01010E01010F02"
                             + "00001002204E11010412010313010014010A1501021601001701011A01011B0119"
                             + "1F01002201012301002401002501322601002901012A0200002C01002D01002E"
-                            + "01012F0101310100320200003501010001012B04000000001C0100270278"
+                            + "01012F0101320200003501013101000001012B04000000001C0100270278"
                             + "0528061A5577477E7D3304B004000034041E0000003803010B0A390101EA0100");
         } else {
             mFiraSessionv11TlvData = UwbUtil.getByteArray(RANGING_ROUND_USAGE_SS_TWR_TLV
@@ -275,8 +275,8 @@ public class FiraEncoderTest {
                     + KEY_ROTATION_TLV + KEY_ROTATION_RATE_TLV + SESSION_PRIORITY_TLV
                     + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV + MAX_RR_RETRY_TLV
                     + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV + RESULT_REPORT_CONFIG_TLV
-                    + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV + BPRF_PHR_DATA_RATE_TLV
-                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + RANGING_INTERVAL_TLV
+                    + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV
+                    + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV + RANGING_INTERVAL_TLV
                     + DEVICE_TYPE_CONTROLLER_TLV + NUMBER_OF_CONTROLEES_TLV + DST_MAC_ADDRESS_TLV
                     + UWB_INITIATION_TIME_TLV + TX_ADAPTIVE_PAYLOAD_POWER_TLV + VENDOR_ID_TLV
                     + STATIC_STS_IV_TLV + RANGE_DATA_NTF_AOA_BOUND_TLV + ANTENNA_MODE_TLV);
@@ -297,7 +297,7 @@ public class FiraEncoderTest {
                     + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                     + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                     + RANGING_INTERVAL_TLV + DEVICE_TYPE_CONTROLLER_TLV + NUMBER_OF_CONTROLEES_TLV
                     + DST_MAC_ADDRESS_TLV + UWB_INITIATION_TIME_2_0_TLV
                     + LINK_LAYER_MODE_CONNECTIONLESS_DATA_TLV
@@ -323,7 +323,7 @@ public class FiraEncoderTest {
                     + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                     + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                     + RANGING_INTERVAL_TLV + DEVICE_TYPE_CONTROLLER_TLV + NUMBER_OF_CONTROLEES_TLV
                     + DST_MAC_ADDRESS_TLV + ABSOLUTE_UWB_INITIATION_TIME_2_0_TLV
                     + LINK_LAYER_MODE_CONNECTIONLESS_DATA_TLV
@@ -348,7 +348,7 @@ public class FiraEncoderTest {
                     + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                     + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                     + DEVICE_TYPE_CONTROLLER_TLV
                     + UWB_INITIATION_TIME_TLV + TX_ADAPTIVE_PAYLOAD_POWER_TLV + VENDOR_ID_TLV
                     + STATIC_STS_IV_TLV + UL_TDOA_TX_INTERVAL_TLV + UL_TDOA_RANDOM_WINDOW_TLV
@@ -457,7 +457,7 @@ public class FiraEncoderTest {
                     "01010102010303010004010906020604080260090B01000C01030D01010E01040F02"
                             + "00001002204E11010012010313010014010A1501021601001701011A01011B0119"
                             + "1F01002201012301002401002501322601002901012A0200002C01002D01002E"
-                            + "01012F0101310100320200003501010904C8000000000101050101070206042B0400"
+                            + "01012F0101320200003501013101000904C8000000000101050101070206042B0400"
                             + "0000001C0100451005780578057805780578057805780578"
                             + "1D0807D59E4707D56022EA0100");
         } else {
@@ -475,7 +475,7 @@ public class FiraEncoderTest {
                     + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                     + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                     + RANGING_INTERVAL_TLV + DEVICE_TYPE_CONTROLLER_TLV + NUMBER_OF_CONTROLEES_TLV
                     + DST_MAC_ADDRESS_TLV + UWB_INITIATION_TIME_TLV + TX_ADAPTIVE_PAYLOAD_POWER_TLV
                     + SESSION_KEY_TLV + RANGE_DATA_NTF_AOA_BOUND_TLV + ANTENNA_MODE_TLV);
@@ -515,7 +515,7 @@ public class FiraEncoderTest {
                     "01010102010303010004010906020604080260090B01000C01030D01010E01040F02"
                             + "00001002204E11010012010313010014010A1501021601001701011A01011B0119"
                             + "1F01002201012301002401002501322601002901012A0200002C01002D01002E"
-                            + "01012F0101310100320200003501010904C8000000000101050101070206042B0400"
+                            + "01012F0101320200003501013101000904C8000000000101050101070206042B0400"
                             + "0000001C01001D0807D59E4707D56022EA0100");
         } else {
             expected_data = UwbUtil.getByteArray(RANGING_ROUND_USAGE_SS_TWR_TLV
@@ -532,7 +532,7 @@ public class FiraEncoderTest {
                     + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                     + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                     + RANGING_INTERVAL_TLV + DEVICE_TYPE_CONTROLLER_TLV + NUMBER_OF_CONTROLEES_TLV
                     + DST_MAC_ADDRESS_TLV + UWB_INITIATION_TIME_TLV + TX_ADAPTIVE_PAYLOAD_POWER_TLV
                     + RANGE_DATA_NTF_AOA_BOUND_TLV + ANTENNA_MODE_TLV);
@@ -574,7 +574,7 @@ public class FiraEncoderTest {
                     "01010102010203010004010906020604080260090B01000C01030D01010E01040F02"
                             + "00001002204E11010012010313010014010A1501021601001701011A01011B0119"
                             + "1F01002201012301002401002501322601002901012A0200002C01002D01002E"
-                            + "01012F0101310100320200003501010904C8000000000100050101070206042B0400"
+                            + "01012F0101320200003501013101000904C8000000000100050101070206042B0400"
                             + "0000001C01003004010000001D0807D59E4707D56022EA0100");
         } else {
             expected_data = UwbUtil.getByteArray(RANGING_ROUND_USAGE_SS_TWR_TLV
@@ -592,7 +592,7 @@ public class FiraEncoderTest {
                     + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                     + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                     + RANGING_INTERVAL_TLV + DEVICE_TYPE_CONTROLEE_TLV + NUMBER_OF_CONTROLEES_TLV
                     + DST_MAC_ADDRESS_TLV + UWB_INITIATION_TIME_TLV + TX_ADAPTIVE_PAYLOAD_POWER_TLV
                     + SUB_SESSION_ID_TLV + RANGE_DATA_NTF_AOA_BOUND_TLV + ANTENNA_MODE_TLV);
@@ -639,7 +639,7 @@ public class FiraEncoderTest {
                     "01010102010403010004010906020604080260090B01000C01030D01010E01040F02"
                             + "00001002204E11010012010313010014010A1501021601001701011A01011B0119"
                             + "1F01002201012301002401002501322601002901012A0200002C01002D01002E"
-                            + "01012F0101310100320200003501010904C8000000000100050101070206042B0400"
+                            + "01012F0101320200003501013101000904C8000000000100050101070206042B0400"
                             + "0000001C0100300401000000"
                             + "461006790679067906790679067906790679"
                             + "451005780578057805780578057805780578"
@@ -659,7 +659,7 @@ public class FiraEncoderTest {
                     + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                     + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                     + RANGING_INTERVAL_TLV + DEVICE_TYPE_CONTROLEE_TLV + NUMBER_OF_CONTROLEES_TLV
                     + DST_MAC_ADDRESS_TLV + UWB_INITIATION_TIME_TLV + TX_ADAPTIVE_PAYLOAD_POWER_TLV
                     + SUB_SESSION_ID_TLV + subsession_key + SESSION_KEY_TLV
@@ -702,7 +702,7 @@ public class FiraEncoderTest {
                     "01010102010403010004010906020604080260090B01000C01030D01010E01040F02"
                             + "00001002204E11010012010313010014010A1501021601001701011A01011B0119"
                             + "1F01002201012301002401002501322601002901012A0200002C01002D01002E"
-                            + "01012F0101310100320200003501010904C8000000000100050101070206042B0400"
+                            + "01012F0101320200003501013101000904C8000000000100050101070206042B0400"
                             + "0000001C01003004010000001D0807D59E4707D56022EA0100");
         } else {
             expected_data = UwbUtil.getByteArray(RANGING_ROUND_USAGE_SS_TWR_TLV
@@ -719,7 +719,7 @@ public class FiraEncoderTest {
                     + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                     + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                     + RANGING_INTERVAL_TLV + DEVICE_TYPE_CONTROLEE_TLV + NUMBER_OF_CONTROLEES_TLV
                     + DST_MAC_ADDRESS_TLV + UWB_INITIATION_TIME_TLV + TX_ADAPTIVE_PAYLOAD_POWER_TLV
                     + SUB_SESSION_ID_TLV
@@ -765,7 +765,7 @@ public class FiraEncoderTest {
                 + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                 + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                 + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                 + RANGING_INTERVAL_TLV + TX_ADAPTIVE_PAYLOAD_POWER_TLV
                 + VENDOR_ID_TLV + STATIC_STS_IV_TLV + ANTENNA_MODE_TLV);
 
@@ -811,7 +811,7 @@ public class FiraEncoderTest {
                 + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                 + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                 + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                 + RANGING_INTERVAL_TLV + DL_TDOA_BLOCK_STRIDING_TLV
                 + LINK_LAYER_MODE_BYPASS_TLV + DATA_REPETITION_COUNT_TLV
                 + SESSION_DATA_TRANSFER_STATUS_NTF_CONFIG_TLV
@@ -885,9 +885,9 @@ public class FiraEncoderTest {
                     + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV
                     + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV
                     + MAX_NUMBER_OF_MEASUREMENTS_TLV
                     + STS_LENGTH_TLV
+                    + BPRF_PHR_DATA_RATE_TLV
                     + RANGING_INTERVAL_TLV
                     + DEVICE_TYPE_CONTROLLER_TLV
                     + UWB_INITIATION_TIME_2_0_TLV
@@ -949,7 +949,7 @@ public class FiraEncoderTest {
                     + SESSION_PRIORITY_TLV + MAC_ADDRESS_MODE_TLV + NUMBER_OF_STS_SEGMENTS_TLV
                     + MAX_RR_RETRY_TLV + HOPPING_MODE_TLV + BLOCK_STRIDE_LENGTH_TLV
                     + RESULT_REPORT_CONFIG_TLV + IN_BAND_TERMINATION_ATTEMPT_COUNT_TLV
-                    + BPRF_PHR_DATA_RATE_TLV + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV
+                    + MAX_NUMBER_OF_MEASUREMENTS_TLV + STS_LENGTH_TLV + BPRF_PHR_DATA_RATE_TLV
                     + RANGING_INTERVAL_TLV + DEVICE_TYPE_CONTROLLER_TLV + NUMBER_OF_CONTROLEES_TLV
                     + DST_MAC_ADDRESS_TLV + UWB_INITIATION_TIME_2_0_TLV
                     + LINK_LAYER_MODE_BYPASS_TLV
diff --git a/service/tests/src/com/android/server/uwb/params/GenericDecoderTest.java b/service/tests/src/com/android/server/uwb/params/GenericDecoderTest.java
index e8092c01..6346b89a 100644
--- a/service/tests/src/com/android/server/uwb/params/GenericDecoderTest.java
+++ b/service/tests/src/com/android/server/uwb/params/GenericDecoderTest.java
@@ -16,8 +16,8 @@
 
 package com.android.server.uwb.params;
 
-import static com.android.server.uwb.params.CccDecoderTest.TEST_CCC_SPECIFICATION_TLV_DATA_STRING;
-import static com.android.server.uwb.params.CccDecoderTest.TEST_CCC_SPECIFICATION_TLV_NUM_PARAMS;
+import static com.android.server.uwb.params.AliroDecoderTest.TEST_ALIRO_SPECIFICATION_TLV_DATA_STRING;
+import static com.android.server.uwb.params.AliroDecoderTest.TEST_ALIRO_SPECIFICATION_TLV_NUM_PARAMS;
 import static com.android.server.uwb.params.FiraDecoderTest.TEST_FIRA_SPECIFICATION_TLV_NUM_PARAMS_VER_1;
 import static com.android.server.uwb.params.FiraDecoderTest.TEST_FIRA_SPECIFICATION_TLV_NUM_PARAMS_VER_2;
 import static com.android.server.uwb.params.FiraDecoderTest.TEST_FIRA_SPECIFICATION_TLV_STRING_VER_1;
@@ -57,11 +57,11 @@ public class GenericDecoderTest {
     private static final byte[] TEST_GENERIC_SPECIFICATION_TLV_DATA_VER_1 =
             UwbUtil.getByteArray("C00101" // SUPPORTED_POWER_STATS_QUERY
                             + TEST_FIRA_SPECIFICATION_TLV_STRING_VER_1
-                            + TEST_CCC_SPECIFICATION_TLV_DATA_STRING
+                            + TEST_ALIRO_SPECIFICATION_TLV_DATA_STRING
                             + TEST_RADAR_SPECIFICATION_TLV_DATA_STRING);
     private static final int TEST_GENERIC_SPECIFICATION_TLV_NUM_PARAMS_VER_1 = 1
                     + TEST_FIRA_SPECIFICATION_TLV_NUM_PARAMS_VER_1
-                    + TEST_CCC_SPECIFICATION_TLV_NUM_PARAMS
+                    + TEST_ALIRO_SPECIFICATION_TLV_NUM_PARAMS
                     + TEST_RADAR_SPECIFICATION_TLV_NUM_PARAMS;
 
     private static final byte[] TEST_GENERIC_SPECIFICATION_TLV_DATA_VER_2 =
@@ -69,11 +69,11 @@ public class GenericDecoderTest {
                             + "C10103" // ANTENNA MODE CAPABILITIES
                             + "EB0408000000" // MAX SUPPORTED SESSION COUNT
                             + FiraDecoderTest.TEST_FIRA_SPECIFICATION_TLV_STRING_VER_2
-                            + TEST_CCC_SPECIFICATION_TLV_DATA_STRING
+                            + TEST_ALIRO_SPECIFICATION_TLV_DATA_STRING
                             + TEST_RADAR_SPECIFICATION_TLV_DATA_STRING);
     private static final int TEST_GENERIC_SPECIFICATION_TLV_NUM_PARAMS_VER_2 = 3
             + TEST_FIRA_SPECIFICATION_TLV_NUM_PARAMS_VER_2
-            + TEST_CCC_SPECIFICATION_TLV_NUM_PARAMS
+            + TEST_ALIRO_SPECIFICATION_TLV_NUM_PARAMS
             + TEST_RADAR_SPECIFICATION_TLV_NUM_PARAMS;
 
     private static final int MAX_SUPPORTED_SESSION_COUNT = 8;
@@ -221,9 +221,9 @@ public class GenericDecoderTest {
         TlvDecoderBuffer tlvDecoderBuffer =
                 new TlvDecoderBuffer(
                         UwbUtil.getByteArray(
-                                TEST_CCC_SPECIFICATION_TLV_DATA_STRING
+                                TEST_ALIRO_SPECIFICATION_TLV_DATA_STRING
                                         + TEST_RADAR_SPECIFICATION_TLV_DATA_STRING),
-                        TEST_CCC_SPECIFICATION_TLV_NUM_PARAMS
+                        TEST_ALIRO_SPECIFICATION_TLV_NUM_PARAMS
                                 + TEST_RADAR_SPECIFICATION_TLV_NUM_PARAMS);
         assertThat(tlvDecoderBuffer.parse()).isTrue();
 
@@ -247,9 +247,9 @@ public class GenericDecoderTest {
                 new TlvDecoderBuffer(
                         UwbUtil.getByteArray(
                                 TEST_FIRA_SPECIFICATION_TLV_STRING_VER_1
-                                        + TEST_CCC_SPECIFICATION_TLV_DATA_STRING),
+                                        + TEST_ALIRO_SPECIFICATION_TLV_DATA_STRING),
                         TEST_FIRA_SPECIFICATION_TLV_NUM_PARAMS_VER_1
-                                + TEST_CCC_SPECIFICATION_TLV_NUM_PARAMS);
+                                + TEST_ALIRO_SPECIFICATION_TLV_NUM_PARAMS);
         assertThat(tlvDecoderBuffer.parse()).isTrue();
 
         GenericSpecificationParams genericSpecificationParams =
diff --git a/service/uci/jni/Android.bp b/service/uci/jni/Android.bp
index 74e9680f..b0561b52 100644
--- a/service/uci/jni/Android.bp
+++ b/service/uci/jni/Android.bp
@@ -23,6 +23,7 @@ rust_defaults {
     prefer_rlib: true,
     apex_available: [
         "com.android.uwb",
+        "//apex_available:platform",
     ],
 }
 
diff --git a/service/uci/jni/src/dispatcher.rs b/service/uci/jni/src/dispatcher.rs
index 44287ce0..4240fe76 100644
--- a/service/uci/jni/src/dispatcher.rs
+++ b/service/uci/jni/src/dispatcher.rs
@@ -151,7 +151,7 @@ pub(crate) struct GuardedUciManager<'a> {
     chip_id: String,
 }
 
-impl<'a> Deref for GuardedUciManager<'a> {
+impl Deref for GuardedUciManager<'_> {
     type Target = UciManagerSync<UciManagerImpl>;
     fn deref(&self) -> &Self::Target {
         // Unwrap GuardedUciManager will not panic since content is checked at creation.
@@ -189,7 +189,7 @@ impl<'a> GuardedDispatcher<'a> {
     }
 }
 
-impl<'a> Deref for GuardedDispatcher<'a> {
+impl Deref for GuardedDispatcher<'_> {
     type Target = Dispatcher;
     fn deref(&self) -> &Self::Target {
         // Unwrap GuardedDispatcher will not panic since content is checked at creation.
diff --git a/service/uci/jni/src/jclass_name.rs b/service/uci/jni/src/jclass_name.rs
index 1a228760..5e9282a0 100644
--- a/service/uci/jni/src/jclass_name.rs
+++ b/service/uci/jni/src/jclass_name.rs
@@ -34,3 +34,4 @@ pub(crate) const UWB_RADAR_DATA_CLASS: &str = "com/android/server/uwb/data/UwbRa
 pub(crate) const UWB_RADAR_SWEEP_DATA_CLASS: &str = "com/android/server/uwb/data/UwbRadarSweepData";
 pub(crate) const RFTEST_PERIODIC_TX_CLASS: &str =
     "com/android/server/uwb/rftest/UwbTestPeriodicTxResult";
+pub(crate) const RFTEST_PER_RX_CLASS: &str = "com/android/server/uwb/rftest/UwbTestPerRxResult";
diff --git a/service/uci/jni/src/notification_manager_android.rs b/service/uci/jni/src/notification_manager_android.rs
index 9d33547d..63eb5fbf 100644
--- a/service/uci/jni/src/notification_manager_android.rs
+++ b/service/uci/jni/src/notification_manager_android.rs
@@ -15,9 +15,9 @@
 //! Implementation of NotificationManagerAndroid and its builder.
 
 use crate::jclass_name::{
-    MULTICAST_LIST_UPDATE_STATUS_CLASS, RFTEST_PERIODIC_TX_CLASS, UWB_DL_TDOA_MEASUREMENT_CLASS,
-    UWB_OWR_AOA_MEASUREMENT_CLASS, UWB_RADAR_DATA_CLASS, UWB_RADAR_SWEEP_DATA_CLASS,
-    UWB_RANGING_DATA_CLASS, UWB_TWO_WAY_MEASUREMENT_CLASS,
+    MULTICAST_LIST_UPDATE_STATUS_CLASS, RFTEST_PERIODIC_TX_CLASS, RFTEST_PER_RX_CLASS,
+    UWB_DL_TDOA_MEASUREMENT_CLASS, UWB_OWR_AOA_MEASUREMENT_CLASS, UWB_RADAR_DATA_CLASS,
+    UWB_RADAR_SWEEP_DATA_CLASS, UWB_RANGING_DATA_CLASS, UWB_TWO_WAY_MEASUREMENT_CLASS,
 };
 
 use std::collections::HashMap;
@@ -34,7 +34,7 @@ use uwb_core::params::{ControleeStatusList, UwbAddress};
 use uwb_core::uci::uci_manager_sync::{NotificationManager, NotificationManagerBuilder};
 use uwb_core::uci::{
     CoreNotification, DataRcvNotification, RadarDataRcvNotification, RangingMeasurements,
-    RfTestNotification, SessionNotification, SessionRangeData,
+    RfTestNotification, RfTestPerRxData, SessionNotification, SessionRangeData,
 };
 use uwb_uci_packets::{
     radar_bytes_per_sample_value, ExtendedAddressDlTdoaRangingMeasurement,
@@ -637,7 +637,7 @@ impl NotificationManagerAndroid {
             UWB_RANGING_DATA_CLASS,
         )?;
 
-        let method_sig = "(JJIJIII[L".to_owned() + UWB_DL_TDOA_MEASUREMENT_CLASS + ";[B)V";
+        let method_sig = "(JJIJIJII[L".to_owned() + UWB_DL_TDOA_MEASUREMENT_CLASS + ";[B)V";
 
         // Safety: measurements_jobjectarray is safely instantiated above.
         let measurements_jobject = unsafe { JObject::from_raw(measurements_jobjectarray) };
@@ -656,6 +656,7 @@ impl NotificationManagerAndroid {
                     JValue::Int(range_data.rcr_indicator as i32),
                     JValue::Long(range_data.current_ranging_interval_ms as i64),
                     JValue::Int(range_data.ranging_measurement_type as i32),
+                    JValue::Long(range_data.hus_primary_session_id as i64),
                     JValue::Int(mac_indicator as i32),
                     JValue::Int(measurement_count),
                     JValue::Object(measurements_jobject),
@@ -847,7 +848,7 @@ impl NotificationManagerAndroid {
             &self.env,
             UWB_RANGING_DATA_CLASS,
         )?;
-        let method_sig = "(JJIJIIIL".to_owned() + UWB_OWR_AOA_MEASUREMENT_CLASS + ";[B)V";
+        let method_sig = "(JJIJIJIIL".to_owned() + UWB_OWR_AOA_MEASUREMENT_CLASS + ";[B)V";
 
         // Safety: raw_notification_jobject is safely instantiated above.
         let raw_notification_jobject = unsafe { JObject::from_raw(raw_notification_jbytearray) };
@@ -864,6 +865,7 @@ impl NotificationManagerAndroid {
                     JValue::Int(range_data.rcr_indicator as i32),
                     JValue::Long(range_data.current_ranging_interval_ms as i64),
                     JValue::Int(range_data.ranging_measurement_type as i32),
+                    JValue::Long(range_data.hus_primary_session_id as i64),
                     JValue::Int(mac_indicator as i32),
                     JValue::Int(1), // measurement_count
                     JValue::Object(measurement_jobject),
@@ -939,7 +941,7 @@ impl NotificationManagerAndroid {
             &self.env,
             UWB_RANGING_DATA_CLASS,
         )?;
-        let method_sig = "(JJIJIII[L".to_owned() + UWB_TWO_WAY_MEASUREMENT_CLASS + ";[B)V";
+        let method_sig = "(JJIJIJII[L".to_owned() + UWB_TWO_WAY_MEASUREMENT_CLASS + ";[B)V";
 
         // Safety: measurements_jobjectarray is safely instantiated above.
         let measurements_jobject = unsafe { JObject::from_raw(measurements_jobjectarray) };
@@ -957,6 +959,7 @@ impl NotificationManagerAndroid {
                     JValue::Int(range_data.rcr_indicator as i32),
                     JValue::Long(range_data.current_ranging_interval_ms as i64),
                     JValue::Int(range_data.ranging_measurement_type as i32),
+                    JValue::Long(range_data.hus_primary_session_id as i64),
                     JValue::Int(mac_indicator as i32),
                     JValue::Int(measurement_count),
                     JValue::Object(measurements_jobject),
@@ -1037,6 +1040,51 @@ impl NotificationManagerAndroid {
             &[jvalue::from(JValue::Object(periodic_tx_jobject))],
         )
     }
+
+    fn on_rf_per_rx_notification(
+        &mut self,
+        per_rx_data: RfTestPerRxData,
+    ) -> Result<JObject, JNIError> {
+        let raw_notification_jbytearray =
+            self.env.byte_array_from_slice(&per_rx_data.raw_notification_data)?;
+        // Safety: raw_notification_jbytearray safely instantiated above.
+        let raw_notification_jobject = unsafe { JObject::from_raw(raw_notification_jbytearray) };
+
+        let per_rx_jclass = NotificationManagerAndroid::find_local_class(
+            &mut self.jclass_map,
+            &self.class_loader_obj,
+            &self.env,
+            RFTEST_PER_RX_CLASS,
+        )?;
+        let method_sig = "(L".to_owned() + RFTEST_PER_RX_CLASS + ";)V";
+
+        let per_rx_jobject = self.env.new_object(
+            per_rx_jclass,
+            "(IJJJJJJJJJJJJJ[B)V",
+            &[
+                JValue::Int(i32::from(per_rx_data.status)),
+                JValue::Long(per_rx_data.attempts as i64),
+                JValue::Long(per_rx_data.acq_detect as i64),
+                JValue::Long(per_rx_data.acq_reject as i64),
+                JValue::Long(per_rx_data.rx_fail as i64),
+                JValue::Long(per_rx_data.sync_cir_ready as i64),
+                JValue::Long(per_rx_data.sfd_fail as i64),
+                JValue::Long(per_rx_data.sfd_found as i64),
+                JValue::Long(per_rx_data.phr_dec_error as i64),
+                JValue::Long(per_rx_data.phr_bit_error as i64),
+                JValue::Long(per_rx_data.psdu_dec_error as i64),
+                JValue::Long(per_rx_data.psdu_bit_error as i64),
+                JValue::Long(per_rx_data.sts_found as i64),
+                JValue::Long(per_rx_data.eof as i64),
+                JValue::Object(raw_notification_jobject),
+            ],
+        )?;
+        self.cached_jni_call(
+            "onPerRxDataNotificationReceived",
+            &method_sig,
+            &[jvalue::from(JValue::Object(per_rx_jobject))],
+        )
+    }
 }
 
 impl NotificationManager for NotificationManagerAndroid {
@@ -1402,6 +1450,9 @@ impl NotificationManager for NotificationManagerAndroid {
             RfTestNotification::TestPeriodicTxNtf { status, raw_notification_data } => {
                 self.on_rf_periodic_tx_notification(u8::from(status), &raw_notification_data)
             }
+            RfTestNotification::TestPerRxNtf(per_rx_data) => {
+                self.on_rf_per_rx_notification(per_rx_data)
+            }
         })
         .map_err(|e| {
             error!("on_rf_test_notification error: {:?}", e);
diff --git a/service/uci/jni/src/uci_jni_android_new.rs b/service/uci/jni/src/uci_jni_android_new.rs
index bf8c0055..ec137516 100644
--- a/service/uci/jni/src/uci_jni_android_new.rs
+++ b/service/uci/jni/src/uci_jni_android_new.rs
@@ -36,16 +36,15 @@ use jni::JNIEnv;
 use log::{debug, error};
 use uwb_core::error::{Error, Result};
 use uwb_core::params::{
-    AndroidRadarConfigResponse, AppConfigTlv, CountryCode, GetDeviceInfoResponse, PhaseList,
-    RadarConfigTlv, RawAppConfigTlv, RawUciMessage, RfTestConfigResponse, RfTestConfigTlv,
-    SessionUpdateControllerMulticastResponse, SessionUpdateDtTagRangingRoundsResponse,
-    SetAppConfigResponse, UpdateTime,
+    AndroidRadarConfigResponse, AppConfigTlv, ControllerPhaseList, CountryCode,
+    GetDeviceInfoResponse, RadarConfigTlv, RawAppConfigTlv, RawUciMessage, RfTestConfigResponse,
+    RfTestConfigTlv, SessionUpdateControllerMulticastResponse,
+    SessionUpdateDtTagRangingRoundsResponse, SetAppConfigResponse,
 };
 use uwb_uci_packets::{
     AppConfigTlvType, CapTlv, Controlee, ControleePhaseList, Controlee_V2_0_16_Byte_Version,
-    Controlee_V2_0_32_Byte_Version, Controlees, MacAddressIndicator, PhaseListExtendedMacAddress,
-    PhaseListShortMacAddress, PowerStats, ResetConfig, SessionState, SessionType, StatusCode,
-    UpdateMulticastListAction,
+    Controlee_V2_0_32_Byte_Version, Controlees, MacAddressIndicator, PowerStats, ResetConfig,
+    SessionState, SessionType, StatusCode, UpdateMulticastListAction,
 };
 
 /// Macro capturing the name of the function calling this macro.
@@ -618,6 +617,30 @@ fn native_rf_test_periodic_tx(
     uci_manager.rf_test_periodic_tx(psdu_data_bytearray)
 }
 
+/// Test RF per rx test. Return value defined by uci_packets.pdl
+#[no_mangle]
+pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeTestPerRx(
+    env: JNIEnv,
+    obj: JObject,
+    psdu_data: jbyteArray,
+    chip_id: JString,
+) -> jbyte {
+    debug!("{}: enter", function_name!());
+    byte_result_helper(native_rf_test_per_rx(env, obj, psdu_data, chip_id), function_name!())
+}
+
+fn native_rf_test_per_rx(
+    env: JNIEnv,
+    obj: JObject,
+    psdu_data: jbyteArray,
+    chip_id: JString,
+) -> Result<()> {
+    let uci_manager = Dispatcher::get_uci_manager(env, obj, chip_id)?;
+    let psdu_data_bytearray =
+        env.convert_byte_array(psdu_data).map_err(|_| Error::ForeignFunctionInterface)?;
+    uci_manager.rf_test_per_rx(psdu_data_bytearray)
+}
+
 /// Set radar app configurations on a single UWB device. Return null JObject if failed.
 #[no_mangle]
 pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeSetRadarAppConfigurations(
@@ -667,80 +690,63 @@ fn native_set_radar_app_configurations(
 
 fn parse_hybrid_controller_config_phase_list(
     number_of_phases: usize,
-    message_control: u8,
     byte_array: &[u8],
-) -> Result<PhaseList> {
-    const MAC_ADDRESS_BIT_MASK: u8 = 0x01;
-    let phase_list = match MacAddressIndicator::try_from(message_control & MAC_ADDRESS_BIT_MASK)
-        .map_err(|_| Error::BadParameters)?
-    {
-        MacAddressIndicator::ShortAddress => {
-            const PHASE_LIST_SHORT_ADDRESS_SIZE: usize = 11;
-
-            let phase_list_short = byte_array
-                .chunks(PHASE_LIST_SHORT_ADDRESS_SIZE)
-                .filter(|chunk| chunk.len() == PHASE_LIST_SHORT_ADDRESS_SIZE)
-                .map(|chunk| {
-                    let session_token = u32::from_le_bytes(chunk[0..4].try_into().unwrap());
-                    let start_slot_index = u16::from_le_bytes(chunk[4..6].try_into().unwrap());
-                    let end_slot_index = u16::from_le_bytes(chunk[6..8].try_into().unwrap());
-                    let phase_participation = chunk[8];
-                    let mac_address = [chunk[9], chunk[10]];
-                    PhaseListShortMacAddress {
-                        session_token,
-                        start_slot_index,
-                        end_slot_index,
-                        phase_participation,
-                        mac_address,
-                    }
-                })
-                .collect::<Vec<PhaseListShortMacAddress>>();
-            if phase_list_short.len() != number_of_phases {
-                return Err(Error::BadParameters);
+) -> Result<Vec<ControllerPhaseList>> {
+    let mut controller_phase_list: Vec<ControllerPhaseList> = vec![];
+    let mut i = 0;
+    while i < byte_array.len() {
+        let session_token = u32::from_le_bytes(byte_array[i..(i + 4)].try_into().unwrap());
+        let start_slot_index = u16::from_le_bytes(byte_array[(i + 4)..(i + 6)].try_into().unwrap());
+        let end_slot_index = u16::from_le_bytes(byte_array[(i + 6)..(i + 8)].try_into().unwrap());
+        let control = byte_array[i + 8];
+        const MAC_ADDRESS_BIT_MASK: u8 = 0x01;
+
+        match MacAddressIndicator::try_from(control & MAC_ADDRESS_BIT_MASK)
+            .map_err(|_| Error::BadParameters)?
+        {
+            MacAddressIndicator::ShortAddress => {
+                let mut short_mac_address = [0; 2];
+                const PHASE_LIST_SHORT_ADDRESS_SIZE: usize = 11;
+                short_mac_address.copy_from_slice(&byte_array[(i + 9)..(i + 11)]);
+                let phase_list = ControllerPhaseList {
+                    session_token,
+                    start_slot_index,
+                    end_slot_index,
+                    control,
+                    mac_address: short_mac_address.to_vec(),
+                };
+                i += PHASE_LIST_SHORT_ADDRESS_SIZE;
+                controller_phase_list.push(phase_list);
             }
-            PhaseList::ShortMacAddress(phase_list_short)
-        }
-        MacAddressIndicator::ExtendedAddress => {
-            const PHASE_LIST_EXTENDED_ADDRESS_SIZE: usize = 17;
-            let phase_list_extended = byte_array
-                .chunks(PHASE_LIST_EXTENDED_ADDRESS_SIZE)
-                .filter(|chunk| chunk.len() == PHASE_LIST_EXTENDED_ADDRESS_SIZE)
-                .map(|chunk| {
-                    let session_token = u32::from_le_bytes(chunk[0..4].try_into().unwrap());
-                    let start_slot_index = u16::from_le_bytes(chunk[4..6].try_into().unwrap());
-                    let end_slot_index = u16::from_le_bytes(chunk[6..8].try_into().unwrap());
-                    let phase_participation = chunk[8];
-                    let mut mac_address = [0; 8];
-                    mac_address.copy_from_slice(&chunk[9..17]);
-                    PhaseListExtendedMacAddress {
-                        session_token,
-                        start_slot_index,
-                        end_slot_index,
-                        phase_participation,
-                        mac_address,
-                    }
-                })
-                .collect::<Vec<PhaseListExtendedMacAddress>>();
-            if phase_list_extended.len() != number_of_phases {
-                return Err(Error::BadParameters);
+            MacAddressIndicator::ExtendedAddress => {
+                let mut extended_mac_address = [0; 8];
+                const PHASE_LIST_EXTENDED_ADDRESS_SIZE: usize = 17;
+                extended_mac_address.copy_from_slice(&byte_array[(i + 9)..(i + 17)]);
+                let phase_list = ControllerPhaseList {
+                    session_token,
+                    start_slot_index,
+                    end_slot_index,
+                    control,
+                    mac_address: extended_mac_address.to_vec(),
+                };
+                i += PHASE_LIST_EXTENDED_ADDRESS_SIZE;
+                controller_phase_list.push(phase_list);
             }
-            PhaseList::ExtendedMacAddress(phase_list_extended)
-        }
-    };
-
-    Ok(phase_list)
+        };
+    }
+    if controller_phase_list.len() != number_of_phases {
+        return Err(Error::BadParameters);
+    }
+    Ok(controller_phase_list)
 }
 
 /// Set hybrid session controller configurations. Return null JObject if failed.
 #[no_mangle]
-#[allow(clippy::too_many_arguments)]
 pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeSetHybridSessionControllerConfigurations(
     env: JNIEnv,
     obj: JObject,
     session_id: jint,
-    message_control: jbyte,
     number_of_phases: jint,
-    update_time: jbyteArray,
     phase_list: jbyteArray,
     chip_id: JString,
 ) -> jbyte {
@@ -750,9 +756,7 @@ pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeSe
             env,
             obj,
             session_id,
-            message_control,
             number_of_phases,
-            update_time,
             phase_list,
             chip_id,
         ),
@@ -760,36 +764,23 @@ pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeSe
     )
 }
 
-#[allow(clippy::too_many_arguments)]
 fn native_set_hybrid_session_controller_configurations(
     env: JNIEnv,
     obj: JObject,
     session_id: jint,
-    message_control: jbyte,
     number_of_phases: jint,
-    update_time: jbyteArray,
     phase_list: jbyteArray,
     chip_id: JString,
 ) -> Result<()> {
     let uci_manager = Dispatcher::get_uci_manager(env, obj, chip_id)?;
     let phase_list_bytes =
         env.convert_byte_array(phase_list).map_err(|_| Error::ForeignFunctionInterface)?;
-    let phase_list = parse_hybrid_controller_config_phase_list(
-        number_of_phases as usize,
-        message_control as u8,
-        &phase_list_bytes,
-    )?;
-
-    let update_time_bytes =
-        env.convert_byte_array(update_time).map_err(|_| Error::ForeignFunctionInterface)?;
-    let update_time_array: [u8; 8] =
-        TryFrom::try_from(&update_time_bytes[..]).map_err(|_| Error::BadParameters)?;
+    let phase_list =
+        parse_hybrid_controller_config_phase_list(number_of_phases as usize, &phase_list_bytes)?;
 
     uci_manager.session_set_hybrid_controller_config(
         session_id as u32,
-        message_control as u8,
         number_of_phases as u8,
-        UpdateTime::new(&update_time_array).unwrap(),
         phase_list,
     )
 }
@@ -798,14 +789,13 @@ fn parse_hybrid_controlee_config_phase_list(
     number_of_phases: usize,
     byte_array: &[u8],
 ) -> Result<Vec<ControleePhaseList>> {
-    const CONTROLEE_PHASE_LIST_SIZE: usize = 5;
+    const CONTROLEE_PHASE_LIST_SIZE: usize = 4;
     let controlee_phase_list = byte_array
         .chunks(CONTROLEE_PHASE_LIST_SIZE)
         .filter(|chunk| chunk.len() == CONTROLEE_PHASE_LIST_SIZE)
         .map(|chunk| {
             let session_token = u32::from_le_bytes(chunk[0..4].try_into().unwrap());
-            let phase_participation = chunk[4];
-            ControleePhaseList { session_token, phase_participation }
+            ControleePhaseList { session_token }
         })
         .collect::<Vec<ControleePhaseList>>();
     if controlee_phase_list.len() != number_of_phases {
@@ -1547,6 +1537,7 @@ pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeSe
     dtpml_size: jbyte,
     mac_address: jbyteArray,
     slot_bitmap: jbyteArray,
+    stop_data_transfer: jbyteArray,
     chip_id: JString,
 ) -> jbyte {
     debug!("{}: enter", function_name!());
@@ -1560,6 +1551,7 @@ pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeSe
             dtpml_size,
             mac_address,
             slot_bitmap,
+            stop_data_transfer,
             chip_id,
         ),
         function_name!(),
@@ -1576,6 +1568,7 @@ fn native_session_data_transfer_phase_config(
     dtpml_size: jbyte,
     mac_address: jbyteArray,
     slot_bitmap: jbyteArray,
+    stop_data_transfer: jbyteArray,
     chip_id: JString,
 ) -> Result<()> {
     let uci_manager = Dispatcher::get_uci_manager(env, obj, chip_id)
@@ -1587,6 +1580,7 @@ fn native_session_data_transfer_phase_config(
         dtpml_size as u8,
         env.convert_byte_array(mac_address).map_err(|_| Error::ForeignFunctionInterface)?,
         env.convert_byte_array(slot_bitmap).map_err(|_| Error::ForeignFunctionInterface)?,
+        env.convert_byte_array(stop_data_transfer).map_err(|_| Error::ForeignFunctionInterface)?,
     )
 }
 
@@ -1845,20 +1839,20 @@ mod tests {
             0x1, 0x0, 0x0, 0x0, // session token
             0x1, 0x0, // start slot index
             0x2, 0x0, // end slot index
-            0x1, // phase participation
+            0x0, //control
             0x1, 0x2, // mac address
         ];
         let mut phase_list =
-            parse_hybrid_controller_config_phase_list(1, 0, &raw_controller_config_phase_list)
+            parse_hybrid_controller_config_phase_list(1, &raw_controller_config_phase_list)
                 .unwrap();
         assert_eq!(
-            PhaseList::ShortMacAddress(vec![PhaseListShortMacAddress {
+            vec![uwb_uci_packets::ControllerPhaseList {
                 session_token: 1,
                 start_slot_index: 1,
                 end_slot_index: 2,
-                phase_participation: 1,
-                mac_address: [0x1, 0x2]
-            }]),
+                control: 0,
+                mac_address: [0x1, 0x2].to_vec()
+            }],
             phase_list
         );
 
@@ -1866,20 +1860,20 @@ mod tests {
             0x1, 0x0, 0x0, 0x0, // session token
             0x1, 0x0, // start slot index
             0x2, 0x0, // end slot index
-            0x1, // phase participation
+            0x1, //control
             0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, // mac address
         ];
         phase_list =
-            parse_hybrid_controller_config_phase_list(1, 1, &raw_controller_config_phase_list)
+            parse_hybrid_controller_config_phase_list(1, &raw_controller_config_phase_list)
                 .unwrap();
         assert_eq!(
-            PhaseList::ExtendedMacAddress(vec![PhaseListExtendedMacAddress {
+            vec![uwb_uci_packets::ControllerPhaseList {
                 session_token: 1,
                 start_slot_index: 1,
                 end_slot_index: 2,
-                phase_participation: 1,
-                mac_address: [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]
-            }]),
+                control: 1,
+                mac_address: [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8].to_vec()
+            }],
             phase_list
         );
     }
@@ -1888,13 +1882,9 @@ mod tests {
     fn test_parse_hybrid_controlee_config_phase_list() {
         let raw_controlee_config_phase_list = vec![
             0x1, 0x0, 0x0, 0x0, // session token
-            0x1, // phase participation
         ];
         let phase_list =
             parse_hybrid_controlee_config_phase_list(1, &raw_controlee_config_phase_list).unwrap();
-        assert_eq!(
-            vec![ControleePhaseList { session_token: 1, phase_participation: 1 }],
-            phase_list
-        );
+        assert_eq!(vec![ControleePhaseList { session_token: 1 }], phase_list);
     }
 }
diff --git a/service/uci/jni/src/unique_jvm.rs b/service/uci/jni/src/unique_jvm.rs
index bedb7f89..3ffe6b5b 100644
--- a/service/uci/jni/src/unique_jvm.rs
+++ b/service/uci/jni/src/unique_jvm.rs
@@ -39,6 +39,7 @@ pub(crate) fn set_once(jvm: JavaVM) -> Result<()> {
     Ok(())
 }
 /// Gets a `'static` reference to the unique JavaVM. Returns `None` if [`set_once`] was never called.
+#[allow(static_mut_refs)]
 pub(crate) fn get_static_ref() -> Option<&'static Arc<JavaVM>> {
     // Safety: follows [this pattern](https://doc.rust-lang.org/std/sync/struct.Once.html).
     // Modification to static mut is nested inside call_once.
diff --git a/tests/cts/hostsidetests/multidevices/uwb/Android.bp b/tests/cts/hostsidetests/multidevices/uwb/Android.bp
index 128dffee..5e946fae 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/Android.bp
+++ b/tests/cts/hostsidetests/multidevices/uwb/Android.bp
@@ -21,6 +21,7 @@ python_defaults {
     name: "CtsUwbMultiDevicePythonDefaults",
     libs: [
         "mobly",
+        "platform-test-py-annotations",
     ],
     test_suites: [
         "cts",
@@ -28,11 +29,6 @@ python_defaults {
         "mts-uwb",
         "mcts-uwb",
     ],
-    version: {
-        py3: {
-            embedded_launcher: true,
-        },
-    },
 }
 
 python_test_host {
@@ -78,3 +74,56 @@ python_test_host {
     ],
     defaults: ["CtsUwbMultiDevicePythonDefaults"],
 }
+
+// Modules for CTS-Verifier (cts-v-host)
+python_test_host {
+    name: "CtsUwbMultiDeviceUwbManagerTests",
+    main: "UwbManagerTests/uwb_manager_test.py",
+    srcs: [
+        "UwbManagerTests/uwb_manager_test.py",
+        "lib/uwb_base_test.py",
+        "lib/uwb_ranging_decorator.py",
+        "lib/uwb_ranging_params.py",
+        "test_utils/uwb_test_utils.py",
+    ],
+    test_suites: [
+        "cts-v-host",
+    ],
+    test_config: "UwbManagerTests/AndroidTestV2.xml",
+    test_options: {
+        runner: "mobly",
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":uwb_snippet",
+        "README.md",
+    ],
+    defaults: ["CtsUwbMultiDevicePythonDefaults"],
+}
+
+python_test_host {
+    name: "CtsUwbMultiDeviceFiraRangingTests",
+    main: "FiraRangingTests/ranging_test.py",
+    srcs: [
+        "FiraRangingTests/ranging_test.py",
+        "lib/uwb_base_test.py",
+        "lib/uwb_ranging_decorator.py",
+        "lib/uwb_ranging_params.py",
+        "test_utils/uwb_test_utils.py",
+    ],
+    test_suites: [
+        "cts-v-host",
+    ],
+    test_config: "FiraRangingTests/AndroidTestV2.xml",
+    test_options: {
+        runner: "mobly",
+        unit_test: false,
+    },
+    device_common_data: [
+        // Package the snippet with the mobly test
+        ":uwb_snippet",
+        "README.md",
+    ],
+    defaults: ["CtsUwbMultiDevicePythonDefaults"],
+}
diff --git a/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/AndroidTestV2.xml b/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/AndroidTestV2.xml
new file mode 100644
index 00000000..526a0da4
--- /dev/null
+++ b/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/AndroidTestV2.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<configuration description="CTS FiRa ranging tests.">
+    <option name="test-suite-tag" value="cts-v-host" />
+    <option name="config-descriptor:metadata" key="component" value="uwb" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_instant_app" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_secondary_user" />
+    <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.uwb.apex" />
+
+    <device name="AndroidDevice">
+        <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+            <option name="required_feature" value="android.hardware.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidMainlineModulesCheckDecorator">
+            <option name="mainline_module_package_name" value="com.google.android.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidInstallAppsDecorator" />
+    </device>
+    <device name="AndroidDevice">
+        <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+            <option name="required_feature" value="android.hardware.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidMainlineModulesCheckDecorator">
+            <option name="mainline_module_package_name" value="com.google.android.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidInstallAppsDecorator" />
+    </device>
+
+    <test class="MoblyAospPackageTest" />
+
+    <option name="mobly_pkg" key="file" value="CtsUwbMultiDeviceFiraRangingTests" />
+    <option name="build_apk" key="file" value="uwb_snippet.apk" />
+</configuration>
diff --git a/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/ranging_test.py b/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/ranging_test.py
index 11e2c1be..e27029c0 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/ranging_test.py
+++ b/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/ranging_test.py
@@ -14,6 +14,7 @@ from mobly import config_parser
 from mobly import signals
 from mobly import suite_runner
 from test_utils import uwb_test_utils
+from android.platform.test.annotations import ApiTest
 
 RESPONDER_STOP_CALLBACK_TIMEOUT = 60
 
@@ -40,6 +41,7 @@ _TEST_CASES = (
     # "test_ranging_device_tracker_profile_with_airplane_mode_toggle",
     # "test_ranging_nearby_share_profile_with_airplane_mode_toggle",
     "test_ranging_nearby_share_profile_move_to_bg_and_fg",
+    "test_ranging_nearby_share_profile_move_to_bg_and_fg_with_range_data_ntf_disabled",
     "test_ranging_nearby_share_profile_verify_app_in_bg_stops_session",
     "test_ranging_nearby_share_profile_bg_fails",
     "test_ranging_nearby_share_profile_no_valid_reports_stops_session",
@@ -103,7 +105,8 @@ class RangingTest(uwb_base_test.UwbBaseTest):
       initiator_params: uwb_ranging_params.UwbRangingParams,
       responder_params: uwb_ranging_params.UwbRangingParams,
       peer_addr: List[int],
-      session: int = 0):
+      session: int = 0,
+      verify_on_initiator: bool = True):
     """Verifies ranging between two uwb devices.
 
     Args:
@@ -113,12 +116,16 @@ class RangingTest(uwb_base_test.UwbBaseTest):
       responder_params: ranging params for responder.
       peer_addr: address of uwb device.
       session: Session key to use.
+      verify_on_initiator: Whether to verify on initiator.
     """
     initiator.open_fira_ranging(initiator_params, session=session)
     responder.open_fira_ranging(responder_params, session=session)
     initiator.start_fira_ranging(session=session)
     responder.start_fira_ranging(session=session)
-    uwb_test_utils.verify_peer_found(initiator, peer_addr, session=session)
+    if verify_on_initiator:
+      uwb_test_utils.verify_peer_found(initiator, peer_addr, session=session)
+    else:
+      uwb_test_utils.verify_peer_found(responder, peer_addr, session=session)
 
   def _verify_one_to_one_ranging_reconfigured_controlee_params(
       self, initiator: uwb_ranging_decorator.UwbRangingDecorator,
@@ -483,6 +490,14 @@ class RangingTest(uwb_base_test.UwbBaseTest):
 
   ### Test Cases ###
 
+  @ApiTest(apis=[
+      'android.content.AttributionSource#checkCallingUid',
+      'android.os.Parcel#readPersistableBundle(java.lang.ClassLoader)',
+      'android.os.Parcel#writeBlob(byte[])',
+      'android.app.AlarmManager#setInexactRepeating(int, long, long, android.app.PendingIntent)',
+      'java.util#copyOf(byte[], int)',
+      'java.util#copyOfRange(byte[], int, int)',
+  ])
   def test_ranging_device_tracker_profile_default(self):
     """Verifies ranging with device tracker profile default values."""
     initiator_params = uwb_ranging_params.UwbRangingParams(
@@ -1456,6 +1471,72 @@ class RangingTest(uwb_base_test.UwbBaseTest):
     self.responder.stop_ranging()
     self.initiator.stop_ranging()
 
+  def test_ranging_nearby_share_profile_move_to_bg_and_fg_with_range_data_ntf_disabled(self):
+    """Verifies ranging with app moving background and foreground when range data ntf is disabled.
+
+    Steps:
+      1. Verifies ranging with default Fira parameters and range data ntf disabled.
+      2. Ensures the app does not receive range data notifications
+      3. Move app to background.
+      4. Ensures the app does not receive range data notifications
+      5. Move app to foreground.
+      6. Ensures the app does not receive range data notifications
+    """
+    initiator_params = uwb_ranging_params.UwbRangingParams(
+        device_role=uwb_ranging_params.FiraParamEnums.DEVICE_ROLE_INITIATOR,
+        device_type=uwb_ranging_params.FiraParamEnums.DEVICE_TYPE_CONTROLLER,
+        device_address=self.initiator_addr,
+        destination_addresses=[self.responder_addr],
+        ranging_interval_ms=200,
+        slots_per_ranging_round=20,
+        in_band_termination_attempt_count=3,
+        range_data_ntf_config=uwb_ranging_params.FiraParamEnums.RANGE_DATA_NTF_CONFIG_DISABLE,
+    )
+    responder_params = uwb_ranging_params.UwbRangingParams(
+        device_role=uwb_ranging_params.FiraParamEnums.DEVICE_ROLE_RESPONDER,
+        device_type=uwb_ranging_params.FiraParamEnums.DEVICE_TYPE_CONTROLEE,
+        device_address=self.responder_addr,
+        destination_addresses=[self.initiator_addr],
+        ranging_interval_ms=200,
+        slots_per_ranging_round=20,
+        in_band_termination_attempt_count=3,
+    )
+    self._verify_one_to_one_ranging(
+        self.initiator,
+        self.responder,
+        initiator_params,
+        responder_params,
+        self.initiator_addr,
+        verify_on_initiator=False,
+    )
+
+    self._move_snippet_to_bg(self.initiator)
+    time.sleep(0.75)
+    self.initiator.clear_ranging_session_callback_events()
+    try:
+      self.initiator.verify_callback_received("ReportReceived")
+      asserts.fail(
+          "Should not receive ranging reports when the app is in background"
+      )
+    except TimeoutError:
+      # Expect to get a timeout error
+      self.initiator.log.info("Did not get any ranging reports as expected")
+
+    self._move_snippet_to_fg(self.initiator)
+    time.sleep(0.75)
+    self.initiator.clear_ranging_session_callback_events()
+    try:
+      self.initiator.verify_callback_received("ReportReceived")
+      asserts.fail(
+          "Should not receive ranging reports when the app is in background"
+      )
+    except TimeoutError:
+      # Expect to get a timeout error
+      self.initiator.log.info("Did not get any ranging reports as expected")
+
+    self.responder.stop_ranging()
+    self.initiator.stop_ranging()
+
   def test_ranging_nearby_share_profile_verify_app_in_bg_stops_session(self):
     """Verifies stop session callback with app staying in the background.
 
@@ -1573,6 +1654,7 @@ class RangingTest(uwb_base_test.UwbBaseTest):
     def reboot_responder():
       self.responder.ad.reboot()
       self.responder.clear_all_ranging_sessions()
+      uwb_test_utils.request_hw_enable_if_required(self.responder.ad)
       uwb_test_utils.initialize_uwb_country_code_if_not_set(self.responder.ad)
 
     # create a thread to reboot the responder and not block the main test.
@@ -1614,6 +1696,11 @@ class RangingTest(uwb_base_test.UwbBaseTest):
         .getSpecificationInfo()["fira"]["max_ranging_session_number"])
     max_fira_ranging_sessions = min(initiator_max_fira_ranging_sessions,
                                     responder_max_fira_ranging_sessions)
+    max_supported_session_count = (
+        self.initiator.ad.uwb
+        .getSpecificationInfo()["max_supported_session_count"])
+    max_fira_ranging_sessions = min(max_supported_session_count,
+                                    max_fira_ranging_sessions)
     initiator_params = uwb_ranging_params.UwbRangingParams(
         device_role=uwb_ranging_params.FiraParamEnums.DEVICE_ROLE_INITIATOR,
         device_type=uwb_ranging_params.FiraParamEnums.DEVICE_TYPE_CONTROLLER,
diff --git a/tests/cts/hostsidetests/multidevices/uwb/OWNERS b/tests/cts/hostsidetests/multidevices/uwb/OWNERS
index 14bdcc94..b3a4d0cd 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/OWNERS
+++ b/tests/cts/hostsidetests/multidevices/uwb/OWNERS
@@ -4,4 +4,3 @@ include platform/packages/modules/Uwb:/OWNERS
 # Engprod - Not owner of the test but help maintaining the module as an example
 jdesprez@google.com
 frankfeng@google.com
-murj@google.com
diff --git a/tests/cts/hostsidetests/multidevices/uwb/UwbManagerTests/AndroidTestV2.xml b/tests/cts/hostsidetests/multidevices/uwb/UwbManagerTests/AndroidTestV2.xml
new file mode 100644
index 00000000..42af7200
--- /dev/null
+++ b/tests/cts/hostsidetests/multidevices/uwb/UwbManagerTests/AndroidTestV2.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<configuration description="CTS multi-device tests for UwbManager APIs.">
+    <option name="test-suite-tag" value="cts-v-host" />
+    <option name="config-descriptor:metadata" key="component" value="uwb" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_instant_app" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_secondary_user" />
+    <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.uwb.apex" />
+
+    <device name="AndroidDevice">
+        <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+            <option name="required_feature" value="android.hardware.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidMainlineModulesCheckDecorator">
+            <option name="mainline_module_package_name" value="com.google.android.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidInstallAppsDecorator" />
+    </device>
+    <device name="AndroidDevice">
+        <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+            <option name="required_feature" value="android.hardware.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidMainlineModulesCheckDecorator">
+            <option name="mainline_module_package_name" value="com.google.android.uwb" />
+        </target_preparer>
+        <target_preparer class="AndroidInstallAppsDecorator" />
+    </device>
+
+    <test class="MoblyAospPackageTest" />
+
+    <option name="mobly_pkg" key="file" value="CtsUwbMultiDeviceUwbManagerTests" />
+    <option name="build_apk" key="file" value="uwb_snippet.apk" />
+</configuration>
diff --git a/tests/cts/hostsidetests/multidevices/uwb/UwbManagerTests/uwb_manager_test.py b/tests/cts/hostsidetests/multidevices/uwb/UwbManagerTests/uwb_manager_test.py
index d379ca09..b12010af 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/UwbManagerTests/uwb_manager_test.py
+++ b/tests/cts/hostsidetests/multidevices/uwb/UwbManagerTests/uwb_manager_test.py
@@ -66,6 +66,7 @@ class UwbManagerTest(uwb_base_test.UwbBaseTest):
     """
     uwb_test_utils.set_uwb_state_and_verify(dut, state)
     dut.reboot()
+    uwb_test_utils.request_hw_enable_if_required(dut)
     uwb_test_utils.initialize_uwb_country_code_if_not_set(dut)
     state_after_reboot = uwb_test_utils.get_uwb_state(dut)
     asserts.assert_equal(
diff --git a/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_base_test.py b/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_base_test.py
index 535650f1..480c2a81 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_base_test.py
+++ b/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_base_test.py
@@ -25,6 +25,7 @@ class UwbBaseTest(base_test.BaseTestClass):
       ad.load_snippet("uwb", "com.google.snippet.uwb")
 
     for ad in self.android_devices:
+      uwb_test_utils.request_hw_enable_if_required(ad)
       uwb_test_utils.initialize_uwb_country_code_if_not_set(ad)
 
   def setup_test(self):
@@ -38,6 +39,9 @@ class UwbBaseTest(base_test.BaseTestClass):
       ad.uwb.logInfo("*** TEST END: " + self.current_test_info.name + " ***")
 
   def teardown_class(self):
+    for ad in self.android_devices:
+      if ad.uwb.isUwbHwIdleTurnOffEnabled():
+        ad.uwb.requestUwbHwEnabled(False)
     super().teardown_class()
     self._record_all()
 
diff --git a/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_ranging_params.py b/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_ranging_params.py
index a040c56f..b614daa0 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_ranging_params.py
+++ b/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_ranging_params.py
@@ -79,6 +79,14 @@ class FiraParamEnums:
   STS_CONFIG_PROVISIONED = 3
   STS_CONFIG_PROVISIONED_FOR_CONTROLEE_INDIVIDUAL_KEY = 4
 
+  # rfrmae config
+  RFRAME_CONFIG_SP0 = 0
+  RFRAME_CONFIG_SP1 = 1
+  RFRAME_CONFIG_SP3 = 3
+
+  # ranging ntf config
+  RANGE_DATA_NTF_CONFIG_DISABLE = 0
+  RANGE_DATA_NTF_CONFIG_ENABLE = 1
 
 @dataclasses.dataclass
 class UwbRangingReconfigureParams():
@@ -179,6 +187,7 @@ class UwbRangingParams():
     session_key: Provisioned sts session key.
     sub_session_id: Ranging sub session ID.
     sub_session_key: Ranging sub session key.
+    range_data_ntf_config: Range data ntf config.
 
   Example:
       An example of UWB ranging parameters passed to sl4a is below.
@@ -240,6 +249,8 @@ class UwbRangingParams():
   )
   sub_session_id: Optional[int] = None
   sub_session_key: Optional[List[int]] = None
+  rframe_config: int = FiraParamEnums.RFRAME_CONFIG_SP3
+  range_data_ntf_config: int = FiraParamEnums.RANGE_DATA_NTF_CONFIG_ENABLE
 
   def to_dict(self) -> Dict[str, Any]:
     """Returns UWB ranging parameters in dictionary for sl4a.
@@ -261,6 +272,7 @@ class UwbRangingParams():
         "slotsPerRangingRound": self.slots_per_ranging_round,
         "rangingIntervalMs": self.ranging_interval_ms,
         "hoppingMode": self.hopping_mode,
+        "rframeConfig": self.rframe_config,
         "maxRangingRoundRetries": self.max_ranging_round_retries,
         "inBandTerminationAttemptCount": self.in_band_termination_attempt_count,
         "aoaResultRequest": self.aoa_result_request,
@@ -271,6 +283,7 @@ class UwbRangingParams():
         "staticStsIV": self.static_sts_iv,
         "stsConfig": self.sts_config,
         "sessionKey": self.session_key,
+        "rangeDataNtfConfig": self.range_data_ntf_config,
     }
     if self.sub_session_id is not None:
       dict["subSessionId"] = self.sub_session_id
diff --git a/tests/cts/hostsidetests/multidevices/uwb/snippet/Android.bp b/tests/cts/hostsidetests/multidevices/uwb/snippet/Android.bp
index bbfe1f71..d36c645c 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/snippet/Android.bp
+++ b/tests/cts/hostsidetests/multidevices/uwb/snippet/Android.bp
@@ -34,4 +34,8 @@ android_test {
         "com.uwb.support.multichip",
     ],
     min_sdk_version: "31",
+    visibility: [
+        "//packages/modules/Uwb:__subpackages__",
+        "//platform_testing:__subpackages__",
+    ],
 }
diff --git a/tests/cts/hostsidetests/multidevices/uwb/snippet/UwbManagerSnippet.java b/tests/cts/hostsidetests/multidevices/uwb/snippet/UwbManagerSnippet.java
index afc530ec..426e6f6e 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/snippet/UwbManagerSnippet.java
+++ b/tests/cts/hostsidetests/multidevices/uwb/snippet/UwbManagerSnippet.java
@@ -482,6 +482,8 @@ public class UwbManagerSnippet implements Snippet {
             return null;
         }
         FiraRangingReconfigureParams.Builder builder = new FiraRangingReconfigureParams.Builder();
+
+        // keep-sorted start block=yes
         if (j.has("action")) {
             builder.setAction(j.getInt("action"));
         }
@@ -494,6 +496,9 @@ public class UwbManagerSnippet implements Snippet {
             }
             builder.setAddressList(addressList);
         }
+        if (j.has("blockStrideLength")) {
+            builder.setBlockStrideLength(j.getInt("blockStrideLength"));
+        }
         if (j.has("subSessionIdList")) {
             JSONArray jArray = j.getJSONArray("subSessionIdList");
             int[] subSessionIdList = new int[jArray.length()];
@@ -506,9 +511,7 @@ public class UwbManagerSnippet implements Snippet {
             JSONArray jSubSessionKeyListArray = j.getJSONArray("subSessionKeyList");
             builder.setSubSessionKeyList(convertJSONArrayToByteArray(jSubSessionKeyListArray));
         }
-        if (j.has("blockStrideLength")) {
-            builder.setBlockStrideLength(j.getInt("blockStrideLength"));
-        }
+        // keep-sorted end
         return builder.build();
     }
 
@@ -517,6 +520,7 @@ public class UwbManagerSnippet implements Snippet {
             return null;
         }
         FiraControleeParams.Builder builder = new FiraControleeParams.Builder();
+        // keep-sorted start block=yes
         if (j.has("action")) {
             builder.setAction(j.getInt("action"));
         }
@@ -541,6 +545,7 @@ public class UwbManagerSnippet implements Snippet {
             JSONArray jSubSessionKeyListArray = j.getJSONArray("subSessionKeyList");
             builder.setSubSessionKeyList(convertJSONArrayToByteArray(jSubSessionKeyListArray));
         }
+        // keep-sorted end
         return builder.build();
     }
 
@@ -550,21 +555,23 @@ public class UwbManagerSnippet implements Snippet {
             return null;
         }
         CccRangingStartedParams.Builder builder = new CccRangingStartedParams.Builder();
-        if (j.has("stsIndex")) {
-            builder.setStartingStsIndex(j.getInt("stsIndex"));
-        }
-        if (j.has("uwbTime")) {
-            builder.setUwbTime0(j.getInt("uwbTime"));
-        }
+        // keep-sorted start block=yes
         if (j.has("hopModeKey")) {
             builder.setHopModeKey(j.getInt("hopModeKey"));
         }
+        if (j.has("ranMultiplier")) {
+            builder.setRanMultiplier(j.getInt("ranMultiplier"));
+        }
+        if (j.has("stsIndex")) {
+            builder.setStartingStsIndex(j.getInt("stsIndex"));
+        }
         if (j.has("syncCodeIndex")) {
             builder.setSyncCodeIndex(j.getInt("syncCodeIndex"));
         }
-        if (j.has("ranMultiplier")) {
-            builder.setRanMultiplier(j.getInt("ranMultiplier"));
+        if (j.has("uwbTime")) {
+            builder.setUwbTime0(j.getInt("uwbTime"));
         }
+        // keep-sorted end
 
         return builder.build();
     }
@@ -575,42 +582,44 @@ public class UwbManagerSnippet implements Snippet {
         }
         CccOpenRangingParams.Builder builder = new CccOpenRangingParams.Builder();
         builder.setProtocolVersion(CccParams.PROTOCOL_VERSION_1_0);
-        if (j.has("sessionId")) {
-            builder.setSessionId(j.getInt("sessionId"));
-        }
-        if (j.has("uwbConfig")) {
-            builder.setUwbConfig(j.getInt("uwbConfig"));
-        }
-        if (j.has("ranMultiplier")) {
-            builder.setRanMultiplier(j.getInt("ranMultiplier"));
-        }
+        // keep-sorted start block=yes
         if (j.has("channel")) {
             builder.setChannel(j.getInt("channel"));
         }
         if (j.has("chapsPerSlot")) {
             builder.setNumChapsPerSlot(j.getInt("chapsPerSlot"));
         }
-        if (j.has("responderNodes")) {
-            builder.setNumResponderNodes(j.getInt("responderNodes"));
-        }
-        if (j.has("slotsPerRound")) {
-            builder.setNumSlotsPerRound(j.getInt("slotsPerRound"));
-        }
         if (j.has("hoppingMode")) {
             builder.setHoppingConfigMode(j.getInt("hoppingMode"));
         }
         if (j.has("hoppingSequence")) {
             builder.setHoppingSequence(j.getInt("hoppingSequence"));
         }
-        if (j.has("syncCodeIndex")) {
-            builder.setSyncCodeIndex(j.getInt("syncCodeIndex"));
-        }
         if (j.has("pulseShapeCombo")) {
             JSONObject pulseShapeCombo = j.getJSONObject("pulseShapeCombo");
             builder.setPulseShapeCombo(new CccPulseShapeCombo(
                     pulseShapeCombo.getInt("pulseShapeComboTx"),
                     pulseShapeCombo.getInt("pulseShapeComboRx")));
         }
+        if (j.has("ranMultiplier")) {
+            builder.setRanMultiplier(j.getInt("ranMultiplier"));
+        }
+        if (j.has("responderNodes")) {
+            builder.setNumResponderNodes(j.getInt("responderNodes"));
+        }
+        if (j.has("sessionId")) {
+            builder.setSessionId(j.getInt("sessionId"));
+        }
+        if (j.has("slotsPerRound")) {
+            builder.setNumSlotsPerRound(j.getInt("slotsPerRound"));
+        }
+        if (j.has("syncCodeIndex")) {
+            builder.setSyncCodeIndex(j.getInt("syncCodeIndex"));
+        }
+        if (j.has("uwbConfig")) {
+            builder.setUwbConfig(j.getInt("uwbConfig"));
+        }
+        // keep-sorted end
 
         return builder.build();
     }
@@ -621,26 +630,16 @@ public class UwbManagerSnippet implements Snippet {
         }
         FiraOpenSessionParams.Builder builder = new FiraOpenSessionParams.Builder();
         builder.setProtocolVersion(FiraParams.PROTOCOL_VERSION_1_1);
-        if (j.has("sessionId")) {
-            builder.setSessionId(j.getInt("sessionId"));
-        }
-        if (j.has("deviceType")) {
-            builder.setDeviceType(j.getInt("deviceType"));
-        }
-        if (j.has("deviceRole")) {
-            builder.setDeviceRole(j.getInt("deviceRole"));
-        }
-        if (j.has("rangingRoundUsage")) {
-            builder.setRangingRoundUsage(j.getInt("rangingRoundUsage"));
+
+        // keep-sorted start block=yes
+        if (j.has("aoaResultRequest")) {
+            builder.setAoaResultRequest(j.getInt("aoaResultRequest"));
         }
-        if (j.has("multiNodeMode")) {
-            builder.setMultiNodeMode(j.getInt("multiNodeMode"));
+        if (j.has("blockStrideLength")) {
+            builder.setBlockStrideLength(j.getInt("blockStrideLength"));
         }
-        if (j.has("deviceAddress")) {
-            JSONArray jArray = j.getJSONArray("deviceAddress");
-            byte[] bArray = convertJSONArrayToByteArray(jArray);
-            UwbAddress deviceAddress = getComputedMacAddress(UwbAddress.fromBytes(bArray));
-            builder.setDeviceAddress(deviceAddress);
+        if (j.has("channel")) {
+            builder.setChannelNumber(j.getInt("channel"));
         }
         if (j.has("destinationAddresses")) {
             JSONArray jArray = j.getJSONArray("destinationAddresses");
@@ -651,95 +650,114 @@ public class UwbManagerSnippet implements Snippet {
             }
             builder.setDestAddressList(Arrays.asList(destinationUwbAddresses));
         }
-        if (j.has("initiationTimeMs")) {
-            builder.setInitiationTime(j.getInt("initiationTimeMs"));
+        if (j.has("deviceAddress")) {
+            JSONArray jArray = j.getJSONArray("deviceAddress");
+            byte[] bArray = convertJSONArrayToByteArray(jArray);
+            UwbAddress deviceAddress = getComputedMacAddress(UwbAddress.fromBytes(bArray));
+            builder.setDeviceAddress(deviceAddress);
         }
-        if (j.has("slotDurationRstu")) {
-            builder.setSlotDurationRstu(j.getInt("slotDurationRstu"));
+        if (j.has("deviceRole")) {
+            builder.setDeviceRole(j.getInt("deviceRole"));
         }
-        if (j.has("slotsPerRangingRound")) {
-            builder.setSlotsPerRangingRound(j.getInt("slotsPerRangingRound"));
+        if (j.has("deviceType")) {
+            builder.setDeviceType(j.getInt("deviceType"));
         }
-        if (j.has("rangingIntervalMs")) {
-            builder.setRangingIntervalMs(j.getInt("rangingIntervalMs"));
+        if (j.has("filterType")) {
+            builder.setFilterType(j.getInt("filterType"));
         }
-        if (j.has("blockStrideLength")) {
-            builder.setBlockStrideLength(j.getInt("blockStrideLength"));
+        if (j.has("hasRangingResultReportMessage")) {
+            builder.setHasRangingResultReportMessage(j.getBoolean("hasRangingResultReportMessage"));
         }
         if (j.has("hoppingMode")) {
             builder.setHoppingMode(j.getInt("hoppingMode"));
         }
-        if (j.has("maxRangingRoundRetries")) {
-            builder.setMaxRangingRoundRetries(j.getInt("maxRangingRoundRetries"));
+        if (j.has("inBandTerminationAttemptCount")) {
+            builder.setInBandTerminationAttemptCount(j.getInt("inBandTerminationAttemptCount"));
         }
-        if (j.has("maxNumberOfMeasurements")) {
-            builder.setMaxNumberOfMeasurements(j.getInt("maxNumberOfMeasurements"));
+        if (j.has("initiationTimeMs")) {
+            builder.setInitiationTime(j.getInt("initiationTimeMs"));
         }
-        if (j.has("sessionPriority")) {
-            builder.setSessionPriority(j.getInt("sessionPriority"));
+        if (j.has("isKeyRotationEnabled")) {
+            builder.setIsKeyRotationEnabled(j.getBoolean("isKeyRotationEnabled"));
+        }
+        if (j.has("keyRotationRate")) {
+            builder.setKeyRotationRate(j.getInt("keyRotationRate"));
         }
         if (j.has("macAddressMode")) {
             builder.setMacAddressMode(j.getInt("macAddressMode"));
         }
-        if (j.has("inBandTerminationAttemptCount")) {
-            builder.setInBandTerminationAttemptCount(j.getInt("inBandTerminationAttemptCount"));
+        if (j.has("maxNumberOfMeasurements")) {
+            builder.setMaxNumberOfMeasurements(j.getInt("maxNumberOfMeasurements"));
         }
-        if (j.has("channel")) {
-            builder.setChannelNumber(j.getInt("channel"));
+        if (j.has("maxRangingRoundRetries")) {
+            builder.setMaxRangingRoundRetries(j.getInt("maxRangingRoundRetries"));
+        }
+        if (j.has("multiNodeMode")) {
+            builder.setMultiNodeMode(j.getInt("multiNodeMode"));
         }
         if (j.has("preamble")) {
             builder.setPreambleCodeIndex(j.getInt("preamble"));
         }
-        if (j.getInt("stsConfig") == FiraParams.STS_CONFIG_STATIC) {
-            JSONArray jVendorIdArray = j.getJSONArray("vendorId");
-            builder.setVendorId(getComputedVendorId(convertJSONArrayToByteArray(jVendorIdArray)));
-            JSONArray jStatisStsIVArray = j.getJSONArray("staticStsIV");
-            builder.setStaticStsIV(convertJSONArrayToByteArray(jStatisStsIVArray));
-        } else if (j.getInt("stsConfig") == FiraParams.STS_CONFIG_PROVISIONED) {
-            builder.setStsConfig(j.getInt("stsConfig"));
-            JSONArray jSessionKeyArray = j.getJSONArray("sessionKey");
-            builder.setSessionKey(convertJSONArrayToByteArray(jSessionKeyArray));
-        } else if (j.getInt(
-                "stsConfig") == FiraParams.STS_CONFIG_PROVISIONED_FOR_CONTROLEE_INDIVIDUAL_KEY) {
-            builder.setStsConfig(j.getInt("stsConfig"));
-            JSONArray jSessionKeyArray = j.getJSONArray("sessionKey");
-            builder.setSessionKey(convertJSONArrayToByteArray(jSessionKeyArray));
-            if (j.getInt("deviceType") == FiraParams.RANGING_DEVICE_TYPE_CONTROLEE) {
-                JSONArray jSubSessionKeyArray = j.getJSONArray("subSessionKey");
-                builder.setSubsessionKey(convertJSONArrayToByteArray(jSubSessionKeyArray));
-                builder.setSubSessionId(j.getInt("subSessionId"));
+        if (j.has("prfMode")) {
+            builder.setPrfMode(j.getInt("prfMode"));
+            if (j.getInt("prfMode") == FiraParams.PRF_MODE_HPRF) {
+                builder.setPsduDataRate(FiraParams.PSDU_DATA_RATE_6M81);
             }
         }
-        if (j.has("aoaResultRequest")) {
-            builder.setAoaResultRequest(j.getInt("aoaResultRequest"));
-        }
-        if (j.has("filterType")) {
-            builder.setFilterType(j.getInt("filterType"));
-        }
         if (j.has("rangeDataNtfConfig")) {
             builder.setRangeDataNtfConfig(j.getInt("rangeDataNtfConfig"));
         }
-        if (j.has("errorStreakTimeoutInMs")) {
-            builder.setRangingErrorStreakTimeoutMs(j.getInt("errorStreakTimeoutInMs"));
-        }
-        if (j.has("hasRangingResultReportMessage")) {
-            builder.setHasRangingResultReportMessage(j.getBoolean("hasRangingResultReportMessage"));
-        }
         if (j.has("rangingErrorStreakTimeoutMs")) {
             builder.setRangingErrorStreakTimeoutMs(j.getLong("rangingErrorStreakTimeoutMs"));
         }
-        if (j.has("isKeyRotationEnabled")) {
-            builder.setIsKeyRotationEnabled(j.getBoolean("isKeyRotationEnabled"));
+        if (j.has("rangingIntervalMs")) {
+            builder.setRangingIntervalMs(j.getInt("rangingIntervalMs"));
         }
-        if (j.has("keyRotationRate")) {
-            builder.setKeyRotationRate(j.getInt("keyRotationRate"));
+        if (j.has("rangingRoundUsage")) {
+            builder.setRangingRoundUsage(j.getInt("rangingRoundUsage"));
         }
-        if (j.has("hasRangingResultReportMessage")) {
-            builder.setHasRangingResultReportMessage(j.getBoolean("hasRangingResultReportMessage"));
+        if (j.has("rframeConfig")) {
+            builder.setRframeConfig(j.getInt("rframeConfig"));
         }
-        if (j.has("prfMode")) {
-            builder.setPrfMode(j.getInt("prfMode"));
+        if (j.has("sessionId")) {
+            builder.setSessionId(j.getInt("sessionId"));
+        }
+        if (j.has("sessionPriority")) {
+            builder.setSessionPriority(j.getInt("sessionPriority"));
+        }
+        if (j.has("slotDurationRstu")) {
+            builder.setSlotDurationRstu(j.getInt("slotDurationRstu"));
+        }
+        if (j.has("slotsPerRangingRound")) {
+            builder.setSlotsPerRangingRound(j.getInt("slotsPerRangingRound"));
+        }
+        if (j.has("rangeDataNtfConfig")) {
+            builder.setRangeDataNtfConfig(j.getInt("rangeDataNtfConfig"));
+        }
+        if (j.has("stsConfig")) {
+            if (j.getInt("stsConfig") == FiraParams.STS_CONFIG_PROVISIONED) {
+                builder.setStsConfig(j.getInt("stsConfig"));
+                JSONArray jSessionKeyArray = j.getJSONArray("sessionKey");
+                builder.setSessionKey(convertJSONArrayToByteArray(jSessionKeyArray));
+            } else if (j.getInt("stsConfig")
+                       == FiraParams.STS_CONFIG_PROVISIONED_FOR_CONTROLEE_INDIVIDUAL_KEY) {
+                builder.setStsConfig(j.getInt("stsConfig"));
+                JSONArray jSessionKeyArray = j.getJSONArray("sessionKey");
+                builder.setSessionKey(convertJSONArrayToByteArray(jSessionKeyArray));
+                if (j.getInt("deviceType") == FiraParams.RANGING_DEVICE_TYPE_CONTROLEE) {
+                    JSONArray jSubSessionKeyArray = j.getJSONArray("subSessionKey");
+                    builder.setSubsessionKey(convertJSONArrayToByteArray(jSubSessionKeyArray));
+                    builder.setSubSessionId(j.getInt("subSessionId"));
+                }
+            } else if (j.getInt("stsConfig") == FiraParams.STS_CONFIG_STATIC) {
+                JSONArray jVendorIdArray = j.getJSONArray("vendorId");
+                builder.setVendorId(
+                        getComputedVendorId(convertJSONArrayToByteArray(jVendorIdArray)));
+                JSONArray jStatisStsIVArray = j.getJSONArray("staticStsIV");
+                builder.setStaticStsIV(convertJSONArrayToByteArray(jStatisStsIVArray));
+            }
         }
+        // keep-sorted end
 
         return builder.build();
     }
diff --git a/tests/cts/hostsidetests/multidevices/uwb/test_utils/uwb_test_utils.py b/tests/cts/hostsidetests/multidevices/uwb/test_utils/uwb_test_utils.py
index 0bd419a7..411de326 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/test_utils/uwb_test_utils.py
+++ b/tests/cts/hostsidetests/multidevices/uwb/test_utils/uwb_test_utils.py
@@ -177,9 +177,26 @@ def initialize_uwb_country_code_if_not_set(
     logging.warning("Unable to force country code")
 
   # Unable to get UWB enabled even after setting country code, abort!
-  asserts.fail(
-      not verify_uwb_state_callback(
+  asserts.assert_true(
+      verify_uwb_state_callback(
           ad=ad, uwb_event="Inactive", handler=handler, timeout=120
       ),
       "Uwb is not enabled",
   )
+
+
+def request_hw_enable_if_required(
+    ad: android_device.AndroidDevice,
+):
+  """For wearable kind of devices, request UWB HW.
+
+  Without this UWB itself will not get enabled.  And the
+  tests waiting for UWB Status change would fail.
+
+  See isUwbHwIdleTurnOffEnabled and requestUwbHwEnabled.
+
+  Args:
+    ad: android device object.
+  """
+  if ad.uwb.isUwbHwIdleTurnOffEnabled():
+    ad.uwb.requestUwbHwEnabled(True)
diff --git a/tests/cts/tests/src/android/uwb/cts/UwbManagerTest.java b/tests/cts/tests/src/android/uwb/cts/UwbManagerTest.java
index d222a3e1..8e01c904 100644
--- a/tests/cts/tests/src/android/uwb/cts/UwbManagerTest.java
+++ b/tests/cts/tests/src/android/uwb/cts/UwbManagerTest.java
@@ -18,6 +18,7 @@ package android.uwb.cts;
 
 import static android.Manifest.permission.UWB_PRIVILEGED;
 import static android.Manifest.permission.UWB_RANGING;
+import static android.uwb.RangingMeasurement.NON_HYBRID_UWB_SESSION_ID;
 import static android.uwb.UwbManager.AdapterStateCallback.STATE_DISABLED;
 import static android.uwb.UwbManager.AdapterStateCallback.STATE_ENABLED_ACTIVE;
 import static android.uwb.UwbManager.AdapterStateCallback.STATE_ENABLED_HW_IDLE;
@@ -66,6 +67,7 @@ import androidx.test.filters.SmallTest;
 
 import com.android.compatibility.common.util.CddTest;
 import com.android.modules.utils.build.SdkLevel;
+import com.android.uwb.flags.Flags;
 
 import com.google.uwb.support.dltdoa.DlTDoAMeasurement;
 import com.google.uwb.support.dltdoa.DlTDoARangingRoundsUpdate;
@@ -268,10 +270,15 @@ public class UwbManagerTest {
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
     @RequiresFlagsEnabled("com.android.uwb.flags.query_timestamp_micros")
     public void testQueryUwbsTimestampMicros() {
+        assumeTrue(SdkLevel.isAtLeastV());
+        FiraProtocolVersion firaProtocolVersion =
+                getFiraSpecificationParams().getMaxMacVersionSupported();
+        assumeTrue(firaProtocolVersion.getMajor() >= 2);
+
         UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
         try {
             uiAutomation.adoptShellPermissionIdentity();
-            assertThat(mUwbManager.elapsedRealtimeResolutionNanos() >= 0L).isTrue();
+            assertThat(mUwbManager.queryUwbsTimestampMicros() > 0L).isTrue();
         } finally {
             uiAutomation.dropShellPermissionIdentity();
         }
@@ -281,8 +288,10 @@ public class UwbManagerTest {
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
     @RequiresFlagsEnabled("com.android.uwb.flags.query_timestamp_micros")
     public void testQueryUwbsTimestampMicrosPrivileged() {
+        assumeTrue(SdkLevel.isAtLeastV());
+
         try {
-            mUwbManager.elapsedRealtimeResolutionNanos();
+            mUwbManager.queryUwbsTimestampMicros();
             // should fail if the call was successful without UWB_PRIVILEGED permission.
             fail();
         } catch (SecurityException e) {
@@ -2387,4 +2396,85 @@ public class UwbManagerTest {
             uiAutomation.dropShellPermissionIdentity();
         }
     }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2,C-1-5"})
+    @RequiresFlagsEnabled("com.android.uwb.flags.uwb_fira_3_0_25q4")
+    public void testHybridUwbSession() throws Exception {
+        Assume.assumeTrue(Flags.uwbFira3025q4());
+        FiraSpecificationParams params = getFiraSpecificationParams();
+        FiraProtocolVersion firaProtocolVersion = params.getMaxMacVersionSupported();
+        // Hybrid UWB session is supported only for devices with FiRa 3.0 support.
+        assumeTrue(firaProtocolVersion.getMajor() >= 3);
+
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        CancellationSignal cancellationSignal = null;
+        CountDownLatch countDownLatch = new CountDownLatch(1);
+        CountDownLatch resultCountDownLatch = new CountDownLatch(1);
+
+        int sessionId = 1;
+        RangingSessionCallback rangingSessionCallback =
+                new RangingSessionCallback(countDownLatch, resultCountDownLatch);
+        FiraOpenSessionParams firaOpenSessionParams = new FiraOpenSessionParams.Builder()
+                .setProtocolVersion(new FiraProtocolVersion(1, 1))
+                .setSessionId(sessionId)
+                .setStsConfig(FiraParams.STS_CONFIG_STATIC)
+                .setVendorId(new byte[]{0x5, 0x6})
+                .setStaticStsIV(new byte[]{0x5, 0x6, 0x9, 0xa, 0x4, 0x6})
+                .setDeviceType(FiraParams.RANGING_DEVICE_TYPE_CONTROLLER)
+                .setDeviceRole(FiraParams.RANGING_DEVICE_ROLE_INITIATOR)
+                .setMultiNodeMode(FiraParams.MULTI_NODE_MODE_UNICAST)
+                .setDeviceAddress(UwbAddress.fromBytes(new byte[]{0x5, 6}))
+                .setDestAddressList(List.of(UwbAddress.fromBytes(new byte[]{0x5, 6})))
+                .build();
+        try {
+            // Needs UWB_PRIVILEGED & UWB_RANGING permission which is held by shell.
+            uiAutomation.adoptShellPermissionIdentity();
+            // Start ranging session
+            cancellationSignal = mUwbManager.openRangingSession(
+                    firaOpenSessionParams.toBundle(),
+                    Executors.newSingleThreadExecutor(),
+                    rangingSessionCallback,
+                    mDefaultChipId);
+            // Wait for the on opened callback.
+            assertThat(countDownLatch.await(1, TimeUnit.SECONDS)).isTrue();
+
+            countDownLatch = new CountDownLatch(1);
+            rangingSessionCallback.replaceCtrlCountDownLatch(countDownLatch);
+            rangingSessionCallback.rangingSession.start(new PersistableBundle());
+            // Wait for the on started callback.
+            assertThat(countDownLatch.await(1, TimeUnit.SECONDS)).isTrue();
+
+            // Wait for the on ranging report callback.
+            assertThat(resultCountDownLatch.await(1, TimeUnit.SECONDS)).isTrue();
+            assertThat(rangingSessionCallback.rangingReport).isNotNull();
+            RangingReport rangingReport = rangingSessionCallback.rangingReport;
+            assertThat(rangingReport.getMeasurements()).isNotNull();
+            RangingMeasurement rangingMeasurement = rangingReport.getMeasurements().get(0);
+
+            // TODO: update this.
+            assertEquals(rangingMeasurement.getHusPrimarySessionId(), NON_HYBRID_UWB_SESSION_ID);
+
+            countDownLatch = new CountDownLatch(1);
+            rangingSessionCallback.replaceCtrlCountDownLatch(countDownLatch);
+            // Stop ongoing session.
+            rangingSessionCallback.rangingSession.stop();
+
+            // Wait for on stopped callback.
+            assertThat(countDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+            assertThat(rangingSessionCallback.onStoppedCalled).isTrue();
+        } finally {
+            if (cancellationSignal != null) {
+                // Close session.
+                cancellationSignal.cancel();
+                countDownLatch = new CountDownLatch(1);
+                rangingSessionCallback.replaceCtrlCountDownLatch(countDownLatch);
+
+                // Wait for the on closed callback.
+                assertThat(countDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+                //assertThat(rangingSessionCallback.onClosedCalled).isTrue();
+            }
+            uiAutomation.dropShellPermissionIdentity();
+        }
+    }
 }
```

