```diff
diff --git a/Android.bp b/Android.bp
index 290f0368..30b74dc7 100644
--- a/Android.bp
+++ b/Android.bp
@@ -47,7 +47,6 @@ apex {
     defaults: ["t-launched-apex-module"],
     jni_libs: ["libicing"],
     prebuilts: ["current_sdkinfo"],
-    min_sdk_version: "33",
     apps: ["com.android.appsearch.apk"],
 }
 
diff --git a/TEST_MAPPING b/TEST_MAPPING
index fa0bcbb8..34b3af9a 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -1,25 +1,28 @@
 {
   "presubmit": [
     {
-      "name": "ContactsIndexerTests"
+      "name": "AppsIndexerTests"
     },
     {
-      "name": "CtsAppSearchTestCases"
+      "name": "AppSearchCoreTests"
     },
     {
-      "name": "CtsAppSearchHostTestCases"
+      "name": "AppSearchMockingServicesTests"
     },
     {
-      "name": "AppSearchCoreTests"
+      "name": "AppSearchServicesTests"
     },
     {
-      "name": "AppSearchServicesTests"
+      "name": "ContactsIndexerTests"
     },
     {
-      "name": "AppSearchMockingServicesTests"
+      "name": "CtsAppFunctionTestCases"
     },
     {
-      "name": "AppsIndexerTests"
+      "name": "CtsAppSearchTestCases"
+    },
+    {
+      "name": "CtsAppSearchHostTestCases"
     }
   ]
 }
diff --git a/apk/Android.bp b/apk/Android.bp
index e9b6a518..1693d00f 100644
--- a/apk/Android.bp
+++ b/apk/Android.bp
@@ -21,12 +21,65 @@ android_app_certificate {
     certificate: "com.android.appsearch.apk",
 }
 
+soong_config_module_type {
+    name: "appsearch_java_defaults",
+    module_type: "java_defaults",
+    config_namespace: "appsearch",
+    bool_variables: [
+        "enable_isolated_storage",
+    ],
+    properties: [
+        "jni_libs",
+    ],
+}
+
+soong_config_bool_variable {
+    name: "enable_isolated_storage",
+}
+
+appsearch_java_defaults {
+    name: "appsearch-apk-defaults",
+    sdk_version: "module_current",
+    min_sdk_version: "Tiramisu",
+    srcs: ["src/**/*.java"],
+    static_libs: [
+        "androidx.appcompat_appcompat",
+        "com.android.appsearch.isolated_storage_service.aidl-java",
+        "com.android.isolated_storage_service.aidl-java",
+        "statslog-appsearch-lib",
+    ],
+    libs: [
+        "androidx.annotation_annotation",
+        "framework-virtualization.stubs.module_lib",
+    ],
+    jni_uses_platform_apis: true,
+    use_embedded_native_libs: true,
+    apex_available: ["com.android.appsearch"],
+    soong_config_variables: {
+        enable_isolated_storage: {
+            jni_libs: ["libisolated_storage_service"],
+        },
+    },
+}
+
 android_app {
     name: "com.android.appsearch.apk",
     sdk_version: "module_current",
-    min_sdk_version: "33",
+    min_sdk_version: "Tiramisu",
     privileged: true,
     updatable: true,
     certificate: ":com.android.appsearch.apk.certificate",
+    defaults: [
+        "appsearch-apk-defaults",
+    ],
+    compile_multilib: "first",
     apex_available: ["com.android.appsearch"],
 }
+
+// A special library created strictly for use by the tests as they need the implementation library
+// but that is not available when building from prebuilts. Using a library with a different name to
+// what is used by the prebuilts ensures that this will never depend on the prebuilt.
+java_library {
+    name: "appsearch-apk-for-tests",
+    defaults: ["appsearch-apk-defaults"],
+}
diff --git a/apk/AndroidManifest.xml b/apk/AndroidManifest.xml
index b567e1ed..96738405 100644
--- a/apk/AndroidManifest.xml
+++ b/apk/AndroidManifest.xml
@@ -16,4 +16,24 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.android.appsearch.apk">
 
-</manifest>
\ No newline at end of file
+    <!-- TODO(b/359911502): Remove this permission along with the other app functionality that
+           exists in app search once the new app function implementation is done.
+         Allows system applications to execute app functions provided by apps through AppSearch. -->
+    <permission android:name="android.permission.EXECUTE_APP_FUNCTION"
+                android:protectionLevel="internal|role" />
+    <uses-permission android:name="android.permission.MANAGE_VIRTUAL_MACHINE" />
+    <uses-permission android:name="android.permission.USE_RELAXED_MICRODROID_ROLLBACK_PROTECTION" />
+    <uses-feature android:name="android.software.virtualization_framework" android:required="true" />
+    <application android:allowBackup="false">
+        <!-- Only non-decreasing ROLLBACK_INDEX value is allowed. In case of security fixes, we'll
+        increase the ROLLBACK_INDEX value to prevent rolling pVM back to old versions with lower
+        ROLLBACK_INDEX value. -->
+        <property android:name="android.system.virtualmachine.ROLLBACK_INDEX" android:value="1" />
+        <service android:name="com.android.server.appsearch.isolated_storage_service.IsolatedStorageService" android:exported="true">
+            <intent-filter>
+                <action android:name="com.android.appsearch.ISOLATED_STORAGE_SERVICE" />
+            </intent-filter>
+        </service>
+    </application>
+
+</manifest>
diff --git a/apk/aidl/Android.bp b/apk/aidl/Android.bp
new file mode 100644
index 00000000..a74d43c7
--- /dev/null
+++ b/apk/aidl/Android.bp
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+aidl_interface {
+    name: "com.android.appsearch.isolated_storage_service.aidl",
+    srcs: ["com/**/*.aidl"],
+    include_dirs: [
+        "frameworks/base/core/java", // needed for SharedMemory usage in AIDL
+    ],
+    unstable: true,
+    flags: [
+        "-Werror",
+        "-Wno-mixed-oneway",
+    ],
+    backend: {
+        java: {
+            gen_rpc: true,
+            apex_available: ["com.android.appsearch"],
+        },
+        rust: {
+            enabled: false,
+        },
+        cpp: {
+            enabled: false,
+        },
+        ndk: {
+            enabled: false,
+        },
+    },
+    min_sdk_version: "33",
+}
diff --git a/apk/aidl/com/android/server/appsearch/isolated_storage_service/IIsolatedStorageService.aidl b/apk/aidl/com/android/server/appsearch/isolated_storage_service/IIsolatedStorageService.aidl
new file mode 100644
index 00000000..b2207834
--- /dev/null
+++ b/apk/aidl/com/android/server/appsearch/isolated_storage_service/IIsolatedStorageService.aidl
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.isolated_storage_service;
+
+import android.os.ParcelFileDescriptor;
+import com.android.server.appsearch.isolated_storage_service.ServiceConfig;
+
+/**
+ * Isolated storage service.
+ *
+ * <p> This provides an isolated storage backed by a pVM for better protection. Inside the pVM, the
+ * service host the storage is isloated from the main Android operating system, and the underlying
+ * storage is encrypted.
+ */
+interface IIsolatedStorageService {
+    const int PORT = 5678;
+
+    /**
+     * Sets up the service.
+     */
+    void setup(in ServiceConfig config);
+
+    /**
+     * Gets the connection to the pVM.
+     */
+    ParcelFileDescriptor getVmConnection();
+}
diff --git a/apk/aidl/com/android/server/appsearch/isolated_storage_service/ServiceConfig.aidl b/apk/aidl/com/android/server/appsearch/isolated_storage_service/ServiceConfig.aidl
new file mode 100644
index 00000000..e47c8974
--- /dev/null
+++ b/apk/aidl/com/android/server/appsearch/isolated_storage_service/ServiceConfig.aidl
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.isolated_storage_service;
+
+/**
+ * Configs for the isolated storage service.
+ */
+parcelable ServiceConfig {
+  /**
+   * Size of pVM's memory in bytes.
+   */
+  long pVmMemoryBytes;
+
+  /** The cached value for sampling interval for all the stats. */
+  int pCachedSamplingInterval;
+
+  /** The min time interval between samples in millis */
+  long pCachedMinTimeIntervalBetweenSamplesMillis;
+}
diff --git a/apk/src/com/android/server/appsearch/isolated_storage_service/IsolatedStorageService.java b/apk/src/com/android/server/appsearch/isolated_storage_service/IsolatedStorageService.java
new file mode 100644
index 00000000..26ae6b74
--- /dev/null
+++ b/apk/src/com/android/server/appsearch/isolated_storage_service/IsolatedStorageService.java
@@ -0,0 +1,303 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.isolated_storage_service;
+
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_ERROR;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_FINISH;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_READY;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_START;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_STOP;
+
+import android.app.Service;
+import android.content.Context;
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.ParcelFileDescriptor;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.os.storage.StorageManager;
+import android.system.virtualmachine.VirtualMachine;
+import android.system.virtualmachine.VirtualMachineCallback;
+import android.system.virtualmachine.VirtualMachineConfig;
+import android.system.virtualmachine.VirtualMachineException;
+import android.system.virtualmachine.VirtualMachineManager;
+import android.util.Log;
+
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.server.appsearch.stats.IsolateStorageServiceLogger;
+import com.android.server.appsearch.stats.VMPayloadStats;
+
+import java.io.IOException;
+import java.util.Objects;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Service that provides isolated storage.
+ *
+ * <p>This services manages the pVM that hosts the isolated storage, and implements the {@link
+ * IIsolatedStorageService} interface.
+ */
+public class IsolatedStorageService extends Service {
+
+    private static final String TAG = "IsolatedStorageService";
+
+    private static final String VM_NAME = "isolated_storage_service_vm";
+    private static final String PAYLOAD_BINARY_NAME = "libisolated_storage_service.so";
+
+    private static final String SYSTEM_PROPERTY_ENABLE_DEBUG_BUILD = "ro.debuggable";
+    private static final boolean IS_DEBUG_BUILD =
+            SystemProperties.getInt(SYSTEM_PROPERTY_ENABLE_DEBUG_BUILD, /* def= */ 0) == 1;
+
+    /* Constant large storage size used for the VM's encrypted storage. The VM grows storage
+     * as needed and choosing a reasonably large storage size avoids costly storage resizing
+     * in the VM.
+     */
+    public static final long DEFAULT_ENCRYPTED_STORAGE_BYTES = 64_000_000_000L; // 64GB
+    private long mAvailableStorageBytes = DEFAULT_ENCRYPTED_STORAGE_BYTES;
+
+    private final ExecutorService mExecutorService = Executors.newFixedThreadPool(1);
+    private final IsolatedStorageServiceStub mIsolatedStorageServiceStub =
+            new IsolatedStorageServiceStub();
+
+    private VirtualMachine mVm;
+
+    /* Gets the size of the IsolatedStorageService encrypted storage. Set the size to the
+     * maximum number of bytes the app can allocate based on available device space.
+     */
+    private long getEncryptedStorageBytes() {
+        // mAvailableStorageBytes is initialized with the default storage value. Only query the
+        // storageManager if we have not done so before or a previous query failed.
+        if (mAvailableStorageBytes != DEFAULT_ENCRYPTED_STORAGE_BYTES) {
+            return mAvailableStorageBytes;
+        }
+
+        // Query the storageManager to determine the amount of space the app can allocate on device.
+        Context context = this.getApplicationContext();
+        StorageManager storageManager = context.getSystemService(StorageManager.class);
+        try {
+            UUID appInternalDir = storageManager.getUuidForPath(context.getFilesDir());
+            mAvailableStorageBytes = storageManager.getAllocatableBytes(appInternalDir);
+            Log.i(TAG, "Setting encrypted storage size to " + mAvailableStorageBytes + " bytes.");
+        } catch (IOException e) {
+            Log.i(TAG, "Setting encrypted storage size to " + mAvailableStorageBytes + " bytes.");
+        }
+        return mAvailableStorageBytes;
+    }
+
+    @Override
+    public void onCreate() {
+        Log.i(TAG, "onCreate.");
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        Log.i(TAG, "onStartCommand. flags = " + flags + ", startId = " + startId);
+        return START_STICKY;
+    }
+
+    private CompletableFuture<Void> startVm(ServiceConfig config) {
+        CompletableFuture<Void> future = new CompletableFuture<>();
+        mVm = maybeCreateVm(config);
+        if (mVm == null) {
+            Log.e(TAG, "Unable to create/get VirtualMachine");
+            future.cancel(/* mayInterruptIfRunning= */ true);
+            return future;
+        }
+        IsolateStorageServiceLogger logger = new IsolateStorageServiceLogger(config);
+        VmCallback vmCallback = new VmCallback(future, logger);
+        mVm.setCallback(mExecutorService, vmCallback);
+        try {
+            mVm.run();
+        } catch (VirtualMachineException e) {
+            Log.e(TAG, "Failed to run " + VM_NAME, e);
+        }
+        return future;
+    }
+
+    /**
+     * Tries to create the VM.
+     *
+     * <p>If the VM already exists, return it. If the VM doesn't exist or is deleted, create a new
+     * VM and return it. Return {@code null} if failed to get or create the VM.
+     */
+    private @Nullable VirtualMachine maybeCreateVm(ServiceConfig config) {
+        VirtualMachineManager vmm = getSystemService(VirtualMachineManager.class);
+        if (vmm == null) {
+            Log.e(TAG, "Unable to get VirtualMachineManager");
+            return null;
+        }
+        VirtualMachine vm = null;
+        try {
+            vm = vmm.get(VM_NAME);
+        } catch (VirtualMachineException e) {
+            Log.e(TAG, "VirtualMachineManager#get failed", e);
+        }
+        if (vm != null && vm.getStatus() != VirtualMachine.STATUS_DELETED) {
+            return vm;
+        }
+        if (vm == null) {
+            Log.i(TAG, "Virtual machine " + VM_NAME + " does not exist. Creating one");
+        } else {
+            Log.i(TAG, "Virtual machine " + VM_NAME + " is deleted. Creating one");
+        }
+        return createVm(vmm, config);
+    }
+
+    private @Nullable VirtualMachine createVm(
+            VirtualMachineManager vmm, ServiceConfig serviceConfig) {
+        final int vmDebugLevel =
+                IS_DEBUG_BUILD
+                        ? VirtualMachineConfig.DEBUG_LEVEL_FULL
+                        : VirtualMachineConfig.DEBUG_LEVEL_NONE;
+        try {
+            VirtualMachineConfig config =
+                    new VirtualMachineConfig.Builder(this)
+                            .setPayloadBinaryName(PAYLOAD_BINARY_NAME)
+                            .setProtectedVm(true)
+                            .setDebugLevel(vmDebugLevel)
+                            // Set the maximum size of the VM encrypted storage. Storage is
+                            // allocated on an as needed basis.
+                            .setEncryptedStorageBytes(getEncryptedStorageBytes())
+                            .setMemoryBytes(serviceConfig.pVmMemoryBytes)
+                            .setCpuTopology(VirtualMachineConfig.CPU_TOPOLOGY_ONE_CPU)
+                            .setShouldUseHugepages(true)
+                            .build();
+            try {
+                return vmm.create(VM_NAME, config);
+            } catch (VirtualMachineException e) {
+                Log.e(TAG, "Failed to create virtual machine " + VM_NAME, e);
+                return null;
+            }
+        } catch (IllegalArgumentException
+                | IllegalStateException
+                | UnsupportedOperationException e) {
+            Log.e(TAG, "Failed to create virtual machine config " + VM_NAME, e);
+            return null;
+        }
+    }
+
+    /** Callbacks for pVM status changes. */
+    private class VmCallback implements VirtualMachineCallback {
+
+        private final CompletableFuture<Void> mFuture;
+        private final IsolateStorageServiceLogger mLogger;
+
+        VmCallback(@NonNull CompletableFuture<Void> future, IsolateStorageServiceLogger logger) {
+            mFuture = Objects.requireNonNull(future);
+            mLogger = Objects.requireNonNull(logger);
+        }
+
+        @Override
+        public void onPayloadStarted(VirtualMachine vm) {
+            Log.i(TAG, "Payload started");
+            VMPayloadStats stats = new VMPayloadStats.Builder(CALLBACK_TYPE_START).build();
+            mLogger.logStats(stats);
+        }
+
+        @Override
+        public void onPayloadReady(VirtualMachine vm) {
+            Log.i(TAG, "Payload ready");
+            mFuture.complete(null);
+            VMPayloadStats stats = new VMPayloadStats.Builder(CALLBACK_TYPE_READY).build();
+            mLogger.logStats(stats);
+        }
+
+        @Override
+        public void onPayloadFinished(VirtualMachine vm, int exitCode) {
+            Log.i(TAG, "Payload finished. Code: " + exitCode);
+            VMPayloadStats stats =
+                    new VMPayloadStats.Builder(CALLBACK_TYPE_FINISH).setExitCode(exitCode).build();
+            mLogger.logStats(stats);
+        }
+
+        @Override
+        public void onError(VirtualMachine vm, int errorCode, String errorMessage) {
+            Log.e(TAG, "Error " + VM_NAME + " code : " + errorCode + " msg : " + errorMessage);
+            VMPayloadStats stats =
+                    new VMPayloadStats.Builder(CALLBACK_TYPE_ERROR).setErrorCode(errorCode).build();
+            mLogger.logStats(stats);
+        }
+
+        @Override
+        public void onStopped(VirtualMachine vm, int stopReason) {
+            Log.w(TAG, VM_NAME + " stopped, reason : " + stopReason);
+            VMPayloadStats stats =
+                    new VMPayloadStats.Builder(CALLBACK_TYPE_STOP)
+                            .setStopReason(stopReason)
+                            .build();
+            mLogger.logStats(stats);
+        }
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        // TODO: b/384768541 - ensure only AppSearch can bind to this service.
+        return mIsolatedStorageServiceStub.asBinder();
+    }
+
+    /** Implementation of the {@link IIsolatedStorageService}. */
+    private class IsolatedStorageServiceStub extends IIsolatedStorageService.Stub {
+        private static final int PAYLOAD_READY_WAIT_TIMEOUT_SECONDS = 15;
+
+        @GuardedBy("mConfigLocked")
+        private final AtomicReference<ServiceConfig> mConfigLocked = new AtomicReference<>();
+
+        @Override
+        public void setup(ServiceConfig config) throws RemoteException {
+            Objects.requireNonNull(config);
+            synchronized (mConfigLocked) {
+                if (mConfigLocked.get() != null) {
+                    Log.w(TAG, "Service already set up");
+                    return;
+                }
+                mConfigLocked.set(config);
+                try {
+                    startVm(config).get(PAYLOAD_READY_WAIT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
+                } catch (Exception e) {
+                    Log.e(TAG, "Unable to wait for payload ready", e);
+                    throw new RemoteException(e.getMessage());
+                }
+            }
+        }
+
+        @Override
+        public ParcelFileDescriptor getVmConnection() throws RemoteException {
+            synchronized (mConfigLocked) {
+                if (mConfigLocked.get() == null) {
+                    throw new RemoteException("Service not set up yet");
+                }
+                if (mVm == null) {
+                    throw new RemoteException("pVM payload is not ready/available");
+                }
+                try {
+                    return mVm.connectVsock(
+                            com.android.isolated_storage_service.IIsolatedStorageService.PORT);
+                } catch (Exception e) {
+                    Log.e(TAG, "Unable to connect vsock", e);
+                    throw new RemoteException(e.getMessage());
+                }
+            }
+        }
+    }
+}
diff --git a/apk/src/com/android/server/appsearch/stats/IsolateStorageServiceLogger.java b/apk/src/com/android/server/appsearch/stats/IsolateStorageServiceLogger.java
new file mode 100644
index 00000000..8dec12f0
--- /dev/null
+++ b/apk/src/com/android/server/appsearch/stats/IsolateStorageServiceLogger.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.stats;
+
+import static com.android.server.appsearch.stats.VMPayloadStats.PAYLOAD_CALLBACK_TYPE_SIZE;
+
+import android.os.SystemClock;
+
+import androidx.annotation.GuardedBy;
+import androidx.annotation.VisibleForTesting;
+
+import com.android.server.appsearch.isolated_storage_service.ServiceConfig;
+
+import org.jspecify.annotations.NonNull;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Random;
+
+/**
+ * Logger Implementation for pushed atoms.
+ *
+ * <p>This class is thread-safe.
+ *
+ * @hide
+ */
+public class IsolateStorageServiceLogger {
+
+    private static final Random sRng = new Random();
+
+    /** Elapsed time for last stats logged from boot in millis */
+    @GuardedBy("mLock")
+    private long mLastPushTimeMillisLocked = 0;
+
+    /**
+     * The List to track how many stats we skipped due to {@link
+     * ServiceConfig#pCachedSamplingInterval()}.
+     *
+     * <p>We can have correct extrapolated number by adding those counts back when we log the same
+     * type of stats next time. E.g. the true count of an event could be estimated as:
+     * SUM(sampling_interval * (num_skipped_sample + 1)) as est_count
+     *
+     * <p>The key to the SparseArray is {@link VMPayloadStats.PayloadCallbackType}
+     */
+    @GuardedBy("mLock")
+    @VisibleForTesting
+    final List<Integer> mSkippedSampleCountLocked = new ArrayList(PAYLOAD_CALLBACK_TYPE_SIZE);
+
+    // Manager holding the configuration flags
+    private final ServiceConfig mConfig;
+
+    private final Object mLock = new Object();
+
+    /** Creates the {@link IsolateStorageServiceLogger} instance. */
+    public IsolateStorageServiceLogger(@NonNull ServiceConfig config) {
+        Objects.requireNonNull(config);
+        mConfig = config;
+        // preload the mSkippedSampleCountLocked.
+        for (int i = 0; i < PAYLOAD_CALLBACK_TYPE_SIZE; i++) {
+            mSkippedSampleCountLocked.add(0);
+        }
+    }
+
+    /** Push the given {@link VMPayloadStats} to services. */
+    public void logStats(@NonNull VMPayloadStats stats) {
+        Objects.requireNonNull(stats);
+        synchronized (mLock) {
+            if (shouldLogForTypeLocked(stats.getCallbackType())) {
+                mLastPushTimeMillisLocked = SystemClock.elapsedRealtime();
+                int skippedSampleCount = mSkippedSampleCountLocked.get(stats.getCallbackType());
+                mSkippedSampleCountLocked.set(stats.getCallbackType(), 0);
+                // ignore close exception
+                AppSearchStatsLog.write(
+                        AppSearchStatsLog.APP_SEARCH_VM_PAYLOAD_STATS_REPORTED,
+                        mConfig.pCachedSamplingInterval,
+                        skippedSampleCount,
+                        stats.getCallbackType(),
+                        stats.getErrorCode(),
+                        stats.getExitCode(),
+                        stats.getStopReason());
+            }
+        }
+    }
+
+    /**
+     * Checks if this stats should be logged.
+     *
+     * <p>It won't be logged if it is "sampled" out, or it is too close to the previous logged
+     * stats.
+     */
+    @GuardedBy("mLock")
+    @VisibleForTesting
+    boolean shouldLogForTypeLocked(@VMPayloadStats.PayloadCallbackType int callbackType) {
+        int samplingInterval = mConfig.pCachedSamplingInterval;
+        // Sampling
+        if (!shouldSample(samplingInterval)) {
+            return false;
+        }
+
+        // Rate limiting
+        // Check the timestamp to see if it is too close to last logged sample
+        long currentTimeMillis = SystemClock.elapsedRealtime();
+        if (mLastPushTimeMillisLocked
+                > currentTimeMillis - mConfig.pCachedMinTimeIntervalBetweenSamplesMillis) {
+            int count = mSkippedSampleCountLocked.get(callbackType);
+            ++count;
+            mSkippedSampleCountLocked.set(callbackType, count);
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Checks if the stats should be sampled for logging based on the provided sampling interval.
+     *
+     * <p>The probability of sampling is 1/samplingInterval. For example:
+     *
+     * <ul>
+     *   <li>If the samplingInterval is 1, all stats will be sampled (100% sampling).
+     *   <li>If the samplingInterval is 10, 1 in 10 stats will be sampled (10% sampling).
+     * </ul>
+     *
+     * @param samplingInterval the interval used to calculate the sampling probability.
+     * @return true if the stats should be sampled, false otherwise.
+     */
+    private static boolean shouldSample(int samplingInterval) {
+        if (samplingInterval <= 0) {
+            return false;
+        }
+
+        return sRng.nextInt(samplingInterval) == 0;
+    }
+}
diff --git a/apk/src/com/android/server/appsearch/stats/VMPayloadStats.java b/apk/src/com/android/server/appsearch/stats/VMPayloadStats.java
new file mode 100644
index 00000000..97304c10
--- /dev/null
+++ b/apk/src/com/android/server/appsearch/stats/VMPayloadStats.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.stats;
+
+import androidx.annotation.IntDef;
+
+import org.jspecify.annotations.NonNull;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Represents statistics related to a VM payload execution. This class captures information about
+ * the lifecycle of a payload execution, including callback types, exit codes, error codes, and stop
+ * reasons.
+ *
+ * @hide
+ */
+public class VMPayloadStats {
+    /** Call types for the VM payload execution. */
+    @IntDef(
+            value = {
+                CALLBACK_TYPE_UNKNOWN,
+                CALLBACK_TYPE_START,
+                CALLBACK_TYPE_READY,
+                CALLBACK_TYPE_FINISH,
+                CALLBACK_TYPE_ERROR,
+                CALLBACK_TYPE_STOP,
+            })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface PayloadCallbackType {}
+
+    /** Represents an unknown callback type. */
+    public static final int CALLBACK_TYPE_UNKNOWN = 0;
+
+    /** Represents the start of the payload execution. */
+    public static final int CALLBACK_TYPE_START = 1;
+
+    /** Represents the payload being ready for execution. */
+    public static final int CALLBACK_TYPE_READY = 2;
+
+    /** Represents the successful completion of the payload execution. */
+    public static final int CALLBACK_TYPE_FINISH = 3;
+
+    /** Represents an error during the payload execution. */
+    public static final int CALLBACK_TYPE_ERROR = 4;
+
+    /** Represents the stopping of the payload execution. */
+    public static final int CALLBACK_TYPE_STOP = 5;
+
+    /** The last callback type represents the number of callback types. */
+    public static final int PAYLOAD_CALLBACK_TYPE_SIZE = CALLBACK_TYPE_STOP + 1;
+
+    /** The callback type of the payload execution. */
+    @PayloadCallbackType private final int mCallbackType;
+
+    /**
+     * The exit code of the payload execution. {@code
+     * IsolateStorageService.VmCallback#onPayloadFinished}.
+     */
+    private final int mExitCode;
+
+    /** The error code of the payload execution {@code IsolateStorageService.VmCallback#onError}. */
+    private final int mErrorCode;
+
+    /**
+     * The reason for stopping the payload execution in {@code
+     * IsolateStorageService.VmCallback#onStop}.
+     */
+    private final int mStopReason;
+
+    /**
+     * Constructs a new {@link VMPayloadStats} object using the provided builder.
+     *
+     * @param builder The builder containing the statistics.
+     */
+    VMPayloadStats(@NonNull Builder builder) {
+        mCallbackType = builder.mCallbackType;
+        mExitCode = builder.mExitCode;
+        mErrorCode = builder.mErrorCode;
+        mStopReason = builder.mStopReason;
+    }
+
+    /** Returns the callback type of the payload execution. */
+    public int getCallbackType() {
+        return mCallbackType;
+    }
+
+    /** Returns the exit code of the payload execution. */
+    public int getExitCode() {
+        return mExitCode;
+    }
+
+    /** Returns the error code of the payload execution. */
+    public int getErrorCode() {
+        return mErrorCode;
+    }
+
+    /** Returns the reason for stopping the payload execution. */
+    public int getStopReason() {
+        return mStopReason;
+    }
+
+    /** Builder for {@link VMPayloadStats}. */
+    public static class Builder {
+        int mCallbackType;
+        int mExitCode;
+        int mErrorCode;
+        int mStopReason;
+
+        /** Constructs a new {@link Builder} with the specified callback type. */
+        public Builder(@PayloadCallbackType int callbackType) {
+            mCallbackType = callbackType;
+        }
+
+        /** Sets the exit code of the payload execution. */
+        public @NonNull Builder setExitCode(int exitCode) {
+            mExitCode = exitCode;
+            return this;
+        }
+
+        /** Sets the error code of the payload execution. */
+        public @NonNull Builder setErrorCode(int errorCode) {
+            mErrorCode = errorCode;
+            return this;
+        }
+
+        /** Sets the reason for stopping the payload execution. */
+        public @NonNull Builder setStopReason(int stopReason) {
+            mStopReason = stopReason;
+            return this;
+        }
+
+        /** Builds a new {@link VMPayloadStats} object. */
+        public VMPayloadStats build() {
+            return new VMPayloadStats(/* builder= */ this);
+        }
+    }
+}
diff --git a/flags/appsearch.aconfig b/flags/appsearch.aconfig
index 42b32fdb..457ab81e 100644
--- a/flags/appsearch.aconfig
+++ b/flags/appsearch.aconfig
@@ -1,9 +1,10 @@
 package: "com.android.appsearch.flags"
 container: "com.android.appsearch"
 
-#
-# all the flags we are adding in V have to be is_fixed_read_only true.
-#
+# Mainline flags had to be is_fixed_read_only in the past but this is no longer true in Android B+
+# Flags going forward can be created read-write by leaving out is_fixed_read_only.
+# Note, trunk stable does NOT support changing flags from read-only to read-write or vice versa.
+# If you want to change a flag's read type, a new flag must be created.
 
 flag {
     name: "enable_safe_parcelable_2"
@@ -320,3 +321,169 @@ flag {
     is_fixed_read_only: true
     is_exported: true
 }
+
+flag {
+    name: "enable_check_contacts_indexer_delta_timestamps"
+    namespace: "appsearch"
+    description: "Enables checking Contacts Indexer delta timestamps before delta updates."
+    bug: "329108459"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_four_hour_min_time_optimize_threshold"
+    namespace: "appsearch"
+    description: "Sets the minimum time interval threshold between successive optimize calls to 4 hours."
+    bug: "385020106"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_apps_indexer_check_prior_attempt"
+    namespace: "appsearch"
+    description: "Enables a check that prevents apps indexer running too soon after a prior sync."
+    bug: "385197463"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_check_contacts_indexer_update_job_params"
+    namespace: "appsearch"
+    description: "Enables checking Contacts Indexer update job params on boot and rescheduling if the job params do not match the expected."
+    bug: "384773430"
+    is_exported: true
+}
+
+flag {
+    name: "enable_app_open_events_indexer_check_prior_attempt"
+    namespace: "appsearch"
+    description: "Enables a check that prevents app open events indexer running too soon after a prior sync."
+    bug: "385197463"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_all_package_indexing_on_indexer_update"
+    namespace: "appsearch"
+    description: "Enables the all package indexing when app indexer is updated."
+    bug: "389034742"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_isolated_storage"
+    namespace: "appsearch"
+    description: "Uses isolated storage for user data."
+    bug: "384768541"
+    is_exported: true
+}
+
+flag {
+    name: "enable_recovery_proof_persistence"
+    namespace: "appsearch"
+    description: "Whether mutations should call persistToDisk with RECOVERY_PROOF (true) or LITE (false)"
+    bug: "352556856"
+    is_exported: true
+}
+
+flag {
+    name: "enable_schema_description"
+    namespace: "appsearch"
+    description: "Enable getDescription and related builders."
+    bug: "326987971"
+    is_exported: true
+}
+
+flag {
+    name: "enable_app_search_manage_blob_files"
+    namespace: "appsearch"
+    description: "Enable AppSearch to manage blob files."
+    bug: "392140774"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_calculate_time_since_last_attempted_optimize"
+    namespace: "appsearch"
+    description: "Enable time since last optimize to be calculated by last attempted optimize run time instead of last successful optimize run time."
+    bug: "385189503"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_qualified_id_join_index_v3"
+    namespace: "appsearch"
+    description: "Enable qualified id join index v3."
+    bug: "376913014"
+    is_exported: true
+}
+
+flag {
+    name: "enable_soft_index_restoration"
+    namespace: "appsearch"
+    description: "Enable soft index restoration."
+    bug: "384947619"
+    is_exported: true
+}
+
+flag {
+    name: "enable_marker_file_for_optimize"
+    namespace: "appsearch"
+    description: "Enable marker file creation for Optimize API."
+    bug: "385021899"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_release_backup_schema_file_if_overlay_present"
+    namespace: "appsearch"
+    description: "Enable releasing the backup schema file instance in the schema store if the overlay schema instance exists."
+    bug: "396436137"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_embedding_match_info"
+    namespace: "appsearch"
+    description: "Enables the option to retrieve embedding match info during snippetting."
+    bug: "395128139"
+    is_exported: true
+}
+
+flag {
+    name: "enable_batch_put"
+    namespace: "appsearch"
+    description: "Uses the new batch put API from Icing."
+    bug: "394875109"
+    is_exported: true
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
diff --git a/framework/Android.bp b/framework/Android.bp
index 0b2b7821..fdbab839 100644
--- a/framework/Android.bp
+++ b/framework/Android.bp
@@ -58,6 +58,7 @@ java_sdk_library {
     sdk_version: "module_current",
     min_sdk_version: "Tiramisu",
     libs: [
+        "jspecify",
         "unsupportedappusage",
     ],
     static_libs: [
@@ -69,12 +70,20 @@ java_sdk_library {
         enabled: true,
         optimize: true,
         shrink: true,
+        // Enable R8 compat mode. R8 full mode implicitly adds -allowaccessmodification,
+        // which may cause non-public fields and methods to become public.
+        proguard_compatibility: true,
         proguard_flags_files: ["proguard.flags"],
     },
     plugins: [
         "safeparcel-annotation-processor",
     ],
     defaults: ["framework-module-defaults"],
+    // WARNING: As part of the boot classpath, this framework target's permitted
+    // packages list should *only* contain packages that are entirely and
+    // exclusively owned by this module. Do not add additional packages
+    // (including any packages for dependencies) without first consulting
+    // mainline/API owners.
     permitted_packages: [
         "android.app.appsearch",
     ],
diff --git a/framework/api/current.txt b/framework/api/current.txt
index 8d1afe99..feb8a11f 100644
--- a/framework/api/current.txt
+++ b/framework/api/current.txt
@@ -61,13 +61,12 @@ package android.app.appsearch {
     field public static final int RESULT_OUT_OF_SPACE = 5; // 0x5
     field @FlaggedApi("com.android.appsearch.flags.enable_result_denied_and_result_rate_limited") public static final int RESULT_RATE_LIMITED = 10; // 0xa
     field public static final int RESULT_SECURITY_ERROR = 8; // 0x8
-    field @FlaggedApi("com.android.appsearch.flags.enable_app_functions") public static final int RESULT_TIMED_OUT = 11; // 0xb
     field public static final int RESULT_UNKNOWN_ERROR = 1; // 0x1
   }
 
   public final class AppSearchSchema implements android.os.Parcelable {
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public String getDescription();
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public String getDescription();
     method @FlaggedApi("com.android.appsearch.flags.enable_get_parent_types_and_indexable_nested_properties") @NonNull public java.util.List<java.lang.String> getParentTypes();
     method @NonNull public java.util.List<android.app.appsearch.AppSearchSchema.PropertyConfig> getProperties();
     method @NonNull public String getSchemaType();
@@ -82,7 +81,7 @@ package android.app.appsearch {
     ctor public AppSearchSchema.BlobHandlePropertyConfig.Builder(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.BlobHandlePropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.BlobHandlePropertyConfig.Builder setCardinality(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.BlobHandlePropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public android.app.appsearch.AppSearchSchema.BlobHandlePropertyConfig.Builder setDescription(@NonNull String);
   }
 
   public static final class AppSearchSchema.BooleanPropertyConfig extends android.app.appsearch.AppSearchSchema.PropertyConfig {
@@ -93,7 +92,7 @@ package android.app.appsearch {
     ctor public AppSearchSchema.BooleanPropertyConfig.Builder(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.BooleanPropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.BooleanPropertyConfig.Builder setCardinality(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.BooleanPropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public android.app.appsearch.AppSearchSchema.BooleanPropertyConfig.Builder setDescription(@NonNull String);
     method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") @NonNull public android.app.appsearch.AppSearchSchema.BooleanPropertyConfig.Builder setScoringEnabled(boolean);
   }
 
@@ -105,7 +104,7 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.AppSearchSchema build();
     method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.AppSearchSchema.Builder clearParentTypes();
     method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.AppSearchSchema.Builder clearProperties();
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public android.app.appsearch.AppSearchSchema.Builder setDescription(@NonNull String);
     method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.AppSearchSchema.Builder setSchemaType(@NonNull String);
   }
 
@@ -116,7 +115,7 @@ package android.app.appsearch {
     ctor public AppSearchSchema.BytesPropertyConfig.Builder(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.BytesPropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.BytesPropertyConfig.Builder setCardinality(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.BytesPropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public android.app.appsearch.AppSearchSchema.BytesPropertyConfig.Builder setDescription(@NonNull String);
   }
 
   public static final class AppSearchSchema.DocumentPropertyConfig extends android.app.appsearch.AppSearchSchema.PropertyConfig {
@@ -133,7 +132,7 @@ package android.app.appsearch {
     method @FlaggedApi("com.android.appsearch.flags.enable_get_parent_types_and_indexable_nested_properties") @NonNull public android.app.appsearch.AppSearchSchema.DocumentPropertyConfig.Builder addIndexableNestedPropertyPaths(@NonNull java.util.Collection<android.app.appsearch.PropertyPath>);
     method @NonNull public android.app.appsearch.AppSearchSchema.DocumentPropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.DocumentPropertyConfig.Builder setCardinality(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.DocumentPropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public android.app.appsearch.AppSearchSchema.DocumentPropertyConfig.Builder setDescription(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.DocumentPropertyConfig.Builder setShouldIndexNestedProperties(boolean);
   }
 
@@ -145,7 +144,7 @@ package android.app.appsearch {
     ctor public AppSearchSchema.DoublePropertyConfig.Builder(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.DoublePropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.DoublePropertyConfig.Builder setCardinality(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.DoublePropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public android.app.appsearch.AppSearchSchema.DoublePropertyConfig.Builder setDescription(@NonNull String);
     method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") @NonNull public android.app.appsearch.AppSearchSchema.DoublePropertyConfig.Builder setScoringEnabled(boolean);
   }
 
@@ -162,7 +161,7 @@ package android.app.appsearch {
     ctor public AppSearchSchema.EmbeddingPropertyConfig.Builder(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig.Builder setCardinality(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig.Builder setDescription(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig.Builder setIndexingType(int);
     method @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_quantization") @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig.Builder setQuantizationType(int);
   }
@@ -178,14 +177,14 @@ package android.app.appsearch {
     ctor public AppSearchSchema.LongPropertyConfig.Builder(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig.Builder setCardinality(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig.Builder setDescription(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig.Builder setIndexingType(int);
     method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig.Builder setScoringEnabled(boolean);
   }
 
   public abstract static class AppSearchSchema.PropertyConfig {
     method public int getCardinality();
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public String getDescription();
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public String getDescription();
     method @NonNull public String getName();
     field public static final int CARDINALITY_OPTIONAL = 2; // 0x2
     field public static final int CARDINALITY_REPEATED = 1; // 0x1
@@ -215,7 +214,7 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setCardinality(int);
     method @FlaggedApi("com.android.appsearch.flags.enable_delete_propagation_type") @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setDeletePropagationType(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_description") @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setDescription(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setIndexingType(int);
     method @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setJoinableValueType(int);
     method @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setTokenizerType(int);
@@ -567,8 +566,19 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.SearchResult.Builder setRankingSignal(double);
   }
 
+  @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") public static final class SearchResult.EmbeddingMatchInfo implements android.os.Parcelable {
+    ctor public SearchResult.EmbeddingMatchInfo(double, int, int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") public int getEmbeddingSearchMetricType();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") public int getQueryEmbeddingVectorIndex();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") public double getSemanticScore();
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.SearchResult.EmbeddingMatchInfo> CREATOR;
+  }
+
   public static final class SearchResult.MatchInfo implements android.os.Parcelable {
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @Nullable public android.app.appsearch.SearchResult.EmbeddingMatchInfo getEmbeddingMatch();
     method @NonNull public CharSequence getExactMatch();
     method @NonNull public android.app.appsearch.SearchResult.MatchRange getExactMatchRange();
     method @NonNull public String getFullText();
@@ -578,6 +588,7 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.SearchResult.MatchRange getSnippetRange();
     method @NonNull public CharSequence getSubmatch();
     method @NonNull public android.app.appsearch.SearchResult.MatchRange getSubmatchRange();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @Nullable public android.app.appsearch.SearchResult.TextMatchInfo getTextMatch();
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public void writeToParcel(@NonNull android.os.Parcel, int);
     field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.SearchResult.MatchInfo> CREATOR;
   }
@@ -585,6 +596,7 @@ package android.app.appsearch {
   public static final class SearchResult.MatchInfo.Builder {
     ctor public SearchResult.MatchInfo.Builder(@NonNull String);
     method @NonNull public android.app.appsearch.SearchResult.MatchInfo build();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public android.app.appsearch.SearchResult.MatchInfo.Builder setEmbeddingMatch(@Nullable android.app.appsearch.SearchResult.EmbeddingMatchInfo);
     method @NonNull public android.app.appsearch.SearchResult.MatchInfo.Builder setExactMatchRange(@NonNull android.app.appsearch.SearchResult.MatchRange);
     method @NonNull public android.app.appsearch.SearchResult.MatchInfo.Builder setSnippetRange(@NonNull android.app.appsearch.SearchResult.MatchRange);
     method @NonNull public android.app.appsearch.SearchResult.MatchInfo.Builder setSubmatchRange(@NonNull android.app.appsearch.SearchResult.MatchRange);
@@ -596,6 +608,20 @@ package android.app.appsearch {
     method public int getStart();
   }
 
+  @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") public static final class SearchResult.TextMatchInfo implements android.os.Parcelable {
+    ctor public SearchResult.TextMatchInfo(int, int, int, int, int, int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public CharSequence getExactMatch();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public android.app.appsearch.SearchResult.MatchRange getExactMatchRange();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public String getFullText();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public CharSequence getSnippet();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public android.app.appsearch.SearchResult.MatchRange getSnippetRange();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public CharSequence getSubmatch();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public android.app.appsearch.SearchResult.MatchRange getSubmatchRange();
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.SearchResult.TextMatchInfo> CREATOR;
+  }
+
   public class SearchResults implements java.io.Closeable {
     method public void close();
     method public void getNextPage(@NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<java.util.List<android.app.appsearch.SearchResult>>>);
@@ -634,6 +660,7 @@ package android.app.appsearch {
     method public boolean isNumericSearchEnabled();
     method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") public boolean isScorablePropertyRankingEnabled();
     method public boolean isVerbatimSearchEnabled();
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") public boolean shouldRetrieveEmbeddingMatchInfos();
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public void writeToParcel(@NonNull android.os.Parcel, int);
     field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.SearchSpec> CREATOR;
     field @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") public static final int EMBEDDING_SEARCH_METRIC_TYPE_COSINE = 1; // 0x1
@@ -710,6 +737,7 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.SearchSpec.Builder setRankingStrategy(@NonNull String);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setResultCountPerPage(@IntRange(from=0, to=0x2710) int);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setResultGrouping(int, int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public android.app.appsearch.SearchSpec.Builder setRetrieveEmbeddingMatchInfos(boolean);
     method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") @NonNull public android.app.appsearch.SearchSpec.Builder setScorablePropertyRankingEnabled(boolean);
     method @FlaggedApi("com.android.appsearch.flags.enable_search_spec_set_search_source_log_tag") @NonNull public android.app.appsearch.SearchSpec.Builder setSearchSourceLogTag(@NonNull String);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setSnippetCount(@IntRange(from=0, to=0x2710) int);
@@ -853,8 +881,8 @@ package android.app.appsearch {
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
     method public int getAliveDocumentsCount();
     method public int getAliveNamespacesCount();
-    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public int getBlobCount();
-    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public long getBlobSizeBytes();
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public int getBlobsCount();
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public long getBlobsSizeBytes();
     method public long getSizeBytes();
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public void writeToParcel(@NonNull android.os.Parcel, int);
     field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.StorageInfo> CREATOR;
@@ -865,8 +893,8 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.StorageInfo build();
     method @NonNull public android.app.appsearch.StorageInfo.Builder setAliveDocumentsCount(int);
     method @NonNull public android.app.appsearch.StorageInfo.Builder setAliveNamespacesCount(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") @NonNull public android.app.appsearch.StorageInfo.Builder setBlobCount(int);
-    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") @NonNull public android.app.appsearch.StorageInfo.Builder setBlobSizeBytes(long);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") @NonNull public android.app.appsearch.StorageInfo.Builder setBlobsCount(int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") @NonNull public android.app.appsearch.StorageInfo.Builder setBlobsSizeBytes(long);
     method @NonNull public android.app.appsearch.StorageInfo.Builder setSizeBytes(long);
   }
 
@@ -950,9 +978,9 @@ package android.app.appsearch.ast.operators {
     ctor public PropertyRestrictNode(@NonNull android.app.appsearch.PropertyPath, @NonNull android.app.appsearch.ast.Node);
     method @NonNull public android.app.appsearch.ast.Node getChild();
     method @NonNull public java.util.List<android.app.appsearch.ast.Node> getChildren();
-    method @NonNull public android.app.appsearch.PropertyPath getProperty();
+    method @NonNull public android.app.appsearch.PropertyPath getPropertyPath();
     method public void setChild(@NonNull android.app.appsearch.ast.Node);
-    method public void setProperty(@NonNull android.app.appsearch.PropertyPath);
+    method public void setPropertyPath(@NonNull android.app.appsearch.PropertyPath);
   }
 
 }
@@ -969,27 +997,27 @@ package android.app.appsearch.ast.query {
   @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class HasPropertyNode implements android.app.appsearch.ast.FunctionNode {
     ctor public HasPropertyNode(@NonNull android.app.appsearch.PropertyPath);
     method @NonNull public String getFunctionName();
-    method @NonNull public android.app.appsearch.PropertyPath getProperty();
-    method public void setProperty(@NonNull android.app.appsearch.PropertyPath);
+    method @NonNull public android.app.appsearch.PropertyPath getPropertyPath();
+    method public void setPropertyPath(@NonNull android.app.appsearch.PropertyPath);
   }
 
   @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class PropertyDefinedNode implements android.app.appsearch.ast.FunctionNode {
     ctor public PropertyDefinedNode(@NonNull android.app.appsearch.PropertyPath);
     method @NonNull public String getFunctionName();
-    method @NonNull public android.app.appsearch.PropertyPath getProperty();
-    method public void setProperty(@NonNull android.app.appsearch.PropertyPath);
+    method @NonNull public android.app.appsearch.PropertyPath getPropertyPath();
+    method public void setPropertyPath(@NonNull android.app.appsearch.PropertyPath);
   }
 
   @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class SearchNode implements android.app.appsearch.ast.FunctionNode {
     ctor public SearchNode(@NonNull android.app.appsearch.ast.Node, @NonNull java.util.List<android.app.appsearch.PropertyPath>);
     ctor public SearchNode(@NonNull android.app.appsearch.ast.Node);
-    method public void addProperty(@NonNull android.app.appsearch.PropertyPath);
+    method public void addPropertyPath(@NonNull android.app.appsearch.PropertyPath);
     method @NonNull public android.app.appsearch.ast.Node getChild();
     method @NonNull public java.util.List<android.app.appsearch.ast.Node> getChildren();
     method @NonNull public String getFunctionName();
-    method @NonNull public java.util.List<android.app.appsearch.PropertyPath> getProperties();
+    method @NonNull public java.util.List<android.app.appsearch.PropertyPath> getPropertyPaths();
     method public void setChild(@NonNull android.app.appsearch.ast.Node);
-    method public void setProperties(@NonNull java.util.List<android.app.appsearch.PropertyPath>);
+    method public void setPropertyPaths(@NonNull java.util.List<android.app.appsearch.PropertyPath>);
   }
 
   @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class SemanticSearchNode implements android.app.appsearch.ast.FunctionNode {
diff --git a/framework/java/android/app/appsearch/AppSearchSession.java b/framework/java/android/app/appsearch/AppSearchSession.java
index 3486f90a..1d9d81be 100644
--- a/framework/java/android/app/appsearch/AppSearchSession.java
+++ b/framework/java/android/app/appsearch/AppSearchSession.java
@@ -547,8 +547,8 @@ public final class AppSearchSession implements Closeable {
      * content or rewrite via {@link #openBlobForWrite} of this blob won't be allowed.
      *
      * <p>If the blob is already stored in AppSearch and committed. A failed {@link AppSearchResult}
-     * with error code {@link AppSearchResult#I} will be associated with the {@link
-     * AppSearchBlobHandle}.
+     * with error code {@link AppSearchResult#RESULT_ALREADY_EXISTS} will be associated with the
+     * {@link AppSearchBlobHandle}.
      *
      * <p>If the blob content doesn't match the digest in {@link AppSearchBlobHandle}, a failed
      * {@link AppSearchResult} with error code {@link AppSearchResult#RESULT_INVALID_ARGUMENT} will
diff --git a/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.java b/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.java
index 838d0014..17bad446 100644
--- a/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.java
+++ b/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.java
@@ -16,6 +16,7 @@
 
 package android.app.appsearch.aidl;
 
+import static android.app.appsearch.AppSearchResult.RESULT_INTERNAL_ERROR;
 import static android.app.appsearch.ParcelableUtil.WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL;
 import static android.app.appsearch.ParcelableUtil.WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB;
 
@@ -28,7 +29,6 @@ import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.ParcelableUtil;
 import android.app.appsearch.safeparcel.AbstractSafeParcelable;
 import android.app.appsearch.safeparcel.SafeParcelable;
-import android.os.Build;
 import android.os.Bundle;
 import android.os.Parcel;
 import android.os.ParcelFileDescriptor;
@@ -116,6 +116,8 @@ public final class AppSearchBatchResultParcelV2<KeyType, ValueType> extends Abst
     @ParcelableUtil.WriteParcelMode
     int mWriteParcelModel;
 
+    // No longer used, we shouldn't use class name to generate clazz file since proguard will
+    // mutate the class name.
     @Field(id = 2)
     @NonNull
     final String mKeyClassName;
@@ -144,6 +146,13 @@ public final class AppSearchBatchResultParcelV2<KeyType, ValueType> extends Abst
         mKeyClassName = keyClassName;
         mKeyBundle = keyBundle;
         mAppSearchResultValueBundle = appSearchResultValueBundle;
+
+        // We need to set the bundle's class loader otherwise it may return null in getParcelable.
+        // Normally all AppSearch's classes should be under the same classLoader, using
+        // AppSearchResultParcelV2.class.getClassLoader() here.
+        ClassLoader classLoader = AppSearchResultParcelV2.class.getClassLoader();
+        mKeyBundle.setClassLoader(classLoader);
+        mAppSearchResultValueBundle.setClassLoader(classLoader);
     }
 
     /**
@@ -221,36 +230,34 @@ public final class AppSearchBatchResultParcelV2<KeyType, ValueType> extends Abst
 
     /** Gets the {@link AppSearchBatchResult} out of this {@link AppSearchBatchResultParcelV2}. */
     @NonNull
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "deprecation"})
     public AppSearchBatchResult<KeyType, ValueType> getResult() {
         if (mResultCached == null) {
             AppSearchBatchResult.Builder<KeyType, ValueType> builder =
                     new AppSearchBatchResult.Builder<>();
 
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
-                try {
-                    java.lang.Class<?> clazz = java.lang.Class.forName(mKeyClassName);
-                    for (String key : mKeyBundle.keySet()) {
-                        builder.setResult(
-                                (KeyType) mKeyBundle.getParcelable(key, clazz),
-                                mAppSearchResultValueBundle
-                                        .getParcelable(key, AppSearchResultParcelV2.class)
-                                        .getResult());
-                    }
-                } catch (ClassNotFoundException e) {
-                    // Impossible, the key type name should always match the KeyType.
-                    throw new RuntimeException("Class not found: " + e.getMessage(), e);
-                }
-            } else {
-                for (String key : mKeyBundle.keySet()) {
+            for (String key : mKeyBundle.keySet()) {
+                KeyType keyType = (KeyType) mKeyBundle.getParcelable(key);
+                AppSearchResultParcelV2<ValueType> valueTypeResult =
+                        (AppSearchResultParcelV2<ValueType>)
+                                mAppSearchResultValueBundle.getParcelable(key);
+                if (keyType == null) {
+                    // keyType is null means the type of key doesn't match keyClazz, which
+                    // is impossible.
+                    throw new IllegalArgumentException(
+                            "AppSearchResultParcelV2's key type doesn't match.");
+                } else if (valueTypeResult == null) {
+                    // valueTypeResult is null means the type of value isn't
+                    // AppSearchResultParcelV2, which is impossible.
                     builder.setResult(
-                            mKeyBundle.getParcelable(key),
-                            ((AppSearchResultParcelV2)
-                                            mAppSearchResultValueBundle.getParcelable(key))
-                                    .getResult());
+                            keyType,
+                            AppSearchResult.newFailedResult(
+                                    RESULT_INTERNAL_ERROR,
+                                    "Cannot read value parcelable from bundle."));
+                } else {
+                    builder.setResult(keyType, valueTypeResult.getResult());
                 }
             }
-
             mResultCached = builder.build();
         }
         return mResultCached;
diff --git a/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.java b/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.java
index 764478f8..8bc88e72 100644
--- a/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.java
+++ b/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.java
@@ -18,6 +18,7 @@ package android.app.appsearch.aidl;
 
 import static android.app.appsearch.ParcelableUtil.WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL;
 import static android.app.appsearch.ParcelableUtil.WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB;
+import static android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -313,7 +314,14 @@ public final class AppSearchResultParcelV2<ValueType> extends AbstractSafeParcel
                 ParcelableUtil.writeBlob(dest, bytes);
                 break;
             case WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL:
-                directlyWriteToParcel(this, dest, flags);
+                // It's important to add the PARCELABLE_WRITE_RETURN_VALUE flags to ensure
+                // resources, such as ParcelFileDescriptor, are released on the sender's side.
+                // Normally, PARCELABLE_WRITE_RETURN_VALUE is automatically added when a parcelable
+                // object is directly returned in a binder call.
+                // However, since AppSearch uses a callback mechanism and a void binder call
+                // pattern, we need to manually add the PARCELABLE_WRITE_RETURN_VALUE flag when
+                // parceling this object to invoke the callback.
+                directlyWriteToParcel(this, dest, flags | PARCELABLE_WRITE_RETURN_VALUE);
                 break;
             default:
                 throw new UnsupportedOperationException(
diff --git a/framework/java/external/android/app/appsearch/AppSearchBatchResult.java b/framework/java/external/android/app/appsearch/AppSearchBatchResult.java
index ebae8838..74c48dd6 100644
--- a/framework/java/external/android/app/appsearch/AppSearchBatchResult.java
+++ b/framework/java/external/android/app/appsearch/AppSearchBatchResult.java
@@ -16,13 +16,14 @@
 package android.app.appsearch;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.util.ArrayMap;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Collections;
 import java.util.Map;
 import java.util.Objects;
@@ -45,17 +46,12 @@ import java.util.Objects;
  * @see AppSearchSession#remove
  */
 public final class AppSearchBatchResult<KeyType, ValueType> {
-    @NonNull
-    private final Map<KeyType, @android.app.appsearch.checker.nullness.qual.Nullable ValueType>
-            mSuccesses;
-
-    @NonNull private final Map<KeyType, AppSearchResult<ValueType>> mFailures;
-    @NonNull private final Map<KeyType, AppSearchResult<ValueType>> mAll;
+    private final @NonNull Map<KeyType, @Nullable ValueType> mSuccesses;
+    private final @NonNull Map<KeyType, AppSearchResult<ValueType>> mFailures;
+    private final @NonNull Map<KeyType, AppSearchResult<ValueType>> mAll;
 
     AppSearchBatchResult(
-            @NonNull
-                    Map<KeyType, @android.app.appsearch.checker.nullness.qual.Nullable ValueType>
-                            successes,
+            @NonNull Map<KeyType, @Nullable ValueType> successes,
             @NonNull Map<KeyType, AppSearchResult<ValueType>> failures,
             @NonNull Map<KeyType, AppSearchResult<ValueType>> all) {
         mSuccesses = Objects.requireNonNull(successes);
@@ -78,8 +74,7 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
      *
      * <p>The values of the {@link Map} will not be {@code null}.
      */
-    @NonNull
-    public Map<KeyType, ValueType> getSuccesses() {
+    public @NonNull Map<KeyType, ValueType> getSuccesses() {
         return Collections.unmodifiableMap(mSuccesses);
     }
 
@@ -89,8 +84,7 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
      *
      * <p>The values of the {@link Map} will not be {@code null}.
      */
-    @NonNull
-    public Map<KeyType, AppSearchResult<ValueType>> getFailures() {
+    public @NonNull Map<KeyType, AppSearchResult<ValueType>> getFailures() {
         return Collections.unmodifiableMap(mFailures);
     }
 
@@ -100,8 +94,7 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
      *
      * <p>The values of the {@link Map} will not be {@code null}.
      */
-    @NonNull
-    public Map<KeyType, AppSearchResult<ValueType>> getAll() {
+    public @NonNull Map<KeyType, AppSearchResult<ValueType>> getAll() {
         return Collections.unmodifiableMap(mAll);
     }
 
@@ -117,8 +110,7 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
     }
 
     @Override
-    @NonNull
-    public String toString() {
+    public @NonNull String toString() {
         return "{\n  successes: " + mSuccesses + "\n  failures: " + mFailures + "\n}";
     }
 
@@ -129,8 +121,7 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
      * @param <ValueType> The type of the result objects for successful results.
      */
     public static final class Builder<KeyType, ValueType> {
-        private ArrayMap<KeyType, @android.app.appsearch.checker.nullness.qual.Nullable ValueType>
-                mSuccesses = new ArrayMap<>();
+        private ArrayMap<KeyType, @Nullable ValueType> mSuccesses = new ArrayMap<>();
         private ArrayMap<KeyType, AppSearchResult<ValueType>> mFailures = new ArrayMap<>();
         private ArrayMap<KeyType, AppSearchResult<ValueType>> mAll = new ArrayMap<>();
         private boolean mBuilt = false;
@@ -161,8 +152,7 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
          */
         @CanIgnoreReturnValue
         @SuppressWarnings("MissingGetterMatchingBuilder") // See getSuccesses
-        @NonNull
-        public Builder<KeyType, ValueType> setSuccess(
+        public @NonNull Builder<KeyType, ValueType> setSuccess(
                 @NonNull KeyType key, @Nullable ValueType value) {
             Objects.requireNonNull(key);
             resetIfBuilt();
@@ -185,8 +175,7 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
          */
         @CanIgnoreReturnValue
         @SuppressWarnings("MissingGetterMatchingBuilder") // See getFailures
-        @NonNull
-        public Builder<KeyType, ValueType> setFailure(
+        public @NonNull Builder<KeyType, ValueType> setFailure(
                 @NonNull KeyType key,
                 @AppSearchResult.ResultCode int resultCode,
                 @Nullable String errorMessage) {
@@ -206,8 +195,7 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
          */
         @CanIgnoreReturnValue
         @SuppressWarnings("MissingGetterMatchingBuilder") // See getAll
-        @NonNull
-        public Builder<KeyType, ValueType> setResult(
+        public @NonNull Builder<KeyType, ValueType> setResult(
                 @NonNull KeyType key, @NonNull AppSearchResult<ValueType> result) {
             Objects.requireNonNull(key);
             Objects.requireNonNull(result);
@@ -226,8 +214,7 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
         /**
          * Builds an {@link AppSearchBatchResult} object from the contents of this {@link Builder}.
          */
-        @NonNull
-        public AppSearchBatchResult<KeyType, ValueType> build() {
+        public @NonNull AppSearchBatchResult<KeyType, ValueType> build() {
             mBuilt = true;
             return new AppSearchBatchResult<>(mSuccesses, mFailures, mAll);
         }
diff --git a/framework/java/external/android/app/appsearch/AppSearchBlobHandle.java b/framework/java/external/android/app/appsearch/AppSearchBlobHandle.java
index f0b37c77..1ca2c0c1 100644
--- a/framework/java/external/android/app/appsearch/AppSearchBlobHandle.java
+++ b/framework/java/external/android/app/appsearch/AppSearchBlobHandle.java
@@ -53,7 +53,8 @@ import java.util.Objects;
  * @see GenericDocument.Builder#setPropertyBlobHandle
  */
 @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 @SafeParcelable.Class(creator = "AppSearchBlobHandleCreator")
 public final class AppSearchBlobHandle extends AbstractSafeParcelable {
     /** The length of the SHA-256 digest in bytes. SHA-256 produces a 256-bit (32-byte) digest. */
@@ -63,23 +64,19 @@ public final class AppSearchBlobHandle extends AbstractSafeParcelable {
     public static final Parcelable.Creator<AppSearchBlobHandle> CREATOR =
             new AppSearchBlobHandleCreator();
 
-    @NonNull
     @Field(id = 1, getter = "getSha256Digest")
-    private final byte[] mSha256Digest;
+    private final @NonNull byte[] mSha256Digest;
 
-    @NonNull
     @Field(id = 2, getter = "getPackageName")
-    private final String mPackageName;
+    private final @NonNull String mPackageName;
 
-    @NonNull
     @Field(id = 3, getter = "getDatabaseName")
-    private final String mDatabaseName;
+    private final @NonNull String mDatabaseName;
 
-    @NonNull
     @Field(id = 4, getter = "getNamespace")
-    private final String mNamespace;
+    private final @NonNull String mNamespace;
 
-    @Nullable private Integer mHashCode;
+    private @Nullable Integer mHashCode;
 
     /**
      * Build an {@link AppSearchBlobHandle}.
@@ -107,8 +104,7 @@ public final class AppSearchBlobHandle extends AbstractSafeParcelable {
      * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code
      * packageName}, {@code database}, {@code namespace} and {@code digest} must be equal.
      */
-    @NonNull
-    public byte[] getSha256Digest() {
+    public @NonNull byte[] getSha256Digest() {
         return mSha256Digest;
     }
 
@@ -119,8 +115,7 @@ public final class AppSearchBlobHandle extends AbstractSafeParcelable {
      * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code
      * packageName}, {@code database}, {@code namespace} and {@code digest} must be equal.
      */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
@@ -130,8 +125,7 @@ public final class AppSearchBlobHandle extends AbstractSafeParcelable {
      * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code
      * packageName}, {@code database}, {@code namespace} and {@code digest} must be equal.
      */
-    @NonNull
-    public String getDatabaseName() {
+    public @NonNull String getDatabaseName() {
         return mDatabaseName;
     }
 
@@ -141,8 +135,7 @@ public final class AppSearchBlobHandle extends AbstractSafeParcelable {
      * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code
      * packageName}, {@code database}, {@code namespace} and {@code digest} must be equal.
      */
-    @NonNull
-    public String getNamespace() {
+    public @NonNull String getNamespace() {
         return mNamespace;
     }
 
@@ -171,9 +164,8 @@ public final class AppSearchBlobHandle extends AbstractSafeParcelable {
         return mHashCode;
     }
 
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         IndentingStringBuilder builder = new IndentingStringBuilder();
         builder.append("{\n");
         builder.increaseIndentLevel();
@@ -210,8 +202,7 @@ public final class AppSearchBlobHandle extends AbstractSafeParcelable {
      * @param namespace The namespace of this blob resides in.
      * @return a new instance of {@link AppSearchBlobHandle} object.
      */
-    @NonNull
-    public static AppSearchBlobHandle createWithSha256(
+    public static @NonNull AppSearchBlobHandle createWithSha256(
             @NonNull byte[] digest,
             @NonNull String packageName,
             @NonNull String databaseName,
diff --git a/framework/java/external/android/app/appsearch/AppSearchEnvironment.java b/framework/java/external/android/app/appsearch/AppSearchEnvironment.java
index 48925af6..95595a67 100644
--- a/framework/java/external/android/app/appsearch/AppSearchEnvironment.java
+++ b/framework/java/external/android/app/appsearch/AppSearchEnvironment.java
@@ -17,11 +17,12 @@
 package android.app.appsearch;
 
 import android.annotation.IntDef;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.content.Context;
 import android.os.UserHandle;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.io.File;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -37,16 +38,13 @@ import java.util.concurrent.TimeUnit;
 public interface AppSearchEnvironment {
 
     /** Returns the directory to initialize appsearch based on the environment. */
-    @NonNull
-    File getAppSearchDir(@NonNull Context context, @Nullable UserHandle userHandle);
+    @NonNull File getAppSearchDir(@NonNull Context context, @Nullable UserHandle userHandle);
 
     /** Returns the correct context for the user based on the environment. */
-    @NonNull
-    Context createContextAsUser(@NonNull Context context, @NonNull UserHandle userHandle);
+    @NonNull Context createContextAsUser(@NonNull Context context, @NonNull UserHandle userHandle);
 
     /** Returns an ExecutorService based on given parameters. */
-    @NonNull
-    ExecutorService createExecutorService(
+    @NonNull ExecutorService createExecutorService(
             int corePoolSize,
             int maxConcurrency,
             long keepAliveTime,
@@ -55,18 +53,15 @@ public interface AppSearchEnvironment {
             int priority);
 
     /** Returns an ExecutorService with a single thread. */
-    @NonNull
-    ExecutorService createSingleThreadExecutor();
+    @NonNull ExecutorService createSingleThreadExecutor();
 
     /** Creates and returns an Executor with cached thread pools. */
-    @NonNull
-    ExecutorService createCachedThreadPoolExecutor();
+    @NonNull ExecutorService createCachedThreadPoolExecutor();
 
     /**
      * Returns a cache directory for creating temporary files like in case of migrating documents.
      */
-    @Nullable
-    File getCacheDir(@NonNull Context context);
+    @Nullable File getCacheDir(@NonNull Context context);
 
     /** Returns if we can log INFO level logs. */
     boolean isInfoLoggingEnabled();
diff --git a/framework/java/external/android/app/appsearch/AppSearchResult.java b/framework/java/external/android/app/appsearch/AppSearchResult.java
index 47c3e401..cf43e774 100644
--- a/framework/java/external/android/app/appsearch/AppSearchResult.java
+++ b/framework/java/external/android/app/appsearch/AppSearchResult.java
@@ -36,6 +36,8 @@ import java.util.Objects;
  *
  * @param <ValueType> The type of result object for successful calls.
  */
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings("JSpecifyNullness")
 public final class AppSearchResult<ValueType> {
     private static final String TAG = "AppSearchResult";
 
@@ -57,7 +59,6 @@ public final class AppSearchResult<ValueType> {
                 RESULT_SECURITY_ERROR,
                 RESULT_DENIED,
                 RESULT_RATE_LIMITED,
-                RESULT_TIMED_OUT,
                 RESULT_ALREADY_EXISTS
             })
     @Retention(RetentionPolicy.SOURCE)
@@ -116,17 +117,13 @@ public final class AppSearchResult<ValueType> {
     @FlaggedApi(Flags.FLAG_ENABLE_RESULT_DENIED_AND_RESULT_RATE_LIMITED)
     public static final int RESULT_RATE_LIMITED = 10;
 
-    /** The operation was timed out. */
-    @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-    public static final int RESULT_TIMED_OUT = 11;
-
     /** The operation is invalid because the resource already exists and can't be replaced. */
     @FlaggedApi(Flags.FLAG_ENABLE_RESULT_ALREADY_EXISTS)
     public static final int RESULT_ALREADY_EXISTS = 12;
 
     @ResultCode private final int mResultCode;
-    @Nullable private final ValueType mResultValue;
-    @Nullable private final String mErrorMessage;
+    private final @Nullable ValueType mResultValue;
+    private final @Nullable String mErrorMessage;
 
     private AppSearchResult(
             @ResultCode int resultCode,
@@ -156,8 +153,7 @@ public final class AppSearchResult<ValueType> {
      *
      * @throws IllegalStateException if this {@link AppSearchResult} is not successful.
      */
-    @Nullable
-    public ValueType getResultValue() {
+    public @Nullable ValueType getResultValue() {
         if (!isSuccess()) {
             throw new IllegalStateException("AppSearchResult is a failure: " + this);
         }
@@ -172,8 +168,7 @@ public final class AppSearchResult<ValueType> {
      * documentation of the particular {@link AppSearchSession} call producing this {@link
      * AppSearchResult} for what is returned by {@link #getErrorMessage}.
      */
-    @Nullable
-    public String getErrorMessage() {
+    public @Nullable String getErrorMessage() {
         return mErrorMessage;
     }
 
@@ -197,8 +192,7 @@ public final class AppSearchResult<ValueType> {
     }
 
     @Override
-    @NonNull
-    public String toString() {
+    public @NonNull String toString() {
         if (isSuccess()) {
             return "[SUCCESS]: " + mResultValue;
         }
@@ -211,8 +205,7 @@ public final class AppSearchResult<ValueType> {
      * @param value An optional value to associate with the successful result of the operation being
      *     performed.
      */
-    @NonNull
-    public static <ValueType> AppSearchResult<ValueType> newSuccessfulResult(
+    public static @NonNull <ValueType> AppSearchResult<ValueType> newSuccessfulResult(
             @Nullable ValueType value) {
         return new AppSearchResult<>(RESULT_OK, value, /* errorMessage= */ null);
     }
@@ -223,8 +216,7 @@ public final class AppSearchResult<ValueType> {
      * @param resultCode One of the constants documented in {@link AppSearchResult#getResultCode}.
      * @param errorMessage An optional string describing the reason or nature of the failure.
      */
-    @NonNull
-    public static <ValueType> AppSearchResult<ValueType> newFailedResult(
+    public static @NonNull <ValueType> AppSearchResult<ValueType> newFailedResult(
             @ResultCode int resultCode, @Nullable String errorMessage) {
         return new AppSearchResult<>(resultCode, /* resultValue= */ null, errorMessage);
     }
@@ -234,8 +226,7 @@ public final class AppSearchResult<ValueType> {
      *
      * @hide
      */
-    @NonNull
-    public static <ValueType> AppSearchResult<ValueType> newFailedResult(
+    public static @NonNull <ValueType> AppSearchResult<ValueType> newFailedResult(
             @NonNull AppSearchResult<?> otherFailedResult) {
         Preconditions.checkState(
                 !otherFailedResult.isSuccess(),
@@ -245,8 +236,7 @@ public final class AppSearchResult<ValueType> {
     }
 
     /** @hide */
-    @NonNull
-    public static <ValueType> AppSearchResult<ValueType> throwableToFailedResult(
+    public static @NonNull <ValueType> AppSearchResult<ValueType> throwableToFailedResult(
             @NonNull Throwable t) {
         // Log for traceability. NOT_FOUND is logged at VERBOSE because this error can occur during
         // the regular operation of the system (b/183550974). Everything else is indicative of an
diff --git a/framework/java/external/android/app/appsearch/AppSearchSchema.java b/framework/java/external/android/app/appsearch/AppSearchSchema.java
index c271d949..cd3794d1 100644
--- a/framework/java/external/android/app/appsearch/AppSearchSchema.java
+++ b/framework/java/external/android/app/appsearch/AppSearchSchema.java
@@ -60,12 +60,13 @@ import java.util.Set;
  * @see AppSearchSession#setSchema
  */
 @SafeParcelable.Class(creator = "AppSearchSchemaCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class AppSearchSchema extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<AppSearchSchema> CREATOR = new AppSearchSchemaCreator();
+    public static final @NonNull Parcelable.Creator<AppSearchSchema> CREATOR =
+            new AppSearchSchemaCreator();
 
     @Field(id = 1, getter = "getSchemaType")
     private final String mSchemaType;
@@ -92,8 +93,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
     }
 
     @Override
-    @NonNull
-    public String toString() {
+    public @NonNull String toString() {
         IndentingStringBuilder stringBuilder = new IndentingStringBuilder();
         appendAppSearchSchemaString(stringBuilder);
         return stringBuilder.toString();
@@ -135,8 +135,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
     }
 
     /** Returns the name of this schema type, such as Email. */
-    @NonNull
-    public String getSchemaType() {
+    public @NonNull String getSchemaType() {
         return mSchemaType;
     }
 
@@ -149,9 +148,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
      * meaning. This field has no effect in AppSearch - it is just stored with the AppSearchSchema.
      * If {@link Builder#setDescription} is uncalled, then this method will return an empty string.
      */
-    @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-    @NonNull
-    public String getDescription() {
+    @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
+    public @NonNull String getDescription() {
         return mDescription;
     }
 
@@ -160,9 +158,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
      *
      * <p>This method creates a new list when called.
      */
-    @NonNull
     @SuppressWarnings({"MixedMutabilityReturnType"})
-    public List<PropertyConfig> getProperties() {
+    public @NonNull List<PropertyConfig> getProperties() {
         if (mPropertyConfigParcels.isEmpty()) {
             return Collections.emptyList();
         }
@@ -175,8 +172,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
 
     /** Returns the list of parent types of this schema for polymorphism. */
     @FlaggedApi(Flags.FLAG_ENABLE_GET_PARENT_TYPES_AND_INDEXABLE_NESTED_PROPERTIES)
-    @NonNull
-    public List<String> getParentTypes() {
+    public @NonNull List<String> getParentTypes() {
         return Collections.unmodifiableList(mParentTypes);
     }
 
@@ -241,8 +237,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
         /** Sets the schema type name. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public AppSearchSchema.Builder setSchemaType(@NonNull String schemaType) {
+        public @NonNull AppSearchSchema.Builder setSchemaType(@NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
             mSchemaType = schemaType;
@@ -255,10 +250,9 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          * <p>For more details about the description field, see {@link
          * AppSearchSchema#getDescription}.
          */
-        @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+        @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
         @CanIgnoreReturnValue
-        @NonNull
-        public AppSearchSchema.Builder setDescription(@NonNull String description) {
+        public @NonNull AppSearchSchema.Builder setDescription(@NonNull String description) {
             Objects.requireNonNull(description);
             resetIfBuilt();
             mDescription = description;
@@ -267,8 +261,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
 
         /** Adds a property to the schema type. */
         @CanIgnoreReturnValue
-        @NonNull
-        public AppSearchSchema.Builder addProperty(@NonNull PropertyConfig propertyConfig) {
+        public @NonNull AppSearchSchema.Builder addProperty(
+                @NonNull PropertyConfig propertyConfig) {
             Objects.requireNonNull(propertyConfig);
             resetIfBuilt();
             String name = propertyConfig.getName();
@@ -285,8 +279,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public AppSearchSchema.Builder clearProperties() {
+        public @NonNull AppSearchSchema.Builder clearProperties() {
             resetIfBuilt();
             mPropertyConfigParcels.clear();
             mPropertyNames.clear();
@@ -354,8 +347,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          * Place and the compatibility of LocalBusiness with Organization will both be checked.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public AppSearchSchema.Builder addParentType(@NonNull String parentSchemaType) {
+        public @NonNull AppSearchSchema.Builder addParentType(@NonNull String parentSchemaType) {
             Objects.requireNonNull(parentSchemaType);
             resetIfBuilt();
             mParentTypes.add(parentSchemaType);
@@ -368,16 +360,14 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public AppSearchSchema.Builder clearParentTypes() {
+        public @NonNull AppSearchSchema.Builder clearParentTypes() {
             resetIfBuilt();
             mParentTypes.clear();
             return this;
         }
 
         /** Constructs a new {@link AppSearchSchema} from the contents of this builder. */
-        @NonNull
-        public AppSearchSchema build() {
+        public @NonNull AppSearchSchema build() {
             mBuilt = true;
             return new AppSearchSchema(
                     mSchemaType,
@@ -515,8 +505,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
         }
 
         @Override
-        @NonNull
-        public String toString() {
+        public @NonNull String toString() {
             IndentingStringBuilder stringBuilder = new IndentingStringBuilder();
             appendPropertyConfigString(stringBuilder);
             return stringBuilder.toString();
@@ -591,8 +580,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
         }
 
         /** Returns the name of this property. */
-        @NonNull
-        public String getName() {
+        public @NonNull String getName() {
             return mPropertyConfigParcel.getName();
         }
 
@@ -607,9 +595,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          * AppSearchSchema. If the description is not set, then this method will return an empty
          * string.
          */
-        @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-        @NonNull
-        public String getDescription() {
+        @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
+        public @NonNull String getDescription() {
             return mPropertyConfigParcel.getDescription();
         }
 
@@ -658,8 +645,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          *     {@code DATA_TYPE_FIELD}.
          * @hide
          */
-        @NonNull
-        public static PropertyConfig fromParcel(
+        public static @NonNull PropertyConfig fromParcel(
                 @NonNull PropertyConfigParcel propertyConfigParcel) {
             Objects.requireNonNull(propertyConfigParcel);
             switch (propertyConfigParcel.getDataType()) {
@@ -841,6 +827,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
         public @interface DeletePropagationType {}
 
         /** Does not propagate deletion. */
+        // TODO(b/384947619) unhide the API once it is ready.
+
         @FlaggedApi(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
         public static final int DELETE_PROPAGATION_TYPE_NONE = 0;
 
@@ -859,6 +847,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          * the joinable value type). Otherwise, throw {@link IllegalStateException} when building
          * (see {@link StringPropertyConfig.Builder#build}).
          */
+        // TODO(b/384947619) unhide the API once it is ready.
+
         @FlaggedApi(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
         public static final int DELETE_PROPAGATION_TYPE_PROPAGATE_FROM = 1;
 
@@ -908,6 +898,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          * Returns how the deletion will be propagated between this document and the referenced
          * document whose qualified id is held by this property.
          */
+        // TODO(b/384947619) unhide the API once it is ready.
+
         @FlaggedApi(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
         @DeletePropagationType
         public int getDeletePropagationType() {
@@ -944,10 +936,10 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * AppSearchSchema.PropertyConfig#getDescription}.
              */
             @CanIgnoreReturnValue
-            @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+            @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public StringPropertyConfig.Builder setDescription(@NonNull String description) {
+            public @NonNull StringPropertyConfig.Builder setDescription(
+                    @NonNull String description) {
                 mDescription = Objects.requireNonNull(description);
                 return this;
             }
@@ -960,8 +952,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public StringPropertyConfig.Builder setCardinality(@Cardinality int cardinality) {
+            public @NonNull StringPropertyConfig.Builder setCardinality(
+                    @Cardinality int cardinality) {
                 Preconditions.checkArgumentInRange(
                         cardinality, CARDINALITY_REPEATED, CARDINALITY_REQUIRED, "cardinality");
                 mCardinality = cardinality;
@@ -975,8 +967,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * StringPropertyConfig#INDEXING_TYPE_NONE}, so that it cannot be matched by queries.
              */
             @CanIgnoreReturnValue
-            @NonNull
-            public StringPropertyConfig.Builder setIndexingType(
+            public @NonNull StringPropertyConfig.Builder setIndexingType(
                     @StringPropertyConfig.IndexingType int indexingType) {
                 Preconditions.checkArgumentInRange(
                         indexingType, INDEXING_TYPE_NONE, INDEXING_TYPE_PREFIXES, "indexingType");
@@ -996,8 +987,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * StringPropertyConfig#INDEXING_TYPE_NONE}).
              */
             @CanIgnoreReturnValue
-            @NonNull
-            public StringPropertyConfig.Builder setTokenizerType(@TokenizerType int tokenizerType) {
+            public @NonNull StringPropertyConfig.Builder setTokenizerType(
+                    @TokenizerType int tokenizerType) {
                 Preconditions.checkArgumentInRange(
                         tokenizerType, TOKENIZER_TYPE_NONE, TOKENIZER_TYPE_RFC822, "tokenizerType");
                 mTokenizerType = tokenizerType;
@@ -1013,8 +1004,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * <p>At most, 64 properties can be set as joinable per schema.
              */
             @CanIgnoreReturnValue
-            @NonNull
-            public StringPropertyConfig.Builder setJoinableValueType(
+            public @NonNull StringPropertyConfig.Builder setJoinableValueType(
                     @JoinableValueType int joinableValueType) {
                 Preconditions.checkArgumentInRange(
                         joinableValueType,
@@ -1039,10 +1029,11 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * delete propagation has to use the qualified id. Otherwise, throw {@link
              * IllegalStateException} when building.
              */
+            // TODO(b/384947619) unhide the API once it is ready.
+
             @CanIgnoreReturnValue
             @FlaggedApi(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
-            @NonNull
-            public StringPropertyConfig.Builder setDeletePropagationType(
+            public @NonNull StringPropertyConfig.Builder setDeletePropagationType(
                     @DeletePropagationType int deletePropagationType) {
                 Preconditions.checkArgumentInRange(
                         deletePropagationType,
@@ -1069,8 +1060,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              *           {@link StringPropertyConfig#JOINABLE_VALUE_TYPE_QUALIFIED_ID}.
              *     </ul>
              */
-            @NonNull
-            public StringPropertyConfig build() {
+            public @NonNull StringPropertyConfig build() {
                 if (mTokenizerType == TOKENIZER_TYPE_NONE) {
                     Preconditions.checkState(
                             mIndexingType == INDEXING_TYPE_NONE,
@@ -1237,10 +1227,9 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * AppSearchSchema.PropertyConfig#getDescription}.
              */
             @CanIgnoreReturnValue
-            @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+            @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public LongPropertyConfig.Builder setDescription(@NonNull String description) {
+            public @NonNull LongPropertyConfig.Builder setDescription(@NonNull String description) {
                 mDescription = Objects.requireNonNull(description);
                 return this;
             }
@@ -1253,8 +1242,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public LongPropertyConfig.Builder setCardinality(@Cardinality int cardinality) {
+            public @NonNull LongPropertyConfig.Builder setCardinality(
+                    @Cardinality int cardinality) {
                 Preconditions.checkArgumentInRange(
                         cardinality, CARDINALITY_REPEATED, CARDINALITY_REQUIRED, "cardinality");
                 mCardinality = cardinality;
@@ -1269,8 +1258,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * matched by queries.
              */
             @CanIgnoreReturnValue
-            @NonNull
-            public LongPropertyConfig.Builder setIndexingType(
+            public @NonNull LongPropertyConfig.Builder setIndexingType(
                     @LongPropertyConfig.IndexingType int indexingType) {
                 Preconditions.checkArgumentInRange(
                         indexingType, INDEXING_TYPE_NONE, INDEXING_TYPE_RANGE, "indexingType");
@@ -1291,15 +1279,13 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
-            @NonNull
-            public LongPropertyConfig.Builder setScoringEnabled(boolean scoringEnabled) {
+            public @NonNull LongPropertyConfig.Builder setScoringEnabled(boolean scoringEnabled) {
                 mScoringEnabled = scoringEnabled;
                 return this;
             }
 
             /** Constructs a new {@link LongPropertyConfig} from the contents of this builder. */
-            @NonNull
-            public LongPropertyConfig build() {
+            public @NonNull LongPropertyConfig build() {
                 return new LongPropertyConfig(
                         PropertyConfigParcel.createForLong(
                                 mPropertyName,
@@ -1363,10 +1349,10 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * AppSearchSchema.PropertyConfig#getDescription}.
              */
             @CanIgnoreReturnValue
-            @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+            @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public DoublePropertyConfig.Builder setDescription(@NonNull String description) {
+            public @NonNull DoublePropertyConfig.Builder setDescription(
+                    @NonNull String description) {
                 mDescription = Objects.requireNonNull(description);
                 return this;
             }
@@ -1379,8 +1365,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public DoublePropertyConfig.Builder setCardinality(@Cardinality int cardinality) {
+            public @NonNull DoublePropertyConfig.Builder setCardinality(
+                    @Cardinality int cardinality) {
                 Preconditions.checkArgumentInRange(
                         cardinality, CARDINALITY_REPEATED, CARDINALITY_REQUIRED, "cardinality");
                 mCardinality = cardinality;
@@ -1400,15 +1386,13 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
-            @NonNull
-            public DoublePropertyConfig.Builder setScoringEnabled(boolean scoringEnabled) {
+            public @NonNull DoublePropertyConfig.Builder setScoringEnabled(boolean scoringEnabled) {
                 mScoringEnabled = scoringEnabled;
                 return this;
             }
 
             /** Constructs a new {@link DoublePropertyConfig} from the contents of this builder. */
-            @NonNull
-            public DoublePropertyConfig build() {
+            public @NonNull DoublePropertyConfig build() {
                 return new DoublePropertyConfig(
                         PropertyConfigParcel.createForDouble(
                                 mPropertyName, mDescription, mCardinality, mScoringEnabled));
@@ -1447,10 +1431,10 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * AppSearchSchema.PropertyConfig#getDescription}.
              */
             @CanIgnoreReturnValue
-            @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+            @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public BooleanPropertyConfig.Builder setDescription(@NonNull String description) {
+            public @NonNull BooleanPropertyConfig.Builder setDescription(
+                    @NonNull String description) {
                 mDescription = Objects.requireNonNull(description);
                 return this;
             }
@@ -1463,8 +1447,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public BooleanPropertyConfig.Builder setCardinality(@Cardinality int cardinality) {
+            public @NonNull BooleanPropertyConfig.Builder setCardinality(
+                    @Cardinality int cardinality) {
                 Preconditions.checkArgumentInRange(
                         cardinality, CARDINALITY_REPEATED, CARDINALITY_REQUIRED, "cardinality");
                 mCardinality = cardinality;
@@ -1484,15 +1468,14 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
-            @NonNull
-            public BooleanPropertyConfig.Builder setScoringEnabled(boolean scoringEnabled) {
+            public @NonNull BooleanPropertyConfig.Builder setScoringEnabled(
+                    boolean scoringEnabled) {
                 mScoringEnabled = scoringEnabled;
                 return this;
             }
 
             /** Constructs a new {@link BooleanPropertyConfig} from the contents of this builder. */
-            @NonNull
-            public BooleanPropertyConfig build() {
+            public @NonNull BooleanPropertyConfig build() {
                 return new BooleanPropertyConfig(
                         PropertyConfigParcel.createForBoolean(
                                 mPropertyName, mDescription, mCardinality, mScoringEnabled));
@@ -1524,10 +1507,10 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * AppSearchSchema.PropertyConfig#getDescription}.
              */
             @CanIgnoreReturnValue
-            @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+            @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public BytesPropertyConfig.Builder setDescription(@NonNull String description) {
+            public @NonNull BytesPropertyConfig.Builder setDescription(
+                    @NonNull String description) {
                 mDescription = Objects.requireNonNull(description);
                 return this;
             }
@@ -1540,8 +1523,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public BytesPropertyConfig.Builder setCardinality(@Cardinality int cardinality) {
+            public @NonNull BytesPropertyConfig.Builder setCardinality(
+                    @Cardinality int cardinality) {
                 Preconditions.checkArgumentInRange(
                         cardinality, CARDINALITY_REPEATED, CARDINALITY_REQUIRED, "cardinality");
                 mCardinality = cardinality;
@@ -1549,8 +1532,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             }
 
             /** Constructs a new {@link BytesPropertyConfig} from the contents of this builder. */
-            @NonNull
-            public BytesPropertyConfig build() {
+            public @NonNull BytesPropertyConfig build() {
                 return new BytesPropertyConfig(
                         PropertyConfigParcel.createForBytes(
                                 mPropertyName, mDescription, mCardinality));
@@ -1565,8 +1547,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
         }
 
         /** Returns the logical schema-type of the contents of this document property. */
-        @NonNull
-        public String getSchemaType() {
+        public @NonNull String getSchemaType() {
             return Objects.requireNonNull(mPropertyConfigParcel.getSchemaType());
         }
 
@@ -1592,8 +1573,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
 
         /** Returns the list of indexable nested properties for the nested document. */
         @FlaggedApi(Flags.FLAG_ENABLE_GET_PARENT_TYPES_AND_INDEXABLE_NESTED_PROPERTIES)
-        @NonNull
-        public List<String> getIndexableNestedProperties() {
+        public @NonNull List<String> getIndexableNestedProperties() {
             DocumentIndexingConfigParcel indexingConfigParcel =
                     mPropertyConfigParcel.getDocumentIndexingConfigParcel();
             if (indexingConfigParcel == null) {
@@ -1639,10 +1619,10 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * AppSearchSchema.PropertyConfig#getDescription}.
              */
             @CanIgnoreReturnValue
-            @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+            @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public DocumentPropertyConfig.Builder setDescription(@NonNull String description) {
+            public @NonNull DocumentPropertyConfig.Builder setDescription(
+                    @NonNull String description) {
                 mDescription = Objects.requireNonNull(description);
                 return this;
             }
@@ -1655,8 +1635,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public DocumentPropertyConfig.Builder setCardinality(@Cardinality int cardinality) {
+            public @NonNull DocumentPropertyConfig.Builder setCardinality(
+                    @Cardinality int cardinality) {
                 Preconditions.checkArgumentInRange(
                         cardinality, CARDINALITY_REPEATED, CARDINALITY_REQUIRED, "cardinality");
                 mCardinality = cardinality;
@@ -1674,8 +1654,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * use {@link #addIndexableNestedProperties(Collection)}.
              */
             @CanIgnoreReturnValue
-            @NonNull
-            public DocumentPropertyConfig.Builder setShouldIndexNestedProperties(
+            public @NonNull DocumentPropertyConfig.Builder setShouldIndexNestedProperties(
                     boolean indexNestedProperties) {
                 mShouldIndexNestedProperties = indexNestedProperties;
                 return this;
@@ -1688,8 +1667,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @FlaggedApi(Flags.FLAG_ENABLE_GET_PARENT_TYPES_AND_INDEXABLE_NESTED_PROPERTIES)
             @CanIgnoreReturnValue
-            @NonNull
-            public DocumentPropertyConfig.Builder addIndexableNestedProperties(
+            public @NonNull DocumentPropertyConfig.Builder addIndexableNestedProperties(
                     @NonNull String... indexableNestedProperties) {
                 Objects.requireNonNull(indexableNestedProperties);
                 return addIndexableNestedProperties(Arrays.asList(indexableNestedProperties));
@@ -1703,8 +1681,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             @FlaggedApi(Flags.FLAG_ENABLE_GET_PARENT_TYPES_AND_INDEXABLE_NESTED_PROPERTIES)
             @CanIgnoreReturnValue
             @SuppressLint("MissingGetterMatchingBuilder")
-            @NonNull
-            public DocumentPropertyConfig.Builder addIndexableNestedPropertyPaths(
+            public @NonNull DocumentPropertyConfig.Builder addIndexableNestedPropertyPaths(
                     @NonNull PropertyPath... indexableNestedPropertyPaths) {
                 Objects.requireNonNull(indexableNestedPropertyPaths);
                 return addIndexableNestedPropertyPaths(Arrays.asList(indexableNestedPropertyPaths));
@@ -1741,8 +1718,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * {@link IllegalArgumentException}.
              */
             @CanIgnoreReturnValue
-            @NonNull
-            public DocumentPropertyConfig.Builder addIndexableNestedProperties(
+            public @NonNull DocumentPropertyConfig.Builder addIndexableNestedProperties(
                     @NonNull Collection<String> indexableNestedProperties) {
                 Objects.requireNonNull(indexableNestedProperties);
                 mIndexableNestedPropertiesList.addAll(indexableNestedProperties);
@@ -1757,8 +1733,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             @FlaggedApi(Flags.FLAG_ENABLE_GET_PARENT_TYPES_AND_INDEXABLE_NESTED_PROPERTIES)
             @CanIgnoreReturnValue
             @SuppressLint("MissingGetterMatchingBuilder")
-            @NonNull
-            public DocumentPropertyConfig.Builder addIndexableNestedPropertyPaths(
+            public @NonNull DocumentPropertyConfig.Builder addIndexableNestedPropertyPaths(
                     @NonNull Collection<PropertyPath> indexableNestedPropertyPaths) {
                 Objects.requireNonNull(indexableNestedPropertyPaths);
                 List<PropertyPath> propertyPathList = new ArrayList<>(indexableNestedPropertyPaths);
@@ -1775,8 +1750,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              *     #shouldIndexNestedProperties()} to true and has one or more properties defined
              *     using {@link #addIndexableNestedProperties(Collection)}.
              */
-            @NonNull
-            public DocumentPropertyConfig build() {
+            public @NonNull DocumentPropertyConfig build() {
                 if (mShouldIndexNestedProperties && !mIndexableNestedPropertiesList.isEmpty()) {
                     throw new IllegalArgumentException(
                             "DocumentIndexingConfig#shouldIndexNestedProperties is required "
@@ -1913,10 +1887,10 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * AppSearchSchema.PropertyConfig#getDescription}.
              */
             @CanIgnoreReturnValue
-            @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+            @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public EmbeddingPropertyConfig.Builder setDescription(@NonNull String description) {
+            public @NonNull EmbeddingPropertyConfig.Builder setDescription(
+                    @NonNull String description) {
                 mDescription = Objects.requireNonNull(description);
                 return this;
             }
@@ -1929,8 +1903,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public EmbeddingPropertyConfig.Builder setCardinality(@Cardinality int cardinality) {
+            public @NonNull EmbeddingPropertyConfig.Builder setCardinality(
+                    @Cardinality int cardinality) {
                 Preconditions.checkArgumentInRange(
                         cardinality, CARDINALITY_REPEATED, CARDINALITY_REQUIRED, "cardinality");
                 mCardinality = cardinality;
@@ -1945,8 +1919,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * cannot be matched by queries.
              */
             @CanIgnoreReturnValue
-            @NonNull
-            public EmbeddingPropertyConfig.Builder setIndexingType(
+            public @NonNull EmbeddingPropertyConfig.Builder setIndexingType(
                     @EmbeddingPropertyConfig.IndexingType int indexingType) {
                 Preconditions.checkArgumentInRange(
                         indexingType, INDEXING_TYPE_NONE, INDEXING_TYPE_SIMILARITY, "indexingType");
@@ -1967,8 +1940,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_QUANTIZATION)
             @CanIgnoreReturnValue
-            @NonNull
-            public EmbeddingPropertyConfig.Builder setQuantizationType(
+            public @NonNull EmbeddingPropertyConfig.Builder setQuantizationType(
                     @EmbeddingPropertyConfig.QuantizationType int quantizationType) {
                 Preconditions.checkArgumentInRange(
                         quantizationType,
@@ -1982,8 +1954,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             /**
              * Constructs a new {@link EmbeddingPropertyConfig} from the contents of this builder.
              */
-            @NonNull
-            public EmbeddingPropertyConfig build() {
+            public @NonNull EmbeddingPropertyConfig build() {
                 return new EmbeddingPropertyConfig(
                         PropertyConfigParcel.createForEmbedding(
                                 mPropertyName,
@@ -2021,10 +1992,9 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              * AppSearchSchema.PropertyConfig#getDescription}.
              */
             @CanIgnoreReturnValue
-            @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+            @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_DESCRIPTION)
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public Builder setDescription(@NonNull String description) {
+            public @NonNull Builder setDescription(@NonNull String description) {
                 mDescription = Objects.requireNonNull(description);
                 return this;
             }
@@ -2037,8 +2007,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
              */
             @CanIgnoreReturnValue
             @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
-            @NonNull
-            public Builder setCardinality(@Cardinality int cardinality) {
+            public @NonNull Builder setCardinality(@Cardinality int cardinality) {
                 Preconditions.checkArgumentInRange(
                         cardinality, CARDINALITY_REPEATED, CARDINALITY_REQUIRED, "cardinality");
                 mCardinality = cardinality;
@@ -2048,8 +2017,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             /**
              * Constructs a new {@link BlobHandlePropertyConfig} from the contents of this builder.
              */
-            @NonNull
-            public BlobHandlePropertyConfig build() {
+            public @NonNull BlobHandlePropertyConfig build() {
                 return new BlobHandlePropertyConfig(
                         PropertyConfigParcel.createForBlobHandle(
                                 mPropertyName, mDescription, mCardinality));
diff --git a/framework/java/external/android/app/appsearch/CommitBlobResponse.java b/framework/java/external/android/app/appsearch/CommitBlobResponse.java
index f6722ef8..ecd18322 100644
--- a/framework/java/external/android/app/appsearch/CommitBlobResponse.java
+++ b/framework/java/external/android/app/appsearch/CommitBlobResponse.java
@@ -34,12 +34,12 @@ import java.util.Objects;
  * handles.
  */
 @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 @SafeParcelable.Class(creator = "CommitBlobResponseCreator")
 public final class CommitBlobResponse extends AbstractSafeParcelable {
 
-    @NonNull
-    public static final Parcelable.Creator<CommitBlobResponse> CREATOR =
+    public static final @NonNull Parcelable.Creator<CommitBlobResponse> CREATOR =
             new CommitBlobResponseCreator();
 
     @Field(id = 1, getter = "getResponseParcel")
@@ -66,8 +66,7 @@ public final class CommitBlobResponse extends AbstractSafeParcelable {
      *     operation was successful, the result for that handle is {@code null}; if there was an
      *     error, the result contains an {@link AppSearchResult} with details of the failure.
      */
-    @NonNull
-    public AppSearchBatchResult<AppSearchBlobHandle, Void> getResult() {
+    public @NonNull AppSearchBatchResult<AppSearchBlobHandle, Void> getResult() {
         return mResultParcel.getResult();
     }
 
@@ -76,8 +75,7 @@ public final class CommitBlobResponse extends AbstractSafeParcelable {
      *
      * @hide
      */
-    @NonNull
-    public AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> getResponseParcel() {
+    public @NonNull AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> getResponseParcel() {
         return mResultParcel;
     }
 
diff --git a/framework/java/external/android/app/appsearch/EmbeddingVector.java b/framework/java/external/android/app/appsearch/EmbeddingVector.java
index 660df9b1..b8e91a95 100644
--- a/framework/java/external/android/app/appsearch/EmbeddingVector.java
+++ b/framework/java/external/android/app/appsearch/EmbeddingVector.java
@@ -44,21 +44,20 @@ import java.util.Objects;
  */
 @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
 @SafeParcelable.Class(creator = "EmbeddingVectorCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class EmbeddingVector extends AbstractSafeParcelable {
 
-    @NonNull
-    public static final Parcelable.Creator<EmbeddingVector> CREATOR = new EmbeddingVectorCreator();
+    public static final @NonNull Parcelable.Creator<EmbeddingVector> CREATOR =
+            new EmbeddingVectorCreator();
 
-    @NonNull
     @Field(id = 1, getter = "getValues")
-    private final float[] mValues;
+    private final @NonNull float[] mValues;
 
-    @NonNull
     @Field(id = 2, getter = "getModelSignature")
-    private final String mModelSignature;
+    private final @NonNull String mModelSignature;
 
-    @Nullable private Integer mHashCode;
+    private @Nullable Integer mHashCode;
 
     /**
      * Creates a new {@link EmbeddingVector}.
@@ -76,8 +75,7 @@ public final class EmbeddingVector extends AbstractSafeParcelable {
     }
 
     /** Returns the values of this embedding vector. */
-    @NonNull
-    public float[] getValues() {
+    public @NonNull float[] getValues() {
         return mValues;
     }
 
@@ -85,8 +83,7 @@ public final class EmbeddingVector extends AbstractSafeParcelable {
      * Returns the model signature of this embedding vector, which is an arbitrary string to
      * distinguish between embedding vectors generated by different models.
      */
-    @NonNull
-    public String getModelSignature() {
+    public @NonNull String getModelSignature() {
         return mModelSignature;
     }
 
diff --git a/framework/java/external/android/app/appsearch/GenericDocument.java b/framework/java/external/android/app/appsearch/GenericDocument.java
index f84f5513..a2e1e458 100644
--- a/framework/java/external/android/app/appsearch/GenericDocument.java
+++ b/framework/java/external/android/app/appsearch/GenericDocument.java
@@ -54,6 +54,8 @@ import java.util.Set;
  * @see AppSearchSession#getByDocumentId
  * @see AppSearchSession#search
  */
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings("JSpecifyNullness")
 public class GenericDocument {
     private static final String TAG = "AppSearchGenericDocumen";
 
@@ -140,8 +142,7 @@ public class GenericDocument {
     @SuppressWarnings("deprecation")
     @SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
     @FlaggedApi(Flags.FLAG_ENABLE_GENERIC_DOCUMENT_OVER_IPC)
-    @NonNull
-    public static GenericDocument createFromParcel(@NonNull Parcel parcel) {
+    public static @NonNull GenericDocument createFromParcel(@NonNull Parcel parcel) {
         Objects.requireNonNull(parcel);
         GenericDocumentParcel documentParcel;
 
@@ -167,26 +168,22 @@ public class GenericDocument {
      *
      * @hide
      */
-    @NonNull
-    public GenericDocumentParcel getDocumentParcel() {
+    public @NonNull GenericDocumentParcel getDocumentParcel() {
         return mDocumentParcel;
     }
 
     /** Returns the unique identifier of the {@link GenericDocument}. */
-    @NonNull
-    public String getId() {
+    public @NonNull String getId() {
         return mDocumentParcel.getId();
     }
 
     /** Returns the namespace of the {@link GenericDocument}. */
-    @NonNull
-    public String getNamespace() {
+    public @NonNull String getNamespace() {
         return mDocumentParcel.getNamespace();
     }
 
     /** Returns the {@link AppSearchSchema} type of the {@link GenericDocument}. */
-    @NonNull
-    public String getSchemaType() {
+    public @NonNull String getSchemaType() {
         return mDocumentParcel.getSchemaType();
     }
 
@@ -200,8 +197,7 @@ public class GenericDocument {
      * @hide
      */
     @Deprecated
-    @Nullable
-    public List<String> getParentTypes() {
+    public @Nullable List<String> getParentTypes() {
         List<String> result = mDocumentParcel.getParentTypes();
         if (result == null) {
             return null;
@@ -249,8 +245,7 @@ public class GenericDocument {
     }
 
     /** Returns the names of all properties defined in this document. */
-    @NonNull
-    public Set<String> getPropertyNames() {
+    public @NonNull Set<String> getPropertyNames() {
         return Collections.unmodifiableSet(mDocumentParcel.getPropertyNames());
     }
 
@@ -315,8 +310,7 @@ public class GenericDocument {
      *     The returned object will be one of the following types: {@code String[]}, {@code long[]},
      *     {@code double[]}, {@code boolean[]}, {@code byte[][]}, {@code GenericDocument[]}.
      */
-    @Nullable
-    public Object getProperty(@NonNull String path) {
+    public @Nullable Object getProperty(@NonNull String path) {
         Objects.requireNonNull(path);
         Object rawValue =
                 getRawPropertyFromRawDocument(
@@ -367,9 +361,8 @@ public class GenericDocument {
      * @param propertyMap the map containing the path we are looking up
      * @return the raw property
      */
-    @Nullable
     @SuppressWarnings("deprecation")
-    private static Object getRawPropertyFromRawDocument(
+    private static @Nullable Object getRawPropertyFromRawDocument(
             @NonNull PropertyPath path,
             int pathIndex,
             @NonNull Map<String, PropertyParcel> propertyMap) {
@@ -523,8 +516,7 @@ public class GenericDocument {
      * @return The result of concatenating each individual list element into a larger array/list of
      *     the same type.
      */
-    @Nullable
-    private static Object flattenAccumulator(@NonNull List<Object> accumulator) {
+    private static @Nullable Object flattenAccumulator(@NonNull List<Object> accumulator) {
         if (accumulator.isEmpty()) {
             return null;
         }
@@ -625,8 +617,7 @@ public class GenericDocument {
      * @return The first {@link String} associated with the given path or {@code null} if there is
      *     no such value or the value is of a different type.
      */
-    @Nullable
-    public String getPropertyString(@NonNull String path) {
+    public @Nullable String getPropertyString(@NonNull String path) {
         Objects.requireNonNull(path);
         String[] propertyArray = getPropertyStringArray(path);
         if (propertyArray == null || propertyArray.length == 0) {
@@ -702,8 +693,7 @@ public class GenericDocument {
      * @return The first {@code byte[]} associated with the given path or {@code null} if there is
      *     no such value or the value is of a different type.
      */
-    @Nullable
-    public byte[] getPropertyBytes(@NonNull String path) {
+    public @Nullable byte[] getPropertyBytes(@NonNull String path) {
         Objects.requireNonNull(path);
         byte[][] propertyArray = getPropertyBytesArray(path);
         if (propertyArray == null || propertyArray.length == 0) {
@@ -722,8 +712,7 @@ public class GenericDocument {
      * @return The first {@link GenericDocument} associated with the given path or {@code null} if
      *     there is no such value or the value is of a different type.
      */
-    @Nullable
-    public GenericDocument getPropertyDocument(@NonNull String path) {
+    public @Nullable GenericDocument getPropertyDocument(@NonNull String path) {
         Objects.requireNonNull(path);
         GenericDocument[] propertyArray = getPropertyDocumentArray(path);
         if (propertyArray == null || propertyArray.length == 0) {
@@ -742,9 +731,8 @@ public class GenericDocument {
      * @return The first {@code EmbeddingVector[]} associated with the given path or {@code null} if
      *     there is no such value or the value is of a different type.
      */
-    @Nullable
     @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
-    public EmbeddingVector getPropertyEmbedding(@NonNull String path) {
+    public @Nullable EmbeddingVector getPropertyEmbedding(@NonNull String path) {
         Objects.requireNonNull(path);
         EmbeddingVector[] propertyArray = getPropertyEmbeddingArray(path);
         if (propertyArray == null || propertyArray.length == 0) {
@@ -766,9 +754,8 @@ public class GenericDocument {
      * @return The first {@link AppSearchBlobHandle} associated with the given path or {@code null}
      *     if there is no such value or the value is of a different type.
      */
-    @Nullable
     @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-    public AppSearchBlobHandle getPropertyBlobHandle(@NonNull String path) {
+    public @Nullable AppSearchBlobHandle getPropertyBlobHandle(@NonNull String path) {
         Objects.requireNonNull(path);
         AppSearchBlobHandle[] propertyArray = getPropertyBlobHandleArray(path);
         if (propertyArray == null || propertyArray.length == 0) {
@@ -812,8 +799,7 @@ public class GenericDocument {
      * @return The {@code String[]} associated with the given path, or {@code null} if no value is
      *     set or the value is of a different type.
      */
-    @Nullable
-    public String[] getPropertyStringArray(@NonNull String path) {
+    public @Nullable String[] getPropertyStringArray(@NonNull String path) {
         Objects.requireNonNull(path);
         Object value = getProperty(path);
         return safeCastProperty(path, value, String[].class);
@@ -834,8 +820,7 @@ public class GenericDocument {
      * @return The {@code long[]} associated with the given path, or {@code null} if no value is set
      *     or the value is of a different type.
      */
-    @Nullable
-    public long[] getPropertyLongArray(@NonNull String path) {
+    public @Nullable long[] getPropertyLongArray(@NonNull String path) {
         Objects.requireNonNull(path);
         Object value = getProperty(path);
         return safeCastProperty(path, value, long[].class);
@@ -856,8 +841,7 @@ public class GenericDocument {
      * @return The {@code double[]} associated with the given path, or {@code null} if no value is
      *     set or the value is of a different type.
      */
-    @Nullable
-    public double[] getPropertyDoubleArray(@NonNull String path) {
+    public @Nullable double[] getPropertyDoubleArray(@NonNull String path) {
         Objects.requireNonNull(path);
         Object value = getProperty(path);
         return safeCastProperty(path, value, double[].class);
@@ -878,8 +862,7 @@ public class GenericDocument {
      * @return The {@code boolean[]} associated with the given path, or {@code null} if no value is
      *     set or the value is of a different type.
      */
-    @Nullable
-    public boolean[] getPropertyBooleanArray(@NonNull String path) {
+    public @Nullable boolean[] getPropertyBooleanArray(@NonNull String path) {
         Objects.requireNonNull(path);
         Object value = getProperty(path);
         return safeCastProperty(path, value, boolean[].class);
@@ -903,8 +886,7 @@ public class GenericDocument {
      *     set or the value is of a different type.
      */
     @SuppressLint("ArrayReturn")
-    @Nullable
-    public byte[][] getPropertyBytesArray(@NonNull String path) {
+    public @Nullable byte[][] getPropertyBytesArray(@NonNull String path) {
         Objects.requireNonNull(path);
         Object value = getProperty(path);
         return safeCastProperty(path, value, byte[][].class);
@@ -928,8 +910,7 @@ public class GenericDocument {
      *     value is set or the value is of a different type.
      */
     @SuppressLint("ArrayReturn")
-    @Nullable
-    public GenericDocument[] getPropertyDocumentArray(@NonNull String path) {
+    public @Nullable GenericDocument[] getPropertyDocumentArray(@NonNull String path) {
         Objects.requireNonNull(path);
         Object value = getProperty(path);
         return safeCastProperty(path, value, GenericDocument[].class);
@@ -951,9 +932,8 @@ public class GenericDocument {
      *     value is set or the value is of a different type.
      */
     @SuppressLint({"ArrayReturn", "NullableCollection"})
-    @Nullable
     @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
-    public EmbeddingVector[] getPropertyEmbeddingArray(@NonNull String path) {
+    public @Nullable EmbeddingVector[] getPropertyEmbeddingArray(@NonNull String path) {
         Objects.requireNonNull(path);
         Object value = getProperty(path);
         return safeCastProperty(path, value, EmbeddingVector[].class);
@@ -975,9 +955,8 @@ public class GenericDocument {
      *     no value is set or the value is of a different type.
      */
     @SuppressLint({"ArrayReturn", "NullableCollection"})
-    @Nullable
     @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-    public AppSearchBlobHandle[] getPropertyBlobHandleArray(@NonNull String path) {
+    public @Nullable AppSearchBlobHandle[] getPropertyBlobHandleArray(@NonNull String path) {
         Objects.requireNonNull(path);
         Object value = getProperty(path);
         return safeCastProperty(path, value, AppSearchBlobHandle[].class);
@@ -991,8 +970,7 @@ public class GenericDocument {
      * @param value Value of the property
      * @param tClass Class to cast the value into
      */
-    @Nullable
-    private static <T> T safeCastProperty(
+    private static <T> @Nullable T safeCastProperty(
             @NonNull String path, @Nullable Object value, @NonNull Class<T> tClass) {
         if (value == null) {
             return null;
@@ -1023,8 +1001,7 @@ public class GenericDocument {
     }
 
     @Override
-    @NonNull
-    public String toString() {
+    public @NonNull String toString() {
         IndentingStringBuilder stringBuilder = new IndentingStringBuilder();
         appendGenericDocumentString(stringBuilder);
         return stringBuilder.toString();
@@ -1196,8 +1173,7 @@ public class GenericDocument {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_GENERIC_DOCUMENT_BUILDER_HIDDEN_METHODS)
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setNamespace(@NonNull String namespace) {
+        public @NonNull BuilderType setNamespace(@NonNull String namespace) {
             Objects.requireNonNull(namespace);
             mDocumentParcelBuilder.setNamespace(namespace);
             return mBuilderTypeInstance;
@@ -1214,8 +1190,7 @@ public class GenericDocument {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_GENERIC_DOCUMENT_BUILDER_HIDDEN_METHODS)
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setId(@NonNull String id) {
+        public @NonNull BuilderType setId(@NonNull String id) {
             Objects.requireNonNull(id);
             mDocumentParcelBuilder.setId(id);
             return mBuilderTypeInstance;
@@ -1229,8 +1204,7 @@ public class GenericDocument {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_GENERIC_DOCUMENT_BUILDER_HIDDEN_METHODS)
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setSchemaType(@NonNull String schemaType) {
+        public @NonNull BuilderType setSchemaType(@NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             mDocumentParcelBuilder.setSchemaType(schemaType);
             return mBuilderTypeInstance;
@@ -1247,8 +1221,7 @@ public class GenericDocument {
          */
         @CanIgnoreReturnValue
         @Deprecated
-        @NonNull
-        public BuilderType setParentTypes(@Nullable List<String> parentTypes) {
+        public @NonNull BuilderType setParentTypes(@Nullable List<String> parentTypes) {
             mDocumentParcelBuilder.setParentTypes(parentTypes);
             return mBuilderTypeInstance;
         }
@@ -1268,8 +1241,8 @@ public class GenericDocument {
          * @throws IllegalArgumentException if the score is negative.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setScore(@IntRange(from = 0, to = Integer.MAX_VALUE) int score) {
+        public @NonNull BuilderType setScore(
+                @IntRange(from = 0, to = Integer.MAX_VALUE) int score) {
             if (score < 0) {
                 throw new IllegalArgumentException("Document score cannot be negative.");
             }
@@ -1288,8 +1261,7 @@ public class GenericDocument {
          * @param creationTimestampMillis a creation timestamp in milliseconds.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setCreationTimestampMillis(
+        public @NonNull BuilderType setCreationTimestampMillis(
                 @CurrentTimeMillisLong long creationTimestampMillis) {
             mDocumentParcelBuilder.setCreationTimestampMillis(creationTimestampMillis);
             return mBuilderTypeInstance;
@@ -1309,8 +1281,7 @@ public class GenericDocument {
          * @throws IllegalArgumentException if ttlMillis is negative.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setTtlMillis(long ttlMillis) {
+        public @NonNull BuilderType setTtlMillis(long ttlMillis) {
             if (ttlMillis < 0) {
                 throw new IllegalArgumentException("Document ttlMillis cannot be negative.");
             }
@@ -1328,8 +1299,8 @@ public class GenericDocument {
          *     String} is {@code null} or "".
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setPropertyString(@NonNull String name, @NonNull String... values) {
+        public @NonNull BuilderType setPropertyString(
+                @NonNull String name, @NonNull String... values) {
             Objects.requireNonNull(name);
             Objects.requireNonNull(values);
             validatePropertyName(name);
@@ -1352,8 +1323,8 @@ public class GenericDocument {
          * @throws IllegalArgumentException if the name is empty or {@code null}.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setPropertyBoolean(@NonNull String name, @NonNull boolean... values) {
+        public @NonNull BuilderType setPropertyBoolean(
+                @NonNull String name, @NonNull boolean... values) {
             Objects.requireNonNull(name);
             Objects.requireNonNull(values);
             validatePropertyName(name);
@@ -1370,8 +1341,7 @@ public class GenericDocument {
          * @throws IllegalArgumentException if the name is empty or {@code null}.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setPropertyLong(@NonNull String name, @NonNull long... values) {
+        public @NonNull BuilderType setPropertyLong(@NonNull String name, @NonNull long... values) {
             Objects.requireNonNull(name);
             Objects.requireNonNull(values);
             validatePropertyName(name);
@@ -1388,8 +1358,8 @@ public class GenericDocument {
          * @throws IllegalArgumentException if the name is empty or {@code null}.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setPropertyDouble(@NonNull String name, @NonNull double... values) {
+        public @NonNull BuilderType setPropertyDouble(
+                @NonNull String name, @NonNull double... values) {
             Objects.requireNonNull(name);
             Objects.requireNonNull(values);
             validatePropertyName(name);
@@ -1409,8 +1379,8 @@ public class GenericDocument {
          *     byte[]} is {@code null}, or if name is empty.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setPropertyBytes(@NonNull String name, @NonNull byte[]... values) {
+        public @NonNull BuilderType setPropertyBytes(
+                @NonNull String name, @NonNull byte[]... values) {
             Objects.requireNonNull(name);
             Objects.requireNonNull(values);
             validatePropertyName(name);
@@ -1434,8 +1404,7 @@ public class GenericDocument {
          *     GenericDocument} is {@code null}, or if name is empty.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType setPropertyDocument(
+        public @NonNull BuilderType setPropertyDocument(
                 @NonNull String name, @NonNull GenericDocument... values) {
             Objects.requireNonNull(name);
             Objects.requireNonNull(values);
@@ -1461,9 +1430,8 @@ public class GenericDocument {
          * @throws IllegalArgumentException if the name is empty or {@code null}.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
-        public BuilderType setPropertyEmbedding(
+        public @NonNull BuilderType setPropertyEmbedding(
                 @NonNull String name, @NonNull EmbeddingVector... values) {
             Objects.requireNonNull(name);
             Objects.requireNonNull(values);
@@ -1494,9 +1462,8 @@ public class GenericDocument {
          * @throws IllegalArgumentException if the name is empty or {@code null}.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-        public BuilderType setPropertyBlobHandle(
+        public @NonNull BuilderType setPropertyBlobHandle(
                 @NonNull String name, @NonNull AppSearchBlobHandle... values) {
             Objects.requireNonNull(name);
             Objects.requireNonNull(values);
@@ -1525,16 +1492,14 @@ public class GenericDocument {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_GENERIC_DOCUMENT_BUILDER_HIDDEN_METHODS)
         @CanIgnoreReturnValue
-        @NonNull
-        public BuilderType clearProperty(@NonNull String name) {
+        public @NonNull BuilderType clearProperty(@NonNull String name) {
             Objects.requireNonNull(name);
             mDocumentParcelBuilder.clearProperty(name);
             return mBuilderTypeInstance;
         }
 
         /** Builds the {@link GenericDocument} object. */
-        @NonNull
-        public GenericDocument build() {
+        public @NonNull GenericDocument build() {
             return new GenericDocument(mDocumentParcelBuilder.build());
         }
 
diff --git a/framework/java/external/android/app/appsearch/GetByDocumentIdRequest.java b/framework/java/external/android/app/appsearch/GetByDocumentIdRequest.java
index 33758fea..3faa9620 100644
--- a/framework/java/external/android/app/appsearch/GetByDocumentIdRequest.java
+++ b/framework/java/external/android/app/appsearch/GetByDocumentIdRequest.java
@@ -46,13 +46,13 @@ import java.util.Set;
  *
  * @see AppSearchSession#getByDocumentId
  */
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 @SafeParcelable.Class(creator = "GetByDocumentIdRequestCreator")
 public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<GetByDocumentIdRequest> CREATOR =
+    public static final @NonNull Parcelable.Creator<GetByDocumentIdRequest> CREATOR =
             new GetByDocumentIdRequestCreator();
 
     /**
@@ -62,20 +62,17 @@ public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
      */
     public static final String PROJECTION_SCHEMA_TYPE_WILDCARD = "*";
 
-    @NonNull
     @Field(id = 1, getter = "getNamespace")
-    private final String mNamespace;
+    private final @NonNull String mNamespace;
 
-    @NonNull
     @Field(id = 2)
-    final List<String> mIds;
+    final @NonNull List<String> mIds;
 
-    @NonNull
     @Field(id = 3)
-    final Bundle mTypePropertyPaths;
+    final @NonNull Bundle mTypePropertyPaths;
 
     /** Cache of the ids. Comes from inflating mIds at first use. */
-    @Nullable private Set<String> mIdsCached;
+    private @Nullable Set<String> mIdsCached;
 
     @Constructor
     GetByDocumentIdRequest(
@@ -88,14 +85,12 @@ public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
     }
 
     /** Returns the namespace attached to the request. */
-    @NonNull
-    public String getNamespace() {
+    public @NonNull String getNamespace() {
         return mNamespace;
     }
 
     /** Returns the set of document IDs attached to the request. */
-    @NonNull
-    public Set<String> getIds() {
+    public @NonNull Set<String> getIds() {
         if (mIdsCached == null) {
             mIdsCached = Collections.unmodifiableSet(new ArraySet<>(mIds));
         }
@@ -110,8 +105,7 @@ public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
      * <p>Calling this function repeatedly is inefficient. Prefer to retain the Map returned by this
      * function, rather than calling it multiple times.
      */
-    @NonNull
-    public Map<String, List<String>> getProjections() {
+    public @NonNull Map<String, List<String>> getProjections() {
         Set<String> schemas = mTypePropertyPaths.keySet();
         Map<String, List<String>> typePropertyPathsMap = new ArrayMap<>(schemas.size());
         for (String schema : schemas) {
@@ -131,8 +125,7 @@ public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
      * <p>Calling this function repeatedly is inefficient. Prefer to retain the Map returned by this
      * function, rather than calling it multiple times.
      */
-    @NonNull
-    public Map<String, List<PropertyPath>> getProjectionPaths() {
+    public @NonNull Map<String, List<PropertyPath>> getProjectionPaths() {
         Set<String> schemas = mTypePropertyPaths.keySet();
         Map<String, List<PropertyPath>> typePropertyPathsMap = new ArrayMap<>(schemas.size());
         for (String schema : schemas) {
@@ -169,8 +162,7 @@ public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
 
         /** Adds one or more document IDs to the request. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addIds(@NonNull String... ids) {
+        public @NonNull Builder addIds(@NonNull String... ids) {
             Objects.requireNonNull(ids);
             resetIfBuilt();
             return addIds(Arrays.asList(ids));
@@ -178,8 +170,7 @@ public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
 
         /** Adds a collection of IDs to the request. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addIds(@NonNull Collection<String> ids) {
+        public @NonNull Builder addIds(@NonNull Collection<String> ids) {
             Objects.requireNonNull(ids);
             resetIfBuilt();
             mIds.addAll(ids);
@@ -203,8 +194,7 @@ public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
          * @see SearchSpec.Builder#addProjectionPaths
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addProjection(
+        public @NonNull Builder addProjection(
                 @NonNull String schemaType, @NonNull Collection<String> propertyPaths) {
             Objects.requireNonNull(schemaType);
             Objects.requireNonNull(propertyPaths);
@@ -235,8 +225,7 @@ public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
          * @see SearchSpec.Builder#addProjectionPaths
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addProjectionPaths(
+        public @NonNull Builder addProjectionPaths(
                 @NonNull String schemaType, @NonNull Collection<PropertyPath> propertyPaths) {
             Objects.requireNonNull(schemaType);
             Objects.requireNonNull(propertyPaths);
@@ -248,8 +237,7 @@ public final class GetByDocumentIdRequest extends AbstractSafeParcelable {
         }
 
         /** Builds a new {@link GetByDocumentIdRequest}. */
-        @NonNull
-        public GetByDocumentIdRequest build() {
+        public @NonNull GetByDocumentIdRequest build() {
             mBuilt = true;
             return new GetByDocumentIdRequest(mNamespace, mIds, mProjectionTypePropertyPaths);
         }
diff --git a/framework/java/external/android/app/appsearch/GetSchemaResponse.java b/framework/java/external/android/app/appsearch/GetSchemaResponse.java
index db510bd4..dbe44f2c 100644
--- a/framework/java/external/android/app/appsearch/GetSchemaResponse.java
+++ b/framework/java/external/android/app/appsearch/GetSchemaResponse.java
@@ -41,12 +41,12 @@ import java.util.Set;
 
 /** The response class of {@link AppSearchSession#getSchema} */
 @SafeParcelable.Class(creator = "GetSchemaResponseCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class GetSchemaResponse extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<GetSchemaResponse> CREATOR =
+    public static final @NonNull Parcelable.Creator<GetSchemaResponse> CREATOR =
             new GetSchemaResponseCreator();
 
     @Field(id = 1, getter = "getVersion")
@@ -60,29 +60,28 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
      * visibility settings is not possible on the current backend.
      */
     @Field(id = 3)
-    @Nullable
-    final List<InternalVisibilityConfig> mVisibilityConfigs;
+    final @Nullable List<InternalVisibilityConfig> mVisibilityConfigs;
 
     /**
      * This set contains all schemas most recently successfully provided to {@link
      * AppSearchSession#setSchema}. We do lazy fetch, the object will be created when you first time
      * fetch it.
      */
-    @Nullable private Set<AppSearchSchema> mSchemasCached;
+    private @Nullable Set<AppSearchSchema> mSchemasCached;
 
     /**
      * This Set contains all schemas that are not displayed by the system. All values in the set are
      * prefixed with the package-database prefix. We do lazy fetch, the object will be created when
      * you first time fetch it.
      */
-    @Nullable private Set<String> mSchemasNotDisplayedBySystemCached;
+    private @Nullable Set<String> mSchemasNotDisplayedBySystemCached;
 
     /**
      * This map contains all schemas and {@link PackageIdentifier} that has access to the schema.
      * All keys in the map are prefixed with the package-database prefix. We do lazy fetch, the
      * object will be created when you first time fetch it.
      */
-    @Nullable private Map<String, Set<PackageIdentifier>> mSchemasVisibleToPackagesCached;
+    private @Nullable Map<String, Set<PackageIdentifier>> mSchemasVisibleToPackagesCached;
 
     /**
      * This map contains all schemas and Android Permissions combinations that are required to
@@ -93,20 +92,20 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
      *
      * @see SetSchemaRequest.Builder#addRequiredPermissionsForSchemaTypeVisibility(String, Set)
      */
-    @Nullable private Map<String, Set<Set<Integer>>> mSchemasVisibleToPermissionsCached;
+    private @Nullable Map<String, Set<Set<Integer>>> mSchemasVisibleToPermissionsCached;
 
     /**
      * This map contains all publicly visible schemas and the {@link PackageIdentifier} specifying
      * the package that the schemas are from.
      */
-    @Nullable private Map<String, PackageIdentifier> mPubliclyVisibleSchemasCached;
+    private @Nullable Map<String, PackageIdentifier> mPubliclyVisibleSchemasCached;
 
     /**
      * This map contains all {@link SchemaVisibilityConfig}s that has access to the schema. All keys
      * in the map are prefixed with the package-database prefix. We do lazy fetch, the object will
      * be created when you first time fetch it.
      */
-    @Nullable private Map<String, Set<SchemaVisibilityConfig>> mSchemasVisibleToConfigsCached;
+    private @Nullable Map<String, Set<SchemaVisibilityConfig>> mSchemasVisibleToConfigsCached;
 
     @Constructor
     GetSchemaResponse(
@@ -131,8 +130,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
     /**
      * Return the schemas most recently successfully provided to {@link AppSearchSession#setSchema}.
      */
-    @NonNull
-    public Set<AppSearchSchema> getSchemas() {
+    public @NonNull Set<AppSearchSchema> getSchemas() {
         if (mSchemasCached == null) {
             mSchemasCached = Collections.unmodifiableSet(new ArraySet<>(mSchemas));
         }
@@ -143,8 +141,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
      * Returns all the schema types that are opted out of being displayed and visible on any system
      * UI surface.
      */
-    @NonNull
-    public Set<String> getSchemaTypesNotDisplayedBySystem() {
+    public @NonNull Set<String> getSchemaTypesNotDisplayedBySystem() {
         List<InternalVisibilityConfig> visibilityConfigs = getVisibilityConfigsOrThrow();
         if (mSchemasNotDisplayedBySystemCached == null) {
             Set<String> copy = new ArraySet<>();
@@ -162,8 +159,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
      * Returns a mapping of schema types to the set of packages that have access to that schema
      * type.
      */
-    @NonNull
-    public Map<String, Set<PackageIdentifier>> getSchemaTypesVisibleToPackages() {
+    public @NonNull Map<String, Set<PackageIdentifier>> getSchemaTypesVisibleToPackages() {
         List<InternalVisibilityConfig> visibilityConfigs = getVisibilityConfigsOrThrow();
         if (mSchemasVisibleToPackagesCached == null) {
             Map<String, Set<PackageIdentifier>> copy = new ArrayMap<>();
@@ -209,9 +205,10 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
      *     SetSchemaRequest#READ_ASSISTANT_APP_SEARCH_DATA}.
      */
     // TODO(b/237388235): add enterprise permissions to javadocs after they're unhidden
-
-    @NonNull
-    public Map<String, Set<Set<Integer>>> getRequiredPermissionsForSchemaTypeVisibility() {
+    // Annotation is here to suppress lint error. Lint error is erroneous since the method does not
+    // require the caller to hold any permission for the method to function.
+    @SuppressLint("RequiresPermission")
+    public @NonNull Map<String, Set<Set<Integer>>> getRequiredPermissionsForSchemaTypeVisibility() {
         List<InternalVisibilityConfig> visibilityConfigs = getVisibilityConfigsOrThrow();
         if (mSchemasVisibleToPermissionsCached == null) {
             Map<String, Set<Set<Integer>>> copy = new ArrayMap<>();
@@ -237,8 +234,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
      * <p>If no schemas have been set as publicly visible, an empty set will be returned.
      */
     @FlaggedApi(Flags.FLAG_ENABLE_SET_PUBLICLY_VISIBLE_SCHEMA)
-    @NonNull
-    public Map<String, PackageIdentifier> getPubliclyVisibleSchemas() {
+    public @NonNull Map<String, PackageIdentifier> getPubliclyVisibleSchemas() {
         List<InternalVisibilityConfig> visibilityConfigs = getVisibilityConfigsOrThrow();
         if (mPubliclyVisibleSchemasCached == null) {
             Map<String, PackageIdentifier> copy = new ArrayMap<>();
@@ -262,8 +258,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
      * @see SetSchemaRequest.Builder#addSchemaTypeVisibleToConfig
      */
     @FlaggedApi(Flags.FLAG_ENABLE_SET_SCHEMA_VISIBLE_TO_CONFIGS)
-    @NonNull
-    public Map<String, Set<SchemaVisibilityConfig>> getSchemaTypesVisibleToConfigs() {
+    public @NonNull Map<String, Set<SchemaVisibilityConfig>> getSchemaTypesVisibleToConfigs() {
         List<InternalVisibilityConfig> visibilityConfigs = getVisibilityConfigsOrThrow();
         if (mSchemasVisibleToConfigsCached == null) {
             Map<String, Set<SchemaVisibilityConfig>> copy = new ArrayMap<>();
@@ -282,8 +277,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         return mSchemasVisibleToConfigsCached;
     }
 
-    @NonNull
-    private List<InternalVisibilityConfig> getVisibilityConfigsOrThrow() {
+    private @NonNull List<InternalVisibilityConfig> getVisibilityConfigsOrThrow() {
         List<InternalVisibilityConfig> visibilityConfigs = mVisibilityConfigs;
         if (visibilityConfigs == null) {
             throw new UnsupportedOperationException(
@@ -308,7 +302,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
          * Creates the object when we actually set them. If we never set visibility settings, we
          * should throw {@link UnsupportedOperationException} in the visibility getters.
          */
-        @Nullable private Map<String, InternalVisibilityConfig.Builder> mVisibilityConfigBuilders;
+        private @Nullable Map<String, InternalVisibilityConfig.Builder> mVisibilityConfigBuilders;
 
         private boolean mBuilt = false;
 
@@ -339,8 +333,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
          * <p>Default version is 0
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setVersion(@IntRange(from = 0) int version) {
+        public @NonNull Builder setVersion(@IntRange(from = 0) int version) {
             Preconditions.checkArgument(version >= 0, "Version must be a non-negative number.");
             resetIfBuilt();
             mVersion = version;
@@ -349,8 +342,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
 
         /** Adds one {@link AppSearchSchema} to the schema list. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addSchema(@NonNull AppSearchSchema schema) {
+        public @NonNull Builder addSchema(@NonNull AppSearchSchema schema) {
             Objects.requireNonNull(schema);
             resetIfBuilt();
             mSchemas.add(schema);
@@ -360,8 +352,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         /** Clears all {@link AppSearchSchema}s from the list of schemas. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearSchemas() {
+        public @NonNull Builder clearSchemas() {
             resetIfBuilt();
             mSchemas.clear();
             return this;
@@ -377,8 +368,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         // Getter getSchemaTypesNotDisplayedBySystem returns plural objects.
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
-        @NonNull
-        public Builder addSchemaTypeNotDisplayedBySystem(@NonNull String schemaType) {
+        public @NonNull Builder addSchemaTypeNotDisplayedBySystem(@NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
             InternalVisibilityConfig.Builder visibilityConfigBuilder =
@@ -395,8 +385,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearSchemaTypeNotDisplayedBySystem(@NonNull String schemaType) {
+        public @NonNull Builder clearSchemaTypeNotDisplayedBySystem(@NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
             InternalVisibilityConfig.Builder visibilityConfigBuilder =
@@ -428,8 +417,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         // Getter getSchemaTypesVisibleToPackages returns a map contains all schema types.
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
-        @NonNull
-        public Builder setSchemaTypeVisibleToPackages(
+        public @NonNull Builder setSchemaTypeVisibleToPackages(
                 @NonNull String schemaType, @NonNull Set<PackageIdentifier> packageIdentifiers) {
             Objects.requireNonNull(schemaType);
             Objects.requireNonNull(packageIdentifiers);
@@ -449,8 +437,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearSchemaTypeVisibleToPackages(@NonNull String schemaType) {
+        public @NonNull Builder clearSchemaTypeVisibleToPackages(@NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
             InternalVisibilityConfig.Builder visibilityConfigBuilder =
@@ -497,8 +484,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         @SuppressLint({"MissingGetterMatchingBuilder", "RequiresPermission"})
         // @SetSchemaRequest is an IntDef annotation applied to Set<Set<Integer>>.
         @SuppressWarnings("SupportAnnotationUsage")
-        @NonNull
-        public Builder setRequiredPermissionsForSchemaTypeVisibility(
+        public @NonNull Builder setRequiredPermissionsForSchemaTypeVisibility(
                 @NonNull String schemaType,
                 @SetSchemaRequest.AppSearchSupportedPermission @NonNull
                         Set<Set<Integer>> visibleToPermissionSets) {
@@ -524,8 +510,8 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         @SuppressLint("RequiresPermission")
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearRequiredPermissionsForSchemaTypeVisibility(@NonNull String schemaType) {
+        public @NonNull Builder clearRequiredPermissionsForSchemaTypeVisibility(
+                @NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
             InternalVisibilityConfig.Builder visibilityConfigBuilder =
@@ -548,8 +534,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
         @FlaggedApi(Flags.FLAG_ENABLE_SET_PUBLICLY_VISIBLE_SCHEMA)
-        @NonNull
-        public Builder setPubliclyVisibleSchema(
+        public @NonNull Builder setPubliclyVisibleSchema(
                 @NonNull String schemaType, @NonNull PackageIdentifier packageIdentifier) {
             Objects.requireNonNull(schemaType);
             Objects.requireNonNull(packageIdentifier);
@@ -568,8 +553,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearPubliclyVisibleSchema(@NonNull String schemaType) {
+        public @NonNull Builder clearPubliclyVisibleSchema(@NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
             InternalVisibilityConfig.Builder visibilityConfigBuilder =
@@ -611,8 +595,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
         @FlaggedApi(Flags.FLAG_ENABLE_SET_SCHEMA_VISIBLE_TO_CONFIGS)
-        @NonNull
-        public Builder setSchemaTypeVisibleToConfigs(
+        public @NonNull Builder setSchemaTypeVisibleToConfigs(
                 @NonNull String schemaType, @NonNull Set<SchemaVisibilityConfig> visibleToConfigs) {
             Objects.requireNonNull(schemaType);
             Objects.requireNonNull(visibleToConfigs);
@@ -634,8 +617,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearSchemaTypeVisibleToConfigs(@NonNull String schemaType) {
+        public @NonNull Builder clearSchemaTypeVisibleToConfigs(@NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
             InternalVisibilityConfig.Builder visibilityConfigBuilder =
@@ -660,8 +642,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         // Visibility setting is determined by SDK version, so it won't be needed in framework
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
-        @NonNull
-        public Builder setVisibilitySettingSupported(boolean visibilitySettingSupported) {
+        public @NonNull Builder setVisibilitySettingSupported(boolean visibilitySettingSupported) {
             if (visibilitySettingSupported) {
                 mVisibilityConfigBuilders = new ArrayMap<>();
             } else {
@@ -671,8 +652,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         }
 
         /** Builds a {@link GetSchemaResponse} object. */
-        @NonNull
-        public GetSchemaResponse build() {
+        public @NonNull GetSchemaResponse build() {
             List<InternalVisibilityConfig> visibilityConfigs = null;
             if (mVisibilityConfigBuilders != null) {
                 visibilityConfigs = new ArrayList<>();
@@ -685,8 +665,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
             return new GetSchemaResponse(mVersion, mSchemas, visibilityConfigs);
         }
 
-        @NonNull
-        private InternalVisibilityConfig.Builder getOrCreateVisibilityConfigBuilder(
+        private @NonNull InternalVisibilityConfig.Builder getOrCreateVisibilityConfigBuilder(
                 @NonNull String schemaType) {
             if (mVisibilityConfigBuilders == null) {
                 throw new IllegalStateException(
@@ -700,8 +679,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
             return builder;
         }
 
-        @Nullable
-        private InternalVisibilityConfig.Builder getVisibilityConfigBuilder(
+        private @Nullable InternalVisibilityConfig.Builder getVisibilityConfigBuilder(
                 @NonNull String schemaType) {
             if (mVisibilityConfigBuilders == null) {
                 throw new IllegalStateException(
diff --git a/framework/java/external/android/app/appsearch/InternalSetSchemaResponse.java b/framework/java/external/android/app/appsearch/InternalSetSchemaResponse.java
index 3d1d2683..6579d559 100644
--- a/framework/java/external/android/app/appsearch/InternalSetSchemaResponse.java
+++ b/framework/java/external/android/app/appsearch/InternalSetSchemaResponse.java
@@ -17,8 +17,6 @@
 package android.app.appsearch;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.safeparcel.AbstractSafeParcelable;
 import android.app.appsearch.safeparcel.SafeParcelable;
 import android.os.Parcel;
@@ -26,6 +24,9 @@ import android.os.Parcelable;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Objects;
 
 /**
@@ -42,8 +43,7 @@ import java.util.Objects;
 public class InternalSetSchemaResponse extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<InternalSetSchemaResponse> CREATOR =
+    public static final Parcelable.@NonNull Creator<InternalSetSchemaResponse> CREATOR =
             new InternalSetSchemaResponseCreator();
 
     @Field(id = 1, getter = "isSuccess")
@@ -53,8 +53,7 @@ public class InternalSetSchemaResponse extends AbstractSafeParcelable {
     private final SetSchemaResponse mSetSchemaResponse;
 
     @Field(id = 3, getter = "getErrorMessage")
-    @Nullable
-    private final String mErrorMessage;
+    private final @Nullable String mErrorMessage;
 
     @Constructor
     public InternalSetSchemaResponse(
@@ -72,8 +71,7 @@ public class InternalSetSchemaResponse extends AbstractSafeParcelable {
      *
      * @param setSchemaResponse The object this internal object represents.
      */
-    @NonNull
-    public static InternalSetSchemaResponse newSuccessfulSetSchemaResponse(
+    public static @NonNull InternalSetSchemaResponse newSuccessfulSetSchemaResponse(
             @NonNull SetSchemaResponse setSchemaResponse) {
         return new InternalSetSchemaResponse(
                 /* isSuccess= */ true, setSchemaResponse, /* errorMessage= */ null);
@@ -85,8 +83,7 @@ public class InternalSetSchemaResponse extends AbstractSafeParcelable {
      * @param setSchemaResponse The object this internal object represents.
      * @param errorMessage An string describing the reason or nature of the failure.
      */
-    @NonNull
-    public static InternalSetSchemaResponse newFailedSetSchemaResponse(
+    public static @NonNull InternalSetSchemaResponse newFailedSetSchemaResponse(
             @NonNull SetSchemaResponse setSchemaResponse, @NonNull String errorMessage) {
         return new InternalSetSchemaResponse(
                 /* isSuccess= */ false, setSchemaResponse, errorMessage);
@@ -102,8 +99,7 @@ public class InternalSetSchemaResponse extends AbstractSafeParcelable {
      *
      * <p>The call may or may not success. Check {@link #isSuccess()} before call this method.
      */
-    @NonNull
-    public SetSchemaResponse getSetSchemaResponse() {
+    public @NonNull SetSchemaResponse getSetSchemaResponse() {
         return mSetSchemaResponse;
     }
 
@@ -112,8 +108,7 @@ public class InternalSetSchemaResponse extends AbstractSafeParcelable {
      *
      * <p>If {@link #isSuccess} is {@code true}, the error message is always {@code null}.
      */
-    @Nullable
-    public String getErrorMessage() {
+    public @Nullable String getErrorMessage() {
         return mErrorMessage;
     }
 
diff --git a/framework/java/external/android/app/appsearch/InternalVisibilityConfig.java b/framework/java/external/android/app/appsearch/InternalVisibilityConfig.java
index 8ec15fb2..153da297 100644
--- a/framework/java/external/android/app/appsearch/InternalVisibilityConfig.java
+++ b/framework/java/external/android/app/appsearch/InternalVisibilityConfig.java
@@ -17,8 +17,6 @@
 package android.app.appsearch;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.app.appsearch.safeparcel.AbstractSafeParcelable;
 import android.app.appsearch.safeparcel.SafeParcelable;
@@ -28,6 +26,9 @@ import android.util.ArraySet;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -42,13 +43,12 @@ import java.util.Set;
  */
 @SafeParcelable.Class(creator = "InternalVisibilityConfigCreator")
 public final class InternalVisibilityConfig extends AbstractSafeParcelable {
-    @NonNull
-    public static final Parcelable.Creator<InternalVisibilityConfig> CREATOR =
+
+    public static final Parcelable.@NonNull Creator<InternalVisibilityConfig> CREATOR =
             new InternalVisibilityConfigCreator();
 
     /** Build the List of {@link InternalVisibilityConfig}s from given {@link SetSchemaRequest}. */
-    @NonNull
-    public static List<InternalVisibilityConfig> toInternalVisibilityConfigs(
+    public static @NonNull List<InternalVisibilityConfig> toInternalVisibilityConfigs(
             @NonNull SetSchemaRequest setSchemaRequest) {
         Set<AppSearchSchema> searchSchemas = setSchemaRequest.getSchemas();
         Set<String> schemasNotDisplayedBySystem = setSchemaRequest.getSchemasNotDisplayedBySystem();
@@ -104,8 +104,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
      * Build the List of {@link InternalVisibilityConfig}s from given {@link
      * SetBlobVisibilityRequest}.
      */
-    @NonNull
-    public static List<InternalVisibilityConfig> toInternalVisibilityConfigs(
+    public static @NonNull List<InternalVisibilityConfig> toInternalVisibilityConfigs(
             @NonNull SetBlobVisibilityRequest setBlobVisibilityRequest) {
 
         Set<String> blobNamespacesNotDisplayedBySystem =
@@ -136,22 +135,19 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
         return result;
     }
 
-    @NonNull
     @Field(id = 1, getter = "getSchemaType")
-    private final String mSchemaType;
+    private final @NonNull String mSchemaType;
 
     @Field(id = 2, getter = "isNotDisplayedBySystem")
     private final boolean mIsNotDisplayedBySystem;
 
     /** The public visibility settings available in VisibilityConfig. */
-    @NonNull
     @Field(id = 3, getter = "getVisibilityConfig")
-    private final SchemaVisibilityConfig mVisibilityConfig;
+    private final @NonNull SchemaVisibilityConfig mVisibilityConfig;
 
     /** Extended visibility settings from {@link SetSchemaRequest#getSchemasVisibleToConfigs()} */
-    @NonNull
     @Field(id = 4)
-    final List<SchemaVisibilityConfig> mVisibleToConfigs;
+    final @NonNull List<SchemaVisibilityConfig> mVisibleToConfigs;
 
     @Constructor
     InternalVisibilityConfig(
@@ -171,8 +167,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
      * <p>This is being used as the document id when we convert a {@link InternalVisibilityConfig}
      * to a {@link GenericDocument}.
      */
-    @NonNull
-    public String getSchemaType() {
+    public @NonNull String getSchemaType() {
         return mSchemaType;
     }
 
@@ -184,8 +179,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
     /**
      * Returns the visibility settings stored in the public {@link SchemaVisibilityConfig} object.
      */
-    @NonNull
-    public SchemaVisibilityConfig getVisibilityConfig() {
+    public @NonNull SchemaVisibilityConfig getVisibilityConfig() {
         return mVisibilityConfig;
     }
 
@@ -193,8 +187,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
      * Returns required {@link SchemaVisibilityConfig} sets for a caller need to match to access the
      * schema this {@link InternalVisibilityConfig} represents.
      */
-    @NonNull
-    public Set<SchemaVisibilityConfig> getVisibleToConfigs() {
+    public @NonNull Set<SchemaVisibilityConfig> getVisibleToConfigs() {
         return new ArraySet<>(mVisibleToConfigs);
     }
 
@@ -262,9 +255,8 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
         }
 
         /** Sets schemaType, which will be as the id when converting to {@link GenericDocument}. */
-        @NonNull
         @CanIgnoreReturnValue
-        public Builder setSchemaType(@NonNull String schemaType) {
+        public @NonNull Builder setSchemaType(@NonNull String schemaType) {
             resetIfBuilt();
             mSchemaType = Objects.requireNonNull(schemaType);
             return this;
@@ -274,9 +266,9 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
          * Resets all values contained in the VisibilityConfig with the values from the given
          * VisibiltiyConfig.
          */
-        @NonNull
         @CanIgnoreReturnValue
-        public Builder setVisibilityConfig(@NonNull SchemaVisibilityConfig schemaVisibilityConfig) {
+        public @NonNull Builder setVisibilityConfig(
+                @NonNull SchemaVisibilityConfig schemaVisibilityConfig) {
             resetIfBuilt();
             mVisibilityConfigBuilder = new SchemaVisibilityConfig.Builder(schemaVisibilityConfig);
             return this;
@@ -284,8 +276,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
 
         /** Sets whether this schema has opted out of platform surfacing. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNotDisplayedBySystem(boolean notDisplayedBySystem) {
+        public @NonNull Builder setNotDisplayedBySystem(boolean notDisplayedBySystem) {
             resetIfBuilt();
             mIsNotDisplayedBySystem = notDisplayedBySystem;
             return this;
@@ -297,8 +288,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
          * @see SchemaVisibilityConfig.Builder#addAllowedPackage
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addVisibleToPackage(@NonNull PackageIdentifier packageIdentifier) {
+        public @NonNull Builder addVisibleToPackage(@NonNull PackageIdentifier packageIdentifier) {
             resetIfBuilt();
             mVisibilityConfigBuilder.addAllowedPackage(packageIdentifier);
             return this;
@@ -310,8 +300,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
          * @see SchemaVisibilityConfig.Builder#clearAllowedPackages
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearVisibleToPackages() {
+        public @NonNull Builder clearVisibleToPackages() {
             resetIfBuilt();
             mVisibilityConfigBuilder.clearAllowedPackages();
             return this;
@@ -324,8 +313,8 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
          * @see SchemaVisibilityConfig.Builder#addRequiredPermissions
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addVisibleToPermissions(@NonNull Set<Integer> visibleToPermissions) {
+        public @NonNull Builder addVisibleToPermissions(
+                @NonNull Set<Integer> visibleToPermissions) {
             resetIfBuilt();
             mVisibilityConfigBuilder.addRequiredPermissions(visibleToPermissions);
             return this;
@@ -337,8 +326,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
          * @see SchemaVisibilityConfig.Builder#clearRequiredPermissions
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearVisibleToPermissions() {
+        public @NonNull Builder clearVisibleToPermissions() {
             resetIfBuilt();
             mVisibilityConfigBuilder.clearRequiredPermissions();
             return this;
@@ -352,8 +340,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
          * @see SchemaVisibilityConfig.Builder#setPubliclyVisibleTargetPackage
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setPubliclyVisibleTargetPackage(
+        public @NonNull Builder setPubliclyVisibleTargetPackage(
                 @Nullable PackageIdentifier packageIdentifier) {
             resetIfBuilt();
             mVisibilityConfigBuilder.setPubliclyVisibleTargetPackage(packageIdentifier);
@@ -371,8 +358,8 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
          *     that a call must match to access the schema.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addVisibleToConfig(@NonNull SchemaVisibilityConfig schemaVisibilityConfig) {
+        public @NonNull Builder addVisibleToConfig(
+                @NonNull SchemaVisibilityConfig schemaVisibilityConfig) {
             Objects.requireNonNull(schemaVisibilityConfig);
             resetIfBuilt();
             mVisibleToConfigs.add(schemaVisibilityConfig);
@@ -381,8 +368,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
 
         /** Clears the set of {@link SchemaVisibilityConfig} which have access to this schema. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearVisibleToConfig() {
+        public @NonNull Builder clearVisibleToConfig() {
             resetIfBuilt();
             mVisibleToConfigs.clear();
             return this;
@@ -396,8 +382,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
         }
 
         /** Build a {@link InternalVisibilityConfig} */
-        @NonNull
-        public InternalVisibilityConfig build() {
+        public @NonNull InternalVisibilityConfig build() {
             mBuilt = true;
             return new InternalVisibilityConfig(
                     mSchemaType,
diff --git a/framework/java/external/android/app/appsearch/JoinSpec.java b/framework/java/external/android/app/appsearch/JoinSpec.java
index 0e9bdbe4..3490394d 100644
--- a/framework/java/external/android/app/appsearch/JoinSpec.java
+++ b/framework/java/external/android/app/appsearch/JoinSpec.java
@@ -112,12 +112,12 @@ import java.util.Objects;
  * nested {@link SearchSpec}, as in {@link SearchResult#getRankingSignal}.
  */
 @SafeParcelable.Class(creator = "JoinSpecCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class JoinSpec extends AbstractSafeParcelable {
     /** Creator class for {@link JoinSpec}. */
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<JoinSpec> CREATOR = new JoinSpecCreator();
+    public static final @NonNull Parcelable.Creator<JoinSpec> CREATOR = new JoinSpecCreator();
 
     @Field(id = 1, getter = "getNestedQuery")
     private final String mNestedQuery;
@@ -202,8 +202,7 @@ public final class JoinSpec extends AbstractSafeParcelable {
     }
 
     /** Returns the query to run on the joined documents. */
-    @NonNull
-    public String getNestedQuery() {
+    public @NonNull String getNestedQuery() {
         return mNestedQuery;
     }
 
@@ -215,8 +214,7 @@ public final class JoinSpec extends AbstractSafeParcelable {
      * @return the property expression to match in the child documents.
      * @see Builder
      */
-    @NonNull
-    public String getChildPropertyExpression() {
+    public @NonNull String getChildPropertyExpression() {
         return mChildPropertyExpression;
     }
 
@@ -235,8 +233,7 @@ public final class JoinSpec extends AbstractSafeParcelable {
      * with all default values. This will match every document, as the nested search query will be
      * "" and no schema will be filtered out.
      */
-    @NonNull
-    public SearchSpec getNestedSearchSpec() {
+    public @NonNull SearchSpec getNestedSearchSpec() {
         return mNestedSearchSpec;
     }
 
@@ -331,8 +328,8 @@ public final class JoinSpec extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setChildPropertyExpression(@NonNull String childPropertyExpression) {
+        public @NonNull Builder setChildPropertyExpression(
+                @NonNull String childPropertyExpression) {
             Objects.requireNonNull(childPropertyExpression);
             mChildPropertyExpression = childPropertyExpression;
             return this;
@@ -359,8 +356,7 @@ public final class JoinSpec extends AbstractSafeParcelable {
         @SuppressWarnings("MissingGetterMatchingBuilder")
         // See getNestedQuery & getNestedSearchSpec
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNestedSearch(
+        public @NonNull Builder setNestedSearch(
                 @NonNull String nestedQuery, @NonNull SearchSpec nestedSearchSpec) {
             Objects.requireNonNull(nestedQuery);
             Objects.requireNonNull(nestedSearchSpec);
@@ -379,8 +375,7 @@ public final class JoinSpec extends AbstractSafeParcelable {
          * a parent will factor into the score.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setMaxJoinedResultCount(int maxJoinedResultCount) {
+        public @NonNull Builder setMaxJoinedResultCount(int maxJoinedResultCount) {
             mMaxJoinedResultCount = maxJoinedResultCount;
             return this;
         }
@@ -395,8 +390,7 @@ public final class JoinSpec extends AbstractSafeParcelable {
          * @see SearchSpec#RANKING_STRATEGY_JOIN_AGGREGATE_SCORE
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setAggregationScoringStrategy(
+        public @NonNull Builder setAggregationScoringStrategy(
                 @AggregationScoringStrategy int aggregationScoringStrategy) {
             Preconditions.checkArgumentInRange(
                     aggregationScoringStrategy,
@@ -408,8 +402,7 @@ public final class JoinSpec extends AbstractSafeParcelable {
         }
 
         /** Constructs a new {@link JoinSpec} from the contents of this builder. */
-        @NonNull
-        public JoinSpec build() {
+        public @NonNull JoinSpec build() {
             return new JoinSpec(
                     mNestedQuery,
                     mNestedSearchSpec,
diff --git a/framework/java/external/android/app/appsearch/Migrator.java b/framework/java/external/android/app/appsearch/Migrator.java
index c5a0f63c..a661f80a 100644
--- a/framework/java/external/android/app/appsearch/Migrator.java
+++ b/framework/java/external/android/app/appsearch/Migrator.java
@@ -16,9 +16,10 @@
 
 package android.app.appsearch;
 
-import android.annotation.NonNull;
 import android.annotation.WorkerThread;
 
+import org.jspecify.annotations.NonNull;
+
 /**
  * A migrator class to translate {@link GenericDocument} from different version of {@link
  * AppSearchSchema}
@@ -63,8 +64,7 @@ public abstract class Migrator {
      * @return A {@link GenericDocument} in new version.
      */
     @WorkerThread
-    @NonNull
-    public abstract GenericDocument onUpgrade(
+    public abstract @NonNull GenericDocument onUpgrade(
             int currentVersion, int finalVersion, @NonNull GenericDocument document);
 
     /**
@@ -85,7 +85,6 @@ public abstract class Migrator {
      * @return A {@link GenericDocument} in new version.
      */
     @WorkerThread
-    @NonNull
-    public abstract GenericDocument onDowngrade(
+    public abstract @NonNull GenericDocument onDowngrade(
             int currentVersion, int finalVersion, @NonNull GenericDocument document);
 }
diff --git a/framework/java/external/android/app/appsearch/OpenBlobForReadResponse.java b/framework/java/external/android/app/appsearch/OpenBlobForReadResponse.java
index b5539649..f590d991 100644
--- a/framework/java/external/android/app/appsearch/OpenBlobForReadResponse.java
+++ b/framework/java/external/android/app/appsearch/OpenBlobForReadResponse.java
@@ -42,12 +42,12 @@ import java.util.Objects;
  * descriptor in the system.
  */
 @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 @SafeParcelable.Class(creator = "OpenBlobForReadResponseCreator")
 public final class OpenBlobForReadResponse extends AbstractSafeParcelable implements Closeable {
 
-    @NonNull
-    public static final Parcelable.Creator<OpenBlobForReadResponse> CREATOR =
+    public static final @NonNull Parcelable.Creator<OpenBlobForReadResponse> CREATOR =
             new OpenBlobForReadResponseCreator();
 
     @Field(id = 1)
@@ -77,8 +77,7 @@ public final class OpenBlobForReadResponse extends AbstractSafeParcelable implem
      *     if there was an error, the result contains an {@link AppSearchResult} with details of the
      *     failure.
      */
-    @NonNull
-    public AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> getResult() {
+    public @NonNull AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> getResult() {
         return mResultParcel.getResult();
     }
 
diff --git a/framework/java/external/android/app/appsearch/OpenBlobForWriteResponse.java b/framework/java/external/android/app/appsearch/OpenBlobForWriteResponse.java
index b5cb20c8..54f0a0f9 100644
--- a/framework/java/external/android/app/appsearch/OpenBlobForWriteResponse.java
+++ b/framework/java/external/android/app/appsearch/OpenBlobForWriteResponse.java
@@ -42,12 +42,12 @@ import java.util.Objects;
  * descriptor in the system.
  */
 @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 @SafeParcelable.Class(creator = "OpenBlobForWriteResponseCreator")
 public final class OpenBlobForWriteResponse extends AbstractSafeParcelable implements Closeable {
 
-    @NonNull
-    public static final Parcelable.Creator<OpenBlobForWriteResponse> CREATOR =
+    public static final @NonNull Parcelable.Creator<OpenBlobForWriteResponse> CREATOR =
             new OpenBlobForWriteResponseCreator();
 
     @Field(id = 1)
@@ -77,8 +77,7 @@ public final class OpenBlobForWriteResponse extends AbstractSafeParcelable imple
      *     if there was an error, the result contains an {@link AppSearchResult} with details of the
      *     failure.
      */
-    @NonNull
-    public AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> getResult() {
+    public @NonNull AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> getResult() {
         return mResultParcel.getResult();
     }
 
diff --git a/framework/java/external/android/app/appsearch/PackageIdentifier.java b/framework/java/external/android/app/appsearch/PackageIdentifier.java
index 4882b2d4..e55b262d 100644
--- a/framework/java/external/android/app/appsearch/PackageIdentifier.java
+++ b/framework/java/external/android/app/appsearch/PackageIdentifier.java
@@ -23,8 +23,10 @@ import android.app.appsearch.safeparcel.PackageIdentifierParcel;
 import java.util.Objects;
 
 /** This class represents a uniquely identifiable package. */
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings("JSpecifyNullness")
 public class PackageIdentifier {
-    @NonNull private final PackageIdentifierParcel mPackageIdentifierParcel;
+    private final @NonNull PackageIdentifierParcel mPackageIdentifierParcel;
 
     /**
      * Creates a unique identifier for a package.
@@ -59,20 +61,17 @@ public class PackageIdentifier {
      *
      * @hide
      */
-    @NonNull
-    public PackageIdentifierParcel getPackageIdentifierParcel() {
+    public @NonNull PackageIdentifierParcel getPackageIdentifierParcel() {
         return mPackageIdentifierParcel;
     }
 
     /** Returns the name for a package. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageIdentifierParcel.getPackageName();
     }
 
     /** Returns the SHA-256 certificate for a package. */
-    @NonNull
-    public byte[] getSha256Certificate() {
+    public @NonNull byte[] getSha256Certificate() {
         return mPackageIdentifierParcel.getSha256Certificate();
     }
 
diff --git a/framework/java/external/android/app/appsearch/PropertyPath.java b/framework/java/external/android/app/appsearch/PropertyPath.java
index 6c19fff2..3dfcf1df 100644
--- a/framework/java/external/android/app/appsearch/PropertyPath.java
+++ b/framework/java/external/android/app/appsearch/PropertyPath.java
@@ -16,12 +16,13 @@
 
 package android.app.appsearch;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.app.appsearch.checker.initialization.qual.UnderInitialization;
 import android.app.appsearch.checker.nullness.qual.RequiresNonNull;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -131,9 +132,8 @@ public class PropertyPath implements Iterable<PropertyPath.PathSegment> {
      * @param controlPos the position of the start bracket
      * @return the rest of the path after the end brackets, or null if there is nothing after them
      */
-    @Nullable
     @RequiresNonNull("mPathList")
-    private String consumePropertyWithIndex(
+    private @Nullable String consumePropertyWithIndex(
             @UnderInitialization PropertyPath this, @NonNull String path, int controlPos) {
         Objects.requireNonNull(path);
         String propertyName = path.substring(0, controlPos);
@@ -178,8 +178,7 @@ public class PropertyPath implements Iterable<PropertyPath.PathSegment> {
     // Allow use of the Kotlin indexing operator
     @SuppressWarnings("KotlinOperator")
     @SuppressLint("KotlinOperator")
-    @NonNull
-    public PathSegment get(int index) {
+    public @NonNull PathSegment get(int index) {
         return mPathList.get(index);
     }
 
@@ -195,8 +194,7 @@ public class PropertyPath implements Iterable<PropertyPath.PathSegment> {
 
     /** Returns a valid path string representing this PropertyPath */
     @Override
-    @NonNull
-    public String toString() {
+    public @NonNull String toString() {
         StringBuilder result = new StringBuilder();
         for (int i = 0; i < mPathList.size(); i++) {
             result.append(get(i).toString());
@@ -209,9 +207,8 @@ public class PropertyPath implements Iterable<PropertyPath.PathSegment> {
     }
 
     /** Returns an iterator over the PathSegments within the PropertyPath */
-    @NonNull
     @Override
-    public Iterator<PathSegment> iterator() {
+    public @NonNull Iterator<PathSegment> iterator() {
         return mPathList.iterator();
     }
 
@@ -250,7 +247,7 @@ public class PropertyPath implements Iterable<PropertyPath.PathSegment> {
          */
         public static final int NON_REPEATED_CARDINALITY = -1;
 
-        @NonNull private final String mPropertyName;
+        private final @NonNull String mPropertyName;
         private final int mPropertyIndex;
 
         /**
@@ -267,8 +264,7 @@ public class PropertyPath implements Iterable<PropertyPath.PathSegment> {
          * @return A new PathSegment
          * @throws IllegalArgumentException if the property name or index is invalid.
          */
-        @NonNull
-        public static PathSegment create(@NonNull String propertyName, int propertyIndex) {
+        public static @NonNull PathSegment create(@NonNull String propertyName, int propertyIndex) {
             Objects.requireNonNull(propertyName);
             // A path may contain control characters, but a PathSegment may not
             if (propertyName.isEmpty()
@@ -292,8 +288,7 @@ public class PropertyPath implements Iterable<PropertyPath.PathSegment> {
          * @param propertyName the name of the property
          * @return A new PathSegment
          */
-        @NonNull
-        public static PathSegment create(@NonNull String propertyName) {
+        public static @NonNull PathSegment create(@NonNull String propertyName) {
             return create(Objects.requireNonNull(propertyName), NON_REPEATED_CARDINALITY);
         }
 
@@ -310,8 +305,7 @@ public class PropertyPath implements Iterable<PropertyPath.PathSegment> {
         }
 
         /** Returns the name of the property. */
-        @NonNull
-        public String getPropertyName() {
+        public @NonNull String getPropertyName() {
             return mPropertyName;
         }
 
@@ -325,8 +319,7 @@ public class PropertyPath implements Iterable<PropertyPath.PathSegment> {
 
         /** Returns a path representing a PathSegment, either "foo" or "foo[1]" */
         @Override
-        @NonNull
-        public String toString() {
+        public @NonNull String toString() {
             if (mPropertyIndex != NON_REPEATED_CARDINALITY) {
                 return mPropertyName + "[" + mPropertyIndex + "]";
             }
diff --git a/framework/java/external/android/app/appsearch/PutDocumentsRequest.java b/framework/java/external/android/app/appsearch/PutDocumentsRequest.java
index c355dbe4..1b0a6e7b 100644
--- a/framework/java/external/android/app/appsearch/PutDocumentsRequest.java
+++ b/framework/java/external/android/app/appsearch/PutDocumentsRequest.java
@@ -38,6 +38,8 @@ import java.util.Set;
  *
  * @see AppSearchSession#put
  */
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings("JSpecifyNullness")
 public final class PutDocumentsRequest {
     private final List<GenericDocument> mDocuments;
 
@@ -49,8 +51,7 @@ public final class PutDocumentsRequest {
     }
 
     /** Returns a list of {@link GenericDocument} objects that are part of this request. */
-    @NonNull
-    public List<GenericDocument> getGenericDocuments() {
+    public @NonNull List<GenericDocument> getGenericDocuments() {
         return Collections.unmodifiableList(mDocuments);
     }
 
@@ -60,9 +61,8 @@ public final class PutDocumentsRequest {
      *
      * <p>See {@link Builder#addTakenActionGenericDocuments(GenericDocument...)}.
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_PUT_DOCUMENTS_REQUEST_ADD_TAKEN_ACTIONS)
-    public List<GenericDocument> getTakenActionGenericDocuments() {
+    public @NonNull List<GenericDocument> getTakenActionGenericDocuments() {
         return Collections.unmodifiableList(mTakenActions);
     }
 
@@ -74,8 +74,7 @@ public final class PutDocumentsRequest {
 
         /** Adds one or more {@link GenericDocument} objects to the request. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addGenericDocuments(@NonNull GenericDocument... documents) {
+        public @NonNull Builder addGenericDocuments(@NonNull GenericDocument... documents) {
             Objects.requireNonNull(documents);
             resetIfBuilt();
             return addGenericDocuments(Arrays.asList(documents));
@@ -83,8 +82,7 @@ public final class PutDocumentsRequest {
 
         /** Adds a collection of {@link GenericDocument} objects to the request. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addGenericDocuments(
+        public @NonNull Builder addGenericDocuments(
                 @NonNull Collection<? extends GenericDocument> documents) {
             Objects.requireNonNull(documents);
             resetIfBuilt();
@@ -170,9 +168,8 @@ public final class PutDocumentsRequest {
          *     taken action metric fields.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_PUT_DOCUMENTS_REQUEST_ADD_TAKEN_ACTIONS)
-        public Builder addTakenActionGenericDocuments(
+        public @NonNull Builder addTakenActionGenericDocuments(
                 @NonNull GenericDocument... takenActionGenericDocuments) throws AppSearchException {
             Objects.requireNonNull(takenActionGenericDocuments);
             resetIfBuilt();
@@ -188,9 +185,8 @@ public final class PutDocumentsRequest {
          *     containing taken action metric fields.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_PUT_DOCUMENTS_REQUEST_ADD_TAKEN_ACTIONS)
-        public Builder addTakenActionGenericDocuments(
+        public @NonNull Builder addTakenActionGenericDocuments(
                 @NonNull Collection<? extends GenericDocument> takenActionGenericDocuments)
                 throws AppSearchException {
             Objects.requireNonNull(takenActionGenericDocuments);
@@ -205,8 +201,7 @@ public final class PutDocumentsRequest {
          * @throws IllegalArgumentException if there is any id collision between normal and action
          *     documents.
          */
-        @NonNull
-        public PutDocumentsRequest build() {
+        public @NonNull PutDocumentsRequest build() {
             mBuilt = true;
 
             // Verify there is no id collision between normal documents and action documents.
diff --git a/framework/java/external/android/app/appsearch/RemoveBlobResponse.java b/framework/java/external/android/app/appsearch/RemoveBlobResponse.java
index d63c77de..c012c50b 100644
--- a/framework/java/external/android/app/appsearch/RemoveBlobResponse.java
+++ b/framework/java/external/android/app/appsearch/RemoveBlobResponse.java
@@ -35,12 +35,12 @@ import java.util.Objects;
  * handles.
  */
 @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 @SafeParcelable.Class(creator = "RemoveBlobResponseCreator")
 public final class RemoveBlobResponse extends AbstractSafeParcelable {
 
-    @NonNull
-    public static final Parcelable.Creator<RemoveBlobResponse> CREATOR =
+    public static final @NonNull Parcelable.Creator<RemoveBlobResponse> CREATOR =
             new RemoveBlobResponseCreator();
 
     @Field(id = 1, getter = "getResponseParcel")
@@ -67,8 +67,7 @@ public final class RemoveBlobResponse extends AbstractSafeParcelable {
      *     operation was successful, the result for that handle is {@code null}; if there was an
      *     error, the result contains an {@link AppSearchResult} with details of the failure.
      */
-    @NonNull
-    public AppSearchBatchResult<AppSearchBlobHandle, Void> getResult() {
+    public @NonNull AppSearchBatchResult<AppSearchBlobHandle, Void> getResult() {
         return mResultParcel.getResult();
     }
 
@@ -77,8 +76,7 @@ public final class RemoveBlobResponse extends AbstractSafeParcelable {
      *
      * @hide
      */
-    @NonNull
-    public AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> getResponseParcel() {
+    public @NonNull AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> getResponseParcel() {
         return mResultParcel;
     }
 
diff --git a/framework/java/external/android/app/appsearch/RemoveByDocumentIdRequest.java b/framework/java/external/android/app/appsearch/RemoveByDocumentIdRequest.java
index cc09adef..ad55c9cd 100644
--- a/framework/java/external/android/app/appsearch/RemoveByDocumentIdRequest.java
+++ b/framework/java/external/android/app/appsearch/RemoveByDocumentIdRequest.java
@@ -43,23 +43,21 @@ import java.util.Set;
  * @see AppSearchSession#remove
  */
 @SafeParcelable.Class(creator = "RemoveByDocumentIdRequestCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class RemoveByDocumentIdRequest extends AbstractSafeParcelable {
     /** Creator class for {@link android.app.appsearch.RemoveByDocumentIdRequest}. */
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<RemoveByDocumentIdRequest> CREATOR =
+    public static final @NonNull Parcelable.Creator<RemoveByDocumentIdRequest> CREATOR =
             new RemoveByDocumentIdRequestCreator();
 
-    @NonNull
     @Field(id = 1, getter = "getNamespace")
-    private final String mNamespace;
+    private final @NonNull String mNamespace;
 
-    @NonNull
     @Field(id = 2)
-    final List<String> mIds;
+    final @NonNull List<String> mIds;
 
-    @Nullable private Set<String> mIdsCached;
+    private @Nullable Set<String> mIdsCached;
 
     /**
      * Removes documents by ID.
@@ -75,14 +73,12 @@ public final class RemoveByDocumentIdRequest extends AbstractSafeParcelable {
     }
 
     /** Returns the namespace to remove documents from. */
-    @NonNull
-    public String getNamespace() {
+    public @NonNull String getNamespace() {
         return mNamespace;
     }
 
     /** Returns the set of document IDs attached to the request. */
-    @NonNull
-    public Set<String> getIds() {
+    public @NonNull Set<String> getIds() {
         if (mIdsCached == null) {
             mIdsCached = Collections.unmodifiableSet(new ArraySet<>(mIds));
         }
@@ -108,8 +104,7 @@ public final class RemoveByDocumentIdRequest extends AbstractSafeParcelable {
 
         /** Adds one or more document IDs to the request. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addIds(@NonNull String... ids) {
+        public @NonNull Builder addIds(@NonNull String... ids) {
             Objects.requireNonNull(ids);
             resetIfBuilt();
             return addIds(Arrays.asList(ids));
@@ -117,8 +112,7 @@ public final class RemoveByDocumentIdRequest extends AbstractSafeParcelable {
 
         /** Adds a collection of IDs to the request. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addIds(@NonNull Collection<String> ids) {
+        public @NonNull Builder addIds(@NonNull Collection<String> ids) {
             Objects.requireNonNull(ids);
             resetIfBuilt();
             mIds.addAll(ids);
@@ -126,8 +120,7 @@ public final class RemoveByDocumentIdRequest extends AbstractSafeParcelable {
         }
 
         /** Builds a new {@link RemoveByDocumentIdRequest}. */
-        @NonNull
-        public RemoveByDocumentIdRequest build() {
+        public @NonNull RemoveByDocumentIdRequest build() {
             mBuilt = true;
             return new RemoveByDocumentIdRequest(mNamespace, new ArrayList<>(mIds));
         }
diff --git a/framework/java/external/android/app/appsearch/ReportSystemUsageRequest.java b/framework/java/external/android/app/appsearch/ReportSystemUsageRequest.java
index 00d965ee..14c23edd 100644
--- a/framework/java/external/android/app/appsearch/ReportSystemUsageRequest.java
+++ b/framework/java/external/android/app/appsearch/ReportSystemUsageRequest.java
@@ -31,6 +31,8 @@ import java.util.Objects;
  * <p>See {@link GlobalSearchSession#reportSystemUsage} for a detailed description of usage
  * reporting.
  */
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings("JSpecifyNullness")
 public final class ReportSystemUsageRequest {
     private final String mPackageName;
     private final String mDatabase;
@@ -52,26 +54,22 @@ public final class ReportSystemUsageRequest {
     }
 
     /** Returns the package name of the app which owns the document that was used. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
     /** Returns the database in which the document that was used resides. */
-    @NonNull
-    public String getDatabaseName() {
+    public @NonNull String getDatabaseName() {
         return mDatabase;
     }
 
     /** Returns the namespace of the document that was used. */
-    @NonNull
-    public String getNamespace() {
+    public @NonNull String getNamespace() {
         return mNamespace;
     }
 
     /** Returns the ID of document that was used. */
-    @NonNull
-    public String getDocumentId() {
+    public @NonNull String getDocumentId() {
         return mDocumentId;
     }
 
@@ -127,16 +125,14 @@ public final class ReportSystemUsageRequest {
          * ReportSystemUsageRequest} is constructed.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public ReportSystemUsageRequest.Builder setUsageTimestampMillis(
+        public @NonNull ReportSystemUsageRequest.Builder setUsageTimestampMillis(
                 @CurrentTimeMillisLong long usageTimestampMillis) {
             mUsageTimestampMillis = usageTimestampMillis;
             return this;
         }
 
         /** Builds a new {@link ReportSystemUsageRequest}. */
-        @NonNull
-        public ReportSystemUsageRequest build() {
+        public @NonNull ReportSystemUsageRequest build() {
             if (mUsageTimestampMillis == null) {
                 mUsageTimestampMillis = System.currentTimeMillis();
             }
diff --git a/framework/java/external/android/app/appsearch/ReportUsageRequest.java b/framework/java/external/android/app/appsearch/ReportUsageRequest.java
index 753b6cd6..296acf29 100644
--- a/framework/java/external/android/app/appsearch/ReportUsageRequest.java
+++ b/framework/java/external/android/app/appsearch/ReportUsageRequest.java
@@ -36,22 +36,20 @@ import java.util.Objects;
  *
  * @see AppSearchSession#reportUsage
  */
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 @SafeParcelable.Class(creator = "ReportUsageRequestCreator")
 public final class ReportUsageRequest extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<ReportUsageRequest> CREATOR =
+    public static final @NonNull Parcelable.Creator<ReportUsageRequest> CREATOR =
             new ReportUsageRequestCreator();
 
-    @NonNull
     @Field(id = 1, getter = "getNamespace")
-    private final String mNamespace;
+    private final @NonNull String mNamespace;
 
-    @NonNull
     @Field(id = 2, getter = "getDocumentId")
-    private final String mDocumentId;
+    private final @NonNull String mDocumentId;
 
     @Field(id = 3, getter = "getUsageTimestampMillis")
     private final long mUsageTimestampMillis;
@@ -67,14 +65,12 @@ public final class ReportUsageRequest extends AbstractSafeParcelable {
     }
 
     /** Returns the namespace of the document that was used. */
-    @NonNull
-    public String getNamespace() {
+    public @NonNull String getNamespace() {
         return mNamespace;
     }
 
     /** Returns the ID of document that was used. */
-    @NonNull
-    public String getDocumentId() {
+    public @NonNull String getDocumentId() {
         return mDocumentId;
     }
 
@@ -124,16 +120,14 @@ public final class ReportUsageRequest extends AbstractSafeParcelable {
          * ReportUsageRequest} is constructed.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public ReportUsageRequest.Builder setUsageTimestampMillis(
+        public @NonNull ReportUsageRequest.Builder setUsageTimestampMillis(
                 @CurrentTimeMillisLong long usageTimestampMillis) {
             mUsageTimestampMillis = usageTimestampMillis;
             return this;
         }
 
         /** Builds a new {@link ReportUsageRequest}. */
-        @NonNull
-        public ReportUsageRequest build() {
+        public @NonNull ReportUsageRequest build() {
             if (mUsageTimestampMillis == null) {
                 mUsageTimestampMillis = System.currentTimeMillis();
             }
diff --git a/framework/java/external/android/app/appsearch/SchemaVisibilityConfig.java b/framework/java/external/android/app/appsearch/SchemaVisibilityConfig.java
index 1cadc1ed..8d3e1a36 100644
--- a/framework/java/external/android/app/appsearch/SchemaVisibilityConfig.java
+++ b/framework/java/external/android/app/appsearch/SchemaVisibilityConfig.java
@@ -43,27 +43,25 @@ import java.util.Set;
  */
 @FlaggedApi(Flags.FLAG_ENABLE_SET_SCHEMA_VISIBLE_TO_CONFIGS)
 @SafeParcelable.Class(creator = "VisibilityConfigCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
-    @NonNull
-    public static final Parcelable.Creator<SchemaVisibilityConfig> CREATOR =
+
+    public static final @NonNull Parcelable.Creator<SchemaVisibilityConfig> CREATOR =
             new VisibilityConfigCreator();
 
-    @NonNull
     @Field(id = 1)
-    final List<PackageIdentifierParcel> mAllowedPackages;
+    final @NonNull List<PackageIdentifierParcel> mAllowedPackages;
 
-    @NonNull
     @Field(id = 2)
-    final List<VisibilityPermissionConfig> mRequiredPermissions;
+    final @NonNull List<VisibilityPermissionConfig> mRequiredPermissions;
 
-    @Nullable
     @Field(id = 3)
-    final PackageIdentifierParcel mPubliclyVisibleTargetPackage;
+    final @Nullable PackageIdentifierParcel mPubliclyVisibleTargetPackage;
 
-    @Nullable private Integer mHashCode;
-    @Nullable private List<PackageIdentifier> mAllowedPackagesCached;
-    @Nullable private Set<Set<Integer>> mRequiredPermissionsCached;
+    private @Nullable Integer mHashCode;
+    private @Nullable List<PackageIdentifier> mAllowedPackagesCached;
+    private @Nullable Set<Set<Integer>> mRequiredPermissionsCached;
 
     @Constructor
     SchemaVisibilityConfig(
@@ -76,8 +74,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
     }
 
     /** Returns a list of {@link PackageIdentifier}s of packages that can access this schema. */
-    @NonNull
-    public List<PackageIdentifier> getAllowedPackages() {
+    public @NonNull List<PackageIdentifier> getAllowedPackages() {
         if (mAllowedPackagesCached == null) {
             mAllowedPackagesCached = new ArrayList<>(mAllowedPackages.size());
             for (int i = 0; i < mAllowedPackages.size(); i++) {
@@ -93,8 +90,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
      *
      * @see SetSchemaRequest.Builder#addRequiredPermissionsForSchemaTypeVisibility(String, Set)
      */
-    @NonNull
-    public Set<Set<Integer>> getRequiredPermissions() {
+    public @NonNull Set<Set<Integer>> getRequiredPermissions() {
         if (mRequiredPermissionsCached == null) {
             mRequiredPermissionsCached = new ArraySet<>(mRequiredPermissions.size());
             for (int i = 0; i < mRequiredPermissions.size(); i++) {
@@ -115,8 +111,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
      * packages can access this publicly visible schema. Returns null if the schema is not publicly
      * visible.
      */
-    @Nullable
-    public PackageIdentifier getPubliclyVisibleTargetPackage() {
+    public @Nullable PackageIdentifier getPubliclyVisibleTargetPackage() {
         if (mPubliclyVisibleTargetPackage == null) {
             return null;
         }
@@ -161,7 +156,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
     public static final class Builder {
         private List<PackageIdentifierParcel> mAllowedPackages = new ArrayList<>();
         private List<VisibilityPermissionConfig> mRequiredPermissions = new ArrayList<>();
-        @Nullable private PackageIdentifierParcel mPubliclyVisibleTargetPackage;
+        private @Nullable PackageIdentifierParcel mPubliclyVisibleTargetPackage;
         private boolean mBuilt;
 
         /** Creates a {@link Builder} for a {@link SchemaVisibilityConfig}. */
@@ -182,8 +177,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
 
         /** Add {@link PackageIdentifier} of packages which has access to this schema. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addAllowedPackage(@NonNull PackageIdentifier packageIdentifier) {
+        public @NonNull Builder addAllowedPackage(@NonNull PackageIdentifier packageIdentifier) {
             Objects.requireNonNull(packageIdentifier);
             resetIfBuilt();
             mAllowedPackages.add(packageIdentifier.getPackageIdentifierParcel());
@@ -192,8 +186,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
 
         /** Clears the list of packages which have access to this schema. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearAllowedPackages() {
+        public @NonNull Builder clearAllowedPackages() {
             resetIfBuilt();
             mAllowedPackages.clear();
             return this;
@@ -216,8 +209,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
          */
         @SuppressWarnings("RequiresPermission") // No permission required to call this method
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addRequiredPermissions(@NonNull Set<Integer> visibleToPermissions) {
+        public @NonNull Builder addRequiredPermissions(@NonNull Set<Integer> visibleToPermissions) {
             Objects.requireNonNull(visibleToPermissions);
             resetIfBuilt();
             mRequiredPermissions.add(new VisibilityPermissionConfig(visibleToPermissions));
@@ -228,8 +220,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
          * Clears all required permissions combinations set to this {@link SchemaVisibilityConfig}.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearRequiredPermissions() {
+        public @NonNull Builder clearRequiredPermissions() {
             resetIfBuilt();
             mRequiredPermissions.clear();
             return this;
@@ -255,8 +246,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
          *     access this publicly visible schema.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setPubliclyVisibleTargetPackage(
+        public @NonNull Builder setPubliclyVisibleTargetPackage(
                 @Nullable PackageIdentifier packageIdentifier) {
             resetIfBuilt();
             if (packageIdentifier == null) {
@@ -276,8 +266,7 @@ public final class SchemaVisibilityConfig extends AbstractSafeParcelable {
         }
 
         /** Build a {@link SchemaVisibilityConfig} */
-        @NonNull
-        public SchemaVisibilityConfig build() {
+        public @NonNull SchemaVisibilityConfig build() {
             mBuilt = true;
             return new SchemaVisibilityConfig(
                     mAllowedPackages, mRequiredPermissions, mPubliclyVisibleTargetPackage);
diff --git a/framework/java/external/android/app/appsearch/SearchResult.java b/framework/java/external/android/app/appsearch/SearchResult.java
index 22cf2e1a..3d0d3b3d 100644
--- a/framework/java/external/android/app/appsearch/SearchResult.java
+++ b/framework/java/external/android/app/appsearch/SearchResult.java
@@ -16,6 +16,9 @@
 
 package android.app.appsearch;
 
+import static android.app.appsearch.SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_COSINE;
+import static android.app.appsearch.SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_EUCLIDEAN;
+
 import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -56,12 +59,13 @@ import java.util.Set;
  * @see SearchResults
  */
 @SafeParcelable.Class(creator = "SearchResultCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class SearchResult extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<SearchResult> CREATOR = new SearchResultCreator();
+    public static final @NonNull Parcelable.Creator<SearchResult> CREATOR =
+            new SearchResultCreator();
 
     @Field(id = 1)
     final GenericDocumentParcel mDocument;
@@ -81,9 +85,8 @@ public final class SearchResult extends AbstractSafeParcelable {
     @Field(id = 6, getter = "getJoinedResults")
     private final List<SearchResult> mJoinedResults;
 
-    @NonNull
     @Field(id = 7, getter = "getInformationalRankingSignals")
-    private final List<Double> mInformationalRankingSignals;
+    private final @NonNull List<Double> mInformationalRankingSignals;
 
     /**
      * Holds the map from schema type names to the list of their parent types.
@@ -95,15 +98,14 @@ public final class SearchResult extends AbstractSafeParcelable {
      *
      * <p>All schema names in this map are un-prefixed, for both keys and values.
      */
-    @NonNull
     @Field(id = 8)
-    final Bundle mParentTypeMap;
+    final @NonNull Bundle mParentTypeMap;
 
     /** Cache of the {@link GenericDocument}. Comes from mDocument at first use. */
-    @Nullable private GenericDocument mDocumentCached;
+    private @Nullable GenericDocument mDocumentCached;
 
     /** Cache of the inflated {@link MatchInfo}. Comes from inflating mMatchInfos at first use. */
-    @Nullable private List<MatchInfo> mMatchInfosCached;
+    private @Nullable List<MatchInfo> mMatchInfosCached;
 
     /** @hide */
     @Constructor
@@ -140,8 +142,7 @@ public final class SearchResult extends AbstractSafeParcelable {
      *
      * @return Document object which matched the query.
      */
-    @NonNull
-    public GenericDocument getGenericDocument() {
+    public @NonNull GenericDocument getGenericDocument() {
         if (mDocumentCached == null) {
             mDocumentCached = new GenericDocument(mDocument);
         }
@@ -157,13 +158,18 @@ public final class SearchResult extends AbstractSafeParcelable {
      *     SearchSpec.Builder#setSnippetCountPerProperty}, for all results after that value, this
      *     method returns an empty list.
      */
-    @NonNull
-    public List<MatchInfo> getMatchInfos() {
+    public @NonNull List<MatchInfo> getMatchInfos() {
         if (mMatchInfosCached == null) {
             mMatchInfosCached = new ArrayList<>(mMatchInfos.size());
             for (int i = 0; i < mMatchInfos.size(); i++) {
                 MatchInfo matchInfo = mMatchInfos.get(i);
                 matchInfo.setDocument(getGenericDocument());
+                if (matchInfo.getTextMatch() != null) {
+                    // This is necessary in order to use the TextMatchInfo after IPC, since
+                    // TextMatch.mPropertyPath is private and is not retained by SafeParcelable
+                    // across IPC.
+                    matchInfo.mTextMatch.setPropertyPath(matchInfo.getPropertyPath());
+                }
                 if (mMatchInfosCached != null) {
                     // This additional check is added for NullnessChecker.
                     mMatchInfosCached.add(matchInfo);
@@ -180,8 +186,7 @@ public final class SearchResult extends AbstractSafeParcelable {
      *
      * @return Package name that stored the document
      */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
@@ -190,8 +195,7 @@ public final class SearchResult extends AbstractSafeParcelable {
      *
      * @return Name of the database within which the document is stored
      */
-    @NonNull
-    public String getDatabaseName() {
+    public @NonNull String getDatabaseName() {
         return mDatabaseName;
     }
 
@@ -229,9 +233,8 @@ public final class SearchResult extends AbstractSafeParcelable {
      * Returns the informational ranking signals of the {@link GenericDocument}, according to the
      * expressions added in {@link SearchSpec.Builder#addInformationalRankingExpressions}.
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_INFORMATIONAL_RANKING_EXPRESSIONS)
-    public List<Double> getInformationalRankingSignals() {
+    public @NonNull List<Double> getInformationalRankingSignals() {
         return mInformationalRankingSignals;
     }
 
@@ -246,9 +249,8 @@ public final class SearchResult extends AbstractSafeParcelable {
      * <p>Calling this function repeatedly is inefficient. Prefer to retain the Map returned by this
      * function, rather than calling it multiple times.
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_RESULT_PARENT_TYPES)
-    public Map<String, List<String>> getParentTypeMap() {
+    public @NonNull Map<String, List<String>> getParentTypeMap() {
         Set<String> schemaTypes = mParentTypeMap.keySet();
         Map<String, List<String>> parentTypeMap = new ArrayMap<>(schemaTypes.size());
         for (String schemaType : schemaTypes) {
@@ -274,8 +276,7 @@ public final class SearchResult extends AbstractSafeParcelable {
      *
      * @return a List of SearchResults containing joined documents.
      */
-    @NonNull
-    public List<SearchResult> getJoinedResults() {
+    public @NonNull List<SearchResult> getJoinedResults() {
         return mJoinedResults;
     }
 
@@ -330,8 +331,7 @@ public final class SearchResult extends AbstractSafeParcelable {
 
         /** Sets the document which matched. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setGenericDocument(@NonNull GenericDocument document) {
+        public @NonNull Builder setGenericDocument(@NonNull GenericDocument document) {
             Objects.requireNonNull(document);
             resetIfBuilt();
             mGenericDocument = document;
@@ -340,8 +340,7 @@ public final class SearchResult extends AbstractSafeParcelable {
 
         /** Adds another match to this SearchResult. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addMatchInfo(@NonNull MatchInfo matchInfo) {
+        public @NonNull Builder addMatchInfo(@NonNull MatchInfo matchInfo) {
             Preconditions.checkState(
                     matchInfo.mDocument == null,
                     "This MatchInfo is already associated with a SearchResult and can't be "
@@ -353,8 +352,7 @@ public final class SearchResult extends AbstractSafeParcelable {
 
         /** Sets the ranking signal of the matched document in this SearchResult. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRankingSignal(double rankingSignal) {
+        public @NonNull Builder setRankingSignal(double rankingSignal) {
             resetIfBuilt();
             mRankingSignal = rankingSignal;
             return this;
@@ -363,8 +361,7 @@ public final class SearchResult extends AbstractSafeParcelable {
         /** Adds the informational ranking signal of the matched document in this SearchResult. */
         @CanIgnoreReturnValue
         @FlaggedApi(Flags.FLAG_ENABLE_INFORMATIONAL_RANKING_EXPRESSIONS)
-        @NonNull
-        public Builder addInformationalRankingSignal(double rankingSignal) {
+        public @NonNull Builder addInformationalRankingSignal(double rankingSignal) {
             resetIfBuilt();
             mInformationalRankingSignals.add(rankingSignal);
             return this;
@@ -385,8 +382,7 @@ public final class SearchResult extends AbstractSafeParcelable {
          */
         @CanIgnoreReturnValue
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_RESULT_PARENT_TYPES)
-        @NonNull
-        public Builder setParentTypeMap(@NonNull Map<String, List<String>> parentTypeMap) {
+        public @NonNull Builder setParentTypeMap(@NonNull Map<String, List<String>> parentTypeMap) {
             Objects.requireNonNull(parentTypeMap);
             resetIfBuilt();
             mParentTypeMap.clear();
@@ -411,29 +407,38 @@ public final class SearchResult extends AbstractSafeParcelable {
          * @param joinedResult The joined SearchResult to add.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addJoinedResult(@NonNull SearchResult joinedResult) {
+        public @NonNull Builder addJoinedResult(@NonNull SearchResult joinedResult) {
             resetIfBuilt();
             mJoinedResults.add(joinedResult);
             return this;
         }
 
+        /**
+         * Clears the {@link MatchInfo}s.
+         *
+         * @hide
+         */
+        @CanIgnoreReturnValue
+        public @NonNull Builder clearMatchInfos() {
+            resetIfBuilt();
+            mMatchInfos.clear();
+            return this;
+        }
+
         /**
          * Clears the {@link SearchResult}s that were joined.
          *
          * @hide
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearJoinedResults() {
+        public @NonNull Builder clearJoinedResults() {
             resetIfBuilt();
             mJoinedResults.clear();
             return this;
         }
 
         /** Constructs a new {@link SearchResult}. */
-        @NonNull
-        public SearchResult build() {
+        public @NonNull SearchResult build() {
             mBuilt = true;
             return new SearchResult(
                     mGenericDocument.getDocumentParcel(),
@@ -459,7 +464,343 @@ public final class SearchResult extends AbstractSafeParcelable {
 
     /**
      * This class represents match objects for any snippets that might be present in {@link
-     * SearchResults} from a query. Using this class, you can get:
+     * SearchResults} from a query.
+     *
+     * <p>A {@link MatchInfo} contains either a {@link TextMatchInfo} representing a text match
+     * snippet, or an {@link EmbeddingMatchInfo} representing an embedding match snippet.
+     */
+    @SafeParcelable.Class(creator = "MatchInfoCreator")
+    @SuppressWarnings("HiddenSuperclass")
+    public static final class MatchInfo extends AbstractSafeParcelable {
+
+        @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
+        public static final @NonNull Parcelable.Creator<MatchInfo> CREATOR = new MatchInfoCreator();
+
+        /** The path of the matching snippet property. */
+        @Field(id = 1, getter = "getPropertyPath")
+        private final String mPropertyPath;
+
+        @Field(id = 2)
+        final int mExactMatchRangeStart;
+
+        @Field(id = 3)
+        final int mExactMatchRangeEnd;
+
+        @Field(id = 4)
+        final int mSubmatchRangeStart;
+
+        @Field(id = 5)
+        final int mSubmatchRangeEnd;
+
+        @Field(id = 6)
+        final int mSnippetRangeStart;
+
+        @Field(id = 7)
+        final int mSnippetRangeEnd;
+
+        /** Represents text-based match information. */
+        @Field(id = 8, getter = "getTextMatch")
+        private @Nullable final TextMatchInfo mTextMatch;
+
+        /** Represents embedding-based match information. */
+        @Field(id = 9, getter = "getEmbeddingMatch")
+        private @Nullable final EmbeddingMatchInfo mEmbeddingMatch;
+
+        private @Nullable PropertyPath mPropertyPathObject = null;
+
+        /**
+         * Document which the match comes from.
+         *
+         * <p>If this is {@code null}, methods which require access to the document, like {@link
+         * #getExactMatch}, will throw {@link NullPointerException}.
+         */
+        private @Nullable GenericDocument mDocument = null;
+
+        @Constructor
+        MatchInfo(
+                @Param(id = 1) @NonNull String propertyPath,
+                @Param(id = 2) int exactMatchRangeStart,
+                @Param(id = 3) int exactMatchRangeEnd,
+                @Param(id = 4) int submatchRangeStart,
+                @Param(id = 5) int submatchRangeEnd,
+                @Param(id = 6) int snippetRangeStart,
+                @Param(id = 7) int snippetRangeEnd,
+                @Param(id = 8) @Nullable TextMatchInfo textMatchInfo,
+                @Param(id = 9) @Nullable EmbeddingMatchInfo embeddingMatchInfo) {
+            mPropertyPath = Objects.requireNonNull(propertyPath);
+            mExactMatchRangeStart = exactMatchRangeStart;
+            mExactMatchRangeEnd = exactMatchRangeEnd;
+            mSubmatchRangeStart = submatchRangeStart;
+            mSubmatchRangeEnd = submatchRangeEnd;
+            mSnippetRangeStart = snippetRangeStart;
+            mSnippetRangeEnd = snippetRangeEnd;
+            mEmbeddingMatch = embeddingMatchInfo;
+            TextMatchInfo tempTextMatch = textMatchInfo;
+            if (tempTextMatch == null && mEmbeddingMatch == null) {
+                tempTextMatch =
+                        new TextMatchInfo(
+                                exactMatchRangeStart, exactMatchRangeEnd,
+                                submatchRangeStart, submatchRangeEnd,
+                                snippetRangeStart, snippetRangeEnd);
+                tempTextMatch.setPropertyPath(mPropertyPath);
+            }
+
+            mTextMatch = tempTextMatch;
+        }
+
+        /**
+         * Gets the property path corresponding to the given entry.
+         *
+         * <p>A property path is a '.' - delimited sequence of property names indicating which
+         * property in the document these snippets correspond to.
+         *
+         * <p>Example properties: 'body', 'sender.name', 'sender.emailaddress', etc. For class
+         * example 1 this returns "subject"
+         */
+        public @NonNull String getPropertyPath() {
+            return mPropertyPath;
+        }
+
+        /**
+         * Gets a {@link PropertyPath} object representing the property path corresponding to the
+         * given entry.
+         *
+         * <p>Methods such as {@link GenericDocument#getPropertyDocument} accept a path as a string
+         * rather than a {@link PropertyPath} object. However, you may want to manipulate the path
+         * before getting a property document. This method returns a {@link PropertyPath} rather
+         * than a String for easier path manipulation, which can then be converted to a String.
+         *
+         * @see #getPropertyPath
+         * @see PropertyPath
+         */
+        public @NonNull PropertyPath getPropertyPathObject() {
+            if (mPropertyPathObject == null) {
+                mPropertyPathObject = new PropertyPath(mPropertyPath);
+            }
+            return mPropertyPathObject;
+        }
+
+        /**
+         * Retrieves the text-based match information.
+         *
+         * @return A {@link TextMatchInfo} instance, or null if the match is not text-based.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public @Nullable TextMatchInfo getTextMatch() {
+            return mTextMatch;
+        }
+
+        /**
+         * Retrieves the embedding-based match information. Only populated when {@link
+         * SearchSpec#shouldRetrieveEmbeddingMatchInfos()} is true.
+         *
+         * @return A {@link EmbeddingMatchInfo} instance, or null if the match is not an embedding
+         *     match.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public @Nullable EmbeddingMatchInfo getEmbeddingMatch() {
+            return mEmbeddingMatch;
+        }
+
+        /**
+         * Gets the full text corresponding to the given entry. Returns an empty string if the match
+         * is not text-based.
+         */
+        public @NonNull String getFullText() {
+            if (mTextMatch == null) {
+                return "";
+            }
+            return mTextMatch.getFullText();
+        }
+
+        /**
+         * Gets the {@link MatchRange} of the exact term of the given entry that matched the query.
+         * Returns [0, 0] if the match is not text-based.
+         */
+        public @NonNull MatchRange getExactMatchRange() {
+            if (mTextMatch == null) {
+                return new MatchRange(0, 0);
+            }
+            return mTextMatch.getExactMatchRange();
+        }
+
+        /**
+         * Gets the exact term of the given entry that matched the query. Returns an empty
+         * CharSequence if the match is not text-based.
+         */
+        public @NonNull CharSequence getExactMatch() {
+            if (mTextMatch == null) {
+                return "";
+            }
+            return mTextMatch.getExactMatch();
+        }
+
+        /**
+         * Gets the {@link MatchRange} of the submatch term subsequence of the given entry that
+         * matched the query. Returns [0, 0] if the match is not text-based.
+         */
+        public @NonNull MatchRange getSubmatchRange() {
+            if (mTextMatch == null) {
+                return new MatchRange(0, 0);
+            }
+            return mTextMatch.getSubmatchRange();
+        }
+
+        /**
+         * Gets the exact term subsequence of the given entry that matched the query. Returns an
+         * empty CharSequence if the match is not text-based.
+         */
+        public @NonNull CharSequence getSubmatch() {
+            if (mTextMatch == null) {
+                return "";
+            }
+            return mTextMatch.getSubmatch();
+        }
+
+        /**
+         * Gets the snippet {@link MatchRange} corresponding to the given entry. Returns [0,0] if
+         * the match is not text-based.
+         *
+         * <p>Only populated when set maxSnippetSize > 0 in {@link
+         * SearchSpec.Builder#setMaxSnippetSize}.
+         */
+        public @NonNull MatchRange getSnippetRange() {
+            if (mTextMatch == null) {
+                return new MatchRange(0, 0);
+            }
+            return mTextMatch.getSnippetRange();
+        }
+
+        /**
+         * Gets the snippet corresponding to the given entry. Returns an empty CharSequence if the
+         * match is not text-based.
+         *
+         * <p>Snippet - Provides a subset of the content to display. Only populated when requested
+         * maxSnippetSize > 0. The size of this content can be changed by {@link
+         * SearchSpec.Builder#setMaxSnippetSize}. Windowing is centered around the middle of the
+         * matched token with content on either side clipped to token boundaries.
+         */
+        public @NonNull CharSequence getSnippet() {
+            if (mTextMatch == null) {
+                return "";
+            }
+            return mTextMatch.getSnippet();
+        }
+
+        /**
+         * Sets the {@link GenericDocument} for {@link MatchInfo}.
+         *
+         * <p>{@link MatchInfo} lacks a constructor that populates {@link MatchInfo#mDocument} This
+         * provides the ability to set {@link MatchInfo#mDocument}
+         */
+        void setDocument(@NonNull GenericDocument document) {
+            mDocument = Objects.requireNonNull(document);
+            if (mTextMatch != null) {
+                mTextMatch.setDocument(document);
+            }
+        }
+
+        @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
+        @Override
+        public void writeToParcel(@NonNull Parcel dest, int flags) {
+            MatchInfoCreator.writeToParcel(this, dest, flags);
+        }
+
+        /** Builder for {@link MatchInfo} objects. */
+        public static final class Builder {
+            private final String mPropertyPath;
+            private EmbeddingMatchInfo mEmbeddingMatch = null;
+            private MatchRange mExactMatchRange = new MatchRange(0, 0);
+            private MatchRange mSubmatchRange = new MatchRange(-1, -1);
+            private MatchRange mSnippetRange = new MatchRange(0, 0);
+
+            /**
+             * Creates a new {@link MatchInfo.Builder} reporting a match with the given property
+             * path.
+             *
+             * <p>A property path is a dot-delimited sequence of property names indicating which
+             * property in the document these snippets correspond to.
+             *
+             * <p>Example properties: 'body', 'sender.name', 'sender.emailaddress', etc. For class
+             * example 1, this returns "subject".
+             *
+             * @param propertyPath A dot-delimited sequence of property names indicating which
+             *     property in the document these snippets correspond to.
+             */
+            public Builder(@NonNull String propertyPath) {
+                mPropertyPath = Objects.requireNonNull(propertyPath);
+            }
+
+            /** @hide */
+            public Builder(@NonNull MatchInfo matchInfo) {
+                Objects.requireNonNull(matchInfo);
+                mPropertyPath = matchInfo.mPropertyPath;
+                mEmbeddingMatch = matchInfo.getEmbeddingMatch();
+                mExactMatchRange = matchInfo.getExactMatchRange();
+                // Using the fields directly instead of getSubmatchRange() to bypass the
+                // checkSubmatchSupported check.
+                mSubmatchRange =
+                        new MatchRange(matchInfo.mSubmatchRangeStart, matchInfo.mSubmatchRangeEnd);
+                mSnippetRange = matchInfo.getSnippetRange();
+            }
+
+            /** Sets the {@link EmbeddingMatchInfo} corresponding to the given entry. */
+            @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+            @CanIgnoreReturnValue
+            public @NonNull Builder setEmbeddingMatch(@Nullable EmbeddingMatchInfo embeddingMatch) {
+                mEmbeddingMatch = embeddingMatch;
+                return this;
+            }
+
+            /** Sets the exact {@link MatchRange} corresponding to the given entry. */
+            @CanIgnoreReturnValue
+            public @NonNull Builder setExactMatchRange(@NonNull MatchRange matchRange) {
+                mExactMatchRange = Objects.requireNonNull(matchRange);
+                return this;
+            }
+
+            /** Sets the submatch {@link MatchRange} corresponding to the given entry. */
+            @CanIgnoreReturnValue
+            public @NonNull Builder setSubmatchRange(@NonNull MatchRange matchRange) {
+                mSubmatchRange = Objects.requireNonNull(matchRange);
+                return this;
+            }
+
+            /** Sets the snippet {@link MatchRange} corresponding to the given entry. */
+            @CanIgnoreReturnValue
+            public @NonNull Builder setSnippetRange(@NonNull MatchRange matchRange) {
+                mSnippetRange = Objects.requireNonNull(matchRange);
+                return this;
+            }
+
+            /** Constructs a new {@link MatchInfo}. */
+            public @NonNull MatchInfo build() {
+                TextMatchInfo textMatch = null;
+                if (mEmbeddingMatch == null) {
+                    textMatch =
+                            new TextMatchInfo(
+                                    mExactMatchRange.getStart(), mExactMatchRange.getEnd(),
+                                    mSubmatchRange.getStart(), mSubmatchRange.getEnd(),
+                                    mSnippetRange.getStart(), mSnippetRange.getEnd());
+                    textMatch.setPropertyPath(mPropertyPath);
+                }
+                return new MatchInfo(
+                        mPropertyPath,
+                        mExactMatchRange.getStart(),
+                        mExactMatchRange.getEnd(),
+                        mSubmatchRange.getStart(),
+                        mSubmatchRange.getEnd(),
+                        mSnippetRange.getStart(),
+                        mSnippetRange.getEnd(),
+                        textMatch,
+                        mEmbeddingMatch);
+            }
+        }
+    }
+
+    /**
+     * This class represents match objects for any text match snippets that might be present in
+     * {@link SearchResults} from a string query. Using this class, you can get:
      *
      * <ul>
      *   <li>the full text - all of the text in that String property
@@ -470,7 +811,7 @@ public final class SearchResult extends AbstractSafeParcelable {
      *       SearchSpec.Builder#setMaxSnippetSize}
      * </ul>
      *
-     * for each match in the document.
+     * for each text match in the document.
      *
      * <p>Class Example 1:
      *
@@ -481,15 +822,14 @@ public final class SearchResult extends AbstractSafeParcelable {
      * <p>If the queryExpression is "foo" and {@link SearchSpec#getMaxSnippetSize} is 10,
      *
      * <ul>
-     *   <li>{@link MatchInfo#getPropertyPath()} returns "subject"
-     *   <li>{@link MatchInfo#getFullText()} returns "A commonly used fake word is foo. Another
+     *   <li>{@link TextMatchInfo#getFullText()} returns "A commonly used fake word is foo. Another
      *       nonsense word thats used a lot is bar."
-     *   <li>{@link MatchInfo#getExactMatchRange()} returns [29, 32]
-     *   <li>{@link MatchInfo#getExactMatch()} returns "foo"
-     *   <li>{@link MatchInfo#getSubmatchRange()} returns [29, 32]
-     *   <li>{@link MatchInfo#getSubmatch()} returns "foo"
-     *   <li>{@link MatchInfo#getSnippetRange()} returns [26, 33]
-     *   <li>{@link MatchInfo#getSnippet()} returns "is foo."
+     *   <li>{@link TextMatchInfo#getExactMatchRange()} returns [29, 32]
+     *   <li>{@link TextMatchInfo#getExactMatch()} returns "foo"
+     *   <li>{@link TextMatchInfo#getSubmatchRange()} returns [29, 32]
+     *   <li>{@link TextMatchInfo#getSubmatch()} returns "foo"
+     *   <li>{@link TextMatchInfo#getSnippetRange()} returns [26, 33]
+     *   <li>{@link TextMatchInfo#getSnippet()} returns "is foo."
      * </ul>
      *
      * <p>
@@ -509,60 +849,61 @@ public final class SearchResult extends AbstractSafeParcelable {
      * <p>Match-1
      *
      * <ul>
-     *   <li>{@link MatchInfo#getPropertyPath()} returns "sender.name"
-     *   <li>{@link MatchInfo#getFullText()} returns "Test Name Jr."
-     *   <li>{@link MatchInfo#getExactMatchRange()} returns [0, 4]
-     *   <li>{@link MatchInfo#getExactMatch()} returns "Test"
-     *   <li>{@link MatchInfo#getSubmatchRange()} returns [0, 4]
-     *   <li>{@link MatchInfo#getSubmatch()} returns "Test"
-     *   <li>{@link MatchInfo#getSnippetRange()} returns [0, 9]
-     *   <li>{@link MatchInfo#getSnippet()} returns "Test Name"
+     *   <li>{@link TextMatchInfo#getFullText()} returns "Test Name Jr."
+     *   <li>{@link TextMatchInfo#getExactMatchRange()} returns [0, 4]
+     *   <li>{@link TextMatchInfo#getExactMatch()} returns "Test"
+     *   <li>{@link TextMatchInfo#getSubmatchRange()} returns [0, 4]
+     *   <li>{@link TextMatchInfo#getSubmatch()} returns "Test"
+     *   <li>{@link TextMatchInfo#getSnippetRange()} returns [0, 9]
+     *   <li>{@link TextMatchInfo#getSnippet()} returns "Test Name"
      * </ul>
      *
      * <p>Match-2
      *
      * <ul>
-     *   <li>{@link MatchInfo#getPropertyPath()} returns "subject"
-     *   <li>{@link MatchInfo#getFullText()} returns "Testing 1 2 3"
-     *   <li>{@link MatchInfo#getExactMatchRange()} returns [0, 7]
-     *   <li>{@link MatchInfo#getExactMatch()} returns "Testing"
-     *   <li>{@link MatchInfo#getSubmatchRange()} returns [0, 4]
-     *   <li>{@link MatchInfo#getSubmatch()} returns "Test"
-     *   <li>{@link MatchInfo#getSnippetRange()} returns [0, 9]
-     *   <li>{@link MatchInfo#getSnippet()} returns "Testing 1"
+     *   <li>{@link TextMatchInfo#getFullText()} returns "Testing 1 2 3"
+     *   <li>{@link TextMatchInfo#getExactMatchRange()} returns [0, 7]
+     *   <li>{@link TextMatchInfo#getExactMatch()} returns "Testing"
+     *   <li>{@link TextMatchInfo#getSubmatchRange()} returns [0, 4]
+     *   <li>{@link TextMatchInfo#getSubmatch()} returns "Test"
+     *   <li>{@link TextMatchInfo#getSnippetRange()} returns [0, 9]
+     *   <li>{@link TextMatchInfo#getSnippet()} returns "Testing 1"
      * </ul>
      */
-    @SafeParcelable.Class(creator = "MatchInfoCreator")
+    @SafeParcelable.Class(creator = "TextMatchInfoCreator")
     @SuppressWarnings("HiddenSuperclass")
-    public static final class MatchInfo extends AbstractSafeParcelable {
+    @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+    public static final class TextMatchInfo extends AbstractSafeParcelable {
 
         @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-        @NonNull
-        public static final Parcelable.Creator<MatchInfo> CREATOR = new MatchInfoCreator();
-
-        /** The path of the matching snippet property. */
-        @Field(id = 1, getter = "getPropertyPath")
-        private final String mPropertyPath;
+        public static final @NonNull Parcelable.Creator<TextMatchInfo> CREATOR =
+                new TextMatchInfoCreator();
 
-        @Field(id = 2)
+        @Field(id = 1)
         final int mExactMatchRangeStart;
 
-        @Field(id = 3)
+        @Field(id = 2)
         final int mExactMatchRangeEnd;
 
-        @Field(id = 4)
+        @Field(id = 3)
         final int mSubmatchRangeStart;
 
-        @Field(id = 5)
+        @Field(id = 4)
         final int mSubmatchRangeEnd;
 
-        @Field(id = 6)
+        @Field(id = 5)
         final int mSnippetRangeStart;
 
-        @Field(id = 7)
+        @Field(id = 6)
         final int mSnippetRangeEnd;
 
-        @Nullable private PropertyPath mPropertyPathObject = null;
+        /**
+         * The path of the matching snippet property.
+         *
+         * <p>If this is {@code null}, methods which require access to the property, like {@link
+         * #getExactMatch}, will throw {@link NullPointerException}.
+         */
+        private @Nullable String mPropertyPath = null;
 
         /**
          * Document which the match comes from.
@@ -570,33 +911,41 @@ public final class SearchResult extends AbstractSafeParcelable {
          * <p>If this is {@code null}, methods which require access to the document, like {@link
          * #getExactMatch}, will throw {@link NullPointerException}.
          */
-        @Nullable private GenericDocument mDocument = null;
+        private @Nullable GenericDocument mDocument = null;
 
         /** Full text of the matched property. Populated on first use. */
-        @Nullable private String mFullText;
+        private @Nullable String mFullText;
 
         /** Range of property that exactly matched the query. Populated on first use. */
-        @Nullable private MatchRange mExactMatchRangeCached;
+        private @Nullable MatchRange mExactMatchRangeCached;
 
         /**
          * Range of property that corresponds to the subsequence of the exact match that directly
          * matches a query term. Populated on first use.
          */
-        @Nullable private MatchRange mSubmatchRangeCached;
+        private @Nullable MatchRange mSubmatchRangeCached;
 
         /** Range of some reasonable amount of context around the query. Populated on first use. */
-        @Nullable private MatchRange mWindowRangeCached;
+        private @Nullable MatchRange mWindowRangeCached;
 
+        /**
+         * Creates a new immutable TextMatchInfo.
+         *
+         * @param exactMatchRangeStart the start of the exact {@link MatchRange} for the entry.
+         * @param exactMatchRangeEnd the end of the exact {@link MatchRange} for the entry.
+         * @param submatchRangeStart the start of the sub-match {@link MatchRange} for the entry.
+         * @param submatchRangeEnd the end of the sub-match {@link MatchRange} for the entry.
+         * @param snippetRangeStart the start of the snippet {@link MatchRange} for the entry.
+         * @param snippetRangeEnd the end of the snippet {@link MatchRange} for the entry.
+         */
         @Constructor
-        MatchInfo(
-                @Param(id = 1) @NonNull String propertyPath,
-                @Param(id = 2) int exactMatchRangeStart,
-                @Param(id = 3) int exactMatchRangeEnd,
-                @Param(id = 4) int submatchRangeStart,
-                @Param(id = 5) int submatchRangeEnd,
-                @Param(id = 6) int snippetRangeStart,
-                @Param(id = 7) int snippetRangeEnd) {
-            mPropertyPath = Objects.requireNonNull(propertyPath);
+        public TextMatchInfo(
+                @Param(id = 1) int exactMatchRangeStart,
+                @Param(id = 2) int exactMatchRangeEnd,
+                @Param(id = 3) int submatchRangeStart,
+                @Param(id = 4) int submatchRangeEnd,
+                @Param(id = 5) int snippetRangeStart,
+                @Param(id = 6) int snippetRangeEnd) {
             mExactMatchRangeStart = exactMatchRangeStart;
             mExactMatchRangeEnd = exactMatchRangeEnd;
             mSubmatchRangeStart = submatchRangeStart;
@@ -605,55 +954,22 @@ public final class SearchResult extends AbstractSafeParcelable {
             mSnippetRangeEnd = snippetRangeEnd;
         }
 
-        /**
-         * Gets the property path corresponding to the given entry.
-         *
-         * <p>A property path is a '.' - delimited sequence of property names indicating which
-         * property in the document these snippets correspond to.
-         *
-         * <p>Example properties: 'body', 'sender.name', 'sender.emailaddress', etc. For class
-         * example 1 this returns "subject"
-         */
-        @NonNull
-        public String getPropertyPath() {
-            return mPropertyPath;
-        }
-
-        /**
-         * Gets a {@link PropertyPath} object representing the property path corresponding to the
-         * given entry.
-         *
-         * <p>Methods such as {@link GenericDocument#getPropertyDocument} accept a path as a string
-         * rather than a {@link PropertyPath} object. However, you may want to manipulate the path
-         * before getting a property document. This method returns a {@link PropertyPath} rather
-         * than a String for easier path manipulation, which can then be converted to a String.
-         *
-         * @see #getPropertyPath
-         * @see PropertyPath
-         */
-        @NonNull
-        public PropertyPath getPropertyPathObject() {
-            if (mPropertyPathObject == null) {
-                mPropertyPathObject = new PropertyPath(mPropertyPath);
-            }
-            return mPropertyPathObject;
-        }
-
         /**
          * Gets the full text corresponding to the given entry.
          *
          * <p>Class example 1: this returns "A commonly used fake word is foo. Another nonsense word
          * that's used a lot is bar."
          *
-         * <p>Class example 2: for the first {@link MatchInfo}, this returns "Test Name Jr." and,
-         * for the second {@link MatchInfo}, this returns "Testing 1 2 3".
+         * <p>Class example 2: for the first {@link TextMatchInfo}, this returns "Test Name Jr."
+         * and, for the second {@link TextMatchInfo}, this returns "Testing 1 2 3".
          */
-        @NonNull
-        public String getFullText() {
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public @NonNull String getFullText() {
             if (mFullText == null) {
-                if (mDocument == null) {
+                if (mDocument == null || mPropertyPath == null) {
                     throw new IllegalStateException(
-                            "Document has not been populated; this MatchInfo cannot be used yet");
+                            "Document or property path has not been populated; this TextMatchInfo"
+                                    + " cannot be used yet");
                 }
                 mFullText = getPropertyValues(mDocument, mPropertyPath);
             }
@@ -665,11 +981,11 @@ public final class SearchResult extends AbstractSafeParcelable {
          *
          * <p>Class example 1: this returns [29, 32].
          *
-         * <p>Class example 2: for the first {@link MatchInfo}, this returns [0, 4] and, for the
-         * second {@link MatchInfo}, this returns [0, 7].
+         * <p>Class example 2: for the first {@link TextMatchInfo}, this returns [0, 4] and, for the
+         * second {@link TextMatchInfo}, this returns [0, 7].
          */
-        @NonNull
-        public MatchRange getExactMatchRange() {
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public @NonNull MatchRange getExactMatchRange() {
             if (mExactMatchRangeCached == null) {
                 mExactMatchRangeCached = new MatchRange(mExactMatchRangeStart, mExactMatchRangeEnd);
             }
@@ -681,11 +997,11 @@ public final class SearchResult extends AbstractSafeParcelable {
          *
          * <p>Class example 1: this returns "foo".
          *
-         * <p>Class example 2: for the first {@link MatchInfo}, this returns "Test" and, for the
-         * second {@link MatchInfo}, this returns "Testing".
+         * <p>Class example 2: for the first {@link TextMatchInfo}, this returns "Test" and, for the
+         * second {@link TextMatchInfo}, this returns "Testing".
          */
-        @NonNull
-        public CharSequence getExactMatch() {
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public @NonNull CharSequence getExactMatch() {
             return getSubstring(getExactMatchRange());
         }
 
@@ -695,11 +1011,11 @@ public final class SearchResult extends AbstractSafeParcelable {
          *
          * <p>Class example 1: this returns [29, 32].
          *
-         * <p>Class example 2: for the first {@link MatchInfo}, this returns [0, 4] and, for the
-         * second {@link MatchInfo}, this returns [0, 4].
+         * <p>Class example 2: for the first {@link TextMatchInfo}, this returns [0, 4] and, for the
+         * second {@link TextMatchInfo}, this returns [0, 4].
          */
-        @NonNull
-        public MatchRange getSubmatchRange() {
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public @NonNull MatchRange getSubmatchRange() {
             checkSubmatchSupported();
             if (mSubmatchRangeCached == null) {
                 mSubmatchRangeCached = new MatchRange(mSubmatchRangeStart, mSubmatchRangeEnd);
@@ -712,28 +1028,28 @@ public final class SearchResult extends AbstractSafeParcelable {
          *
          * <p>Class example 1: this returns "foo".
          *
-         * <p>Class example 2: for the first {@link MatchInfo}, this returns "Test" and, for the
-         * second {@link MatchInfo}, this returns "Test".
+         * <p>Class example 2: for the first {@link TextMatchInfo}, this returns "Test" and, for the
+         * second {@link TextMatchInfo}, this returns "Test".
          */
-        @NonNull
-        public CharSequence getSubmatch() {
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public @NonNull CharSequence getSubmatch() {
             checkSubmatchSupported();
             return getSubstring(getSubmatchRange());
         }
 
         /**
-         * Gets the snippet {@link MatchRange} corresponding to the given entry.
+         * Gets the snippet {@link TextMatchInfo} corresponding to the given entry.
          *
          * <p>Only populated when set maxSnippetSize > 0 in {@link
          * SearchSpec.Builder#setMaxSnippetSize}.
          *
          * <p>Class example 1: this returns [29, 41].
          *
-         * <p>Class example 2: for the first {@link MatchInfo}, this returns [0, 9] and, for the
-         * second {@link MatchInfo}, this returns [0, 13].
+         * <p>Class example 2: for the first {@link TextMatchInfo}, this returns [0, 9] and, for the
+         * second {@link TextMatchInfo}, this returns [0, 13].
          */
-        @NonNull
-        public MatchRange getSnippetRange() {
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public @NonNull MatchRange getSnippetRange() {
             if (mWindowRangeCached == null) {
                 mWindowRangeCached = new MatchRange(mSnippetRangeStart, mSnippetRangeEnd);
             }
@@ -750,11 +1066,11 @@ public final class SearchResult extends AbstractSafeParcelable {
          *
          * <p>Class example 1: this returns "foo. Another".
          *
-         * <p>Class example 2: for the first {@link MatchInfo}, this returns "Test Name" and, for
-         * the second {@link MatchInfo}, this returns "Testing 1 2 3".
+         * <p>Class example 2: for the first {@link TextMatchInfo}, this returns "Test Name" and,
+         * for the second {@link TextMatchInfo}, this returns "Testing 1 2 3".
          */
-        @NonNull
-        public CharSequence getSnippet() {
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public @NonNull CharSequence getSnippet() {
             return getSubstring(getSnippetRange());
         }
 
@@ -781,101 +1097,120 @@ public final class SearchResult extends AbstractSafeParcelable {
         }
 
         /**
-         * Sets the {@link GenericDocument} for {@link MatchInfo}.
+         * Sets the {@link GenericDocument} for this {@link TextMatchInfo}.
          *
-         * <p>{@link MatchInfo} lacks a constructor that populates {@link MatchInfo#mDocument} This
-         * provides the ability to set {@link MatchInfo#mDocument}
+         * <p>{@link TextMatchInfo} lacks a constructor that populates {@link
+         * TextMatchInfo#mDocument} This provides the ability to set {@link TextMatchInfo#mDocument}
          */
         void setDocument(@NonNull GenericDocument document) {
-            mDocument = document;
+            mDocument = Objects.requireNonNull(document);
+        }
+
+        /**
+         * Sets the property path for this {@link TextMatchInfo}.
+         *
+         * <p>{@link TextMatchInfo} lacks a constructor that populates {@link
+         * TextMatchInfo#mPropertyPath} This provides the ability to set it.
+         */
+        void setPropertyPath(@NonNull String propertyPath) {
+            mPropertyPath = Objects.requireNonNull(propertyPath);
         }
 
         @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
         @Override
         public void writeToParcel(@NonNull Parcel dest, int flags) {
-            MatchInfoCreator.writeToParcel(this, dest, flags);
+            TextMatchInfoCreator.writeToParcel(this, dest, flags);
         }
+    }
 
-        /** Builder for {@link MatchInfo} objects. */
-        public static final class Builder {
-            private final String mPropertyPath;
-            private MatchRange mExactMatchRange = new MatchRange(0, 0);
-            int mSubmatchRangeStart = -1;
-            int mSubmatchRangeEnd = -1;
-            private MatchRange mSnippetRange = new MatchRange(0, 0);
+    /**
+     * This class represents match objects for any snippets that might be present in {@link
+     * SearchResults} from an embedding query. Using this class, you can get:
+     *
+     * <ul>
+     *   <li>the semantic score of the matching vector with the embedding query
+     *   <li>the query embedding vector index - the index of the query {@link EmbeddingVector} in
+     *       the list returned by {@link SearchSpec#getEmbeddingParameters()}
+     *   <li>the embedding search metric type for the corresponding query
+     * </ul>
+     *
+     * for each vector match in the document.
+     */
+    @SafeParcelable.Class(creator = "EmbeddingMatchInfoCreator")
+    @SuppressWarnings("HiddenSuperclass")
+    @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+    public static final class EmbeddingMatchInfo extends AbstractSafeParcelable {
 
-            /**
-             * Creates a new {@link MatchInfo.Builder} reporting a match with the given property
-             * path.
-             *
-             * <p>A property path is a dot-delimited sequence of property names indicating which
-             * property in the document these snippets correspond to.
-             *
-             * <p>Example properties: 'body', 'sender.name', 'sender.emailaddress', etc. For class
-             * example 1, this returns "subject".
-             *
-             * @param propertyPath A dot-delimited sequence of property names indicating which
-             *     property in the document these snippets correspond to.
-             */
-            public Builder(@NonNull String propertyPath) {
-                mPropertyPath = Objects.requireNonNull(propertyPath);
-            }
+        @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
+        public static final @NonNull Parcelable.Creator<EmbeddingMatchInfo> CREATOR =
+                new EmbeddingMatchInfoCreator();
 
-            /** @hide */
-            public Builder(@NonNull MatchInfo matchInfo) {
-                Objects.requireNonNull(matchInfo);
-                mPropertyPath = matchInfo.mPropertyPath;
-                mExactMatchRange = matchInfo.getExactMatchRange();
-                mSubmatchRangeStart = matchInfo.mSubmatchRangeStart;
-                mSubmatchRangeEnd = matchInfo.mSubmatchRangeEnd;
-                mSnippetRange = matchInfo.getSnippetRange();
-            }
+        @Field(id = 1, getter = "getSemanticScore")
+        private final double mSemanticScore;
 
-            /** Sets the exact {@link MatchRange} corresponding to the given entry. */
-            @CanIgnoreReturnValue
-            @NonNull
-            public Builder setExactMatchRange(@NonNull MatchRange matchRange) {
-                mExactMatchRange = Objects.requireNonNull(matchRange);
-                return this;
-            }
+        @Field(id = 2, getter = "getQueryEmbeddingVectorIndex")
+        private final int mQueryEmbeddingVectorIndex;
 
-            /**
-             * Sets the start and end of a submatch {@link MatchRange} corresponding to the given
-             * entry.
-             */
-            @CanIgnoreReturnValue
-            @NonNull
-            public Builder setSubmatchRange(@NonNull MatchRange matchRange) {
-                mSubmatchRangeStart = matchRange.getStart();
-                mSubmatchRangeEnd = matchRange.getEnd();
-                return this;
-            }
+        @Field(id = 3, getter = "getEmbeddingSearchMetricType")
+        private final int mEmbeddingSearchMetricType;
 
-            /** Sets the snippet {@link MatchRange} corresponding to the given entry. */
-            @CanIgnoreReturnValue
-            @NonNull
-            public Builder setSnippetRange(@NonNull MatchRange matchRange) {
-                mSnippetRange = Objects.requireNonNull(matchRange);
-                return this;
-            }
+        /**
+         * Creates a new immutable EmbeddingMatchInfo.
+         *
+         * @param semanticScore the semantic score of the embedding match against the query vector.
+         * @param queryEmbeddingVectorIndex the index of the matched query embedding vector in
+         *     {@link SearchSpec#getEmbeddingParameters()}
+         * @param embeddingSearchMetricType the search metric type used to calculate the score for
+         *     the match and the query vector
+         */
+        @Constructor
+        public EmbeddingMatchInfo(
+                @Param(id = 1) double semanticScore,
+                @Param(id = 2) int queryEmbeddingVectorIndex,
+                @Param(id = 3) @SearchSpec.EmbeddingSearchMetricType
+                        int embeddingSearchMetricType) {
+            Preconditions.checkArgumentInRange(
+                    embeddingSearchMetricType,
+                    EMBEDDING_SEARCH_METRIC_TYPE_COSINE,
+                    EMBEDDING_SEARCH_METRIC_TYPE_EUCLIDEAN,
+                    "Embedding search metric type");
+            mSemanticScore = semanticScore;
+            mQueryEmbeddingVectorIndex = queryEmbeddingVectorIndex;
+            mEmbeddingSearchMetricType = embeddingSearchMetricType;
+        }
 
-            /** Constructs a new {@link MatchInfo}. */
-            @NonNull
-            public MatchInfo build() {
-                return new MatchInfo(
-                        mPropertyPath,
-                        mExactMatchRange.getStart(),
-                        mExactMatchRange.getEnd(),
-                        mSubmatchRangeStart,
-                        mSubmatchRangeEnd,
-                        mSnippetRange.getStart(),
-                        mSnippetRange.getEnd());
-            }
+        /** Gets the semantic score corresponding to the embedding match. */
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public double getSemanticScore() {
+            return mSemanticScore;
+        }
+
+        /**
+         * Gets the index of the query vector that this embedding match corresponds to. This is the
+         * index of the query {@link EmbeddingVector} in the list returned by {@link
+         * SearchSpec#getEmbeddingParameters()}
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        public int getQueryEmbeddingVectorIndex() {
+            return mQueryEmbeddingVectorIndex;
+        }
+
+        /** Gets the embedding search metric type that this embedding match corresponds to. */
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        @SearchSpec.EmbeddingSearchMetricType
+        public int getEmbeddingSearchMetricType() {
+            return mEmbeddingSearchMetricType;
+        }
+
+        @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
+        @Override
+        public void writeToParcel(@NonNull Parcel dest, int flags) {
+            EmbeddingMatchInfoCreator.writeToParcel(this, dest, flags);
         }
     }
 
     /**
-     * Class providing the position range of matching information.
+     * Class providing the position range of a text match information.
      *
      * <p>All ranges are finite, and the left side of the range is always {@code <=} the right side
      * of the range.
@@ -928,8 +1263,7 @@ public final class SearchResult extends AbstractSafeParcelable {
         }
 
         @Override
-        @NonNull
-        public String toString() {
+        public @NonNull String toString() {
             return "MatchRange { start: " + mStart + " , end: " + mEnd + "}";
         }
 
diff --git a/framework/java/external/android/app/appsearch/SearchResultPage.java b/framework/java/external/android/app/appsearch/SearchResultPage.java
index a00b05de..8aacd867 100644
--- a/framework/java/external/android/app/appsearch/SearchResultPage.java
+++ b/framework/java/external/android/app/appsearch/SearchResultPage.java
@@ -16,13 +16,14 @@
 
 package android.app.appsearch;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.safeparcel.AbstractSafeParcelable;
 import android.app.appsearch.safeparcel.SafeParcelable;
 import android.os.Parcel;
 import android.os.Parcelable;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Collections;
 import java.util.List;
 
@@ -33,16 +34,14 @@ import java.util.List;
  */
 @SafeParcelable.Class(creator = "SearchResultPageCreator")
 public class SearchResultPage extends AbstractSafeParcelable {
-    @NonNull
-    public static final Parcelable.Creator<SearchResultPage> CREATOR =
+    public static final Parcelable.@NonNull Creator<SearchResultPage> CREATOR =
             new SearchResultPageCreator();
 
     @Field(id = 1, getter = "getNextPageToken")
     private final long mNextPageToken;
 
-    @Nullable
     @Field(id = 2, getter = "getResults")
-    private final List<SearchResult> mResults;
+    private final @Nullable List<SearchResult> mResults;
 
     @Constructor
     public SearchResultPage(
@@ -64,8 +63,7 @@ public class SearchResultPage extends AbstractSafeParcelable {
     }
 
     /** Returns all {@link android.app.appsearch.SearchResult}s of this page */
-    @NonNull
-    public List<SearchResult> getResults() {
+    public @NonNull List<SearchResult> getResults() {
         if (mResults == null) {
             return Collections.emptyList();
         }
diff --git a/framework/java/external/android/app/appsearch/SearchSpec.java b/framework/java/external/android/app/appsearch/SearchSpec.java
index 5b4108ed..5ec58680 100644
--- a/framework/java/external/android/app/appsearch/SearchSpec.java
+++ b/framework/java/external/android/app/appsearch/SearchSpec.java
@@ -52,13 +52,13 @@ import java.util.Set;
  * search, like prefix or exact only or apply filters to search for a specific schema type only etc.
  */
 @SafeParcelable.Class(creator = "SearchSpecCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class SearchSpec extends AbstractSafeParcelable {
 
     /** Creator class for {@link SearchSpec}. */
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<SearchSpec> CREATOR = new SearchSpecCreator();
+    public static final @NonNull Parcelable.Creator<SearchSpec> CREATOR = new SearchSpecCreator();
 
     /**
      * Schema type to be used in {@link SearchSpec.Builder#addProjection} to apply property paths to
@@ -124,9 +124,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
     @Field(id = 15)
     final Bundle mTypePropertyWeightsField;
 
-    @Nullable
     @Field(id = 16, getter = "getJoinSpec")
-    private final JoinSpec mJoinSpec;
+    private final @Nullable JoinSpec mJoinSpec;
 
     @Field(id = 17, getter = "getAdvancedRankingExpression")
     private final String mAdvancedRankingExpression;
@@ -135,32 +134,31 @@ public final class SearchSpec extends AbstractSafeParcelable {
     private final List<String> mEnabledFeatures;
 
     @Field(id = 19, getter = "getSearchSourceLogTag")
-    @Nullable
-    private final String mSearchSourceLogTag;
+    private final @Nullable String mSearchSourceLogTag;
 
-    @NonNull
     @Field(id = 20, getter = "getEmbeddingParameters")
-    private final List<EmbeddingVector> mEmbeddingParameters;
+    private final @NonNull List<EmbeddingVector> mEmbeddingParameters;
 
     @Field(id = 21, getter = "getDefaultEmbeddingSearchMetricType")
     private final int mDefaultEmbeddingSearchMetricType;
 
-    @NonNull
     @Field(id = 22, getter = "getInformationalRankingExpressions")
-    private final List<String> mInformationalRankingExpressions;
+    private final @NonNull List<String> mInformationalRankingExpressions;
 
-    @NonNull
     @Field(id = 23, getter = "getSearchStringParameters")
-    private final List<String> mSearchStringParameters;
+    private final @NonNull List<String> mSearchStringParameters;
 
     /**
      * Holds the list of document ids to search over.
      *
      * <p>If empty, the query will search over all documents.
      */
-    @NonNull
     @Field(id = 24, getter = "getFilterDocumentIds")
-    private final List<String> mFilterDocumentIds;
+    private final @NonNull List<String> mFilterDocumentIds;
+
+    /** Whether to retrieve embedding match info for the query. */
+    @Field(id = 25, getter = "shouldRetrieveEmbeddingMatchInfos")
+    private final boolean mRetrieveEmbeddingMatchInfos;
 
     /**
      * Default number of documents per page.
@@ -381,7 +379,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
             @Param(id = 21) int defaultEmbeddingSearchMetricType,
             @Param(id = 22) @Nullable List<String> informationalRankingExpressions,
             @Param(id = 23) @Nullable List<String> searchStringParameters,
-            @Param(id = 24) @Nullable List<String> filterDocumentIds) {
+            @Param(id = 24) @Nullable List<String> filterDocumentIds,
+            @Param(id = 25) boolean retrieveEmbeddingMatchInfos) {
         mTermMatchType = termMatchType;
         mSchemas = Collections.unmodifiableList(Objects.requireNonNull(schemas));
         mNamespaces = Collections.unmodifiableList(Objects.requireNonNull(namespaces));
@@ -421,6 +420,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
                 (filterDocumentIds != null)
                         ? Collections.unmodifiableList(filterDocumentIds)
                         : Collections.emptyList();
+        mRetrieveEmbeddingMatchInfos = retrieveEmbeddingMatchInfos;
     }
 
     /** Returns how the query terms should match terms in the index. */
@@ -434,8 +434,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
      *
      * <p>If empty, the query will search over all schema types.
      */
-    @NonNull
-    public List<String> getFilterSchemas() {
+    public @NonNull List<String> getFilterSchemas() {
         if (mSchemas == null) {
             return Collections.emptyList();
         }
@@ -450,9 +449,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
      * <p>Calling this function repeatedly is inefficient. Prefer to retain the Map returned by this
      * function, rather than calling it multiple times.
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_PROPERTIES)
-    public Map<String, List<String>> getFilterProperties() {
+    public @NonNull Map<String, List<String>> getFilterProperties() {
         Set<String> schemas = mTypePropertyFilters.keySet();
         Map<String, List<String>> typePropertyPathsMap = new ArrayMap<>(schemas.size());
         for (String schema : schemas) {
@@ -468,8 +466,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
      *
      * <p>If empty, the query will search over all namespaces.
      */
-    @NonNull
-    public List<String> getFilterNamespaces() {
+    public @NonNull List<String> getFilterNamespaces() {
         if (mNamespaces == null) {
             return Collections.emptyList();
         }
@@ -483,8 +480,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
      * package names are specified which caller doesn't have access to, then those package names
      * will be ignored.
      */
-    @NonNull
-    public List<String> getFilterPackageNames() {
+    public @NonNull List<String> getFilterPackageNames() {
         if (mPackageNames == null) {
             return Collections.emptyList();
         }
@@ -496,9 +492,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
      *
      * <p>If empty, the query will search over all documents.
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_DOCUMENT_IDS)
-    public List<String> getFilterDocumentIds() {
+    public @NonNull List<String> getFilterDocumentIds() {
         return mFilterDocumentIds;
     }
 
@@ -536,6 +531,15 @@ public final class SearchSpec extends AbstractSafeParcelable {
         return mMaxSnippetSize;
     }
 
+    /**
+     * Returns whether to retrieve embedding match infos as a part of {@link
+     * SearchResult#getMatchInfos()}
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+    public boolean shouldRetrieveEmbeddingMatchInfos() {
+        return mRetrieveEmbeddingMatchInfos;
+    }
+
     /**
      * Returns a map from schema type to property paths to be used for projection.
      *
@@ -546,8 +550,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
      *
      * @return A mapping of schema types to lists of projection strings.
      */
-    @NonNull
-    public Map<String, List<String>> getProjections() {
+    public @NonNull Map<String, List<String>> getProjections() {
         Set<String> schemas = mProjectionTypePropertyMasks.keySet();
         Map<String, List<String>> typePropertyPathsMap = new ArrayMap<>(schemas.size());
         for (String schema : schemas) {
@@ -569,8 +572,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
      *
      * @return A mapping of schema types to lists of projection {@link PropertyPath} objects.
      */
-    @NonNull
-    public Map<String, List<PropertyPath>> getProjectionPaths() {
+    public @NonNull Map<String, List<PropertyPath>> getProjectionPaths() {
         Set<String> schemas = mProjectionTypePropertyMasks.keySet();
         Map<String, List<PropertyPath>> typePropertyPathsMap = new ArrayMap<>(schemas.size());
         for (String schema : schemas) {
@@ -597,8 +599,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
      * @return a {@link Map} of schema type to an inner-map of property paths of the schema type to
      *     the weight to set for that property.
      */
-    @NonNull
-    public Map<String, Map<String, Double>> getPropertyWeights() {
+    public @NonNull Map<String, Map<String, Double>> getPropertyWeights() {
         Set<String> schemaTypes = mTypePropertyWeightsField.keySet();
         Map<String, Map<String, Double>> typePropertyWeightsMap =
                 new ArrayMap<>(schemaTypes.size());
@@ -626,8 +627,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
      * @return a {@link Map} of schema type to an inner-map of property paths of the schema type to
      *     the weight to set for that property.
      */
-    @NonNull
-    public Map<String, Map<PropertyPath, Double>> getPropertyWeightPaths() {
+    public @NonNull Map<String, Map<PropertyPath, Double>> getPropertyWeightPaths() {
         Set<String> schemaTypes = mTypePropertyWeightsField.keySet();
         Map<String, Map<PropertyPath, Double>> typePropertyWeightsMap =
                 new ArrayMap<>(schemaTypes.size());
@@ -668,8 +668,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
     }
 
     /** Returns specification on which documents need to be joined. */
-    @Nullable
-    public JoinSpec getJoinSpec() {
+    public @Nullable JoinSpec getJoinSpec() {
         return mJoinSpec;
     }
 
@@ -677,8 +676,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
      * Get the advanced ranking expression, or "" if {@link Builder#setRankingStrategy(String)} was
      * not called.
      */
-    @NonNull
-    public String getAdvancedRankingExpression() {
+    public @NonNull String getAdvancedRankingExpression() {
         return mAdvancedRankingExpression;
     }
 
@@ -696,9 +694,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
      * be provided as-is to custom {@code AppSearchLogger} implementations you have registered in
      * your app.
      */
-    @Nullable
     @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_SET_SEARCH_SOURCE_LOG_TAG)
-    public String getSearchSourceLogTag() {
+    public @Nullable String getSearchSourceLogTag() {
         return mSearchSourceLogTag;
     }
 
@@ -708,9 +705,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
      *
      * @see AppSearchSession#search
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
-    public List<EmbeddingVector> getEmbeddingParameters() {
+    public @NonNull List<EmbeddingVector> getEmbeddingParameters() {
         return mEmbeddingParameters;
     }
 
@@ -730,9 +726,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
      *
      * @see Builder#addInformationalRankingExpressions
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_INFORMATIONAL_RANKING_EXPRESSIONS)
-    public List<String> getInformationalRankingExpressions() {
+    public @NonNull List<String> getInformationalRankingExpressions() {
         return mInformationalRankingExpressions;
     }
 
@@ -742,9 +737,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
      *
      * @see AppSearchSession#search
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_SEARCH_STRING_PARAMETERS)
-    public List<String> getSearchStringParameters() {
+    public @NonNull List<String> getSearchStringParameters() {
         return mSearchStringParameters;
     }
 
@@ -788,8 +782,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
      * @return the set of {@link Features} enabled in this {@link SearchSpec} Entry.
      * @hide
      */
-    @NonNull
-    public List<String> getEnabledFeatures() {
+    public @NonNull List<String> getEnabledFeatures() {
         return mEnabledFeatures;
     }
 
@@ -825,10 +818,11 @@ public final class SearchSpec extends AbstractSafeParcelable {
         @Order private int mOrder = ORDER_DESCENDING;
         @GroupingType private int mGroupingTypeFlags = 0;
         private int mGroupingLimit = 0;
-        @Nullable private JoinSpec mJoinSpec;
+        private @Nullable JoinSpec mJoinSpec;
         private String mAdvancedRankingExpression = "";
         private List<String> mInformationalRankingExpressions = new ArrayList<>();
-        @Nullable private String mSearchSourceLogTag;
+        private @Nullable String mSearchSourceLogTag;
+        private boolean mRetrieveEmbeddingMatchInfos = false;
         private boolean mBuilt = false;
 
         /** Constructs a new {@link Builder} for {@link SearchSpec} objects. */
@@ -871,6 +865,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
                     new ArrayList<>(searchSpec.getInformationalRankingExpressions());
             mSearchSourceLogTag = searchSpec.getSearchSourceLogTag();
             mFilterDocumentIds = new ArrayList<>(searchSpec.getFilterDocumentIds());
+            mRetrieveEmbeddingMatchInfos = searchSpec.shouldRetrieveEmbeddingMatchInfos();
         }
 
         /**
@@ -880,8 +875,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * SearchSpec#TERM_MATCH_PREFIX}.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTermMatch(@TermMatch int termMatchType) {
+        public @NonNull Builder setTermMatch(@TermMatch int termMatchType) {
             Preconditions.checkArgumentInRange(
                     termMatchType, TERM_MATCH_EXACT_ONLY, TERM_MATCH_PREFIX, "Term match type");
             resetIfBuilt();
@@ -896,8 +890,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all schema types.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterSchemas(@NonNull String... schemas) {
+        public @NonNull Builder addFilterSchemas(@NonNull String... schemas) {
             Objects.requireNonNull(schemas);
             resetIfBuilt();
             return addFilterSchemas(Arrays.asList(schemas));
@@ -910,8 +903,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all schema types.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterSchemas(@NonNull Collection<String> schemas) {
+        public @NonNull Builder addFilterSchemas(@NonNull Collection<String> schemas) {
             Objects.requireNonNull(schemas);
             resetIfBuilt();
             mSchemas.addAll(schemas);
@@ -921,8 +913,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears all schema type filters. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearFilterSchemas() {
+        public @NonNull Builder clearFilterSchemas() {
             resetIfBuilt();
             mSchemas.clear();
             return this;
@@ -951,9 +942,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          *     of property names.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_PROPERTIES)
-        public Builder addFilterProperties(
+        public @NonNull Builder addFilterProperties(
                 @NonNull String schema, @NonNull Collection<String> propertyPaths) {
             Objects.requireNonNull(schema);
             Objects.requireNonNull(propertyPaths);
@@ -977,11 +967,10 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @param schema the {@link AppSearchSchema} that contains the target properties
          * @param propertyPaths The {@link PropertyPath} to search search over
          */
-        @NonNull
         // Getter method is getFilterProperties
         @SuppressLint("MissingGetterMatchingBuilder")
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_PROPERTIES)
-        public Builder addFilterPropertyPaths(
+        public @NonNull Builder addFilterPropertyPaths(
                 @NonNull String schema, @NonNull Collection<PropertyPath> propertyPaths) {
             Objects.requireNonNull(schema);
             Objects.requireNonNull(propertyPaths);
@@ -995,8 +984,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears the property filters for all schema types. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearFilterProperties() {
+        public @NonNull Builder clearFilterProperties() {
             resetIfBuilt();
             mTypePropertyFilters.clear();
             return this;
@@ -1009,8 +997,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all namespaces.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterNamespaces(@NonNull String... namespaces) {
+        public @NonNull Builder addFilterNamespaces(@NonNull String... namespaces) {
             Objects.requireNonNull(namespaces);
             resetIfBuilt();
             return addFilterNamespaces(Arrays.asList(namespaces));
@@ -1023,8 +1010,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all namespaces.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterNamespaces(@NonNull Collection<String> namespaces) {
+        public @NonNull Builder addFilterNamespaces(@NonNull Collection<String> namespaces) {
             Objects.requireNonNull(namespaces);
             resetIfBuilt();
             mNamespaces.addAll(namespaces);
@@ -1034,8 +1020,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears all namespace filters. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearFilterNamespaces() {
+        public @NonNull Builder clearFilterNamespaces() {
             resetIfBuilt();
             mNamespaces.clear();
             return this;
@@ -1050,8 +1035,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * will be ignored.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterPackageNames(@NonNull String... packageNames) {
+        public @NonNull Builder addFilterPackageNames(@NonNull String... packageNames) {
             Objects.requireNonNull(packageNames);
             resetIfBuilt();
             return addFilterPackageNames(Arrays.asList(packageNames));
@@ -1066,8 +1050,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * will be ignored.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterPackageNames(@NonNull Collection<String> packageNames) {
+        public @NonNull Builder addFilterPackageNames(@NonNull Collection<String> packageNames) {
             Objects.requireNonNull(packageNames);
             resetIfBuilt();
             mPackageNames.addAll(packageNames);
@@ -1077,8 +1060,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears all package name filters. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearFilterPackageNames() {
+        public @NonNull Builder clearFilterPackageNames() {
             resetIfBuilt();
             mPackageNames.clear();
             return this;
@@ -1091,9 +1073,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all documents.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_DOCUMENT_IDS)
-        public Builder addFilterDocumentIds(@NonNull String... documentIds) {
+        public @NonNull Builder addFilterDocumentIds(@NonNull String... documentIds) {
             Objects.requireNonNull(documentIds);
             resetIfBuilt();
             return addFilterDocumentIds(Arrays.asList(documentIds));
@@ -1106,9 +1087,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all documents.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_DOCUMENT_IDS)
-        public Builder addFilterDocumentIds(@NonNull Collection<String> documentIds) {
+        public @NonNull Builder addFilterDocumentIds(@NonNull Collection<String> documentIds) {
             Objects.requireNonNull(documentIds);
             resetIfBuilt();
             mFilterDocumentIds.addAll(documentIds);
@@ -1118,8 +1098,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears the document id filters. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearFilterDocumentIds() {
+        public @NonNull Builder clearFilterDocumentIds() {
             resetIfBuilt();
             mFilterDocumentIds.clear();
             return this;
@@ -1131,8 +1110,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * <p>The default number of results per page is 10.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public SearchSpec.Builder setResultCountPerPage(
+        public @NonNull SearchSpec.Builder setResultCountPerPage(
                 @IntRange(from = 0, to = MAX_NUM_PER_PAGE) int resultCountPerPage) {
             Preconditions.checkArgumentInRange(
                     resultCountPerPage, 0, MAX_NUM_PER_PAGE, "resultCountPerPage");
@@ -1143,8 +1121,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
 
         /** Sets ranking strategy for AppSearch results. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRankingStrategy(@RankingStrategy int rankingStrategy) {
+        public @NonNull Builder setRankingStrategy(@RankingStrategy int rankingStrategy) {
             Preconditions.checkArgumentInRange(
                     rankingStrategy,
                     RANKING_STRATEGY_NONE,
@@ -1283,6 +1260,35 @@ public final class SearchSpec extends AbstractSafeParcelable {
          *       </ul>
          * </ul>
          *
+         * <p>The following functions are provided for enhanced list manipulation.
+         *
+         * <ul>
+         *   <li>minOrDefault(V, default_score)
+         *       <p>Returns the minimum value in the input list V or the default_score if the list
+         *       is empty.
+         *       <p>Example: "minOrDefault(this.matchedSemanticScores(getEmbeddingParameter(0)),
+         *       10)" will return the minimum matched semantic scores or 10 if there is no matched
+         *       score for the current document.
+         *       <p>This function requires the feature {@link
+         *       Features#SEARCH_SPEC_RANKING_FUNCTION_MAX_MIN_OR_DEFAULT}.
+         *   <li>maxOrDefault(V, default_score)
+         *       <p>Returns the maximum value in the input list V or the default_score if the list
+         *       is empty.
+         *       <p>Example: "maxOrDefault(this.matchedSemanticScores(getEmbeddingParameter(0)),
+         *       -10)" will return the maximum matched semantic scores or -10 if there is no matched
+         *       score for the current document.
+         *       <p>This function requires the feature {@link
+         *       Features#SEARCH_SPEC_RANKING_FUNCTION_MAX_MIN_OR_DEFAULT}.
+         *   <li>filterByRange(V, low, high)
+         *       <p>Returns a sublist of V that only contains the elements that fall within the
+         *       specified range [low, high].
+         *       <p>Example: "filterByRange(this.matchedSemanticScores(getEmbeddingParameter(0)), 0,
+         *       1)" will return a list of matched semantic scores that are between 0 and 1,
+         *       inclusive.
+         *       <p>This function requires the feature {@link
+         *       Features#SEARCH_SPEC_RANKING_FUNCTION_FILTER_BY_RANGE}.
+         * </ul>
+         *
          * <p>Some errors may occur when using advanced ranking.
          *
          * <p>Syntax Error: the expression violates the syntax of the advanced ranking language.
@@ -1328,8 +1334,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @param advancedRankingExpression a non-empty string representing the ranking expression.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRankingStrategy(@NonNull String advancedRankingExpression) {
+        public @NonNull Builder setRankingStrategy(@NonNull String advancedRankingExpression) {
             Preconditions.checkStringNotEmpty(advancedRankingExpression);
             resetIfBuilt();
             mRankingStrategy = RANKING_STRATEGY_ADVANCED_RANKING_EXPRESSION;
@@ -1347,9 +1352,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * SearchSpec.Builder#setRankingStrategy(String)}.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_INFORMATIONAL_RANKING_EXPRESSIONS)
-        public Builder addInformationalRankingExpressions(
+        public @NonNull Builder addInformationalRankingExpressions(
                 @NonNull String... informationalRankingExpressions) {
             Objects.requireNonNull(informationalRankingExpressions);
             resetIfBuilt();
@@ -1367,9 +1371,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * SearchSpec.Builder#setRankingStrategy(String)}.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_INFORMATIONAL_RANKING_EXPRESSIONS)
-        public Builder addInformationalRankingExpressions(
+        public @NonNull Builder addInformationalRankingExpressions(
                 @NonNull Collection<String> informationalRankingExpressions) {
             Objects.requireNonNull(informationalRankingExpressions);
             resetIfBuilt();
@@ -1380,8 +1383,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears all informational ranking expressions. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearInformationalRankingExpressions() {
+        public @NonNull Builder clearInformationalRankingExpressions() {
             resetIfBuilt();
             mInformationalRankingExpressions.clear();
             return this;
@@ -1405,9 +1407,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          *     using in {@link android.util.Log}. The length of the teg should between 1 and 100.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_SET_SEARCH_SOURCE_LOG_TAG)
-        public Builder setSearchSourceLogTag(@NonNull String searchSourceLogTag) {
+        public @NonNull Builder setSearchSourceLogTag(@NonNull String searchSourceLogTag) {
             Preconditions.checkStringNotEmpty(searchSourceLogTag);
             Preconditions.checkArgument(
                     searchSourceLogTag.length() <= 100,
@@ -1421,8 +1422,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears the log tag that indicates the source of this search. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearSearchSourceLogTag() {
+        public @NonNull Builder clearSearchSourceLogTag() {
             resetIfBuilt();
             mSearchSourceLogTag = null;
             return this;
@@ -1435,8 +1435,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * <p>This order field will be ignored if RankingStrategy = {@code RANKING_STRATEGY_NONE}.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setOrder(@Order int order) {
+        public @NonNull Builder setOrder(@Order int order) {
             Preconditions.checkArgumentInRange(
                     order, ORDER_DESCENDING, ORDER_ASCENDING, "Result ranking order");
             resetIfBuilt();
@@ -1455,8 +1454,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * SearchResult#getMatchInfos} will be empty.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public SearchSpec.Builder setSnippetCount(
+        public @NonNull SearchSpec.Builder setSnippetCount(
                 @IntRange(from = 0, to = MAX_SNIPPET_COUNT) int snippetCount) {
             Preconditions.checkArgumentInRange(snippetCount, 0, MAX_SNIPPET_COUNT, "snippetCount");
             resetIfBuilt();
@@ -1476,8 +1474,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * value of 10,000.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public SearchSpec.Builder setSnippetCountPerProperty(
+        public @NonNull SearchSpec.Builder setSnippetCountPerProperty(
                 @IntRange(from = 0, to = MAX_SNIPPET_PER_PROPERTY_COUNT)
                         int snippetCountPerProperty) {
             Preconditions.checkArgumentInRange(
@@ -1503,8 +1500,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * will return a window of "bar baz bat" which is only 11 bytes long.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public SearchSpec.Builder setMaxSnippetSize(
+        public @NonNull SearchSpec.Builder setMaxSnippetSize(
                 @IntRange(from = 0, to = MAX_SNIPPET_SIZE_LIMIT) int maxSnippetSize) {
             Preconditions.checkArgumentInRange(
                     maxSnippetSize, 0, MAX_SNIPPET_SIZE_LIMIT, "maxSnippetSize");
@@ -1513,6 +1509,24 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Sets whether to retrieve embedding match infos as a part of {@link
+         * SearchResult#getMatchInfos()}.
+         *
+         * <p>Note that this does not modify the snippet count fields, and any retrieved embedding
+         * match infos also count toward the limit set in {@link SearchSpec#getSnippetCount()} and
+         * {@link SearchSpec#getSnippetCountPerProperty()}.
+         */
+        @CanIgnoreReturnValue
+        @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+        @SuppressLint("MissingGetterMatchingBuilder")
+        public @NonNull Builder setRetrieveEmbeddingMatchInfos(
+                boolean retrieveEmbeddingMatchInfos) {
+            resetIfBuilt();
+            mRetrieveEmbeddingMatchInfos = retrieveEmbeddingMatchInfos;
+            return this;
+        }
+
         /**
          * Adds property paths for the specified type to be used for projection. If property paths
          * are added for a type, then only the properties referred to will be retrieved for results
@@ -1524,8 +1538,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @param propertyPaths the projections to add.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public SearchSpec.Builder addProjection(
+        public @NonNull SearchSpec.Builder addProjection(
                 @NonNull String schema, @NonNull Collection<String> propertyPaths) {
             Objects.requireNonNull(schema);
             Objects.requireNonNull(propertyPaths);
@@ -1605,8 +1618,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @param propertyPaths the projections to add.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public SearchSpec.Builder addProjectionPaths(
+        public @NonNull SearchSpec.Builder addProjectionPaths(
                 @NonNull String schema, @NonNull Collection<PropertyPath> propertyPaths) {
             Objects.requireNonNull(schema);
             Objects.requireNonNull(propertyPaths);
@@ -1620,8 +1632,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears the projections for all schema types. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearProjections() {
+        public @NonNull Builder clearProjections() {
             resetIfBuilt();
             mProjectionTypePropertyMasks.clear();
             return this;
@@ -1647,8 +1658,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         // getResultGroupingLimit
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
-        @NonNull
-        public Builder setResultGrouping(@GroupingType int groupingTypeFlags, int limit) {
+        public @NonNull Builder setResultGrouping(@GroupingType int groupingTypeFlags, int limit) {
             Preconditions.checkState(
                     groupingTypeFlags != 0, "Result grouping type cannot be zero.");
             resetIfBuilt();
@@ -1660,8 +1670,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears the result grouping and limit. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearResultGrouping() {
+        public @NonNull Builder clearResultGrouping() {
             resetIfBuilt();
             mGroupingTypeFlags = 0;
             mGroupingLimit = 0;
@@ -1694,8 +1703,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @throws IllegalArgumentException if a weight is equal to or less than 0.0.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public SearchSpec.Builder setPropertyWeights(
+        public @NonNull SearchSpec.Builder setPropertyWeights(
                 @NonNull String schemaType, @NonNull Map<String, Double> propertyPathWeights) {
             Objects.requireNonNull(schemaType);
             Objects.requireNonNull(propertyPathWeights);
@@ -1722,8 +1730,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears the property weights for all schema types. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearPropertyWeights() {
+        public @NonNull Builder clearPropertyWeights() {
             resetIfBuilt();
             mTypePropertyWeights.clear();
             return this;
@@ -1738,8 +1745,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @param joinSpec a specification on how to perform the Join operation.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setJoinSpec(@NonNull JoinSpec joinSpec) {
+        public @NonNull Builder setJoinSpec(@NonNull JoinSpec joinSpec) {
             resetIfBuilt();
             mJoinSpec = Objects.requireNonNull(joinSpec);
             return this;
@@ -1748,8 +1754,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears the {@link JoinSpec}. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearJoinSpec() {
+        public @NonNull Builder clearJoinSpec() {
             resetIfBuilt();
             mJoinSpec = null;
             return this;
@@ -1781,8 +1786,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @throws IllegalArgumentException if a weight is equal to or less than 0.0.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public SearchSpec.Builder setPropertyWeightPaths(
+        public @NonNull SearchSpec.Builder setPropertyWeightPaths(
                 @NonNull String schemaType,
                 @NonNull Map<PropertyPath, Double> propertyPathWeights) {
             Objects.requireNonNull(propertyPathWeights);
@@ -1805,9 +1809,9 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @see SearchSpec.Builder#setRankingStrategy(String)
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
-        public Builder addEmbeddingParameters(@NonNull EmbeddingVector... searchEmbeddings) {
+        public @NonNull Builder addEmbeddingParameters(
+                @NonNull EmbeddingVector... searchEmbeddings) {
             Objects.requireNonNull(searchEmbeddings);
             resetIfBuilt();
             return addEmbeddingParameters(Arrays.asList(searchEmbeddings));
@@ -1821,9 +1825,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @see SearchSpec.Builder#setRankingStrategy(String)
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
-        public Builder addEmbeddingParameters(
+        public @NonNull Builder addEmbeddingParameters(
                 @NonNull Collection<EmbeddingVector> searchEmbeddings) {
             Objects.requireNonNull(searchEmbeddings);
             resetIfBuilt();
@@ -1834,8 +1837,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         /** Clears the embedding parameters. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearEmbeddingParameters() {
+        public @NonNull Builder clearEmbeddingParameters() {
             resetIfBuilt();
             mEmbeddingParameters.clear();
             return this;
@@ -1852,9 +1854,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * override this default.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
-        public Builder setDefaultEmbeddingSearchMetricType(
+        public @NonNull Builder setDefaultEmbeddingSearchMetricType(
                 @EmbeddingSearchMetricType int defaultEmbeddingSearchMetricType) {
             Preconditions.checkArgumentInRange(
                     defaultEmbeddingSearchMetricType,
@@ -1873,9 +1874,9 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @see AppSearchSession#search
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_SEARCH_STRING_PARAMETERS)
-        public Builder addSearchStringParameters(@NonNull String... searchStringParameters) {
+        public @NonNull Builder addSearchStringParameters(
+                @NonNull String... searchStringParameters) {
             Objects.requireNonNull(searchStringParameters);
             resetIfBuilt();
             return addSearchStringParameters(Arrays.asList(searchStringParameters));
@@ -1888,9 +1889,9 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @see AppSearchSession#search
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_SEARCH_STRING_PARAMETERS)
-        public Builder addSearchStringParameters(@NonNull List<String> searchStringParameters) {
+        public @NonNull Builder addSearchStringParameters(
+                @NonNull List<String> searchStringParameters) {
             Objects.requireNonNull(searchStringParameters);
             resetIfBuilt();
             mSearchStringParameters.addAll(searchStringParameters);
@@ -1903,8 +1904,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearSearchStringParameters() {
+        public @NonNull Builder clearSearchStringParameters() {
             resetIfBuilt();
             mSearchStringParameters.clear();
             return this;
@@ -1919,8 +1919,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          *     querying features.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNumericSearchEnabled(boolean enabled) {
+        public @NonNull Builder setNumericSearchEnabled(boolean enabled) {
             modifyEnabledFeature(FeatureConstants.NUMERIC_SEARCH, enabled);
             return this;
         }
@@ -1937,8 +1936,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          *     'foo/bar' is treated as a single 'verbatim' token.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setVerbatimSearchEnabled(boolean enabled) {
+        public @NonNull Builder setVerbatimSearchEnabled(boolean enabled) {
             modifyEnabledFeature(FeatureConstants.VERBATIM_SEARCH, enabled);
             return this;
         }
@@ -1969,8 +1967,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          *     rewritten as "termSearch(\"foo bar\", createList(\"subject\", \"bar\"))"
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setListFilterQueryLanguageEnabled(boolean enabled) {
+        public @NonNull Builder setListFilterQueryLanguageEnabled(boolean enabled) {
             modifyEnabledFeature(FeatureConstants.LIST_FILTER_QUERY_LANGUAGE, enabled);
             return this;
         }
@@ -1984,9 +1981,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          *     AppSearchSession#search} for more details about the function.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_LIST_FILTER_HAS_PROPERTY_FUNCTION)
-        public Builder setListFilterHasPropertyFunctionEnabled(boolean enabled) {
+        public @NonNull Builder setListFilterHasPropertyFunctionEnabled(boolean enabled) {
             modifyEnabledFeature(FeatureConstants.LIST_FILTER_HAS_PROPERTY_FUNCTION, enabled);
             return this;
         }
@@ -2001,9 +1997,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * @param enabled Enables the feature if true, otherwise disables it
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION)
-        public Builder setListFilterMatchScoreExpressionFunctionEnabled(boolean enabled) {
+        public @NonNull Builder setListFilterMatchScoreExpressionFunctionEnabled(boolean enabled) {
             modifyEnabledFeature(
                     FeatureConstants.LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION, enabled);
             return this;
@@ -2019,8 +2014,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          */
         @CanIgnoreReturnValue
         @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
-        @NonNull
-        public Builder setScorablePropertyRankingEnabled(boolean enabled) {
+        public @NonNull Builder setScorablePropertyRankingEnabled(boolean enabled) {
             modifyEnabledFeature(FeatureConstants.SCHEMA_SCORABLE_PROPERTY_CONFIG, enabled);
             return this;
         }
@@ -2037,8 +2031,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
          *     JoinSpec#getAggregationScoringStrategy()} but the ranking strategy is not {@link
          *     #RANKING_STRATEGY_JOIN_AGGREGATE_SCORE}.
          */
-        @NonNull
-        public SearchSpec build() {
+        public @NonNull SearchSpec build() {
             if (mJoinSpec != null) {
                 if (mRankingStrategy != RANKING_STRATEGY_JOIN_AGGREGATE_SCORE
                         && mJoinSpec.getAggregationScoringStrategy()
@@ -2087,7 +2080,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
                     mDefaultEmbeddingSearchMetricType,
                     mInformationalRankingExpressions,
                     mSearchStringParameters,
-                    mFilterDocumentIds);
+                    mFilterDocumentIds,
+                    mRetrieveEmbeddingMatchInfos);
         }
 
         private void resetIfBuilt() {
diff --git a/framework/java/external/android/app/appsearch/SearchSuggestionResult.java b/framework/java/external/android/app/appsearch/SearchSuggestionResult.java
index 27f538d7..062feed7 100644
--- a/framework/java/external/android/app/appsearch/SearchSuggestionResult.java
+++ b/framework/java/external/android/app/appsearch/SearchSuggestionResult.java
@@ -32,18 +32,18 @@ import java.util.Objects;
 
 /** The result class of the {@link AppSearchSession#searchSuggestion}. */
 @SafeParcelable.Class(creator = "SearchSuggestionResultCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class SearchSuggestionResult extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<SearchSuggestionResult> CREATOR =
+    public static final @NonNull Parcelable.Creator<SearchSuggestionResult> CREATOR =
             new SearchSuggestionResultCreator();
 
     @Field(id = 1, getter = "getSuggestedResult")
     private final String mSuggestedResult;
 
-    @Nullable private Integer mHashCode;
+    private @Nullable Integer mHashCode;
 
     @Constructor
     SearchSuggestionResult(@Param(id = 1) String suggestedResult) {
@@ -58,8 +58,7 @@ public final class SearchSuggestionResult extends AbstractSafeParcelable {
      *
      * <p>The suggested result only contains lowercase or special characters.
      */
-    @NonNull
-    public String getSuggestedResult() {
+    public @NonNull String getSuggestedResult() {
         return mSuggestedResult;
     }
 
@@ -94,8 +93,7 @@ public final class SearchSuggestionResult extends AbstractSafeParcelable {
          * <p>The suggested result should only contain lowercase or special characters.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setSuggestedResult(@NonNull String suggestedResult) {
+        public @NonNull Builder setSuggestedResult(@NonNull String suggestedResult) {
             Objects.requireNonNull(suggestedResult);
             Preconditions.checkStringNotEmpty(suggestedResult);
             mSuggestedResult = suggestedResult;
@@ -103,8 +101,7 @@ public final class SearchSuggestionResult extends AbstractSafeParcelable {
         }
 
         /** Build a {@link SearchSuggestionResult} object */
-        @NonNull
-        public SearchSuggestionResult build() {
+        public @NonNull SearchSuggestionResult build() {
             return new SearchSuggestionResult(mSuggestedResult);
         }
     }
diff --git a/framework/java/external/android/app/appsearch/SearchSuggestionSpec.java b/framework/java/external/android/app/appsearch/SearchSuggestionSpec.java
index ff12c6e3..2db86970 100644
--- a/framework/java/external/android/app/appsearch/SearchSuggestionSpec.java
+++ b/framework/java/external/android/app/appsearch/SearchSuggestionSpec.java
@@ -53,33 +53,29 @@ import java.util.Set;
  * @see AppSearchSession#searchSuggestion
  */
 @SafeParcelable.Class(creator = "SearchSuggestionSpecCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class SearchSuggestionSpec extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<SearchSuggestionSpec> CREATOR =
+    public static final @NonNull Parcelable.Creator<SearchSuggestionSpec> CREATOR =
             new SearchSuggestionSpecCreator();
 
-    @NonNull
     @Field(id = 1, getter = "getFilterNamespaces")
-    private final List<String> mFilterNamespaces;
+    private final @NonNull List<String> mFilterNamespaces;
 
-    @NonNull
     @Field(id = 2, getter = "getFilterSchemas")
-    private final List<String> mFilterSchemas;
+    private final @NonNull List<String> mFilterSchemas;
 
     // Maps are not supported by SafeParcelable fields, using Bundle instead. Here the key is
     // schema type and value is a list of target property paths in that schema to search over.
-    @NonNull
     @Field(id = 3)
-    final Bundle mFilterProperties;
+    final @NonNull Bundle mFilterProperties;
 
     // Maps are not supported by SafeParcelable fields, using Bundle instead. Here the key is
     // namespace and value is a list of target document ids in that namespace to search over.
-    @NonNull
     @Field(id = 4)
-    final Bundle mFilterDocumentIds;
+    final @NonNull Bundle mFilterDocumentIds;
 
     @Field(id = 5, getter = "getRankingStrategy")
     private final int mRankingStrategy;
@@ -87,9 +83,8 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
     @Field(id = 6, getter = "getMaximumResultCount")
     private final int mMaximumResultCount;
 
-    @NonNull
     @Field(id = 7, getter = "getSearchStringParameters")
-    private final List<String> mSearchStringParameters;
+    private final @NonNull List<String> mSearchStringParameters;
 
     /** @hide */
     @Constructor
@@ -174,8 +169,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
      *
      * <p>If empty, will search over all namespaces.
      */
-    @NonNull
-    public List<String> getFilterNamespaces() {
+    public @NonNull List<String> getFilterNamespaces() {
         if (mFilterNamespaces == null) {
             return Collections.emptyList();
         }
@@ -193,8 +187,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
      *
      * <p>If empty, will search over all schemas.
      */
-    @NonNull
-    public List<String> getFilterSchemas() {
+    public @NonNull List<String> getFilterSchemas() {
         if (mFilterSchemas == null) {
             return Collections.emptyList();
         }
@@ -213,9 +206,8 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
      * <p>Calling this function repeatedly is inefficient. Prefer to retain the Map returned by this
      * function, rather than calling it multiple times.
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_PROPERTIES)
-    public Map<String, List<String>> getFilterProperties() {
+    public @NonNull Map<String, List<String>> getFilterProperties() {
         Set<String> schemas = mFilterProperties.keySet();
         Map<String, List<String>> typePropertyPathsMap = new ArrayMap<>(schemas.size());
         for (String schema : schemas) {
@@ -237,8 +229,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
      * <p>Calling this function repeatedly is inefficient. Prefer to retain the Map returned by this
      * function, rather than calling it multiple times.
      */
-    @NonNull
-    public Map<String, List<String>> getFilterDocumentIds() {
+    public @NonNull Map<String, List<String>> getFilterDocumentIds() {
         Set<String> namespaces = mFilterDocumentIds.keySet();
         Map<String, List<String>> documentIdsMap = new ArrayMap<>(namespaces.size());
         for (String namespace : namespaces) {
@@ -255,9 +246,8 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
      *
      * @see AppSearchSession#search
      */
-    @NonNull
     @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_SEARCH_STRING_PARAMETERS)
-    public List<String> getSearchStringParameters() {
+    public @NonNull List<String> getSearchStringParameters() {
         return mSearchStringParameters;
     }
 
@@ -293,8 +283,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all namespaces.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterNamespaces(@NonNull String... namespaces) {
+        public @NonNull Builder addFilterNamespaces(@NonNull String... namespaces) {
             Objects.requireNonNull(namespaces);
             resetIfBuilt();
             return addFilterNamespaces(Arrays.asList(namespaces));
@@ -307,8 +296,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all namespaces.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterNamespaces(@NonNull Collection<String> namespaces) {
+        public @NonNull Builder addFilterNamespaces(@NonNull Collection<String> namespaces) {
             Objects.requireNonNull(namespaces);
             resetIfBuilt();
             mNamespaces.addAll(namespaces);
@@ -322,8 +310,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * this method is never called.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRankingStrategy(@SuggestionRankingStrategy int rankingStrategy) {
+        public @NonNull Builder setRankingStrategy(@SuggestionRankingStrategy int rankingStrategy) {
             Preconditions.checkArgumentInRange(
                     rankingStrategy,
                     SUGGESTION_RANKING_STRATEGY_DOCUMENT_COUNT,
@@ -341,8 +328,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all schema.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterSchemas(@NonNull String... schemaTypes) {
+        public @NonNull Builder addFilterSchemas(@NonNull String... schemaTypes) {
             Objects.requireNonNull(schemaTypes);
             resetIfBuilt();
             return addFilterSchemas(Arrays.asList(schemaTypes));
@@ -355,8 +341,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all schema.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterSchemas(@NonNull Collection<String> schemaTypes) {
+        public @NonNull Builder addFilterSchemas(@NonNull Collection<String> schemaTypes) {
             Objects.requireNonNull(schemaTypes);
             resetIfBuilt();
             mSchemas.addAll(schemaTypes);
@@ -383,9 +368,8 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          *     to.
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_PROPERTIES)
-        public Builder addFilterProperties(
+        public @NonNull Builder addFilterProperties(
                 @NonNull String schema, @NonNull Collection<String> propertyPaths) {
             Objects.requireNonNull(schema);
             Objects.requireNonNull(propertyPaths);
@@ -415,11 +399,10 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * @param propertyPaths The {@link PropertyPath} to search suggestion over
          */
         @CanIgnoreReturnValue
-        @NonNull
         // Getter method is getFilterProperties
         @SuppressLint("MissingGetterMatchingBuilder")
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_PROPERTIES)
-        public Builder addFilterPropertyPaths(
+        public @NonNull Builder addFilterPropertyPaths(
                 @NonNull String schema, @NonNull Collection<PropertyPath> propertyPaths) {
             Objects.requireNonNull(schema);
             Objects.requireNonNull(propertyPaths);
@@ -437,8 +420,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all documents.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterDocumentIds(
+        public @NonNull Builder addFilterDocumentIds(
                 @NonNull String namespace, @NonNull String... documentIds) {
             Objects.requireNonNull(namespace);
             Objects.requireNonNull(documentIds);
@@ -453,8 +435,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * <p>If unset, the query will search over all documents.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterDocumentIds(
+        public @NonNull Builder addFilterDocumentIds(
                 @NonNull String namespace, @NonNull Collection<String> documentIds) {
             Objects.requireNonNull(namespace);
             Objects.requireNonNull(documentIds);
@@ -474,9 +455,9 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * @see AppSearchSession#search
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_SEARCH_STRING_PARAMETERS)
-        public Builder addSearchStringParameters(@NonNull String... searchStringParameters) {
+        public @NonNull Builder addSearchStringParameters(
+                @NonNull String... searchStringParameters) {
             Objects.requireNonNull(searchStringParameters);
             resetIfBuilt();
             return addSearchStringParameters(Arrays.asList(searchStringParameters));
@@ -489,9 +470,9 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
          * @see AppSearchSession#search
          */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_SEARCH_STRING_PARAMETERS)
-        public Builder addSearchStringParameters(@NonNull List<String> searchStringParameters) {
+        public @NonNull Builder addSearchStringParameters(
+                @NonNull List<String> searchStringParameters) {
             Objects.requireNonNull(searchStringParameters);
             resetIfBuilt();
             mSearchStringParameters.addAll(searchStringParameters);
@@ -499,8 +480,7 @@ public final class SearchSuggestionSpec extends AbstractSafeParcelable {
         }
 
         /** Constructs a new {@link SearchSpec} from the contents of this builder. */
-        @NonNull
-        public SearchSuggestionSpec build() {
+        public @NonNull SearchSuggestionSpec build() {
             if (!mSchemas.isEmpty()) {
                 Set<String> schemaFilter = new ArraySet<>(mSchemas);
                 for (String schema : mTypePropertyFilters.keySet()) {
diff --git a/framework/java/external/android/app/appsearch/SetBlobVisibilityRequest.java b/framework/java/external/android/app/appsearch/SetBlobVisibilityRequest.java
index 91a50f8e..83857e49 100644
--- a/framework/java/external/android/app/appsearch/SetBlobVisibilityRequest.java
+++ b/framework/java/external/android/app/appsearch/SetBlobVisibilityRequest.java
@@ -17,7 +17,6 @@
 package android.app.appsearch;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 import android.annotation.SuppressLint;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.util.ArrayMap;
@@ -25,6 +24,8 @@ import android.util.ArraySet;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Collections;
 import java.util.Map;
 import java.util.Objects;
@@ -58,8 +59,7 @@ public class SetBlobVisibilityRequest {
      * Returns all the blob namespaces that are opted out of being displayed and visible on any
      * system UI surface.
      */
-    @NonNull
-    public Set<String> getNamespacesNotDisplayedBySystem() {
+    public @NonNull Set<String> getNamespacesNotDisplayedBySystem() {
         return Collections.unmodifiableSet(mNamespacesNotDisplayedBySystem);
     }
 
@@ -76,8 +76,7 @@ public class SetBlobVisibilityRequest {
      *
      * @see Builder#addNamespaceVisibleToConfig
      */
-    @NonNull
-    public Map<String, Set<SchemaVisibilityConfig>> getNamespacesVisibleToConfigs() {
+    public @NonNull Map<String, Set<SchemaVisibilityConfig>> getNamespacesVisibleToConfigs() {
         return Collections.unmodifiableMap(mNamespacesVisibleToConfigs);
     }
 
@@ -105,8 +104,8 @@ public class SetBlobVisibilityRequest {
         // Merged list available from getBlobNamespacesNotDisplayedBySystem
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
-        @NonNull
-        public Builder setNamespaceDisplayedBySystem(@NonNull String namespace, boolean displayed) {
+        public @NonNull Builder setNamespaceDisplayedBySystem(
+                @NonNull String namespace, boolean displayed) {
             Objects.requireNonNull(namespace);
             if (displayed) {
                 mNamespacesNotDisplayedBySystem.remove(namespace);
@@ -134,8 +133,7 @@ public class SetBlobVisibilityRequest {
         // Merged list available from getNamespacesVisibleToConfigs
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
-        @NonNull
-        public Builder addNamespaceVisibleToConfig(
+        public @NonNull Builder addNamespaceVisibleToConfig(
                 @NonNull String namespace, @NonNull SchemaVisibilityConfig visibilityConfig) {
             Objects.requireNonNull(namespace);
             Objects.requireNonNull(visibilityConfig);
@@ -158,16 +156,14 @@ public class SetBlobVisibilityRequest {
          * @param namespace The blob namespace for which visibility config should be cleared.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearNamespaceVisibleToConfigs(@NonNull String namespace) {
+        public @NonNull Builder clearNamespaceVisibleToConfigs(@NonNull String namespace) {
             Objects.requireNonNull(namespace);
             mNamespacesVisibleToConfigs.remove(namespace);
             return this;
         }
 
         /** Builds a new {@link SetBlobVisibilityRequest} object. */
-        @NonNull
-        public SetBlobVisibilityRequest build() {
+        public @NonNull SetBlobVisibilityRequest build() {
             return new SetBlobVisibilityRequest(
                     new ArraySet<>(mNamespacesNotDisplayedBySystem),
                     new ArrayMap<>(mNamespacesVisibleToConfigs));
diff --git a/framework/java/external/android/app/appsearch/SetSchemaRequest.java b/framework/java/external/android/app/appsearch/SetSchemaRequest.java
index d85e55f1..227f366d 100644
--- a/framework/java/external/android/app/appsearch/SetSchemaRequest.java
+++ b/framework/java/external/android/app/appsearch/SetSchemaRequest.java
@@ -87,6 +87,8 @@ import java.util.Set;
  * @see AppSearchSession#setSchema
  * @see Migrator
  */
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings("JSpecifyNullness")
 public final class SetSchemaRequest {
 
     /**
@@ -107,7 +109,6 @@ public final class SetSchemaRequest {
                 ENTERPRISE_ACCESS,
                 MANAGED_PROFILE_CONTACTS_ACCESS,
                 EXECUTE_APP_FUNCTIONS,
-                EXECUTE_APP_FUNCTIONS_TRUSTED,
                 PACKAGE_USAGE_STATS,
             })
     @Retention(RetentionPolicy.SOURCE)
@@ -185,16 +186,8 @@ public final class SetSchemaRequest {
     public static final int EXECUTE_APP_FUNCTIONS = 9;
 
     /**
-     * The AppSearch enumeration corresponding to {@link
-     * android.Manifest.permission#EXECUTE_APP_FUNCTIONS_TRUSTED} Android permission that can be
-     * used to guard AppSearch schema type visibility in {@link
-     * SetSchemaRequest.Builder#addRequiredPermissionsForSchemaTypeVisibility}.
-     *
-     * <p>This is internally used by AppFunctions API to store app functions runtime metadata so it
-     * is visible to packages holding {@link
-     * android.Manifest.permission#EXECUTE_APP_FUNCTIONS_TRUSTED} permission (currently associated
-     * with system packages in the {@link android.app.role.SYSTEM_UI_INTELLIGENCE} role).
-     *
+     * @deprecated The corresponding permission is deprecated. Some documents are already persisted
+     *     with this constant, therefore keeping the constant here for compatibility reasons.
      * @hide
      */
     public static final int EXECUTE_APP_FUNCTIONS_TRUSTED = 10;
@@ -239,8 +232,7 @@ public final class SetSchemaRequest {
     }
 
     /** Returns the {@link AppSearchSchema} types that are part of this request. */
-    @NonNull
-    public Set<AppSearchSchema> getSchemas() {
+    public @NonNull Set<AppSearchSchema> getSchemas() {
         return Collections.unmodifiableSet(mSchemas);
     }
 
@@ -248,8 +240,7 @@ public final class SetSchemaRequest {
      * Returns all the schema types that are opted out of being displayed and visible on any system
      * UI surface.
      */
-    @NonNull
-    public Set<String> getSchemasNotDisplayedBySystem() {
+    public @NonNull Set<String> getSchemasNotDisplayedBySystem() {
         return Collections.unmodifiableSet(mSchemasNotDisplayedBySystem);
     }
 
@@ -259,8 +250,7 @@ public final class SetSchemaRequest {
      *
      * <p>Its inefficient to call this method repeatedly.
      */
-    @NonNull
-    public Map<String, Set<PackageIdentifier>> getSchemasVisibleToPackages() {
+    public @NonNull Map<String, Set<PackageIdentifier>> getSchemasVisibleToPackages() {
         Map<String, Set<PackageIdentifier>> copy = new ArrayMap<>();
         for (Map.Entry<String, Set<PackageIdentifier>> entry :
                 mSchemasVisibleToPackages.entrySet()) {
@@ -298,8 +288,10 @@ public final class SetSchemaRequest {
      *     SetSchemaRequest#READ_ASSISTANT_APP_SEARCH_DATA}.
      */
     // TODO(b/237388235): add enterprise permissions to javadocs after they're unhidden
-    @NonNull
-    public Map<String, Set<Set<Integer>>> getRequiredPermissionsForSchemaTypeVisibility() {
+    // Annotation is here to suppress lint error. Lint error is erroneous since the method does not
+    // require the caller to hold any permission for the method to function.
+    @SuppressLint("RequiresPermission")
+    public @NonNull Map<String, Set<Set<Integer>>> getRequiredPermissionsForSchemaTypeVisibility() {
         return deepCopy(mSchemasVisibleToPermissions);
     }
 
@@ -308,8 +300,7 @@ public final class SetSchemaRequest {
      * package the schemas are from.
      */
     @FlaggedApi(Flags.FLAG_ENABLE_SET_PUBLICLY_VISIBLE_SCHEMA)
-    @NonNull
-    public Map<String, PackageIdentifier> getPubliclyVisibleSchemas() {
+    public @NonNull Map<String, PackageIdentifier> getPubliclyVisibleSchemas() {
         return Collections.unmodifiableMap(mPubliclyVisibleSchemas);
     }
 
@@ -322,8 +313,7 @@ public final class SetSchemaRequest {
      * @see SetSchemaRequest.Builder#addSchemaTypeVisibleToConfig
      */
     @FlaggedApi(Flags.FLAG_ENABLE_SET_SCHEMA_VISIBLE_TO_CONFIGS)
-    @NonNull
-    public Map<String, Set<SchemaVisibilityConfig>> getSchemasVisibleToConfigs() {
+    public @NonNull Map<String, Set<SchemaVisibilityConfig>> getSchemasVisibleToConfigs() {
         Map<String, Set<SchemaVisibilityConfig>> copy = new ArrayMap<>();
         for (Map.Entry<String, Set<SchemaVisibilityConfig>> entry :
                 mSchemasVisibleToConfigs.entrySet()) {
@@ -336,8 +326,7 @@ public final class SetSchemaRequest {
      * Returns the map of {@link Migrator}, the key will be the schema type of the {@link Migrator}
      * associated with.
      */
-    @NonNull
-    public Map<String, Migrator> getMigrators() {
+    public @NonNull Map<String, Migrator> getMigrators() {
         return Collections.unmodifiableMap(mMigrators);
     }
 
@@ -350,8 +339,7 @@ public final class SetSchemaRequest {
      *
      * @hide
      */
-    @NonNull
-    public Map<String, Set<PackageIdentifier>> getSchemasVisibleToPackagesInternal() {
+    public @NonNull Map<String, Set<PackageIdentifier>> getSchemasVisibleToPackagesInternal() {
         return mSchemasVisibleToPackages;
     }
 
@@ -366,6 +354,40 @@ public final class SetSchemaRequest {
         return mVersion;
     }
 
+    @Override
+    public boolean equals(@Nullable Object other) {
+        if (this == other) {
+            return true;
+        }
+        if (!(other instanceof SetSchemaRequest)) {
+            return false;
+        }
+        SetSchemaRequest otherRequest = (SetSchemaRequest) other;
+        return mSchemas.equals(otherRequest.mSchemas)
+                && mSchemasNotDisplayedBySystem.equals(otherRequest.mSchemasNotDisplayedBySystem)
+                && mSchemasVisibleToPackages.equals(otherRequest.mSchemasVisibleToPackages)
+                && mSchemasVisibleToPermissions.equals(otherRequest.mSchemasVisibleToPermissions)
+                && mPubliclyVisibleSchemas.equals(otherRequest.mPubliclyVisibleSchemas)
+                && mSchemasVisibleToConfigs.equals(otherRequest.mSchemasVisibleToConfigs)
+                && mMigrators.equals(otherRequest.mMigrators)
+                && mForceOverride == otherRequest.mForceOverride
+                && mVersion == otherRequest.mVersion;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(
+                mSchemas,
+                mSchemasNotDisplayedBySystem,
+                mSchemasVisibleToPackages,
+                mSchemasVisibleToPermissions,
+                mPubliclyVisibleSchemas,
+                mSchemasVisibleToConfigs,
+                mMigrators,
+                mForceOverride,
+                mVersion);
+    }
+
     /** Builder for {@link SetSchemaRequest} objects. */
     public static final class Builder {
         private static final int DEFAULT_VERSION = 1;
@@ -413,8 +435,7 @@ public final class SetSchemaRequest {
          * <p>Any documents of these types will be displayed on system UI surfaces by default.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addSchemas(@NonNull AppSearchSchema... schemas) {
+        public @NonNull Builder addSchemas(@NonNull AppSearchSchema... schemas) {
             Objects.requireNonNull(schemas);
             resetIfBuilt();
             return addSchemas(Arrays.asList(schemas));
@@ -426,8 +447,7 @@ public final class SetSchemaRequest {
          * <p>An {@link AppSearchSchema} object represents one type of structured data.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addSchemas(@NonNull Collection<AppSearchSchema> schemas) {
+        public @NonNull Builder addSchemas(@NonNull Collection<AppSearchSchema> schemas) {
             Objects.requireNonNull(schemas);
             resetIfBuilt();
             mSchemas.addAll(schemas);
@@ -437,8 +457,7 @@ public final class SetSchemaRequest {
         /** Clears all {@link AppSearchSchema}s from the list of schemas. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearSchemas() {
+        public @NonNull Builder clearSchemas() {
             resetIfBuilt();
             mSchemas.clear();
             return this;
@@ -461,8 +480,7 @@ public final class SetSchemaRequest {
         // Merged list available from getSchemasNotDisplayedBySystem
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
-        @NonNull
-        public Builder setSchemaTypeDisplayedBySystem(
+        public @NonNull Builder setSchemaTypeDisplayedBySystem(
                 @NonNull String schemaType, boolean displayed) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
@@ -507,10 +525,11 @@ public final class SetSchemaRequest {
          */
         // TODO(b/237388235): add enterprise permissions to javadocs after they're unhidden
         // Merged list available from getRequiredPermissionsForSchemaTypeVisibility
+        // Annotation is here to suppress lint error. Lint error is erroneous since the method does
+        // not require the caller to hold any permission for the method to function.
         @CanIgnoreReturnValue
-        @SuppressLint("MissingGetterMatchingBuilder")
-        @NonNull
-        public Builder addRequiredPermissionsForSchemaTypeVisibility(
+        @SuppressLint({"MissingGetterMatchingBuilder", "RequiresPermission"})
+        public @NonNull Builder addRequiredPermissionsForSchemaTypeVisibility(
                 @NonNull String schemaType,
                 @AppSearchSupportedPermission @NonNull Set<Integer> permissions) {
             Objects.requireNonNull(schemaType);
@@ -531,8 +550,8 @@ public final class SetSchemaRequest {
 
         /** Clears all required permissions combinations for the given schema type. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearRequiredPermissionsForSchemaTypeVisibility(@NonNull String schemaType) {
+        public @NonNull Builder clearRequiredPermissionsForSchemaTypeVisibility(
+                @NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
             mSchemasVisibleToPermissions.remove(schemaType);
@@ -568,8 +587,7 @@ public final class SetSchemaRequest {
         // Merged list available from getSchemasVisibleToPackages
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
-        @NonNull
-        public Builder setSchemaTypeVisibilityForPackage(
+        public @NonNull Builder setSchemaTypeVisibilityForPackage(
                 @NonNull String schemaType,
                 boolean visible,
                 @NonNull PackageIdentifier packageIdentifier) {
@@ -625,8 +643,7 @@ public final class SetSchemaRequest {
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
         @FlaggedApi(Flags.FLAG_ENABLE_SET_PUBLICLY_VISIBLE_SCHEMA)
-        @NonNull
-        public Builder setPubliclyVisibleSchema(
+        public @NonNull Builder setPubliclyVisibleSchema(
                 @NonNull String schema, @Nullable PackageIdentifier packageIdentifier) {
             Objects.requireNonNull(schema);
             resetIfBuilt();
@@ -660,8 +677,7 @@ public final class SetSchemaRequest {
         @CanIgnoreReturnValue
         @SuppressLint("MissingGetterMatchingBuilder")
         @FlaggedApi(Flags.FLAG_ENABLE_SET_SCHEMA_VISIBLE_TO_CONFIGS)
-        @NonNull
-        public Builder addSchemaTypeVisibleToConfig(
+        public @NonNull Builder addSchemaTypeVisibleToConfig(
                 @NonNull String schemaType,
                 @NonNull SchemaVisibilityConfig schemaVisibilityConfig) {
             Objects.requireNonNull(schemaType);
@@ -679,8 +695,7 @@ public final class SetSchemaRequest {
         /** Clears all visible to {@link SchemaVisibilityConfig} for the given schema type. */
         @CanIgnoreReturnValue
         @FlaggedApi(Flags.FLAG_ENABLE_SET_SCHEMA_VISIBLE_TO_CONFIGS)
-        @NonNull
-        public Builder clearSchemaTypeVisibleToConfigs(@NonNull String schemaType) {
+        public @NonNull Builder clearSchemaTypeVisibleToConfigs(@NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             resetIfBuilt();
             mSchemaVisibleToConfigs.remove(schemaType);
@@ -710,9 +725,9 @@ public final class SetSchemaRequest {
          * @see AppSearchSession#setSchema
          */
         @CanIgnoreReturnValue
-        @NonNull
         @SuppressLint("MissingGetterMatchingBuilder") // Getter return plural objects.
-        public Builder setMigrator(@NonNull String schemaType, @NonNull Migrator migrator) {
+        public @NonNull Builder setMigrator(
+                @NonNull String schemaType, @NonNull Migrator migrator) {
             Objects.requireNonNull(schemaType);
             Objects.requireNonNull(migrator);
             resetIfBuilt();
@@ -745,8 +760,7 @@ public final class SetSchemaRequest {
          * @see AppSearchSession#setSchema
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setMigrators(@NonNull Map<String, Migrator> migrators) {
+        public @NonNull Builder setMigrators(@NonNull Map<String, Migrator> migrators) {
             Objects.requireNonNull(migrators);
             resetIfBuilt();
             mMigrators.putAll(migrators);
@@ -756,8 +770,7 @@ public final class SetSchemaRequest {
         /** Clears all {@link Migrator}s. */
         @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearMigrators() {
+        public @NonNull Builder clearMigrators() {
             resetIfBuilt();
             mMigrators.clear();
             return this;
@@ -775,8 +788,7 @@ public final class SetSchemaRequest {
          * <p>By default, this is {@code false}.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setForceOverride(boolean forceOverride) {
+        public @NonNull Builder setForceOverride(boolean forceOverride) {
             resetIfBuilt();
             mForceOverride = forceOverride;
             return this;
@@ -809,8 +821,7 @@ public final class SetSchemaRequest {
          * @see SetSchemaRequest.Builder#setMigrator
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setVersion(@IntRange(from = 1) int version) {
+        public @NonNull Builder setVersion(@IntRange(from = 1) int version) {
             Preconditions.checkArgument(version >= 1, "Version must be a positive number.");
             resetIfBuilt();
             mVersion = version;
@@ -823,8 +834,7 @@ public final class SetSchemaRequest {
          * @throws IllegalArgumentException if schema types were referenced, but the corresponding
          *     {@link AppSearchSchema} type was never added.
          */
-        @NonNull
-        public SetSchemaRequest build() {
+        public @NonNull SetSchemaRequest build() {
             // Verify that any schema types with display or visibility settings refer to a real
             // schema.
             // Create a copy because we're going to remove from the set for verification purposes.
diff --git a/framework/java/external/android/app/appsearch/SetSchemaResponse.java b/framework/java/external/android/app/appsearch/SetSchemaResponse.java
index a00b0b50..0df35c67 100644
--- a/framework/java/external/android/app/appsearch/SetSchemaResponse.java
+++ b/framework/java/external/android/app/appsearch/SetSchemaResponse.java
@@ -38,12 +38,12 @@ import java.util.Set;
 
 /** The response class of {@link AppSearchSession#setSchema} */
 @SafeParcelable.Class(creator = "SetSchemaResponseCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class SetSchemaResponse extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<SetSchemaResponse> CREATOR =
+    public static final @NonNull Parcelable.Creator<SetSchemaResponse> CREATOR =
             new SetSchemaResponseCreator();
 
     @Field(id = 1)
@@ -71,19 +71,19 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
     /**
      * Cache of the inflated deleted schema types. Comes from inflating mDeletedTypes at first use
      */
-    @Nullable private Set<String> mDeletedTypesCached;
+    private @Nullable Set<String> mDeletedTypesCached;
 
     /**
      * Cache of the inflated migrated schema types. Comes from inflating mMigratedTypes at first
      * use.
      */
-    @Nullable private Set<String> mMigratedTypesCached;
+    private @Nullable Set<String> mMigratedTypesCached;
 
     /**
      * Cache of the inflated incompatible schema types. Comes from inflating mIncompatibleTypes at
      * first use.
      */
-    @Nullable private Set<String> mIncompatibleTypesCached;
+    private @Nullable Set<String> mIncompatibleTypesCached;
 
     @Constructor
     SetSchemaResponse(
@@ -117,8 +117,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
      * {@link GenericDocument} and the error reason. Mostly it will be mismatch the schema it
      * migrated to.
      */
-    @NonNull
-    public List<MigrationFailure> getMigrationFailures() {
+    public @NonNull List<MigrationFailure> getMigrationFailures() {
         return Collections.unmodifiableList(mMigrationFailures);
     }
 
@@ -131,8 +130,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
      *
      * <p>Documents for a deleted type are removed from the database.
      */
-    @NonNull
-    public Set<String> getDeletedTypes() {
+    public @NonNull Set<String> getDeletedTypes() {
         if (mDeletedTypesCached == null) {
             mDeletedTypesCached = new ArraySet<>(Objects.requireNonNull(mDeletedTypes));
         }
@@ -152,8 +150,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
      *
      * @see Migrator
      */
-    @NonNull
-    public Set<String> getMigratedTypes() {
+    public @NonNull Set<String> getMigratedTypes() {
         if (mMigratedTypesCached == null) {
             mMigratedTypesCached = new ArraySet<>(Objects.requireNonNull(mMigratedTypes));
         }
@@ -171,8 +168,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
      * @see AppSearchSession#setSchema
      * @see SetSchemaRequest.Builder#setForceOverride
      */
-    @NonNull
-    public Set<String> getIncompatibleTypes() {
+    public @NonNull Set<String> getIncompatibleTypes() {
         if (mIncompatibleTypesCached == null) {
             mIncompatibleTypesCached = new ArraySet<>(Objects.requireNonNull(mIncompatibleTypes));
         }
@@ -205,8 +201,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
 
         /** Adds {@link MigrationFailure}s to the list of migration failures. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addMigrationFailures(
+        public @NonNull Builder addMigrationFailures(
                 @NonNull Collection<MigrationFailure> migrationFailures) {
             Objects.requireNonNull(migrationFailures);
             resetIfBuilt();
@@ -216,8 +211,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
 
         /** Adds a {@link MigrationFailure} to the list of migration failures. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addMigrationFailure(@NonNull MigrationFailure migrationFailure) {
+        public @NonNull Builder addMigrationFailure(@NonNull MigrationFailure migrationFailure) {
             Objects.requireNonNull(migrationFailure);
             resetIfBuilt();
             mMigrationFailures.add(migrationFailure);
@@ -226,8 +220,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
 
         /** Adds {@code deletedTypes} to the list of deleted schema types. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addDeletedTypes(@NonNull Collection<String> deletedTypes) {
+        public @NonNull Builder addDeletedTypes(@NonNull Collection<String> deletedTypes) {
             Objects.requireNonNull(deletedTypes);
             resetIfBuilt();
             mDeletedTypes.addAll(deletedTypes);
@@ -236,8 +229,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
 
         /** Adds one {@code deletedType} to the list of deleted schema types. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addDeletedType(@NonNull String deletedType) {
+        public @NonNull Builder addDeletedType(@NonNull String deletedType) {
             Objects.requireNonNull(deletedType);
             resetIfBuilt();
             mDeletedTypes.add(deletedType);
@@ -246,8 +238,8 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
 
         /** Adds {@code incompatibleTypes} to the list of incompatible schema types. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addIncompatibleTypes(@NonNull Collection<String> incompatibleTypes) {
+        public @NonNull Builder addIncompatibleTypes(
+                @NonNull Collection<String> incompatibleTypes) {
             Objects.requireNonNull(incompatibleTypes);
             resetIfBuilt();
             mIncompatibleTypes.addAll(incompatibleTypes);
@@ -256,8 +248,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
 
         /** Adds one {@code incompatibleType} to the list of incompatible schema types. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addIncompatibleType(@NonNull String incompatibleType) {
+        public @NonNull Builder addIncompatibleType(@NonNull String incompatibleType) {
             Objects.requireNonNull(incompatibleType);
             resetIfBuilt();
             mIncompatibleTypes.add(incompatibleType);
@@ -266,8 +257,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
 
         /** Adds {@code migratedTypes} to the list of migrated schema types. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addMigratedTypes(@NonNull Collection<String> migratedTypes) {
+        public @NonNull Builder addMigratedTypes(@NonNull Collection<String> migratedTypes) {
             Objects.requireNonNull(migratedTypes);
             resetIfBuilt();
             mMigratedTypes.addAll(migratedTypes);
@@ -276,8 +266,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
 
         /** Adds one {@code migratedType} to the list of migrated schema types. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addMigratedType(@NonNull String migratedType) {
+        public @NonNull Builder addMigratedType(@NonNull String migratedType) {
             Objects.requireNonNull(migratedType);
             resetIfBuilt();
             mMigratedTypes.add(migratedType);
@@ -285,8 +274,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
         }
 
         /** Builds a {@link SetSchemaResponse} object. */
-        @NonNull
-        public SetSchemaResponse build() {
+        public @NonNull SetSchemaResponse build() {
             mBuilt = true;
             // Avoid converting the potential thousands of MigrationFailures to Pracelable and
             // back just for put in bundle. In platform, we should set MigrationFailures in
@@ -321,8 +309,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
     public static class MigrationFailure extends AbstractSafeParcelable {
 
         @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-        @NonNull
-        public static final Parcelable.Creator<MigrationFailure> CREATOR =
+        public static final @NonNull Parcelable.Creator<MigrationFailure> CREATOR =
                 new MigrationFailureCreator();
 
         @Field(id = 1, getter = "getNamespace")
@@ -335,8 +322,7 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
         private final String mSchemaType;
 
         @Field(id = 4)
-        @Nullable
-        final String mErrorMessage;
+        final @Nullable String mErrorMessage;
 
         @Field(id = 5)
         final int mResultCode;
@@ -381,20 +367,17 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
         }
 
         /** Returns the namespace of the {@link GenericDocument} that failed to be migrated. */
-        @NonNull
-        public String getNamespace() {
+        public @NonNull String getNamespace() {
             return mNamespace;
         }
 
         /** Returns the id of the {@link GenericDocument} that failed to be migrated. */
-        @NonNull
-        public String getDocumentId() {
+        public @NonNull String getDocumentId() {
             return mDocumentId;
         }
 
         /** Returns the schema type of the {@link GenericDocument} that failed to be migrated. */
-        @NonNull
-        public String getSchemaType() {
+        public @NonNull String getSchemaType() {
             return mSchemaType;
         }
 
@@ -402,14 +385,12 @@ public final class SetSchemaResponse extends AbstractSafeParcelable {
          * Returns the {@link AppSearchResult} that indicates why the post-migration {@link
          * GenericDocument} failed to be indexed.
          */
-        @NonNull
-        public AppSearchResult<Void> getAppSearchResult() {
+        public @NonNull AppSearchResult<Void> getAppSearchResult() {
             return AppSearchResult.newFailedResult(mResultCode, mErrorMessage);
         }
 
-        @NonNull
         @Override
-        public String toString() {
+        public @NonNull String toString() {
             return "MigrationFailure { schemaType: "
                     + getSchemaType()
                     + ", namespace: "
diff --git a/framework/java/external/android/app/appsearch/StorageInfo.java b/framework/java/external/android/app/appsearch/StorageInfo.java
index 685171f9..85fdb64d 100644
--- a/framework/java/external/android/app/appsearch/StorageInfo.java
+++ b/framework/java/external/android/app/appsearch/StorageInfo.java
@@ -28,12 +28,12 @@ import com.android.appsearch.flags.Flags;
 
 /** The response class of {@code AppSearchSession#getStorageInfo}. */
 @SafeParcelable.Class(creator = "StorageInfoCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class StorageInfo extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<StorageInfo> CREATOR = new StorageInfoCreator();
+    public static final @NonNull Parcelable.Creator<StorageInfo> CREATOR = new StorageInfoCreator();
 
     @Field(id = 1, getter = "getSizeBytes")
     private long mSizeBytes;
@@ -44,24 +44,24 @@ public final class StorageInfo extends AbstractSafeParcelable {
     @Field(id = 3, getter = "getAliveNamespacesCount")
     private int mAliveNamespacesCount;
 
-    @Field(id = 4, getter = "getBlobSizeBytes")
-    private long mBlobSizeBytes;
+    @Field(id = 4, getter = "getBlobsSizeBytes")
+    private long mBlobsSizeBytes;
 
-    @Field(id = 5, getter = "getBlobCount")
-    private int mBlobCount;
+    @Field(id = 5, getter = "getBlobsCount")
+    private int mBlobsCount;
 
     @Constructor
     StorageInfo(
             @Param(id = 1) long sizeBytes,
             @Param(id = 2) int aliveDocumentsCount,
             @Param(id = 3) int aliveNamespacesCount,
-            @Param(id = 4) long blobSizeBytes,
-            @Param(id = 5) int blobCount) {
+            @Param(id = 4) long blobsSizeBytes,
+            @Param(id = 5) int blobsCount) {
         mSizeBytes = sizeBytes;
         mAliveDocumentsCount = aliveDocumentsCount;
         mAliveNamespacesCount = aliveNamespacesCount;
-        mBlobSizeBytes = blobSizeBytes;
-        mBlobCount = blobCount;
+        mBlobsSizeBytes = blobsSizeBytes;
+        mBlobsCount = blobsCount;
     }
 
     /** Returns the estimated size of the session's database in bytes. */
@@ -98,8 +98,8 @@ public final class StorageInfo extends AbstractSafeParcelable {
      * along with alive blobs.
      */
     @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-    public long getBlobSizeBytes() {
-        return mBlobSizeBytes;
+    public long getBlobsSizeBytes() {
+        return mBlobsSizeBytes;
     }
 
     /**
@@ -110,8 +110,8 @@ public final class StorageInfo extends AbstractSafeParcelable {
      * with alive blobs as well.
      */
     @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-    public int getBlobCount() {
-        return mBlobCount;
+    public int getBlobsCount() {
+        return mBlobsCount;
     }
 
     /** Builder for {@link StorageInfo} objects. */
@@ -119,60 +119,54 @@ public final class StorageInfo extends AbstractSafeParcelable {
         private long mSizeBytes;
         private int mAliveDocumentsCount;
         private int mAliveNamespacesCount;
-        private long mBlobSizeBytes;
-        private int mBlobCount;
+        private long mBlobsSizeBytes;
+        private int mBlobsCount;
 
         /** Sets the size in bytes. */
         @CanIgnoreReturnValue
-        @NonNull
-        public StorageInfo.Builder setSizeBytes(long sizeBytes) {
+        public @NonNull StorageInfo.Builder setSizeBytes(long sizeBytes) {
             mSizeBytes = sizeBytes;
             return this;
         }
 
         /** Sets the number of alive documents. */
         @CanIgnoreReturnValue
-        @NonNull
-        public StorageInfo.Builder setAliveDocumentsCount(int aliveDocumentsCount) {
+        public @NonNull StorageInfo.Builder setAliveDocumentsCount(int aliveDocumentsCount) {
             mAliveDocumentsCount = aliveDocumentsCount;
             return this;
         }
 
         /** Sets the number of alive namespaces. */
         @CanIgnoreReturnValue
-        @NonNull
-        public StorageInfo.Builder setAliveNamespacesCount(int aliveNamespacesCount) {
+        public @NonNull StorageInfo.Builder setAliveNamespacesCount(int aliveNamespacesCount) {
             mAliveNamespacesCount = aliveNamespacesCount;
             return this;
         }
 
         /** Sets the size of stored blobs in bytes. */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-        public StorageInfo.Builder setBlobSizeBytes(long blobSizeBytes) {
-            mBlobSizeBytes = blobSizeBytes;
+        public @NonNull StorageInfo.Builder setBlobsSizeBytes(long blobsSizeBytes) {
+            mBlobsSizeBytes = blobsSizeBytes;
             return this;
         }
 
         /** Sets the number of stored blobs. */
         @CanIgnoreReturnValue
-        @NonNull
         @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
-        public StorageInfo.Builder setBlobCount(int blobCount) {
-            mBlobCount = blobCount;
+        public @NonNull StorageInfo.Builder setBlobsCount(int blobsCount) {
+            mBlobsCount = blobsCount;
             return this;
         }
 
         /** Builds a {@link StorageInfo} object. */
-        @NonNull
-        public StorageInfo build() {
+        public @NonNull StorageInfo build() {
             return new StorageInfo(
                     mSizeBytes,
                     mAliveDocumentsCount,
                     mAliveNamespacesCount,
-                    mBlobSizeBytes,
-                    mBlobCount);
+                    mBlobsSizeBytes,
+                    mBlobsCount);
         }
     }
 
diff --git a/framework/java/external/android/app/appsearch/VisibilityPermissionConfig.java b/framework/java/external/android/app/appsearch/VisibilityPermissionConfig.java
index 0bf81098..9bc7a36b 100644
--- a/framework/java/external/android/app/appsearch/VisibilityPermissionConfig.java
+++ b/framework/java/external/android/app/appsearch/VisibilityPermissionConfig.java
@@ -16,14 +16,15 @@
 
 package android.app.appsearch;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.safeparcel.AbstractSafeParcelable;
 import android.app.appsearch.safeparcel.SafeParcelable;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.util.ArraySet;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Arrays;
 import java.util.Objects;
 import java.util.Set;
@@ -36,8 +37,7 @@ import java.util.Set;
  */
 @SafeParcelable.Class(creator = "VisibilityPermissionConfigCreator")
 public final class VisibilityPermissionConfig extends AbstractSafeParcelable {
-    @NonNull
-    public static final Parcelable.Creator<VisibilityPermissionConfig> CREATOR =
+    public static final Parcelable.@NonNull Creator<VisibilityPermissionConfig> CREATOR =
             new VisibilityPermissionConfigCreator();
 
     /**
@@ -64,21 +64,19 @@ public final class VisibilityPermissionConfig extends AbstractSafeParcelable {
                                     .build())
                     .build();
 
-    @Nullable
     @Field(id = 1)
-    final int[] mAllRequiredPermissions;
+    final int @Nullable [] mAllRequiredPermissions;
 
-    @Nullable
     // We still need to convert this class to a GenericDocument until we completely treat it
     // differently in AppSearchImpl.
     // TODO(b/298118943) Remove this once internally we don't use GenericDocument to store
     //  visibility information.
-    private GenericDocument mGenericDocument;
+    private @Nullable GenericDocument mGenericDocument;
 
-    @Nullable private Integer mHashCode;
+    private @Nullable Integer mHashCode;
 
     @Constructor
-    VisibilityPermissionConfig(@Param(id = 1) @Nullable int[] allRequiredPermissions) {
+    VisibilityPermissionConfig(@Param(id = 1) int @Nullable [] allRequiredPermissions) {
         mAllRequiredPermissions = allRequiredPermissions;
     }
 
@@ -94,13 +92,11 @@ public final class VisibilityPermissionConfig extends AbstractSafeParcelable {
      * Returns an array of Android Permissions that caller mush hold to access the schema that the
      * outer {@link SchemaVisibilityConfig} represents.
      */
-    @Nullable
-    public Set<Integer> getAllRequiredPermissions() {
+    public @Nullable Set<Integer> getAllRequiredPermissions() {
         return toIntegerSet(mAllRequiredPermissions);
     }
 
-    @NonNull
-    private static int[] toInts(@NonNull Set<Integer> properties) {
+    private static int @NonNull [] toInts(@NonNull Set<Integer> properties) {
         int[] outputs = new int[properties.size()];
         int i = 0;
         for (int property : properties) {
@@ -109,8 +105,7 @@ public final class VisibilityPermissionConfig extends AbstractSafeParcelable {
         return outputs;
     }
 
-    @Nullable
-    private static Set<Integer> toIntegerSet(@Nullable int[] properties) {
+    private static @Nullable Set<Integer> toIntegerSet(int @Nullable [] properties) {
         if (properties == null) {
             return null;
         }
@@ -127,8 +122,7 @@ public final class VisibilityPermissionConfig extends AbstractSafeParcelable {
      * <p>This conversion is needed until we don't treat Visibility related documents as {@link
      * GenericDocument}s internally.
      */
-    @NonNull
-    public GenericDocument toGenericDocument() {
+    public @NonNull GenericDocument toGenericDocument() {
         if (mGenericDocument == null) {
             // This is used as a nested document, we do not need a namespace or id.
             GenericDocument.Builder<?> builder =
diff --git a/framework/java/external/android/app/appsearch/ast/FunctionNode.java b/framework/java/external/android/app/appsearch/ast/FunctionNode.java
index 83d4c9aa..aabbdb1b 100644
--- a/framework/java/external/android/app/appsearch/ast/FunctionNode.java
+++ b/framework/java/external/android/app/appsearch/ast/FunctionNode.java
@@ -17,11 +17,12 @@
 package android.app.appsearch.ast;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 import android.annotation.StringDef;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -80,7 +81,6 @@ public interface FunctionNode extends Node {
     String FUNCTION_NAME_SEMANTIC_SEARCH = "semanticSearch";
 
     /** Gets the name of the node that extends the {@link FunctionNode}. */
-    @NonNull
     @FunctionName
-    String getFunctionName();
+    @NonNull String getFunctionName();
 }
diff --git a/framework/java/external/android/app/appsearch/ast/NegationNode.java b/framework/java/external/android/app/appsearch/ast/NegationNode.java
index 44278d1a..20e49077 100644
--- a/framework/java/external/android/app/appsearch/ast/NegationNode.java
+++ b/framework/java/external/android/app/appsearch/ast/NegationNode.java
@@ -17,10 +17,11 @@
 package android.app.appsearch.ast;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -73,8 +74,7 @@ public final class NegationNode implements Node {
      *     logically negated that could be cast to a type that implements {@link Node}
      */
     @Override
-    @NonNull
-    public List<Node> getChildren() {
+    public @NonNull List<Node> getChildren() {
         return Collections.unmodifiableList(mChildren);
     }
 
@@ -88,8 +88,7 @@ public final class NegationNode implements Node {
      * @return The child {@link Node} representing a query that is being logically negated that
      *     could be cast to a type that implements {@link Node}
      */
-    @NonNull
-    public Node getChild() {
+    public @NonNull Node getChild() {
         return mChildren.get(0);
     }
 
@@ -111,9 +110,8 @@ public final class NegationNode implements Node {
      * <p>The string representation of {@link NegationNode} is "NOT" prepended to the string
      * representation of the child {@link Node}.
      */
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         return "NOT " + getChild();
     }
 
diff --git a/framework/java/external/android/app/appsearch/ast/Node.java b/framework/java/external/android/app/appsearch/ast/Node.java
index 488c43aa..d3698f83 100644
--- a/framework/java/external/android/app/appsearch/ast/Node.java
+++ b/framework/java/external/android/app/appsearch/ast/Node.java
@@ -17,10 +17,11 @@
 package android.app.appsearch.ast;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Collections;
 import java.util.List;
 
@@ -44,8 +45,7 @@ public interface Node {
      *
      * @return An empty list of {@link Node} representing the child nodes.
      */
-    @NonNull
-    default List<Node> getChildren() {
+    default @NonNull List<Node> getChildren() {
         return Collections.emptyList();
     }
 }
diff --git a/framework/java/external/android/app/appsearch/ast/TextNode.java b/framework/java/external/android/app/appsearch/ast/TextNode.java
index badfe4ba..e0af0b91 100644
--- a/framework/java/external/android/app/appsearch/ast/TextNode.java
+++ b/framework/java/external/android/app/appsearch/ast/TextNode.java
@@ -17,10 +17,11 @@
 package android.app.appsearch.ast;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Objects;
 
 /**
@@ -85,8 +86,7 @@ public final class TextNode implements Node {
      *
      * @return A string representing the text that the TextNode holds.
      */
-    @NonNull
-    public String getValue() {
+    public @NonNull String getValue() {
         return mValue;
     }
 
@@ -177,9 +177,8 @@ public final class TextNode implements Node {
      * contains operators that need to be escaped for the query string to be treated as a string
      * rather than a query.
      */
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         StringBuilder queryStringBuilder = new StringBuilder();
         queryStringBuilder.append('(');
         if (mVerbatim) {
diff --git a/framework/java/external/android/app/appsearch/ast/operators/AndNode.java b/framework/java/external/android/app/appsearch/ast/operators/AndNode.java
index 62abf5aa..abed5c26 100644
--- a/framework/java/external/android/app/appsearch/ast/operators/AndNode.java
+++ b/framework/java/external/android/app/appsearch/ast/operators/AndNode.java
@@ -31,6 +31,8 @@ import java.util.Objects;
 
 /** {@link Node} that represents logical AND of nodes. */
 @FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings("JSpecifyNullness")
 public final class AndNode implements Node {
     private List<Node> mChildren;
 
@@ -69,8 +71,7 @@ public final class AndNode implements Node {
 
     /** Get the list of nodes being logically ANDed over by this node. */
     @Override
-    @NonNull
-    public List<Node> getChildren() {
+    public @NonNull List<Node> getChildren() {
         return Collections.unmodifiableList(mChildren);
     }
 
@@ -140,9 +141,8 @@ public final class AndNode implements Node {
      * <p>The string representation of {@link AndNode} is the string representation of {@link
      * AndNode}'s child nodes joined with "AND", all surrounded by parentheses.
      */
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         return "(" + TextUtils.join(" AND ", mChildren) + ")";
     }
 
diff --git a/framework/java/external/android/app/appsearch/ast/operators/ComparatorNode.java b/framework/java/external/android/app/appsearch/ast/operators/ComparatorNode.java
index e86cb6be..e1face2c 100644
--- a/framework/java/external/android/app/appsearch/ast/operators/ComparatorNode.java
+++ b/framework/java/external/android/app/appsearch/ast/operators/ComparatorNode.java
@@ -18,13 +18,14 @@ package android.app.appsearch.ast.operators;
 
 import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
-import android.annotation.NonNull;
 import android.app.appsearch.PropertyPath;
 import android.app.appsearch.ast.Node;
 
 import com.android.appsearch.flags.Flags;
 import com.android.internal.util.Preconditions;
 
+import org.jspecify.annotations.NonNull;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Objects;
@@ -101,8 +102,7 @@ public final class ComparatorNode implements Node {
      *
      * <p>I.e. left hand side of the comparison represented by this node.
      */
-    @NonNull
-    public PropertyPath getPropertyPath() {
+    public @NonNull PropertyPath getPropertyPath() {
         return mPropertyPath;
     }
 
@@ -139,9 +139,8 @@ public final class ComparatorNode implements Node {
      * the left to the value being compared with the string representation of the {@link
      * Comparator}.
      */
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         String comparatorString = "";
         switch (mComparator) {
             case ComparatorNode.EQUALS:
diff --git a/framework/java/external/android/app/appsearch/ast/operators/OrNode.java b/framework/java/external/android/app/appsearch/ast/operators/OrNode.java
index d823d853..4e245551 100644
--- a/framework/java/external/android/app/appsearch/ast/operators/OrNode.java
+++ b/framework/java/external/android/app/appsearch/ast/operators/OrNode.java
@@ -31,6 +31,8 @@ import java.util.Objects;
 
 /** {@link Node} that represents logical OR of nodes. */
 @FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings("JSpecifyNullness")
 public final class OrNode implements Node {
     private List<Node> mChildren;
 
@@ -68,8 +70,7 @@ public final class OrNode implements Node {
 
     /** Get the list of nodes being logically ORed over by this node. */
     @Override
-    @NonNull
-    public List<Node> getChildren() {
+    public @NonNull List<Node> getChildren() {
         return Collections.unmodifiableList(mChildren);
     }
 
@@ -139,9 +140,8 @@ public final class OrNode implements Node {
      * <p>The string representation of {@link OrNode} is the string representation of {@link
      * OrNode}'s child nodes joined with "OR", all surrounded by parentheses.
      */
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         return "(" + TextUtils.join(" OR ", mChildren) + ")";
     }
 
diff --git a/framework/java/external/android/app/appsearch/ast/operators/PropertyRestrictNode.java b/framework/java/external/android/app/appsearch/ast/operators/PropertyRestrictNode.java
index 4924ab04..e30d5ad6 100644
--- a/framework/java/external/android/app/appsearch/ast/operators/PropertyRestrictNode.java
+++ b/framework/java/external/android/app/appsearch/ast/operators/PropertyRestrictNode.java
@@ -17,12 +17,13 @@
 package android.app.appsearch.ast.operators;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 import android.app.appsearch.PropertyPath;
 import android.app.appsearch.ast.Node;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -42,7 +43,7 @@ import java.util.Objects;
  */
 @FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
 public final class PropertyRestrictNode implements Node {
-    private PropertyPath mProperty;
+    private PropertyPath mPropertyPath;
     private final List<Node> mChildren = new ArrayList<>(1);
 
     /**
@@ -54,26 +55,24 @@ public final class PropertyRestrictNode implements Node {
      * @param childNode The subexpression to be restricted in the property restrict
      */
     public PropertyRestrictNode(@NonNull PropertyPath propertyPath, @NonNull Node childNode) {
-        mProperty = Objects.requireNonNull(propertyPath);
+        mPropertyPath = Objects.requireNonNull(propertyPath);
         mChildren.add(Objects.requireNonNull(childNode));
     }
 
     /**
-     * Get the property in the property restriction (i.e. the left hand side of the property
-     * restrict sign (":")).
+     * Get the {@link PropertyPath} in the property restriction (i.e. the left hand side of the
+     * property restrict sign (":")).
      */
-    @NonNull
-    public PropertyPath getProperty() {
-        return mProperty;
+    public @NonNull PropertyPath getPropertyPath() {
+        return mPropertyPath;
     }
 
     /**
      * Get the child {@link Node} of {@link PropertyRestrictNode} as a list containing the only
      * child {@link Node}.
      */
-    @NonNull
     @Override
-    public List<Node> getChildren() {
+    public @NonNull List<Node> getChildren() {
         return Collections.unmodifiableList(mChildren);
     }
 
@@ -81,17 +80,16 @@ public final class PropertyRestrictNode implements Node {
      * Get the subexpression in the property restriction as a {@link Node} (i.e. the right hand side
      * of the property restrict sign (":")).
      */
-    @NonNull
-    public Node getChild() {
+    public @NonNull Node getChild() {
         return mChildren.get(0);
     }
 
     /**
-     * Set the property in the property restriction (i.e. the left hand side of the property
-     * restrict sign (":")).
+     * Set the {@link PropertyPath} in the property restriction (i.e. the left hand side of the
+     * property restrict sign (":")).
      */
-    public void setProperty(@NonNull PropertyPath propertyPath) {
-        mProperty = Objects.requireNonNull(propertyPath);
+    public void setPropertyPath(@NonNull PropertyPath propertyPath) {
+        mPropertyPath = Objects.requireNonNull(propertyPath);
     }
 
     /**
@@ -109,10 +107,9 @@ public final class PropertyRestrictNode implements Node {
      * the left to the query sub expression surrounded in parentheses with the property restrict
      * symbol (":").
      */
-    @NonNull
     @Override
-    public String toString() {
-        return "(" + mProperty + ":" + getChild() + ")";
+    public @NonNull String toString() {
+        return "(" + mPropertyPath + ":" + getChild() + ")";
     }
 
     @Override
@@ -120,12 +117,12 @@ public final class PropertyRestrictNode implements Node {
         if (this == o) return true;
         if (!(o instanceof PropertyRestrictNode)) return false;
         PropertyRestrictNode that = (PropertyRestrictNode) o;
-        return Objects.equals(mProperty, that.mProperty)
+        return Objects.equals(mPropertyPath, that.mPropertyPath)
                 && Objects.equals(mChildren, that.mChildren);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(mProperty, mChildren);
+        return Objects.hash(mPropertyPath, mChildren);
     }
 }
diff --git a/framework/java/external/android/app/appsearch/ast/query/GetSearchStringParameterNode.java b/framework/java/external/android/app/appsearch/ast/query/GetSearchStringParameterNode.java
index 66d95c13..004b120b 100644
--- a/framework/java/external/android/app/appsearch/ast/query/GetSearchStringParameterNode.java
+++ b/framework/java/external/android/app/appsearch/ast/query/GetSearchStringParameterNode.java
@@ -17,13 +17,14 @@
 package android.app.appsearch.ast.query;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.ast.FunctionNode;
 
 import com.android.appsearch.flags.Flags;
 import com.android.internal.util.Preconditions;
 
+import org.jspecify.annotations.NonNull;
+
 /**
  * {@link FunctionNode} that represents the getSearchStringParameter function.
  *
@@ -64,10 +65,9 @@ public final class GetSearchStringParameterNode implements FunctionNode {
     }
 
     /** Returns the name of the function represented by {@link GetSearchStringParameterNode}. */
-    @NonNull
     @FunctionName
     @Override
-    public String getFunctionName() {
+    public @NonNull String getFunctionName() {
         return FUNCTION_NAME_GET_SEARCH_STRING_PARAMETER;
     }
 
@@ -97,9 +97,8 @@ public final class GetSearchStringParameterNode implements FunctionNode {
      * followed by the {@code searchStringIndex} surrounded by parentheses. For example, the string
      * representation of {@code GetSearchStringParameterNode(1)} is `getSearchStringParameter(1)`.
      */
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         return FunctionNode.FUNCTION_NAME_GET_SEARCH_STRING_PARAMETER
                 + "("
                 + mSearchStringIndex
diff --git a/framework/java/external/android/app/appsearch/ast/query/HasPropertyNode.java b/framework/java/external/android/app/appsearch/ast/query/HasPropertyNode.java
index a58f4278..52bab5a2 100644
--- a/framework/java/external/android/app/appsearch/ast/query/HasPropertyNode.java
+++ b/framework/java/external/android/app/appsearch/ast/query/HasPropertyNode.java
@@ -17,12 +17,13 @@
 package android.app.appsearch.ast.query;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 import android.app.appsearch.PropertyPath;
 import android.app.appsearch.ast.FunctionNode;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Objects;
 
 /**
@@ -33,26 +34,25 @@ import java.util.Objects;
  */
 @FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
 public final class HasPropertyNode implements FunctionNode {
-    private PropertyPath mProperty;
+    private PropertyPath mPropertyPath;
 
     /**
      * Constructor for a {@link HasPropertyNode} representing the query function `hasProperty`.
      *
-     * @param property A {@link PropertyPath} representing the property to check whether or not it
-     *     contains a value in the document.
+     * @param propertyPath A {@link PropertyPath} representing the property to check whether or not
+     *     it contains a value in the document.
      */
-    public HasPropertyNode(@NonNull PropertyPath property) {
-        mProperty = Objects.requireNonNull(property);
+    public HasPropertyNode(@NonNull PropertyPath propertyPath) {
+        mPropertyPath = Objects.requireNonNull(propertyPath);
     }
 
     /**
      * Returns the name of the function represented by {@link HasPropertyNode}, stored in the enum
      * {@link FunctionNode#FUNCTION_NAME_HAS_PROPERTY}.
      */
-    @NonNull
     @Override
     @FunctionName
-    public String getFunctionName() {
+    public @NonNull String getFunctionName() {
         return FunctionNode.FUNCTION_NAME_HAS_PROPERTY;
     }
 
@@ -60,17 +60,16 @@ public final class HasPropertyNode implements FunctionNode {
      * Gets the {@link PropertyPath} representing the property being checked for some value in the
      * document.
      */
-    @NonNull
-    public PropertyPath getProperty() {
-        return mProperty;
+    public @NonNull PropertyPath getPropertyPath() {
+        return mPropertyPath;
     }
 
     /**
      * Sets the {@link PropertyPath} representing the property being checked for some value in the
      * document.
      */
-    public void setProperty(@NonNull PropertyPath property) {
-        mProperty = Objects.requireNonNull(property);
+    public void setPropertyPath(@NonNull PropertyPath property) {
+        mPropertyPath = Objects.requireNonNull(property);
     }
 
     /**
@@ -79,10 +78,9 @@ public final class HasPropertyNode implements FunctionNode {
      * <p>The string representation of {@link HasPropertyNode} is the function name followed by the
      * property path in quotes.
      */
-    @NonNull
     @Override
-    public String toString() {
-        return FunctionNode.FUNCTION_NAME_HAS_PROPERTY + "(\"" + mProperty + "\")";
+    public @NonNull String toString() {
+        return FunctionNode.FUNCTION_NAME_HAS_PROPERTY + "(\"" + mPropertyPath + "\")";
     }
 
     @Override
@@ -90,11 +88,11 @@ public final class HasPropertyNode implements FunctionNode {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         HasPropertyNode that = (HasPropertyNode) o;
-        return Objects.equals(mProperty, that.mProperty);
+        return Objects.equals(mPropertyPath, that.mPropertyPath);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hashCode(mProperty);
+        return Objects.hashCode(mPropertyPath);
     }
 }
diff --git a/framework/java/external/android/app/appsearch/ast/query/PropertyDefinedNode.java b/framework/java/external/android/app/appsearch/ast/query/PropertyDefinedNode.java
index 5550a8a1..2020a5f5 100644
--- a/framework/java/external/android/app/appsearch/ast/query/PropertyDefinedNode.java
+++ b/framework/java/external/android/app/appsearch/ast/query/PropertyDefinedNode.java
@@ -17,12 +17,13 @@
 package android.app.appsearch.ast.query;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 import android.app.appsearch.PropertyPath;
 import android.app.appsearch.ast.FunctionNode;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Objects;
 
 /**
@@ -37,39 +38,36 @@ import java.util.Objects;
  */
 @FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
 public final class PropertyDefinedNode implements FunctionNode {
-    private PropertyPath mProperty;
+    private PropertyPath mPropertyPath;
 
     /**
      * Constructor for a {@link PropertyDefinedNode} representing the query function
      * `propertyDefined` that takes in a {@link PropertyPath}.
      */
-    public PropertyDefinedNode(@NonNull PropertyPath property) {
-        mProperty = Objects.requireNonNull(property);
+    public PropertyDefinedNode(@NonNull PropertyPath propertyPath) {
+        mPropertyPath = Objects.requireNonNull(propertyPath);
     }
 
     /** Returns the name of the function represented by {@link PropertyDefinedNode}. */
-    @NonNull
     @Override
     @FunctionName
-    public String getFunctionName() {
+    public @NonNull String getFunctionName() {
         return FUNCTION_NAME_PROPERTY_DEFINED;
     }
 
     /**
-     * Returns the {@link PropertyDefinedNode} representing the property being checked for in the
-     * document.
+     * Returns the {@link PropertyPath} representing the property being checked for in the document.
      */
-    @NonNull
-    public PropertyPath getProperty() {
-        return mProperty;
+    public @NonNull PropertyPath getPropertyPath() {
+        return mPropertyPath;
     }
 
     /**
      * Sets the property being checked for in the document, as represented by {@link
      * PropertyDefinedNode}.
      */
-    public void setProperty(@NonNull PropertyPath property) {
-        mProperty = Objects.requireNonNull(property);
+    public void setPropertyPath(@NonNull PropertyPath property) {
+        mPropertyPath = Objects.requireNonNull(property);
     }
 
     /**
@@ -78,10 +76,9 @@ public final class PropertyDefinedNode implements FunctionNode {
      * <p>The string representation of {@link PropertyDefinedNode} is the function name followed by
      * the property path in quotes surrounded by parentheses.
      */
-    @NonNull
     @Override
-    public String toString() {
-        return FUNCTION_NAME_PROPERTY_DEFINED + "(\"" + mProperty + "\")";
+    public @NonNull String toString() {
+        return FUNCTION_NAME_PROPERTY_DEFINED + "(\"" + mPropertyPath + "\")";
     }
 
     @Override
@@ -89,11 +86,11 @@ public final class PropertyDefinedNode implements FunctionNode {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         PropertyDefinedNode that = (PropertyDefinedNode) o;
-        return Objects.equals(mProperty, that.mProperty);
+        return Objects.equals(mPropertyPath, that.mPropertyPath);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hashCode(mProperty);
+        return Objects.hashCode(mPropertyPath);
     }
 }
diff --git a/framework/java/external/android/app/appsearch/ast/query/SearchNode.java b/framework/java/external/android/app/appsearch/ast/query/SearchNode.java
index 9b5664eb..2ce49ac3 100644
--- a/framework/java/external/android/app/appsearch/ast/query/SearchNode.java
+++ b/framework/java/external/android/app/appsearch/ast/query/SearchNode.java
@@ -17,13 +17,14 @@
 package android.app.appsearch.ast.query;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 import android.app.appsearch.PropertyPath;
 import android.app.appsearch.ast.FunctionNode;
 import android.app.appsearch.ast.Node;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -40,24 +41,24 @@ import java.util.Objects;
 @FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
 public final class SearchNode implements FunctionNode {
     private final List<Node> mChildren = new ArrayList<>(1);
-    private final List<PropertyPath> mProperties;
+    private final List<PropertyPath> mPropertyPaths;
 
     /**
      * Create a {@link SearchNode} representing the query function `search(queryString,
      * createList(listOfProperties)`.
      *
      * @param childNode The query to search for represented as a {@link Node}.
-     * @param properties A list of property paths to restrict results from the query. If the list is
-     *     empty, all results from the query will be returned.
+     * @param propertyPaths A list of property paths to restrict results from the query. If the list
+     *     is empty, all results from the query will be returned.
      */
-    public SearchNode(@NonNull Node childNode, @NonNull List<PropertyPath> properties) {
+    public SearchNode(@NonNull Node childNode, @NonNull List<PropertyPath> propertyPaths) {
         Objects.requireNonNull(childNode);
-        Objects.requireNonNull(properties);
-        for (int i = 0; i < properties.size(); i++) {
-            Objects.requireNonNull(properties.get(i));
+        Objects.requireNonNull(propertyPaths);
+        for (int i = 0; i < propertyPaths.size(); i++) {
+            Objects.requireNonNull(propertyPaths.get(i));
         }
         mChildren.add(childNode);
-        mProperties = new ArrayList<>(properties);
+        mPropertyPaths = new ArrayList<>(propertyPaths);
     }
 
     /**
@@ -73,10 +74,9 @@ public final class SearchNode implements FunctionNode {
     }
 
     /** Returns the name of the function represented by {@link SearchNode}. */
-    @NonNull
     @Override
     @FunctionName
-    public String getFunctionName() {
+    public @NonNull String getFunctionName() {
         return FUNCTION_NAME_SEARCH;
     }
 
@@ -84,15 +84,13 @@ public final class SearchNode implements FunctionNode {
      * Returns the child {@link Node} of {@link SearchNode} as a list containing the only child
      * {@link Node}.
      */
-    @NonNull
     @Override
-    public List<Node> getChildren() {
+    public @NonNull List<Node> getChildren() {
         return Collections.unmodifiableList(mChildren);
     }
 
     /** Returns the child query searched for in the function. */
-    @NonNull
-    public Node getChild() {
+    public @NonNull Node getChild() {
         return mChildren.get(0);
     }
 
@@ -100,9 +98,8 @@ public final class SearchNode implements FunctionNode {
      * Returns the list of property restricts applied to the query. If the list is empty, there are
      * no property restricts, which means that `search` will return all results from the query.
      */
-    @NonNull
-    public List<PropertyPath> getProperties() {
-        return Collections.unmodifiableList(mProperties);
+    public @NonNull List<PropertyPath> getPropertyPaths() {
+        return Collections.unmodifiableList(mPropertyPaths);
     }
 
     /** Sets the query searched for in the function. */
@@ -111,18 +108,18 @@ public final class SearchNode implements FunctionNode {
     }
 
     /** Sets what property restricts will be applied to the query. */
-    public void setProperties(@NonNull List<PropertyPath> properties) {
+    public void setPropertyPaths(@NonNull List<PropertyPath> properties) {
         Objects.requireNonNull(properties);
         for (int i = 0; i < properties.size(); i++) {
             Objects.requireNonNull(properties.get(i));
         }
-        mProperties.clear();
-        mProperties.addAll(properties);
+        mPropertyPaths.clear();
+        mPropertyPaths.addAll(properties);
     }
 
-    /** Add a restrict to the end of the current list of restricts {@link #mProperties}. */
-    public void addProperty(@NonNull PropertyPath propertyPath) {
-        mProperties.add(Objects.requireNonNull(propertyPath));
+    /** Add a restrict to the end of the current list of restricts {@link #mPropertyPaths}. */
+    public void addPropertyPath(@NonNull PropertyPath propertyPath) {
+        mPropertyPaths.add(Objects.requireNonNull(propertyPath));
     }
 
     /**
@@ -139,7 +136,7 @@ public final class SearchNode implements FunctionNode {
      *
      * will be represented by the query string `search("(foo)")`.
      *
-     * <p>If there are property restricts, i.e. {@link #getProperties()} is not empty, then in
+     * <p>If there are property restricts, i.e. {@link #getPropertyPaths()} is not empty, then in
      * addition to the string representation of the child subquery, the property restricts will be
      * represented as inputs to the {@code createList} function, which itself will be an input. So
      * for the node represented by
@@ -167,22 +164,21 @@ public final class SearchNode implements FunctionNode {
      *
      * the query string of {@code searchNode} will be `search("search(\"(\\\"foo\\\")\")")`
      */
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         StringBuilder builder = new StringBuilder(FunctionNode.FUNCTION_NAME_SEARCH);
         builder.append("(\"");
         builder.append(escapeQuery(getChild().toString()));
         builder.append("\"");
-        if (!mProperties.isEmpty()) {
+        if (!mPropertyPaths.isEmpty()) {
             builder.append(", createList(");
-            for (int i = 0; i < mProperties.size() - 1; i++) {
+            for (int i = 0; i < mPropertyPaths.size() - 1; i++) {
                 builder.append("\"");
-                builder.append(mProperties.get(i));
+                builder.append(mPropertyPaths.get(i));
                 builder.append("\", ");
             }
             builder.append("\"");
-            builder.append(mProperties.get(mProperties.size() - 1));
+            builder.append(mPropertyPaths.get(mPropertyPaths.size() - 1));
             builder.append("\")");
         }
         builder.append(")");
@@ -216,11 +212,11 @@ public final class SearchNode implements FunctionNode {
         if (o == null || getClass() != o.getClass()) return false;
         SearchNode that = (SearchNode) o;
         return Objects.equals(mChildren, that.mChildren)
-                && Objects.equals(mProperties, that.mProperties);
+                && Objects.equals(mPropertyPaths, that.mPropertyPaths);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(mChildren, mProperties);
+        return Objects.hash(mChildren, mPropertyPaths);
     }
 }
diff --git a/framework/java/external/android/app/appsearch/ast/query/SemanticSearchNode.java b/framework/java/external/android/app/appsearch/ast/query/SemanticSearchNode.java
index e5f8275b..72b4f985 100644
--- a/framework/java/external/android/app/appsearch/ast/query/SemanticSearchNode.java
+++ b/framework/java/external/android/app/appsearch/ast/query/SemanticSearchNode.java
@@ -17,13 +17,14 @@
 package android.app.appsearch.ast.query;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.ast.FunctionNode;
 
 import com.android.appsearch.flags.Flags;
 import com.android.internal.util.Preconditions;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Objects;
 
 /**
@@ -32,7 +33,10 @@ import java.util.Objects;
  * <p>The semanticSearch function matches all documents that have at least one embedding vector with
  * a matching model signature (see {@link
  * android.app.appsearch.EmbeddingVector#getModelSignature()}) and a similarity score within the
- * range specified based on the provided metric.
+ * range specified. The similarity score is calculated by determining the distance between the
+ * document embedding vector with a matching model signature and the embedding vector indexed at the
+ * list of vectors returned by {@link SearchSpec#getEmbeddingParameters()}. How this distance is
+ * defined is based on what distance metric set.
  *
  * <p>This node can be used to build a query that contains the semanticSearch function. For example,
  * the node {@code SemanticSearchNode(0, -0.5, 0.5, DOT_PRODUCT)} is equivalent to the query
@@ -142,14 +146,16 @@ public final class SemanticSearchNode implements FunctionNode {
     }
 
     /** Returns the name of the function represented by {@link SemanticSearchNode}. */
-    @NonNull
     @Override
     @FunctionName
-    public String getFunctionName() {
+    public @NonNull String getFunctionName() {
         return FUNCTION_NAME_SEMANTIC_SEARCH;
     }
 
-    /** Returns the index of the embedding vector used in semanticSearch. */
+    /**
+     * Returns the index of the embedding vector to be retrieved from the list of embedding vectors
+     * returned by {@link SearchSpec#getEmbeddingParameters()}.
+     */
     public int getVectorIndex() {
         return mVectorIndex;
     }
@@ -236,9 +242,8 @@ public final class SemanticSearchNode implements FunctionNode {
      * Then the query string will look like `semanticSearch(getEmbeddingParameter(0),
      * -Float.MAX_VALUE, 1)` where {@code Float.MAX_VALUE} is the max value of float.
      */
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         StringBuilder builder = new StringBuilder(FunctionNode.FUNCTION_NAME_SEMANTIC_SEARCH);
         builder.append("(getEmbeddingParameter(");
         builder.append(mVectorIndex);
diff --git a/framework/java/external/android/app/appsearch/checker/nullness/qual/Nullable.java b/framework/java/external/android/app/appsearch/checker/nullness/qual/Nullable.java
deleted file mode 100644
index d832dcca..00000000
--- a/framework/java/external/android/app/appsearch/checker/nullness/qual/Nullable.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app.appsearch.checker.nullness.qual;
-
-// This is an annotation stub to avoid dependencies on annotations that aren't
-// in the Android platform source tree.
-
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/** @hide */
-@Target({
-    ElementType.ANNOTATION_TYPE,
-    ElementType.CONSTRUCTOR,
-    ElementType.FIELD,
-    ElementType.LOCAL_VARIABLE,
-    ElementType.METHOD,
-    ElementType.PACKAGE,
-    ElementType.PARAMETER,
-    ElementType.TYPE,
-    ElementType.TYPE_PARAMETER,
-    ElementType.TYPE_USE
-})
-@Retention(RetentionPolicy.SOURCE)
-public @interface Nullable {
-
-    // These fields maintain API compatibility with annotations that expect arguments.
-
-    String[] value() default {};
-
-    boolean result() default false;
-
-    String[] expression() default "";
-}
diff --git a/framework/java/external/android/app/appsearch/exceptions/AppSearchException.java b/framework/java/external/android/app/appsearch/exceptions/AppSearchException.java
index a7db12cc..d14ac306 100644
--- a/framework/java/external/android/app/appsearch/exceptions/AppSearchException.java
+++ b/framework/java/external/android/app/appsearch/exceptions/AppSearchException.java
@@ -26,6 +26,8 @@ import android.app.appsearch.AppSearchResult;
  * <p>These exceptions can be converted into a failed {@link AppSearchResult} for propagating to the
  * client.
  */
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings("JSpecifyNullness")
 public class AppSearchException extends Exception {
     @AppSearchResult.ResultCode private final int mResultCode;
 
diff --git a/framework/java/external/android/app/appsearch/exceptions/IllegalSchemaException.java b/framework/java/external/android/app/appsearch/exceptions/IllegalSchemaException.java
index 5f8da7fe..72220ece 100644
--- a/framework/java/external/android/app/appsearch/exceptions/IllegalSchemaException.java
+++ b/framework/java/external/android/app/appsearch/exceptions/IllegalSchemaException.java
@@ -16,7 +16,8 @@
 
 package android.app.appsearch.exceptions;
 
-import android.annotation.NonNull;
+
+import org.jspecify.annotations.NonNull;
 
 /**
  * Indicates that a {@link android.app.appsearch.AppSearchSchema} has logical inconsistencies such
diff --git a/framework/java/external/android/app/appsearch/observer/DocumentChangeInfo.java b/framework/java/external/android/app/appsearch/observer/DocumentChangeInfo.java
index 39fdd5b2..bb5683c7 100644
--- a/framework/java/external/android/app/appsearch/observer/DocumentChangeInfo.java
+++ b/framework/java/external/android/app/appsearch/observer/DocumentChangeInfo.java
@@ -16,8 +16,8 @@
 
 package android.app.appsearch.observer;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
 
 import java.util.Collections;
 import java.util.Objects;
@@ -71,26 +71,22 @@ public final class DocumentChangeInfo {
     }
 
     /** Returns the package name of the app which owns the documents that changed. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
     /** Returns the database in which the documents that was changed reside. */
-    @NonNull
-    public String getDatabaseName() {
+    public @NonNull String getDatabaseName() {
         return mDatabase;
     }
 
     /** Returns the namespace of the documents that changed. */
-    @NonNull
-    public String getNamespace() {
+    public @NonNull String getNamespace() {
         return mNamespace;
     }
 
     /** Returns the name of the schema type that contains the changed documents. */
-    @NonNull
-    public String getSchemaName() {
+    public @NonNull String getSchemaName() {
         return mSchemaName;
     }
 
@@ -99,8 +95,7 @@ public final class DocumentChangeInfo {
      *
      * <p>This will never be empty.
      */
-    @NonNull
-    public Set<String> getChangedDocumentIds() {
+    public @NonNull Set<String> getChangedDocumentIds() {
         return mChangedDocumentIds;
     }
 
@@ -127,9 +122,8 @@ public final class DocumentChangeInfo {
         return Objects.hash(mPackageName, mDatabase, mNamespace, mSchemaName, mChangedDocumentIds);
     }
 
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         return "DocumentChangeInfo{"
                 + "packageName='"
                 + mPackageName
diff --git a/framework/java/external/android/app/appsearch/observer/ObserverCallback.java b/framework/java/external/android/app/appsearch/observer/ObserverCallback.java
index 224e36bd..b0985673 100644
--- a/framework/java/external/android/app/appsearch/observer/ObserverCallback.java
+++ b/framework/java/external/android/app/appsearch/observer/ObserverCallback.java
@@ -16,7 +16,7 @@
 
 package android.app.appsearch.observer;
 
-import android.annotation.NonNull;
+import org.jspecify.annotations.NonNull;
 
 /**
  * An interface which apps can implement to subscribe to notifications of changes to AppSearch data.
diff --git a/framework/java/external/android/app/appsearch/observer/ObserverSpec.java b/framework/java/external/android/app/appsearch/observer/ObserverSpec.java
index e81beb88..6dbb7946 100644
--- a/framework/java/external/android/app/appsearch/observer/ObserverSpec.java
+++ b/framework/java/external/android/app/appsearch/observer/ObserverSpec.java
@@ -41,18 +41,19 @@ import java.util.Set;
  * match against.
  */
 @SafeParcelable.Class(creator = "ObserverSpecCreator")
-@SuppressWarnings("HiddenSuperclass")
+// TODO(b/384721898): Switch to JSpecify annotations
+@SuppressWarnings({"HiddenSuperclass", "JSpecifyNullness"})
 public final class ObserverSpec extends AbstractSafeParcelable {
 
     @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
-    @NonNull
-    public static final Parcelable.Creator<ObserverSpec> CREATOR = new ObserverSpecCreator();
+    public static final @NonNull Parcelable.Creator<ObserverSpec> CREATOR =
+            new ObserverSpecCreator();
 
     @Field(id = 1)
     final List<String> mFilterSchemas;
 
     /** Populated on first use */
-    @Nullable private volatile Set<String> mFilterSchemasCached;
+    private volatile @Nullable Set<String> mFilterSchemasCached;
 
     /** @hide */
     @Constructor
@@ -65,8 +66,7 @@ public final class ObserverSpec extends AbstractSafeParcelable {
      *
      * <p>If empty, the observers will trigger on all schema types.
      */
-    @NonNull
-    public Set<String> getFilterSchemas() {
+    public @NonNull Set<String> getFilterSchemas() {
         if (mFilterSchemasCached == null) {
             if (mFilterSchemas == null) {
                 mFilterSchemasCached = Collections.emptySet();
@@ -89,8 +89,7 @@ public final class ObserverSpec extends AbstractSafeParcelable {
          * <p>If unset, the observer will match documents of all types.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterSchemas(@NonNull String... schemas) {
+        public @NonNull Builder addFilterSchemas(@NonNull String... schemas) {
             Objects.requireNonNull(schemas);
             resetIfBuilt();
             return addFilterSchemas(Arrays.asList(schemas));
@@ -103,8 +102,7 @@ public final class ObserverSpec extends AbstractSafeParcelable {
          * <p>If unset, the observer will match documents of all types.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addFilterSchemas(@NonNull Collection<String> schemas) {
+        public @NonNull Builder addFilterSchemas(@NonNull Collection<String> schemas) {
             Objects.requireNonNull(schemas);
             resetIfBuilt();
             mFilterSchemas.addAll(schemas);
@@ -112,8 +110,7 @@ public final class ObserverSpec extends AbstractSafeParcelable {
         }
 
         /** Constructs a new {@link ObserverSpec} from the contents of this builder. */
-        @NonNull
-        public ObserverSpec build() {
+        public @NonNull ObserverSpec build() {
             mBuilt = true;
             return new ObserverSpec(mFilterSchemas);
         }
diff --git a/framework/java/external/android/app/appsearch/observer/SchemaChangeInfo.java b/framework/java/external/android/app/appsearch/observer/SchemaChangeInfo.java
index 40f82e07..dee5f865 100644
--- a/framework/java/external/android/app/appsearch/observer/SchemaChangeInfo.java
+++ b/framework/java/external/android/app/appsearch/observer/SchemaChangeInfo.java
@@ -16,8 +16,8 @@
 
 package android.app.appsearch.observer;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
 
 import java.util.Collections;
 import java.util.Objects;
@@ -58,14 +58,12 @@ public final class SchemaChangeInfo {
     }
 
     /** Returns the package name of the app which owns the schema that changed. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
     /** Returns the database in which the schema that was changed resides. */
-    @NonNull
-    public String getDatabaseName() {
+    public @NonNull String getDatabaseName() {
         return mDatabaseName;
     }
 
@@ -74,8 +72,7 @@ public final class SchemaChangeInfo {
      *
      * <p>This will never be empty.
      */
-    @NonNull
-    public Set<String> getChangedSchemaNames() {
+    public @NonNull Set<String> getChangedSchemaNames() {
         return mChangedSchemaNames;
     }
 
@@ -100,9 +97,8 @@ public final class SchemaChangeInfo {
         return Objects.hash(mPackageName, mDatabaseName, mChangedSchemaNames);
     }
 
-    @NonNull
     @Override
-    public String toString() {
+    public @NonNull String toString() {
         return "SchemaChangeInfo{"
                 + "packageName='"
                 + mPackageName
diff --git a/framework/java/external/android/app/appsearch/safeparcel/GenericDocumentParcel.java b/framework/java/external/android/app/appsearch/safeparcel/GenericDocumentParcel.java
index 8656e9e5..1cf292bd 100644
--- a/framework/java/external/android/app/appsearch/safeparcel/GenericDocumentParcel.java
+++ b/framework/java/external/android/app/appsearch/safeparcel/GenericDocumentParcel.java
@@ -17,8 +17,6 @@
 package android.app.appsearch.safeparcel;
 
 import android.annotation.CurrentTimeMillisLong;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchSchema;
@@ -30,6 +28,9 @@ import android.os.Parcel;
 import android.os.Parcelable;
 import android.util.ArrayMap;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -45,8 +46,7 @@ import java.util.Set;
 // This won't be used to send data over binder, and we have to use Parcelable for code sync purpose.
 @SuppressLint("BanParcelableUsage")
 public final class GenericDocumentParcel extends AbstractSafeParcelable implements Parcelable {
-    @NonNull
-    public static final Parcelable.Creator<GenericDocumentParcel> CREATOR =
+    public static final Parcelable.@NonNull Creator<GenericDocumentParcel> CREATOR =
             new GenericDocumentParcelCreator();
 
     /** The default score of document. */
@@ -59,16 +59,13 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
     private static final long INVALID_CREATION_TIMESTAMP_MILLIS = -1L;
 
     @Field(id = 1, getter = "getNamespace")
-    @NonNull
-    private final String mNamespace;
+    private final @NonNull String mNamespace;
 
     @Field(id = 2, getter = "getId")
-    @NonNull
-    private final String mId;
+    private final @NonNull String mId;
 
     @Field(id = 3, getter = "getSchemaType")
-    @NonNull
-    private final String mSchemaType;
+    private final @NonNull String mSchemaType;
 
     @Field(id = 4, getter = "getCreationTimestampMillis")
     private final long mCreationTimestampMillis;
@@ -85,22 +82,20 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
      * <p>Unfortunately SafeParcelable doesn't support map type so we have to use a list here.
      */
     @Field(id = 7, getter = "getProperties")
-    @NonNull
-    private final List<PropertyParcel> mProperties;
+    private final @NonNull List<PropertyParcel> mProperties;
 
     /** Contains all parent properties for this {@link GenericDocument} in a list. */
     @Field(id = 8, getter = "getParentTypes")
-    @Nullable
-    private final List<String> mParentTypes;
+    private final @Nullable List<String> mParentTypes;
 
     /**
      * Contains all properties in {@link GenericDocument} to support getting properties via name
      *
      * <p>This map is created for quick looking up property by name.
      */
-    @NonNull private final Map<String, PropertyParcel> mPropertyMap;
+    private final @NonNull Map<String, PropertyParcel> mPropertyMap;
 
-    @Nullable private Integer mHashCode;
+    private @Nullable Integer mHashCode;
 
     /**
      * The constructor taking the property list, and create map internally from this list.
@@ -158,8 +153,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
     }
 
     /** Returns the {@link GenericDocumentParcel} object from the given {@link GenericDocument}. */
-    @NonNull
-    public static GenericDocumentParcel fromGenericDocument(
+    public static @NonNull GenericDocumentParcel fromGenericDocument(
             @NonNull GenericDocument genericDocument) {
         Objects.requireNonNull(genericDocument);
         return genericDocument.getDocumentParcel();
@@ -177,20 +171,17 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
     }
 
     /** Returns the unique identifier of the {@link GenericDocument}. */
-    @NonNull
-    public String getId() {
+    public @NonNull String getId() {
         return mId;
     }
 
     /** Returns the namespace of the {@link GenericDocument}. */
-    @NonNull
-    public String getNamespace() {
+    public @NonNull String getNamespace() {
         return mNamespace;
     }
 
     /** Returns the {@link AppSearchSchema} type of the {@link GenericDocument}. */
-    @NonNull
-    public String getSchemaType() {
+    public @NonNull String getSchemaType() {
         return mSchemaType;
     }
 
@@ -211,26 +202,22 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
     }
 
     /** Returns the names of all properties defined in this document. */
-    @NonNull
-    public Set<String> getPropertyNames() {
+    public @NonNull Set<String> getPropertyNames() {
         return mPropertyMap.keySet();
     }
 
     /** Returns all the properties the document has. */
-    @NonNull
-    public List<PropertyParcel> getProperties() {
+    public @NonNull List<PropertyParcel> getProperties() {
         return mProperties;
     }
 
     /** Returns the property map the document has. */
-    @NonNull
-    public Map<String, PropertyParcel> getPropertyMap() {
+    public @NonNull Map<String, PropertyParcel> getPropertyMap() {
         return mPropertyMap;
     }
 
     /** Returns the list of parent types for the {@link GenericDocument}. */
-    @Nullable
-    public List<String> getParentTypes() {
+    public @Nullable List<String> getParentTypes() {
         return mParentTypes;
     }
 
@@ -286,7 +273,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
         private long mTtlMillis;
         private int mScore;
         private Map<String, PropertyParcel> mPropertyMap;
-        @Nullable private List<String> mParentTypes;
+        private @Nullable List<String> mParentTypes;
 
         /**
          * Creates a new {@link GenericDocumentParcel.Builder}.
@@ -340,8 +327,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
          * <p>The number of namespaces per app should be kept small for efficiency reasons.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNamespace(@NonNull String namespace) {
+        public @NonNull Builder setNamespace(@NonNull String namespace) {
             Objects.requireNonNull(namespace);
             mNamespace = namespace;
             return this;
@@ -354,8 +340,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
          * <p>Document IDs are unique within a namespace.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setId(@NonNull String id) {
+        public @NonNull Builder setId(@NonNull String id) {
             Objects.requireNonNull(id);
             mId = id;
             return this;
@@ -368,8 +353,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
          * AppSearchSchema} object previously provided to {@link AppSearchSession#setSchema}.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setSchemaType(@NonNull String schemaType) {
+        public @NonNull Builder setSchemaType(@NonNull String schemaType) {
             Objects.requireNonNull(schemaType);
             mSchemaType = schemaType;
             return this;
@@ -377,8 +361,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
 
         /** Sets the score of the parent {@link GenericDocument}. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setScore(int score) {
+        public @NonNull Builder setScore(int score) {
             mScore = score;
             return this;
         }
@@ -394,8 +377,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
          * @param creationTimestampMillis a creation timestamp in milliseconds.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setCreationTimestampMillis(
+        public @NonNull Builder setCreationTimestampMillis(
                 @CurrentTimeMillisLong long creationTimestampMillis) {
             mCreationTimestampMillis = creationTimestampMillis;
             return this;
@@ -415,8 +397,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
          * @throws IllegalArgumentException if ttlMillis is negative.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTtlMillis(long ttlMillis) {
+        public @NonNull Builder setTtlMillis(long ttlMillis) {
             if (ttlMillis < 0) {
                 throw new IllegalArgumentException("Document ttlMillis cannot be negative.");
             }
@@ -430,8 +411,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
          * <p>Child types must appear before parent types in the list.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setParentTypes(@Nullable List<String> parentTypes) {
+        public @NonNull Builder setParentTypes(@Nullable List<String> parentTypes) {
             if (parentTypes == null) {
                 mParentTypes = null;
             } else {
@@ -448,8 +428,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
          * @param name The name of the property to clear.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder clearProperty(@NonNull String name) {
+        public @NonNull Builder clearProperty(@NonNull String name) {
             Objects.requireNonNull(name);
             mPropertyMap.remove(name);
             return this;
@@ -457,8 +436,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
 
         /** Puts an array of {@link String} in the property map. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder putInPropertyMap(@NonNull String name, @NonNull String[] values)
+        public @NonNull Builder putInPropertyMap(@NonNull String name, String @NonNull [] values)
                 throws IllegalArgumentException {
             putInPropertyMap(
                     name, new PropertyParcel.Builder(name).setStringValues(values).build());
@@ -467,8 +445,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
 
         /** Puts an array of boolean in the property map. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder putInPropertyMap(@NonNull String name, @NonNull boolean[] values) {
+        public @NonNull Builder putInPropertyMap(@NonNull String name, boolean @NonNull [] values) {
             putInPropertyMap(
                     name, new PropertyParcel.Builder(name).setBooleanValues(values).build());
             return this;
@@ -476,8 +453,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
 
         /** Puts an array of double in the property map. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder putInPropertyMap(@NonNull String name, @NonNull double[] values) {
+        public @NonNull Builder putInPropertyMap(@NonNull String name, double @NonNull [] values) {
             putInPropertyMap(
                     name, new PropertyParcel.Builder(name).setDoubleValues(values).build());
             return this;
@@ -485,25 +461,22 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
 
         /** Puts an array of long in the property map. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder putInPropertyMap(@NonNull String name, @NonNull long[] values) {
+        public @NonNull Builder putInPropertyMap(@NonNull String name, long @NonNull [] values) {
             putInPropertyMap(name, new PropertyParcel.Builder(name).setLongValues(values).build());
             return this;
         }
 
         /** Converts and saves a byte[][] into {@link #mProperties}. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder putInPropertyMap(@NonNull String name, @NonNull byte[][] values) {
+        public @NonNull Builder putInPropertyMap(@NonNull String name, byte @NonNull [][] values) {
             putInPropertyMap(name, new PropertyParcel.Builder(name).setBytesValues(values).build());
             return this;
         }
 
         /** Puts an array of {@link GenericDocumentParcel} in the property map. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder putInPropertyMap(
-                @NonNull String name, @NonNull GenericDocumentParcel[] values) {
+        public @NonNull Builder putInPropertyMap(
+                @NonNull String name, GenericDocumentParcel @NonNull [] values) {
             putInPropertyMap(
                     name, new PropertyParcel.Builder(name).setDocumentValues(values).build());
             return this;
@@ -511,8 +484,8 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
 
         /** Puts an array of {@link EmbeddingVector} in the property map. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder putInPropertyMap(@NonNull String name, @NonNull EmbeddingVector[] values) {
+        public @NonNull Builder putInPropertyMap(
+                @NonNull String name, EmbeddingVector @NonNull [] values) {
             putInPropertyMap(
                     name, new PropertyParcel.Builder(name).setEmbeddingValues(values).build());
             return this;
@@ -520,9 +493,8 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
 
         /** Puts an array of {@link AppSearchBlobHandle} in the property map. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder putInPropertyMap(
-                @NonNull String name, @NonNull AppSearchBlobHandle[] values) {
+        public @NonNull Builder putInPropertyMap(
+                @NonNull String name, AppSearchBlobHandle @NonNull [] values) {
             Objects.requireNonNull(values);
             putInPropertyMap(
                     name, new PropertyParcel.Builder(name).setBlobHandleValues(values).build());
@@ -531,16 +503,15 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
 
         /** Directly puts a {@link PropertyParcel} in the property map. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder putInPropertyMap(@NonNull String name, @NonNull PropertyParcel value) {
+        public @NonNull Builder putInPropertyMap(
+                @NonNull String name, @NonNull PropertyParcel value) {
             Objects.requireNonNull(value);
             mPropertyMap.put(name, value);
             return this;
         }
 
         /** Builds the {@link GenericDocument} object. */
-        @NonNull
-        public GenericDocumentParcel build() {
+        public @NonNull GenericDocumentParcel build() {
             // Set current timestamp for creation timestamp by default.
             if (mCreationTimestampMillis == INVALID_CREATION_TIMESTAMP_MILLIS) {
                 mCreationTimestampMillis = System.currentTimeMillis();
diff --git a/framework/java/external/android/app/appsearch/safeparcel/PackageIdentifierParcel.java b/framework/java/external/android/app/appsearch/safeparcel/PackageIdentifierParcel.java
index d97e8bc2..71054b9d 100644
--- a/framework/java/external/android/app/appsearch/safeparcel/PackageIdentifierParcel.java
+++ b/framework/java/external/android/app/appsearch/safeparcel/PackageIdentifierParcel.java
@@ -17,8 +17,6 @@
 package android.app.appsearch.safeparcel;
 
 import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.app.appsearch.PackageIdentifier;
 import android.os.Parcel;
@@ -26,6 +24,9 @@ import android.os.Parcelable;
 
 import com.android.appsearch.flags.Flags;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Arrays;
 import java.util.Objects;
 
@@ -42,8 +43,7 @@ import java.util.Objects;
 @SafeParcelable.Class(creator = "PackageIdentifierParcelCreator")
 @SuppressLint("BanParcelableUsage")
 public final class PackageIdentifierParcel extends AbstractSafeParcelable implements Parcelable {
-    @NonNull
-    public static final Parcelable.Creator<PackageIdentifierParcel> CREATOR =
+    public static final Parcelable.@NonNull Creator<PackageIdentifierParcel> CREATOR =
             new PackageIdentifierParcelCreator();
 
     @Field(id = 1, getter = "getPackageName")
@@ -60,18 +60,16 @@ public final class PackageIdentifierParcel extends AbstractSafeParcelable implem
     @Constructor
     public PackageIdentifierParcel(
             @Param(id = 1) @NonNull String packageName,
-            @Param(id = 2) @NonNull byte[] sha256Certificate) {
+            @Param(id = 2) byte @NonNull [] sha256Certificate) {
         mPackageName = Objects.requireNonNull(packageName);
         mSha256Certificate = Objects.requireNonNull(sha256Certificate);
     }
 
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
-    @NonNull
-    public byte[] getSha256Certificate() {
+    public byte @NonNull [] getSha256Certificate() {
         return mSha256Certificate;
     }
 
diff --git a/framework/java/external/android/app/appsearch/safeparcel/PropertyConfigParcel.java b/framework/java/external/android/app/appsearch/safeparcel/PropertyConfigParcel.java
index 719d5973..bf14a869 100644
--- a/framework/java/external/android/app/appsearch/safeparcel/PropertyConfigParcel.java
+++ b/framework/java/external/android/app/appsearch/safeparcel/PropertyConfigParcel.java
@@ -16,8 +16,6 @@
 
 package android.app.appsearch.safeparcel;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.AppSearchSchema.PropertyConfig.Cardinality;
@@ -28,6 +26,9 @@ import android.app.appsearch.AppSearchSchema.StringPropertyConfig.TokenizerType;
 import android.os.Parcel;
 import android.os.Parcelable;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.List;
 import java.util.Objects;
 
@@ -43,8 +44,7 @@ import java.util.Objects;
  */
 @SafeParcelable.Class(creator = "PropertyConfigParcelCreator")
 public final class PropertyConfigParcel extends AbstractSafeParcelable {
-    @NonNull
-    public static final Parcelable.Creator<PropertyConfigParcel> CREATOR =
+    public static final Parcelable.@NonNull Creator<PropertyConfigParcel> CREATOR =
             new PropertyConfigParcelCreator();
 
     @Field(id = 1, getter = "getName")
@@ -59,24 +59,19 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     private final int mCardinality;
 
     @Field(id = 4, getter = "getSchemaType")
-    @Nullable
-    private final String mSchemaType;
+    private final @Nullable String mSchemaType;
 
     @Field(id = 5, getter = "getStringIndexingConfigParcel")
-    @Nullable
-    private final StringIndexingConfigParcel mStringIndexingConfigParcel;
+    private final @Nullable StringIndexingConfigParcel mStringIndexingConfigParcel;
 
     @Field(id = 6, getter = "getDocumentIndexingConfigParcel")
-    @Nullable
-    private final DocumentIndexingConfigParcel mDocumentIndexingConfigParcel;
+    private final @Nullable DocumentIndexingConfigParcel mDocumentIndexingConfigParcel;
 
     @Field(id = 7, getter = "getIntegerIndexingConfigParcel")
-    @Nullable
-    private final IntegerIndexingConfigParcel mIntegerIndexingConfigParcel;
+    private final @Nullable IntegerIndexingConfigParcel mIntegerIndexingConfigParcel;
 
     @Field(id = 8, getter = "getJoinableConfigParcel")
-    @Nullable
-    private final JoinableConfigParcel mJoinableConfigParcel;
+    private final @Nullable JoinableConfigParcel mJoinableConfigParcel;
 
     @Field(id = 9, getter = "getDescription")
     private final String mDescription;
@@ -87,7 +82,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     @Field(id = 11, getter = "isScoringEnabled")
     private final boolean mScoringEnabled;
 
-    @Nullable private Integer mHashCode;
+    private @Nullable Integer mHashCode;
 
     /** Constructor for {@link PropertyConfigParcel}. */
     @Constructor
@@ -117,8 +112,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Creates a {@link PropertyConfigParcel} for String. */
-    @NonNull
-    public static PropertyConfigParcel createForString(
+    public static @NonNull PropertyConfigParcel createForString(
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality,
@@ -139,8 +133,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Creates a {@link PropertyConfigParcel} for Long. */
-    @NonNull
-    public static PropertyConfigParcel createForLong(
+    public static @NonNull PropertyConfigParcel createForLong(
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality,
@@ -161,8 +154,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Creates a {@link PropertyConfigParcel} for Double. */
-    @NonNull
-    public static PropertyConfigParcel createForDouble(
+    public static @NonNull PropertyConfigParcel createForDouble(
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality,
@@ -182,8 +174,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Creates a {@link PropertyConfigParcel} for Boolean. */
-    @NonNull
-    public static PropertyConfigParcel createForBoolean(
+    public static @NonNull PropertyConfigParcel createForBoolean(
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality,
@@ -203,8 +194,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Creates a {@link PropertyConfigParcel} for Bytes. */
-    @NonNull
-    public static PropertyConfigParcel createForBytes(
+    public static @NonNull PropertyConfigParcel createForBytes(
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality) {
@@ -223,8 +213,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Creates a {@link PropertyConfigParcel} for Document. */
-    @NonNull
-    public static PropertyConfigParcel createForDocument(
+    public static @NonNull PropertyConfigParcel createForDocument(
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality,
@@ -245,8 +234,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Creates a {@link PropertyConfigParcel} for Embedding. */
-    @NonNull
-    public static PropertyConfigParcel createForEmbedding(
+    public static @NonNull PropertyConfigParcel createForEmbedding(
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality,
@@ -267,8 +255,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Creates a {@link PropertyConfigParcel} for {@link AppSearchBlobHandle}. */
-    @NonNull
-    public static PropertyConfigParcel createForBlobHandle(
+    public static @NonNull PropertyConfigParcel createForBlobHandle(
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality) {
@@ -287,14 +274,12 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Gets name for the property. */
-    @NonNull
-    public String getName() {
+    public @NonNull String getName() {
         return mName;
     }
 
     /** Gets description for the property. */
-    @NonNull
-    public String getDescription() {
+    public @NonNull String getDescription() {
         return mDescription;
     }
 
@@ -311,38 +296,32 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     /** Gets schema type. */
-    @Nullable
-    public String getSchemaType() {
+    public @Nullable String getSchemaType() {
         return mSchemaType;
     }
 
     /** Gets the {@link StringIndexingConfigParcel}. */
-    @Nullable
-    public StringIndexingConfigParcel getStringIndexingConfigParcel() {
+    public @Nullable StringIndexingConfigParcel getStringIndexingConfigParcel() {
         return mStringIndexingConfigParcel;
     }
 
     /** Gets the {@link DocumentIndexingConfigParcel}. */
-    @Nullable
-    public DocumentIndexingConfigParcel getDocumentIndexingConfigParcel() {
+    public @Nullable DocumentIndexingConfigParcel getDocumentIndexingConfigParcel() {
         return mDocumentIndexingConfigParcel;
     }
 
     /** Gets the {@link IntegerIndexingConfigParcel}. */
-    @Nullable
-    public IntegerIndexingConfigParcel getIntegerIndexingConfigParcel() {
+    public @Nullable IntegerIndexingConfigParcel getIntegerIndexingConfigParcel() {
         return mIntegerIndexingConfigParcel;
     }
 
     /** Gets the {@link JoinableConfigParcel}. */
-    @Nullable
-    public JoinableConfigParcel getJoinableConfigParcel() {
+    public @Nullable JoinableConfigParcel getJoinableConfigParcel() {
         return mJoinableConfigParcel;
     }
 
     /** Gets the {@link EmbeddingIndexingConfigParcel}. */
-    @Nullable
-    public EmbeddingIndexingConfigParcel getEmbeddingIndexingConfigParcel() {
+    public @Nullable EmbeddingIndexingConfigParcel getEmbeddingIndexingConfigParcel() {
         return mEmbeddingIndexingConfigParcel;
     }
 
@@ -404,8 +383,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     }
 
     @Override
-    @NonNull
-    public String toString() {
+    public @NonNull String toString() {
         return "{name: "
                 + mName
                 + ", description: "
@@ -434,8 +412,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     /** Class to hold join configuration for a String type. */
     @SafeParcelable.Class(creator = "JoinableConfigParcelCreator")
     public static class JoinableConfigParcel extends AbstractSafeParcelable {
-        @NonNull
-        public static final Parcelable.Creator<JoinableConfigParcel> CREATOR =
+        public static final Parcelable.@NonNull Creator<JoinableConfigParcel> CREATOR =
                 new JoinableConfigParcelCreator();
 
         @JoinableValueType
@@ -490,8 +467,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         }
 
         @Override
-        @NonNull
-        public String toString() {
+        public @NonNull String toString() {
             return "{joinableValueType: "
                     + mJoinableValueType
                     + ", deletePropagationType: "
@@ -503,8 +479,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     /** Class to hold configuration a string type. */
     @SafeParcelable.Class(creator = "StringIndexingConfigParcelCreator")
     public static class StringIndexingConfigParcel extends AbstractSafeParcelable {
-        @NonNull
-        public static final Parcelable.Creator<StringIndexingConfigParcel> CREATOR =
+        public static final Parcelable.@NonNull Creator<StringIndexingConfigParcel> CREATOR =
                 new StringIndexingConfigParcelCreator();
 
         @AppSearchSchema.StringPropertyConfig.IndexingType
@@ -560,8 +535,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         }
 
         @Override
-        @NonNull
-        public String toString() {
+        public @NonNull String toString() {
             return "{indexingType: " + mIndexingType + ", tokenizerType: " + mTokenizerType + "}";
         }
     }
@@ -569,8 +543,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     /** Class to hold configuration for integer property type. */
     @SafeParcelable.Class(creator = "IntegerIndexingConfigParcelCreator")
     public static class IntegerIndexingConfigParcel extends AbstractSafeParcelable {
-        @NonNull
-        public static final Parcelable.Creator<IntegerIndexingConfigParcel> CREATOR =
+        public static final Parcelable.@NonNull Creator<IntegerIndexingConfigParcel> CREATOR =
                 new IntegerIndexingConfigParcelCreator();
 
         @AppSearchSchema.LongPropertyConfig.IndexingType
@@ -613,8 +586,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         }
 
         @Override
-        @NonNull
-        public String toString() {
+        public @NonNull String toString() {
             return "{indexingType: " + mIndexingType + "}";
         }
     }
@@ -622,16 +594,14 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     /** Class to hold configuration for document property type. */
     @SafeParcelable.Class(creator = "DocumentIndexingConfigParcelCreator")
     public static class DocumentIndexingConfigParcel extends AbstractSafeParcelable {
-        @NonNull
-        public static final Parcelable.Creator<DocumentIndexingConfigParcel> CREATOR =
+        public static final Parcelable.@NonNull Creator<DocumentIndexingConfigParcel> CREATOR =
                 new DocumentIndexingConfigParcelCreator();
 
         @Field(id = 1, getter = "shouldIndexNestedProperties")
         private final boolean mIndexNestedProperties;
 
-        @NonNull
         @Field(id = 2, getter = "getIndexableNestedPropertiesList")
-        private final List<String> mIndexableNestedPropertiesList;
+        private final @NonNull List<String> mIndexableNestedPropertiesList;
 
         /** Constructor for {@link DocumentIndexingConfigParcel}. */
         @Constructor
@@ -648,8 +618,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         }
 
         /** Gets the list for nested property list. */
-        @NonNull
-        public List<String> getIndexableNestedPropertiesList() {
+        public @NonNull List<String> getIndexableNestedPropertiesList() {
             return mIndexableNestedPropertiesList;
         }
 
@@ -679,8 +648,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         }
 
         @Override
-        @NonNull
-        public String toString() {
+        public @NonNull String toString() {
             return "{indexNestedProperties: "
                     + mIndexNestedProperties
                     + ", indexableNestedPropertiesList: "
@@ -692,8 +660,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     /** Class to hold configuration for embedding property. */
     @SafeParcelable.Class(creator = "EmbeddingIndexingConfigParcelCreator")
     public static class EmbeddingIndexingConfigParcel extends AbstractSafeParcelable {
-        @NonNull
-        public static final Parcelable.Creator<EmbeddingIndexingConfigParcel> CREATOR =
+        public static final Parcelable.@NonNull Creator<EmbeddingIndexingConfigParcel> CREATOR =
                 new EmbeddingIndexingConfigParcelCreator();
 
         @AppSearchSchema.EmbeddingPropertyConfig.IndexingType
@@ -751,8 +718,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         }
 
         @Override
-        @NonNull
-        public String toString() {
+        public @NonNull String toString() {
             return "{indexingType: "
                     + mIndexingType
                     + ", quantizationType: "
diff --git a/framework/java/external/android/app/appsearch/safeparcel/PropertyParcel.java b/framework/java/external/android/app/appsearch/safeparcel/PropertyParcel.java
index 7bdc1715..37334720 100644
--- a/framework/java/external/android/app/appsearch/safeparcel/PropertyParcel.java
+++ b/framework/java/external/android/app/appsearch/safeparcel/PropertyParcel.java
@@ -16,8 +16,6 @@
 
 package android.app.appsearch.safeparcel;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.EmbeddingVector;
@@ -25,6 +23,9 @@ import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.os.Parcel;
 import android.os.Parcelable;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Arrays;
 import java.util.Objects;
 
@@ -39,58 +40,49 @@ import java.util.Objects;
 // This won't be used to send data over binder, and we have to use Parcelable for code sync purpose.
 @SuppressLint("BanParcelableUsage")
 public final class PropertyParcel extends AbstractSafeParcelable implements Parcelable {
-    @NonNull
-    public static final Parcelable.Creator<PropertyParcel> CREATOR = new PropertyParcelCreator();
+    public static final Parcelable.@NonNull Creator<PropertyParcel> CREATOR =
+            new PropertyParcelCreator();
 
-    @NonNull
     @Field(id = 1, getter = "getPropertyName")
-    private final String mPropertyName;
+    private final @NonNull String mPropertyName;
 
-    @Nullable
     @Field(id = 2, getter = "getStringValues")
-    private final String[] mStringValues;
+    private final String @Nullable [] mStringValues;
 
-    @Nullable
     @Field(id = 3, getter = "getLongValues")
-    private final long[] mLongValues;
+    private final long @Nullable [] mLongValues;
 
-    @Nullable
     @Field(id = 4, getter = "getDoubleValues")
-    private final double[] mDoubleValues;
+    private final double @Nullable [] mDoubleValues;
 
-    @Nullable
     @Field(id = 5, getter = "getBooleanValues")
-    private final boolean[] mBooleanValues;
+    private final boolean @Nullable [] mBooleanValues;
 
-    @Nullable
     @Field(id = 6, getter = "getBytesValues")
-    private final byte[][] mBytesValues;
+    private final byte @Nullable [][] mBytesValues;
 
-    @Nullable
     @Field(id = 7, getter = "getDocumentValues")
-    private final GenericDocumentParcel[] mDocumentValues;
+    private final GenericDocumentParcel @Nullable [] mDocumentValues;
 
-    @Nullable
     @Field(id = 8, getter = "getEmbeddingValues")
-    private final EmbeddingVector[] mEmbeddingValues;
+    private final EmbeddingVector @Nullable [] mEmbeddingValues;
 
-    @Nullable
     @Field(id = 9, getter = "getBlobHandleValues")
-    private final AppSearchBlobHandle[] mBlobHandleValues;
+    private final AppSearchBlobHandle @Nullable [] mBlobHandleValues;
 
-    @Nullable private Integer mHashCode;
+    private @Nullable Integer mHashCode;
 
     @Constructor
     PropertyParcel(
             @Param(id = 1) @NonNull String propertyName,
-            @Param(id = 2) @Nullable String[] stringValues,
-            @Param(id = 3) @Nullable long[] longValues,
-            @Param(id = 4) @Nullable double[] doubleValues,
-            @Param(id = 5) @Nullable boolean[] booleanValues,
-            @Param(id = 6) @Nullable byte[][] bytesValues,
-            @Param(id = 7) @Nullable GenericDocumentParcel[] documentValues,
-            @Param(id = 8) @Nullable EmbeddingVector[] embeddingValues,
-            @Param(id = 9) @Nullable AppSearchBlobHandle[] blobHandleValues) {
+            @Param(id = 2) String @Nullable [] stringValues,
+            @Param(id = 3) long @Nullable [] longValues,
+            @Param(id = 4) double @Nullable [] doubleValues,
+            @Param(id = 5) boolean @Nullable [] booleanValues,
+            @Param(id = 6) byte @Nullable [][] bytesValues,
+            @Param(id = 7) GenericDocumentParcel @Nullable [] documentValues,
+            @Param(id = 8) EmbeddingVector @Nullable [] embeddingValues,
+            @Param(id = 9) AppSearchBlobHandle @Nullable [] blobHandleValues) {
         mPropertyName = Objects.requireNonNull(propertyName);
         mStringValues = stringValues;
         mLongValues = longValues;
@@ -104,56 +96,47 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
     }
 
     /** Returns the name of the property. */
-    @NonNull
-    public String getPropertyName() {
+    public @NonNull String getPropertyName() {
         return mPropertyName;
     }
 
     /** Returns {@code String} values in an array. */
-    @Nullable
-    public String[] getStringValues() {
+    public String @Nullable [] getStringValues() {
         return mStringValues;
     }
 
     /** Returns {@code long} values in an array. */
-    @Nullable
-    public long[] getLongValues() {
+    public long @Nullable [] getLongValues() {
         return mLongValues;
     }
 
     /** Returns {@code double} values in an array. */
-    @Nullable
-    public double[] getDoubleValues() {
+    public double @Nullable [] getDoubleValues() {
         return mDoubleValues;
     }
 
     /** Returns {@code boolean} values in an array. */
-    @Nullable
-    public boolean[] getBooleanValues() {
+    public boolean @Nullable [] getBooleanValues() {
         return mBooleanValues;
     }
 
     /** Returns a two-dimension {@code byte} array. */
-    @Nullable
-    public byte[][] getBytesValues() {
+    public byte @Nullable [][] getBytesValues() {
         return mBytesValues;
     }
 
     /** Returns {@link GenericDocumentParcel}s in an array. */
-    @Nullable
-    public GenericDocumentParcel[] getDocumentValues() {
+    public GenericDocumentParcel @Nullable [] getDocumentValues() {
         return mDocumentValues;
     }
 
     /** Returns {@link EmbeddingVector}s in an array. */
-    @Nullable
-    public EmbeddingVector[] getEmbeddingValues() {
+    public EmbeddingVector @Nullable [] getEmbeddingValues() {
         return mEmbeddingValues;
     }
 
     /** Returns {@link AppSearchBlobHandle}s in an array. */
-    @Nullable
-    public AppSearchBlobHandle[] getBlobHandleValues() {
+    public AppSearchBlobHandle @Nullable [] getBlobHandleValues() {
         return mBlobHandleValues;
     }
 
@@ -162,8 +145,7 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
      *
      * <p>Different from other getter methods, this one will return an {@link Object}.
      */
-    @Nullable
-    public Object getValues() {
+    public @Nullable Object getValues() {
         if (mStringValues != null) {
             return mStringValues;
         }
@@ -299,71 +281,64 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
 
         /** Sets String values. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStringValues(@NonNull String[] stringValues) {
+        public @NonNull Builder setStringValues(String @NonNull [] stringValues) {
             mStringValues = Objects.requireNonNull(stringValues);
             return this;
         }
 
         /** Sets long values. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setLongValues(@NonNull long[] longValues) {
+        public @NonNull Builder setLongValues(long @NonNull [] longValues) {
             mLongValues = Objects.requireNonNull(longValues);
             return this;
         }
 
         /** Sets double values. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDoubleValues(@NonNull double[] doubleValues) {
+        public @NonNull Builder setDoubleValues(double @NonNull [] doubleValues) {
             mDoubleValues = Objects.requireNonNull(doubleValues);
             return this;
         }
 
         /** Sets boolean values. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setBooleanValues(@NonNull boolean[] booleanValues) {
+        public @NonNull Builder setBooleanValues(boolean @NonNull [] booleanValues) {
             mBooleanValues = Objects.requireNonNull(booleanValues);
             return this;
         }
 
         /** Sets a two dimension byte array. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setBytesValues(@NonNull byte[][] bytesValues) {
+        public @NonNull Builder setBytesValues(byte @NonNull [][] bytesValues) {
             mBytesValues = Objects.requireNonNull(bytesValues);
             return this;
         }
 
         /** Sets document values. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDocumentValues(@NonNull GenericDocumentParcel[] documentValues) {
+        public @NonNull Builder setDocumentValues(
+                GenericDocumentParcel @NonNull [] documentValues) {
             mDocumentValues = Objects.requireNonNull(documentValues);
             return this;
         }
 
         /** Sets embedding values. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setEmbeddingValues(@NonNull EmbeddingVector[] embeddingValues) {
+        public @NonNull Builder setEmbeddingValues(EmbeddingVector @NonNull [] embeddingValues) {
             mEmbeddingValues = Objects.requireNonNull(embeddingValues);
             return this;
         }
 
         /** Sets {@link AppSearchBlobHandle} values. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setBlobHandleValues(@NonNull AppSearchBlobHandle[] blobHandleValues) {
+        public @NonNull Builder setBlobHandleValues(
+                AppSearchBlobHandle @NonNull [] blobHandleValues) {
             mBlobHandleValues = Objects.requireNonNull(blobHandleValues);
             return this;
         }
 
         /** Builds a {@link PropertyParcel}. */
-        @NonNull
-        public PropertyParcel build() {
+        public @NonNull PropertyParcel build() {
             return new PropertyParcel(
                     mPropertyName,
                     mStringValues,
diff --git a/framework/java/external/android/app/appsearch/stats/BaseStats.java b/framework/java/external/android/app/appsearch/stats/BaseStats.java
new file mode 100644
index 00000000..9a8ab4b9
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/stats/BaseStats.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.stats;
+
+import android.annotation.SuppressLint;
+import android.app.appsearch.annotation.CanIgnoreReturnValue;
+
+import org.jspecify.annotations.NonNull;
+
+import java.util.Objects;
+
+/**
+ * Encapsulates base statistics information for AppSearch results.
+ *
+ * <p>This class provides a convenient way to store and retrieve key statistics, such as the result
+ * code and a bitmask of enabled features.
+ *
+ * @hide
+ */
+public class BaseStats {
+    private static final int LAUNCH_VM = 0;
+
+    private final long mEnabledFeatures;
+
+    protected BaseStats(@NonNull Builder<?> builder) {
+        Objects.requireNonNull(builder);
+        mEnabledFeatures = builder.mEnabledFeatures;
+    }
+
+    /** Returns the bitmask representing the enabled features. */
+    public long getEnabledFeatures() {
+        return mEnabledFeatures;
+    }
+
+    /**
+     * Builder for {@link BaseStats}.
+     *
+     * @param <BuilderType> Type of subclass who extends this.
+     */
+    // This builder is specifically designed to be extended by stats classes.
+    @SuppressLint("StaticFinalBuilder")
+    @SuppressWarnings("rawtypes")
+    public static class Builder<BuilderType extends Builder> {
+        private final BuilderType mBuilderTypeInstance;
+        long mEnabledFeatures;
+
+        /** Creates a new {@link BaseStats.Builder}. */
+        @SuppressWarnings("unchecked")
+        public Builder() {
+            mBuilderTypeInstance = (BuilderType) this;
+        }
+
+        /** Sets bitmask for all enabled features . */
+        @CanIgnoreReturnValue
+        public @NonNull BuilderType setLaunchVMEnabled(boolean enabled) {
+            modifyEnabledFeature(LAUNCH_VM, enabled);
+            return mBuilderTypeInstance;
+        }
+
+        /** Builds the {@link BaseStats} instance. */
+        public @NonNull BaseStats build() {
+            return new BaseStats(this);
+        }
+
+        private void modifyEnabledFeature(int feature, boolean enabled) {
+            if (enabled) {
+                mEnabledFeatures |= (1L << feature);
+            } else {
+                mEnabledFeatures &= ~(1L << feature);
+            }
+        }
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/stats/SchemaMigrationStats.java b/framework/java/external/android/app/appsearch/stats/SchemaMigrationStats.java
index a0debbe3..30de6be6 100644
--- a/framework/java/external/android/app/appsearch/stats/SchemaMigrationStats.java
+++ b/framework/java/external/android/app/appsearch/stats/SchemaMigrationStats.java
@@ -17,7 +17,6 @@
 package android.app.appsearch.stats;
 
 import android.annotation.IntDef;
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.SetSchemaRequest;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
@@ -26,6 +25,8 @@ import android.app.appsearch.safeparcel.SafeParcelable;
 import android.os.Parcel;
 import android.os.Parcelable;
 
+import org.jspecify.annotations.NonNull;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Objects;
@@ -37,8 +38,7 @@ import java.util.Objects;
  */
 @SafeParcelable.Class(creator = "SchemaMigrationStatsCreator")
 public final class SchemaMigrationStats extends AbstractSafeParcelable {
-    @NonNull
-    public static final Parcelable.Creator<SchemaMigrationStats> CREATOR =
+    public static final Parcelable.@NonNull Creator<SchemaMigrationStats> CREATOR =
             new SchemaMigrationStatsCreator();
 
     /** Indicate the SetSchema call type relative to SchemaMigration case. */
@@ -61,12 +61,10 @@ public final class SchemaMigrationStats extends AbstractSafeParcelable {
     public static final int SECOND_CALL_APPLY_NEW_SCHEMA = 2;
 
     @Field(id = 1, getter = "getPackageName")
-    @NonNull
-    private final String mPackageName;
+    private final @NonNull String mPackageName;
 
     @Field(id = 2, getter = "getDatabase")
-    @NonNull
-    private final String mDatabase;
+    private final @NonNull String mDatabase;
 
     @Field(id = 3, getter = "getStatusCode")
     private final int mStatusCode;
@@ -104,6 +102,9 @@ public final class SchemaMigrationStats extends AbstractSafeParcelable {
     @Field(id = 14, getter = "getTotalSuccessMigratedDocumentCount")
     private final int mTotalSuccessMigratedDocumentCount;
 
+    @Field(id = 15, getter = "getEnabledFeatures")
+    private final long mEnabledFeatures;
+
     /** Build a {@link SchemaMigrationStats} from the given parameters. */
     @Constructor
     public SchemaMigrationStats(
@@ -120,7 +121,8 @@ public final class SchemaMigrationStats extends AbstractSafeParcelable {
             @Param(id = 11) int saveDocumentLatencyMillis,
             @Param(id = 12) int totalNeedMigratedDocumentCount,
             @Param(id = 13) int migrationFailureCount,
-            @Param(id = 14) int totalSuccessMigratedDocumentCount) {
+            @Param(id = 14) int totalSuccessMigratedDocumentCount,
+            @Param(id = 15) long enabledFeatures) {
         mPackageName = packageName;
         mDatabase = database;
         mStatusCode = statusCode;
@@ -135,17 +137,16 @@ public final class SchemaMigrationStats extends AbstractSafeParcelable {
         mTotalNeedMigratedDocumentCount = totalNeedMigratedDocumentCount;
         mMigrationFailureCount = migrationFailureCount;
         mTotalSuccessMigratedDocumentCount = totalSuccessMigratedDocumentCount;
+        mEnabledFeatures = enabledFeatures;
     }
 
     /** Returns calling package name. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
     /** Returns calling database name. */
-    @NonNull
-    public String getDatabase() {
+    public @NonNull String getDatabase() {
         return mDatabase;
     }
 
@@ -226,6 +227,11 @@ public final class SchemaMigrationStats extends AbstractSafeParcelable {
         return mTotalSuccessMigratedDocumentCount;
     }
 
+    /** Returns the bitmask representing the enabled features. */
+    public long getEnabledFeatures() {
+        return mEnabledFeatures;
+    }
+
     @Override
     public void writeToParcel(@NonNull Parcel dest, int flags) {
         SchemaMigrationStatsCreator.writeToParcel(this, dest, flags);
@@ -248,6 +254,7 @@ public final class SchemaMigrationStats extends AbstractSafeParcelable {
         int mTotalNeedMigratedDocumentCount;
         int mMigrationFailureCount;
         int mTotalSuccessMigratedDocumentCount;
+        long mEnabledFeatures;
 
         /** Creates a {@link SchemaMigrationStats.Builder}. */
         public Builder(@NonNull String packageName, @NonNull String database) {
@@ -278,36 +285,34 @@ public final class SchemaMigrationStats extends AbstractSafeParcelable {
             mTotalNeedMigratedDocumentCount = stats.mTotalNeedMigratedDocumentCount;
             mMigrationFailureCount = stats.mMigrationFailureCount;
             mTotalSuccessMigratedDocumentCount = stats.mTotalSuccessMigratedDocumentCount;
+            mEnabledFeatures = stats.mEnabledFeatures;
         }
 
         /** Sets status code for the schema migration action. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
+        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
             mStatusCode = statusCode;
             return this;
         }
 
         /** Sets the latency for waiting the executor. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setExecutorAcquisitionLatencyMillis(int executorAcquisitionLatencyMillis) {
+        public @NonNull Builder setExecutorAcquisitionLatencyMillis(
+                int executorAcquisitionLatencyMillis) {
             mExecutorAcquisitionLatencyMillis = executorAcquisitionLatencyMillis;
             return this;
         }
 
         /** Sets total latency for the schema migration action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalLatencyMillis(int totalLatencyMillis) {
+        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
             mTotalLatencyMillis = totalLatencyMillis;
             return this;
         }
 
         /** Sets latency for the GetSchema action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setGetSchemaLatencyMillis(int getSchemaLatencyMillis) {
+        public @NonNull Builder setGetSchemaLatencyMillis(int getSchemaLatencyMillis) {
             mGetSchemaLatencyMillis = getSchemaLatencyMillis;
             return this;
         }
@@ -317,73 +322,73 @@ public final class SchemaMigrationStats extends AbstractSafeParcelable {
          * transforming documents to new version in milliseconds.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setQueryAndTransformLatencyMillis(int queryAndTransformLatencyMillis) {
+        public @NonNull Builder setQueryAndTransformLatencyMillis(
+                int queryAndTransformLatencyMillis) {
             mQueryAndTransformLatencyMillis = queryAndTransformLatencyMillis;
             return this;
         }
 
         /** Sets latency of first SetSchema action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setFirstSetSchemaLatencyMillis(int firstSetSchemaLatencyMillis) {
+        public @NonNull Builder setFirstSetSchemaLatencyMillis(int firstSetSchemaLatencyMillis) {
             mFirstSetSchemaLatencyMillis = firstSetSchemaLatencyMillis;
             return this;
         }
 
         /** Returns status of the first SetSchema action. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setIsFirstSetSchemaSuccess(boolean isFirstSetSchemaSuccess) {
+        public @NonNull Builder setIsFirstSetSchemaSuccess(boolean isFirstSetSchemaSuccess) {
             mIsFirstSetSchemaSuccess = isFirstSetSchemaSuccess;
             return this;
         }
 
         /** Sets latency of second SetSchema action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setSecondSetSchemaLatencyMillis(int secondSetSchemaLatencyMillis) {
+        public @NonNull Builder setSecondSetSchemaLatencyMillis(int secondSetSchemaLatencyMillis) {
             mSecondSetSchemaLatencyMillis = secondSetSchemaLatencyMillis;
             return this;
         }
 
         /** Sets latency for putting migrated document to Icing lib in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setSaveDocumentLatencyMillis(int saveDocumentLatencyMillis) {
+        public @NonNull Builder setSaveDocumentLatencyMillis(int saveDocumentLatencyMillis) {
             mSaveDocumentLatencyMillis = saveDocumentLatencyMillis;
             return this;
         }
 
         /** Sets number of document that need to be migrated to another version. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalNeedMigratedDocumentCount(int migratedDocumentCount) {
+        public @NonNull Builder setTotalNeedMigratedDocumentCount(int migratedDocumentCount) {
             mTotalNeedMigratedDocumentCount = migratedDocumentCount;
             return this;
         }
 
         /** Sets total document count of successfully migrated and saved in Icing. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalSuccessMigratedDocumentCount(int totalSuccessMigratedDocumentCount) {
+        public @NonNull Builder setTotalSuccessMigratedDocumentCount(
+                int totalSuccessMigratedDocumentCount) {
             mTotalSuccessMigratedDocumentCount = totalSuccessMigratedDocumentCount;
             return this;
         }
 
         /** Sets number of {@link android.app.appsearch.SetSchemaResponse.MigrationFailure}. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setMigrationFailureCount(int migrationFailureCount) {
+        public @NonNull Builder setMigrationFailureCount(int migrationFailureCount) {
             mMigrationFailureCount = migrationFailureCount;
             return this;
         }
 
+        /** Sets bitmask for all enabled features . */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setEnabledFeatures(long enabledFeatures) {
+            mEnabledFeatures = enabledFeatures;
+            return this;
+        }
+
         /**
          * Builds a new {@link SchemaMigrationStats} from the {@link SchemaMigrationStats.Builder}.
          */
-        @NonNull
-        public SchemaMigrationStats build() {
+        public @NonNull SchemaMigrationStats build() {
             return new SchemaMigrationStats(
                     mPackageName,
                     mDatabase,
@@ -398,7 +403,8 @@ public final class SchemaMigrationStats extends AbstractSafeParcelable {
                     mSaveDocumentLatencyMillis,
                     mTotalNeedMigratedDocumentCount,
                     mMigrationFailureCount,
-                    mTotalSuccessMigratedDocumentCount);
+                    mTotalSuccessMigratedDocumentCount,
+                    mEnabledFeatures);
         }
     }
 }
diff --git a/framework/java/external/android/app/appsearch/util/BundleUtil.java b/framework/java/external/android/app/appsearch/util/BundleUtil.java
index 5df64add..ee906c28 100644
--- a/framework/java/external/android/app/appsearch/util/BundleUtil.java
+++ b/framework/java/external/android/app/appsearch/util/BundleUtil.java
@@ -16,12 +16,13 @@
 
 package android.app.appsearch.util;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.os.Bundle;
 import android.os.Parcel;
 import android.util.SparseArray;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 
@@ -236,8 +237,7 @@ public final class BundleUtil {
      *
      * <p>Values which are Bundles, Lists or Arrays are deeply copied themselves.
      */
-    @NonNull
-    public static Bundle deepCopy(@NonNull Bundle bundle) {
+    public static @NonNull Bundle deepCopy(@NonNull Bundle bundle) {
         // Write bundle to bytes
         Parcel parcel = Parcel.obtain();
         try {
diff --git a/framework/java/external/android/app/appsearch/util/DocumentIdUtil.java b/framework/java/external/android/app/appsearch/util/DocumentIdUtil.java
index 749f5cc6..9eafdd80 100644
--- a/framework/java/external/android/app/appsearch/util/DocumentIdUtil.java
+++ b/framework/java/external/android/app/appsearch/util/DocumentIdUtil.java
@@ -16,8 +16,10 @@
 
 package android.app.appsearch.util;
 
-import android.annotation.NonNull;
 import android.app.appsearch.GenericDocument;
+import android.app.appsearch.JoinSpec;
+
+import org.jspecify.annotations.NonNull;
 
 import java.util.Objects;
 
@@ -29,10 +31,20 @@ public class DocumentIdUtil {
     private static final String NAMESPACE_DELIMITER = "#";
 
     /**
-     * In regex, 4 backslashes in Java represent a single backslash in Regex. This will escape the
-     * namespace delimiter.
+     * Replacement for the namespace delimiter.
+     *
+     * <p>We are using literal replace, so this is the literal replacement String, not a regex. We
+     * want to replace "#" with "\\#".
+     */
+    private static final String NAMESPACE_DELIMITER_REPLACEMENT = "\\#";
+
+    /**
+     * Replacement for backslash.
+     *
+     * <p>We are using literal replace, so this is the literal replacement String, not a regex. We
+     * want to replace "\" with "\\".
      */
-    private static final String NAMESPACE_DELIMITER_REPLACEMENT_REGEX = "\\\\#";
+    private static final String BACKSLASH_REPLACEMENT = "\\\\";
 
     /**
      * Generates a qualified id based on package, database, and a {@link GenericDocument}.
@@ -43,8 +55,7 @@ public class DocumentIdUtil {
      * @return the qualified id of a document.
      * @see #createQualifiedId(String, String, String, String)
      */
-    @NonNull
-    public static String createQualifiedId(
+    public static @NonNull String createQualifiedId(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull GenericDocument document) {
@@ -57,17 +68,17 @@ public class DocumentIdUtil {
      *
      * <p>A qualified id is a String referring to the combined package name, database name,
      * namespace, and id of the document. It is useful for linking one document to another in order
-     * to perform a join operation.
+     * to perform a join operation with {@link JoinSpec}.
      *
      * @param packageName The package the document belongs to.
      * @param databaseName The database containing the document.
      * @param namespace The namespace of the document.
      * @param id The id of the document.
      * @return the qualified id of a document
+     * @see JoinSpec
+     * @see JoinSpec#QUALIFIED_ID
      */
-    // TODO(b/256022027): Add @link to QUALIFIED_ID and JoinSpec
-    @NonNull
-    public static String createQualifiedId(
+    public static @NonNull String createQualifiedId(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull String namespace,
@@ -101,8 +112,23 @@ public class DocumentIdUtil {
      * @return An escaped string
      */
     private static String escapeNsDelimiters(@NonNull String original) {
-        // Four backslashes represent a single backslash in regex.
-        return original.replaceAll("\\\\", "\\\\\\\\")
-                .replaceAll(NAMESPACE_DELIMITER, NAMESPACE_DELIMITER_REPLACEMENT_REGEX);
+        StringBuilder escapedString = null;
+        for (int i = 0; i < original.length(); i++) {
+            char currentChar = original.charAt(i);
+            if (currentChar == '\\') {
+                if (escapedString == null) {
+                    escapedString = new StringBuilder(original.substring(0, i));
+                }
+                escapedString.append(BACKSLASH_REPLACEMENT);
+            } else if (currentChar == '#') {
+                if (escapedString == null) {
+                    escapedString = new StringBuilder(original.substring(0, i));
+                }
+                escapedString.append(NAMESPACE_DELIMITER_REPLACEMENT);
+            } else if (escapedString != null) {
+                escapedString.append(currentChar);
+            }
+        }
+        return escapedString == null ? original : escapedString.toString();
     }
 }
diff --git a/framework/java/external/android/app/appsearch/util/IndentingStringBuilder.java b/framework/java/external/android/app/appsearch/util/IndentingStringBuilder.java
index 7531ce44..2032a401 100644
--- a/framework/java/external/android/app/appsearch/util/IndentingStringBuilder.java
+++ b/framework/java/external/android/app/appsearch/util/IndentingStringBuilder.java
@@ -16,9 +16,10 @@
 
 package android.app.appsearch.util;
 
-import android.annotation.NonNull;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
 
+import org.jspecify.annotations.NonNull;
+
 /**
  * Utility for building indented strings.
  *
@@ -39,16 +40,14 @@ public class IndentingStringBuilder {
 
     /** Increases the indent level by one for appended strings. */
     @CanIgnoreReturnValue
-    @NonNull
-    public IndentingStringBuilder increaseIndentLevel() {
+    public @NonNull IndentingStringBuilder increaseIndentLevel() {
         mIndentLevel++;
         return this;
     }
 
     /** Decreases the indent level by one for appended strings. */
     @CanIgnoreReturnValue
-    @NonNull
-    public IndentingStringBuilder decreaseIndentLevel() throws IllegalStateException {
+    public @NonNull IndentingStringBuilder decreaseIndentLevel() throws IllegalStateException {
         if (mIndentLevel == 0) {
             throw new IllegalStateException("Cannot set indent level below 0.");
         }
@@ -62,8 +61,7 @@ public class IndentingStringBuilder {
      * <p>Indentation is applied after each newline character.
      */
     @CanIgnoreReturnValue
-    @NonNull
-    public IndentingStringBuilder append(@NonNull String str) {
+    public @NonNull IndentingStringBuilder append(@NonNull String str) {
         applyIndentToString(str);
         return this;
     }
@@ -75,15 +73,13 @@ public class IndentingStringBuilder {
      * <p>Indentation is applied after each newline character.
      */
     @CanIgnoreReturnValue
-    @NonNull
-    public IndentingStringBuilder append(@NonNull Object obj) {
+    public @NonNull IndentingStringBuilder append(@NonNull Object obj) {
         applyIndentToString(obj.toString());
         return this;
     }
 
     @Override
-    @NonNull
-    public String toString() {
+    public @NonNull String toString() {
         return mStringBuilder.toString();
     }
 
diff --git a/framework/java/external/android/app/appsearch/util/LogUtil.java b/framework/java/external/android/app/appsearch/util/LogUtil.java
index 61be70dd..21f97db1 100644
--- a/framework/java/external/android/app/appsearch/util/LogUtil.java
+++ b/framework/java/external/android/app/appsearch/util/LogUtil.java
@@ -16,12 +16,13 @@
 
 package android.app.appsearch.util;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.Size;
 import android.app.appsearch.AppSearchEnvironmentFactory;
 import android.util.Log;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 /**
  * Utilities for logging to logcat.
  *
diff --git a/framework/java/external/android/app/appsearch/util/SchemaMigrationUtil.java b/framework/java/external/android/app/appsearch/util/SchemaMigrationUtil.java
index fcacb5f9..0ba04737 100644
--- a/framework/java/external/android/app/appsearch/util/SchemaMigrationUtil.java
+++ b/framework/java/external/android/app/appsearch/util/SchemaMigrationUtil.java
@@ -18,7 +18,6 @@ package android.app.appsearch.util;
 
 import static android.app.appsearch.AppSearchResult.RESULT_INVALID_SCHEMA;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.InternalSetSchemaResponse;
 import android.app.appsearch.Migrator;
@@ -27,6 +26,8 @@ import android.app.appsearch.exceptions.AppSearchException;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
@@ -44,8 +45,7 @@ public final class SchemaMigrationUtil {
      *
      * <p>{@link Migrator#shouldMigrate} returns {@code true} will make the {@link Migrator} active.
      */
-    @NonNull
-    public static Map<String, Migrator> getActiveMigrators(
+    public static @NonNull Map<String, Migrator> getActiveMigrators(
             @NonNull Set<AppSearchSchema> existingSchemas,
             @NonNull Map<String, Migrator> migrators,
             int currentVersion,
diff --git a/safeparcel-processor/Android.bp b/safeparcel-processor/Android.bp
index 16d2fedf..45ec4664 100644
--- a/safeparcel-processor/Android.bp
+++ b/safeparcel-processor/Android.bp
@@ -30,6 +30,7 @@ java_library_host {
     static_libs: [
         "androidx.annotation_annotation",
         "guava",
+        "javapoet",
         "jsilver",
     ],
     use_tools_jar: true,
diff --git a/safeparcel-processor/src/android/app/appsearch/safeparcel/SafeParcelProcessor.java b/safeparcel-processor/src/android/app/appsearch/safeparcel/SafeParcelProcessor.java
index 99ab770b..c92f392f 100644
--- a/safeparcel-processor/src/android/app/appsearch/safeparcel/SafeParcelProcessor.java
+++ b/safeparcel-processor/src/android/app/appsearch/safeparcel/SafeParcelProcessor.java
@@ -28,6 +28,7 @@ import com.google.clearsilver.jsilver.autoescape.EscapeMode;
 import com.google.clearsilver.jsilver.data.Data;
 import com.google.clearsilver.jsilver.resourceloader.ClassLoaderResourceLoader;
 import com.google.common.base.Joiner;
+import com.squareup.javapoet.TypeName;
 
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -1492,21 +1493,23 @@ public class SafeParcelProcessor extends AbstractProcessor {
                 // class is not a type that is known by the annotation processor.  Hence, we must
                 // manually qualify the package.  The expected name of the CREATOR class is the
                 // value of generatedClassName.
+                String fieldTypeName = TypeName.get(field.asType()).toString();
                 String detectedCreatorTypeName =
                         mElements.getPackageOf(parcelableClass).getQualifiedName()
                                 + "."
-                                + field.asType();
+                                + fieldTypeName;
                 // If the type of the CREATOR field is the generic form, Parcelable.Creator<T>
                 // then we don't need to manually qualify the type.
-                String detectedAlternativeCreatorTypeName = field.asType().toString();
+                String detectedAlternativeCreatorTypeName = fieldTypeName;
 
                 // This represents the expected type of the CREATOR object in the alternative form.
                 // The expected name is in this form is the value of
                 // expectedAlternativeCreatorTypeName.
                 String expectedAlternativeCreatorTypeName =
-                        mTypes.getDeclaredType(
+                        TypeName.get(
+                                mTypes.getDeclaredType(
                                         (TypeElement) mTypes.asElement(mParcelableCreatorType),
-                                        parcelableClass.asType())
+                                        parcelableClass.asType()))
                                 .toString();
                 TypeMirror parcelableType = parcelableClass.asType();
                 if (parcelableType instanceof DeclaredType) {
@@ -1517,7 +1520,7 @@ public class SafeParcelProcessor extends AbstractProcessor {
                         // detectedAlternativeCreatorTypeName would only return Parcel resulting
                         // in an incorrect ParcelCreatorType failure.
                         StringBuilder type = new StringBuilder();
-                        Joiner.on(',').appendTo(type, declaredType.getTypeArguments());
+                        Joiner.on(", ").appendTo(type, declaredType.getTypeArguments());
                         expectedAlternativeCreatorTypeName =
                                 expectedAlternativeCreatorTypeName.replace("<" + type + ">", "");
                     }
diff --git a/service/Android.bp b/service/Android.bp
index 2adbb6ba..9f72bedf 100644
--- a/service/Android.bp
+++ b/service/Android.bp
@@ -37,7 +37,7 @@ java_library {
         // add StatsLog as a dependency of the generated file.
         "framework-statsd.stubs.module_lib",
     ],
-    sdk_version: "system_server_current",
+    sdk_version: "module_current",
     min_sdk_version: "Tiramisu",
     apex_available: ["com.android.appsearch"],
 }
@@ -50,6 +50,8 @@ java_defaults {
     sdk_version: "system_server_current",
     min_sdk_version: "Tiramisu",
     static_libs: [
+        "com.android.appsearch.isolated_storage_service.aidl-java",
+        "com.android.isolated_storage_service.aidl-java",
         "icing-java-proto-lite",
         "libicing-java",
         "statslog-appsearch-lib",
@@ -64,6 +66,8 @@ java_defaults {
         "framework-configinfrastructure.stubs.module_lib",
         "framework-permission-s.stubs.module_lib",
         "framework-statsd.stubs.module_lib",
+        "framework-virtualization.stubs.module_lib",
+        "jspecify",
     ],
     optimize: {
         proguard_flags_files: ["proguard.flags"],
@@ -73,6 +77,7 @@ java_defaults {
         "framework-system-server-module-optimize-defaults",
     ],
     permitted_packages: [
+        "com.android.isolated_storage_service",
         "com.android.server.appsearch",
         "com.google.android.icing",
     ],
diff --git a/service/java/com/android/server/appsearch/AppSearchManagerService.java b/service/java/com/android/server/appsearch/AppSearchManagerService.java
index 3104c499..e5142808 100644
--- a/service/java/com/android/server/appsearch/AppSearchManagerService.java
+++ b/service/java/com/android/server/appsearch/AppSearchManagerService.java
@@ -16,7 +16,6 @@
 package com.android.server.appsearch;
 
 import static android.app.appsearch.AppSearchResult.RESULT_DENIED;
-import static android.app.appsearch.AppSearchResult.RESULT_INVALID_ARGUMENT;
 import static android.app.appsearch.AppSearchResult.RESULT_NOT_FOUND;
 import static android.app.appsearch.AppSearchResult.RESULT_OK;
 import static android.app.appsearch.AppSearchResult.RESULT_RATE_LIMITED;
@@ -89,6 +88,7 @@ import android.app.appsearch.aidl.UnregisterObserverCallbackAidlRequest;
 import android.app.appsearch.aidl.WriteSearchResultsToFileAidlRequest;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.safeparcel.GenericDocumentParcel;
+import android.app.appsearch.stats.BaseStats;
 import android.app.appsearch.stats.SchemaMigrationStats;
 import android.app.appsearch.util.ExceptionUtil;
 import android.app.appsearch.util.LogUtil;
@@ -146,6 +146,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -162,6 +163,10 @@ public class AppSearchManagerService extends SystemService {
     @VisibleForTesting
     static final String SYSTEM_UI_INTELLIGENCE = "android.app.role.SYSTEM_UI_INTELLIGENCE";
 
+    // TODO(b/401245113) make it configurable.
+    // BatchPut flush conditions.
+    private static final int MAX_NUMBER_OF_DOCS_BUFFERED = 50;
+
     /**
      * An executor for system activity not tied to any particular user.
      *
@@ -524,11 +529,13 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                         instance.getLogger().logStats(setSchemaStatsBuilder
                                 .setStatusCode(statusCode)
                                 .setSchemaMigrationCallType(request.getSchemaMigrationCallType())
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -623,6 +630,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -694,6 +702,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -732,7 +741,9 @@ public class AppSearchManagerService extends SystemService {
                 AppSearchUserInstance instance = null;
                 int operationSuccessCount = 0;
                 int operationFailureCount = 0;
-                List<GenericDocument> takenActionGenericDocuments = null;  // initialize later
+                // initialize later.
+                // This is only used for logging stats.
+                List<GenericDocument> takenActionGenericDocuments = null;
 
                 try {
                     AppSearchBatchResult.Builder<String, Void> resultBuilder =
@@ -742,65 +753,138 @@ public class AppSearchManagerService extends SystemService {
                             request.getDocumentsParcel().getDocumentParcels();
                     List<GenericDocumentParcel> takenActionDocumentParcels =
                             request.getDocumentsParcel().getTakenActionGenericDocumentParcels();
-
-                    // Write GenericDocument of general documents
-                    for (int i = 0; i < documentParcels.size(); i++) {
-                        GenericDocument document = new GenericDocument(documentParcels.get(i));
-                        try {
-                            instance.getAppSearchImpl().putDocument(
-                                    callingPackageName,
-                                    request.getDatabaseName(),
-                                    document,
-                                    /* sendChangeNotifications= */ true,
-                                    instance.getLogger());
-                            resultBuilder.setSuccess(document.getId(), /* value= */ null);
-                            ++operationSuccessCount;
-                        } catch (AppSearchException | RuntimeException e) {
-                            // We don't rethrow here, so we can keep trying with the
-                            // following documents.
-                            AppSearchResult<Void> result = throwableToFailedResult(e);
-                            resultBuilder.setResult(document.getId(), result);
-                            // Since we can only include one status code in the atom,
-                            // for failures, we would just save the one for the last failure
-                            statusCode = result.getResultCode();
-                            ++operationFailureCount;
-                        }
-                    }
-
                     // Write GenericDocument of taken actions
                     if (!takenActionDocumentParcels.isEmpty()) {
                         takenActionGenericDocuments =
                                 new ArrayList<>(takenActionDocumentParcels.size());
                     }
-                    for (int i = 0; i < takenActionDocumentParcels.size(); i++) {
-                        GenericDocument document =
-                                new GenericDocument(takenActionDocumentParcels.get(i));
-                        takenActionGenericDocuments.add(document);
-                        try {
-                            instance.getAppSearchImpl().putDocument(
+
+                    // Write GenericDocument of general documents
+                    if (!Flags.enableBatchPut()) {
+                        for (int i = 0; i < documentParcels.size(); i++) {
+                            GenericDocument document = new GenericDocument(documentParcels.get(i));
+                            try {
+                                instance.getAppSearchImpl().putDocument(
+                                        callingPackageName,
+                                        request.getDatabaseName(),
+                                        document,
+                                        /* sendChangeNotifications= */ true,
+                                        instance.getLogger());
+                                resultBuilder.setSuccess(document.getId(), /* value= */ null);
+                                ++operationSuccessCount;
+                            } catch (AppSearchException | RuntimeException e) {
+                                // We don't rethrow here, so we can keep trying with the
+                                // following documents.
+                                AppSearchResult<Void> result = throwableToFailedResult(e);
+                                resultBuilder.setResult(document.getId(), result);
+                                // Since we can only include one status code in the atom,
+                                // for failures, we would just save the one for the last failure
+                                statusCode = result.getResultCode();
+                                ++operationFailureCount;
+                            }
+                        }
+
+                        for (int i = 0; i < takenActionDocumentParcels.size(); i++) {
+                            GenericDocument document =
+                                    new GenericDocument(takenActionDocumentParcels.get(i));
+                            takenActionGenericDocuments.add(document);
+                            try {
+                                instance.getAppSearchImpl().putDocument(
+                                        callingPackageName,
+                                        request.getDatabaseName(),
+                                        document,
+                                        /* sendChangeNotifications= */ true,
+                                        instance.getLogger());
+                                resultBuilder.setSuccess(document.getId(), /* value= */ null);
+                                ++operationSuccessCount;
+                            } catch (AppSearchException | RuntimeException e) {
+                                // We don't rethrow here, so we can keep trying with the
+                                // following documents.
+                                AppSearchResult<Void> result = throwableToFailedResult(e);
+                                resultBuilder.setResult(document.getId(), result);
+                                // Since we can only include one status code in the atom,
+                                // for failures, we would just save the one for the last failure
+                                statusCode = result.getResultCode();
+                                ++operationFailureCount;
+                            }
+                        }
+
+                        // Now that the batch has been written. Persist the newly written data.
+                        instance.getAppSearchImpl().persistToDisk(PersistType.Code.LITE);
+                    } else {
+                        if (!documentParcels.isEmpty() || !takenActionDocumentParcels.isEmpty()) {
+                            // List to hold the current batch.
+                            List<GenericDocument> currentBatch = new ArrayList<>();
+                            // The lock is held in AppSearchImpl.batchPutDocuments. To avoid holding
+                            // it for too long, we divide the documents into smaller batches. We
+                            // flush whenever we reach MAX_NUMBER_OF_DOCS_BUFFERED.
+                            // We also need to limit the # of bytes we send to the
+                            // isolated_storage_service, and it is currently done in AppSearchImpl
+                            // as it is easier to get the byte size from the proto directly.
+                            for (int i = 0; i < documentParcels.size(); i++) {
+                                if (currentBatch.size() >= MAX_NUMBER_OF_DOCS_BUFFERED) {
+                                    instance.getAppSearchImpl().batchPutDocuments(
+                                            callingPackageName,
+                                            request.getDatabaseName(),
+                                            currentBatch,
+                                            resultBuilder,
+                                            /* sendChangeNotifications=*/ true,
+                                            instance.getLogger(),
+                                            PersistType.Code.UNKNOWN);
+                                    currentBatch.clear();
+                                }
+                                currentBatch.add(new GenericDocument(documentParcels.get(i)));
+                            }
+                            for (int i = 0; i < takenActionDocumentParcels.size(); i++) {
+                                if (currentBatch.size() >= MAX_NUMBER_OF_DOCS_BUFFERED) {
+                                    instance.getAppSearchImpl().batchPutDocuments(
+                                            callingPackageName,
+                                            request.getDatabaseName(),
+                                            currentBatch,
+                                            resultBuilder,
+                                            /* sendChangeNotifications=*/ true,
+                                            instance.getLogger(),
+                                            PersistType.Code.UNKNOWN);
+                                    currentBatch.clear();
+                                }
+                                GenericDocument document = new GenericDocument(
+                                        takenActionDocumentParcels.get(i));
+                                takenActionGenericDocuments.add(document);
+                                currentBatch.add(document);
+                            }
+                            // flush the last batch with PersistType.Code.LITE.
+                            instance.getAppSearchImpl().batchPutDocuments(
                                     callingPackageName,
                                     request.getDatabaseName(),
-                                    document,
-                                    /* sendChangeNotifications= */ true,
-                                    instance.getLogger());
-                            resultBuilder.setSuccess(document.getId(), /* value= */ null);
-                            ++operationSuccessCount;
-                        } catch (AppSearchException | RuntimeException e) {
-                            // We don't rethrow here, so we can keep trying with the
-                            // following documents.
-                            AppSearchResult<Void> result = throwableToFailedResult(e);
-                            resultBuilder.setResult(document.getId(), result);
-                            // Since we can only include one status code in the atom,
-                            // for failures, we would just save the one for the last failure
-                            statusCode = result.getResultCode();
-                            ++operationFailureCount;
+                                    currentBatch,
+                                    resultBuilder,
+                                    /* sendChangeNotifications=*/ true,
+                                    instance.getLogger(),
+                                    PersistType.Code.LITE);
+                        }
+                    }
+
+                    // For batch put, we need to set the right operations metrics from
+                    // the batchResult.
+                    AppSearchBatchResult<String, Void> batchResult = resultBuilder.build();
+                    if (Flags.enableBatchPut()) {
+                        // reports the success/failure count. For batchPut, those two are not set
+                        // at this point.
+                        operationSuccessCount += batchResult.getSuccesses().size();
+
+                        // Handle failures.
+                        Map<String, AppSearchResult<Void>> failures = batchResult.getFailures();
+                        operationFailureCount += failures.size();
+                        // Previously we use the last failure to set the status code,
+                        // now we use the first id we get from the map.
+                        for (String id : failures.keySet()) {
+                            statusCode = failures.get(id).getResultCode();
+                            break;
                         }
                     }
 
-                    // Now that the batch has been written. Persist the newly written data.
-                    instance.getAppSearchImpl().persistToDisk(PersistType.Code.LITE);
                     invokeCallbackOnResult(callback, AppSearchBatchResultParcel
-                            .fromStringToVoid(resultBuilder.build()));
+                            .fromStringToVoid(batchResult));
 
                     // Schedule a task to dispatch change notifications. See requirements for where
                     // the method is called documented in the method description.
@@ -838,6 +922,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
 
                         // Extract metrics from taken action generic documents and add log.
@@ -847,7 +932,8 @@ public class AppSearchManagerService extends SystemService {
                                     .logStats(mSearchSessionStatsExtractor.extract(
                                             callingPackageName,
                                             request.getDatabaseName(),
-                                            takenActionGenericDocuments));
+                                            takenActionGenericDocuments,
+                                            instance.isVMEnabled()));
                         }
                     }
                 }
@@ -1007,6 +1093,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -1102,6 +1189,7 @@ public class AppSearchManagerService extends SystemService {
                                         estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -1199,6 +1287,7 @@ public class AppSearchManagerService extends SystemService {
                                         estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -1258,7 +1347,7 @@ public class AppSearchManagerService extends SystemService {
                                             callingDatabaseName,
                                             blobHandle);
                             resultBuilder.setSuccess(blobHandle, null);
-                        } catch (AppSearchException e) {
+                        } catch (AppSearchException | IOException e) {
                             AppSearchResult<Void> result =
                                     throwableToFailedResult(e);
                             resultBuilder.setResult(blobHandle, result);
@@ -1297,6 +1386,7 @@ public class AppSearchManagerService extends SystemService {
                                         estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
 
@@ -1407,6 +1497,7 @@ public class AppSearchManagerService extends SystemService {
                                         estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -1489,6 +1580,7 @@ public class AppSearchManagerService extends SystemService {
                                         estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -1569,6 +1661,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -1662,6 +1755,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -1760,7 +1854,8 @@ public class AppSearchManagerService extends SystemService {
                                 // http://dashboards/view/_72c98f9a_91d9_41d4_ab9a_bc14f79742b4
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
-                                .setNumOperationsFailed(operationFailureCount);
+                                .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled());
                         instance.getLogger().logStats(builder.build());
                         instance.getLogger().logStats(statsBuilder.build());
                     }
@@ -1832,6 +1927,7 @@ public class AppSearchManagerService extends SystemService {
                                     .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                     .setNumOperationsSucceeded(operationSuccessCount)
                                     .setNumOperationsFailed(operationFailureCount)
+                                    .setLaunchVMEnabled(instance.isVMEnabled())
                                     .build());
                         }
                     }
@@ -1927,6 +2023,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -2052,11 +2149,15 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
+                        long enabledFeatures = new BaseStats.Builder<>()
+                                .setLaunchVMEnabled(true).build().getEnabledFeatures();
                         instance.getLogger().logStats(schemaMigrationStatsBuilder
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
                                 .setSaveDocumentLatencyMillis(saveDocumentLatencyMillis)
+                                .setEnabledFeatures(enabledFeatures)
                                 .build());
                     }
                 }
@@ -2135,6 +2236,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -2231,6 +2333,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -2331,6 +2434,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -2416,6 +2520,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -2486,6 +2591,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -2550,6 +2656,7 @@ public class AppSearchManagerService extends SystemService {
                                     .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                     .setNumOperationsSucceeded(operationSuccessCount)
                                     .setNumOperationsFailed(operationFailureCount)
+                                    .setLaunchVMEnabled(instance.isVMEnabled())
                                     .build());
                         }
                     }
@@ -2647,6 +2754,7 @@ public class AppSearchManagerService extends SystemService {
                             .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                             .setNumOperationsSucceeded(operationSuccessCount)
                             .setNumOperationsFailed(operationFailureCount)
+                            .setLaunchVMEnabled(instance.isVMEnabled())
                             .build());
                 }
             }
@@ -2713,6 +2821,7 @@ public class AppSearchManagerService extends SystemService {
                             .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                             .setNumOperationsSucceeded(operationSuccessCount)
                             .setNumOperationsFailed(operationFailureCount)
+                            .setLaunchVMEnabled(instance.isVMEnabled())
                             .build());
                 }
             }
@@ -2779,6 +2888,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                                 .setNumOperationsSucceeded(operationSuccessCount)
                                 .setNumOperationsFailed(operationFailureCount)
+                                .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
                     }
                 }
@@ -2935,8 +3045,11 @@ public class AppSearchManagerService extends SystemService {
                     stats.dataSize +=
                             userStorageInfo.getSizeBytesForPackage(packageName);
                 } else {
-                    stats.dataSize += instance.getAppSearchImpl()
-                            .getStorageInfoForPackage(packageName).getSizeBytes();
+                    stats.dataSize +=
+                            instance.getAppSearchImpl()
+                                    .getStorageInfoForPackages(
+                                            new ArraySet<>(Collections.singleton(packageName)))
+                                    .getSizeBytes();
                 }
             } catch (AppSearchException | RuntimeException e) {
                 Log.e(
@@ -2976,10 +3089,11 @@ public class AppSearchManagerService extends SystemService {
                                 packagesForUid[i]);
                     }
                 } else {
-                    for (int i = 0; i < packagesForUid.length; i++) {
-                        stats.dataSize += instance.getAppSearchImpl()
-                                .getStorageInfoForPackage(packagesForUid[i]).getSizeBytes();
-                    }
+                    Set<String> packageNames = new ArraySet<>(packagesForUid);
+                    stats.dataSize +=
+                            instance.getAppSearchImpl()
+                                    .getStorageInfoForPackages(packageNames)
+                                    .getSizeBytes();
                 }
             } catch (AppSearchException | RuntimeException e) {
                 Log.e(TAG, "Unable to augment storage stats for uid " + uid, e);
@@ -3012,11 +3126,15 @@ public class AppSearchManagerService extends SystemService {
                     List<PackageInfo> packagesForUser = mPackageManager.getInstalledPackagesAsUser(
                             /* flags= */ 0, userHandle.getIdentifier());
                     if (packagesForUser != null) {
+                        Set<String> packageNames = new ArraySet<>();
                         for (int i = 0; i < packagesForUser.size(); i++) {
                             String packageName = packagesForUser.get(i).packageName;
-                            stats.dataSize += instance.getAppSearchImpl()
-                                    .getStorageInfoForPackage(packageName).getSizeBytes();
+                            packageNames.add(packageName);
                         }
+                        stats.dataSize +=
+                                instance.getAppSearchImpl()
+                                        .getStorageInfoForPackages(packageNames)
+                                        .getSizeBytes();
                     }
                 }
             } catch (AppSearchException | RuntimeException e) {
@@ -3140,11 +3258,11 @@ public class AppSearchManagerService extends SystemService {
     }
 
     private void checkUnsupportedEmbeddingUse(@NonNull List<AppSearchSchema> schemas) {
-        // Embedding support currently only allowed on W+. This is because embedding properties are
-        // a rollback compatibility issue. Therefore, we cannot allow it to be used on devices that
-        // could be rolled back to a pre-Embedding binary until we have landed rollback
-        // compatibility work.
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.BAKLAVA) {
+        // Embedding support currently only allowed on Baklava+. This is because embedding
+        // properties are a rollback compatibility issue. Therefore, we cannot allow it to be used
+        // on devices that could be rolled back to a pre-Embedding binary until we have landed
+        // rollback compatibility work.
+        if (isAtLeastBaklava()) {
             return;
         }
         for (int i = 0; i < schemas.size(); ++i) {
@@ -3162,11 +3280,11 @@ public class AppSearchManagerService extends SystemService {
     }
 
     private void checkUnsupportedEmbeddingUse(@NonNull SearchSpec spec) {
-        // Embedding support currently only allowed on W+. This is because embedding properties are
-        // a rollback compatibility issue. Therefore, we cannot allow it to be used on devices that
-        // could be rolled back to a pre-Embedding binary until we have landed rollback
-        // compatibility work.
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.BAKLAVA) {
+        // Embedding support currently only allowed on Baklava+. This is because embedding
+        // properties are a rollback compatibility issue. Therefore, we cannot allow it to be used
+        // on devices that could be rolled back to a pre-Embedding binary until we have landed
+        // rollback compatibility work.
+        if (isAtLeastBaklava()) {
             return;
         }
         if (!spec.getEmbeddingParameters().isEmpty()) {
@@ -3179,6 +3297,11 @@ public class AppSearchManagerService extends SystemService {
         }
     }
 
+    private static boolean isAtLeastBaklava() {
+        return Build.VERSION.SDK_INT >= 36
+                || (Build.VERSION.SDK_INT == 35 && Build.VERSION.CODENAME.equals("Baklava"));
+    }
+
     /**
      * Checks if an API call for a given calling package and calling database should be denied
      * according to the denylist. If the call is denied, also logs the denial through CallStats.
diff --git a/service/java/com/android/server/appsearch/AppSearchUserInstance.java b/service/java/com/android/server/appsearch/AppSearchUserInstance.java
index f76c8338..3e31f390 100644
--- a/service/java/com/android/server/appsearch/AppSearchUserInstance.java
+++ b/service/java/com/android/server/appsearch/AppSearchUserInstance.java
@@ -56,6 +56,11 @@ public final class AppSearchUserInstance {
         return mVisibilityChecker;
     }
 
+    /** Whether the pVM is enabled in AppSearch */
+    public boolean isVMEnabled() {
+        return mAppSearchImpl.isVMEnabled();
+    }
+
     @VisibleForTesting
     void setLoggerForTest(@NonNull InternalAppSearchLogger logger) {
         mLogger = Objects.requireNonNull(logger);
diff --git a/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java b/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java
index 6c5bf777..cd4ef3e3 100644
--- a/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java
+++ b/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java
@@ -16,6 +16,8 @@
 
 package com.android.server.appsearch;
 
+import static android.app.appsearch.AppSearchResult.RESULT_INTERNAL_ERROR;
+
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.appsearch.AppSearchEnvironmentFactory;
@@ -32,12 +34,16 @@ import com.android.internal.annotations.GuardedBy;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityChecker;
+import com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager;
+
+import com.google.android.icing.IcingSearchEngineInterface;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.concurrent.atomic.AtomicReference;
 
 /**
  * Manages the lifecycle of AppSearch classes that should only be initialized once per device-user
@@ -56,6 +62,10 @@ public final class AppSearchUserInstanceManager {
     @GuardedBy("mStorageInfoLocked")
     private final Map<UserHandle, UserStorageInfo> mStorageInfoLocked = new ArrayMap<>();
 
+    @GuardedBy("mIsolatedStorageServiceManagerLocked")
+    private final AtomicReference<IsolatedStorageServiceManager>
+            mIsolatedStorageServiceManagerLocked = new AtomicReference<>();
+
     private AppSearchUserInstanceManager() {}
 
     /**
@@ -223,7 +233,11 @@ public final class AppSearchUserInstanceManager {
                         .getAppSearchDir(userContext, userHandle);
         File icingDir = new File(appSearchDir, "icing");
         if (LogUtil.INFO) {
-            Log.i(TAG, "Creating new AppSearch instance at: " + icingDir);
+            if (IsolatedStorageServiceManager.useIsolatedStorage(userContext)) {
+                Log.i(TAG, "Creating new AppSearch instance in isolated storage.");
+            } else {
+                Log.i(TAG, "Creating new AppSearch instance at: " + icingDir);
+            }
         }
         VisibilityChecker visibilityCheckerImpl =
                 AppSearchComponentFactory.createVisibilityCheckerInstance(userContext);
@@ -239,6 +253,7 @@ public final class AppSearchUserInstanceManager {
                         initStatsBuilder,
                         visibilityCheckerImpl,
                         frameworkRevocableFileDescriptorStore,
+                        maybeGetIsolatedIcingSearchEngine(userContext, userHandle, config),
                         new ServiceOptimizeStrategy(config));
 
         // Update storage info file
@@ -252,4 +267,47 @@ public final class AppSearchUserInstanceManager {
 
         return new AppSearchUserInstance(logger, appSearchImpl, visibilityCheckerImpl);
     }
+
+    /**
+     * Gets the isolated icing engine for the user if isolated storage is enabled.
+     *
+     * @return IcingSearchEngineInterface or null if isolated storage is not enabled.
+     * @throws AppSearchException if isolated storage is enabled, but the isolated storage service
+     *     is unavailable or fails.
+     */
+    @Nullable
+    private IcingSearchEngineInterface maybeGetIsolatedIcingSearchEngine(
+            @NonNull Context userContext,
+            @NonNull UserHandle userHandle,
+            @NonNull ServiceAppSearchConfig config)
+            throws AppSearchException {
+        Objects.requireNonNull(userContext);
+        Objects.requireNonNull(userHandle);
+        Objects.requireNonNull(config);
+
+        if (!IsolatedStorageServiceManager.useIsolatedStorage(userContext)) {
+            Log.i(TAG, "Isolated storage is not enabled.");
+            return null;
+        }
+
+        IcingSearchEngineInterface icingInstance;
+        synchronized (mIsolatedStorageServiceManagerLocked) {
+            if (mIsolatedStorageServiceManagerLocked.get() == null) {
+                mIsolatedStorageServiceManagerLocked.set(
+                        new IsolatedStorageServiceManager(userContext, config));
+                mIsolatedStorageServiceManagerLocked.get().startIsolatedStorageService();
+            }
+            icingInstance =
+                    mIsolatedStorageServiceManagerLocked.get().getIcingInstance(userHandle, config);
+        }
+
+        // Enforce successful isolated storage creation when configured for use
+        if (icingInstance == null) {
+            Log.e(TAG, "Failed to get isolated storage instance!");
+            throw new AppSearchException(
+                    RESULT_INTERNAL_ERROR, "Failed to get isolated storage instance!");
+        }
+
+        return icingInstance;
+    }
 }
diff --git a/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptor.java b/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptor.java
new file mode 100644
index 00000000..6d77ef4c
--- /dev/null
+++ b/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptor.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch;
+
+import android.annotation.NonNull;
+import android.content.Context;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.ParcelFileDescriptor;
+import android.os.ProxyFileDescriptorCallback;
+import android.os.storage.StorageManager;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.system.OsConstants;
+
+import com.android.internal.annotations.GuardedBy;
+import com.android.server.appsearch.external.localstorage.AppSearchRevocableFileDescriptor;
+
+import libcore.io.IoUtils;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+
+/**
+ * The Variant of {@link ParcelFileDescriptor} that allows its creator to revoke all access to the
+ * underlying resource.
+ *
+ * <p>This is useful when the code that originally opened a file needs to strongly assert that any
+ * clients are completely hands-off for security purposes.
+ *
+ * <p>Copy from frameworks/base/core/java/android/os/RevocableFileDescriptor.java. We cannot use the
+ * RevocableFileDescriptor directly because it is not a public API.
+ *
+ * <p>This class needs {@link ProxyFileDescriptorCallback} and a {@link Handler} to build revocable
+ * file descriptors in AppSearch's server. Those could allow AppSearch's server side retain control
+ * of the original {@link ParcelFileDescriptor} and generate a revocable {@link
+ * ParcelFileDescriptor}. This RevocableFileDescriptor will be sent to the client. All operations
+ * performed on the RevocableFileDescriptor will not directly affect the actual file. Instead,
+ * AppSearch will monitor these operations on the RevocableFileDescriptor and apply them to the
+ * actual file. Consequently, AppSearch can revoke and disable the RevocableFileDescriptor on the
+ * client side at any time. These is not needed in the Jetpack since sent {@link
+ * ParcelFileDescriptor} to caller won't cross the Binder.
+ */
+public class FrameworkRevocableFileDescriptor implements AppSearchRevocableFileDescriptor {
+
+    private static final Object sLock = new Object();
+    // The name of the background thread for close listeners to run.
+    private static final String HANDLER_NAME = "AppSearchBlobCloseListener";
+
+    @GuardedBy("sLock")
+    private static volatile Handler sRevocableFdHandler;
+
+    /**
+     * By default, when using a RevocableFileDescriptor, callbacks will be sent to the process' main
+     * looper. In this case that would be system_server's main looper, which is a heavily contended
+     * thread. It can also cause deadlocks, because the volume daemon 'vold' holds a lock while
+     * making these callbacks to the system_server, while at the same time the system_server main
+     * thread can make a call into vold, which requires that same vold lock. To avoid these issues,
+     * use a separate thread for the RevocableFileDescriptor's requests, so that it can make
+     * progress independently of system_server.
+     */
+    @NonNull
+    static Handler getRevocableFdHandler() {
+        synchronized (sLock) {
+            if (sRevocableFdHandler != null) {
+                return sRevocableFdHandler;
+            }
+            final HandlerThread t = new HandlerThread(HANDLER_NAME);
+            t.start();
+            sRevocableFdHandler = new Handler(t.getLooper());
+
+            return sRevocableFdHandler;
+        }
+    }
+
+    private ParcelFileDescriptor.OnCloseListener mOnCloseListener;
+    private int mMode;
+
+    private final FileDescriptor mInner;
+    private final ParcelFileDescriptor mOuter;
+
+    private volatile boolean mRevoked;
+
+    FrameworkRevocableFileDescriptor(@NonNull Context context, @NonNull FileDescriptor fd, int mode)
+            throws IOException {
+        mInner = fd;
+        StorageManager sm = context.getSystemService(StorageManager.class);
+        mOuter =
+                sm.openProxyFileDescriptor(
+                        ParcelFileDescriptor.MODE_READ_WRITE, mCallback, getRevocableFdHandler());
+        mMode = mode;
+    }
+
+    @Override
+    public int getMode() {
+        return mMode;
+    }
+
+    @Override
+    public ParcelFileDescriptor getRevocableFileDescriptor() {
+        return mOuter;
+    }
+
+    @Override
+    public void revoke() {
+        mRevoked = true;
+        IoUtils.closeQuietly(mInner);
+    }
+
+    @Override
+    public void setOnCloseListener(ParcelFileDescriptor.OnCloseListener onCloseListener) {
+        mOnCloseListener = onCloseListener;
+    }
+
+    public boolean isRevoked() {
+        return mRevoked;
+    }
+
+    private final ProxyFileDescriptorCallback mCallback =
+            new ProxyFileDescriptorCallback() {
+                private void checkRevoked() throws ErrnoException {
+                    if (mRevoked) {
+                        throw new ErrnoException("TAG", OsConstants.EPERM);
+                    }
+                }
+
+                @Override
+                public long onGetSize() throws ErrnoException {
+                    checkRevoked();
+                    return Os.fstat(mInner).st_size;
+                }
+
+                @Override
+                public int onRead(long offset, int size, byte[] data) throws ErrnoException {
+                    checkRevoked();
+                    int n = 0;
+                    while (n < size) {
+                        try {
+                            n += Os.pread(mInner, data, n, size - n, offset + n);
+                            break;
+                        } catch (InterruptedIOException e) {
+                            n += e.bytesTransferred;
+                        }
+                    }
+                    return n;
+                }
+
+                @Override
+                public int onWrite(long offset, int size, byte[] data) throws ErrnoException {
+                    checkRevoked();
+                    int n = 0;
+                    while (n < size) {
+                        try {
+                            n += Os.pwrite(mInner, data, n, size - n, offset + n);
+                            break;
+                        } catch (InterruptedIOException e) {
+                            n += e.bytesTransferred;
+                        }
+                    }
+                    return n;
+                }
+
+                @Override
+                public void onFsync() throws ErrnoException {
+                    checkRevoked();
+                    Os.fsync(mInner);
+                }
+
+                @Override
+                public void onRelease() {
+                    mRevoked = true;
+                    IoUtils.closeQuietly(mInner);
+                    if (mOnCloseListener != null) {
+                        mOnCloseListener.onClose(null);
+                    }
+                }
+            };
+}
diff --git a/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptorStore.java b/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptorStore.java
index bc77ac13..9efde34d 100644
--- a/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptorStore.java
+++ b/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptorStore.java
@@ -17,30 +17,13 @@
 package com.android.server.appsearch;
 
 import android.annotation.NonNull;
-import android.app.appsearch.AppSearchResult;
-import android.app.appsearch.exceptions.AppSearchException;
 import android.content.Context;
-import android.os.Handler;
-import android.os.HandlerThread;
 import android.os.ParcelFileDescriptor;
-import android.os.ProxyFileDescriptorCallback;
-import android.os.storage.StorageManager;
-import android.system.ErrnoException;
-import android.system.Os;
-import android.system.OsConstants;
-import android.util.ArrayMap;
 
-import com.android.internal.annotations.GuardedBy;
+import com.android.server.appsearch.external.localstorage.AppSearchRevocableFileDescriptor;
 import com.android.server.appsearch.external.localstorage.RevocableFileDescriptorStore;
 
-import libcore.io.IoUtils;
-
-import java.io.FileDescriptor;
 import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
 import java.util.Objects;
 
 /**
@@ -52,280 +35,22 @@ import java.util.Objects;
  * lose the control of that dup. We need wrap the {@link ParcelFileDescriptor} to a {@link
  * FrameworkRevocableFileDescriptor} to give us the ability the control the sending {@link
  * ParcelFileDescriptor}.
- *
- * <p>This class needs {@link ProxyFileDescriptorCallback} and a {@link Handler} to build revocable
- * file descriptors in AppSearch's server. Those could allow AppSearch's server side retain control
- * of the original {@link ParcelFileDescriptor} and generate a revocable {@link
- * ParcelFileDescriptor}. This RevocableFileDescriptor will be sent to the client. All operations
- * performed on the RevocableFileDescriptor will not directly affect the actual file. Instead,
- * AppSearch will monitor these operations on the RevocableFileDescriptor and apply them to the
- * actual file. Consequently, AppSearch can revoke and disable the RevocableFileDescriptor on the
- * client side at any time. These is not needed in the Jetpack since sent {@link
- * ParcelFileDescriptor} to caller won't cross the Binder.
  */
-public class FrameworkRevocableFileDescriptorStore implements RevocableFileDescriptorStore {
-    private static final Object sLock = new Object();
-    // The name of the background thread for close listeners to run.
-    private static final String HANDLER_NAME = "AppSearchBlobCloseListener";
-
-    @GuardedBy("sLock")
-    private static volatile Handler sRevocableFdHandler;
-
-    /**
-     * By default, when using a RevocableFileDescriptor, callbacks will be sent to the process' main
-     * looper. In this case that would be system_server's main looper, which is a heavily contended
-     * thread. It can also cause deadlocks, because the volume daemon 'vold' holds a lock while
-     * making these callbacks to the system_server, while at the same time the system_server main
-     * thread can make a call into vold, which requires that same vold lock. To avoid these issues,
-     * use a separate thread for the RevocableFileDescriptor's requests, so that it can make
-     * progress independently of system_server.
-     */
-    @NonNull
-    static Handler getRevocableFdHandler() {
-        synchronized (sLock) {
-            if (sRevocableFdHandler != null) {
-                return sRevocableFdHandler;
-            }
-            final HandlerThread t = new HandlerThread(HANDLER_NAME);
-            t.start();
-            sRevocableFdHandler = new Handler(t.getLooper());
-
-            return sRevocableFdHandler;
-        }
-    }
-
-    @GuardedBy("sLock")
-    // <packageName, List<sent fds> map to tracking all sent fds.
-    private final Map<String, List<FrameworkRevocableFileDescriptor>>
-            mSentAppSearchParcelFileDescriptorsLocked = new ArrayMap<>();
+public class FrameworkRevocableFileDescriptorStore extends RevocableFileDescriptorStore {
 
     @NonNull private final Context mContext;
 
-    @NonNull private final ServiceAppSearchConfig mConfig;
-
     public FrameworkRevocableFileDescriptorStore(
             @NonNull Context context, @NonNull ServiceAppSearchConfig config) {
+        super(config);
         mContext = Objects.requireNonNull(context);
-        mConfig = Objects.requireNonNull(config);
     }
 
-    /**
-     * Wraps the given {@link ParcelFileDescriptor} to {@link FrameworkRevocableFileDescriptor} to
-     * allow AppSearch to control the sending {@link ParcelFileDescriptor}'s life cycle.
-     *
-     * <p>AppSearch will retain control of the original {@link ParcelFileDescriptor} and generate a
-     * revocable {@link ParcelFileDescriptor} using {@link
-     * FrameworkRevocableFileDescriptor#getRevocableFileDescriptor()}. This RevocableFileDescriptor
-     * will be sent to the client. All operations performed on the RevocableFileDescriptor will not
-     * directly affect the actual file. Instead, AppSearch will monitor these operations on the
-     * RevocableFileDescriptor and apply them to the actual file. Consequently, AppSearch can revoke
-     * and disable the RevocableFileDescriptor on the client side at any time.
-     *
-     * @param packageName The package name requesting the revocable file descriptor.
-     * @param parcelFileDescriptor The original ParcelFileDescriptor to be wrapped.
-     */
     @NonNull
     @Override
-    public ParcelFileDescriptor wrapToRevocableFileDescriptor(
-            @NonNull String packageName, ParcelFileDescriptor parcelFileDescriptor)
-            throws IOException {
-        FrameworkRevocableFileDescriptor revocableFileDescriptor =
-                new FrameworkRevocableFileDescriptor(
-                        mContext,
-                        parcelFileDescriptor.getFileDescriptor(),
-                        getRevocableFdHandler());
-        addOnCloseListener(revocableFileDescriptor, packageName);
-        addToSentAppSearchParcelFileDescriptorMap(revocableFileDescriptor, packageName);
-        return revocableFileDescriptor.getRevocableFileDescriptor();
-    }
-
-    @Override
-    public void revokeAll() throws IOException {
-        synchronized (sLock) {
-            for (String packageName : mSentAppSearchParcelFileDescriptorsLocked.keySet()) {
-                revokeForPackage(packageName);
-            }
-        }
-    }
-
-    @Override
-    public void revokeForPackage(@NonNull String packageName) throws IOException {
-        synchronized (sLock) {
-            List<FrameworkRevocableFileDescriptor> rfds =
-                    mSentAppSearchParcelFileDescriptorsLocked.get(packageName);
-            if (rfds != null) {
-                for (int i = rfds.size() - 1; i >= 0; i--) {
-                    rfds.get(i).revoke();
-                }
-            }
-        }
-    }
-
-    @Override
-    public void checkBlobStoreLimit(@NonNull String packageName) throws AppSearchException {
-        synchronized (sLock) {
-            List<FrameworkRevocableFileDescriptor> rfdsForPackage =
-                    mSentAppSearchParcelFileDescriptorsLocked.get(packageName);
-            if (rfdsForPackage == null) {
-                return;
-            }
-            if (rfdsForPackage.size() >= mConfig.getMaxOpenBlobCount()) {
-                throw new AppSearchException(
-                        AppSearchResult.RESULT_OUT_OF_SPACE,
-                        "Package \""
-                                + packageName
-                                + "\" exceeded limit of "
-                                + mConfig.getMaxOpenBlobCount()
-                                + " opened file descriptors. Some file descriptors "
-                                + "must be closed to open additional ones.");
-            }
-        }
-    }
-
-    private void addOnCloseListener(
-            @NonNull FrameworkRevocableFileDescriptor revocableFileDescriptor,
-            @NonNull String packageName) {
-        revocableFileDescriptor.addOnCloseListener(
-                e -> {
-                    synchronized (sLock) {
-                        List<FrameworkRevocableFileDescriptor> fdsForPackage =
-                                mSentAppSearchParcelFileDescriptorsLocked.get(packageName);
-                        if (fdsForPackage != null) {
-                            fdsForPackage.remove(revocableFileDescriptor);
-                            if (fdsForPackage.isEmpty()) {
-                                mSentAppSearchParcelFileDescriptorsLocked.remove(packageName);
-                            }
-                        }
-                    }
-                });
-    }
-
-    private void addToSentAppSearchParcelFileDescriptorMap(
-            @NonNull FrameworkRevocableFileDescriptor revocableFileDescriptor,
-            @NonNull String packageName) {
-        synchronized (sLock) {
-            List<FrameworkRevocableFileDescriptor> rfdsForPackage =
-                    mSentAppSearchParcelFileDescriptorsLocked.get(packageName);
-            if (rfdsForPackage == null) {
-                rfdsForPackage = new ArrayList<>();
-                mSentAppSearchParcelFileDescriptorsLocked.put(packageName, rfdsForPackage);
-            }
-            rfdsForPackage.add(revocableFileDescriptor);
-        }
-    }
-
-    /**
-     * The Variant of {@link ParcelFileDescriptor} that allows its creator to revoke all access to
-     * the underlying resource.
-     *
-     * <p>This is useful when the code that originally opened a file needs to strongly assert that
-     * any clients are completely hands-off for security purposes.
-     *
-     * <p>Copy from frameworks/base/core/java/android/os/RevocableFileDescriptor.java. We cannot use
-     * the RevocableFileDescriptor directly because it is not a public API.
-     */
-    static class FrameworkRevocableFileDescriptor {
-        private ParcelFileDescriptor.OnCloseListener mOnCloseListener;
-
-        private final FileDescriptor mInner;
-        private final ParcelFileDescriptor mOuter;
-
-        private volatile boolean mRevoked;
-
-        FrameworkRevocableFileDescriptor(
-                @NonNull Context context, @NonNull FileDescriptor fd, @NonNull Handler handler)
-                throws IOException {
-            mInner = fd;
-            StorageManager sm = context.getSystemService(StorageManager.class);
-            mOuter =
-                    sm.openProxyFileDescriptor(
-                            ParcelFileDescriptor.MODE_READ_WRITE, mCallback, handler);
-        }
-
-        ParcelFileDescriptor getRevocableFileDescriptor() {
-            return mOuter;
-        }
-
-        /**
-         * Revoke all future access to the {@link ParcelFileDescriptor} returned by {@link
-         * #getRevocableFileDescriptor()}. From this point forward, all operations will fail with
-         * {@link OsConstants#EPERM}.
-         */
-        void revoke() {
-            mRevoked = true;
-            IoUtils.closeQuietly(mInner);
-        }
-
-        /**
-         * Callback for indicating that {@link ParcelFileDescriptor} passed to the client process
-         * ({@link #getRevocableFileDescriptor()}) has been closed.
-         */
-        void addOnCloseListener(ParcelFileDescriptor.OnCloseListener onCloseListener) {
-            mOnCloseListener = onCloseListener;
-        }
-
-        public boolean isRevoked() {
-            return mRevoked;
-        }
-
-        private final ProxyFileDescriptorCallback mCallback =
-                new ProxyFileDescriptorCallback() {
-                    private void checkRevoked() throws ErrnoException {
-                        if (mRevoked) {
-                            throw new ErrnoException("TAG", OsConstants.EPERM);
-                        }
-                    }
-
-                    @Override
-                    public long onGetSize() throws ErrnoException {
-                        checkRevoked();
-                        return Os.fstat(mInner).st_size;
-                    }
-
-                    @Override
-                    public int onRead(long offset, int size, byte[] data) throws ErrnoException {
-                        checkRevoked();
-                        int n = 0;
-                        while (n < size) {
-                            try {
-                                n += Os.pread(mInner, data, n, size - n, offset + n);
-                                break;
-                            } catch (InterruptedIOException e) {
-                                n += e.bytesTransferred;
-                            }
-                        }
-                        return n;
-                    }
-
-                    @Override
-                    public int onWrite(long offset, int size, byte[] data) throws ErrnoException {
-                        checkRevoked();
-                        int n = 0;
-                        while (n < size) {
-                            try {
-                                n += Os.pwrite(mInner, data, n, size - n, offset + n);
-                                break;
-                            } catch (InterruptedIOException e) {
-                                n += e.bytesTransferred;
-                            }
-                        }
-                        return n;
-                    }
-
-                    @Override
-                    public void onFsync() throws ErrnoException {
-                        checkRevoked();
-                        Os.fsync(mInner);
-                    }
-
-                    @Override
-                    public void onRelease() {
-                        mRevoked = true;
-                        IoUtils.closeQuietly(mInner);
-                        if (mOnCloseListener != null) {
-                            mOnCloseListener.onClose(null);
-                        }
-                    }
-                };
+    public AppSearchRevocableFileDescriptor wrapToRevocableFileDescriptor(
+            @NonNull ParcelFileDescriptor parcelFileDescriptor, int mode) throws IOException {
+        return new FrameworkRevocableFileDescriptor(
+                mContext, parcelFileDescriptor.getFileDescriptor(), mode);
     }
 }
diff --git a/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java b/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java
index 21f44629..95128cdb 100644
--- a/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java
+++ b/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java
@@ -16,7 +16,9 @@
 
 package com.android.server.appsearch;
 
-import android.annotation.NonNull;
+import static com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager.DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE;
+import static com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager.isolatedStorageFlagsSet;
+
 import android.os.Build;
 import android.os.Bundle;
 import android.provider.DeviceConfig;
@@ -25,6 +27,11 @@ import android.provider.DeviceConfig.OnPropertiesChangedListener;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.external.localstorage.IcingOptionsConfig;
+import com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager;
+
+import com.google.android.icing.proto.PersistType;
+
+import org.jspecify.annotations.NonNull;
 
 import java.util.Objects;
 import java.util.concurrent.Executor;
@@ -66,6 +73,8 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
             "sampling_interval_for_optimize_stats";
     public static final String KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES =
             "limit_config_max_document_size_bytes";
+    public static final String KEY_LIMIT_CONFIG_MAX_BYTE_LIMIT_BATCH_PUT =
+            "limit_config_max_byte_limit_batch_put";
     public static final String KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT =
             "limit_config_per_package_document_count_limit";
     public static final String KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD =
@@ -113,6 +122,8 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
     public static final String KEY_FULLY_PERSIST_JOB_INTERVAL = "fully_persist_job_interval";
     public static final String KEY_MAX_OPEN_BLOB_COUNT = "max_open_blob_count";
     public static final String KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS = "orphan_blob_time_to_live_ms";
+    public static final String ISOLATED_STORAGE_MEMORY_BYTES = "isolated_storage_memory_bytes";
+    public static final String KEY_LIGHTWEIGHT_PERSIST_TYPE = "lightweight_persist_type";
 
     /**
      * This config does not need to be cached in FrameworkServiceAppSearchConfig as it is only
@@ -162,7 +173,8 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         KEY_APP_FUNCTION_CALL_TIMEOUT_MILLIS,
         KEY_FULLY_PERSIST_JOB_INTERVAL,
         KEY_MAX_OPEN_BLOB_COUNT,
-        KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS
+        KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS,
+        KEY_LIGHTWEIGHT_PERSIST_TYPE
     };
 
     // Lock needed for all the operations in this class.
@@ -366,6 +378,16 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         }
     }
 
+    @Override
+    public int getMaxByteLimitForBatchPut() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            return mBundleLocked.getInt(
+                    KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES,
+                    DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES);
+        }
+    }
+
     @Override
     public int getPerPackageDocumentCountLimit() {
         synchronized (mLock) {
@@ -437,7 +459,7 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
             throwIfClosedLocked();
             return mBundleLocked.getInt(
                     KEY_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS,
-                    DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS);
+                    defaultMinTimeOptimizeThresholdMillis());
         }
     }
 
@@ -546,9 +568,14 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
     public int getMaxPageBytesLimit() {
         synchronized (mLock) {
             throwIfClosedLocked();
-            return mBundleLocked.getInt(
-                    KEY_ICING_MAX_PAGE_BYTES_LIMIT,
-                    IcingOptionsConfig.DEFAULT_MAX_PAGE_BYTES_LIMIT);
+            // TODO: b/389105038 - remove the temporary workaround for binder transaction
+            //  limit.
+            int defaultMaxPageBytesLimit = IcingOptionsConfig.DEFAULT_MAX_PAGE_BYTES_LIMIT;
+            if (isolatedStorageFlagsSet()) {
+                // It's very likely we are using pVM backed isolated storage now.
+                defaultMaxPageBytesLimit = DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE;
+            }
+            return mBundleLocked.getInt(KEY_ICING_MAX_PAGE_BYTES_LIMIT, defaultMaxPageBytesLimit);
         }
     }
 
@@ -638,6 +665,23 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         }
     }
 
+    // The absolute path for the ICU data file is not available in Framework.
+    // This method is functionally no-op and returns an empty string.
+    @Override
+    public @NonNull String getIcuDataFileAbsolutePath() {
+        return DEFAULT_ICU_DATA_FILE_ABSOLUTE_PATH;
+    }
+
+    @Override
+    public long getIsolatedStorageMemoryBytes() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            return mBundleLocked.getLong(
+                    ISOLATED_STORAGE_MEMORY_BYTES,
+                    IsolatedStorageServiceManager.DEFAULT_MEMORY_BYTES);
+        }
+    }
+
     @Override
     public boolean shouldStoreParentInfoAsSyntheticProperty() {
         // This option is always true in Framework.
@@ -653,6 +697,17 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         }
     }
 
+    @Override
+    public PersistType.@NonNull Code getLightweightPersistType() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            int val =
+                mBundleLocked.getInt(
+                    KEY_LIGHTWEIGHT_PERSIST_TYPE, defaultLightweightPersistType().getNumber());
+            return PersistType.Code.forNumber(val);
+        }
+    }
+
     @GuardedBy("mLock")
     private void throwIfClosedLocked() {
         if (mIsClosedLocked) {
@@ -660,7 +715,7 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         }
     }
 
-    private void updateCachedValues(@NonNull DeviceConfig.Properties properties) {
+    private void updateCachedValues(DeviceConfig.@NonNull Properties properties) {
         for (String key : properties.getKeyset()) {
             updateCachedValue(key, properties);
         }
@@ -668,7 +723,7 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
     }
 
     private void updateCachedValue(
-            @NonNull String key, @NonNull DeviceConfig.Properties properties) {
+            @NonNull String key, DeviceConfig.@NonNull Properties properties) {
         if (properties.getString(key, /* defaultValue= */ null) == null) {
             // Key is missing or value is just null. That is not expected if the key is
             // defined in the configuration.
@@ -702,6 +757,7 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
                 }
                 break;
             case KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES:
+            case KEY_LIMIT_CONFIG_MAX_BYTE_LIMIT_BATCH_PUT:
                 synchronized (mLock) {
                     mBundleLocked.putInt(
                             key,
@@ -752,8 +808,7 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
             case KEY_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS:
                 synchronized (mLock) {
                     mBundleLocked.putInt(
-                            key,
-                            properties.getInt(key, DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS));
+                            key, properties.getInt(key, defaultMinTimeOptimizeThresholdMillis()));
                 }
                 break;
             case KEY_API_CALL_STATS_LIMIT:
@@ -934,6 +989,24 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
                     mBundleLocked.putInt(key, properties.getInt(key, DEFAULT_MAX_OPEN_BLOB_COUNT));
                 }
                 break;
+            case ISOLATED_STORAGE_MEMORY_BYTES:
+                synchronized (mLock) {
+                    mBundleLocked.putLong(
+                            key,
+                            properties.getLong(
+                                    key, IsolatedStorageServiceManager.DEFAULT_MEMORY_BYTES));
+                }
+                break;
+            case KEY_LIGHTWEIGHT_PERSIST_TYPE:
+                synchronized (mLock) {
+                    int val = properties.getInt(key, defaultLightweightPersistType().getNumber());
+                    PersistType.Code code = PersistType.Code.forNumber(val);
+                    // Confirm that the provided value is actually valid. Otherwise, ignore.
+                    if (code != null && code != PersistType.Code.UNKNOWN) {
+                      mBundleLocked.putInt(key, val);
+                    }
+                }
+                break;
             case KEY_BUILD_PROPERTY_EXISTENCE_METADATA_HITS:
                 // TODO(b/309826655) Set this value properly in main branch
                 // fall throw to default since we never turn this feature on in udc-mainline-prod
diff --git a/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java b/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java
index 5ea7c140..ea54ea11 100644
--- a/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java
+++ b/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java
@@ -18,7 +18,15 @@ package com.android.server.appsearch;
 
 import static android.text.format.DateUtils.DAY_IN_MILLIS;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchConfig;
+import com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager;
+
+import com.google.android.icing.proto.PersistType;
+
+import org.jspecify.annotations.NonNull;
+
+import java.util.concurrent.TimeUnit;
 
 /**
  * An interface which exposes config flags to AppSearch.
@@ -50,9 +58,10 @@ public interface ServiceAppSearchConfig extends AppSearchConfig, AutoCloseable {
     int DEFAULT_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD = 2_000_000;
     int DEFAULT_LIMIT_CONFIG_MAX_SUGGESTION_COUNT = 20_000;
     int DEFAULT_BYTES_OPTIMIZE_THRESHOLD = 10 * 1024 * 1024; // 10 MiB
-    int DEFAULT_TIME_OPTIMIZE_THRESHOLD_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days in millis
+    int DEFAULT_TIME_OPTIMIZE_THRESHOLD_MILLIS = (int) TimeUnit.DAYS.toMillis(7);
     int DEFAULT_DOC_COUNT_OPTIMIZE_THRESHOLD = 10_000;
     int DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS = 0;
+    int DEFAULT_FOUR_HOUR_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS = (int) TimeUnit.HOURS.toMillis(4);
     // Cached API Call Stats is disabled by default
     int DEFAULT_API_CALL_STATS_LIMIT = 0;
     boolean DEFAULT_RATE_LIMIT_ENABLED = false;
@@ -202,6 +211,32 @@ public interface ServiceAppSearchConfig extends AppSearchConfig, AutoCloseable {
      */
     long getCachedFullyPersistJobIntervalMillis();
 
+    /** Returns the memory size in bytes for isolated storage. */
+    default long getIsolatedStorageMemoryBytes() {
+        return IsolatedStorageServiceManager.DEFAULT_MEMORY_BYTES;
+    }
+
+    /**
+     * Default min time interval between consecutive optimize calls in millis if there is no value
+     * set for {@link #getCachedMinTimeOptimizeThresholdMs()} in the flag system.
+     */
+    default int defaultMinTimeOptimizeThresholdMillis() {
+        // TODO (b/385020106): figure out how to make the default 0 timeSinceLastOptimize work
+        //  with a higher threshold and return 4 hours when
+        //  Flags.enable_four_hour_min_optimize_threshold is true
+        return DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS;
+    }
+
+    /**
+     * Default {@code PersistType.Code} that should be used to persist common mutations such as
+     * PUTs or DELETEs.
+     */
+    default PersistType.@NonNull Code defaultLightweightPersistType() {
+        return Flags.enableRecoveryProofPersistence()
+                ? PersistType.Code.RECOVERY_PROOF
+                : PersistType.Code.LITE;
+    }
+
     /**
      * Closes this {@link AppSearchConfig}.
      *
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParser.java b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParser.java
similarity index 54%
rename from service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParser.java
rename to service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParser.java
index 2613e235..a684c253 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParser.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParser.java
@@ -1,10 +1,25 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.android.server.appsearch.appsindexer;
 
 import android.annotation.NonNull;
 import android.app.appsearch.AppSearchSchema;
-import android.app.appsearch.GenericDocument;
 import android.content.pm.PackageManager;
 
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 
 import java.util.List;
@@ -14,12 +29,12 @@ import java.util.Map;
  * This class parses static metadata about App Functions from an XML file located within an app's
  * assets.
  *
- * <p>The generated {@link AppFunctionStaticMetadata} objects are inserted into AppSearch after a
- * successful {@link SyncAppSearchSession#setSchema} call under the {@link
+ * <p>The generated {@link android.app.appsearch.GenericDocument} objects are inserted into
+ * AppSearch after a successful {@link SyncAppSearchSession#setSchema} call under the {@link
  * AppSearchHelper#APP_DATABASE} database. Within the database, each {@link AppSearchSchema} is
  * named dynamically to be unique to the app package name.
  */
-public interface AppFunctionStaticMetadataParser {
+public interface AppFunctionDocumentParser {
     // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
     //  rolled out
     /**
@@ -43,7 +58,7 @@ public interface AppFunctionStaticMetadataParser {
      * @param packageManager The PackageManager used to access app resources.
      * @param packageName The package name of the app whose assets contain the XML file.
      * @param assetFilePath The path to the XML file within the app's assets.
-     * @return A mapping of function ids to their corresponding {@link AppFunctionStaticMetadata}
+     * @return A mapping of document ids to their corresponding {@link AppFunctionStaticMetadata}
      *     objects representing the parsed App Functions. An empty map is returned if there's an
      *     error during parsing.
      */
@@ -54,23 +69,28 @@ public interface AppFunctionStaticMetadataParser {
             @NonNull String assetFilePath);
 
     /**
-     * Parses static metadata about App Functions from the given XML asset file, using type
-     * information from the given schemas.
+     * Parses metadata about App Functions from the given XML asset file, using type information
+     * from the given schemas.
      *
-     * <p>Note: The root schema should have property with name {@link
-     * AppFunctionStaticMetadata#PROPERTY_FUNCTION_ID} to construct the mapping of function id to
-     * {@link AppFunctionStaticMetadata} else an empty map is returned.
+     * <p>Note: The following requirements must be met for successful parsing:
      *
-     * @param packageManager The PackageManager used to access app resources.
-     * @param packageName The package name of the app whose assets contain the XML file.
-     * @param assetFilePath The path to the XML file within the app's assets.
-     * @param schemas The mapping of schema types to their corresponding {@link AppSearchSchema}
+     * <ul>
+     *   <li>Each document must contain an `id` tag; otherwise, an empty map is returned.
+     *   <li>Root level schemas should always define `packageName` and
+     *       `mobileApplicationQualifiedId` for easy retrievals.
+     * </ul>
+     *
+     * @param packageManager the PackageManager used to access app resources.
+     * @param packageName the package name of the app whose assets contain the XML file.
+     * @param assetFilePath the path to the XML file within the app's assets.
+     * @param schemas the mapping of schema types to their corresponding {@link AppSearchSchema}
      *     objects.
-     * @return A mapping of function ids to their corresponding {@link AppFunctionStaticMetadata}
-     *     objects. An empty map is returned if there's an error during parsing.
+     * @return a mapping of document IDs to their corresponding {@link AppFunctionDocument} objects.
+     *     The returned document's schema type will match one of the provided schemas. Returns an
+     *     empty map if there's an error during parsing or if no `id` tags are found.
      */
     @NonNull
-    Map<String, AppFunctionStaticMetadata> parseIntoMapForGivenSchemas(
+    Map<String, AppFunctionDocument> parseIntoMapForGivenSchemas(
             @NonNull PackageManager packageManager,
             @NonNull String packageName,
             @NonNull String assetFilePath,
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImpl.java b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImpl.java
similarity index 76%
rename from service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImpl.java
rename to service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImpl.java
index c6eab15f..4ae77d8c 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImpl.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,11 +17,8 @@ package com.android.server.appsearch.appsindexer;
 
 import android.annotation.NonNull;
 import android.app.appsearch.AppSearchSchema;
-import android.app.appsearch.AppSearchSchema.BooleanPropertyConfig;
-import android.app.appsearch.AppSearchSchema.LongPropertyConfig;
-import android.app.appsearch.AppSearchSchema.PropertyConfig;
-import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
 import android.app.appsearch.AppSearchSchema.DocumentPropertyConfig;
+import android.app.appsearch.AppSearchSchema.PropertyConfig;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.util.LogUtil;
 import android.content.pm.PackageManager;
@@ -29,6 +26,7 @@ import android.content.res.AssetManager;
 import android.util.ArrayMap;
 import android.util.Log;
 
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 
 import org.xmlpull.v1.XmlPullParser;
@@ -47,10 +45,12 @@ import java.util.Objects;
  * This class parses static metadata about App Functions from an XML file located within an app's
  * assets.
  */
-public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMetadataParser {
+public class AppFunctionDocumentParserImpl implements AppFunctionDocumentParser {
     private static final String TAG = "AppSearchMetadataParser";
     private static final String XML_TAG_APPFUNCTION = "appfunction";
     private static final String XML_TAG_APPFUNCTIONS_ROOT = "appfunctions";
+    private static final String XML_TAG_ID = "id";
+    private static final String SNAKE_CASE_SEPARATOR = "_";
 
     @NonNull private final String mIndexerPackageName;
     private final int mMaxAppFunctions;
@@ -58,13 +58,12 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
     /**
      * @param indexerPackageName the name of the package performing the indexing. This should be the
      *     same as the package running the apps indexer.
-     * @param maxAppFunctions The maximum number of app functions to be parsed per app. The parser
-     *     will stop once it exceeds the limit.
+     * @param config the app indexer config used to enforce various limits during parsing.
      */
-    public AppFunctionStaticMetadataParserImpl(
-            @NonNull String indexerPackageName, int maxAppFunctions) {
+    public AppFunctionDocumentParserImpl(
+            @NonNull String indexerPackageName, AppsIndexerConfig config) {
         mIndexerPackageName = Objects.requireNonNull(indexerPackageName);
-        mMaxAppFunctions = maxAppFunctions;
+        mMaxAppFunctions = config.getMaxAppFunctionsPerPackage();
     }
 
     // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
@@ -189,7 +188,7 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
             String tagName = parser.getName();
             if (eventType == XmlPullParser.START_TAG && XML_TAG_APPFUNCTION.equals(tagName)) {
                 AppFunctionStaticMetadata appFunction = parseAppFunction(parser, packageName);
-                appFunctions.put(appFunction.getFunctionId(), appFunction);
+                appFunctions.put(appFunction.getId(), appFunction);
                 if (appFunctions.size() >= mMaxAppFunctions) {
                     Log.d(TAG, "Exceeding the max number of app functions: " + packageName);
                     return appFunctions;
@@ -224,28 +223,28 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
             if (eventType == XmlPullParser.START_TAG
                     && !XML_TAG_APPFUNCTION.equals(parser.getName())) {
                 String tagName = parser.getName();
-                String tagValue = parser.nextText().trim();
                 switch (tagName) {
                     case "function_id":
-                        functionId = tagValue;
+                        functionId = parser.nextText().trim();
                         break;
                     case "schema_name":
-                        schemaName = tagValue;
+                        schemaName = parser.nextText().trim();
                         break;
                     case "schema_version":
-                        schemaVersion = Long.parseLong(tagValue);
+                        schemaVersion = Long.parseLong(parser.nextText().trim());
                         break;
                     case "schema_category":
-                        schemaCategory = tagValue;
+                        schemaCategory = parser.nextText().trim();
                         break;
                     case "enabled_by_default":
-                        enabledByDefault = Boolean.parseBoolean(tagValue);
+                        enabledByDefault = Boolean.parseBoolean(parser.nextText().trim());
                         break;
                     case "restrict_callers_with_execute_app_functions":
-                        restrictCallersWithExecuteAppFunctions = Boolean.parseBoolean(tagValue);
+                        restrictCallersWithExecuteAppFunctions =
+                                Boolean.parseBoolean(parser.nextText().trim());
                         break;
                     case "display_name_string_res":
-                        displayNameStringRes = Integer.parseInt(tagValue);
+                        displayNameStringRes = Integer.parseInt(parser.nextText().trim());
                         break;
                 }
             }
@@ -281,7 +280,7 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
 
     @NonNull
     @Override
-    public Map<String, AppFunctionStaticMetadata> parseIntoMapForGivenSchemas(
+    public Map<String, AppFunctionDocument> parseIntoMapForGivenSchemas(
             @NonNull PackageManager packageManager,
             @NonNull String packageName,
             @NonNull String assetFilePath,
@@ -310,7 +309,7 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
     }
 
     @NonNull
-    private Map<String, AppFunctionStaticMetadata> parseAppFunctionsIntoMapForGivenSchemas(
+    private Map<String, AppFunctionDocument> parseAppFunctionsIntoMapForGivenSchemas(
             @NonNull XmlPullParser parser,
             @NonNull String packageName,
             @NonNull Map<String, AppSearchSchema> schemas)
@@ -319,7 +318,7 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         Objects.requireNonNull(packageName);
         Objects.requireNonNull(schemas);
 
-        Map<String, AppFunctionStaticMetadata> appFnMetadatas = new ArrayMap<>();
+        Map<String, AppFunctionDocument> appFnMetadatas = new ArrayMap<>();
 
         Map<String, PropertyConfig> qualifiedPropertyNamesToPropertyConfig =
                 buildQualifiedPropertyNameToPropertyConfigMap(schemas);
@@ -328,23 +327,28 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
 
         while (eventType != XmlPullParser.END_DOCUMENT) {
             String tagName = parser.getName();
-            String schemaName =
-                    AppFunctionStaticMetadata.getSchemaNameForPackage(packageName, tagName);
-            if (eventType == XmlPullParser.START_TAG && schemas.containsKey(schemaName)) {
-                GenericDocument appFnMetadata =
-                        parseXmlElementToGenericDocument(
-                                parser,
-                                packageName,
-                                tagName,
-                                qualifiedPropertyNamesToPropertyConfig);
-                if (appFnMetadata != null) {
-                    appFnMetadatas.put(
-                            appFnMetadata.getPropertyString(
-                                    AppFunctionStaticMetadata.PROPERTY_FUNCTION_ID),
-                            new AppFunctionStaticMetadata(appFnMetadata));
-                } else if (!XML_TAG_APPFUNCTIONS_ROOT.equals(tagName)) {
-                    throw new XmlPullParserException("Unknwown tag: " + tagName);
-                }
+            // In previous document formats <appfunction> XML tag was used for denoting
+            // AppFunctionStaticMetadata type.
+            String schemaType =
+                    XML_TAG_APPFUNCTION.equals(tagName)
+                            ? AppFunctionStaticMetadata.SCHEMA_TYPE
+                            : tagName;
+            String schemaNameForPackage =
+                    AppFunctionDocument.getSchemaNameForPackage(packageName, schemaType);
+            if (eventType == XmlPullParser.START_TAG && schemas.containsKey(schemaNameForPackage)) {
+                // Id of the document will be set after parsing the value from xml.
+                AppFunctionDocument.Builder appFnDocBuilder =
+                        new AppFunctionDocument.Builder(
+                                packageName, "", mIndexerPackageName, schemaType);
+                buildGenericDocumentFromXmlElement(
+                        parser,
+                        packageName,
+                        schemaNameForPackage,
+                        qualifiedPropertyNamesToPropertyConfig,
+                        appFnDocBuilder);
+
+                AppFunctionDocument appFunctionDocument = appFnDocBuilder.build();
+                appFnMetadatas.put(appFunctionDocument.getId(), appFunctionDocument);
                 if (appFnMetadatas.size() >= mMaxAppFunctions) {
                     if (LogUtil.DEBUG) {
                         Log.d(TAG, "Exceeding the max number of app functions: " + packageName);
@@ -358,62 +362,78 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
     }
 
     /**
-     * Tries to parse a single XML element into a {@link GenericDocument} object.
+     * Tries to parse a single XML element and populate the {@link GenericDocument.Builder} object
+     * recursively.
+     *
+     * <p>When this function is called the parser should point to the xml element that marks the
+     * beginning of the {@link GenericDocument}, and would point to the end tag of the corresponding
+     * doc once this function completes.
      *
      * @param parser the XmlPullParser positioned at the start of an XML element.
      * @param packageName the package name of the app that owns the XML element.
      * @param schemaType the type of the schema that the XML element belongs to.
      * @param qualifiedPropertyNamesToPropertyConfig the mapping of qualified property names to
      *     their corresponding {@link PropertyConfig} objects.
-     * @return a {@link GenericDocument} object populated with the data from the XML element, or
-     *     null.
+     * @param docBuilder {@link GenericDocument.Builder} object to populate with the data from the
+     *     XML element.
      * @throws XmlPullParserException if the XML element is malformed.
      */
-    @NonNull
-    private static GenericDocument parseXmlElementToGenericDocument(
+    private static void buildGenericDocumentFromXmlElement(
             @NonNull XmlPullParser parser,
             @NonNull String packageName,
             @NonNull String schemaType,
-            @NonNull Map<String, PropertyConfig> qualifiedPropertyNamesToPropertyConfig)
+            @NonNull Map<String, PropertyConfig> qualifiedPropertyNamesToPropertyConfig,
+            @NonNull GenericDocument.Builder docBuilder)
             throws XmlPullParserException, IOException {
         Objects.requireNonNull(parser);
         Objects.requireNonNull(packageName);
-        Objects.requireNonNull(schemaType);
         Objects.requireNonNull(qualifiedPropertyNamesToPropertyConfig);
 
-        GenericDocument.Builder docBuilder =
-                new GenericDocument.Builder(
-                        AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE,
-                        packageName + "/" + schemaType,
-                        AppFunctionStaticMetadata.getSchemaNameForPackage(packageName, schemaType));
-
         Map<String, List<String>> primitivePropertyValues = new ArrayMap<>();
         Map<String, List<GenericDocument>> nestedDocumentValues = new ArrayMap<>();
         String startTag = parser.getName();
-        String currentPropertyPath = null;
+        String currentPropertyPath;
+        boolean wasDocIdSet = false;
+
+        // Skip the current tag that marks the beginning of the current document.
+        parser.next();
 
         while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {
             switch (parser.getEventType()) {
                 case XmlPullParser.START_TAG:
-                    currentPropertyPath = createQualifiedPropertyName(schemaType, parser.getName());
+                    currentPropertyPath =
+                            createQualifiedPropertyName(
+                                    schemaType,
+                                    toLowerCamelCase(parser.getName(), SNAKE_CASE_SEPARATOR));
                     PropertyConfig propertyConfig =
                             qualifiedPropertyNamesToPropertyConfig.get(currentPropertyPath);
                     if (propertyConfig instanceof DocumentPropertyConfig) {
-                        GenericDocument nestedDoc =
-                                parseXmlElementToGenericDocument(
-                                        parser,
-                                        packageName,
-                                        getSchemaTypeWithoutPackage(
-                                                ((DocumentPropertyConfig) propertyConfig)
-                                                        .getSchemaType()),
-                                        qualifiedPropertyNamesToPropertyConfig);
+                        String nestedSchemaType =
+                                ((DocumentPropertyConfig) propertyConfig).getSchemaType();
+                        GenericDocument.Builder nestedDoc =
+                                new GenericDocument.Builder(
+                                        AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE,
+                                        "",
+                                        nestedSchemaType);
+                        buildGenericDocumentFromXmlElement(
+                                parser,
+                                packageName,
+                                nestedSchemaType,
+                                qualifiedPropertyNamesToPropertyConfig,
+                                nestedDoc);
                         nestedDocumentValues
                                 .computeIfAbsent(currentPropertyPath, k -> new ArrayList<>())
-                                .add(nestedDoc);
+                                .add(nestedDoc.build());
                     } else if (propertyConfig != null) {
                         primitivePropertyValues
                                 .computeIfAbsent(currentPropertyPath, k -> new ArrayList<>())
                                 .add(parser.nextText().trim());
+                    } else if (parser.getName().equals(XML_TAG_ID)) {
+                        String id = parser.nextText().trim();
+                        if (!id.isEmpty()) {
+                            docBuilder.setId(packageName + "/" + id);
+                            wasDocIdSet = true;
+                        }
                     }
                     break;
 
@@ -435,7 +455,11 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
                             docBuilder.setPropertyDocument(
                                     propertyName, entry.getValue().toArray(new GenericDocument[0]));
                         }
-                        return docBuilder.build();
+                        if (!wasDocIdSet) {
+                            throw new XmlPullParserException(
+                                    "No id found for document of type: " + schemaType);
+                        }
+                        return;
                     }
                     break;
             }
@@ -467,7 +491,7 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         Map<String, PropertyConfig> propertyMap = new ArrayMap<>();
 
         for (Map.Entry<String, AppSearchSchema> entry : schemaMap.entrySet()) {
-            String schemaType = getSchemaTypeWithoutPackage(entry.getKey());
+            String schemaType = entry.getKey();
             AppSearchSchema schema = entry.getValue();
 
             List<AppSearchSchema.PropertyConfig> properties = schema.getProperties();
@@ -481,6 +505,43 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         return propertyMap;
     }
 
+    /**
+     * Converts a string of words separated by separator to lowerCamelCase.
+     *
+     * <p>Returns the same string if string doesn't contain the separator.
+     */
+    private static String toLowerCamelCase(@NonNull String str, @NonNull String separator) {
+        if (str.isEmpty()) {
+            return "";
+        }
+
+        // Return the original string if the separator is not present
+        if (!str.contains(separator)) {
+            return str;
+        }
+
+        StringBuilder builder = new StringBuilder(str.length());
+        boolean capitalizeNext = false;
+
+        for (int i = 0; i < str.length(); i++) {
+            char currentChar = str.charAt(i);
+            // skip multiple consecutive separators
+            if (str.startsWith(separator, i)) {
+                capitalizeNext = true;
+                i += separator.length() - 1;
+            } else {
+                if (capitalizeNext) {
+                    builder.append(Character.toUpperCase(currentChar));
+                    capitalizeNext = false;
+                } else {
+                    builder.append(Character.toLowerCase(currentChar));
+                }
+            }
+        }
+
+        return builder.toString();
+    }
+
     /**
      * Creates a qualified property name by concatenating the schema type and property name with a #
      * separator to avoid conflicts between properties with the same name in different schemas.
@@ -491,17 +552,6 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         return Objects.requireNonNull(schemaType) + "#" + Objects.requireNonNull(propertyName);
     }
 
-    /**
-     * Returns the schema type without the package name suffix.
-     *
-     * <p>For example, if the schema name is "Person-com.example.app", this method will return
-     * "Person".
-     */
-    @NonNull
-    private static String getSchemaTypeWithoutPackage(@NonNull String schemaName) {
-        return Objects.requireNonNull(schemaName).substring(0, schemaName.indexOf('-'));
-    }
-
     /**
      * Adds primitive property values to the given {@link GenericDocument.Builder} based on the
      * given {@link PropertyConfig}.
@@ -534,6 +584,8 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
             case PropertyConfig.DATA_TYPE_STRING:
                 builder.setPropertyString(propertyConfig.getName(), values.toArray(new String[0]));
                 break;
+            default:
+                // fall-through
         }
     }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppFunctionSchemaParser.java b/service/java/com/android/server/appsearch/appsindexer/AppFunctionSchemaParser.java
index e06414ea..adf85b1a 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppFunctionSchemaParser.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppFunctionSchemaParser.java
@@ -21,25 +21,25 @@ import android.app.appsearch.AppSearchSchema.BooleanPropertyConfig;
 import android.app.appsearch.AppSearchSchema.LongPropertyConfig;
 import android.app.appsearch.AppSearchSchema.PropertyConfig;
 import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
-import android.app.appsearch.util.LogUtil;
 import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.res.AssetManager;
 import android.util.ArrayMap;
+import android.util.ArraySet;
 import android.util.Log;
 
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.util.Collections;
 import java.util.Map;
 import java.util.Objects;
-
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-import org.xmlpull.v1.XmlPullParserFactory;
+import java.util.Set;
 
 /**
  * This class parses the XSD file from an app's assets and creates AppSearch schemas from document
@@ -50,7 +50,8 @@ import org.xmlpull.v1.XmlPullParserFactory;
  * named dynamically to be unique to the app package name.
  *
  * <p>Note: The XSD file should be generated by the App Functions SDK and always define
- * AppFunctionStaticMetadata document type.
+ * AppFunctionStaticMetadata document type which will have {@link
+ * AppFunctionStaticMetadata#PARENT_TYPE_APPSEARCH_SCHEMA} as parent type.
  */
 public class AppFunctionSchemaParser {
     private static final String TAG = "AppSearchSchemaParser";
@@ -86,6 +87,24 @@ public class AppFunctionSchemaParser {
         mMaxAllowedDocumentType = maxAllowedDocumentType;
     }
 
+    private static boolean getAttributeBoolOrDefault(
+            @NonNull XmlPullParser parser, @NonNull String attributeName, boolean defaultValue) {
+        Objects.requireNonNull(parser);
+        Objects.requireNonNull(attributeName);
+
+        String value = parser.getAttributeValue(/* namespace= */ null, attributeName);
+        return value == null ? defaultValue : Boolean.parseBoolean(value);
+    }
+
+    private static int getAttributeIntOrDefault(
+            @NonNull XmlPullParser parser, @NonNull String attributeName, int defaultValue) {
+        Objects.requireNonNull(parser);
+        Objects.requireNonNull(attributeName);
+
+        String value = parser.getAttributeValue(/* namespace= */ null, attributeName);
+        return value == null ? defaultValue : Integer.parseInt(value);
+    }
+
     /**
      * Parses the XSD and create AppSearch schemas from document types.
      *
@@ -108,20 +127,17 @@ public class AppFunctionSchemaParser {
         Objects.requireNonNull(packageName);
         Objects.requireNonNull(assetFilePath);
 
+        // Keep track of all nested schema types  to validate root schema later.
+        Set<String> nestedSchemaTypes = new ArraySet<>();
+
         try {
             AssetManager assetManager =
                     packageManager.getResourcesForApplication(packageName).getAssets();
             InputStream xsdInputStream = assetManager.open(assetFilePath);
-            String appFunctionStaticMetadataType =
-                    AppFunctionStaticMetadata.getSchemaNameForPackage(
-                            packageName, /* schemaType= */ null);
             Map<String, AppSearchSchema> schemas =
-                    parseDocumentTypeAndCreateSchemas(packageName, xsdInputStream);
-            if (schemas.containsKey(appFunctionStaticMetadataType)) {
-                return schemas;
-            } else if (LogUtil.DEBUG) {
-                Log.d(TAG, "AppFunctionStaticMetadata schema not found.");
-            }
+                    parseDocumentTypeAndCreateSchemas(
+                            packageName, xsdInputStream, nestedSchemaTypes);
+            return getValidatedSchemas(schemas, packageName, nestedSchemaTypes);
         } catch (Exception ex) {
             // The code parses an XSD file from another app's assets, using a broad try-catch to
             // handle potential errors since the XML structure might be unpredictable.
@@ -135,11 +151,26 @@ public class AppFunctionSchemaParser {
         return Collections.emptyMap();
     }
 
+    /**
+     * Parses the XSD and create AppSearch schemas from document types.
+     *
+     * @param packageName The package for which schemas are being parsed.
+     * @param xsdInputStream The input stream to the XSD file within the app's assets.
+     * @param nestedSchemaTypes A set to maintain all the nested schema types encountered when
+     *     processing a root tag. This will be later used to validate that correct schema
+     *     definitions exist for each nested type.
+     * @return A mapping of schema types to their corresponding {@link AppSearchSchema} objects, or
+     *     an empty map if there's an error during parsing or if the AppFunctionStaticMetadata
+     *     document type is not found.
+     */
     private Map<String, AppSearchSchema> parseDocumentTypeAndCreateSchemas(
-            @NonNull String packageName, @NonNull InputStream xsdInputStream)
-            throws XmlPullParserException, IOException {
+            @NonNull String packageName,
+            @NonNull InputStream xsdInputStream,
+            @NonNull Set<String> nestedSchemaTypes)
+            throws XmlPullParserException, IOException, InvalidAppFunctionSchemaException {
         Objects.requireNonNull(packageName);
         Objects.requireNonNull(xsdInputStream);
+        Objects.requireNonNull(nestedSchemaTypes);
 
         Map<String, AppSearchSchema> schemas = new ArrayMap<>();
         XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
@@ -163,12 +194,20 @@ public class AppFunctionSchemaParser {
                         if (documentTypeName != null) {
                             schemaBuilder =
                                     new AppSearchSchema.Builder(
-                                            AppFunctionStaticMetadata.getSchemaNameForPackage(
+                                            AppFunctionDocument.getSchemaNameForPackage(
                                                     packageName, documentTypeName));
+
+                            // All AppFunctionStaticMetadata schemas defined in packages will
+                            // inherit from AppFunctionStaticMetadata#PARENT_TYPE_APPSEARCH_SCHEMA.
+                            if (documentTypeName.equals(AppFunctionStaticMetadata.SCHEMA_TYPE)
+                                    && AppFunctionStaticMetadata.shouldSetParentType()) {
+                                schemaBuilder.addParentType(AppFunctionStaticMetadata.SCHEMA_TYPE);
+                            }
                         }
                     } else if (XML_TAG_ELEMENT.equals(parser.getName()) && schemaBuilder != null) {
                         AppSearchSchema.PropertyConfig propertyConfig =
-                                computePropertyConfigFromXsdType(parser, packageName);
+                                computePropertyConfigFromXsdType(
+                                        parser, packageName, nestedSchemaTypes);
                         if (propertyConfig != null) schemaBuilder.addProperty(propertyConfig);
                     }
                     break;
@@ -189,12 +228,17 @@ public class AppFunctionSchemaParser {
         return schemas;
     }
 
-    private static PropertyConfig computePropertyConfigFromXsdType(
-            @NonNull XmlPullParser parser, @NonNull String packageName)
-            throws XmlPullParserException, IOException {
+    private PropertyConfig computePropertyConfigFromXsdType(
+            @NonNull XmlPullParser parser,
+            @NonNull String packageName,
+            @NonNull Set<String> nestedSchemaTypes)
+            throws InvalidAppFunctionSchemaException {
         Objects.requireNonNull(parser);
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(nestedSchemaTypes);
 
         String name = parser.getAttributeValue(null, XML_ATTRIBUTE_NAME);
+        validatePropertyName(name);
         String type = parser.getAttributeValue(null, XML_ATTRIBUTE_TYPE);
 
         if (name == null || type == null) return null;
@@ -238,37 +282,102 @@ public class AppFunctionSchemaParser {
             default:
                 if (type.contains(XML_APPFN_NAMESPACE_PREFIX)) {
                     String localType = type.substring(type.indexOf(':') + 1);
-                    return new AppSearchSchema.DocumentPropertyConfig.Builder(
-                                    name,
-                                    AppFunctionStaticMetadata.getSchemaNameForPackage(
-                                            packageName, localType))
+                    String schemaType =
+                            AppFunctionDocument.getSchemaNameForPackage(packageName, localType);
+                    nestedSchemaTypes.add(schemaType);
+                    return new AppSearchSchema.DocumentPropertyConfig.Builder(name, schemaType)
                             .setCardinality(cardinality)
                             .setShouldIndexNestedProperties(
                                     getAttributeBoolOrDefault(
                                             parser,
                                             XML_ATTRIBUTE_SHOULD_INDEX_NESTED_PROPERTIES,
-                                            true))
+                                            false))
                             .build();
                 }
                 throw new IllegalArgumentException("Unsupported type: " + type);
         }
     }
 
-    private static boolean getAttributeBoolOrDefault(
-            @NonNull XmlPullParser parser, @NonNull String attributeName, boolean defaultValue) {
-        Objects.requireNonNull(parser);
-        Objects.requireNonNull(attributeName);
-
-        String value = parser.getAttributeValue(null, attributeName);
-        return value == null ? defaultValue : Boolean.parseBoolean(value);
+    /**
+     * Validates the given property name to ensure it is not null, empty, and contains only
+     * alphanumeric characters (letters and digits).
+     *
+     * @param name the property name to validate
+     * @throws InvalidAppFunctionSchemaException if the name is empty, or contains non-alphanumeric
+     *     characters
+     */
+    private static void validatePropertyName(@NonNull String name)
+            throws InvalidAppFunctionSchemaException {
+        Objects.requireNonNull(name);
+        if (name.isEmpty()) {
+            throw new InvalidAppFunctionSchemaException(
+                    "Property name in the schema cannot be null or empty.");
+        }
+        for (int i = 0; i < name.length(); i++) {
+            char c = name.charAt(i);
+            if (!Character.isLetterOrDigit(c)) {
+                throw new InvalidAppFunctionSchemaException(
+                        "Property name must contain only alphanumeric characters: " + name);
+            }
+        }
     }
 
-    private static int getAttributeIntOrDefault(
-            @NonNull XmlPullParser parser, @NonNull String attributeName, int defaultValue) {
-        Objects.requireNonNull(parser);
-        Objects.requireNonNull(attributeName);
+    /**
+     * Validates and returns the provided schema map for a given package.
+     *
+     * <p>This method ensures that the required schemas and properties are present in the schema
+     * map. Specifically:
+     *
+     * <ul>
+     *   <li>It verifies that the schema for {@link AppFunctionStaticMetadata} exists for the given
+     *       package and checks for the presence of required properties from {@link
+     *       AppFunctionStaticMetadata#PARENT_TYPE_APPSEARCH_SCHEMA}.
+     *   <li>It checks for any missing schema definitions for nested schema types.
+     * </ul>
+     *
+     * @param schemaMap A map where the key is the schema type name, and the value is the
+     *     corresponding {@link AppSearchSchema}.
+     * @param packageName The name of the package for which the schemas are being validated.
+     * @param nestedSchemaTypes A set of all the nested schema types used to validate that correct
+     *     schema definitions exist for each nested type.
+     * @return The validated schema map.
+     * @throws InvalidAppFunctionSchemaException If any required schema or properties are missing.
+     */
+    private Map<String, AppSearchSchema> getValidatedSchemas(
+            @NonNull Map<String, AppSearchSchema> schemaMap,
+            @NonNull String packageName,
+            @NonNull Set<String> nestedSchemaTypes)
+            throws InvalidAppFunctionSchemaException {
+        Objects.requireNonNull(schemaMap);
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(nestedSchemaTypes);
 
-        String value = parser.getAttributeValue(null, attributeName);
-        return value == null ? defaultValue : Integer.parseInt(value);
+        String appFunctionStaticMetadataSchemaType =
+                AppFunctionDocument.getSchemaNameForPackage(
+                        packageName, AppFunctionStaticMetadata.SCHEMA_TYPE);
+        if (!schemaMap.containsKey(appFunctionStaticMetadataSchemaType)) {
+            throw new InvalidAppFunctionSchemaException(
+                    "Missing schema definition for AppFunctionStaticMetadata in package: "
+                            + packageName);
+        }
+
+        Set<String> undefinedSchemas = new ArraySet<>(nestedSchemaTypes);
+        undefinedSchemas.removeAll(schemaMap.keySet());
+        if (!undefinedSchemas.isEmpty()) {
+            throw new InvalidAppFunctionSchemaException(
+                    "In package: "
+                            + packageName
+                            + ", missing schema definitions for following nested schema types: "
+                            + undefinedSchemas);
+        }
+
+        return schemaMap;
+    }
+
+    /** Exception thrown when the parsed schema fails any of the validations. */
+    private static class InvalidAppFunctionSchemaException extends Exception {
+        InvalidAppFunctionSchemaException(String message) {
+            super(message);
+        }
     }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppIndexerVersions.java b/service/java/com/android/server/appsearch/appsindexer/AppIndexerVersions.java
new file mode 100644
index 00000000..5d493c19
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/AppIndexerVersions.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import android.annotation.IntDef;
+
+/** Defines constants and annotations for managing App Indexer versions. */
+public class AppIndexerVersions {
+
+    /** Default value when the version is not specified or can not be determined. */
+    public static final int APP_INDEXER_VERSION_UNKNOWN = 0;
+
+    /** Represents the App Indexer version where dynamic schema support is enabled. */
+    private static final int APP_INDEXER_DYNAMIC_SCHEMA_ENABLED_VERSION = 1;
+
+    /** Annotation to restrict values to valid App Indexer versions. */
+    @IntDef(value = {APP_INDEXER_VERSION_UNKNOWN, APP_INDEXER_DYNAMIC_SCHEMA_ENABLED_VERSION})
+    public @interface AppIndexerVersion {}
+
+    /**
+     * Stores the current version of App Indexer. If this differs from the {@link
+     * AppsIndexerSettings#getPreviousIndexerVersionCode()} all apps will be re-indexed irrespective
+     * of whether there was a corresponding package update or not.
+     */
+    @AppIndexerVersion
+    public static final int CURR_APP_INDEXER_VERSION = APP_INDEXER_DYNAMIC_SCHEMA_ENABLED_VERSION;
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java
index f367dd45..3d8ce763 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java
@@ -35,9 +35,21 @@ public interface AppOpenEventIndexerConfig {
      */
     long DEFAULT_APP_OPEN_EVENT_INDEXER_UPDATE_INTERVAL_MILLIS = TimeUnit.DAYS.toMillis(1);
 
+    /**
+     * Returns the minimum time required to wait before attempting a sync after a previous sync,
+     * regardless of whether the sync completes or not.
+     */
+    long DEFAULT_APP_OPEN_EVENT_MIN_TIME_BETWEEN_SYNCS_MILLIS = TimeUnit.HOURS.toMillis(1);
+
     /** Returns whether App Open Event Indexer is enabled. */
     boolean isAppOpenEventIndexerEnabled();
 
     /* Returns the minimum internal in millis for two consecutive scheduled updates. */
     long getAppOpenEventMaintenanceUpdateIntervalMillis();
+
+    /**
+     * Returns the minimum time required to wait before attempting a sync after a previous sync, in
+     * milliseconds.
+     */
+    long getMinTimeBetweenSyncsMillis();
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerManagerService.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerManagerService.java
index 04eb1a07..5cea1e00 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerManagerService.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerManagerService.java
@@ -92,6 +92,22 @@ public final class AppOpenEventIndexerManagerService extends SystemService {
         LocalManagerRegistry.addManager(LocalService.class, mLocalService);
     }
 
+    /** Schedules the periodic update job for all users we have an instance for. */
+    @Override
+    public void onUserUnlocking(@NonNull TargetUser user) {
+        synchronized (mAppOpenEventIndexersLocked) {
+            try {
+                AppOpenEventIndexerUserInstance instance =
+                        getOrCreateUserInstance(user.getUserHandle());
+                if (instance != null) {
+                    instance.schedulePeriodicUpdate();
+                }
+            } catch (RuntimeException e) {
+                Slog.wtf(TAG, "AppOpenEventIndexerManagerService.onUserUnlocking() failed", e);
+            }
+        }
+    }
+
     /** Handles user stopping by shutting down the instance for the user. */
     @Override
     public void onUserStopping(@NonNull TargetUser user) {
@@ -142,22 +158,6 @@ public final class AppOpenEventIndexerManagerService extends SystemService {
         }
     }
 
-    /** Schedules the periodic update job for all users we have an instance for. */
-    @Override
-    public void onUserUnlocking(@NonNull TargetUser user) {
-        synchronized (mAppOpenEventIndexersLocked) {
-            try {
-                AppOpenEventIndexerUserInstance instance =
-                        getOrCreateUserInstance(user.getUserHandle());
-                if (instance != null) {
-                    instance.schedulePeriodicUpdate();
-                }
-            } catch (RuntimeException e) {
-                Slog.wtf(TAG, "AppOpenEventIndexerManagerService.onUserUnlocking() failed", e);
-            }
-        }
-    }
-
     /** Retrieves or creates the {@link AppOpenEventIndexerUserInstance} for the specified user. */
     private AppOpenEventIndexerUserInstance getOrCreateUserInstance(
             @NonNull UserHandle userHandle) {
@@ -202,7 +202,10 @@ public final class AppOpenEventIndexerManagerService extends SystemService {
             Objects.requireNonNull(userHandle);
             try {
                 synchronized (mAppOpenEventIndexersLocked) {
-                    AppOpenEventIndexerUserInstance instance = getOrCreateUserInstance(userHandle);
+                    // Jobs are created onUserUnlocking, so unless the user is removed, this should
+                    // be non-null.
+                    AppOpenEventIndexerUserInstance instance =
+                            mAppOpenEventIndexersLocked.get(userHandle);
                     if (instance != null) {
                         if (mCallback != null) {
                             instance.updateAsync(mCallback);
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java
index 86727316..c4620126 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java
@@ -25,6 +25,7 @@ import android.content.Context;
 import android.util.Log;
 import android.util.Slog;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.indexer.IndexerMaintenanceService;
 
@@ -151,6 +152,8 @@ public final class AppOpenEventIndexerUserInstance {
     /** Shuts down the AppOpenEventIndexerUserInstance */
     public void shutdown() throws InterruptedException {
         mAppOpenEventIndexerImpl.close();
+        IndexerMaintenanceService.cancelUpdateJobIfScheduled(
+                mContext, mContext.getUser(), APP_OPEN_EVENT_INDEXER);
         synchronized (mSingleThreadedExecutor) {
             mSingleThreadedExecutor.shutdown();
         }
@@ -257,6 +260,24 @@ public final class AppOpenEventIndexerUserInstance {
     @VisibleForTesting
     void doUpdate() {
         try {
+            if (Flags.enableAppOpenEventsIndexerCheckPriorAttempt()) {
+                long now = System.currentTimeMillis();
+                long lastRun = mAppOpenEventIndexerSettings.getLastAttemptedUpdateTimestampMillis();
+                long timeSinceLastRun = now - lastRun;
+
+                // If timeSinceLastRun is somehow negative, it means that the system clock
+                // must've turned back since the last run. We'll run the update in this case
+                if (timeSinceLastRun >= 0
+                        && timeSinceLastRun
+                                < mAppOpenEventIndexerConfig.getMinTimeBetweenSyncsMillis()) {
+                    // Last run was too recent, skip and leave timestamps alone
+                    return;
+                }
+
+                mAppOpenEventIndexerSettings.setLastAttemptedUpdateTimestampMillis(now);
+                mAppOpenEventIndexerSettings.persist();
+            }
+
             long lastUpdateMillis = mAppOpenEventIndexerSettings.getLastUpdateTimestampMillis();
             long currentTimeMillis = System.currentTimeMillis();
 
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java b/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java
index 8be0f7c1..31267621 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java
@@ -28,6 +28,7 @@ import android.app.appsearch.AppSearchManager;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
+import android.app.appsearch.JoinSpec;
 import android.app.appsearch.PackageIdentifier;
 import android.app.appsearch.PutDocumentsRequest;
 import android.app.appsearch.RemoveByDocumentIdRequest;
@@ -42,6 +43,7 @@ import android.util.ArraySet;
 import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
@@ -161,11 +163,185 @@ public class AppSearchHelper implements Closeable {
         Objects.requireNonNull(mobileAppPkgs);
         Objects.requireNonNull(appFunctionPkgs);
 
-        SetSchemaRequest.Builder schemaBuilder =
-                new SetSchemaRequest.Builder()
-                        // If MobileApplication schema later gets changed to a compatible schema, we
-                        // should first try setting the schema with forceOverride = false.
-                        .setForceOverride(true);
+        SetSchemaRequest schemaRequest =
+                buildMobileAppAndPreDefinedAppFuncSchemaRequest(
+                        mobileAppPkgs, appFunctionPkgs, Collections.emptyMap());
+
+        // TODO(b/275592563): Log app removal in metrics
+        mSyncAppSearchAppsDbSession.setSchema(schemaRequest);
+    }
+
+    /**
+     * Sets the AppsIndexer database schema to correspond to the list of passed in {@link
+     * PackageIdentifier}s, representing app schemas, and a list of {@link PackageIdentifier}s,
+     * representing app functions. Note that this means if a schema exists in AppSearch that does
+     * not get passed in to this method, it will be erased. And if a schema does not exist in
+     * AppSearch that is passed in to this method, it will be created.
+     *
+     * <p>Note the following for dynamicAppFunctionSchemasForPackages:
+     *
+     * <ul>
+     *   <li>For packages with no dynamic app function schemas mapping, a predefined schema will be
+     *       created using {@link AppFunctionStaticMetadata#createAppFunctionSchemaForPackage}.
+     *   <li>This method first tries to setSchema for all packages in a single call to {@link
+     *       SyncAppSearchSession#setSchema(SetSchemaRequest)}. If this fails, it iteratively adds
+     *       the dynamic schemas to the request and excludes packages with invalid schemas from
+     *       schema updates.
+     * </ul>
+     *
+     * @param mobileAppPkgs A list of {@link PackageIdentifier}s for which to set {@link
+     *     MobileApplication} schemas for.
+     * @param appFunctionPkgs A list of {@link PackageIdentifier}s for which to set {@link
+     *     AppFunctionStaticMetadata} schemas for. These are packages with an AppFunctionService. It
+     *     is always a subset of `mobileAppPkgs`.
+     * @param dynamicAppFunctionSchemasForPackages A map of package name to a map of schema name to
+     *     {@link AppSearchSchema} for dynamic app functions.
+     */
+    @WorkerThread
+    public void setSchemasForPackages(
+            @NonNull List<PackageIdentifier> mobileAppPkgs,
+            @NonNull List<PackageIdentifier> appFunctionPkgs,
+            @NonNull
+                    Map<String, Map<String, AppSearchSchema>>
+                            dynamicAppFunctionSchemasForPackages) {
+        Objects.requireNonNull(mobileAppPkgs);
+        Objects.requireNonNull(appFunctionPkgs);
+        Objects.requireNonNull(dynamicAppFunctionSchemasForPackages);
+
+        // Build predefined schemas for mobile app packages and app function packages that don't
+        // have dynamic schemas.
+        SetSchemaRequest preDefinedSchemaRequest =
+                buildMobileAppAndPreDefinedAppFuncSchemaRequest(
+                        mobileAppPkgs, appFunctionPkgs, dynamicAppFunctionSchemasForPackages);
+
+        // Build all schemas (predefined + dynamic)
+        SetSchemaRequest.Builder allPackagesRequestBuilder =
+                new SetSchemaRequest.Builder(preDefinedSchemaRequest);
+        addDynamicSchemasToBuilder(
+                allPackagesRequestBuilder, appFunctionPkgs, dynamicAppFunctionSchemasForPackages);
+
+        try {
+            mSyncAppSearchAppsDbSession.setSchema(allPackagesRequestBuilder.build());
+        } catch (AppSearchException e) {
+
+            Log.e(TAG, "Failed to setSchema in batch due to invalid schema.", e);
+            iterativelyAddDynamicSchema(
+                    preDefinedSchemaRequest, appFunctionPkgs, dynamicAppFunctionSchemasForPackages);
+        }
+    }
+
+    /**
+     * Builds a schema request for the specified mobile application and app function packages.
+     *
+     * <p>Only adds pre-defined schemas for app function packages without a dynamic schema mapping.
+     *
+     * @param mobileAppPkgs A list of {@link PackageIdentifier}s for which to set {@link
+     *     MobileApplication} schemas.
+     * @param appFunctionPkgs A list of {@link PackageIdentifier}s for which to set {@link
+     *     AppFunctionStaticMetadata} schemas.
+     * @param dynamicSchemas A map of package names to their dynamic schemas, represented as a map
+     *     of schema names to {@link AppSearchSchema}.
+     * @return A {@link SetSchemaRequest} containing the predefined schemas.
+     */
+    private SetSchemaRequest buildMobileAppAndPreDefinedAppFuncSchemaRequest(
+            @NonNull List<PackageIdentifier> mobileAppPkgs,
+            @NonNull List<PackageIdentifier> appFunctionPkgs,
+            @NonNull Map<String, Map<String, AppSearchSchema>> dynamicSchemas) {
+        SetSchemaRequest.Builder builder = new SetSchemaRequest.Builder().setForceOverride(true);
+
+        populateMobileApplicationSchemas(builder, mobileAppPkgs);
+
+        if (!appFunctionPkgs.isEmpty() && AppFunctionStaticMetadata.shouldSetParentType()) {
+            builder.addSchemas(AppFunctionStaticMetadata.PARENT_TYPE_APPSEARCH_SCHEMA);
+        }
+
+        for (int i = 0; i < appFunctionPkgs.size(); i++) {
+            PackageIdentifier pkg = appFunctionPkgs.get(i);
+            Map<String, AppSearchSchema> packageSchemas =
+                    dynamicSchemas.getOrDefault(pkg.getPackageName(), Collections.emptyMap());
+            if (!packageSchemas.isEmpty()) {
+                // Dynamic schemas are handled separately.
+                continue;
+            }
+            AppSearchSchema schema =
+                    AppFunctionStaticMetadata.createAppFunctionSchemaForPackage(
+                            pkg.getPackageName());
+            builder.addSchemas(schema);
+            builder.setPubliclyVisibleSchema(schema.getSchemaType(), pkg);
+        }
+        return builder.build();
+    }
+
+    /**
+     * Adds dynamic schemas to a schema request builder for the specified app function packages.
+     *
+     * @param builder The {@link SetSchemaRequest.Builder} to which dynamic schemas will be added.
+     * @param appFunctionPkgs A list of {@link PackageIdentifier}s representing app function
+     *     packages.
+     * @param dynamicSchemas A map of package names to their dynamic schemas, represented as a map
+     *     of schema names to {@link AppSearchSchema}.
+     */
+    private void addDynamicSchemasToBuilder(
+            @NonNull SetSchemaRequest.Builder builder,
+            @NonNull List<PackageIdentifier> appFunctionPkgs,
+            @NonNull Map<String, Map<String, AppSearchSchema>> dynamicSchemas) {
+        for (int i = 0; i < appFunctionPkgs.size(); i++) {
+            PackageIdentifier pkg = appFunctionPkgs.get(i);
+            Map<String, AppSearchSchema> packageSchemas =
+                    dynamicSchemas.getOrDefault(pkg.getPackageName(), Collections.emptyMap());
+            for (Map.Entry<String, AppSearchSchema> entry : packageSchemas.entrySet()) {
+                builder.addSchemas(entry.getValue());
+                builder.setPubliclyVisibleSchema(entry.getKey(), pkg);
+            }
+        }
+    }
+
+    /**
+     * Iteratively adds dynamic schemas to the AppsIndexer database to ensure all schemas are
+     * applied successfully, skipping invalid schemas.
+     *
+     * @param preDefinedSchemaRequest The base schema request containing predefined schemas.
+     * @param appFunctionPkgs A list of {@link PackageIdentifier}s representing app function
+     *     packages.
+     * @param dynamicSchemas A map of package names to their dynamic schemas, represented as a map
+     *     of schema names to {@link AppSearchSchema}.
+     */
+    private void iterativelyAddDynamicSchema(
+            @NonNull SetSchemaRequest preDefinedSchemaRequest,
+            @NonNull List<PackageIdentifier> appFunctionPkgs,
+            @NonNull Map<String, Map<String, AppSearchSchema>> dynamicSchemas) {
+        SetSchemaRequest prevSuccessfulRequest = preDefinedSchemaRequest;
+
+        for (int i = 0; i < appFunctionPkgs.size(); i++) {
+            PackageIdentifier pkg = appFunctionPkgs.get(i);
+            Map<String, AppSearchSchema> packageSchemas =
+                    dynamicSchemas.getOrDefault(pkg.getPackageName(), Collections.emptyMap());
+            if (packageSchemas.isEmpty()) {
+                continue;
+            }
+
+            SetSchemaRequest.Builder builder = new SetSchemaRequest.Builder(prevSuccessfulRequest);
+            for (Map.Entry<String, AppSearchSchema> entry : packageSchemas.entrySet()) {
+                builder.addSchemas(entry.getValue());
+                builder.setPubliclyVisibleSchema(entry.getKey(), pkg);
+            }
+
+            try {
+                SetSchemaRequest currentRequest = builder.build();
+                mSyncAppSearchAppsDbSession.setSchema(currentRequest);
+                prevSuccessfulRequest = currentRequest; // Update on success
+            } catch (AppSearchException e) {
+                Log.e(TAG, "Skipping invalid schemas for package: " + pkg.getPackageName(), e);
+            }
+        }
+    }
+
+    /**
+     * Creates and populate the schemas for MobileApplications per package in the SetSchemaRequest.
+     */
+    private static void populateMobileApplicationSchemas(
+            @NonNull SetSchemaRequest.Builder schemaBuilder,
+            @NonNull List<PackageIdentifier> mobileAppPkgs) {
         for (int i = 0; i < mobileAppPkgs.size(); i++) {
             PackageIdentifier pkg = mobileAppPkgs.get(i);
             // As all apps are in the same db, we have to make sure that even if it's getting
@@ -180,22 +356,6 @@ public class AppSearchHelper implements Closeable {
             // PackageIdentifier parameter to setPubliclyVisibleSchema.
             schemaBuilder.setPubliclyVisibleSchema(schemaVariant.getSchemaType(), pkg);
         }
-
-        // Set the base type first for AppFunctions
-        if (!appFunctionPkgs.isEmpty() && AppFunctionStaticMetadata.shouldSetParentType()) {
-            schemaBuilder.addSchemas(AppFunctionStaticMetadata.PARENT_TYPE_APPSEARCH_SCHEMA);
-        }
-        for (int i = 0; i < appFunctionPkgs.size(); i++) {
-            PackageIdentifier pkg = appFunctionPkgs.get(i);
-            String packageName = pkg.getPackageName();
-            AppSearchSchema schemaVariant =
-                    AppFunctionStaticMetadata.createAppFunctionSchemaForPackage(packageName);
-            schemaBuilder.addSchemas(schemaVariant);
-            schemaBuilder.setPubliclyVisibleSchema(schemaVariant.getSchemaType(), pkg);
-        }
-
-        // TODO(b/275592563): Log app removal in metrics
-        mSyncAppSearchAppsDbSession.setSchema(schemaBuilder.build());
     }
 
     /**
@@ -267,7 +427,7 @@ public class AppSearchHelper implements Closeable {
             GenericDocument appFunction = indexedAppFunctions.get(i);
             String id = appFunction.getId();
             String packageName =
-                    appFunction.getPropertyString(AppFunctionStaticMetadata.PROPERTY_PACKAGE_NAME);
+                    appFunction.getPropertyString(AppFunctionDocument.PROPERTY_PACKAGE_NAME);
             if (packagesToReindex.contains(packageName) && !currentAppFunctionIds.contains(id)) {
                 appFunctionIdsToRemove.add(id);
             }
@@ -346,8 +506,8 @@ public class AppSearchHelper implements Closeable {
      * doesn't necessarily have to happen in the current sync.
      *
      * @param apps a list of {@link MobileApplication} documents to be inserted.
-     * @param currentAppFunctions a list of {@link AppFunctionStaticMetadata} documents to be
-     *     AppFunctionStaticMetadata should point to its corresponding MobileApplication.
+     * @param currentAppFunctionDocuments a list of {@link AppFunctionDocument} documents to be
+     *     indexed.
      * @throws AppSearchException if indexing results in a {@link
      *     AppSearchResult#RESULT_OUT_OF_SPACE} result code. It will also throw this if the put call
      *     results in a system error as in {@link BatchResultCallback#onSystemError}. This may
@@ -362,16 +522,16 @@ public class AppSearchHelper implements Closeable {
     @WorkerThread
     public AppSearchBatchResult<String, Void> indexApps(
             @NonNull List<MobileApplication> apps,
-            @NonNull List<AppFunctionStaticMetadata> currentAppFunctions)
+            @NonNull List<AppFunctionDocument> currentAppFunctionDocuments)
             throws AppSearchException {
         Objects.requireNonNull(apps);
-        Objects.requireNonNull(currentAppFunctions);
+        Objects.requireNonNull(currentAppFunctionDocuments);
 
         // Insert all the documents. At this point, the proper schemas should've been set.
         PutDocumentsRequest request =
                 new PutDocumentsRequest.Builder()
                         .addGenericDocuments(apps)
-                        .addGenericDocuments(currentAppFunctions)
+                        .addGenericDocuments(currentAppFunctionDocuments)
                         .build();
 
         AppSearchBatchResult<String, Void> result = mSyncAppSearchAppsDbSession.put(request);
@@ -403,43 +563,53 @@ public class AppSearchHelper implements Closeable {
     }
 
     /**
-     * Returns a mapping of packages to a mapping of function ids to {@link
-     * AppFunctionStaticMetadata} objects. This is useful for determining what has changed during an
-     * update.
+     * Returns a mapping of packages to a mapping of document ids to {@link AppFunctionDocument}
+     * objects in {@link AppFunctionStaticMetadata#APP_FUNCTION_NAMESPACE}. This is useful for
+     * determining what has changed during an update.
      *
      * @param appPackageIds a set of package ids for which to retrieve functions from AppSearch.
      */
     @NonNull
     @WorkerThread
-    public Map<String, Map<String, AppFunctionStaticMetadata>> getAppFunctionsFromAppSearch(
-            List<String> appPackageIds) throws AppSearchException {
-        SearchSpec.Builder allAppFunctionsSpec =
+    public Map<String, Map<String, AppFunctionDocument>> getAppFunctionDocumentsFromAppSearch(
+            Set<String> appPackageIds) throws AppSearchException {
+        SearchSpec allAppFunctionsSpec =
                 new SearchSpec.Builder()
                         .addFilterNamespaces(AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE)
-                        .setResultCountPerPage(GET_APP_IDS_PAGE_SIZE);
+                        .build();
 
-        for (int i = 0; i < appPackageIds.size(); i++) {
-            String appPackageId = appPackageIds.get(i);
-            allAppFunctionsSpec.addFilterSchemas(
-                    AppFunctionStaticMetadata.getSchemaNameForPackage(
-                        appPackageId, /** schemaType= */ null));
-        }
+        JoinSpec appFunctionJoinSpec =
+                new JoinSpec.Builder(AppFunctionDocument.PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID)
+                        .setNestedSearch("", allAppFunctionsSpec)
+                        .build();
+
+        SearchSpec mobileApplicationSearchSpec =
+                new SearchSpec.Builder()
+                        .addFilterNamespaces(MobileApplication.APPS_NAMESPACE)
+                        .addProjection(
+                                SearchSpec.SCHEMA_TYPE_WILDCARD,
+                                List.of(MobileApplication.APP_PROPERTY_PACKAGE_NAME))
+                        .setJoinSpec(appFunctionJoinSpec)
+                        .build();
 
         SyncSearchResults results =
-                mSyncAppSearchAppsDbSession.search("", allAppFunctionsSpec.build());
+                mSyncAppSearchAppsDbSession.search("", mobileApplicationSearchSpec);
 
-        return collectAppFunctionDocumentsFromAllPages(results);
+        return collectAppFunctionDocumentsFromAllPages(results, new ArraySet<>(appPackageIds));
     }
 
     /**
-     * Iterates through result pages and returns a mapping of package names to a mapping of function
-     * ids to the corresponding app function currently indexed into AppSearch.
+     * Iterates through result pages and returns a mapping of package names to a mapping of document
+     * ids to the corresponding app function documents currently indexed into AppSearch.
+     *
+     * @param results results from a search query to retrieve all the app function documents.
+     * @param appPackageIds a set of package ids for which to retrieve functions from AppSearch.
      */
     @NonNull
     @WorkerThread
-    private Map<String, Map<String, AppFunctionStaticMetadata>>
-            collectAppFunctionDocumentsFromAllPages(@NonNull SyncSearchResults results) {
-        Map<String, Map<String, AppFunctionStaticMetadata>> appFunctionsMap = new ArrayMap<>();
+    private Map<String, Map<String, AppFunctionDocument>> collectAppFunctionDocumentsFromAllPages(
+            @NonNull SyncSearchResults results, Set<String> appPackageIds) {
+        Map<String, Map<String, AppFunctionDocument>> appFunctionDocumentsMap = new ArrayMap<>();
         // TODO(b/357551503): If possible, use pagination instead of building a map containing all
         // function docs.
         try {
@@ -449,25 +619,28 @@ public class AppSearchHelper implements Closeable {
                     GenericDocument genericDocument = resultList.get(i).getGenericDocument();
                     String packageName =
                             genericDocument.getPropertyString(
-                                    AppFunctionStaticMetadata.PROPERTY_PACKAGE_NAME);
+                                    MobileApplication.APP_PROPERTY_PACKAGE_NAME);
+                    List<SearchResult> joinedResultList = resultList.get(i).getJoinedResults();
+                    if (!appPackageIds.contains(packageName) || joinedResultList.isEmpty()) {
+                        continue;
+                    }
 
-                    Map<String, AppFunctionStaticMetadata> functionsForPackage =
-                            appFunctionsMap.get(packageName);
-                    if (functionsForPackage == null) {
-                        functionsForPackage = new ArrayMap<>();
-                        appFunctionsMap.put(packageName, functionsForPackage);
+                    Map<String, AppFunctionDocument> functionDocumentsForPackage =
+                            appFunctionDocumentsMap.computeIfAbsent(
+                                    packageName, k -> new ArrayMap<>());
+                    for (int j = 0; j < joinedResultList.size(); j++) {
+                        AppFunctionDocument functionDocument =
+                                new AppFunctionDocument(
+                                        joinedResultList.get(j).getGenericDocument());
+                        functionDocumentsForPackage.put(functionDocument.getId(), functionDocument);
                     }
-                    functionsForPackage.put(
-                            genericDocument.getPropertyString(
-                                    AppFunctionStaticMetadata.PROPERTY_FUNCTION_ID),
-                            new AppFunctionStaticMetadata(genericDocument));
                 }
                 resultList = results.getNextPage();
             }
         } catch (AppSearchException e) {
             Log.e(TAG, "Error while searching for all app documents", e);
         }
-        return appFunctionsMap;
+        return appFunctionDocumentsMap;
     }
 
     /**
@@ -598,7 +771,7 @@ public class AppSearchHelper implements Closeable {
                         .addProjection(
                                 SearchSpec.SCHEMA_TYPE_WILDCARD,
                                 Collections.singletonList(
-                                        AppFunctionStaticMetadata.PROPERTY_PACKAGE_NAME))
+                                        AppFunctionDocument.PROPERTY_PACKAGE_NAME))
                         .addFilterPackageNames(mContext.getPackageName())
                         .setResultCountPerPage(GET_APP_IDS_PAGE_SIZE)
                         .build();
@@ -640,8 +813,7 @@ public class AppSearchHelper implements Closeable {
                     SearchResult result = resultList.get(i);
                     packages.add(
                             result.getGenericDocument()
-                                    .getPropertyString(
-                                            AppFunctionStaticMetadata.PROPERTY_PACKAGE_NAME));
+                                    .getPropertyString(AppFunctionDocument.PROPERTY_PACKAGE_NAME));
                 }
 
                 resultList = results.getNextPage();
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerConfig.java
index 5737a3d6..18c3cc74 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerConfig.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerConfig.java
@@ -16,6 +16,8 @@
 
 package com.android.server.appsearch.appsindexer;
 
+import android.app.appsearch.AppSearchSession;
+
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -31,13 +33,27 @@ public interface AppsIndexerConfig {
     long DEFAULT_APPS_UPDATE_INTERVAL_MILLIS = TimeUnit.DAYS.toMillis(30); // 30 days.
 
     /** The default maximum number of app functions per package that the app indexer will index. */
-    int DEFAULT_MAX_APP_FUNCTIONS_PER_PACKAGE = 500;
+    int DEFAULT_MAX_APP_FUNCTIONS_PER_PACKAGE = 250;
 
     /**
      * The default maximum number of app function schemas per package that the app indexer will
      * index.
      */
-    int DEFAULT_MAX_ALLOWED_APP_FUNCTION_SCHEMAS_PER_PACKAGE = 5;
+    int DEFAULT_MAX_ALLOWED_APP_FUNCTION_SCHEMAS_PER_PACKAGE = 20;
+
+    /**
+     * The default max allowed size of an app function document.
+     *
+     * <p>More conservative than one enforced by {@link AppSearchSession#put} to prevent app
+     * developers from indexing additional properties in app function documents using this indexer.
+     */
+    int DEFAULT_MAX_ALLOWED_APP_FUNCTION_DOC_SIZE_IN_BYTES = 4 * 1024; // 4KiB
+
+    /**
+     * The default minimum time required to wait before attempting a firstRun sync after a previous
+     * firstRun sync.
+     */
+    long DEFAULT_MIN_TIME_BETWEEN_FIRST_SYNCS_MILLIS = TimeUnit.HOURS.toMillis(4);
 
     /** Returns whether Apps Indexer is enabled. */
     boolean isAppsIndexerEnabled();
@@ -50,4 +66,10 @@ public interface AppsIndexerConfig {
 
     /** Returns the max number of app function schemas the app indexer will index per package. */
     int getMaxAllowedAppFunctionSchemasPerPackage();
+
+    /**
+     * Returns the minimum time required to wait before attempting a firstRun sync after a previous
+     * firstRun sync in milliseconds.
+     */
+    long getMinTimeBetweenFirstSyncsMillis();
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java
index 128785b6..597a1770 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java
@@ -20,6 +20,7 @@ import android.annotation.NonNull;
 import android.annotation.WorkerThread;
 import android.app.appsearch.AppSearchBatchResult;
 import android.app.appsearch.AppSearchResult;
+import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.PackageIdentifier;
 import android.app.appsearch.exceptions.AppSearchException;
@@ -30,8 +31,11 @@ import android.os.SystemClock;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.Log;
+import android.util.Pair;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
@@ -74,11 +78,15 @@ public final class AppsIndexerImpl implements Closeable {
      *     updated.
      * @param appsUpdateStats contains stats about the apps indexer update. This method will
      *     populate the fields of this {@link AppsUpdateStats} structure.
+     * @param isFullUpdateRequired whether to re-index all apps irrespective of their last update
+     *     timestamp.
      */
     @VisibleForTesting
     @WorkerThread
     public void doUpdateIncrementalPut(
-            @NonNull AppsIndexerSettings settings, @NonNull AppsUpdateStats appsUpdateStats)
+            @NonNull AppsIndexerSettings settings,
+            @NonNull AppsUpdateStats appsUpdateStats,
+            boolean isFullUpdateRequired)
             throws AppSearchException {
         // TODO(b/357551503): Add metrics for app function indexing
         Objects.requireNonNull(settings);
@@ -99,7 +107,7 @@ public final class AppsIndexerImpl implements Closeable {
         appsUpdateStats.mPackageManagerLatencyMillis =
                 SystemClock.elapsedRealtime() - beforePackageManagerTimestamp;
 
-        List<AppFunctionStaticMetadata> functionsToAddOrUpdate = new ArrayList<>();
+        List<AppFunctionDocument> functionDocumentsToAddOrUpdate = new ArrayList<>();
         // To remove, we only need the id
         Set<String> functionIdsToRemove = new ArraySet<>();
 
@@ -122,7 +130,7 @@ public final class AppsIndexerImpl implements Closeable {
         // for removed packages, as we can just remove the entire MobileApplication +
         // AppFunctionStaticMetadata schemas, which will in turn remove the documents.
         Map<PackageInfo, ResolveInfos> packagesToBeAddedOrUpdated = new ArrayMap<>();
-        List<String> updatedPackageIds = new ArrayList<>();
+        Set<String> updatedPackageIds = new ArraySet<>();
 
         // First loop, determine the status of apps
         for (Map.Entry<PackageInfo, ResolveInfos> packageEntry : packagesToIndex.entrySet()) {
@@ -141,9 +149,10 @@ public final class AppsIndexerImpl implements Closeable {
                 addedOrRemovedFlag = true;
                 appsUpdateStats.mNumberOfAppsAdded++;
                 packagesToBeAddedOrUpdated.put(packageInfo, packageEntry.getValue());
-            } else if (packageInfo.lastUpdateTime > storedAppUpdateTime) {
-                // Package updated. Add this to the list of updated apps so we can check what
-                // functions are indexed in AppSearch
+            } else if (packageInfo.lastUpdateTime != storedAppUpdateTime || isFullUpdateRequired) {
+                // Package last update timestamp discrepancy between AppSearch and PackageManager
+                // or app indexer code was updated. Add this to the list of updated
+                // apps so we can check what functions are indexed in AppSearch
                 appsUpdateStats.mNumberOfAppsUpdated++;
                 updatedPackageIds.add(packageInfo.packageName);
                 packagesToBeAddedOrUpdated.put(packageInfo, packagesToIndex.get(packageInfo));
@@ -164,32 +173,44 @@ public final class AppsIndexerImpl implements Closeable {
             }
         }
 
+        Map<String, Map<String, AppSearchSchema>> dynamicAppFunctionSchemasForPackages = null;
+        if (Flags.enableAppFunctionsSchemaParser()) {
+            // TODO(b/382254638): Skip XML parsing for packages that were not updated by using
+            // AppSearchSessio#getSchema.
+            dynamicAppFunctionSchemasForPackages =
+                    AppsUtil.getDynamicAppFunctionSchemasForPackages(
+                            packageManager,
+                            packagesToIndex,
+                            mAppsIndexerConfig.getMaxAllowedAppFunctionSchemasPerPackage());
+        }
+
         // Parse and build all necessary AppFunctionStaticMetadata from PackageManager.
-        Map<String, Map<String, AppFunctionStaticMetadata>>
+        Map<String, Map<String, ? extends AppFunctionDocument>>
                 currentAppFunctionsForAddedUpdatedPackages =
-                        AppsUtil.buildAppFunctionStaticMetadataIntoMap(
+                        AppsUtil.buildAppFunctionDocumentsIntoMap(
                                 packageManager,
                                 packagesToBeAddedOrUpdated,
                                 /* indexerPackageName= */ mContext.getPackageName(),
-                                mAppsIndexerConfig.getMaxAppFunctionsPerPackage());
+                                mAppsIndexerConfig,
+                                dynamicAppFunctionSchemasForPackages);
 
         // Get all currently indexed AppFunctionStaticMetadata docs for the necessary packages.
-        Map<String, Map<String, AppFunctionStaticMetadata>> appFunctionsFromAppSearch =
-                mAppSearchHelper.getAppFunctionsFromAppSearch(updatedPackageIds);
+        Map<String, Map<String, AppFunctionDocument>> appFunctionsFromAppSearch =
+                mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(updatedPackageIds);
 
-        for (Map.Entry<String, Map<String, AppFunctionStaticMetadata>> packageEntry :
+        for (Map.Entry<String, Map<String, ? extends AppFunctionDocument>> packageEntry :
                 currentAppFunctionsForAddedUpdatedPackages.entrySet()) {
             String packageName = packageEntry.getKey();
-            Map<String, AppFunctionStaticMetadata> currentAppFunctionsPerApp =
+            Map<String, ? extends AppFunctionDocument> currentAppFunctionsPerApp =
                     packageEntry.getValue();
 
             // This might be null, in the case of functions newly added to a package
-            Map<String, AppFunctionStaticMetadata> appSearchAppFunctionsPerApp =
+            Map<String, AppFunctionDocument> appSearchAppFunctionsPerApp =
                     appFunctionsFromAppSearch.get(packageName);
 
             if (appSearchAppFunctionsPerApp == null && !currentAppFunctionsPerApp.isEmpty()) {
                 // Functions added to an app that didn't have them
-                functionsToAddOrUpdate.addAll(currentAppFunctionsPerApp.values());
+                functionDocumentsToAddOrUpdate.addAll(currentAppFunctionsPerApp.values());
                 addedOrRemovedFlag = true;
             }
 
@@ -199,55 +220,63 @@ public final class AppsIndexerImpl implements Closeable {
                     addedOrRemovedFlag = true;
                 } else {
                     // App updated that had packages, we should check
-                    comparePackageFunctions(
+                    comparePackageFunctionDocuments(
                             currentAppFunctionsPerApp,
                             appSearchAppFunctionsPerApp,
-                            functionsToAddOrUpdate,
+                            functionDocumentsToAddOrUpdate,
                             functionIdsToRemove);
                 }
             }
         }
 
         try {
-            if (addedOrRemovedFlag) {
-                // This boolean will be turned on if we need to call setSchema to keep AppSearch in
-                // sync with PackageManager.
-                List<PackageIdentifier> packageIdentifiers = new ArrayList<>();
-                List<PackageIdentifier> packageIdentifiersWithAppFunctions = new ArrayList<>();
+            // TODO(b/382254638): Skip set schema calls if no packages have an updated schema.
+            if (dynamicAppFunctionSchemasForPackages != null) {
+                // Since dynamic schemas are enabled, we need to account for schema changes in
+                // both updated packages and newly added packages.
+                Pair<List<PackageIdentifier>, List<PackageIdentifier>>
+                        mobileAppAndAppFunctionIdentifiers =
+                                getPackageIdentifiers(
+                                        packagesToIndex,
+                                        currentAppFunctionsForAddedUpdatedPackages);
+
+                long beforeSetSchemaTimestamp = SystemClock.elapsedRealtime();
+                mAppSearchHelper.setSchemasForPackages(
+                        /* mobileAppPkgs= */ mobileAppAndAppFunctionIdentifiers.first,
+                        /* appFunctionPkgs= */ mobileAppAndAppFunctionIdentifiers.second,
+                        dynamicAppFunctionSchemasForPackages);
+                appsUpdateStats.mAppSearchSetSchemaLatencyMillis =
+                        SystemClock.elapsedRealtime() - beforeSetSchemaTimestamp;
+            } else if (addedOrRemovedFlag) {
+                // This branch is executed when dynamic schemas are disabled and new packages are
+                // added or removed to keep the AppSearch schema in sync with
+                // PackageManager.
+                Pair<List<PackageIdentifier>, List<PackageIdentifier>>
+                        mobileAppAndAppFunctionIdentifiers =
+                                getPackageIdentifiers(
+                                        packagesToIndex,
+                                        currentAppFunctionsForAddedUpdatedPackages);
 
-                for (Map.Entry<PackageInfo, ResolveInfos> entry : packagesToIndex.entrySet()) {
-                    // We get certificates here as getting the certificates during the previous for
-                    // loop would be wasteful if we end up not needing to call set schema
-                    PackageInfo packageInfo = entry.getKey();
-                    byte[] certificate = AppsUtil.getCertificate(packageInfo);
-                    if (certificate == null) {
-                        Log.e(TAG, "Certificate not found for package: " + packageInfo.packageName);
-                        continue;
-                    }
-                    PackageIdentifier packageIdentifier =
-                            new PackageIdentifier(packageInfo.packageName, certificate);
-                    packageIdentifiers.add(packageIdentifier);
-                    if (entry.getValue().getAppFunctionServiceInfo() != null) {
-                        packageIdentifiersWithAppFunctions.add(packageIdentifier);
-                    }
-                }
                 // The certificate is necessary along with the package name as it is used in
                 // visibility settings.
                 long beforeSetSchemaTimestamp = SystemClock.elapsedRealtime();
                 mAppSearchHelper.setSchemasForPackages(
-                        packageIdentifiers, packageIdentifiersWithAppFunctions);
+                        /* mobileAppPkgs= */ mobileAppAndAppFunctionIdentifiers.first,
+                        /* appFunctionPkgs= */ mobileAppAndAppFunctionIdentifiers.second);
                 appsUpdateStats.mAppSearchSetSchemaLatencyMillis =
                         SystemClock.elapsedRealtime() - beforeSetSchemaTimestamp;
             }
 
-            if (!packagesToBeAddedOrUpdated.isEmpty() || !functionsToAddOrUpdate.isEmpty()) {
+            if (!packagesToBeAddedOrUpdated.isEmpty()
+                    || !functionDocumentsToAddOrUpdate.isEmpty()) {
                 long beforePutTimestamp = SystemClock.elapsedRealtime();
                 List<MobileApplication> mobileApplications =
                         AppsUtil.buildAppsFromPackageInfos(
                                 packageManager, packagesToBeAddedOrUpdated);
 
                 AppSearchBatchResult<String, Void> result =
-                        mAppSearchHelper.indexApps(mobileApplications, functionsToAddOrUpdate);
+                        mAppSearchHelper.indexApps(
+                                mobileApplications, functionDocumentsToAddOrUpdate);
                 if (result.isSuccess()) {
                     appsUpdateStats.mUpdateStatusCodes.add(AppSearchResult.RESULT_OK);
                 } else {
@@ -284,71 +313,141 @@ public final class AppsIndexerImpl implements Closeable {
     }
 
     /**
-     * Compares the app functions in PackageManager vs those in AppSearch, and updates
-     * functionsToAddOrUpdate and functionIdsToRemove accordingly.
+     * Return a pair of lists of {@link PackageIdentifier}s, the first list representing all
+     * packages, and the second list representing packages with app functions.
+     *
+     * <p>The second list is always a subset of the first list.
+     *
+     * @param packagesToIndex a mapping of {@link PackageInfo}s with their corresponding {@link
+     *     ResolveInfos} for the packages launch activity and maybe app function resolve info.
+     * @param currentAppFunctionsForAddedUpdatedPackages a mapping of package name to a map of all
+     *     app functions for the packages that were either updated or added.
+     * @return a pair of lists of {@link PackageIdentifier}s, the first list representing all
+     *     packages, and the second list representing packages with app functions.
+     */
+    private Pair<List<PackageIdentifier>, List<PackageIdentifier>> getPackageIdentifiers(
+            @NonNull Map<PackageInfo, ResolveInfos> packagesToIndex,
+            Map<String, Map<String, ? extends AppFunctionDocument>>
+                    currentAppFunctionsForAddedUpdatedPackages) {
+        List<PackageIdentifier> packageIdentifiers = new ArrayList<>();
+        List<PackageIdentifier> packageIdentifiersWithAppFunctions = new ArrayList<>();
+        for (Map.Entry<PackageInfo, ResolveInfos> entry : packagesToIndex.entrySet()) {
+            // We get certificates here as getting the certificates during the previous for
+            // loop would be wasteful if we end up not needing to call set schema
+            PackageInfo packageInfo = entry.getKey();
+            byte[] certificate = AppsUtil.getCertificate(packageInfo);
+            if (certificate == null) {
+                Log.e(TAG, "Certificate not found for package: " + packageInfo.packageName);
+                continue;
+            }
+            PackageIdentifier packageIdentifier =
+                    new PackageIdentifier(packageInfo.packageName, certificate);
+            packageIdentifiers.add(packageIdentifier);
+            // Check if the package was updated and all app functions were removed. The map only
+            // contains entries for packages that updated or newly added, for packages with no
+            // change we would rely solely on presence of AppFunctionServiceInfo to decide if it's
+            // an app function package.
+            boolean appFunctionsRemoved =
+                    currentAppFunctionsForAddedUpdatedPackages.containsKey(packageInfo.packageName)
+                            && currentAppFunctionsForAddedUpdatedPackages
+                                    .get(packageInfo.packageName)
+                                    .isEmpty();
+            if (entry.getValue().getAppFunctionServiceInfo() != null && !appFunctionsRemoved) {
+                packageIdentifiersWithAppFunctions.add(packageIdentifier);
+            }
+        }
+        return new Pair<>(packageIdentifiers, packageIdentifiersWithAppFunctions);
+    }
+
+    /**
+     * Compares the app function documents in PackageManager vs those in AppSearch, and updates
+     * functionDocumentsToAddOrUpdate and functionDocumentIdsToRemove accordingly.
      *
-     * @param currentAppFunctionsPerApp the mapping of function ids to documents corresponding to
-     *     what is in the apps metadata.
-     * @param appSearchAppFunctionsPerApp the mapping of function ids to documents corresponding to
-     *     what is in AppSearch
-     * @param functionsToAddOrUpdate the List of {@link GenericDocument} that will be sent to a put
-     *     call to AppSearch
-     * @param functionIdsToRemove the set of ids that will be sent to a remove call in AppSearch
+     * @param currentAppFunctionDocumentsPerApp the mapping of function ids to documents
+     *     corresponding to what is in the apps metadata.
+     * @param appSearchAppFunctionDocumentsPerApp the mapping of function ids to documents
+     *     corresponding to what is in AppSearch
+     * @param functionDocumentsToAddOrUpdate the List of {@link AppFunctionDocument} that will be
+     *     sent to a put call to AppSearch
+     * @param functionDocumentIdsToRemove the set of ids that will be sent to a remove call in
+     *     AppSearch
      */
-    private void comparePackageFunctions(
-            @NonNull Map<String, AppFunctionStaticMetadata> currentAppFunctionsPerApp,
-            @NonNull Map<String, AppFunctionStaticMetadata> appSearchAppFunctionsPerApp,
-            @NonNull List<AppFunctionStaticMetadata> functionsToAddOrUpdate,
-            @NonNull Set<String> functionIdsToRemove) {
-        Objects.requireNonNull(currentAppFunctionsPerApp);
-        Objects.requireNonNull(appSearchAppFunctionsPerApp);
-        Objects.requireNonNull(functionsToAddOrUpdate);
-        Objects.requireNonNull(functionIdsToRemove);
-
-        for (Map.Entry<String, AppFunctionStaticMetadata> currentFunctionEntry :
-                currentAppFunctionsPerApp.entrySet()) {
+    private void comparePackageFunctionDocuments(
+            @NonNull Map<String, ? extends AppFunctionDocument> currentAppFunctionDocumentsPerApp,
+            @NonNull Map<String, AppFunctionDocument> appSearchAppFunctionDocumentsPerApp,
+            @NonNull List<AppFunctionDocument> functionDocumentsToAddOrUpdate,
+            @NonNull Set<String> functionDocumentIdsToRemove) {
+        Objects.requireNonNull(currentAppFunctionDocumentsPerApp);
+        Objects.requireNonNull(appSearchAppFunctionDocumentsPerApp);
+        Objects.requireNonNull(functionDocumentsToAddOrUpdate);
+        Objects.requireNonNull(functionDocumentIdsToRemove);
+
+        for (Map.Entry<String, ? extends AppFunctionDocument> currentFunctionEntry :
+                currentAppFunctionDocumentsPerApp.entrySet()) {
             String functionId = currentFunctionEntry.getKey();
-            AppFunctionStaticMetadata currentFunction = currentFunctionEntry.getValue();
-            AppFunctionStaticMetadata appSearchFunction =
-                    appSearchAppFunctionsPerApp.get(functionId);
-            // appSearchFunction == null means it's a new function, function inequality means
-            // updated function. Both mean we need to call put with this function.
-            if (appSearchFunction == null
-                    || !areFunctionsEqual(appSearchFunction, currentFunction)) {
-                functionsToAddOrUpdate.add(currentFunction);
+            AppFunctionDocument currentFunctionDocument = currentFunctionEntry.getValue();
+            AppFunctionDocument appSearchFunctionDocument =
+                    appSearchAppFunctionDocumentsPerApp.get(functionId);
+            // appSearchFunctionDocument == null means it's a new document, document inequality
+            // means
+            // updated document. Both mean we need to call put with this document.
+            if (appSearchFunctionDocument == null
+                    || !areFunctionDocumentsEqual(
+                            appSearchFunctionDocument, currentFunctionDocument)) {
+                functionDocumentsToAddOrUpdate.add(currentFunctionDocument);
             }
         }
 
-        for (Map.Entry<String, AppFunctionStaticMetadata> appSearchFunctionEntry :
-                appSearchAppFunctionsPerApp.entrySet()) {
-            if (!currentAppFunctionsPerApp.containsKey(appSearchFunctionEntry.getKey())) {
-                functionIdsToRemove.add(appSearchFunctionEntry.getValue().getId());
+        for (Map.Entry<String, AppFunctionDocument> appSearchFunctionEntry :
+                appSearchAppFunctionDocumentsPerApp.entrySet()) {
+            if (!currentAppFunctionDocumentsPerApp.containsKey(appSearchFunctionEntry.getKey())) {
+                functionDocumentIdsToRemove.add(appSearchFunctionEntry.getValue().getId());
             }
         }
     }
 
     /**
-     * Checks if two AppFunctionMetaData documents are equal. It isn't enough to call equals. We
-     * also need to ignore creation timestamp and parent types. These are set in AppSearch, but
-     * aren't set for the "about to be indexed" docs
+     * Checks if two AppFunction documents are equal. It isn't enough to call equals. We also need
+     * to ignore creation timestamp and parent types. These are set in AppSearch, but aren't set for
+     * the "about to be indexed" docs
      *
      * @return true if the documents are equal, false otherwise.
      */
-    private boolean areFunctionsEqual(
-            @NonNull GenericDocument appSearchFunction, @NonNull GenericDocument currentFunction) {
-        Objects.requireNonNull(appSearchFunction);
-        Objects.requireNonNull(currentFunction);
-        appSearchFunction =
-                new GenericDocument.Builder<>(appSearchFunction)
+    private boolean areFunctionDocumentsEqual(
+            @NonNull GenericDocument document1, @NonNull GenericDocument document2) {
+        Objects.requireNonNull(document1);
+        Objects.requireNonNull(document2);
+
+        document1 = clearTimestampsAndParentTypesInDocument(document1);
+        document2 = clearTimestampsAndParentTypesInDocument(document2);
+
+        return document1.equals(document2);
+    }
+
+    private GenericDocument clearTimestampsAndParentTypesInDocument(
+            @NonNull GenericDocument document) {
+        GenericDocument.Builder<?> builder =
+                new GenericDocument.Builder<>(document)
                         .setCreationTimestampMillis(0)
                         // GenericDocument#PARENT_TYPES_SYNTHETIC_PROPERTY is hidden
-                        .clearProperty("$$__AppSearch__parentTypes")
-                        .build();
-        currentFunction =
-                new GenericDocument.Builder<>(currentFunction)
-                        .setCreationTimestampMillis(0)
-                        .build();
-        return appSearchFunction.equals(currentFunction);
+                        .clearProperty("$$__AppSearch__parentTypes");
+
+        for (String propertyName : document.getPropertyNames()) {
+            Object property = document.getProperty(propertyName);
+            if (property instanceof GenericDocument[] nestedDocuments) {
+                GenericDocument[] clearedNestedDocuments =
+                        new GenericDocument[nestedDocuments.length];
+
+                for (int i = 0; i < nestedDocuments.length; i++) {
+                    clearedNestedDocuments[i] =
+                            clearTimestampsAndParentTypesInDocument(nestedDocuments[i]);
+                }
+
+                builder.setPropertyDocument(propertyName, clearedNestedDocuments);
+            }
+        }
+
+        return builder.build();
     }
 
     /**
@@ -474,7 +573,7 @@ public final class AppsIndexerImpl implements Closeable {
                                 packageManager,
                                 packagesToBeAddedOrUpdated,
                                 /* indexerPackageName= */ mContext.getPackageName(),
-                                mAppsIndexerConfig.getMaxAppFunctionsPerPackage());
+                                mAppsIndexerConfig);
 
                 AppSearchBatchResult<String, Void> result =
                         mAppSearchHelper.indexApps(
@@ -524,7 +623,7 @@ public final class AppsIndexerImpl implements Closeable {
             indexedAppFunctionPackages.add(
                     appSearchAppFunctions
                             .get(i)
-                            .getPropertyString(AppFunctionStaticMetadata.PROPERTY_PACKAGE_NAME));
+                            .getPropertyString(AppFunctionDocument.PROPERTY_PACKAGE_NAME));
         }
         Set<String> currentAppFunctionPackages = getCurrentAppFunctionPackages(targetedPackages);
         return !indexedAppFunctionPackages.equals(currentAppFunctionPackages);
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerSettings.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerSettings.java
index c2ca6dc2..a361c6a2 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerSettings.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerSettings.java
@@ -16,6 +16,8 @@
 
 package com.android.server.appsearch.appsindexer;
 
+import static com.android.server.appsearch.appsindexer.AppIndexerVersions.APP_INDEXER_VERSION_UNKNOWN;
+
 import android.annotation.NonNull;
 
 import com.android.server.appsearch.indexer.IndexerSettings;
@@ -36,6 +38,8 @@ public class AppsIndexerSettings extends IndexerSettings {
     static final String SETTINGS_FILE_NAME = "apps_indexer_settings.pb";
     static final String LAST_APP_UPDATE_TIMESTAMP_KEY = "last_app_update_timestamp_millis";
 
+    static final String PREVIOUS_APP_INDEXER_VERSION_CODE = "previous_app_indexer_version_code";
+
     public AppsIndexerSettings(@NonNull File baseDir) {
         super(baseDir);
     }
@@ -55,9 +59,23 @@ public class AppsIndexerSettings extends IndexerSettings {
         mBundle.putLong(LAST_APP_UPDATE_TIMESTAMP_KEY, timestampMillis);
     }
 
+    /** Returns the version code of AppSearch module that previously indexed the apps. */
+    @AppIndexerVersions.AppIndexerVersion
+    public int getPreviousIndexerVersionCode() {
+        return mBundle.getInt(PREVIOUS_APP_INDEXER_VERSION_CODE, APP_INDEXER_VERSION_UNKNOWN);
+    }
+
+    /** Sets the version code of App Indexer that previously indexed the apps. */
+    public void setPreviousIndexerVersionCode(
+            @AppIndexerVersions.AppIndexerVersion int versionCode) {
+        mBundle.putInt(PREVIOUS_APP_INDEXER_VERSION_CODE, versionCode);
+    }
+
+    /** Resets all settings to default values except {@link #getPreviousIndexerVersionCode()}. */
     @Override
     public void reset() {
         super.reset();
         setLastAppUpdateTimestampMillis(0);
+        setPreviousIndexerVersionCode(APP_INDEXER_VERSION_UNKNOWN);
     }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java
index ec109af2..4416b1ec 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java
@@ -16,6 +16,7 @@
 
 package com.android.server.appsearch.appsindexer;
 
+import static com.android.server.appsearch.appsindexer.AppIndexerVersions.CURR_APP_INDEXER_VERSION;
 import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.APPS_INDEXER;
 
 import android.annotation.NonNull;
@@ -222,11 +223,39 @@ public final class AppsIndexerUserInstance {
         try {
             Objects.requireNonNull(appsUpdateStats);
             // Check if there was a prior run
-            if (firstRun && mSettings.getLastUpdateTimestampMillis() != 0) {
-                return;
+            boolean isAppIndexerUpdated =
+                    Flags.enableAllPackageIndexingOnIndexerUpdate()
+                            && checkAndUpdateIndexerVersion();
+            if (firstRun) {
+                if (Flags.enableAppsIndexerCheckPriorAttempt()) {
+                    // Special "firstRun" case.
+                    long now = System.currentTimeMillis();
+                    long lastRun = mSettings.getLastAttemptedUpdateTimestampMillis();
+                    long timeSinceLastRun = now - lastRun;
+
+                    // If timeSinceLastRun is somehow negative, it means that the system clock
+                    // must've turned back since the last run. We'll run the update in this case
+                    if (timeSinceLastRun >= 0
+                            && timeSinceLastRun
+                                    < mAppsIndexerConfig.getMinTimeBetweenFirstSyncsMillis()) {
+                        // Last firstRun was too recent, skip and leave timestamps alone
+                        return;
+                    }
+
+                    mSettings.setLastAttemptedUpdateTimestampMillis(now);
+                    mSettings.persist();
+                }
+
+                // Check if there was a previous successful run and AppSearch wasn't updated since.
+                if (mSettings.getLastUpdateTimestampMillis() != 0 && !isAppIndexerUpdated) {
+                    return;
+                }
             }
             if (Flags.enableAppsIndexerIncrementalPut()) {
-                mAppsIndexerImpl.doUpdateIncrementalPut(mSettings, appsUpdateStats);
+                mAppsIndexerImpl.doUpdateIncrementalPut(
+                        mSettings,
+                        appsUpdateStats,
+                        /* isFullUpdateRequired= */ isAppIndexerUpdated);
             } else {
                 // TODO(b/367410454): Remove this method and related code paths once
                 //  enable_apps_indexer_incremental_put flag is rolled out.
@@ -245,6 +274,21 @@ public final class AppsIndexerUserInstance {
         }
     }
 
+    /**
+     * Checks if the current App Indexer versionCode differs from the previously stored versionCode
+     * in {@link AppsIndexerSettings} and updates the stored versionCode if necessary.
+     *
+     * @return {@code true} if the versionCode has changed, {@code false} otherwise.
+     */
+    private boolean checkAndUpdateIndexerVersion() {
+        if (mSettings.getPreviousIndexerVersionCode() == CURR_APP_INDEXER_VERSION) {
+            return false;
+        }
+
+        mSettings.setPreviousIndexerVersionCode(CURR_APP_INDEXER_VERSION);
+        return true;
+    }
+
     /**
      * Loads the persisted data from disk.
      *
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java b/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java
index 7fd33742..bfc42b3b 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java
@@ -18,6 +18,8 @@ package com.android.server.appsearch.appsindexer;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.GenericDocument;
 import android.app.appsearch.util.LogUtil;
 import android.app.usage.UsageEvents;
 import android.app.usage.UsageStatsManager;
@@ -37,6 +39,7 @@ import android.util.ArrayMap;
 import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
@@ -44,6 +47,7 @@ import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -52,10 +56,6 @@ import java.util.Objects;
 public final class AppsUtil {
     public static final String TAG = "AppSearchAppsUtil";
 
-    // App Open events are user's activity, which is both privacy and recency sensitive. 14 days was
-    // chosen as a reasonable duration to maintain this type of user activity.
-    private static final long APP_OPEN_EVENT_TTL_MILLIS = 1000 * 60 * 60 * 24 * 14; // 14 days
-
     private AppsUtil() {}
 
     /** Gets the resource Uri given a resource id. */
@@ -231,15 +231,15 @@ public final class AppsUtil {
      *     ResolveInfo} for the packages launch activity.
      * @param indexerPackageName the name of the package performing the indexing. This should be the
      *     same as the package running the apps indexer so that qualified ids are correctly created.
-     * @param maxAppFunctions the max number of app functions to be indexed per package.
+     * @param config the app indexer config used to enforce various limits during parsing.
      */
     public static List<AppFunctionStaticMetadata> buildAppFunctionStaticMetadata(
             @NonNull PackageManager packageManager,
             @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
             @NonNull String indexerPackageName,
-            int maxAppFunctions) {
-        AppFunctionStaticMetadataParser parser =
-                new AppFunctionStaticMetadataParserImpl(indexerPackageName, maxAppFunctions);
+            AppsIndexerConfig config) {
+        AppFunctionDocumentParser parser =
+                new AppFunctionDocumentParserImpl(indexerPackageName, config);
         return buildAppFunctionStaticMetadata(packageManager, packageInfos, parser);
     }
 
@@ -253,7 +253,7 @@ public final class AppsUtil {
     static List<AppFunctionStaticMetadata> buildAppFunctionStaticMetadata(
             @NonNull PackageManager packageManager,
             @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
-            @NonNull AppFunctionStaticMetadataParser parser) {
+            @NonNull AppFunctionDocumentParser parser) {
         Objects.requireNonNull(packageManager);
         Objects.requireNonNull(packageInfos);
         Objects.requireNonNull(parser);
@@ -289,46 +289,58 @@ public final class AppsUtil {
 
     /**
      * Uses {@link PackageManager} and a Map of {@link PackageInfo}s to {@link ResolveInfos}s to
-     * build AppSearch {@link AppFunctionStaticMetadata} documents. Info from both are required to
-     * build app documents.
+     * build AppSearch {@link GenericDocument} objects. Info from both are required to build app
+     * documents.
      *
-     * <p>App documents will be returned as a mapping of packages to a mapping of function ids to
-     * AppFunctionStaticMetadata documents. This is useful for determining what has changed during
-     * an update.
+     * <p>App documents will be returned as a mapping of packages to a mapping of document ids to
+     * documents. This is useful for determining what has changed during an update.
+     *
+     * <p>The parser will parse app function documents based on schemas if schemasPerPackage is not
+     * null or the map of schemas for a package is not empty, else it will default to predefined
+     * schema properties created by {@link
+     * AppFunctionStaticMetadata#createAppFunctionSchemaForPackage} to create the {@link
+     * AppFunctionStaticMetadata} documents.
      *
      * @param packageInfos a mapping of {@link PackageInfo}s and their corresponding {@link
      *     ResolveInfo} for the packages launch activity.
      * @param indexerPackageName the name of the package performing the indexing. This should be the
      *     same as the package running the apps indexer so that qualified ids are correctly created.
-     * @param maxAppFunctions the max number of app functions to be indexed per package.
-     * @return A mapping of packages to a mapping of function ids to AppFunctionStaticMetadata
-     *     documents
+     * @param config the app indexer config used to enforce various limits during parsing.
+     * @param schemasPerPackage a mapping of packages to a mapping of schema types to their
+     *     corresponding {@link AppSearchSchema} objects, or null if there are no schemas to
+     *     consider.
+     * @return A mapping of packages to a mapping of document ids to AppFunction GenericDocuments
+     *     conforming the schemas for the corresponding package.
      */
-    public static Map<String, Map<String, AppFunctionStaticMetadata>>
-            buildAppFunctionStaticMetadataIntoMap(
+    public static Map<String, Map<String, ? extends AppFunctionDocument>>
+            buildAppFunctionDocumentsIntoMap(
                     @NonNull PackageManager packageManager,
                     @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
                     @NonNull String indexerPackageName,
-                    int maxAppFunctions) {
-        AppFunctionStaticMetadataParser parser =
-                new AppFunctionStaticMetadataParserImpl(indexerPackageName, maxAppFunctions);
-        return buildAppFunctionStaticMetadataIntoMap(packageManager, packageInfos, parser);
+                    AppsIndexerConfig config,
+                    @Nullable Map<String, Map<String, AppSearchSchema>> schemasPerPackage) {
+        AppFunctionDocumentParser parser =
+                new AppFunctionDocumentParserImpl(indexerPackageName, config);
+        return buildAppFunctionDocumentsIntoMap(
+                packageManager, packageInfos, parser, schemasPerPackage);
     }
 
     /**
      * Similar to the above {@link #buildAppFunctionStaticMetadata}, but allows the caller to
      * provide a custom parser. This is for testing purposes.
+     *
+     * @see #buildAppFunctionDocumentsIntoMap(PackageManager, Map, String, AppsIndexerConfig, Map)
      */
     @VisibleForTesting
-    static Map<String, Map<String, AppFunctionStaticMetadata>>
-            buildAppFunctionStaticMetadataIntoMap(
-                    @NonNull PackageManager packageManager,
-                    @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
-                    @NonNull AppFunctionStaticMetadataParser parser) {
+    static Map<String, Map<String, ? extends AppFunctionDocument>> buildAppFunctionDocumentsIntoMap(
+            @NonNull PackageManager packageManager,
+            @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
+            @NonNull AppFunctionDocumentParser parser,
+            @Nullable Map<String, Map<String, AppSearchSchema>> schemasPerPackage) {
         Objects.requireNonNull(packageManager);
         Objects.requireNonNull(packageInfos);
         Objects.requireNonNull(parser);
-        Map<String, Map<String, AppFunctionStaticMetadata>> appFunctions = new ArrayMap<>();
+        Map<String, Map<String, ? extends AppFunctionDocument>> appFunctions = new ArrayMap<>();
         for (Map.Entry<PackageInfo, ResolveInfos> entry : packageInfos.entrySet()) {
             PackageInfo packageInfo = entry.getKey();
             ResolveInfo resolveInfo = entry.getValue().getAppFunctionServiceInfo();
@@ -337,10 +349,26 @@ public final class AppsUtil {
             }
 
             String assetFilePath;
+            boolean isDynamicSchemaDefined =
+                    schemasPerPackage != null
+                            && !schemasPerPackage
+                                    .getOrDefault(packageInfo.packageName, Collections.emptyMap())
+                                    .isEmpty();
+
+            // Currently SDK will generate two files for hardcoded and dynamic schemas respectively
+            // so that devices running older AppSearch versions that are incompatible with new
+            // format can continue to parse app function documents while newer versions can use v2
+            // file for constructing app function documents with dynamic schema and more properties.
+            // TODO(b/386676297) - Merge these two when enough devices have changes to support
+            // dynamic schema.
+            String appFunctionXmlPropertyName =
+                    isDynamicSchemaDefined
+                            ? "android.app.appfunctions.v2"
+                            : "android.app.appfunctions";
             try {
                 PackageManager.Property property =
                         packageManager.getProperty(
-                                "android.app.appfunctions",
+                                appFunctionXmlPropertyName,
                                 new ComponentName(
                                         resolveInfo.serviceInfo.packageName,
                                         resolveInfo.serviceInfo.name));
@@ -349,11 +377,22 @@ public final class AppsUtil {
                 Log.w(TAG, "buildAppFunctionMetadataFromPackageInfo: Failed to get property", e);
                 continue;
             }
+
             if (assetFilePath != null) {
-                appFunctions.put(
-                        packageInfo.packageName,
-                        parser.parseIntoMap(
-                                packageManager, packageInfo.packageName, assetFilePath));
+                if (isDynamicSchemaDefined) {
+                    appFunctions.put(
+                            packageInfo.packageName,
+                            parser.parseIntoMapForGivenSchemas(
+                                    packageManager,
+                                    packageInfo.packageName,
+                                    assetFilePath,
+                                    schemasPerPackage.get(packageInfo.packageName)));
+                } else {
+                    appFunctions.put(
+                            packageInfo.packageName,
+                            parser.parseIntoMap(
+                                    packageManager, packageInfo.packageName, assetFilePath));
+                }
             }
         }
         return appFunctions;
@@ -464,4 +503,66 @@ public final class AppsUtil {
         }
         return builder.build();
     }
+
+    /**
+     * Creates dynamic app function schemas defined by the app per package.
+     *
+     * <p>Packages which don't have a AppFunctionService will not have an entry in the returned map.
+     *
+     * @param packageManager the {@link PackageManager} to use to get the schema file path.
+     * @param packageInfos a mapping of {@link PackageInfo}s and their corresponding {@link
+     *     ResolveInfo} for the packages launch activity.
+     * @param maxAllowedAppFunctionSchemasPerPackage the max number of schema definitions allowed
+     *     per package.
+     * @return A mapping of packages to a mapping of schema types to their corresponding {@link
+     *     AppSearchSchema} objects or an empty map for a package if there's an error during parsing
+     *     or no schema file is found.
+     */
+    @NonNull
+    public static Map<String, Map<String, AppSearchSchema>> getDynamicAppFunctionSchemasForPackages(
+            @NonNull PackageManager packageManager,
+            @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
+            int maxAllowedAppFunctionSchemasPerPackage) {
+        Objects.requireNonNull(packageInfos);
+
+        Map<String, Map<String, AppSearchSchema>> schemasPerPackage = new ArrayMap<>();
+        AppFunctionSchemaParser parser =
+                new AppFunctionSchemaParser(maxAllowedAppFunctionSchemasPerPackage);
+        for (Map.Entry<PackageInfo, ResolveInfos> entry : packageInfos.entrySet()) {
+            PackageInfo packageInfo = entry.getKey();
+            ResolveInfo resolveInfo = entry.getValue().getAppFunctionServiceInfo();
+            if (resolveInfo == null) {
+                continue;
+            }
+
+            String assetFilePath = null;
+            try {
+                PackageManager.Property property =
+                        packageManager.getProperty(
+                                /* propertyName= */ "android.app.appfunctions.schema",
+                                new ComponentName(
+                                        resolveInfo.serviceInfo.packageName,
+                                        resolveInfo.serviceInfo.name));
+                assetFilePath = property.getString();
+            } catch (PackageManager.NameNotFoundException e) {
+                Log.w(
+                        TAG,
+                        "getDynamicAppFunctionSchemasForPackages: Failed to get schema "
+                                + "property for package: "
+                                + resolveInfo.serviceInfo.packageName,
+                        e);
+            }
+
+            if (assetFilePath != null) {
+                schemasPerPackage.put(
+                        packageInfo.packageName,
+                        parser.parseAndCreateSchemas(
+                                packageManager, packageInfo.packageName, assetFilePath));
+            } else {
+                schemasPerPackage.put(packageInfo.packageName, Collections.emptyMap());
+            }
+        }
+
+        return schemasPerPackage;
+    }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java
index c0eb19e5..ddf5dc04 100644
--- a/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java
+++ b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java
@@ -31,6 +31,8 @@ public class FrameworkAppOpenEventIndexerConfig implements AppOpenEventIndexerCo
     static final String KEY_APP_OPEN_EVENT_INDEXER_ENABLED = "app_open_event_indexer_enabled";
     static final String KEY_APP_OPEN_EVENT_UPDATE_INTERVAL_MILLIS =
             "app_open_event_update_interval_millis";
+    static final String KEY_APP_OPEN_EVENT_MIN_TIME_BETWEEN_SYNCS_MILLIS =
+            "min_time_between_syncs_millis";
 
     @Override
     public boolean isAppOpenEventIndexerEnabled() {
@@ -47,4 +49,12 @@ public class FrameworkAppOpenEventIndexerConfig implements AppOpenEventIndexerCo
                 KEY_APP_OPEN_EVENT_UPDATE_INTERVAL_MILLIS,
                 DEFAULT_APP_OPEN_EVENT_INDEXER_UPDATE_INTERVAL_MILLIS);
     }
+
+    @Override
+    public long getMinTimeBetweenSyncsMillis() {
+        return DeviceConfig.getLong(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_APP_OPEN_EVENT_MIN_TIME_BETWEEN_SYNCS_MILLIS,
+                DEFAULT_APP_OPEN_EVENT_MIN_TIME_BETWEEN_SYNCS_MILLIS);
+    }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/FrameworkAppsIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppsIndexerConfig.java
index 2a67a353..5938d0ba 100644
--- a/service/java/com/android/server/appsearch/appsindexer/FrameworkAppsIndexerConfig.java
+++ b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppsIndexerConfig.java
@@ -33,6 +33,10 @@ public class FrameworkAppsIndexerConfig implements AppsIndexerConfig {
     static final String KEY_MAX_APP_FUNCTIONS_PER_PACKAGE = "max_app_functions_per_package";
     static final String KEY_MAX_ALLOWED_APP_FUNCTION_SCHEMAS_PER_PACKAGE =
             "max_allowed_app_function_schemas_per_package";
+    static final String KEY_MAX_ALLOWED_APP_FUNCTION_DOC_SIZE_IN_BYTES =
+            "max_allowed_app_function_doc_size_in_bytes";
+    static final String KEY_MIN_TIME_BETWEEN_FIRST_SYNCS_MILLIS =
+            "min_time_between_first_syncs_millis";
 
     @Override
     public boolean isAppsIndexerEnabled() {
@@ -65,5 +69,12 @@ public class FrameworkAppsIndexerConfig implements AppsIndexerConfig {
                 KEY_MAX_ALLOWED_APP_FUNCTION_SCHEMAS_PER_PACKAGE,
                 DEFAULT_MAX_ALLOWED_APP_FUNCTION_SCHEMAS_PER_PACKAGE);
     }
-}
 
+    @Override
+    public long getMinTimeBetweenFirstSyncsMillis() {
+        return DeviceConfig.getLong(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_MIN_TIME_BETWEEN_FIRST_SYNCS_MILLIS,
+                DEFAULT_MIN_TIME_BETWEEN_FIRST_SYNCS_MILLIS);
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionDocument.java b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionDocument.java
new file mode 100644
index 00000000..ea77aab9
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionDocument.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer.appsearchtypes;
+
+import android.annotation.NonNull;
+import android.app.appsearch.GenericDocument;
+import android.app.appsearch.util.DocumentIdUtil;
+
+import com.android.server.appsearch.appsindexer.AppSearchHelper;
+
+import java.util.Objects;
+
+/** Parent type for all top level App Function related documents, providing common properties. */
+public class AppFunctionDocument extends GenericDocument {
+
+    public static final String PROPERTY_PACKAGE_NAME = "packageName";
+    public static final String PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID =
+            "mobileApplicationQualifiedId";
+
+    /**
+     * Returns a per-app schema name.
+     *
+     * @param pkg the package name of the app that owns the schema.
+     * @param schemaType the type of the schema.
+     * @return the schema name by concatenating the type and the package name.
+     */
+    public static String getSchemaNameForPackage(@NonNull String pkg, @NonNull String schemaType) {
+        return schemaType + "-" + Objects.requireNonNull(pkg);
+    }
+
+    public AppFunctionDocument(@NonNull GenericDocument genericDocument) {
+        super(genericDocument);
+    }
+
+    /** The package name of the app that owns the function. */
+    @NonNull
+    public String getPackageName() {
+        return Objects.requireNonNull(getPropertyString(PROPERTY_PACKAGE_NAME));
+    }
+
+    /**
+     * Returns the qualified id linking to the {@link MobileApplication} document representing the
+     * metadata about the app that owns this document.
+     */
+    @NonNull
+    public String getMobileApplicationQualifiedId() {
+        return Objects.requireNonNull(getPropertyString(PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID));
+    }
+
+    /**
+     * Builder for {@link AppFunctionDocument} and its subclasses, extending {@link
+     * GenericDocument.Builder}.
+     *
+     * <p>The parameterization allows extending this builder for subclasses of AppFunctionDocument.
+     *
+     * @param <T> Type of subclass who extends this..
+     */
+    public static class Builder<T extends Builder<T>> extends GenericDocument.Builder<T> {
+
+        /**
+         * Creates a Builder for a {@link AppFunctionDocument}.
+         *
+         * @param packageName the name of the package that owns the function.
+         * @param documentId the id of the document.
+         * @param indexerPackageName the name of the package performing the indexing. This should be
+         *     the same as the package running the apps indexer so that qualified ids are correctly
+         *     created.
+         * @param schemaType the schemaType of the document
+         */
+        public Builder(
+                @NonNull String packageName,
+                @NonNull String documentId,
+                @NonNull String indexerPackageName,
+                @NonNull String schemaType) {
+            super(
+                    AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE,
+                    Objects.requireNonNull(packageName) + "/" + Objects.requireNonNull(documentId),
+                    getSchemaNameForPackage(packageName, Objects.requireNonNull(schemaType)));
+
+            setPropertyString(PROPERTY_PACKAGE_NAME, packageName);
+            setPropertyString(
+                    PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID,
+                    DocumentIdUtil.createQualifiedId(
+                            Objects.requireNonNull(indexerPackageName),
+                            AppSearchHelper.APP_DATABASE,
+                            MobileApplication.APPS_NAMESPACE,
+                            packageName));
+        }
+
+        @Override
+        @NonNull
+        public AppFunctionDocument build() {
+            return new AppFunctionDocument(super.build());
+        }
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadata.java b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadata.java
index 9a7aa095..ad29ca20 100644
--- a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadata.java
+++ b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadata.java
@@ -21,11 +21,9 @@ import android.annotation.Nullable;
 import android.annotation.StringRes;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
-import android.app.appsearch.util.DocumentIdUtil;
 import android.os.Build;
 
 import com.android.internal.annotations.VisibleForTesting;
-import com.android.server.appsearch.appsindexer.AppSearchHelper;
 
 import java.util.Objects;
 
@@ -37,14 +35,13 @@ import java.util.Objects;
  */
 // TODO(b/357551503): Link to canonical docs rather than duplicating once they
 // are available.
-public class AppFunctionStaticMetadata extends GenericDocument {
+public class AppFunctionStaticMetadata extends AppFunctionDocument {
     private static final String TAG = "AppSearchAppFunction";
 
     public static final String SCHEMA_TYPE = "AppFunctionStaticMetadata";
 
     public static final String APP_FUNCTION_NAMESPACE = "app_functions";
     public static final String PROPERTY_FUNCTION_ID = "functionId";
-    public static final String PROPERTY_PACKAGE_NAME = "packageName";
     public static final String PROPERTY_SCHEMA_NAME = "schemaName";
     public static final String PROPERTY_SCHEMA_VERSION = "schemaVersion";
     public static final String PROPERTY_SCHEMA_CATEGORY = "schemaCategory";
@@ -52,24 +49,9 @@ public class AppFunctionStaticMetadata extends GenericDocument {
     public static final String PROPERTY_ENABLED_BY_DEFAULT = "enabledByDefault";
     public static final String PROPERTY_RESTRICT_CALLERS_WITH_EXECUTE_APP_FUNCTIONS =
             "restrictCallersWithExecuteAppFunctions";
-    public static final String PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID =
-            "mobileApplicationQualifiedId";
     public static final AppSearchSchema PARENT_TYPE_APPSEARCH_SCHEMA =
             createAppFunctionSchemaForPackage(/* packageName= */ null);
 
-    /**
-     * Returns a per-app schema name.
-     *
-     * @param pkg the package name of the app that owns the schema.
-     * @param schemaType the type of the schema. If null, {@link #SCHEMA_TYPE} will be used.
-     * @return the schema name by concatenating the type and the package name.
-     */
-    public static String getSchemaNameForPackage(@NonNull String pkg, @Nullable String schemaType) {
-        return ((schemaType == null) ? SCHEMA_TYPE : schemaType)
-                + "-"
-                + Objects.requireNonNull(pkg);
-    }
-
     /**
      * Different packages have different visibility requirements. To allow for different visibility,
      * we need to have per-package app function schemas.
@@ -83,7 +65,7 @@ public class AppFunctionStaticMetadata extends GenericDocument {
                 new AppSearchSchema.Builder(
                         (packageName == null)
                                 ? SCHEMA_TYPE
-                                : getSchemaNameForPackage(packageName, /* schemaType= */ null));
+                                : getSchemaNameForPackage(packageName, SCHEMA_TYPE));
         if (shouldSetParentType() && packageName != null) {
             // This is a child schema, setting the parent type.
             builder.addParentType(SCHEMA_TYPE);
@@ -240,13 +222,19 @@ public class AppFunctionStaticMetadata extends GenericDocument {
 
     /** Whether a parent type should be set for {@link AppFunctionStaticMetadata}. */
     public static boolean shouldSetParentType() {
-        // addParentTypes() is also available on T Extensions 10+. However, we only need it to work
-        // on V+ devices because that is where AppFunctionManager will be available anyway. So,
-        // we're just checking for V+ here to keep it simple.
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.VANILLA_ICE_CREAM;
+        // While added to the SDK in V, addParentTypes() is safe to call on versions above U (Icing
+        // added support for inheritance in the original U build, but the AppSearch API was not
+        // exposed until M-2023-08).
+        //
+        // The fact that this code is running at all implies that the current version > M-2023-08.
+        // Therefore, we know that addParentTypes is an available API.
+        //
+        // However, we cannot call addParentTypes() on T devices as a mainline rollback could break
+        // the schema.
+        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
     }
 
-    public static final class Builder extends GenericDocument.Builder<Builder> {
+    public static final class Builder extends AppFunctionDocument.Builder<Builder> {
         /**
          * Creates a Builder for a {@link AppFunctionStaticMetadata}.
          *
@@ -260,24 +248,10 @@ public class AppFunctionStaticMetadata extends GenericDocument {
                 @NonNull String packageName,
                 @NonNull String functionId,
                 @NonNull String indexerPackageName) {
-            super(
-                    APP_FUNCTION_NAMESPACE,
-                    Objects.requireNonNull(packageName) + "/" + Objects.requireNonNull(functionId),
-                    getSchemaNameForPackage(packageName, /* schemaType= */ null));
+            super(packageName, Objects.requireNonNull(functionId), indexerPackageName, SCHEMA_TYPE);
             setPropertyString(PROPERTY_FUNCTION_ID, functionId);
-            setPropertyString(PROPERTY_PACKAGE_NAME, packageName);
-
             // Default values of properties.
             setPropertyBoolean(PROPERTY_ENABLED_BY_DEFAULT, true);
-
-            // Set qualified id automatically
-            setPropertyString(
-                    PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID,
-                    DocumentIdUtil.createQualifiedId(
-                            indexerPackageName,
-                            AppSearchHelper.APP_DATABASE,
-                            MobileApplication.APPS_NAMESPACE,
-                            packageName));
         }
 
         /**
diff --git a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppOpenEvent.java b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppOpenEvent.java
index 471d5163..a472c0f9 100644
--- a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppOpenEvent.java
+++ b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppOpenEvent.java
@@ -26,6 +26,7 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.appsindexer.AppSearchHelper;
 
 import java.util.Objects;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Represents an app open event in AppSearch. App open events track when a user opens an application
@@ -46,6 +47,10 @@ public class AppOpenEvent extends GenericDocument {
     public static final String APP_OPEN_EVENT_PROPERTY_APP_OPEN_TIMESTAMP_MILLIS =
             "appOpenTimestampMillis";
 
+    // App Open events are user's activity, which is both privacy and recency sensitive. 14 days was
+    // chosen as a reasonable duration to maintain this type of user activity.
+    public static final long APP_OPEN_EVENT_TTL_MILLIS = TimeUnit.DAYS.toMillis(14);
+
     // Schema
     public static final AppSearchSchema SCHEMA =
             new AppSearchSchema.Builder(SCHEMA_TYPE)
@@ -70,7 +75,8 @@ public class AppOpenEvent extends GenericDocument {
                                     .setCardinality(
                                             AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
                                     .build())
-                    .addProperty(
+                    .addProperty( // TODO: Consider using matchScoreExpression to eliminate the need
+                                  // for this field.
                             new AppSearchSchema.LongPropertyConfig.Builder(
                                             APP_OPEN_EVENT_PROPERTY_APP_OPEN_TIMESTAMP_MILLIS)
                                     .setIndexingType(
@@ -147,6 +153,8 @@ public class AppOpenEvent extends GenericDocument {
                         .setPropertyString(
                                 APP_OPEN_EVENT_PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID,
                                 qualifiedId)
+                        .setCreationTimestampMillis(appOpenEventTimestampMillis)
+                        .setTtlMillis(APP_OPEN_EVENT_TTL_MILLIS)
                         .build();
 
         return new AppOpenEvent(document);
diff --git a/service/java/com/android/server/appsearch/contactsindexer/ContactsIndexerUserInstance.java b/service/java/com/android/server/appsearch/contactsindexer/ContactsIndexerUserInstance.java
index c21ba117..235084c2 100644
--- a/service/java/com/android/server/appsearch/contactsindexer/ContactsIndexerUserInstance.java
+++ b/service/java/com/android/server/appsearch/contactsindexer/ContactsIndexerUserInstance.java
@@ -18,6 +18,9 @@ package com.android.server.appsearch.contactsindexer;
 
 import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.CONTACTS_INDEXER;
 
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.WorkerThread;
@@ -29,10 +32,12 @@ import android.content.Context;
 import android.database.ContentObserver;
 import android.net.Uri;
 import android.os.CancellationSignal;
+import android.os.SystemClock;
 import android.provider.ContactsContract;
 import android.util.Log;
 import android.util.Slog;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.indexer.IndexerMaintenanceService;
@@ -232,6 +237,11 @@ public final class ContactsIndexerUserInstance {
         }
     }
 
+    @VisibleForTesting
+    ContactsIndexerSettings getSettings() {
+        return mSettings;
+    }
+
     /**
      * Performs a one-time sync of CP2 contacts into AppSearch.
      *
@@ -247,7 +257,8 @@ public final class ContactsIndexerUserInstance {
      * syncs a configurable number of CP2 contacts into the AppSearch Person corpus so that it's
      * nominally functional.
      */
-    private void doCp2SyncFirstRun() {
+    @VisibleForTesting
+    void doCp2SyncFirstRun() {
         // If this is not the first run of contacts indexer (lastFullUpdateTimestampMillis is not 0)
         // for the given user and a full update job is scheduled, this means that contacts indexer
         // has been running recently and contacts should be up to date. The initial sync can be
@@ -255,10 +266,21 @@ public final class ContactsIndexerUserInstance {
         // If the job is not scheduled but lastFullUpdateTimestampMillis is not 0, the contacts
         // indexer was disabled before. We need to reschedule the job and run a limited delta update
         // to bring latest contact change in AppSearch right away, after it is re-enabled.
-        if (mSettings.getLastFullUpdateTimestampMillis() != 0
-                && IndexerMaintenanceService.isUpdateJobScheduled(
-                        mContext, mContext.getUser(), CONTACTS_INDEXER)) {
-            return;
+        if (Flags.enableCheckContactsIndexerUpdateJobParams()) {
+            if (mSettings.getLastFullUpdateTimestampMillis() != 0
+                    && IndexerMaintenanceService.isUpdateJobScheduledWithExpectedParams(
+                    mContext,
+                    mContext.getUser(),
+                    CONTACTS_INDEXER,
+                    mContactsIndexerConfig.getContactsFullUpdateIntervalMillis())) {
+                return;
+            }
+        } else {
+            if (mSettings.getLastFullUpdateTimestampMillis() != 0
+                    && IndexerMaintenanceService.isUpdateJobScheduled(mContext, mContext.getUser(),
+                    CONTACTS_INDEXER)) {
+                return;
+            }
         }
         IndexerMaintenanceService.scheduleUpdateJob(
                 mContext,
@@ -480,7 +502,9 @@ public final class ContactsIndexerUserInstance {
             // Record that the CP2 change notification is being handled by this delta update task.
             mCp2ChangePending = false;
         }
-
+        if (Flags.enableCheckContactsIndexerDeltaTimestamps()) {
+            checkDeltaTimestamps();
+        }
         long currentTimeMillis = System.currentTimeMillis();
         updateStats.mUpdateType = ContactsUpdateStats.DELTA_UPDATE;
         updateStats.mUpdateAndDeleteStartTimeMillis = currentTimeMillis;
@@ -684,6 +708,42 @@ public final class ContactsIndexerUserInstance {
         }
     }
 
+    /**
+     * Checks if the delta timestamps are newer than the current system time, and if they are newer,
+     * resets the timestamps to the current system time minus the elapsed system time (the estimated
+     * system boot time) and schedules a full update.
+     *
+     * <p>When the delta timestamps are newer than the current system time, any changes to contacts
+     * will be "in the past" and will not be caught in delta updates. Resetting the timestamps is a
+     * temporary measure. It's possible that the new time does not catch previously-missed updates
+     * if it was not set early enough, so we need to schedule a full update to make sure the corpus
+     * is synced properly.
+     */
+    @WorkerThread
+    private void checkDeltaTimestamps() {
+        long currentTimeMillis = System.currentTimeMillis();
+        long lastContactUpdateTimestampMillis = mSettings.getLastContactUpdateTimestampMillis();
+        long lastContactDeleteTimestampMillis = mSettings.getLastContactDeleteTimestampMillis();
+        if (currentTimeMillis < lastContactUpdateTimestampMillis
+                || currentTimeMillis < lastContactDeleteTimestampMillis) {
+            // Reset the delta timestamps to a reasonable time before the current system time so
+            // that the latest changes are caught in the incoming delta update
+            long bootTimeMillis = max(currentTimeMillis - SystemClock.elapsedRealtime(), 0);
+            mSettings.setLastContactUpdateTimestampMillis(
+                    min(lastContactUpdateTimestampMillis, bootTimeMillis));
+            mSettings.setLastContactDeleteTimestampMillis(
+                    min(lastContactDeleteTimestampMillis, bootTimeMillis));
+            persistSettings();
+            // Schedule a full update since the new delta timestamp may still be missing changes
+            IndexerMaintenanceService.scheduleUpdateJob(
+                    mContext,
+                    mContext.getUser(),
+                    CONTACTS_INDEXER,
+                    /* periodic= */ false,
+                    /* intervalMillis= */ -1);
+        }
+    }
+
     /**
      * Executes the given command on {@link #mSingleThreadedExecutor} if it is still alive.
      *
diff --git a/service/java/com/android/server/appsearch/contactsindexer/ContactsProviderUtil.java b/service/java/com/android/server/appsearch/contactsindexer/ContactsProviderUtil.java
index 2c49078a..86ce5eff 100644
--- a/service/java/com/android/server/appsearch/contactsindexer/ContactsProviderUtil.java
+++ b/service/java/com/android/server/appsearch/contactsindexer/ContactsProviderUtil.java
@@ -28,6 +28,8 @@ import android.provider.ContactsContract.Contacts;
 import android.provider.ContactsContract.DeletedContacts;
 import android.util.Log;
 
+import com.android.appsearch.flags.Flags;
+
 import java.util.List;
 import java.util.Objects;
 
@@ -78,20 +80,12 @@ public final class ContactsProviderUtil {
 
         String[] selectionArgs = new String[] {Long.toString(sinceFilter)};
         long newTimestamp = sinceFilter;
-        Cursor cursor = null;
-        try {
-            // TODO(b/203605504) We could optimize the query by setting the sortOrder:
-            //  LAST_DELETED_TIMESTAMP DESC. This way the 1st contact would have the last deleted
-            //  timestamp.
-            cursor =
-                    context.getContentResolver()
-                            .query(
-                                    DeletedContacts.CONTENT_URI,
-                                    DELETION_SELECTION,
-                                    DELETION_SINCE,
-                                    selectionArgs,
-                                    /* sortOrder= */ null);
-
+        // TODO(b/203605504) We could optimize the query by setting the sortOrder:
+        //  LAST_DELETED_TIMESTAMP DESC. This way the 1st contact would have the last deleted
+        //  timestamp.
+        try (Cursor cursor = context.getContentResolver().query(DeletedContacts.CONTENT_URI,
+                DELETION_SELECTION, DELETION_SINCE, selectionArgs,
+                /* sortOrder= */ null)) {
             if (cursor == null) {
                 Log.e(TAG, "Could not fetch deleted contacts - no contacts provider present?");
                 if (updateStats != null) {
@@ -103,12 +97,27 @@ public final class ContactsProviderUtil {
             int contactIdIndex = cursor.getColumnIndex(DeletedContacts.CONTACT_ID);
             int timestampIndex = cursor.getColumnIndex(DeletedContacts.CONTACT_DELETED_TIMESTAMP);
             long rows = 0;
+            // When the checkDeltaTimestamps flag is enabled, we return the timestamp for the
+            // contact most recently deleted _before_ the current system time. This timestamp is
+            // where we will begin fetching contact deletions from in the following delta update. If
+            // we return a timestamp that is ahead of the current system time, any contact deletions
+            // made in CP2 between now and that future time will be ignored by any following delta
+            // updates. Note, under normal circumstances, we will never have contacts with a
+            // deletion timestamp ahead of the current system time.
+            long currentTimeMillis = System.currentTimeMillis();
             while (cursor.moveToNext()) {
                 contactIds.add(String.valueOf(cursor.getLong(contactIdIndex)));
                 // We still get max value between those two here just in case cursor.getLong
                 // returns something unexpected(e.g. somehow it returns an invalid value like
                 // -1 or 0 due to an invalid index).
-                newTimestamp = Math.max(newTimestamp, cursor.getLong(timestampIndex));
+                if (Flags.enableCheckContactsIndexerDeltaTimestamps()) {
+                    long timestamp = cursor.getLong(timestampIndex);
+                    if (timestamp <= currentTimeMillis) {
+                        newTimestamp = Math.max(newTimestamp, timestamp);
+                    }
+                } else {
+                    newTimestamp = Math.max(newTimestamp, cursor.getLong(timestampIndex));
+                }
                 ++rows;
             }
             if (LogUtil.DEBUG) {
@@ -123,10 +132,6 @@ public final class ContactsProviderUtil {
                 updateStats.mDeleteStatuses.add(
                         ContactsUpdateStats.ERROR_CODE_CP2_RUNTIME_EXCEPTION);
             }
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
         }
 
         return newTimestamp;
@@ -181,10 +186,17 @@ public final class ContactsProviderUtil {
                 }
                 return newTimestamp;
             }
-
             int contactIdIndex = cursor.getColumnIndex(Contacts._ID);
             int timestampIndex = cursor.getColumnIndex(Contacts.CONTACT_LAST_UPDATED_TIMESTAMP);
             int numContacts = 0;
+            // When the checkDeltaTimestamps flag is enabled, we return the timestamp for the
+            // contact most recently updated _before_ the current system time. This timestamp is
+            // where we will begin fetching contact updates from in the following delta update. If
+            // we return a timestamp that is ahead of the current system time, any contact updates
+            // made in CP2 between now and that future time will be ignored by any following delta
+            // updates. Note, under normal circumstances, we will never have contacts with an update
+            // timestamp ahead of the current system time.
+            long currentTimeMillis = System.currentTimeMillis();
             while (cursor.moveToNext()) {
                 // Just in case the LIMIT parameter doesn't work in the query to CP2.
                 if (limit >= 0 && numContacts >= limit) {
@@ -194,7 +206,14 @@ public final class ContactsProviderUtil {
                 long contactId = cursor.getLong(contactIdIndex);
                 contactIds.add(String.valueOf(contactId));
                 numContacts++;
-                newTimestamp = Math.max(newTimestamp, cursor.getLong(timestampIndex));
+                if (Flags.enableCheckContactsIndexerDeltaTimestamps()) {
+                    long timestamp = cursor.getLong(timestampIndex);
+                    if (timestamp <= currentTimeMillis) {
+                        newTimestamp = Math.max(newTimestamp, timestamp);
+                    }
+                } else {
+                    newTimestamp = Math.max(newTimestamp, cursor.getLong(timestampIndex));
+                }
             }
 
             if (LogUtil.DEBUG) {
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchConfig.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchConfig.java
index 19a756cd..56fa6cf5 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/AppSearchConfig.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchConfig.java
@@ -18,6 +18,10 @@ package com.android.server.appsearch.external.localstorage;
 
 import android.app.appsearch.GenericDocument;
 
+import com.google.android.icing.proto.PersistType;
+
+import org.jspecify.annotations.NonNull;
+
 /** An interface that wraps AppSearch configurations required to create {@link AppSearchImpl}. */
 public interface AppSearchConfig extends IcingOptionsConfig, LimitConfig {
 
@@ -34,4 +38,10 @@ public interface AppSearchConfig extends IcingOptionsConfig, LimitConfig {
      * com.android.appsearch.flags.Flags#FLAG_ENABLE_SEARCH_RESULT_PARENT_TYPES} in on.
      */
     boolean shouldRetrieveParentInfo();
+
+    /**
+     * Returns the {@code PersistType.Code} that should be used to persist common mutations such as
+     * PUTs or DELETEs.
+     */
+    PersistType.@NonNull Code getLightweightPersistType();
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java
index ec113455..06822082 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java
@@ -17,6 +17,7 @@
 package com.android.server.appsearch.external.localstorage;
 
 import static android.app.appsearch.AppSearchResult.RESULT_SECURITY_ERROR;
+import static android.app.appsearch.AppSearchResult.throwableToFailedResult;
 import static android.app.appsearch.InternalSetSchemaResponse.newFailedSetSchemaResponse;
 import static android.app.appsearch.InternalSetSchemaResponse.newSuccessfulSetSchemaResponse;
 
@@ -27,9 +28,8 @@ import static com.android.server.appsearch.external.localstorage.util.PrefixUtil
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.getPrefix;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.removePrefixesFromDocument;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.annotation.WorkerThread;
+import android.app.appsearch.AppSearchBatchResult;
 import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
@@ -82,6 +82,8 @@ import com.android.server.appsearch.external.localstorage.visibilitystore.Visibi
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityUtil;
 
 import com.google.android.icing.IcingSearchEngine;
+import com.google.android.icing.IcingSearchEngineInterface;
+import com.google.android.icing.proto.BatchPutResultProto;
 import com.google.android.icing.proto.BlobProto;
 import com.google.android.icing.proto.DebugInfoProto;
 import com.google.android.icing.proto.DebugInfoResultProto;
@@ -105,6 +107,7 @@ import com.google.android.icing.proto.PersistToDiskResultProto;
 import com.google.android.icing.proto.PersistType;
 import com.google.android.icing.proto.PropertyConfigProto;
 import com.google.android.icing.proto.PropertyProto;
+import com.google.android.icing.proto.PutDocumentRequest;
 import com.google.android.icing.proto.PutResultProto;
 import com.google.android.icing.proto.ReportUsageResultProto;
 import com.google.android.icing.proto.ResetResultProto;
@@ -122,10 +125,18 @@ import com.google.android.icing.proto.SuggestionResponse;
 import com.google.android.icing.proto.TypePropertyMask;
 import com.google.android.icing.proto.UsageReport;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.io.Closeable;
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
+import java.security.DigestInputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -192,10 +203,13 @@ public final class AppSearchImpl implements Closeable {
     private final ReadWriteLock mReadWriteLock = new ReentrantReadWriteLock();
     private final OptimizeStrategy mOptimizeStrategy;
     private final AppSearchConfig mConfig;
+    private final File mBlobFilesDir;
 
     @GuardedBy("mReadWriteLock")
     @VisibleForTesting
-    final IcingSearchEngine mIcingSearchEngineLocked;
+    final IcingSearchEngineInterface mIcingSearchEngineLocked;
+
+    private final boolean mIsVMEnabled;
 
     @GuardedBy("mReadWriteLock")
     private final SchemaCache mSchemaCacheLocked = new SchemaCache();
@@ -230,19 +244,16 @@ public final class AppSearchImpl implements Closeable {
      * #setSchema} and {@link #getSchema} to get the visibility schema. Make it nullable to avoid
      * call it before we actually create it.
      */
-    @Nullable
     @VisibleForTesting
     @GuardedBy("mReadWriteLock")
-    final VisibilityStore mDocumentVisibilityStoreLocked;
+    final @Nullable VisibilityStore mDocumentVisibilityStoreLocked;
 
-    @Nullable
     @VisibleForTesting
     @GuardedBy("mReadWriteLock")
-    final VisibilityStore mBlobVisibilityStoreLocked;
+    final @Nullable VisibilityStore mBlobVisibilityStoreLocked;
 
-    @Nullable
     @GuardedBy("mReadWriteLock")
-    private final VisibilityChecker mVisibilityCheckerLocked;
+    private final @Nullable VisibilityChecker mVisibilityCheckerLocked;
 
     /**
      * The counter to check when to call {@link #checkForOptimize}. The interval is {@link
@@ -251,7 +262,7 @@ public final class AppSearchImpl implements Closeable {
     @GuardedBy("mReadWriteLock")
     private int mOptimizeIntervalCountLocked = 0;
 
-    @Nullable private final RevocableFileDescriptorStore mRevocableFileDescriptorStore;
+    private final @Nullable RevocableFileDescriptorStore mRevocableFileDescriptorStore;
 
     /** Whether this instance has been closed, and therefore unusable. */
     @GuardedBy("mReadWriteLock")
@@ -272,14 +283,16 @@ public final class AppSearchImpl implements Closeable {
      * @param visibilityChecker The {@link VisibilityChecker} that check whether the caller has
      *     access to aa specific schema. Pass null will lost that ability and global querier could
      *     only get their own data.
+     * @param icingSearchEngine the underlying icing instance to use. If not provided, a new {@link
+     *     IcingSearchEngine} instance will be created and used.
      */
-    @NonNull
-    public static AppSearchImpl create(
+    public static @NonNull AppSearchImpl create(
             @NonNull File icingDir,
             @NonNull AppSearchConfig config,
-            @Nullable InitializeStats.Builder initStatsBuilder,
+            InitializeStats.@Nullable Builder initStatsBuilder,
             @Nullable VisibilityChecker visibilityChecker,
             @Nullable RevocableFileDescriptorStore revocableFileDescriptorStore,
+            @Nullable IcingSearchEngineInterface icingSearchEngine,
             @NonNull OptimizeStrategy optimizeStrategy)
             throws AppSearchException {
         return new AppSearchImpl(
@@ -288,6 +301,7 @@ public final class AppSearchImpl implements Closeable {
                 initStatsBuilder,
                 visibilityChecker,
                 revocableFileDescriptorStore,
+                icingSearchEngine,
                 optimizeStrategy);
     }
 
@@ -297,12 +311,19 @@ public final class AppSearchImpl implements Closeable {
     private AppSearchImpl(
             @NonNull File icingDir,
             @NonNull AppSearchConfig config,
-            @Nullable InitializeStats.Builder initStatsBuilder,
+            InitializeStats.@Nullable Builder initStatsBuilder,
             @Nullable VisibilityChecker visibilityChecker,
             @Nullable RevocableFileDescriptorStore revocableFileDescriptorStore,
+            @Nullable IcingSearchEngineInterface icingSearchEngine,
             @NonNull OptimizeStrategy optimizeStrategy)
             throws AppSearchException {
         Objects.requireNonNull(icingDir);
+        // This directory stores blob files. It is the same directory that Icing used to manage
+        // blob files when Flags.enableAppSearchManageBlobFiles() was false. After the rollout of
+        // this flag, AppSearch will continue to manage blob files in this same directory within
+        // Icing's directory. The location remains unchanged to ensure that the flag does not
+        // introduce any behavioral changes.
+        mBlobFilesDir = new File(icingDir, "blob_dir/blob_files");
         mConfig = Objects.requireNonNull(config);
         mOptimizeStrategy = Objects.requireNonNull(optimizeStrategy);
         mVisibilityCheckerLocked = visibilityChecker;
@@ -312,42 +333,20 @@ public final class AppSearchImpl implements Closeable {
         try {
             // We synchronize here because we don't want to call IcingSearchEngine.initialize() more
             // than once. It's unnecessary and can be a costly operation.
-            IcingSearchEngineOptions options =
-                    IcingSearchEngineOptions.newBuilder()
-                            .setBaseDir(icingDir.getAbsolutePath())
-                            .setMaxTokenLength(mConfig.getMaxTokenLength())
-                            .setIndexMergeSize(mConfig.getIndexMergeSize())
-                            .setDocumentStoreNamespaceIdFingerprint(
-                                    mConfig.getDocumentStoreNamespaceIdFingerprint())
-                            .setOptimizeRebuildIndexThreshold(
-                                    mConfig.getOptimizeRebuildIndexThreshold())
-                            .setCompressionLevel(mConfig.getCompressionLevel())
-                            .setAllowCircularSchemaDefinitions(
-                                    mConfig.getAllowCircularSchemaDefinitions())
-                            .setPreMappingFbv(mConfig.getUsePreMappingWithFileBackedVector())
-                            .setUsePersistentHashMap(mConfig.getUsePersistentHashMap())
-                            .setIntegerIndexBucketSplitThreshold(
-                                    mConfig.getIntegerIndexBucketSplitThreshold())
-                            .setLiteIndexSortAtIndexing(mConfig.getLiteIndexSortAtIndexing())
-                            .setLiteIndexSortSize(mConfig.getLiteIndexSortSize())
-                            .setUseNewQualifiedIdJoinIndex(mConfig.getUseNewQualifiedIdJoinIndex())
-                            .setBuildPropertyExistenceMetadataHits(
-                                    mConfig.getBuildPropertyExistenceMetadataHits())
-                            .setEnableBlobStore(Flags.enableBlobStore())
-                            .setOrphanBlobTimeToLiveMs(mConfig.getOrphanBlobTimeToLiveMs())
-                            .setEnableEmbeddingIndex(Flags.enableSchemaEmbeddingPropertyConfig())
-                            .setEnableEmbeddingQuantization(
-                                    Flags.enableSchemaEmbeddingQuantization())
-                            .setEnableScorableProperties(Flags.enableScorableProperty())
-                            .setEnableQualifiedIdJoinIndexV3AndDeletePropagateFrom(
-                                    Flags.enableDeletePropagationType())
-                            .build();
-            LogUtil.piiTrace(TAG, "Constructing IcingSearchEngine, request", options);
-            mIcingSearchEngineLocked = new IcingSearchEngine(options);
-            LogUtil.piiTrace(
-                    TAG,
-                    "Constructing IcingSearchEngine, response",
-                    Objects.hashCode(mIcingSearchEngineLocked));
+            if (icingSearchEngine == null) {
+                IcingSearchEngineOptions options =
+                        mConfig.toIcingSearchEngineOptions(icingDir.getAbsolutePath());
+                LogUtil.piiTrace(TAG, "Constructing IcingSearchEngine, request", options);
+                mIcingSearchEngineLocked = new IcingSearchEngine(options);
+                LogUtil.piiTrace(
+                        TAG,
+                        "Constructing IcingSearchEngine, response",
+                        Objects.hashCode(mIcingSearchEngineLocked));
+                mIsVMEnabled = false;
+            } else {
+                mIcingSearchEngineLocked = icingSearchEngine;
+                mIsVMEnabled = true;
+            }
 
             // The core initialization procedure. If any part of this fails, we bail into
             // resetLocked(), deleting all data (but hopefully allowing AppSearchImpl to come up).
@@ -365,12 +364,22 @@ public final class AppSearchImpl implements Closeable {
                             .setStatusCode(
                                     statusProtoToResultCode(initializeResultProto.getStatus()))
                             // TODO(b/173532925) how to get DeSyncs value
-                            .setHasDeSync(false);
+                            .setHasDeSync(false)
+                            .setLaunchVMEnabled(mIsVMEnabled);
                     AppSearchLoggerHelper.copyNativeStats(
                             initializeResultProto.getInitializeStats(), initStatsBuilder);
                 }
                 checkSuccess(initializeResultProto.getStatus());
 
+                if (Flags.enableAppSearchManageBlobFiles()
+                        && !mBlobFilesDir.exists()
+                        && !mBlobFilesDir.mkdirs()) {
+                    throw new AppSearchException(
+                            AppSearchResult.RESULT_IO_ERROR,
+                            "Cannot create the blob file directory: "
+                                    + mBlobFilesDir.getAbsolutePath());
+                }
+
                 // Read all protos we need to construct AppSearchImpl's cache maps
                 long prepareSchemaAndNamespacesLatencyStartMillis = SystemClock.elapsedRealtime();
                 SchemaProto schemaProto = getSchemaProtoLocked();
@@ -519,6 +528,16 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
+    /** Returns the instance of AppSearchConfig used by this instance of AppSearchImpl. */
+    public @NonNull AppSearchConfig getConfig() {
+        return mConfig;
+    }
+
+    /** Returns whether pVM is enabled in this AppSearchImpl instance. */
+    public boolean isVMEnabled() {
+        return mIsVMEnabled;
+    }
+
     /**
      * Updates the AppSearch schema for this app.
      *
@@ -544,25 +563,26 @@ public final class AppSearchImpl implements Closeable {
      *     FAILED_PRECONDITION for the incompatible change, the exception will be converted to the
      *     SetSchemaResponse.
      */
-    @NonNull
-    public InternalSetSchemaResponse setSchema(
+    public @NonNull InternalSetSchemaResponse setSchema(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull List<AppSearchSchema> schemas,
             @NonNull List<InternalVisibilityConfig> visibilityConfigs,
             boolean forceOverride,
             int version,
-            @Nullable SetSchemaStats.Builder setSchemaStatsBuilder)
+            SetSchemaStats.@Nullable Builder setSchemaStatsBuilder)
             throws AppSearchException {
         long javaLockAcquisitionLatencyStartMillis = SystemClock.elapsedRealtime();
         mReadWriteLock.writeLock().lock();
         try {
             throwIfClosedLocked();
             if (setSchemaStatsBuilder != null) {
-                setSchemaStatsBuilder.setJavaLockAcquisitionLatencyMillis(
-                        (int)
-                                (SystemClock.elapsedRealtime()
-                                        - javaLockAcquisitionLatencyStartMillis));
+                setSchemaStatsBuilder
+                        .setJavaLockAcquisitionLatencyMillis(
+                                (int)
+                                        (SystemClock.elapsedRealtime()
+                                                - javaLockAcquisitionLatencyStartMillis))
+                        .setLaunchVMEnabled(mIsVMEnabled);
             }
             if (mObserverManager.isPackageObserved(packageName)) {
                 return doSetSchemaWithChangeNotificationLocked(
@@ -595,15 +615,14 @@ public final class AppSearchImpl implements Closeable {
      * @see #doSetSchemaNoChangeNotificationLocked
      */
     @GuardedBy("mReadWriteLock")
-    @NonNull
-    private InternalSetSchemaResponse doSetSchemaWithChangeNotificationLocked(
+    private @NonNull InternalSetSchemaResponse doSetSchemaWithChangeNotificationLocked(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull List<AppSearchSchema> schemas,
             @NonNull List<InternalVisibilityConfig> visibilityConfigs,
             boolean forceOverride,
             int version,
-            @Nullable SetSchemaStats.Builder setSchemaStatsBuilder)
+            SetSchemaStats.@Nullable Builder setSchemaStatsBuilder)
             throws AppSearchException {
         // First, capture the old state of the system. This includes the old schema as well as
         // whether each registered observer can access each type. Once VisibilityStore is updated
@@ -780,15 +799,14 @@ public final class AppSearchImpl implements Closeable {
      * @see #doSetSchemaWithChangeNotificationLocked
      */
     @GuardedBy("mReadWriteLock")
-    @NonNull
-    private InternalSetSchemaResponse doSetSchemaNoChangeNotificationLocked(
+    private @NonNull InternalSetSchemaResponse doSetSchemaNoChangeNotificationLocked(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull List<AppSearchSchema> schemas,
             @NonNull List<InternalVisibilityConfig> visibilityConfigs,
             boolean forceOverride,
             int version,
-            @Nullable SetSchemaStats.Builder setSchemaStatsBuilder)
+            SetSchemaStats.@Nullable Builder setSchemaStatsBuilder)
             throws AppSearchException {
         long setRewriteSchemaLatencyStartTimeMillis = SystemClock.elapsedRealtime();
         SchemaProto.Builder existingSchemaBuilder = getSchemaProtoLocked().toBuilder();
@@ -919,8 +937,7 @@ public final class AppSearchImpl implements Closeable {
      * @param callerAccess Visibility access info of the calling app
      * @throws AppSearchException on IcingSearchEngine error.
      */
-    @NonNull
-    public GetSchemaResponse getSchema(
+    public @NonNull GetSchemaResponse getSchema(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull CallerAccess callerAccess)
@@ -1024,9 +1041,8 @@ public final class AppSearchImpl implements Closeable {
      * @param databaseName The name of the database where this schema lives.
      * @throws AppSearchException on IcingSearchEngine error.
      */
-    @NonNull
-    public List<String> getNamespaces(@NonNull String packageName, @NonNull String databaseName)
-            throws AppSearchException {
+    public @NonNull List<String> getNamespaces(
+            @NonNull String packageName, @NonNull String databaseName) throws AppSearchException {
         mReadWriteLock.readLock().lock();
         try {
             throwIfClosedLocked();
@@ -1056,6 +1072,244 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
+    /**
+     * Adds a list of documents to the AppSearch index.
+     *
+     * <p>This method belongs to mutate group.
+     *
+     * @param packageName The package name that owns this document.
+     * @param databaseName The databaseName this document resides in.
+     * @param documents A list of documents to index.
+     * @param batchResultBuilder The builder for returning the batch result.
+     * @param sendChangeNotifications Whether to dispatch {@link
+     *     android.app.appsearch.observer.DocumentChangeInfo} messages to observers for this change.
+     * @param persistType The persist type used to call PersistToDisk inside Icing at the end of the
+     *     Put request. If UNKNOWN, PersistToDisk will not be called. See also {@link
+     *     #persistToDisk(PersistType.Code)}.
+     * @throws AppSearchException on IcingSearchEngine error.
+     */
+    public void batchPutDocuments(
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull List<GenericDocument> documents,
+            AppSearchBatchResult.@Nullable Builder<String, Void> batchResultBuilder,
+            boolean sendChangeNotifications,
+            @Nullable AppSearchLogger logger,
+            PersistType.@NonNull Code persistType)
+            throws AppSearchException {
+        // All the stats we want to print. This may not be necessary,
+        // but just to keep the behavior same as before.
+        // Use list instead of map as same id can appear more than once.
+        List<PutDocumentStats.Builder> allStatsList = new ArrayList<>();
+        List<PutDocumentStats.Builder> statsNotFilteredOut = new ArrayList<>();
+        long totalStartTimeMillis = SystemClock.elapsedRealtime();
+
+        mReadWriteLock.writeLock().lock();
+        try {
+            throwIfClosedLocked();
+
+            String prefix = createPrefix(packageName, databaseName);
+            List<PutDocumentRequest.Builder> requestBuilderList = new ArrayList<>();
+            // This is to make sure the batching size is at least getMaxDocumentSizeBytes.
+            // Otherwise one valid size doc may not fit into a batch.
+            int maxBufferedBytes =
+                    Integer.max(
+                            mConfig.getMaxByteLimitForBatchPut(),
+                            mConfig.getMaxDocumentSizeBytes());
+            int currentTotalBytes = 0;
+            PutDocumentRequest.Builder currentBatchBuilder =
+                    PutDocumentRequest.newBuilder().setPersistType(PersistType.Code.UNKNOWN);
+            for (int i = 0; i < documents.size(); ++i) {
+                String docId = documents.get(i).getId();
+                PutDocumentStats.Builder pStatsBuilder =
+                        new PutDocumentStats.Builder(packageName, databaseName)
+                                .setLaunchVMEnabled(mIsVMEnabled);
+                // Previously we always log even if we reach the limit. To keep the behavior
+                // same as before, we will save all the stats created.
+                allStatsList.add(pStatsBuilder);
+
+                long generateDocumentProtoStartTimeMillis = 0;
+                long generateDocumentProtoEndTimeMillis = 0;
+                long rewriteDocumentTypeStartTimeMillis = 0;
+                long rewriteDocumentTypeEndTimeMillis = 0;
+                try {
+                    // Generate Document Proto
+                    generateDocumentProtoStartTimeMillis = SystemClock.elapsedRealtime();
+                    DocumentProto.Builder documentBuilder =
+                            GenericDocumentToProtoConverter.toDocumentProto(documents.get(i))
+                                    .toBuilder();
+                    generateDocumentProtoEndTimeMillis = SystemClock.elapsedRealtime();
+
+                    // Rewrite Document Type
+                    rewriteDocumentTypeStartTimeMillis = SystemClock.elapsedRealtime();
+                    addPrefixToDocument(documentBuilder, prefix);
+                    rewriteDocumentTypeEndTimeMillis = SystemClock.elapsedRealtime();
+                    DocumentProto finalDocument = documentBuilder.build();
+
+                    // Check limits
+                    int serializedSizeBytes = finalDocument.getSerializedSize();
+                    enforceLimitConfigLocked(packageName, docId, serializedSizeBytes);
+
+                    // to see if we want to finish the current batch and build a PutRequestProto.
+                    // based on how we calculate maxBufferedBytes, serializedSizeBytes is guaranteed
+                    // to be smaller or same as maxBufferedBytes.
+                    if (serializedSizeBytes > maxBufferedBytes - currentTotalBytes) {
+                        // Time to finish the current batch.
+                        requestBuilderList.add(currentBatchBuilder);
+
+                        // reset everything for next batch
+                        currentBatchBuilder =
+                                PutDocumentRequest.newBuilder()
+                                        .setPersistType(PersistType.Code.UNKNOWN);
+                        currentTotalBytes = 0;
+                    }
+
+                    currentTotalBytes += serializedSizeBytes;
+                    currentBatchBuilder.addDocuments(finalDocument);
+                    statsNotFilteredOut.add(pStatsBuilder);
+
+                } catch (Throwable t) {
+                    if (batchResultBuilder != null) {
+                        batchResultBuilder.setResult(docId, throwableToFailedResult(t));
+                    }
+                } finally {
+                    //
+                    // At this point, the doc has either been put in the requestProto, or error
+                    // result be put in batchResultBuilder.
+                    //
+
+                    pStatsBuilder
+                            .setGenerateDocumentProtoLatencyMillis(
+                                    (int)
+                                            (generateDocumentProtoEndTimeMillis
+                                                    - generateDocumentProtoStartTimeMillis))
+                            .setRewriteDocumentTypesLatencyMillis(
+                                    (int)
+                                            (rewriteDocumentTypeEndTimeMillis
+                                                    - rewriteDocumentTypeStartTimeMillis));
+                }
+            }
+
+            // We have to "flush" the last batch. Since this is the last batch, we set the
+            // persistType passed in here.
+            requestBuilderList.add(currentBatchBuilder.setPersistType(persistType));
+
+            // Put documents
+            int statsIndex = 0;
+            for (int requestIndex = 0; requestIndex < requestBuilderList.size(); ++requestIndex) {
+                PutDocumentRequest requestProto = requestBuilderList.get(requestIndex).build();
+                LogUtil.piiTrace(
+                        TAG,
+                        "batchPutDocument, request",
+                        requestProto.getDocumentsCount(),
+                        requestProto);
+                BatchPutResultProto batchPutResultProto =
+                        mIcingSearchEngineLocked.batchPut(requestProto);
+                // TODO(b/394875109) We can provide a better debug information for fast trace here.
+                LogUtil.piiTrace(
+                        TAG, "batchPutDocument", /* fastTraceObj= */ null, batchPutResultProto);
+
+                List<PutResultProto> putResultProtoList =
+                        batchPutResultProto.getPutResultProtosList();
+                for (int i = 0; i < putResultProtoList.size(); ++i, ++statsIndex) {
+                    PutResultProto putResultProto = putResultProtoList.get(i);
+                    String docId = putResultProto.getUri();
+                    try {
+                        if (statsIndex <= statsNotFilteredOut.size()) {
+                            PutDocumentStats.Builder pStatsBuilder =
+                                    statsNotFilteredOut.get(statsIndex);
+                            pStatsBuilder.setStatusCode(
+                                    statusProtoToResultCode(putResultProto.getStatus()));
+                            AppSearchLoggerHelper.copyNativeStats(
+                                    putResultProto.getPutDocumentStats(), pStatsBuilder);
+                        } else {
+                            // since it is just stats, we just log the debug message if
+                            // something goes wrong.
+                            LogUtil.piiTrace(
+                                    TAG,
+                                    "batchPutDocument",
+                                    "index out of boundary for stats",
+                                    statsNotFilteredOut);
+                        }
+
+                        // If it is a failure, it will throw and the catch section will
+                        // set generated result
+                        checkSuccess(putResultProto.getStatus());
+                        if (batchResultBuilder != null) {
+                            batchResultBuilder.setSuccess(docId, /* value= */ null);
+                        }
+
+                        // Don't need to check the index here, as request doc list size should
+                        // definitely be bigger than response doc list size.
+                        DocumentProto documentProto = requestProto.getDocuments(i);
+                        if (!docId.equals(documentProto.getUri())) {
+                            // This shouldn't happen if native code implemented correctly.
+                            // Have a check here just in case something unexpected happens.
+                            Log.w(TAG, "id mismatch between request and response for batchPut");
+                            continue;
+                        }
+
+                        // Only update caches if the document is successfully put to Icing.
+                        // Prefixed namespace needed here.
+                        mNamespaceCacheLocked.addToDocumentNamespaceMap(
+                                prefix, documentProto.getNamespace());
+                        if (!Flags.enableDocumentLimiterReplaceTracking()
+                                || !putResultProto.getWasReplacement()) {
+                            // If the document was a replacement, then there is no need to report it
+                            // because the number of documents has not changed. We only need to
+                            // report "true" additions to the DocumentLimiter.
+                            // Although a replacement document will consume a document id,
+                            // the limit is only intended to apply to "living" documents.
+                            // It is the responsibility of AppSearch's optimization task to reclaim
+                            // space when needed.
+                            mDocumentLimiterLocked.reportDocumentAdded(
+                                    packageName,
+                                    () ->
+                                            getRawStorageInfoProto()
+                                                    .getDocumentStorageInfo()
+                                                    .getNamespaceStorageInfoList());
+                        }
+                        // Prepare notifications
+                        if (sendChangeNotifications) {
+                            mObserverManager.onDocumentChange(
+                                    packageName,
+                                    databaseName,
+                                    PrefixUtil.removePrefix(documentProto.getNamespace()),
+                                    PrefixUtil.removePrefix(documentProto.getSchema()),
+                                    documentProto.getUri(),
+                                    mDocumentVisibilityStoreLocked,
+                                    mVisibilityCheckerLocked);
+                        }
+                    } catch (Throwable t) {
+                        if (batchResultBuilder != null) {
+                            batchResultBuilder.setResult(docId, throwableToFailedResult(t));
+                        }
+                    }
+                }
+                // As we only set "not unknown" persistType for the last request,
+                // this should ONLY be checked for last request.
+                if (requestProto.getPersistType() != PersistType.Code.UNKNOWN) {
+                    checkSuccess(batchPutResultProto.getPersistToDiskResultProto().getStatus());
+                }
+            }
+        } finally {
+            mReadWriteLock.writeLock().unlock();
+
+            if (logger != null && !allStatsList.isEmpty()) {
+                // This seems broken and no easy way to get accurate number.
+                int avgTotalLatencyMs =
+                        (int)
+                                ((SystemClock.elapsedRealtime() - totalStartTimeMillis)
+                                        / allStatsList.size());
+                for (int i = 0; i < allStatsList.size(); ++i) {
+                    PutDocumentStats.Builder pStatsBuilder = allStatsList.get(i);
+                    pStatsBuilder.setTotalLatencyMillis(avgTotalLatencyMs);
+                    logger.logStats(pStatsBuilder.build());
+                }
+            }
+        }
+    }
+
     /**
      * Adds a document to the AppSearch index.
      *
@@ -1067,7 +1321,11 @@ public final class AppSearchImpl implements Closeable {
      * @param sendChangeNotifications Whether to dispatch {@link
      *     android.app.appsearch.observer.DocumentChangeInfo} messages to observers for this change.
      * @throws AppSearchException on IcingSearchEngine error.
+     * @deprecated use {@link #batchPutDocuments(String, String, List, AppSearchBatchResult.Builder,
+     *     boolean, AppSearchLogger)}
      */
+    // TODO(b/394875109) keep this for now to make code sync easier.
+    @Deprecated
     public void putDocument(
             @NonNull String packageName,
             @NonNull String databaseName,
@@ -1077,7 +1335,9 @@ public final class AppSearchImpl implements Closeable {
             throws AppSearchException {
         PutDocumentStats.Builder pStatsBuilder = null;
         if (logger != null) {
-            pStatsBuilder = new PutDocumentStats.Builder(packageName, databaseName);
+            pStatsBuilder =
+                    new PutDocumentStats.Builder(packageName, databaseName)
+                            .setLaunchVMEnabled(mIsVMEnabled);
         }
         long totalStartTimeMillis = SystemClock.elapsedRealtime();
 
@@ -1172,12 +1432,15 @@ public final class AppSearchImpl implements Closeable {
      * Gets the {@link ParcelFileDescriptor} for write purpose of the given {@link
      * AppSearchBlobHandle}.
      *
+     * <p>Only one opened {@link ParcelFileDescriptor} is allowed for each {@link
+     * AppSearchBlobHandle}. The same {@link ParcelFileDescriptor} will be returned if it is not
+     * closed by caller.
+     *
      * @param packageName The package name that owns this blob.
      * @param databaseName The databaseName this blob resides in.
      * @param handle The {@link AppSearchBlobHandle} represent the blob.
      */
-    @NonNull
-    public ParcelFileDescriptor openWriteBlob(
+    public @NonNull ParcelFileDescriptor openWriteBlob(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull AppSearchBlobHandle handle)
@@ -1190,19 +1453,28 @@ public final class AppSearchImpl implements Closeable {
         try {
             throwIfClosedLocked();
             verifyCallingBlobHandle(packageName, databaseName, handle);
+            ParcelFileDescriptor pfd =
+                    mRevocableFileDescriptorStore.getOpenedRevocableFileDescriptorForWrite(
+                            packageName, handle);
+            if (pfd != null) {
+                // There is already an opened pfd for write with same blob handle, just return the
+                // already opened one.
+                return pfd;
+            }
             mRevocableFileDescriptorStore.checkBlobStoreLimit(packageName);
             PropertyProto.BlobHandleProto blobHandleProto =
                     BlobHandleToProtoConverter.toBlobHandleProto(handle);
             BlobProto result = mIcingSearchEngineLocked.openWriteBlob(blobHandleProto);
-
-            checkSuccess(result.getStatus());
-            ParcelFileDescriptor pfd = ParcelFileDescriptor.adoptFd(result.getFileDescriptor());
-
+            pfd =
+                    retrieveFileDescriptorLocked(
+                            result,
+                            ParcelFileDescriptor.MODE_CREATE
+                                    | ParcelFileDescriptor.MODE_READ_WRITE);
             mNamespaceCacheLocked.addToBlobNamespaceMap(
                     createPrefix(packageName, databaseName), blobHandleProto.getNamespace());
 
             return mRevocableFileDescriptorStore.wrapToRevocableFileDescriptor(
-                    handle.getPackageName(), pfd);
+                    packageName, handle, pfd, ParcelFileDescriptor.MODE_READ_WRITE);
         } finally {
             mReadWriteLock.writeLock().unlock();
         }
@@ -1237,11 +1509,97 @@ public final class AppSearchImpl implements Closeable {
                             BlobHandleToProtoConverter.toBlobHandleProto(handle));
 
             checkSuccess(result.getStatus());
+            if (Flags.enableAppSearchManageBlobFiles()) {
+                File blobFileToRemove = new File(mBlobFilesDir, result.getFileName());
+                if (!blobFileToRemove.delete()) {
+                    throw new AppSearchException(
+                            AppSearchResult.RESULT_IO_ERROR,
+                            "Cannot delete the blob file: " + blobFileToRemove.getName());
+                }
+            }
+            mRevocableFileDescriptorStore.revokeFdForWrite(packageName, handle);
         } finally {
             mReadWriteLock.writeLock().unlock();
         }
     }
 
+    /**
+     * Verifies the integrity of a blob file by comparing its SHA-256 digest with the expected
+     * digest.
+     *
+     * <p>This method is used when AppSearch manages blob files directly. It opens the blob file
+     * associated with the given {@link AppSearchBlobHandle}, calculates its SHA-256 digest, and
+     * compares it with the digest provided in the handle. If the file does not exist or the
+     * calculated digest does not match the expected digest, the blob is considered invalid and is
+     * removed.
+     *
+     * @param handle The {@link AppSearchBlobHandle} representing the blob to verify.
+     * @throws AppSearchException if the blob file does not exist, the calculated digest does not
+     *     match the expected digest, or if there is an error removing the invalid blob.
+     * @throws IOException if there is an error opening or reading the blob file.
+     */
+    @GuardedBy("mReadWriteLock")
+    private void verifyBlobIntegrityLocked(@NonNull AppSearchBlobHandle handle)
+            throws AppSearchException, IOException {
+        // Since the blob has not yet been committed, we open the blob for *write* again to
+        // get the file name.
+        BlobProto result =
+                mIcingSearchEngineLocked.openWriteBlob(
+                        BlobHandleToProtoConverter.toBlobHandleProto(handle));
+        checkSuccess(result.getStatus());
+        File blobFile = new File(mBlobFilesDir, result.getFileName());
+        boolean fileExists = blobFile.exists();
+        boolean digestMatches = false;
+
+        if (fileExists) {
+            // Read the file to check the digest.
+            byte[] digest;
+            ParcelFileDescriptor pfd =
+                    ParcelFileDescriptor.open(blobFile, ParcelFileDescriptor.MODE_READ_ONLY);
+            try (InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(pfd);
+                    DigestInputStream digestInputStream =
+                            new DigestInputStream(
+                                    inputStream, MessageDigest.getInstance("SHA-256"))) {
+                byte[] buffer = new byte[8192];
+                while (digestInputStream.read(buffer) != -1) {
+                    // pass
+                }
+                digest = digestInputStream.getMessageDigest().digest();
+            } catch (NoSuchAlgorithmException e) {
+                throw new AppSearchException(
+                        AppSearchResult.RESULT_INTERNAL_ERROR,
+                        "Failed to get MessageDigest for SHA-256.",
+                        e);
+            }
+            digestMatches = Arrays.equals(digest, handle.getSha256Digest());
+        }
+
+        // If the file does not exist or the digest is wrong, delete the blob and throw
+        // an exception.
+        if (!fileExists || !digestMatches) {
+            BlobProto removeResult =
+                    mIcingSearchEngineLocked.removeBlob(
+                            BlobHandleToProtoConverter.toBlobHandleProto(handle));
+            checkSuccess(removeResult.getStatus());
+
+            if (!fileExists) {
+                throw new AppSearchException(
+                        AppSearchResult.RESULT_NOT_FOUND,
+                        "Cannot find the blob for handle: " + handle);
+            } else {
+                File blobFileToRemove = new File(mBlobFilesDir, removeResult.getFileName());
+                if (!blobFileToRemove.delete()) {
+                    throw new AppSearchException(
+                            AppSearchResult.RESULT_IO_ERROR,
+                            "Cannot delete the blob file: " + blobFileToRemove.getName());
+                }
+                throw new AppSearchException(
+                        AppSearchResult.RESULT_INVALID_ARGUMENT,
+                        "The blob content doesn't match to the digest.");
+            }
+        }
+    }
+
     /**
      * Commits and seals the blob represented by the given {@link AppSearchBlobHandle}.
      *
@@ -1256,7 +1614,7 @@ public final class AppSearchImpl implements Closeable {
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull AppSearchBlobHandle handle)
-            throws AppSearchException {
+            throws AppSearchException, IOException {
         if (mRevocableFileDescriptorStore == null) {
             throw new UnsupportedOperationException(
                     "BLOB_STORAGE is not available on this AppSearch implementation.");
@@ -1265,11 +1623,20 @@ public final class AppSearchImpl implements Closeable {
         try {
             throwIfClosedLocked();
             verifyCallingBlobHandle(packageName, databaseName, handle);
+
+            // If AppSearch manages blob files, it is responsible for verifying the digest of the
+            // blob file.
+            if (Flags.enableAppSearchManageBlobFiles()) {
+                verifyBlobIntegrityLocked(handle);
+            }
+
             BlobProto result =
                     mIcingSearchEngineLocked.commitBlob(
                             BlobHandleToProtoConverter.toBlobHandleProto(handle));
 
             checkSuccess(result.getStatus());
+            // The blob is committed and sealed, revoke the sent pfd for writing.
+            mRevocableFileDescriptorStore.revokeFdForWrite(packageName, handle);
         } finally {
             mReadWriteLock.writeLock().unlock();
         }
@@ -1285,8 +1652,7 @@ public final class AppSearchImpl implements Closeable {
      * @param databaseName The databaseName this blob resides in.
      * @param handle The {@link AppSearchBlobHandle} represent the blob.
      */
-    @NonNull
-    public ParcelFileDescriptor openReadBlob(
+    public @NonNull ParcelFileDescriptor openReadBlob(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull AppSearchBlobHandle handle)
@@ -1304,11 +1670,13 @@ public final class AppSearchImpl implements Closeable {
             BlobProto result =
                     mIcingSearchEngineLocked.openReadBlob(
                             BlobHandleToProtoConverter.toBlobHandleProto(handle));
+            ParcelFileDescriptor pfd =
+                    retrieveFileDescriptorLocked(result, ParcelFileDescriptor.MODE_READ_ONLY);
 
-            checkSuccess(result.getStatus());
-
-            ParcelFileDescriptor pfd = ParcelFileDescriptor.fromFd(result.getFileDescriptor());
-            return mRevocableFileDescriptorStore.wrapToRevocableFileDescriptor(packageName, pfd);
+            // We do NOT need to look up the revocable file descriptor for read, skip passing the
+            // blob handle key.
+            return mRevocableFileDescriptorStore.wrapToRevocableFileDescriptor(
+                    packageName, /* blobHandle= */ null, pfd, ParcelFileDescriptor.MODE_READ_ONLY);
         } finally {
             mReadWriteLock.readLock().unlock();
         }
@@ -1322,8 +1690,7 @@ public final class AppSearchImpl implements Closeable {
      *
      * @param handle The {@link AppSearchBlobHandle} represent the blob.
      */
-    @NonNull
-    public ParcelFileDescriptor globalOpenReadBlob(
+    public @NonNull ParcelFileDescriptor globalOpenReadBlob(
             @NonNull AppSearchBlobHandle handle, @NonNull CallerAccess access)
             throws AppSearchException, IOException {
         if (mRevocableFileDescriptorStore == null) {
@@ -1355,12 +1722,16 @@ public final class AppSearchImpl implements Closeable {
             }
 
             BlobProto result = mIcingSearchEngineLocked.openReadBlob(blobHandleProto);
+            ParcelFileDescriptor pfd =
+                    retrieveFileDescriptorLocked(result, ParcelFileDescriptor.MODE_READ_ONLY);
 
-            checkSuccess(result.getStatus());
-
-            ParcelFileDescriptor pfd = ParcelFileDescriptor.fromFd(result.getFileDescriptor());
+            // We do NOT need to look up the revocable file descriptor for read, skip passing the
+            // blob handle key.
             return mRevocableFileDescriptorStore.wrapToRevocableFileDescriptor(
-                    access.getCallingPackageName(), pfd);
+                    access.getCallingPackageName(),
+                    /* blobHandle= */ null,
+                    pfd,
+                    ParcelFileDescriptor.MODE_READ_ONLY);
         } finally {
             mReadWriteLock.readLock().unlock();
         }
@@ -1423,6 +1794,31 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
+    /**
+     * Retrieves the {@link ParcelFileDescriptor} from a {@link BlobProto}.
+     *
+     * <p>This method handles retrieving the actual file descriptor from the provided {@link
+     * BlobProto}, taking into account whether AppSearch manages blob files directly. If AppSearch
+     * manages blob files ({@code Flags.enableAppSearchManageBlobFiles()} is true), it opens the
+     * file using the file name from the {@link BlobProto}. Otherwise, it retrieves the file
+     * descriptor directly from the {@link BlobProto}.
+     *
+     * @return The {@link ParcelFileDescriptor} for the blob.
+     * @throws AppSearchException if the {@link BlobProto}'s status indicates an error.
+     * @throws IOException if there is an error opening the file, such as the file not being found.
+     */
+    @GuardedBy("mReadWriteLock")
+    private ParcelFileDescriptor retrieveFileDescriptorLocked(BlobProto blobProto, int mode)
+            throws AppSearchException, IOException {
+        checkSuccess(blobProto.getStatus());
+        if (Flags.enableAppSearchManageBlobFiles()) {
+            File blobFile = new File(mBlobFilesDir, blobProto.getFileName());
+            return ParcelFileDescriptor.open(blobFile, mode);
+        } else {
+            return ParcelFileDescriptor.adoptFd(blobProto.getFileDescriptor());
+        }
+    }
+
     /**
      * Checks that a new document can be added to the given packageName with the given serialized
      * size without violating our {@link LimitConfig}.
@@ -1476,8 +1872,7 @@ public final class AppSearchImpl implements Closeable {
      * @return The Document contents
      * @throws AppSearchException on IcingSearchEngine error or invalid permissions
      */
-    @NonNull
-    public GenericDocument globalGetDocument(
+    public @NonNull GenericDocument globalGetDocument(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull String namespace,
@@ -1536,8 +1931,7 @@ public final class AppSearchImpl implements Closeable {
      * @return The Document contents
      * @throws AppSearchException on IcingSearchEngine error.
      */
-    @NonNull
-    public GenericDocument getDocument(
+    public @NonNull GenericDocument getDocument(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull String namespace,
@@ -1576,11 +1970,10 @@ public final class AppSearchImpl implements Closeable {
      * @return the DocumentProto object
      * @throws AppSearchException on IcingSearchEngine error
      */
-    @NonNull
     @GuardedBy("mReadWriteLock")
     // We only log getResultProto.toString() in fullPii trace for debugging.
     @SuppressWarnings("LiteProtoToString")
-    private DocumentProto getDocumentProtoByIdLocked(
+    private @NonNull DocumentProto getDocumentProtoByIdLocked(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull String namespace,
@@ -1633,8 +2026,7 @@ public final class AppSearchImpl implements Closeable {
      *     documents matched the query.
      * @throws AppSearchException on IcingSearchEngine error.
      */
-    @NonNull
-    public SearchResultPage query(
+    public @NonNull SearchResultPage query(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull String queryExpression,
@@ -1647,7 +2039,8 @@ public final class AppSearchImpl implements Closeable {
             sStatsBuilder =
                     new SearchStats.Builder(SearchStats.VISIBILITY_SCOPE_LOCAL, packageName)
                             .setDatabase(databaseName)
-                            .setSearchSourceLogTag(searchSpec.getSearchSourceLogTag());
+                            .setSearchSourceLogTag(searchSpec.getSearchSourceLogTag())
+                            .setLaunchVMEnabled(mIsVMEnabled);
         }
 
         long javaLockAcquisitionLatencyStartMillis = SystemClock.elapsedRealtime();
@@ -1714,8 +2107,7 @@ public final class AppSearchImpl implements Closeable {
      *     documents matched the query.
      * @throws AppSearchException on IcingSearchEngine error.
      */
-    @NonNull
-    public SearchResultPage globalQuery(
+    public @NonNull SearchResultPage globalQuery(
             @NonNull String queryExpression,
             @NonNull SearchSpec searchSpec,
             @NonNull CallerAccess callerAccess,
@@ -1728,7 +2120,8 @@ public final class AppSearchImpl implements Closeable {
                     new SearchStats.Builder(
                                     SearchStats.VISIBILITY_SCOPE_GLOBAL,
                                     callerAccess.getCallingPackageName())
-                            .setSearchSourceLogTag(searchSpec.getSearchSourceLogTag());
+                            .setSearchSourceLogTag(searchSpec.getSearchSourceLogTag())
+                            .setLaunchVMEnabled(mIsVMEnabled);
         }
 
         long javaLockAcquisitionLatencyStartMillis = SystemClock.elapsedRealtime();
@@ -1816,7 +2209,7 @@ public final class AppSearchImpl implements Closeable {
     @GuardedBy("mReadWriteLock")
     private SearchResultPage doQueryLocked(
             @NonNull SearchSpecToProtoConverter searchSpecToProtoConverter,
-            @Nullable SearchStats.Builder sStatsBuilder)
+            SearchStats.@Nullable Builder sStatsBuilder)
             throws AppSearchException {
         // Rewrite the given SearchSpec into SearchSpecProto, ResultSpecProto and ScoringSpecProto.
         // All processes are counted in rewriteSearchSpecLatencyMillis
@@ -1854,7 +2247,7 @@ public final class AppSearchImpl implements Closeable {
             @NonNull SearchSpecProto searchSpec,
             @NonNull ResultSpecProto resultSpec,
             @NonNull ScoringSpecProto scoringSpec,
-            @Nullable SearchStats.Builder sStatsBuilder)
+            SearchStats.@Nullable Builder sStatsBuilder)
             throws AppSearchException {
         if (LogUtil.isPiiTraceEnabled()) {
             LogUtil.piiTrace(
@@ -1893,8 +2286,7 @@ public final class AppSearchImpl implements Closeable {
      *     using that suggestion in {@link #query}.
      * @throws AppSearchException if the suggestionQueryExpression is empty.
      */
-    @NonNull
-    public List<SearchSuggestionResult> searchSuggestion(
+    public @NonNull List<SearchSuggestionResult> searchSuggestion(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull String suggestionQueryExpression,
@@ -1956,8 +2348,7 @@ public final class AppSearchImpl implements Closeable {
      *
      * <p>This method is inefficient to call repeatedly.
      */
-    @NonNull
-    public Map<String, Set<String>> getPackageToDatabases() {
+    public @NonNull Map<String, Set<String>> getPackageToDatabases() {
         mReadWriteLock.readLock().lock();
         try {
             Map<String, Set<String>> packageToDatabases = new ArrayMap<>();
@@ -1991,11 +2382,10 @@ public final class AppSearchImpl implements Closeable {
      * @return The next page of results of previously executed query.
      * @throws AppSearchException on IcingSearchEngine error or if can't advance on nextPageToken.
      */
-    @NonNull
-    public SearchResultPage getNextPage(
+    public @NonNull SearchResultPage getNextPage(
             @NonNull String packageName,
             long nextPageToken,
-            @Nullable SearchStats.Builder sStatsBuilder)
+            SearchStats.@Nullable Builder sStatsBuilder)
             throws AppSearchException {
         long totalLatencyStartMillis = SystemClock.elapsedRealtime();
 
@@ -2003,10 +2393,12 @@ public final class AppSearchImpl implements Closeable {
         mReadWriteLock.readLock().lock();
         try {
             if (sStatsBuilder != null) {
-                sStatsBuilder.setJavaLockAcquisitionLatencyMillis(
-                        (int)
-                                (SystemClock.elapsedRealtime()
-                                        - javaLockAcquisitionLatencyStartMillis));
+                sStatsBuilder
+                        .setJavaLockAcquisitionLatencyMillis(
+                                (int)
+                                        (SystemClock.elapsedRealtime()
+                                                - javaLockAcquisitionLatencyStartMillis))
+                        .setLaunchVMEnabled(mIsVMEnabled);
             }
             throwIfClosedLocked();
 
@@ -2158,7 +2550,7 @@ public final class AppSearchImpl implements Closeable {
             @NonNull String databaseName,
             @NonNull String namespace,
             @NonNull String documentId,
-            @Nullable RemoveStats.Builder removeStatsBuilder)
+            RemoveStats.@Nullable Builder removeStatsBuilder)
             throws AppSearchException {
         long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
         mReadWriteLock.writeLock().lock();
@@ -2193,8 +2585,9 @@ public final class AppSearchImpl implements Closeable {
                     TAG, "removeById, response", deleteResultProto.getStatus(), deleteResultProto);
 
             if (removeStatsBuilder != null) {
-                removeStatsBuilder.setStatusCode(
-                        statusProtoToResultCode(deleteResultProto.getStatus()));
+                removeStatsBuilder
+                        .setStatusCode(statusProtoToResultCode(deleteResultProto.getStatus()))
+                        .setLaunchVMEnabled(mIsVMEnabled);
                 AppSearchLoggerHelper.copyNativeStats(
                         deleteResultProto.getDeleteStats(), removeStatsBuilder);
             }
@@ -2244,7 +2637,7 @@ public final class AppSearchImpl implements Closeable {
             @NonNull String databaseName,
             @NonNull String queryExpression,
             @NonNull SearchSpec searchSpec,
-            @Nullable RemoveStats.Builder removeStatsBuilder)
+            RemoveStats.@Nullable Builder removeStatsBuilder)
             throws AppSearchException {
         if (searchSpec.getJoinSpec() != null) {
             throw new IllegalArgumentException(
@@ -2306,8 +2699,10 @@ public final class AppSearchImpl implements Closeable {
         } finally {
             mReadWriteLock.writeLock().unlock();
             if (removeStatsBuilder != null) {
-                removeStatsBuilder.setTotalLatencyMillis(
-                        (int) (SystemClock.elapsedRealtime() - totalLatencyStartTimeMillis));
+                removeStatsBuilder
+                        .setTotalLatencyMillis(
+                                (int) (SystemClock.elapsedRealtime() - totalLatencyStartTimeMillis))
+                        .setLaunchVMEnabled(mIsVMEnabled);
             }
         }
     }
@@ -2328,7 +2723,7 @@ public final class AppSearchImpl implements Closeable {
             @NonNull String packageName,
             @NonNull SearchSpecProto finalSearchSpec,
             @Nullable Set<String> prefixedObservedSchemas,
-            @Nullable RemoveStats.Builder removeStatsBuilder)
+            RemoveStats.@Nullable Builder removeStatsBuilder)
             throws AppSearchException {
         LogUtil.piiTrace(TAG, "removeByQuery, request", finalSearchSpec);
         boolean returnDeletedDocumentInfo =
@@ -2391,39 +2786,32 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
-    /** Estimates the storage usage info for a specific package. */
-    @NonNull
-    public StorageInfo getStorageInfoForPackage(@NonNull String packageName)
+    /** Estimates the total storage usage info data size for a specific set of packages. */
+    public @NonNull StorageInfo getStorageInfoForPackages(@NonNull Set<String> packageNames)
             throws AppSearchException {
         mReadWriteLock.readLock().lock();
         try {
             throwIfClosedLocked();
 
             StorageInfo.Builder storageInfoBuilder = new StorageInfo.Builder();
-            if (Flags.enableBlobStore()) {
-                StorageInfoProto storageInfoProto = getRawStorageInfoProto();
-                // read blob storage info and set to storageInfoBuilder
-                getBlobStorageInfoForPrefix(storageInfoProto, packageName, storageInfoBuilder);
-                // read document storage info and set to storageInfoBuilder
-                Set<String> wantedPrefixedDocumentNamespaces =
-                        mNamespaceCacheLocked.getAllPrefixedDocumentNamespaceForPackage(
-                                packageName);
-                if (!wantedPrefixedDocumentNamespaces.isEmpty()) {
-                    getDocumentStorageInfoForNamespaces(
-                            storageInfoProto, wantedPrefixedDocumentNamespaces, storageInfoBuilder);
-                }
-            } else {
-                // blob flag off, only read document storage info and set to storageInfoBuilder if
-                // the database exists.
-                Set<String> wantedPrefixedDocumentNamespaces =
-                        mNamespaceCacheLocked.getAllPrefixedDocumentNamespaceForPackage(
-                                packageName);
-                if (!wantedPrefixedDocumentNamespaces.isEmpty()) {
-                    getDocumentStorageInfoForNamespaces(
-                            getRawStorageInfoProto(),
-                            wantedPrefixedDocumentNamespaces,
-                            storageInfoBuilder);
-                }
+            // read document storage info and set to storageInfoBuilder
+            Set<String> wantedPrefixedDocumentNamespaces =
+                    mNamespaceCacheLocked.getAllPrefixedDocumentNamespaceForPackages(packageNames);
+            Set<String> wantedPrefixedBlobNamespaces =
+                    mNamespaceCacheLocked.getAllPrefixedBlobNamespaceForPackages(packageNames);
+            if (wantedPrefixedDocumentNamespaces.isEmpty()
+                    && wantedPrefixedBlobNamespaces.isEmpty()) {
+                return storageInfoBuilder.build();
+            }
+            StorageInfoProto storageInfoProto = getRawStorageInfoProto();
+
+            if (Flags.enableBlobStore() && !wantedPrefixedBlobNamespaces.isEmpty()) {
+                getBlobStorageInfoForNamespaces(
+                        storageInfoProto, wantedPrefixedBlobNamespaces, storageInfoBuilder);
+            }
+            if (!wantedPrefixedDocumentNamespaces.isEmpty()) {
+                getDocumentStorageInfoForNamespaces(
+                        storageInfoProto, wantedPrefixedDocumentNamespaces, storageInfoBuilder);
             }
             return storageInfoBuilder.build();
         } finally {
@@ -2432,8 +2820,7 @@ public final class AppSearchImpl implements Closeable {
     }
 
     /** Estimates the storage usage info for a specific database in a package. */
-    @NonNull
-    public StorageInfo getStorageInfoForDatabase(
+    public @NonNull StorageInfo getStorageInfoForDatabase(
             @NonNull String packageName, @NonNull String databaseName) throws AppSearchException {
         mReadWriteLock.readLock().lock();
         try {
@@ -2487,8 +2874,7 @@ public final class AppSearchImpl implements Closeable {
      * Returns the native storage info capsuled in {@link StorageInfoResultProto} directly from
      * IcingSearchEngine.
      */
-    @NonNull
-    public StorageInfoProto getRawStorageInfoProto() throws AppSearchException {
+    public @NonNull StorageInfoProto getRawStorageInfoProto() throws AppSearchException {
         mReadWriteLock.readLock().lock();
         try {
             throwIfClosedLocked();
@@ -2520,7 +2906,7 @@ public final class AppSearchImpl implements Closeable {
     private static void getDocumentStorageInfoForNamespaces(
             @NonNull StorageInfoProto storageInfoProto,
             @NonNull Set<String> prefixedNamespaces,
-            @NonNull StorageInfo.Builder storageInfoBuilder) {
+            StorageInfo.@NonNull Builder storageInfoBuilder) {
         if (!storageInfoProto.hasDocumentStorageInfo()) {
             return;
         }
@@ -2576,10 +2962,37 @@ public final class AppSearchImpl implements Closeable {
      * @param storageInfoBuilder The {@link StorageInfo.Builder} used to and build the resulting
      *     {@link StorageInfo}. This builder will be modified with calculated values.
      */
-    private static void getBlobStorageInfoForPrefix(
+    private void getBlobStorageInfoForPrefix(
             @NonNull StorageInfoProto storageInfoProto,
             @NonNull String prefix,
-            @NonNull StorageInfo.Builder storageInfoBuilder) {
+            StorageInfo.@NonNull Builder storageInfoBuilder) {
+        Set<String> prefixedNamespaces = new ArraySet<>();
+        List<NamespaceBlobStorageInfoProto> blobStorageInfoProtos =
+                storageInfoProto.getNamespaceBlobStorageInfoList();
+        for (int i = 0; i < blobStorageInfoProtos.size(); i++) {
+            String prefixedNamespace = blobStorageInfoProtos.get(i).getNamespace();
+            if (prefixedNamespace.startsWith(prefix)) {
+                prefixedNamespaces.add(prefixedNamespace);
+            }
+        }
+        getBlobStorageInfoForNamespaces(storageInfoProto, prefixedNamespaces, storageInfoBuilder);
+    }
+
+    /**
+     * Extracts and returns blob storage information from {@link StorageInfoProto} based on prefixed
+     * namespaces.
+     *
+     * @param storageInfoProto The source {@link StorageInfoProto} containing blob storage
+     *     information to be analyzed.
+     * @param prefixedNamespaces A set of prefixed namespaces that the blob storage information will
+     *     be filtered against. Only namespaces in this set will be included in the analysis.
+     * @param storageInfoBuilder The {@link StorageInfo.Builder} used to and build the resulting
+     *     {@link StorageInfo}. This builder will be modified with calculated values.
+     */
+    private void getBlobStorageInfoForNamespaces(
+            @NonNull StorageInfoProto storageInfoProto,
+            @NonNull Set<String> prefixedNamespaces,
+            StorageInfo.@NonNull Builder storageInfoBuilder) {
         if (storageInfoProto.getNamespaceBlobStorageInfoCount() == 0) {
             return;
         }
@@ -2589,12 +3002,21 @@ public final class AppSearchImpl implements Closeable {
         int blobCount = 0;
         for (int i = 0; i < blobStorageInfoProtos.size(); i++) {
             NamespaceBlobStorageInfoProto blobStorageInfoProto = blobStorageInfoProtos.get(i);
-            if (blobStorageInfoProto.getNamespace().startsWith(prefix)) {
-                blobSizeBytes += blobStorageInfoProto.getBlobSize();
-                blobCount += blobStorageInfoProto.getNumBlobs();
+            if (prefixedNamespaces.contains(blobStorageInfoProto.getNamespace())) {
+                if (Flags.enableAppSearchManageBlobFiles()) {
+                    List<String> blobFileNames = blobStorageInfoProto.getBlobFileNamesList();
+                    for (int j = 0; j < blobFileNames.size(); j++) {
+                        File blobFile = new File(mBlobFilesDir, blobFileNames.get(j));
+                        blobSizeBytes += blobFile.length();
+                    }
+                    blobCount += blobFileNames.size();
+                } else {
+                    blobSizeBytes += blobStorageInfoProto.getBlobSize();
+                    blobCount += blobStorageInfoProto.getNumBlobs();
+                }
             }
         }
-        storageInfoBuilder.setBlobCount(blobCount).setBlobSizeBytes(blobSizeBytes);
+        storageInfoBuilder.setBlobsCount(blobCount).setBlobsSizeBytes(blobSizeBytes);
     }
 
     /**
@@ -2605,8 +3027,7 @@ public final class AppSearchImpl implements Closeable {
      *     return the simplest debug information. {@link DebugInfoVerbosity.Code#DETAILED} will
      *     return more detailed debug information as indicated in the comments in debug.proto
      */
-    @NonNull
-    public DebugInfoProto getRawDebugInfoProto(@NonNull DebugInfoVerbosity.Code verbosity)
+    public @NonNull DebugInfoProto getRawDebugInfoProto(DebugInfoVerbosity.@NonNull Code verbosity)
             throws AppSearchException {
         mReadWriteLock.readLock().lock();
         try {
@@ -2643,7 +3064,7 @@ public final class AppSearchImpl implements Closeable {
      *     needing data recovery.
      * @throws AppSearchException on any error that AppSearch persist data to disk.
      */
-    public void persistToDisk(@NonNull PersistType.Code persistType) throws AppSearchException {
+    public void persistToDisk(PersistType.@NonNull Code persistType) throws AppSearchException {
         mReadWriteLock.writeLock().lock();
         try {
             throwIfClosedLocked();
@@ -2775,7 +3196,7 @@ public final class AppSearchImpl implements Closeable {
      * @throws AppSearchException on IcingSearchEngine error.
      */
     @GuardedBy("mReadWriteLock")
-    private void resetLocked(@Nullable InitializeStats.Builder initStatsBuilder)
+    private void resetLocked(InitializeStats.@Nullable Builder initStatsBuilder)
             throws AppSearchException {
         LogUtil.piiTrace(TAG, "icingSearchEngine.reset, request");
         ResetResultProto resetResultProto = mIcingSearchEngineLocked.reset();
@@ -2832,7 +3253,7 @@ public final class AppSearchImpl implements Closeable {
     @VisibleForTesting
     static RewrittenSchemaResults rewriteSchema(
             @NonNull String prefix,
-            @NonNull SchemaProto.Builder existingSchema,
+            SchemaProto.@NonNull Builder existingSchema,
             @NonNull SchemaProto newSchema)
             throws AppSearchException {
         HashMap<String, SchemaTypeConfigProto> newTypesToProto = new HashMap<>();
@@ -3101,7 +3522,7 @@ public final class AppSearchImpl implements Closeable {
      *     #CHECK_OPTIMIZE_INTERVAL}, {@link IcingSearchEngine#getOptimizeInfo()} will be triggered
      *     and the counter will be reset.
      */
-    public void checkForOptimize(int mutationSize, @Nullable OptimizeStats.Builder builder)
+    public void checkForOptimize(int mutationSize, OptimizeStats.@Nullable Builder builder)
             throws AppSearchException {
         mReadWriteLock.writeLock().lock();
         try {
@@ -3123,7 +3544,7 @@ public final class AppSearchImpl implements Closeable {
      * <p>{@link IcingSearchEngine#optimize()} should be called only if {@link
      * OptimizeStrategy#shouldOptimize(GetOptimizeInfoResultProto)} return true.
      */
-    public void checkForOptimize(@Nullable OptimizeStats.Builder builder)
+    public void checkForOptimize(OptimizeStats.@Nullable Builder builder)
             throws AppSearchException {
         mReadWriteLock.writeLock().lock();
         try {
@@ -3142,7 +3563,7 @@ public final class AppSearchImpl implements Closeable {
     }
 
     /** Triggers {@link IcingSearchEngine#optimize()} directly. */
-    public void optimize(@Nullable OptimizeStats.Builder builder) throws AppSearchException {
+    public void optimize(OptimizeStats.@Nullable Builder builder) throws AppSearchException {
         mReadWriteLock.writeLock().lock();
         try {
             LogUtil.piiTrace(TAG, "optimize, request");
@@ -3153,11 +3574,27 @@ public final class AppSearchImpl implements Closeable {
                     optimizeResultProto.getStatus(),
                     optimizeResultProto);
             if (builder != null) {
-                builder.setStatusCode(statusProtoToResultCode(optimizeResultProto.getStatus()));
+                builder.setStatusCode(statusProtoToResultCode(optimizeResultProto.getStatus()))
+                        .setLaunchVMEnabled(mIsVMEnabled);
                 AppSearchLoggerHelper.copyNativeStats(
                         optimizeResultProto.getOptimizeStats(), builder);
             }
             checkSuccess(optimizeResultProto.getStatus());
+
+            // If AppSearch manages blob files, remove the optimized blob files.
+            if (Flags.enableAppSearchManageBlobFiles()) {
+                List<String> blobFileNamesToRemove =
+                        optimizeResultProto.getBlobFileNamesToRemoveList();
+                for (int i = 0; i < blobFileNamesToRemove.size(); i++) {
+                    File blobFileToRemove = new File(mBlobFilesDir, blobFileNamesToRemove.get(i));
+                    if (!blobFileToRemove.delete()) {
+                        Log.e(
+                                TAG,
+                                "Cannot delete the optimized blob file: "
+                                        + blobFileToRemove.getName());
+                    }
+                }
+            }
         } finally {
             mReadWriteLock.writeLock().unlock();
         }
@@ -3210,8 +3647,7 @@ public final class AppSearchImpl implements Closeable {
      *
      * <p>This method is inefficient to call repeatedly.
      */
-    @NonNull
-    public List<String> getAllPrefixedSchemaTypes() {
+    public @NonNull List<String> getAllPrefixedSchemaTypes() {
         mReadWriteLock.readLock().lock();
         try {
             return mSchemaCacheLocked.getAllPrefixedSchemaTypes();
@@ -3225,8 +3661,7 @@ public final class AppSearchImpl implements Closeable {
      *
      * <p>This method is inefficient to call repeatedly.
      */
-    @NonNull
-    public List<String> getAllPrefixedBlobNamespaces() {
+    public @NonNull List<String> getAllPrefixedBlobNamespaces() {
         mReadWriteLock.readLock().lock();
         try {
             return mNamespaceCacheLocked.getAllPrefixedBlobNamespaces();
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchLogger.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchLogger.java
index 847d0aa8..f876ae15 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/AppSearchLogger.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchLogger.java
@@ -16,7 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage;
 
-import android.annotation.NonNull;
 import android.app.appsearch.stats.SchemaMigrationStats;
 
 import com.android.server.appsearch.external.localstorage.stats.CallStats;
@@ -28,6 +27,8 @@ import com.android.server.appsearch.external.localstorage.stats.SearchSessionSta
 import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.List;
 
 /**
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchLoggerHelper.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchLoggerHelper.java
index 58f8599c..422f616d 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/AppSearchLoggerHelper.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchLoggerHelper.java
@@ -16,8 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage;
 
-import android.annotation.NonNull;
-
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
@@ -33,6 +31,8 @@ import com.google.android.icing.proto.PutDocumentStatsProto;
 import com.google.android.icing.proto.QueryStatsProto;
 import com.google.android.icing.proto.SetSchemaResultProto;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Objects;
 
 /**
@@ -53,7 +53,7 @@ public final class AppSearchLoggerHelper {
      */
     static void copyNativeStats(
             @NonNull PutDocumentStatsProto fromNativeStats,
-            @NonNull PutDocumentStats.Builder toStatsBuilder) {
+            PutDocumentStats.@NonNull Builder toStatsBuilder) {
         Objects.requireNonNull(fromNativeStats);
         Objects.requireNonNull(toStatsBuilder);
         toStatsBuilder
@@ -79,7 +79,7 @@ public final class AppSearchLoggerHelper {
      */
     static void copyNativeStats(
             @NonNull InitializeStatsProto fromNativeStats,
-            @NonNull InitializeStats.Builder toStatsBuilder) {
+            InitializeStats.@NonNull Builder toStatsBuilder) {
         Objects.requireNonNull(fromNativeStats);
         Objects.requireNonNull(toStatsBuilder);
         toStatsBuilder
@@ -107,7 +107,7 @@ public final class AppSearchLoggerHelper {
      * @param toStatsBuilder Stats copied to.
      */
     static void copyNativeStats(
-            @NonNull QueryStatsProto fromNativeStats, @NonNull SearchStats.Builder toStatsBuilder) {
+            @NonNull QueryStatsProto fromNativeStats, SearchStats.@NonNull Builder toStatsBuilder) {
         Objects.requireNonNull(fromNativeStats);
         Objects.requireNonNull(toStatsBuilder);
         toStatsBuilder
@@ -144,7 +144,7 @@ public final class AppSearchLoggerHelper {
      */
     static void copyNativeStats(
             @NonNull DeleteStatsProto fromNativeStats,
-            @NonNull RemoveStats.Builder toStatsBuilder) {
+            RemoveStats.@NonNull Builder toStatsBuilder) {
         Objects.requireNonNull(fromNativeStats);
         Objects.requireNonNull(toStatsBuilder);
         toStatsBuilder
@@ -161,7 +161,7 @@ public final class AppSearchLoggerHelper {
      */
     static void copyNativeStats(
             @NonNull DeleteByQueryStatsProto fromNativeStats,
-            @NonNull RemoveStats.Builder toStatsBuilder) {
+            RemoveStats.@NonNull Builder toStatsBuilder) {
         Objects.requireNonNull(fromNativeStats);
         Objects.requireNonNull(toStatsBuilder);
 
@@ -179,7 +179,7 @@ public final class AppSearchLoggerHelper {
      */
     static void copyNativeStats(
             @NonNull OptimizeStatsProto fromNativeStats,
-            @NonNull OptimizeStats.Builder toStatsBuilder) {
+            OptimizeStats.@NonNull Builder toStatsBuilder) {
         Objects.requireNonNull(fromNativeStats);
         Objects.requireNonNull(toStatsBuilder);
         toStatsBuilder
@@ -203,7 +203,7 @@ public final class AppSearchLoggerHelper {
      */
     static void copyNativeStats(
             @NonNull SetSchemaResultProto fromProto,
-            @NonNull SetSchemaStats.Builder toStatsBuilder) {
+            SetSchemaStats.@NonNull Builder toStatsBuilder) {
         Objects.requireNonNull(fromProto);
         Objects.requireNonNull(toStatsBuilder);
         toStatsBuilder
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchRevocableFileDescriptor.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchRevocableFileDescriptor.java
new file mode 100644
index 00000000..f81425c3
--- /dev/null
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchRevocableFileDescriptor.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.external.localstorage;
+
+import android.os.ParcelFileDescriptor;
+import android.os.ParcelFileDescriptor.OnCloseListener;
+
+import org.jspecify.annotations.NonNull;
+
+import java.io.IOException;
+
+/**
+ * A custom {@link ParcelFileDescriptor} that provides an additional mechanism to register a {@link
+ * ParcelFileDescriptor.OnCloseListener} which will be invoked when the file descriptor is closed.
+ *
+ * @hide
+ */
+public interface AppSearchRevocableFileDescriptor {
+
+    /**
+     * Gets the mode of this {@link AppSearchRevocableFileDescriptor}, It should be {@link
+     * ParcelFileDescriptor#MODE_READ_ONLY} or {@link ParcelFileDescriptor#MODE_READ_WRITE}.
+     */
+    int getMode();
+
+    /**
+     * Gets the revocable {@link ParcelFileDescriptor} that could be sent to an untrusted caller.
+     *
+     * <p>AppSearch will retain control of this {@link ParcelFileDescriptor}'s access to the file.
+     *
+     * <p>Call {@link #revoke()} to invoke the sent {@link ParcelFileDescriptor}.
+     */
+    @NonNull ParcelFileDescriptor getRevocableFileDescriptor();
+
+    /**
+     * Revoke the sent {@link ParcelFileDescriptor} returned by {@link
+     * #getRevocableFileDescriptor()}.
+     *
+     * <p>After calling this method, any access to the file descriptors will fail.
+     *
+     * @throws IOException If an I/O error occurs while revoking file descriptors.
+     */
+    void revoke() throws IOException;
+
+    /**
+     * Callback for indicating that the {@link ParcelFileDescriptor} returned by {@link
+     * #getRevocableFileDescriptor()} has been closed.
+     */
+    void setOnCloseListener(@NonNull OnCloseListener onCloseListener);
+}
diff --git a/service/java/com/android/server/appsearch/external/localstorage/DocumentLimiter.java b/service/java/com/android/server/appsearch/external/localstorage/DocumentLimiter.java
index 81f27f50..61c81b8b 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/DocumentLimiter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/DocumentLimiter.java
@@ -18,7 +18,6 @@ package com.android.server.appsearch.external.localstorage;
 
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.getPackageName;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.util.ArrayMap;
@@ -28,6 +27,8 @@ import com.android.server.appsearch.external.localstorage.util.MapUtil;
 
 import com.google.android.icing.proto.NamespaceStorageInfoProto;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
diff --git a/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java b/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java
index 0508caba..7d212fa0 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java
@@ -18,8 +18,12 @@ package com.android.server.appsearch.external.localstorage;
 
 import android.app.appsearch.SearchSpec;
 
+import com.android.appsearch.flags.Flags;
+
 import com.google.android.icing.proto.IcingSearchEngineOptions;
 
+import org.jspecify.annotations.NonNull;
+
 /**
  * An interface exposing the optional config flags in {@link IcingSearchEngineOptions} used to
  * instantiate {@link com.google.android.icing.IcingSearchEngine}, as well as other additional
@@ -74,6 +78,8 @@ public interface IcingOptionsConfig {
 
     long DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS = 7 * 24 * 60 * 60 * 1000L; // 1 week.
 
+    String DEFAULT_ICU_DATA_FILE_ABSOLUTE_PATH = "";
+
     /**
      * The maximum allowable token length. All tokens in excess of this size will be truncated to
      * max_token_length before being indexed.
@@ -230,4 +236,54 @@ public interface IcingOptionsConfig {
      * no reference document linked to it.
      */
     long getOrphanBlobTimeToLiveMs();
+
+    /**
+     * Config for {@link com.google.android.icing.proto.IcingSearchEngineOptions}.
+     *
+     * <p>The absolute path to the ICU data file. If a valid path has been provided, it will be used
+     * to initialize ICU. The path is not available in Jetpack and Framework. This method is
+     * functionally no-op and returns an empty string.
+     */
+    @NonNull String getIcuDataFileAbsolutePath();
+
+    /**
+     * Converts to an {@link IcingSearchEngineOptions} instance.
+     *
+     * @param baseDir base directory of the icing instance.
+     */
+    default @NonNull IcingSearchEngineOptions toIcingSearchEngineOptions(@NonNull String baseDir) {
+        return IcingSearchEngineOptions.newBuilder()
+                .setBaseDir(baseDir)
+                .setMaxTokenLength(getMaxTokenLength())
+                .setIndexMergeSize(getIndexMergeSize())
+                .setDocumentStoreNamespaceIdFingerprint(getDocumentStoreNamespaceIdFingerprint())
+                .setOptimizeRebuildIndexThreshold(getOptimizeRebuildIndexThreshold())
+                .setCompressionLevel(getCompressionLevel())
+                .setAllowCircularSchemaDefinitions(getAllowCircularSchemaDefinitions())
+                .setPreMappingFbv(getUsePreMappingWithFileBackedVector())
+                .setUsePersistentHashMap(getUsePersistentHashMap())
+                .setIntegerIndexBucketSplitThreshold(getIntegerIndexBucketSplitThreshold())
+                .setLiteIndexSortAtIndexing(getLiteIndexSortAtIndexing())
+                .setLiteIndexSortSize(getLiteIndexSortSize())
+                .setUseNewQualifiedIdJoinIndex(getUseNewQualifiedIdJoinIndex())
+                .setBuildPropertyExistenceMetadataHits(getBuildPropertyExistenceMetadataHits())
+                .setEnableBlobStore(Flags.enableBlobStore())
+                .setOrphanBlobTimeToLiveMs(getOrphanBlobTimeToLiveMs())
+                .setEnableEmbeddingIndex(Flags.enableSchemaEmbeddingPropertyConfig())
+                .setEnableEmbeddingQuantization(Flags.enableSchemaEmbeddingQuantization())
+                .setEnableScorableProperties(Flags.enableScorableProperty())
+                .setIcuDataFileAbsolutePath(getIcuDataFileAbsolutePath())
+                .setManageBlobFiles(!Flags.enableAppSearchManageBlobFiles())
+                // Join index v3 is a prerequisite for delete propagation.
+                .setEnableDeletePropagationFrom(
+                        Flags.enableDeletePropagationType() && Flags.enableQualifiedIdJoinIndexV3())
+                .setCalculateTimeSinceLastAttemptedOptimize(
+                        Flags.enableCalculateTimeSinceLastAttemptedOptimize())
+                .setEnableQualifiedIdJoinIndexV3(Flags.enableQualifiedIdJoinIndexV3())
+                .setEnableSoftIndexRestoration(Flags.enableSoftIndexRestoration())
+                .setEnableMarkerFileForOptimize(Flags.enableMarkerFileForOptimize())
+                .setReleaseBackupSchemaFileIfOverlayPresent(
+                        Flags.enableReleaseBackupSchemaFileIfOverlayPresent())
+                .build();
+    }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/LimitConfig.java b/service/java/com/android/server/appsearch/external/localstorage/LimitConfig.java
index 4509cffc..44261100 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/LimitConfig.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/LimitConfig.java
@@ -77,4 +77,11 @@ public interface LimitConfig {
      * open for read and write blob from AppSearch.
      */
     int getMaxOpenBlobCount();
+
+    /**
+     * Returns the max number of bytes we will batch and send to IcingSearchEngine during
+     * AppSearchImpl.batchPutDocuments. By default, we just use the same value as
+     * #getMaxDocumentSizeBytes().
+     */
+    int getMaxByteLimitForBatchPut();
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/NamespaceCache.java b/service/java/com/android/server/appsearch/external/localstorage/NamespaceCache.java
index cdc0d421..e2ced914 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/NamespaceCache.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/NamespaceCache.java
@@ -16,14 +16,15 @@
 
 package com.android.server.appsearch.external.localstorage;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -53,41 +54,51 @@ public class NamespaceCache {
         mDocumentNamespaceMap.putAll(documentNamespaceMap);
     }
 
-    /** Gets all prefixed document namespaces of the given package. */
-    @NonNull
-    public Set<String> getAllPrefixedDocumentNamespaceForPackage(@NonNull String packageName) {
+    /** Gets all prefixed document namespaces of the given set of packages. */
+    public @NonNull Set<String> getAllPrefixedDocumentNamespaceForPackages(
+            @NonNull Set<String> packageNames) {
+        Set<String> wantedPrefixedNamespaces = new ArraySet<>();
+
+        // Accumulate all the namespaces we're interested in.
+        for (Map.Entry<String, Set<String>> entry : mDocumentNamespaceMap.entrySet()) {
+            if (packageNames.contains(PrefixUtil.getPackageName(entry.getKey()))) {
+                wantedPrefixedNamespaces.addAll(entry.getValue());
+            }
+        }
+        return wantedPrefixedNamespaces;
+    }
+
+    /** Gets all prefixed document blob namespaces of the given set of packages. */
+    public @NonNull Set<String> getAllPrefixedBlobNamespaceForPackages(
+            @NonNull Set<String> packageNames) {
         Set<String> wantedPrefixedNamespaces = new ArraySet<>();
 
         // Accumulate all the namespaces we're interested in.
-        for (String prefix : mDocumentNamespaceMap.keySet()) {
-            if (PrefixUtil.getPackageName(prefix).equals(packageName)) {
-                wantedPrefixedNamespaces.addAll(mDocumentNamespaceMap.get(prefix));
+        for (Map.Entry<String, Set<String>> entry : mBlobNamespaceMap.entrySet()) {
+            if (packageNames.contains(PrefixUtil.getPackageName(entry.getKey()))) {
+                wantedPrefixedNamespaces.addAll(entry.getValue());
             }
         }
         return wantedPrefixedNamespaces;
     }
 
     /** Gets prefixed document namespaces of the given prefix. */
-    @Nullable
-    public Set<String> getPrefixedDocumentNamespaces(@NonNull String prefix) {
+    public @Nullable Set<String> getPrefixedDocumentNamespaces(@NonNull String prefix) {
         return mDocumentNamespaceMap.get(prefix);
     }
 
     /** Gets prefixed blob namespaces of the given prefix. */
-    @Nullable
-    public Set<String> getPrefixedBlobNamespaces(@NonNull String prefix) {
+    public @Nullable Set<String> getPrefixedBlobNamespaces(@NonNull String prefix) {
         return mBlobNamespaceMap.get(prefix);
     }
 
     /** Gets all prefixes that contains documents in AppSearch. */
-    @NonNull
-    public Set<String> getAllDocumentPrefixes() {
+    public @NonNull Set<String> getAllDocumentPrefixes() {
         return mDocumentNamespaceMap.keySet();
     }
 
     /** Gets all prefixed blob namespaces in AppSearch. */
-    @NonNull
-    public List<String> getAllPrefixedBlobNamespaces() {
+    public @NonNull List<String> getAllPrefixedBlobNamespaces() {
         List<String> prefixedBlobNamespaces = new ArrayList<>();
         for (Set<String> value : mBlobNamespaceMap.values()) {
             prefixedBlobNamespaces.addAll(value);
@@ -96,8 +107,7 @@ public class NamespaceCache {
     }
 
     /** Removes prefixed document namespaces under the given prefix. */
-    @Nullable
-    public Set<String> removeDocumentNamespaces(@NonNull String prefix) {
+    public @Nullable Set<String> removeDocumentNamespaces(@NonNull String prefix) {
         return mDocumentNamespaceMap.remove(prefix);
     }
 
diff --git a/service/java/com/android/server/appsearch/external/localstorage/ObserverManager.java b/service/java/com/android/server/appsearch/external/localstorage/ObserverManager.java
index 6b22a536..a943f745 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/ObserverManager.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/ObserverManager.java
@@ -16,8 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.observer.DocumentChangeInfo;
 import android.app.appsearch.observer.ObserverCallback;
 import android.app.appsearch.observer.ObserverSpec;
@@ -34,6 +32,9 @@ import com.android.server.appsearch.external.localstorage.visibilitystore.Visibi
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityUtil;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -329,8 +330,7 @@ public class ObserverManager {
      * packageName}, {@code databaseName} and unprefixed {@code schemaType}, only if they have
      * access to that type according to the provided {@code visibilityChecker}.
      */
-    @NonNull
-    public Set<String> getObserversForSchemaType(
+    public @NonNull Set<String> getObserversForSchemaType(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull String schemaType,
diff --git a/service/java/com/android/server/appsearch/external/localstorage/OptimizeStrategy.java b/service/java/com/android/server/appsearch/external/localstorage/OptimizeStrategy.java
index 6cb84bc6..4a357e75 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/OptimizeStrategy.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/OptimizeStrategy.java
@@ -16,10 +16,11 @@
 
 package com.android.server.appsearch.external.localstorage;
 
-import android.annotation.NonNull;
 
 import com.google.android.icing.proto.GetOptimizeInfoResultProto;
 
+import org.jspecify.annotations.NonNull;
+
 /**
  * An interface class for implementing a strategy to determine when to trigger {@link
  * AppSearchImpl#optimize()}.
diff --git a/service/java/com/android/server/appsearch/external/localstorage/RevocableFileDescriptorStore.java b/service/java/com/android/server/appsearch/external/localstorage/RevocableFileDescriptorStore.java
index 6958690b..85677b23 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/RevocableFileDescriptorStore.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/RevocableFileDescriptorStore.java
@@ -16,39 +16,138 @@
 
 package com.android.server.appsearch.external.localstorage;
 
-import android.annotation.NonNull;
+import android.app.appsearch.AppSearchBlobHandle;
+import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.os.ParcelFileDescriptor;
+import android.util.ArrayMap;
+import android.util.ArraySet;
+
+import com.android.internal.annotations.GuardedBy;
+
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
 
 /**
- * Interface for revocable file descriptors storage.
+ * The base class for revocable file descriptors storage.
  *
  * <p>This store allows wrapping {@link ParcelFileDescriptor} instances into revocable file
  * descriptors, enabling the ability to close and revoke it's access to the file even if the {@link
  * ParcelFileDescriptor} has been sent to the client side.
  *
- * <p>Implementations of this interface can provide controlled access to resources by associating
- * each file descriptor with a package and allowing them to be individually revoked by package or
- * revoked all at once.
+ * <p>This class can provide controlled access to resources by associating each file descriptor with
+ * a package and allowing them to be individually revoked by package or revoked all at once.
+ *
+ * <p>The sub-class must define how to wrap a {@link ParcelFileDescriptor} to a {@link
+ * AppSearchRevocableFileDescriptor}.
+ *
+ * <p>This class stores {@link AppSearchBlobHandle} and returned {@link
+ * AppSearchRevocableFileDescriptor} for writing in key-value pairs map. Only one opened {@link
+ * AppSearchRevocableFileDescriptor} for writing will be allowed for each {@link
+ * AppSearchBlobHandle}.
+ *
+ * <p>This class stores {@link AppSearchRevocableFileDescriptor} for reading in a list. There is no
+ * use case to look up and invoke a single {@link AppSearchRevocableFileDescriptor} for reading.
  *
  * @hide
  */
-public interface RevocableFileDescriptorStore {
+public abstract class RevocableFileDescriptorStore {
+
+    private final Object mLock = new Object();
+    private final AppSearchConfig mConfig;
+
+    public RevocableFileDescriptorStore(@NonNull AppSearchConfig config) {
+        mConfig = Objects.requireNonNull(config);
+    }
+
+    @GuardedBy("mLock")
+    // Map<package, Map<blob handle, sent rfds>> map to track all sent rfds for writing. We only
+    // allow user to open 1 pfd for write for same file.
+    private final Map<String, Map<AppSearchBlobHandle, AppSearchRevocableFileDescriptor>>
+            mSentRevocableFileDescriptorsForWriteLocked = new ArrayMap<>();
+
+    @GuardedBy("mLock")
+    // <package, List<sent rfds> map to track all sent rfds for reading. We allow opening
+    // multiple pfds for read for the same file.
+    private final Map<String, List<AppSearchRevocableFileDescriptor>>
+            mSentRevocableFileDescriptorsForReadLocked = new ArrayMap<>();
 
     /**
-     * Wraps the provided ParcelFileDescriptor into a revocable file descriptor. This allows for
-     * controlled access to the file descriptor, making it revocable by the store.
+     * Wraps the provided {@link ParcelFileDescriptor} into a revocable file descriptor.
+     *
+     * <p>This allows for controlled access to the file descriptor, making it revocable by the
+     * store.
      *
      * @param packageName The package name requesting the revocable file descriptor.
-     * @param parcelFileDescriptor The original ParcelFileDescriptor to be wrapped.
-     * @return A ParcelFileDescriptor that can be revoked by the store.
+     * @param blobHandle The blob handle associated with the file descriptor. It cannot be null if
+     *     the mode is READ_WRITE.
+     * @param parcelFileDescriptor The original {@link ParcelFileDescriptor} to be wrapped.
+     * @param mode The mode of the given {@link ParcelFileDescriptor}. It should be {@link
+     *     ParcelFileDescriptor#MODE_READ_ONLY} or {@link ParcelFileDescriptor#MODE_READ_WRITE}.
+     * @return A {@link ParcelFileDescriptor} that can be revoked by the store.
+     * @throws IOException if an I/O error occurs while creating the revocable file descriptor.
+     */
+    public @NonNull ParcelFileDescriptor wrapToRevocableFileDescriptor(
+            @NonNull String packageName,
+            @Nullable AppSearchBlobHandle blobHandle,
+            @NonNull ParcelFileDescriptor parcelFileDescriptor,
+            int mode)
+            throws IOException {
+        AppSearchRevocableFileDescriptor revocableFileDescriptor =
+                wrapToRevocableFileDescriptor(parcelFileDescriptor, mode);
+        setCloseListenerToFd(packageName, blobHandle, revocableFileDescriptor);
+        addToSentRevocableFileDescriptorMap(packageName, blobHandle, revocableFileDescriptor);
+        return revocableFileDescriptor.getRevocableFileDescriptor();
+    }
+
+    /**
+     * Wraps the provided {@link ParcelFileDescriptor} into a specific type of {@link
+     * AppSearchRevocableFileDescriptor}.
+     */
+    protected abstract @NonNull AppSearchRevocableFileDescriptor wrapToRevocableFileDescriptor(
+            @NonNull ParcelFileDescriptor parcelFileDescriptor, int mode) throws IOException;
+
+    /**
+     * Gets the opened revocable file descriptor for write associated with the given {@link
+     * AppSearchBlobHandle}.
+     *
+     * @param packageName The package name associated with the file descriptor.
+     * @param blobHandle The blob handle associated with the file descriptor.
+     * @return The opened revocable file descriptor, or {@code null} if not found.
      */
-    @NonNull
-    ParcelFileDescriptor wrapToRevocableFileDescriptor(
-            @NonNull String packageName, @NonNull ParcelFileDescriptor parcelFileDescriptor)
-            throws IOException;
+    public @Nullable ParcelFileDescriptor getOpenedRevocableFileDescriptorForWrite(
+            @NonNull String packageName, @NonNull AppSearchBlobHandle blobHandle)
+            throws IOException {
+        synchronized (mLock) {
+            Map<AppSearchBlobHandle, AppSearchRevocableFileDescriptor> rfdsForPackage =
+                    mSentRevocableFileDescriptorsForWriteLocked.get(packageName);
+            if (rfdsForPackage == null) {
+                return null;
+            }
+            AppSearchRevocableFileDescriptor revocableFileDescriptor =
+                    rfdsForPackage.get(blobHandle);
+            if (revocableFileDescriptor == null) {
+                return null;
+            }
+            if (!revocableFileDescriptor.getRevocableFileDescriptor().getFileDescriptor().valid()) {
+                // In Android T and below, even if the sent file descriptor is closed, the resource
+                // won't be released immediately. We should revoke now and recreate new pfd.
+                revocableFileDescriptor.revoke();
+                rfdsForPackage.remove(blobHandle);
+                return null;
+            }
+            // The revocableFileDescriptor should never be revoked, otherwise it should be removed
+            // from the map.
+            return revocableFileDescriptor.getRevocableFileDescriptor();
+        }
+    }
 
     /**
      * Revokes all revocable file descriptors previously issued by the store. After calling this
@@ -56,7 +155,16 @@ public interface RevocableFileDescriptorStore {
      *
      * @throws IOException If an I/O error occurs while revoking file descriptors.
      */
-    void revokeAll() throws IOException;
+    public void revokeAll() throws IOException {
+        synchronized (mLock) {
+            Set<String> packageNames =
+                    new ArraySet<>(mSentRevocableFileDescriptorsForReadLocked.keySet());
+            packageNames.addAll(mSentRevocableFileDescriptorsForWriteLocked.keySet());
+            for (String packageName : packageNames) {
+                revokeForPackage(packageName);
+            }
+        }
+    }
 
     /**
      * Revokes all revocable file descriptors for a specified package. Only file descriptors
@@ -65,8 +173,203 @@ public interface RevocableFileDescriptorStore {
      * @param packageName The package name whose file descriptors should be revoked.
      * @throws IOException If an I/O error occurs while revoking file descriptors.
      */
-    void revokeForPackage(@NonNull String packageName) throws IOException;
+    public void revokeForPackage(@NonNull String packageName) throws IOException {
+        synchronized (mLock) {
+            List<AppSearchRevocableFileDescriptor> rfdsForRead =
+                    mSentRevocableFileDescriptorsForReadLocked.remove(packageName);
+            if (rfdsForRead != null) {
+                for (int i = rfdsForRead.size() - 1; i >= 0; i--) {
+                    rfdsForRead.get(i).revoke();
+                }
+            }
+
+            Map<AppSearchBlobHandle, AppSearchRevocableFileDescriptor> rfdsForWrite =
+                    mSentRevocableFileDescriptorsForWriteLocked.remove(packageName);
+            if (rfdsForWrite != null) {
+                for (AppSearchRevocableFileDescriptor rfdForWrite : rfdsForWrite.values()) {
+                    rfdForWrite.revoke();
+                }
+            }
+        }
+    }
+
+    /**
+     * Revokes the revocable file descriptors for write associated with the given {@link
+     * AppSearchBlobHandle}.
+     *
+     * <p>Once a blob is sealed, we should call this method to revoke the sent file descriptor for
+     * write. Otherwise, the user could keep writing to the committed file.
+     *
+     * @param packageName The package name whose file descriptors should be revoked.
+     * @param blobHandle The blob handle associated with the file descriptors.
+     * @throws IOException If an I/O error occurs while revoking file descriptors.
+     */
+    public void revokeFdForWrite(
+            @NonNull String packageName, @NonNull AppSearchBlobHandle blobHandle)
+            throws IOException {
+        synchronized (mLock) {
+            Map<AppSearchBlobHandle, AppSearchRevocableFileDescriptor> rfdsForWrite =
+                    mSentRevocableFileDescriptorsForWriteLocked.get(packageName);
+            if (rfdsForWrite == null) {
+                return;
+            }
+            AppSearchRevocableFileDescriptor revocableFileDescriptor =
+                    rfdsForWrite.remove(blobHandle);
+            if (revocableFileDescriptor == null) {
+                return;
+            }
+            revocableFileDescriptor.revoke();
+            if (rfdsForWrite.isEmpty()) {
+                mSentRevocableFileDescriptorsForWriteLocked.remove(packageName);
+            }
+        }
+    }
 
     /** Checks if the specified package has reached its blob storage limit. */
-    void checkBlobStoreLimit(@NonNull String packageName) throws AppSearchException;
+    public void checkBlobStoreLimit(@NonNull String packageName) throws AppSearchException {
+        synchronized (mLock) {
+            int totalOpenFdSize = 0;
+            List<AppSearchRevocableFileDescriptor> rfdsForRead =
+                    mSentRevocableFileDescriptorsForReadLocked.get(packageName);
+            if (rfdsForRead != null) {
+                totalOpenFdSize += rfdsForRead.size();
+            }
+            Map<AppSearchBlobHandle, AppSearchRevocableFileDescriptor> rfdsForWrite =
+                    mSentRevocableFileDescriptorsForWriteLocked.get(packageName);
+            if (rfdsForWrite != null) {
+                totalOpenFdSize += rfdsForWrite.size();
+            }
+            if (totalOpenFdSize >= mConfig.getMaxOpenBlobCount()) {
+                throw new AppSearchException(
+                        AppSearchResult.RESULT_OUT_OF_SPACE,
+                        "Package \""
+                                + packageName
+                                + "\" exceeded limit of "
+                                + mConfig.getMaxOpenBlobCount()
+                                + " opened file descriptors. Some file descriptors "
+                                + "must be closed to open additional ones.");
+            }
+        }
+    }
+
+    /**
+     * Sets a close listener to the revocable file descriptor for write.
+     *
+     * <p>The listener will be invoked when the file descriptor is closed.
+     *
+     * @param packageName The package name associated with the file descriptor.
+     * @param blobHandle The blob handle associated with the file descriptor. It cannot be null if
+     *     the mode is READ_WRITE.
+     * @param revocableFileDescriptor The revocable file descriptor to set the listener to.
+     */
+    private void setCloseListenerToFd(
+            @NonNull String packageName,
+            @Nullable AppSearchBlobHandle blobHandle,
+            @NonNull AppSearchRevocableFileDescriptor revocableFileDescriptor) {
+        ParcelFileDescriptor.OnCloseListener closeListener;
+        switch (revocableFileDescriptor.getMode()) {
+            case ParcelFileDescriptor.MODE_READ_ONLY:
+                closeListener =
+                        e -> {
+                            synchronized (mLock) {
+                                List<AppSearchRevocableFileDescriptor> fdsForPackage =
+                                        mSentRevocableFileDescriptorsForReadLocked.get(packageName);
+                                if (fdsForPackage != null) {
+                                    fdsForPackage.remove(revocableFileDescriptor);
+                                    if (fdsForPackage.isEmpty()) {
+                                        mSentRevocableFileDescriptorsForReadLocked.remove(
+                                                packageName);
+                                    }
+                                }
+                            }
+                        };
+                break;
+            case ParcelFileDescriptor.MODE_READ_WRITE:
+                Objects.requireNonNull(blobHandle);
+                closeListener =
+                        e -> {
+                            synchronized (mLock) {
+                                Map<AppSearchBlobHandle, AppSearchRevocableFileDescriptor>
+                                        rfdsForPackage =
+                                                mSentRevocableFileDescriptorsForWriteLocked.get(
+                                                        packageName);
+                                if (rfdsForPackage != null) {
+                                    AppSearchRevocableFileDescriptor rfd =
+                                            rfdsForPackage.get(blobHandle);
+                                    if (rfd == revocableFileDescriptor) {
+                                        // In Platform, this close listener will be only called
+                                        // when the resource of sent pfd is released in the sdk
+                                        // side. In T and below this may happened on a delay.
+                                        // If user re-write with the same blob handle before release
+                                        // the resource, the mSentRevocableFileDescriptorsForWrite
+                                        // will be override by new AppSearchRevocableFileDescriptor.
+                                        // We should only revoke and remove from map if there is no
+                                        // other rfd created for this blob handle.
+                                        try {
+                                            rfdsForPackage.remove(blobHandle);
+                                            rfd.revoke();
+                                        } catch (IOException ioException) {
+                                            // ignore, the sent RevocableFileDescriptor should
+                                            // already
+                                            // be closed.
+                                        }
+                                    }
+                                    if (rfdsForPackage.isEmpty()) {
+                                        mSentRevocableFileDescriptorsForWriteLocked.remove(
+                                                packageName);
+                                    }
+                                }
+                            }
+                        };
+                break;
+            default:
+                throw new UnsupportedOperationException(
+                        "Cannot support the AppSearchRevocableFileDescriptor mode: "
+                                + revocableFileDescriptor.getMode());
+        }
+        revocableFileDescriptor.setOnCloseListener(closeListener);
+    }
+
+    /**
+     * Adds a revocable file descriptor to the sent revocable file descriptor map.
+     *
+     * @param packageName The package name associated with the file descriptor.
+     * @param blobHandle The blob handle associated with the file descriptor. It cannot be null if
+     *     the mode is READ_WRITE.
+     * @param revocableFileDescriptor The revocable file descriptor to add.
+     */
+    private void addToSentRevocableFileDescriptorMap(
+            @NonNull String packageName,
+            @Nullable AppSearchBlobHandle blobHandle,
+            @NonNull AppSearchRevocableFileDescriptor revocableFileDescriptor) {
+        synchronized (mLock) {
+            switch (revocableFileDescriptor.getMode()) {
+                case ParcelFileDescriptor.MODE_READ_ONLY:
+                    List<AppSearchRevocableFileDescriptor> rfdListForPackage =
+                            mSentRevocableFileDescriptorsForReadLocked.get(packageName);
+                    if (rfdListForPackage == null) {
+                        rfdListForPackage = new ArrayList<>();
+                        mSentRevocableFileDescriptorsForReadLocked.put(
+                                packageName, rfdListForPackage);
+                    }
+                    rfdListForPackage.add(revocableFileDescriptor);
+                    break;
+                case ParcelFileDescriptor.MODE_READ_WRITE:
+                    Objects.requireNonNull(blobHandle);
+                    Map<AppSearchBlobHandle, AppSearchRevocableFileDescriptor> rfdMapForPackage =
+                            mSentRevocableFileDescriptorsForWriteLocked.get(packageName);
+                    if (rfdMapForPackage == null) {
+                        rfdMapForPackage = new ArrayMap<>();
+                        mSentRevocableFileDescriptorsForWriteLocked.put(
+                                packageName, rfdMapForPackage);
+                    }
+                    rfdMapForPackage.put(blobHandle, revocableFileDescriptor);
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            "Cannot support the AppSearchRevocableFileDescriptor mode: "
+                                    + revocableFileDescriptor.getMode());
+            }
+        }
+    }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/SchemaCache.java b/service/java/com/android/server/appsearch/external/localstorage/SchemaCache.java
index 98ef5952..8db3f94a 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/SchemaCache.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/SchemaCache.java
@@ -16,7 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage;
 
-import android.annotation.NonNull;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.util.ArrayMap;
 import android.util.ArraySet;
@@ -27,6 +26,8 @@ import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 
 import com.google.android.icing.proto.SchemaTypeConfigProto;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -77,8 +78,8 @@ public class SchemaCache {
     }
 
     /** Returns the schema map for the given prefix. */
-    @NonNull
-    public Map<String, SchemaTypeConfigProto> getSchemaMapForPrefix(@NonNull String prefix) {
+    public @NonNull Map<String, SchemaTypeConfigProto> getSchemaMapForPrefix(
+            @NonNull String prefix) {
         Objects.requireNonNull(prefix);
 
         Map<String, SchemaTypeConfigProto> schemaMap = mSchemaMap.get(prefix);
@@ -89,8 +90,7 @@ public class SchemaCache {
     }
 
     /** Returns a set of all prefixes stored in the cache. */
-    @NonNull
-    public Set<String> getAllPrefixes() {
+    public @NonNull Set<String> getAllPrefixes() {
         return Collections.unmodifiableSet(mSchemaMap.keySet());
     }
 
@@ -99,8 +99,7 @@ public class SchemaCache {
      *
      * <p>This method is inefficient to call repeatedly.
      */
-    @NonNull
-    public List<String> getAllPrefixedSchemaTypes() {
+    public @NonNull List<String> getAllPrefixedSchemaTypes() {
         List<String> cachedPrefixedSchemaTypes = new ArrayList<>();
         for (Map<String, SchemaTypeConfigProto> value : mSchemaMap.values()) {
             cachedPrefixedSchemaTypes.addAll(value.keySet());
@@ -112,8 +111,7 @@ public class SchemaCache {
      * Returns the schema types for the given set of prefixed schema types with their descendants,
      * based on the schema parent-to-children map held in the cache.
      */
-    @NonNull
-    public Set<String> getSchemaTypesWithDescendants(
+    public @NonNull Set<String> getSchemaTypesWithDescendants(
             @NonNull String prefix, @NonNull Set<String> prefixedSchemaTypes) {
         Objects.requireNonNull(prefix);
         Objects.requireNonNull(prefixedSchemaTypes);
@@ -146,8 +144,7 @@ public class SchemaCache {
      * prefixed schema type, based on the schema child-to-parents map held in the cache. It's
      * guaranteed that child types always appear before parent types in the list.
      */
-    @NonNull
-    public List<String> getTransitiveUnprefixedParentSchemaTypes(
+    public @NonNull List<String> getTransitiveUnprefixedParentSchemaTypes(
             @NonNull String prefix, @NonNull String prefixedSchemaType) throws AppSearchException {
         Objects.requireNonNull(prefix);
         Objects.requireNonNull(prefixedSchemaType);
@@ -284,8 +281,7 @@ public class SchemaCache {
      * Removes the entry of the given prefix from the schema map, the schema parent-to-children map
      * and the child-to-parents map, and returns the set of removed prefixed schema type.
      */
-    @NonNull
-    public Set<String> removePrefix(@NonNull String prefix) {
+    public @NonNull Set<String> removePrefix(@NonNull String prefix) {
         Objects.requireNonNull(prefix);
 
         Map<String, SchemaTypeConfigProto> removedSchemas =
@@ -307,8 +303,7 @@ public class SchemaCache {
      *
      * <p>It's guaranteed that child types always appear before parent types in the list.
      */
-    @NonNull
-    private List<String> calculateTransitiveUnprefixedParentSchemaTypes(
+    private @NonNull List<String> calculateTransitiveUnprefixedParentSchemaTypes(
             @NonNull String prefixedSchemaType,
             @NonNull Map<String, SchemaTypeConfigProto> prefixedSchemaMap)
             throws AppSearchException {
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverter.java
index bbd3bb29..e3f3d8ff 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverter.java
@@ -16,7 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.converter;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.exceptions.AppSearchException;
 
@@ -25,6 +24,8 @@ import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 import com.google.android.icing.proto.PropertyProto;
 import com.google.protobuf.ByteString;
 
+import org.jspecify.annotations.NonNull;
+
 /**
  * Translates a {@link android.app.blob.BlobHandle} into {@link PropertyProto.BlobHandleProto}.
  *
@@ -34,8 +35,7 @@ public final class BlobHandleToProtoConverter {
     private BlobHandleToProtoConverter() {}
 
     /** Converters a {@link AppSearchBlobHandle} into {@link PropertyProto.BlobHandleProto}. */
-    @NonNull
-    public static PropertyProto.BlobHandleProto toBlobHandleProto(
+    public static PropertyProto.@NonNull BlobHandleProto toBlobHandleProto(
             @NonNull AppSearchBlobHandle blobHandle) {
         return PropertyProto.BlobHandleProto.newBuilder()
                 .setNamespace(
@@ -47,9 +47,8 @@ public final class BlobHandleToProtoConverter {
     }
 
     /** Converters a {@link PropertyProto.BlobHandleProto} into {@link AppSearchBlobHandle}. */
-    @NonNull
-    public static AppSearchBlobHandle toAppSearchBlobHandle(
-            @NonNull PropertyProto.BlobHandleProto proto) throws AppSearchException {
+    public static @NonNull AppSearchBlobHandle toAppSearchBlobHandle(
+            PropertyProto.@NonNull BlobHandleProto proto) throws AppSearchException {
         String prefix = PrefixUtil.getPrefix(proto.getNamespace());
         return AppSearchBlobHandle.createWithSha256(
                 proto.getDigest().toByteArray(),
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverter.java
index 518008d4..6f9b45a6 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverter.java
@@ -16,7 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.converter;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.EmbeddingVector;
@@ -33,6 +32,8 @@ import com.google.android.icing.proto.PropertyProto;
 import com.google.android.icing.proto.SchemaTypeConfigProto;
 import com.google.protobuf.ByteString;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -56,9 +57,8 @@ public final class GenericDocumentToProtoConverter {
     private GenericDocumentToProtoConverter() {}
 
     /** Converts a {@link GenericDocument} into a {@link DocumentProto}. */
-    @NonNull
     @SuppressWarnings("unchecked")
-    public static DocumentProto toDocumentProto(@NonNull GenericDocument document) {
+    public static @NonNull DocumentProto toDocumentProto(@NonNull GenericDocument document) {
         Objects.requireNonNull(document);
         DocumentProto.Builder mProtoBuilder = DocumentProto.newBuilder();
         mProtoBuilder
@@ -143,9 +143,8 @@ public final class GenericDocumentToProtoConverter {
      * @param prefix the package + database prefix used searching the {@code schemaTypeMap}.
      * @param schemaCache The SchemaCache instance held in AppSearch.
      */
-    @NonNull
     @SuppressWarnings("deprecation")
-    public static GenericDocument toGenericDocument(
+    public static @NonNull GenericDocument toGenericDocument(
             @NonNull DocumentProtoOrBuilder proto,
             @NonNull String prefix,
             @NonNull SchemaCache schemaCache,
@@ -247,9 +246,8 @@ public final class GenericDocumentToProtoConverter {
     }
 
     /** Converts a {@link PropertyProto.VectorProto} into an {@link EmbeddingVector}. */
-    @NonNull
-    public static EmbeddingVector vectorProtoToEmbeddingVector(
-            @NonNull PropertyProto.VectorProto vectorProto) {
+    public static @NonNull EmbeddingVector vectorProtoToEmbeddingVector(
+            PropertyProto.@NonNull VectorProto vectorProto) {
         Objects.requireNonNull(vectorProto);
 
         float[] values = new float[vectorProto.getValuesCount()];
@@ -260,8 +258,7 @@ public final class GenericDocumentToProtoConverter {
     }
 
     /** Converts an {@link EmbeddingVector} into a {@link PropertyProto.VectorProto}. */
-    @NonNull
-    public static PropertyProto.VectorProto embeddingVectorToVectorProto(
+    public static PropertyProto.@NonNull VectorProto embeddingVectorToVectorProto(
             @NonNull EmbeddingVector embedding) {
         Objects.requireNonNull(embedding);
 
@@ -275,7 +272,7 @@ public final class GenericDocumentToProtoConverter {
 
     private static void setEmptyProperty(
             @NonNull String propertyName,
-            @NonNull GenericDocument.Builder<?> documentBuilder,
+            GenericDocument.@NonNull Builder<?> documentBuilder,
             @NonNull SchemaTypeConfigProto schema) {
         @AppSearchSchema.PropertyConfig.DataType int dataType = 0;
         for (int i = 0; i < schema.getPropertiesCount(); ++i) {
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/ResultCodeToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/ResultCodeToProtoConverter.java
index ca1c09ad..91d2e5e5 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/ResultCodeToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/ResultCodeToProtoConverter.java
@@ -16,12 +16,13 @@
 
 package com.android.server.appsearch.external.localstorage.converter;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.util.Log;
 
 import com.google.android.icing.proto.StatusProto;
 
+import org.jspecify.annotations.NonNull;
+
 /**
  * Translates an {@link StatusProto.Code} into a {@link AppSearchResult.ResultCode}
  *
@@ -35,7 +36,7 @@ public final class ResultCodeToProtoConverter {
 
     /** Converts an {@link StatusProto.Code} into a {@link AppSearchResult.ResultCode}. */
     @AppSearchResult.ResultCode
-    public static int toResultCode(@NonNull StatusProto.Code statusCode) {
+    public static int toResultCode(StatusProto.@NonNull Code statusCode) {
         switch (statusCode) {
             case OK:
                 return AppSearchResult.RESULT_OK;
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverter.java
index 566d734e..883b4c63 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverter.java
@@ -16,7 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.converter;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchSchema;
 import android.util.Log;
 
@@ -30,6 +29,8 @@ import com.google.android.icing.proto.SchemaTypeConfigProtoOrBuilder;
 import com.google.android.icing.proto.StringIndexingConfig;
 import com.google.android.icing.proto.TermMatchType;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.List;
 import java.util.Objects;
 
@@ -48,8 +49,8 @@ public final class SchemaToProtoConverter {
      * SchemaTypeConfigProto}.
      */
     // TODO(b/284356266): Consider handling addition of schema name prefixes in this function.
-    @NonNull
-    public static SchemaTypeConfigProto toSchemaTypeConfigProto(
+
+    public static @NonNull SchemaTypeConfigProto toSchemaTypeConfigProto(
             @NonNull AppSearchSchema schema, int version) {
         Objects.requireNonNull(schema);
         SchemaTypeConfigProto.Builder protoBuilder =
@@ -66,9 +67,8 @@ public final class SchemaToProtoConverter {
         return protoBuilder.build();
     }
 
-    @NonNull
-    private static PropertyConfigProto toPropertyConfigProto(
-            @NonNull AppSearchSchema.PropertyConfig property) {
+    private static @NonNull PropertyConfigProto toPropertyConfigProto(
+            AppSearchSchema.@NonNull PropertyConfig property) {
         Objects.requireNonNull(property);
         PropertyConfigProto.Builder builder =
                 PropertyConfigProto.newBuilder()
@@ -182,8 +182,9 @@ public final class SchemaToProtoConverter {
      * android.app.appsearch.AppSearchSchema}.
      */
     // TODO(b/284356266): Consider handling removal of schema name prefixes in this function.
-    @NonNull
-    public static AppSearchSchema toAppSearchSchema(@NonNull SchemaTypeConfigProtoOrBuilder proto) {
+
+    public static @NonNull AppSearchSchema toAppSearchSchema(
+            @NonNull SchemaTypeConfigProtoOrBuilder proto) {
         Objects.requireNonNull(proto);
         AppSearchSchema.Builder builder = new AppSearchSchema.Builder(proto.getSchemaType());
         builder.setDescription(proto.getDescription());
@@ -199,8 +200,7 @@ public final class SchemaToProtoConverter {
         return builder.build();
     }
 
-    @NonNull
-    private static AppSearchSchema.PropertyConfig toPropertyConfig(
+    private static AppSearchSchema.@NonNull PropertyConfig toPropertyConfig(
             @NonNull PropertyConfigProto proto) {
         Objects.requireNonNull(proto);
         switch (proto.getDataType()) {
@@ -244,8 +244,7 @@ public final class SchemaToProtoConverter {
         }
     }
 
-    @NonNull
-    private static AppSearchSchema.StringPropertyConfig toStringPropertyConfig(
+    private static AppSearchSchema.@NonNull StringPropertyConfig toStringPropertyConfig(
             @NonNull PropertyConfigProto proto) {
         AppSearchSchema.StringPropertyConfig.Builder builder =
                 new AppSearchSchema.StringPropertyConfig.Builder(proto.getPropertyName())
@@ -267,8 +266,7 @@ public final class SchemaToProtoConverter {
         return builder.build();
     }
 
-    @NonNull
-    private static AppSearchSchema.DocumentPropertyConfig toDocumentPropertyConfig(
+    private static AppSearchSchema.@NonNull DocumentPropertyConfig toDocumentPropertyConfig(
             @NonNull PropertyConfigProto proto) {
         AppSearchSchema.DocumentPropertyConfig.Builder builder =
                 new AppSearchSchema.DocumentPropertyConfig.Builder(
@@ -282,8 +280,7 @@ public final class SchemaToProtoConverter {
         return builder.build();
     }
 
-    @NonNull
-    private static AppSearchSchema.LongPropertyConfig toLongPropertyConfig(
+    private static AppSearchSchema.@NonNull LongPropertyConfig toLongPropertyConfig(
             @NonNull PropertyConfigProto proto) {
         AppSearchSchema.LongPropertyConfig.Builder builder =
                 new AppSearchSchema.LongPropertyConfig.Builder(proto.getPropertyName())
@@ -300,8 +297,7 @@ public final class SchemaToProtoConverter {
         return builder.build();
     }
 
-    @NonNull
-    private static AppSearchSchema.EmbeddingPropertyConfig toEmbeddingPropertyConfig(
+    private static AppSearchSchema.@NonNull EmbeddingPropertyConfig toEmbeddingPropertyConfig(
             @NonNull PropertyConfigProto proto) {
         AppSearchSchema.EmbeddingPropertyConfig.Builder builder =
                 new AppSearchSchema.EmbeddingPropertyConfig.Builder(proto.getPropertyName())
@@ -324,8 +320,7 @@ public final class SchemaToProtoConverter {
         return builder.build();
     }
 
-    @NonNull
-    private static JoinableConfig.ValueType.Code convertJoinableValueTypeToProto(
+    private static JoinableConfig.ValueType.@NonNull Code convertJoinableValueTypeToProto(
             @AppSearchSchema.StringPropertyConfig.JoinableValueType int joinableValueType) {
         switch (joinableValueType) {
             case AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_NONE:
@@ -340,7 +335,7 @@ public final class SchemaToProtoConverter {
 
     @AppSearchSchema.StringPropertyConfig.JoinableValueType
     private static int convertJoinableValueTypeFromProto(
-            @NonNull JoinableConfig.ValueType.Code joinableValueType) {
+            JoinableConfig.ValueType.@NonNull Code joinableValueType) {
         switch (joinableValueType) {
             case NONE:
                 return AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_NONE;
@@ -353,9 +348,10 @@ public final class SchemaToProtoConverter {
         return AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_NONE;
     }
 
-    @NonNull
-    private static JoinableConfig.DeletePropagationType.Code convertDeletePropagationTypeToProto(
-            @AppSearchSchema.StringPropertyConfig.DeletePropagationType int deletePropagationType) {
+    private static JoinableConfig.DeletePropagationType.@NonNull Code
+            convertDeletePropagationTypeToProto(
+                    @AppSearchSchema.StringPropertyConfig.DeletePropagationType
+                            int deletePropagationType) {
         switch (deletePropagationType) {
             case AppSearchSchema.StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE:
                 return JoinableConfig.DeletePropagationType.Code.NONE;
@@ -369,7 +365,7 @@ public final class SchemaToProtoConverter {
 
     @AppSearchSchema.StringPropertyConfig.DeletePropagationType
     private static int convertDeletePropagationTypeFromProto(
-            @NonNull JoinableConfig.DeletePropagationType.Code deletePropagationType) {
+            JoinableConfig.DeletePropagationType.@NonNull Code deletePropagationType) {
         switch (deletePropagationType) {
             case NONE:
                 return AppSearchSchema.StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE;
@@ -382,8 +378,7 @@ public final class SchemaToProtoConverter {
         return AppSearchSchema.StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE;
     }
 
-    @NonNull
-    private static TermMatchType.Code convertTermMatchTypeToProto(
+    private static TermMatchType.@NonNull Code convertTermMatchTypeToProto(
             @AppSearchSchema.StringPropertyConfig.IndexingType int indexingType) {
         switch (indexingType) {
             case AppSearchSchema.StringPropertyConfig.INDEXING_TYPE_NONE:
@@ -398,7 +393,7 @@ public final class SchemaToProtoConverter {
     }
 
     @AppSearchSchema.StringPropertyConfig.IndexingType
-    private static int convertTermMatchTypeFromProto(@NonNull TermMatchType.Code termMatchType) {
+    private static int convertTermMatchTypeFromProto(TermMatchType.@NonNull Code termMatchType) {
         switch (termMatchType) {
             case UNKNOWN:
                 return AppSearchSchema.StringPropertyConfig.INDEXING_TYPE_NONE;
@@ -414,8 +409,7 @@ public final class SchemaToProtoConverter {
         }
     }
 
-    @NonNull
-    private static StringIndexingConfig.TokenizerType.Code convertTokenizerTypeToProto(
+    private static StringIndexingConfig.TokenizerType.@NonNull Code convertTokenizerTypeToProto(
             @AppSearchSchema.StringPropertyConfig.TokenizerType int tokenizerType) {
         StringIndexingConfig.TokenizerType.Code tokenizerTypeProto =
                 StringIndexingConfig.TokenizerType.Code.forNumber(tokenizerType);
@@ -425,9 +419,9 @@ public final class SchemaToProtoConverter {
         return tokenizerTypeProto;
     }
 
-    @NonNull
-    private static IntegerIndexingConfig.NumericMatchType.Code convertNumericMatchTypeToProto(
-            @AppSearchSchema.LongPropertyConfig.IndexingType int indexingType) {
+    private static IntegerIndexingConfig.NumericMatchType.@NonNull Code
+            convertNumericMatchTypeToProto(
+                    @AppSearchSchema.LongPropertyConfig.IndexingType int indexingType) {
         switch (indexingType) {
             case AppSearchSchema.LongPropertyConfig.INDEXING_TYPE_NONE:
                 return IntegerIndexingConfig.NumericMatchType.Code.UNKNOWN;
@@ -440,7 +434,7 @@ public final class SchemaToProtoConverter {
 
     @AppSearchSchema.LongPropertyConfig.IndexingType
     private static int convertNumericMatchTypeFromProto(
-            @NonNull IntegerIndexingConfig.NumericMatchType.Code numericMatchType) {
+            IntegerIndexingConfig.NumericMatchType.@NonNull Code numericMatchType) {
         switch (numericMatchType) {
             case UNKNOWN:
                 return AppSearchSchema.LongPropertyConfig.INDEXING_TYPE_NONE;
@@ -454,8 +448,7 @@ public final class SchemaToProtoConverter {
         }
     }
 
-    @NonNull
-    private static EmbeddingIndexingConfig.EmbeddingIndexingType.Code
+    private static EmbeddingIndexingConfig.EmbeddingIndexingType.@NonNull Code
             convertEmbeddingIndexingTypeToProto(
                     @AppSearchSchema.EmbeddingPropertyConfig.IndexingType int indexingType) {
         switch (indexingType) {
@@ -470,7 +463,7 @@ public final class SchemaToProtoConverter {
 
     @AppSearchSchema.EmbeddingPropertyConfig.IndexingType
     private static int convertEmbeddingIndexingTypeFromProto(
-            @NonNull EmbeddingIndexingConfig.EmbeddingIndexingType.Code indexingType) {
+            EmbeddingIndexingConfig.EmbeddingIndexingType.@NonNull Code indexingType) {
         switch (indexingType) {
             case UNKNOWN:
                 return AppSearchSchema.EmbeddingPropertyConfig.INDEXING_TYPE_NONE;
@@ -484,8 +477,7 @@ public final class SchemaToProtoConverter {
         }
     }
 
-    @NonNull
-    private static EmbeddingIndexingConfig.QuantizationType.Code
+    private static EmbeddingIndexingConfig.QuantizationType.@NonNull Code
             convertEmbeddingQuantizationTypeToProto(
                     @AppSearchSchema.EmbeddingPropertyConfig.QuantizationType
                             int quantizationType) {
@@ -501,7 +493,7 @@ public final class SchemaToProtoConverter {
 
     @AppSearchSchema.EmbeddingPropertyConfig.QuantizationType
     private static int convertEmbeddingQuantizationTypeTypeFromProto(
-            @NonNull EmbeddingIndexingConfig.QuantizationType.Code quantizationType) {
+            EmbeddingIndexingConfig.QuantizationType.@NonNull Code quantizationType) {
         switch (quantizationType) {
             case NONE:
                 return AppSearchSchema.EmbeddingPropertyConfig.QUANTIZATION_TYPE_NONE;
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverter.java
index e15b5955..f182a523 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverter.java
@@ -20,7 +20,6 @@ import static com.android.server.appsearch.external.localstorage.util.PrefixUtil
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.getPackageName;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.removePrefixesFromDocument;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.SearchResult;
@@ -34,11 +33,14 @@ import com.android.server.appsearch.external.localstorage.SchemaCache;
 
 import com.google.android.icing.proto.DocumentProto;
 import com.google.android.icing.proto.DocumentProtoOrBuilder;
+import com.google.android.icing.proto.EmbeddingMatchSnippetProto;
 import com.google.android.icing.proto.PropertyProto;
 import com.google.android.icing.proto.SearchResultProto;
 import com.google.android.icing.proto.SnippetMatchProto;
 import com.google.android.icing.proto.SnippetProto;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -58,8 +60,7 @@ public class SearchResultToProtoConverter {
      * @param schemaCache The SchemaCache instance held in AppSearch.
      * @return {@link SearchResultPage} of results.
      */
-    @NonNull
-    public static SearchResultPage toSearchResultPage(
+    public static @NonNull SearchResultPage toSearchResultPage(
             @NonNull SearchResultProto proto,
             @NonNull SchemaCache schemaCache,
             @NonNull AppSearchConfig config)
@@ -81,9 +82,8 @@ public class SearchResultToProtoConverter {
      * @param schemaCache The SchemaCache instance held in AppSearch.
      * @return A {@link SearchResult}.
      */
-    @NonNull
-    private static SearchResult toUnprefixedSearchResult(
-            @NonNull SearchResultProto.ResultProto proto,
+    private static @NonNull SearchResult toUnprefixedSearchResult(
+            SearchResultProto.@NonNull ResultProto proto,
             @NonNull SchemaCache schemaCache,
             @NonNull AppSearchConfig config)
             throws AppSearchException {
@@ -105,9 +105,18 @@ public class SearchResultToProtoConverter {
                 SnippetProto.EntryProto entry = proto.getSnippet().getEntries(i);
                 for (int j = 0; j < entry.getSnippetMatchesCount(); j++) {
                     SearchResult.MatchInfo matchInfo =
-                            toMatchInfo(entry.getSnippetMatches(j), entry.getPropertyName());
+                            toMatchInfoWithTextMatch(
+                                    entry.getSnippetMatches(j), entry.getPropertyName());
                     builder.addMatchInfo(matchInfo);
                 }
+                if (Flags.enableEmbeddingMatchInfo()) {
+                    for (int j = 0; j < entry.getEmbeddingMatchesCount(); j++) {
+                        SearchResult.MatchInfo matchInfo =
+                                toMatchInfoWithEmbeddingMatch(
+                                        entry.getEmbeddingMatches(j), entry.getPropertyName());
+                        builder.addMatchInfo(matchInfo);
+                    }
+                }
             }
         }
         for (int i = 0; i < proto.getJoinedResultsCount(); i++) {
@@ -154,7 +163,7 @@ public class SearchResultToProtoConverter {
         }
     }
 
-    private static SearchResult.MatchInfo toMatchInfo(
+    private static SearchResult.MatchInfo toMatchInfoWithTextMatch(
             @NonNull SnippetMatchProto snippetMatchProto, @NonNull String propertyPath) {
         int exactMatchPosition = snippetMatchProto.getExactMatchUtf16Position();
         return new SearchResult.MatchInfo.Builder(propertyPath)
@@ -173,4 +182,20 @@ public class SearchResultToProtoConverter {
                                         + snippetMatchProto.getWindowUtf16Length()))
                 .build();
     }
+
+    /**
+     * Returns a MatchInfo for an embedding match. Requires Flags.enableEmbeddingMatchInfo() = true.
+     */
+    private static SearchResult.MatchInfo toMatchInfoWithEmbeddingMatch(
+            @NonNull EmbeddingMatchSnippetProto embeddingMatchSnippetProto,
+            @NonNull String propertyPath) {
+        SearchResult.EmbeddingMatchInfo embeddingMatch =
+                new SearchResult.EmbeddingMatchInfo(
+                        embeddingMatchSnippetProto.getSemanticScore(),
+                        embeddingMatchSnippetProto.getEmbeddingQueryVectorIndex(),
+                        embeddingMatchSnippetProto.getEmbeddingQueryMetricType().getNumber());
+        return new SearchResult.MatchInfo.Builder(propertyPath)
+                .setEmbeddingMatch(embeddingMatch)
+                .build();
+    }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java
index a30d31fa..99cb9c8c 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java
@@ -21,8 +21,6 @@ import static com.android.server.appsearch.external.localstorage.util.PrefixUtil
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.getPrefix;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.removePrefix;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.EmbeddingVector;
 import android.app.appsearch.FeatureConstants;
 import android.app.appsearch.JoinSpec;
@@ -54,6 +52,9 @@ import com.google.android.icing.proto.TermMatchType;
 import com.google.android.icing.proto.TypePropertyMask;
 import com.google.android.icing.proto.TypePropertyWeights;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -105,7 +106,7 @@ public final class SearchSpecToProtoConverter {
      * The nested converter, which contains SearchSpec, ResultSpec, and ScoringSpec information
      * about the nested query. This will remain null if there is no nested {@link JoinSpec}.
      */
-    @Nullable private SearchSpecToProtoConverter mNestedConverter = null;
+    private @Nullable SearchSpecToProtoConverter mNestedConverter = null;
 
     /**
      * Creates a {@link SearchSpecToProtoConverter} for given {@link SearchSpec}.
@@ -277,8 +278,7 @@ public final class SearchSpecToProtoConverter {
     }
 
     /** Extracts {@link SearchSpecProto} information from a {@link SearchSpec}. */
-    @NonNull
-    public SearchSpecProto toSearchSpecProto() {
+    public @NonNull SearchSpecProto toSearchSpecProto() {
         // set query to SearchSpecProto and override schema and namespace filter by
         // targetPrefixedFilters which contains all existing and also accessible to the caller
         // filters.
@@ -400,9 +400,9 @@ public final class SearchSpecToProtoConverter {
      *
      * @param aggregationScoringStrategy the scoring strategy to convert.
      */
-    @NonNull
-    public static JoinSpecProto.AggregationScoringStrategy.Code toAggregationScoringStrategy(
-            @JoinSpec.AggregationScoringStrategy int aggregationScoringStrategy) {
+    public static JoinSpecProto.AggregationScoringStrategy.@NonNull Code
+            toAggregationScoringStrategy(
+                    @JoinSpec.AggregationScoringStrategy int aggregationScoringStrategy) {
         switch (aggregationScoringStrategy) {
             case JoinSpec.AGGREGATION_SCORING_AVG_RANKING_SIGNAL:
                 return JoinSpecProto.AggregationScoringStrategy.Code.AVG;
@@ -425,8 +425,7 @@ public final class SearchSpecToProtoConverter {
      * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param schemaCache The SchemaCache instance held in AppSearch.
      */
-    @NonNull
-    public ResultSpecProto toResultSpecProto(
+    public @NonNull ResultSpecProto toResultSpecProto(
             @NonNull NamespaceCache namespaceCache, @NonNull SchemaCache schemaCache) {
         ResultSpecProto.Builder resultSpecBuilder =
                 ResultSpecProto.newBuilder()
@@ -436,7 +435,9 @@ public final class SearchSpecToProtoConverter {
                                         .setNumToSnippet(mSearchSpec.getSnippetCount())
                                         .setNumMatchesPerProperty(
                                                 mSearchSpec.getSnippetCountPerProperty())
-                                        .setMaxWindowUtf32Length(mSearchSpec.getMaxSnippetSize()))
+                                        .setMaxWindowUtf32Length(mSearchSpec.getMaxSnippetSize())
+                                        .setGetEmbeddingMatchInfo(
+                                                mSearchSpec.shouldRetrieveEmbeddingMatchInfos()))
                         .setNumTotalBytesPerPageThreshold(
                                 mIcingOptionsConfig.getMaxPageBytesLimit());
         JoinSpec joinSpec = mSearchSpec.getJoinSpec();
@@ -542,8 +543,7 @@ public final class SearchSpecToProtoConverter {
     }
 
     /** Extracts {@link ScoringSpecProto} information from a {@link SearchSpec}. */
-    @NonNull
-    public ScoringSpecProto toScoringSpecProto() {
+    public @NonNull ScoringSpecProto toScoringSpecProto() {
         ScoringSpecProto.Builder protoBuilder = ScoringSpecProto.newBuilder();
 
         @SearchSpec.Order int orderCode = mSearchSpec.getOrder();
@@ -616,8 +616,8 @@ public final class SearchSpecToProtoConverter {
      *
      * @param appSearchFeatures The list of AppSearch search feature strings.
      */
-    @NonNull
-    private static List<String> toIcingSearchFeatures(@NonNull List<String> appSearchFeatures) {
+    private static @NonNull List<String> toIcingSearchFeatures(
+            @NonNull List<String> appSearchFeatures) {
         List<String> result = new ArrayList<>();
         for (int i = 0; i < appSearchFeatures.size(); i++) {
             String appSearchFeature = appSearchFeatures.get(i);
@@ -828,7 +828,7 @@ public final class SearchSpecToProtoConverter {
             @NonNull Set<String> prefixes,
             int maxNumResults,
             @NonNull NamespaceCache namespaceCache,
-            @NonNull ResultSpecProto.Builder resultSpecBuilder) {
+            ResultSpecProto.@NonNull Builder resultSpecBuilder) {
         Map<String, List<String>> packageAndNamespaceToNamespaces =
                 getPackageAndNamespaceToPrefixedNamespaces(prefixes, namespaceCache);
 
@@ -860,7 +860,7 @@ public final class SearchSpecToProtoConverter {
             @NonNull Set<String> prefixes,
             int maxNumResults,
             @NonNull SchemaCache schemaCache,
-            @NonNull ResultSpecProto.Builder resultSpecBuilder) {
+            ResultSpecProto.@NonNull Builder resultSpecBuilder) {
         Map<String, List<String>> packageAndSchemaToSchemas =
                 getPackageAndSchemaToPrefixedSchemas(prefixes, schemaCache);
 
@@ -894,7 +894,7 @@ public final class SearchSpecToProtoConverter {
             int maxNumResults,
             @NonNull NamespaceCache namespaceCache,
             @NonNull SchemaCache schemaCache,
-            @NonNull ResultSpecProto.Builder resultSpecBuilder) {
+            ResultSpecProto.@NonNull Builder resultSpecBuilder) {
         Map<String, List<String>> packageAndNamespaceToNamespaces =
                 getPackageAndNamespaceToPrefixedNamespaces(prefixes, namespaceCache);
         Map<String, List<String>> packageAndSchemaToSchemas =
@@ -941,7 +941,7 @@ public final class SearchSpecToProtoConverter {
             @NonNull Set<String> prefixes,
             int maxNumResults,
             @NonNull NamespaceCache namespaceCache,
-            @NonNull ResultSpecProto.Builder resultSpecBuilder) {
+            ResultSpecProto.@NonNull Builder resultSpecBuilder) {
         // Build up a map of package to namespaces.
         Map<String, List<String>> packageToNamespacesMap = new ArrayMap<>();
         for (String prefix : prefixes) {
@@ -986,7 +986,7 @@ public final class SearchSpecToProtoConverter {
             @NonNull Set<String> prefixes,
             int maxNumResults,
             @NonNull NamespaceCache namespaceCache,
-            @NonNull ResultSpecProto.Builder resultSpecBuilder) {
+            ResultSpecProto.@NonNull Builder resultSpecBuilder) {
         Map<String, List<String>> namespaceToPrefixedNamespaces =
                 getNamespaceToPrefixedNamespaces(prefixes, namespaceCache);
 
@@ -1018,7 +1018,7 @@ public final class SearchSpecToProtoConverter {
             @NonNull Set<String> prefixes,
             int maxNumResults,
             @NonNull SchemaCache schemaCache,
-            @NonNull ResultSpecProto.Builder resultSpecBuilder) {
+            ResultSpecProto.@NonNull Builder resultSpecBuilder) {
         Map<String, List<String>> schemaToPrefixedSchemas =
                 getSchemaToPrefixedSchemas(prefixes, schemaCache);
 
@@ -1052,7 +1052,7 @@ public final class SearchSpecToProtoConverter {
             int maxNumResults,
             @NonNull NamespaceCache namespaceCache,
             @NonNull SchemaCache schemaCache,
-            @NonNull ResultSpecProto.Builder resultSpecBuilder) {
+            ResultSpecProto.@NonNull Builder resultSpecBuilder) {
         Map<String, List<String>> namespaceToPrefixedNamespaces =
                 getNamespaceToPrefixedNamespaces(prefixes, namespaceCache);
         Map<String, List<String>> schemaToPrefixedSchemas =
@@ -1110,7 +1110,7 @@ public final class SearchSpecToProtoConverter {
      */
     private void addTypePropertyWeights(
             @NonNull Map<String, Map<String, Double>> typePropertyWeightsMap,
-            @NonNull ScoringSpecProto.Builder scoringSpecBuilder) {
+            ScoringSpecProto.@NonNull Builder scoringSpecBuilder) {
         Objects.requireNonNull(scoringSpecBuilder);
         Objects.requireNonNull(typePropertyWeightsMap);
 
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterUtil.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterUtil.java
index f9be7b88..5c4a5d9e 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterUtil.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterUtil.java
@@ -16,7 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.converter;
 
-import android.annotation.NonNull;
 import android.util.ArraySet;
 
 import com.android.server.appsearch.external.localstorage.NamespaceCache;
@@ -24,6 +23,8 @@ import com.android.server.appsearch.external.localstorage.SchemaCache;
 
 import com.google.android.icing.proto.SchemaTypeConfigProto;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverter.java
index 84892db5..6df16f89 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverter.java
@@ -16,7 +16,7 @@
 
 package com.android.server.appsearch.external.localstorage.converter;
 
-import android.annotation.NonNull;
+import android.app.appsearch.FeatureConstants;
 import android.app.appsearch.SearchSuggestionSpec;
 
 import com.android.server.appsearch.external.localstorage.NamespaceCache;
@@ -28,6 +28,8 @@ import com.google.android.icing.proto.SuggestionSpecProto;
 import com.google.android.icing.proto.TermMatchType;
 import com.google.android.icing.proto.TypePropertyMask;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -96,8 +98,7 @@ public final class SearchSuggestionSpecToProtoConverter {
     }
 
     /** Extracts {@link SuggestionSpecProto} information from a {@link SearchSuggestionSpec}. */
-    @NonNull
-    public SuggestionSpecProto toSearchSuggestionSpecProto() {
+    public @NonNull SuggestionSpecProto toSearchSuggestionSpecProto() {
         // Set query suggestion prefix to the SearchSuggestionProto and override schema and
         // namespace filter by targetPrefixedFilters which contains all existing and also
         // accessible to the caller filters.
@@ -106,9 +107,21 @@ public final class SearchSuggestionSpecToProtoConverter {
                         .setPrefix(mSuggestionQueryExpression)
                         .addAllNamespaceFilters(mTargetPrefixedNamespaceFilters)
                         .addAllSchemaTypeFilters(mTargetPrefixedSchemaFilters)
-                        .setNumToReturn(mSearchSuggestionSpec.getMaximumResultCount())
-                        .addAllQueryParameterStrings(
-                                mSearchSuggestionSpec.getSearchStringParameters());
+                        .setNumToReturn(mSearchSuggestionSpec.getMaximumResultCount());
+
+        if (!mSearchSuggestionSpec.getSearchStringParameters().isEmpty()) {
+            protoBuilder.addAllQueryParameterStrings(
+                    mSearchSuggestionSpec.getSearchStringParameters());
+            // When the SearchSuggestions api first launched, it did not include the various "set
+            // feature enabled" apis that {@link SearchSpec} has.
+            //
+            // Search string parameters necessarily invokes the LIST_FILTER_QUERY_LANGUAGE feature
+            // because they are referenced in the query expression through a function call.
+            // To avoid errors about using un-enabled query features, we add it here. This is safe
+            // to do because search string parameters were added after the
+            // LIST_FILTER_QUERY_LANGUAGE.
+            protoBuilder.addEnabledFeatures(FeatureConstants.LIST_FILTER_QUERY_LANGUAGE);
+        }
 
         // Convert type property filter map into type property mask proto.
         for (Map.Entry<String, List<String>> entry :
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SetSchemaResponseToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SetSchemaResponseToProtoConverter.java
index ed73593f..dfe8058e 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SetSchemaResponseToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SetSchemaResponseToProtoConverter.java
@@ -16,11 +16,12 @@
 
 package com.android.server.appsearch.external.localstorage.converter;
 
-import android.annotation.NonNull;
 import android.app.appsearch.SetSchemaResponse;
 
 import com.google.android.icing.proto.SetSchemaResultProto;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Objects;
 
 /**
@@ -39,8 +40,7 @@ public class SetSchemaResponseToProtoConverter {
      * @param prefix The prefix need to removed from schemaTypes
      * @return The {@link SetSchemaResponse} object.
      */
-    @NonNull
-    public static SetSchemaResponse toSetSchemaResponse(
+    public static @NonNull SetSchemaResponse toSetSchemaResponse(
             @NonNull SetSchemaResultProto proto, @NonNull String prefix) {
         Objects.requireNonNull(proto);
         Objects.requireNonNull(prefix);
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/TypePropertyPathToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/TypePropertyPathToProtoConverter.java
index 5056d4b6..e7ff286c 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/TypePropertyPathToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/TypePropertyPathToProtoConverter.java
@@ -16,10 +16,10 @@
 
 package com.android.server.appsearch.external.localstorage.converter;
 
-import android.annotation.NonNull;
-
 import com.google.android.icing.proto.TypePropertyMask;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -34,8 +34,7 @@ public final class TypePropertyPathToProtoConverter {
     private TypePropertyPathToProtoConverter() {}
 
     /** Extracts {@link TypePropertyMask} information from a {@link Map}. */
-    @NonNull
-    public static List<TypePropertyMask.Builder> toTypePropertyMaskBuilderList(
+    public static @NonNull List<TypePropertyMask.Builder> toTypePropertyMaskBuilderList(
             @NonNull Map<String, List<String>> typePropertyPaths) {
         Objects.requireNonNull(typePropertyPaths);
         List<TypePropertyMask.Builder> typePropertyMaskBuilders =
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java
index c010d5ab..ec5a844f 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java
@@ -17,18 +17,19 @@
 package com.android.server.appsearch.external.localstorage.stats;
 
 import android.annotation.IntDef;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
 import android.util.ArraySet;
 
 import com.android.internal.annotations.VisibleForTesting;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
-import java.util.Objects;
 import java.util.Set;
 
 /**
@@ -43,7 +44,7 @@ import java.util.Set;
  *
  * @hide
  */
-public class CallStats {
+public class CallStats extends BaseStats {
     /** Call types. */
     @IntDef(
             value = {
@@ -166,8 +167,8 @@ public class CallStats {
     private static final String CALL_TYPE_STRING_REMOVE_BLOB = "removeBlob";
     private static final String CALL_TYPE_STRING_SET_BLOB_VISIBILITY = "setBlobVisibility";
 
-    @Nullable private final String mPackageName;
-    @Nullable private final String mDatabase;
+    private final @Nullable String mPackageName;
+    private final @Nullable String mDatabase;
 
     /**
      * The status code returned by {@link AppSearchResult#getResultCode()} for the call or internal
@@ -183,7 +184,7 @@ public class CallStats {
     private final int mNumOperationsFailed;
 
     CallStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mPackageName = builder.mPackageName;
         mDatabase = builder.mDatabase;
         mStatusCode = builder.mStatusCode;
@@ -195,14 +196,12 @@ public class CallStats {
     }
 
     /** Returns calling package name. */
-    @Nullable
-    public String getPackageName() {
+    public @Nullable String getPackageName() {
         return mPackageName;
     }
 
     /** Returns calling database name. */
-    @Nullable
-    public String getDatabase() {
+    public @Nullable String getDatabase() {
         return mDatabase;
     }
 
@@ -259,7 +258,7 @@ public class CallStats {
     }
 
     /** Builder for {@link CallStats}. */
-    public static class Builder {
+    public static class Builder extends BaseStats.Builder<CallStats.Builder> {
         @Nullable String mPackageName;
         @Nullable String mDatabase;
         @AppSearchResult.ResultCode int mStatusCode;
@@ -271,48 +270,42 @@ public class CallStats {
 
         /** Sets the PackageName used by the session. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setPackageName(@Nullable String packageName) {
+        public @NonNull Builder setPackageName(@Nullable String packageName) {
             mPackageName = packageName;
             return this;
         }
 
         /** Sets the database used by the session. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDatabase(@Nullable String database) {
+        public @NonNull Builder setDatabase(@Nullable String database) {
             mDatabase = database;
             return this;
         }
 
         /** Sets the status code. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
+        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
             mStatusCode = statusCode;
             return this;
         }
 
         /** Sets total latency in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalLatencyMillis(int totalLatencyMillis) {
+        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
             mTotalLatencyMillis = totalLatencyMillis;
             return this;
         }
 
         /** Sets type of the call. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setCallType(@CallType int callType) {
+        public @NonNull Builder setCallType(@CallType int callType) {
             mCallType = callType;
             return this;
         }
 
         /** Sets estimated binder latency, in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setEstimatedBinderLatencyMillis(int estimatedBinderLatencyMillis) {
+        public @NonNull Builder setEstimatedBinderLatencyMillis(int estimatedBinderLatencyMillis) {
             mEstimatedBinderLatencyMillis = estimatedBinderLatencyMillis;
             return this;
         }
@@ -329,8 +322,7 @@ public class CallStats {
          * CallStats#getNumOperationsFailed()} is always 1 since there is only one operation.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNumOperationsSucceeded(int numOperationsSucceeded) {
+        public @NonNull Builder setNumOperationsSucceeded(int numOperationsSucceeded) {
             mNumOperationsSucceeded = numOperationsSucceeded;
             return this;
         }
@@ -347,15 +339,14 @@ public class CallStats {
          * CallStats#getNumOperationsFailed()} is always 1 since there is only one operation.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNumOperationsFailed(int numOperationsFailed) {
+        public @NonNull Builder setNumOperationsFailed(int numOperationsFailed) {
             mNumOperationsFailed = numOperationsFailed;
             return this;
         }
 
         /** Creates {@link CallStats} object from {@link Builder} instance. */
-        @NonNull
-        public CallStats build() {
+        @Override
+        public @NonNull CallStats build() {
             return new CallStats(/* builder= */ this);
         }
     }
@@ -436,8 +427,7 @@ public class CallStats {
 
     /** Returns the set of all {@link CallStats.CallType} that map to an AppSearchManager API. */
     @VisibleForTesting
-    @NonNull
-    public static Set<Integer> getAllApiCallTypes() {
+    public static @NonNull Set<Integer> getAllApiCallTypes() {
         return new ArraySet<>(
                 Arrays.asList(
                         CALL_TYPE_INITIALIZE,
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/ClickStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/ClickStats.java
index e74a4e42..5e975d40 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/ClickStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/ClickStats.java
@@ -16,10 +16,10 @@
 
 package com.android.server.appsearch.external.localstorage.stats;
 
-import android.annotation.NonNull;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
 
-import java.util.Objects;
+import org.jspecify.annotations.NonNull;
 
 // TODO(b/319285816): link converter here.
 /**
@@ -28,7 +28,7 @@ import java.util.Objects;
  *
  * @hide
  */
-public class ClickStats {
+public class ClickStats extends BaseStats {
     private final long mTimestampMillis;
 
     private final long mTimeStayOnResultMillis;
@@ -40,7 +40,7 @@ public class ClickStats {
     private final boolean mIsGoodClick;
 
     ClickStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mTimestampMillis = builder.mTimestampMillis;
         mTimeStayOnResultMillis = builder.mTimeStayOnResultMillis;
         mResultRankInBlock = builder.mResultRankInBlock;
@@ -78,7 +78,7 @@ public class ClickStats {
     }
 
     /** Builder for {@link ClickStats} */
-    public static final class Builder {
+    public static final class Builder extends BaseStats.Builder<ClickStats.Builder> {
         private long mTimestampMillis;
 
         private long mTimeStayOnResultMillis;
@@ -91,32 +91,28 @@ public class ClickStats {
 
         /** Sets the click action timestamp in milliseconds since Unix epoch. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTimestampMillis(long timestampMillis) {
+        public @NonNull Builder setTimestampMillis(long timestampMillis) {
             mTimestampMillis = timestampMillis;
             return this;
         }
 
         /** Sets the time (duration) of the user staying on the clicked result. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTimeStayOnResultMillis(long timeStayOnResultMillis) {
+        public @NonNull Builder setTimeStayOnResultMillis(long timeStayOnResultMillis) {
             mTimeStayOnResultMillis = timeStayOnResultMillis;
             return this;
         }
 
         /** Sets the in-block rank of the clicked result. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setResultRankInBlock(int resultRankInBlock) {
+        public @NonNull Builder setResultRankInBlock(int resultRankInBlock) {
             mResultRankInBlock = resultRankInBlock;
             return this;
         }
 
         /** Sets the global rank of the clicked result. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setResultRankGlobal(int resultRankGlobal) {
+        public @NonNull Builder setResultRankGlobal(int resultRankGlobal) {
             mResultRankGlobal = resultRankGlobal;
             return this;
         }
@@ -139,15 +135,14 @@ public class ClickStats {
          * </ul>
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setIsGoodClick(boolean isGoodClick) {
+        public @NonNull Builder setIsGoodClick(boolean isGoodClick) {
             mIsGoodClick = isGoodClick;
             return this;
         }
 
         /** Builds a new {@link ClickStats} from the {@link ClickStats.Builder}. */
-        @NonNull
-        public ClickStats build() {
+        @Override
+        public @NonNull ClickStats build() {
             return new ClickStats(/* builder= */ this);
         }
     }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/InitializeStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/InitializeStats.java
index 2a75c914..5811f54d 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/InitializeStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/InitializeStats.java
@@ -17,20 +17,21 @@
 package com.android.server.appsearch.external.localstorage.stats;
 
 import android.annotation.IntDef;
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
+
+import org.jspecify.annotations.NonNull;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
-import java.util.Objects;
 
 /**
  * Class holds detailed stats for initialization
  *
  * @hide
  */
-public final class InitializeStats {
+public final class InitializeStats extends BaseStats {
     /**
      * The cause of IcingSearchEngine recovering from a previous bad state during initialization.
      */
@@ -247,7 +248,7 @@ public final class InitializeStats {
     }
 
     InitializeStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mStatusCode = builder.mStatusCode;
         mTotalLatencyMillis = builder.mTotalLatencyMillis;
         mHasDeSync = builder.mHasDeSync;
@@ -269,7 +270,7 @@ public final class InitializeStats {
     }
 
     /** Builder for {@link InitializeStats}. */
-    public static class Builder {
+    public static class Builder extends BaseStats.Builder<InitializeStats.Builder> {
         @AppSearchResult.ResultCode int mStatusCode;
 
         int mTotalLatencyMillis;
@@ -291,16 +292,14 @@ public final class InitializeStats {
 
         /** Sets the status of the initialization. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
+        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
             mStatusCode = statusCode;
             return this;
         }
 
         /** Sets the total latency of the initialization in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalLatencyMillis(int totalLatencyMillis) {
+        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
             mTotalLatencyMillis = totalLatencyMillis;
             return this;
         }
@@ -312,16 +311,14 @@ public final class InitializeStats {
          * view of what data should exist.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setHasDeSync(boolean hasDeSync) {
+        public @NonNull Builder setHasDeSync(boolean hasDeSync) {
             mHasDeSync = hasDeSync;
             return this;
         }
 
         /** Sets time used to read and process the schema and namespaces. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setPrepareSchemaAndNamespacesLatencyMillis(
+        public @NonNull Builder setPrepareSchemaAndNamespacesLatencyMillis(
                 int prepareSchemaAndNamespacesLatencyMillis) {
             mPrepareSchemaAndNamespacesLatencyMillis = prepareSchemaAndNamespacesLatencyMillis;
             return this;
@@ -329,8 +326,7 @@ public final class InitializeStats {
 
         /** Sets time used to read and process the visibility file. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setPrepareVisibilityStoreLatencyMillis(
+        public @NonNull Builder setPrepareVisibilityStoreLatencyMillis(
                 int prepareVisibilityStoreLatencyMillis) {
             mPrepareVisibilityStoreLatencyMillis = prepareVisibilityStoreLatencyMillis;
             return this;
@@ -338,8 +334,7 @@ public final class InitializeStats {
 
         /** Sets overall time used for the native function call. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeLatencyMillis(int nativeLatencyMillis) {
+        public @NonNull Builder setNativeLatencyMillis(int nativeLatencyMillis) {
             mNativeLatencyMillis = nativeLatencyMillis;
             return this;
         }
@@ -353,8 +348,7 @@ public final class InitializeStats {
          * <li>{@link InitializeStats#RECOVERY_CAUSE_IO_ERROR}
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDocumentStoreRecoveryCause(
+        public @NonNull Builder setDocumentStoreRecoveryCause(
                 @RecoveryCause int documentStoreRecoveryCause) {
             mNativeDocumentStoreRecoveryCause = documentStoreRecoveryCause;
             return this;
@@ -369,8 +363,7 @@ public final class InitializeStats {
          * <li>{@link InitializeStats#RECOVERY_CAUSE_IO_ERROR}
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setIndexRestorationCause(@RecoveryCause int indexRestorationCause) {
+        public @NonNull Builder setIndexRestorationCause(@RecoveryCause int indexRestorationCause) {
             mNativeIndexRestorationCause = indexRestorationCause;
             return this;
         }
@@ -382,16 +375,15 @@ public final class InitializeStats {
          * <li>{@link InitializeStats#RECOVERY_CAUSE_IO_ERROR}
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setSchemaStoreRecoveryCause(@RecoveryCause int schemaStoreRecoveryCause) {
+        public @NonNull Builder setSchemaStoreRecoveryCause(
+                @RecoveryCause int schemaStoreRecoveryCause) {
             mNativeSchemaStoreRecoveryCause = schemaStoreRecoveryCause;
             return this;
         }
 
         /** Sets time used to recover the document store. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDocumentStoreRecoveryLatencyMillis(
+        public @NonNull Builder setDocumentStoreRecoveryLatencyMillis(
                 int documentStoreRecoveryLatencyMillis) {
             mNativeDocumentStoreRecoveryLatencyMillis = documentStoreRecoveryLatencyMillis;
             return this;
@@ -399,16 +391,16 @@ public final class InitializeStats {
 
         /** Sets time used to restore the index. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setIndexRestorationLatencyMillis(int indexRestorationLatencyMillis) {
+        public @NonNull Builder setIndexRestorationLatencyMillis(
+                int indexRestorationLatencyMillis) {
             mNativeIndexRestorationLatencyMillis = indexRestorationLatencyMillis;
             return this;
         }
 
         /** Sets time used to recover the schema store. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setSchemaStoreRecoveryLatencyMillis(int schemaStoreRecoveryLatencyMillis) {
+        public @NonNull Builder setSchemaStoreRecoveryLatencyMillis(
+                int schemaStoreRecoveryLatencyMillis) {
             mNativeSchemaStoreRecoveryLatencyMillis = schemaStoreRecoveryLatencyMillis;
             return this;
         }
@@ -418,8 +410,7 @@ public final class InitializeStats {
          * external/icing/proto/icing/proto/logging.proto
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDocumentStoreDataStatus(
+        public @NonNull Builder setDocumentStoreDataStatus(
                 @DocumentStoreDataStatus int documentStoreDataStatus) {
             mNativeDocumentStoreDataStatus = documentStoreDataStatus;
             return this;
@@ -430,32 +421,29 @@ public final class InitializeStats {
          * and expired documents.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDocumentCount(int numDocuments) {
+        public @NonNull Builder setDocumentCount(int numDocuments) {
             mNativeNumDocuments = numDocuments;
             return this;
         }
 
         /** Sets number of schema types currently in the schema store. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setSchemaTypeCount(int numSchemaTypes) {
+        public @NonNull Builder setSchemaTypeCount(int numSchemaTypes) {
             mNativeNumSchemaTypes = numSchemaTypes;
             return this;
         }
 
         /** Sets whether we had to reset the index, losing all data, as part of initialization. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setHasReset(boolean hasReset) {
+        public @NonNull Builder setHasReset(boolean hasReset) {
             mHasReset = hasReset;
             return this;
         }
 
         /** Sets the status of the reset, if one was performed according to {@link #setHasReset}. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setResetStatusCode(@AppSearchResult.ResultCode int resetStatusCode) {
+        public @NonNull Builder setResetStatusCode(
+                @AppSearchResult.ResultCode int resetStatusCode) {
             mResetStatusCode = resetStatusCode;
             return this;
         }
@@ -464,8 +452,8 @@ public final class InitializeStats {
          * Constructs a new {@link InitializeStats} from the contents of this {@link
          * InitializeStats.Builder}
          */
-        @NonNull
-        public InitializeStats build() {
+        @Override
+        public @NonNull InitializeStats build() {
             return new InitializeStats(/* builder= */ this);
         }
     }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/OptimizeStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/OptimizeStats.java
index 7a633dc6..629591d1 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/OptimizeStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/OptimizeStats.java
@@ -16,18 +16,18 @@
 
 package com.android.server.appsearch.external.localstorage.stats;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
 
-import java.util.Objects;
+import org.jspecify.annotations.NonNull;
 
 /**
  * Class holds detailed stats for Optimize.
  *
  * @hide
  */
-public final class OptimizeStats {
+public final class OptimizeStats extends BaseStats {
     /**
      * The status code returned by {@link AppSearchResult#getResultCode()} for the call or internal
      * state.
@@ -62,7 +62,7 @@ public final class OptimizeStats {
     private final long mNativeTimeSinceLastOptimizeMillis;
 
     OptimizeStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mStatusCode = builder.mStatusCode;
         mTotalLatencyMillis = builder.mTotalLatencyMillis;
         mNativeLatencyMillis = builder.mNativeLatencyMillis;
@@ -137,7 +137,7 @@ public final class OptimizeStats {
     }
 
     /** Builder for {@link RemoveStats}. */
-    public static class Builder {
+    public static class Builder extends BaseStats.Builder<OptimizeStats.Builder> {
         /**
          * The status code returned by {@link AppSearchResult#getResultCode()} for the call or
          * internal state.
@@ -157,32 +157,28 @@ public final class OptimizeStats {
 
         /** Sets the status code. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
+        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
             mStatusCode = statusCode;
             return this;
         }
 
         /** Sets total latency in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalLatencyMillis(int totalLatencyMillis) {
+        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
             mTotalLatencyMillis = totalLatencyMillis;
             return this;
         }
 
         /** Sets native latency in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeLatencyMillis(int nativeLatencyMillis) {
+        public @NonNull Builder setNativeLatencyMillis(int nativeLatencyMillis) {
             mNativeLatencyMillis = nativeLatencyMillis;
             return this;
         }
 
         /** Sets time used to optimize the document store. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDocumentStoreOptimizeLatencyMillis(
+        public @NonNull Builder setDocumentStoreOptimizeLatencyMillis(
                 int documentStoreOptimizeLatencyMillis) {
             mNativeDocumentStoreOptimizeLatencyMillis = documentStoreOptimizeLatencyMillis;
             return this;
@@ -190,48 +186,43 @@ public final class OptimizeStats {
 
         /** Sets time used to restore the index. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setIndexRestorationLatencyMillis(int indexRestorationLatencyMillis) {
+        public @NonNull Builder setIndexRestorationLatencyMillis(
+                int indexRestorationLatencyMillis) {
             mNativeIndexRestorationLatencyMillis = indexRestorationLatencyMillis;
             return this;
         }
 
         /** Sets number of documents before the optimization. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setOriginalDocumentCount(int originalDocumentCount) {
+        public @NonNull Builder setOriginalDocumentCount(int originalDocumentCount) {
             mNativeOriginalDocumentCount = originalDocumentCount;
             return this;
         }
 
         /** Sets number of documents deleted during the optimization. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDeletedDocumentCount(int deletedDocumentCount) {
+        public @NonNull Builder setDeletedDocumentCount(int deletedDocumentCount) {
             mNativeDeletedDocumentCount = deletedDocumentCount;
             return this;
         }
 
         /** Sets number of documents expired during the optimization. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setExpiredDocumentCount(int expiredDocumentCount) {
+        public @NonNull Builder setExpiredDocumentCount(int expiredDocumentCount) {
             mNativeExpiredDocumentCount = expiredDocumentCount;
             return this;
         }
 
         /** Sets Storage size in bytes before optimization. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStorageSizeBeforeBytes(long storageSizeBeforeBytes) {
+        public @NonNull Builder setStorageSizeBeforeBytes(long storageSizeBeforeBytes) {
             mNativeStorageSizeBeforeBytes = storageSizeBeforeBytes;
             return this;
         }
 
         /** Sets storage size in bytes after optimization. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStorageSizeAfterBytes(long storageSizeAfterBytes) {
+        public @NonNull Builder setStorageSizeAfterBytes(long storageSizeAfterBytes) {
             mNativeStorageSizeAfterBytes = storageSizeAfterBytes;
             return this;
         }
@@ -240,15 +231,14 @@ public final class OptimizeStats {
          * Sets the amount the time since the last optimize ran calculated using wall clock time.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTimeSinceLastOptimizeMillis(long timeSinceLastOptimizeMillis) {
+        public @NonNull Builder setTimeSinceLastOptimizeMillis(long timeSinceLastOptimizeMillis) {
             mNativeTimeSinceLastOptimizeMillis = timeSinceLastOptimizeMillis;
             return this;
         }
 
         /** Creates a {@link OptimizeStats}. */
-        @NonNull
-        public OptimizeStats build() {
+        @Override
+        public @NonNull OptimizeStats build() {
             return new OptimizeStats(/* builder= */ this);
         }
     }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/PutDocumentStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/PutDocumentStats.java
index 2e9c508d..a5a191e6 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/PutDocumentStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/PutDocumentStats.java
@@ -16,9 +16,11 @@
 
 package com.android.server.appsearch.external.localstorage.stats;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
+
+import org.jspecify.annotations.NonNull;
 
 import java.util.Objects;
 
@@ -28,9 +30,9 @@ import java.util.Objects;
  *
  * @hide
  */
-public final class PutDocumentStats {
-    @NonNull private final String mPackageName;
-    @NonNull private final String mDatabase;
+public final class PutDocumentStats extends BaseStats {
+    private final @NonNull String mPackageName;
+    private final @NonNull String mDatabase;
 
     /**
      * The status code returned by {@link AppSearchResult#getResultCode()} for the call or internal
@@ -80,7 +82,7 @@ public final class PutDocumentStats {
     private final int mNativeLiteIndexSortLatencyMillis;
 
     PutDocumentStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mPackageName = builder.mPackageName;
         mDatabase = builder.mDatabase;
         mStatusCode = builder.mStatusCode;
@@ -100,14 +102,12 @@ public final class PutDocumentStats {
     }
 
     /** Returns calling package name. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
     /** Returns calling database name. */
-    @NonNull
-    public String getDatabase() {
+    public @NonNull String getDatabase() {
         return mDatabase;
     }
 
@@ -183,9 +183,9 @@ public final class PutDocumentStats {
     }
 
     /** Builder for {@link PutDocumentStats}. */
-    public static class Builder {
-        @NonNull final String mPackageName;
-        @NonNull final String mDatabase;
+    public static class Builder extends BaseStats.Builder<PutDocumentStats.Builder> {
+        final @NonNull String mPackageName;
+        final @NonNull String mDatabase;
         @AppSearchResult.ResultCode int mStatusCode;
         int mTotalLatencyMillis;
         int mGenerateDocumentProtoLatencyMillis;
@@ -209,24 +209,21 @@ public final class PutDocumentStats {
 
         /** Sets the status code. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
+        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
             mStatusCode = statusCode;
             return this;
         }
 
         /** Sets total latency in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalLatencyMillis(int totalLatencyMillis) {
+        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
             mTotalLatencyMillis = totalLatencyMillis;
             return this;
         }
 
         /** Sets how much time we spend for generating document proto, in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setGenerateDocumentProtoLatencyMillis(
+        public @NonNull Builder setGenerateDocumentProtoLatencyMillis(
                 int generateDocumentProtoLatencyMillis) {
             mGenerateDocumentProtoLatencyMillis = generateDocumentProtoLatencyMillis;
             return this;
@@ -237,80 +234,74 @@ public final class PutDocumentStats {
          * milliseconds.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRewriteDocumentTypesLatencyMillis(int rewriteDocumentTypesLatencyMillis) {
+        public @NonNull Builder setRewriteDocumentTypesLatencyMillis(
+                int rewriteDocumentTypesLatencyMillis) {
             mRewriteDocumentTypesLatencyMillis = rewriteDocumentTypesLatencyMillis;
             return this;
         }
 
         /** Sets the native latency, in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeLatencyMillis(int nativeLatencyMillis) {
+        public @NonNull Builder setNativeLatencyMillis(int nativeLatencyMillis) {
             mNativeLatencyMillis = nativeLatencyMillis;
             return this;
         }
 
         /** Sets how much time we spend on document store, in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeDocumentStoreLatencyMillis(int nativeDocumentStoreLatencyMillis) {
+        public @NonNull Builder setNativeDocumentStoreLatencyMillis(
+                int nativeDocumentStoreLatencyMillis) {
             mNativeDocumentStoreLatencyMillis = nativeDocumentStoreLatencyMillis;
             return this;
         }
 
         /** Sets the native index latency, in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeIndexLatencyMillis(int nativeIndexLatencyMillis) {
+        public @NonNull Builder setNativeIndexLatencyMillis(int nativeIndexLatencyMillis) {
             mNativeIndexLatencyMillis = nativeIndexLatencyMillis;
             return this;
         }
 
         /** Sets how much time we spend on merging indices, in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeIndexMergeLatencyMillis(int nativeIndexMergeLatencyMillis) {
+        public @NonNull Builder setNativeIndexMergeLatencyMillis(
+                int nativeIndexMergeLatencyMillis) {
             mNativeIndexMergeLatencyMillis = nativeIndexMergeLatencyMillis;
             return this;
         }
 
         /** Sets document size, in bytes. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeDocumentSizeBytes(int nativeDocumentSizeBytes) {
+        public @NonNull Builder setNativeDocumentSizeBytes(int nativeDocumentSizeBytes) {
             mNativeDocumentSizeBytes = nativeDocumentSizeBytes;
             return this;
         }
 
         /** Sets number of tokens indexed in native. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeNumTokensIndexed(int nativeNumTokensIndexed) {
+        public @NonNull Builder setNativeNumTokensIndexed(int nativeNumTokensIndexed) {
             mNativeNumTokensIndexed = nativeNumTokensIndexed;
             return this;
         }
 
         /** Sets the native term indexing time, in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeTermIndexLatencyMillis(int nativeTermIndexLatencyMillis) {
+        public @NonNull Builder setNativeTermIndexLatencyMillis(int nativeTermIndexLatencyMillis) {
             mNativeTermIndexLatencyMillis = nativeTermIndexLatencyMillis;
             return this;
         }
 
         /** Sets the native integer indexing time, in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeIntegerIndexLatencyMillis(int nativeIntegerIndexLatencyMillis) {
+        public @NonNull Builder setNativeIntegerIndexLatencyMillis(
+                int nativeIntegerIndexLatencyMillis) {
             mNativeIntegerIndexLatencyMillis = nativeIntegerIndexLatencyMillis;
             return this;
         }
 
         /** Sets the native qualified id indexing time, in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeQualifiedIdJoinIndexLatencyMillis(
+        public @NonNull Builder setNativeQualifiedIdJoinIndexLatencyMillis(
                 int nativeQualifiedIdJoinIndexLatencyMillis) {
             mNativeQualifiedIdJoinIndexLatencyMillis = nativeQualifiedIdJoinIndexLatencyMillis;
             return this;
@@ -318,8 +309,8 @@ public final class PutDocumentStats {
 
         /** Sets the native lite index sort latency, in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeLiteIndexSortLatencyMillis(int nativeLiteIndexSortLatencyMillis) {
+        public @NonNull Builder setNativeLiteIndexSortLatencyMillis(
+                int nativeLiteIndexSortLatencyMillis) {
             mNativeLiteIndexSortLatencyMillis = nativeLiteIndexSortLatencyMillis;
             return this;
         }
@@ -328,8 +319,8 @@ public final class PutDocumentStats {
          * Creates a new {@link PutDocumentStats} object from the contents of this {@link Builder}
          * instance.
          */
-        @NonNull
-        public PutDocumentStats build() {
+        @Override
+        public @NonNull PutDocumentStats build() {
             return new PutDocumentStats(/* builder= */ this);
         }
     }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/RemoveStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/RemoveStats.java
index 8dcfa4ed..6d791dc6 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/RemoveStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/RemoveStats.java
@@ -17,11 +17,13 @@
 package com.android.server.appsearch.external.localstorage.stats;
 
 import android.annotation.IntDef;
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.RemoveByDocumentIdRequest;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
+
+import org.jspecify.annotations.NonNull;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -34,7 +36,7 @@ import java.util.Objects;
  *
  * @hide
  */
-public final class RemoveStats {
+public final class RemoveStats extends BaseStats {
     /** Types of stats available for remove API. */
     @IntDef(
             value = {
@@ -64,8 +66,8 @@ public final class RemoveStats {
     /** Delete by schema type. */
     public static final int SCHEMA_TYPE = 4;
 
-    @NonNull private final String mPackageName;
-    @NonNull private final String mDatabase;
+    private final @NonNull String mPackageName;
+    private final @NonNull String mDatabase;
 
     /**
      * The status code returned by {@link AppSearchResult#getResultCode()} for the call or internal
@@ -79,7 +81,7 @@ public final class RemoveStats {
     private final int mNativeNumDocumentsDeleted;
 
     RemoveStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mPackageName = builder.mPackageName;
         mDatabase = builder.mDatabase;
         mStatusCode = builder.mStatusCode;
@@ -90,14 +92,12 @@ public final class RemoveStats {
     }
 
     /** Returns calling package name. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
     /** Returns calling database name. */
-    @NonNull
-    public String getDatabase() {
+    public @NonNull String getDatabase() {
         return mDatabase;
     }
 
@@ -129,9 +129,9 @@ public final class RemoveStats {
     }
 
     /** Builder for {@link RemoveStats}. */
-    public static class Builder {
-        @NonNull final String mPackageName;
-        @NonNull final String mDatabase;
+    public static class Builder extends BaseStats.Builder<RemoveStats.Builder> {
+        final @NonNull String mPackageName;
+        final @NonNull String mDatabase;
         @AppSearchResult.ResultCode int mStatusCode;
         int mTotalLatencyMillis;
         int mNativeLatencyMillis;
@@ -146,47 +146,42 @@ public final class RemoveStats {
 
         /** Sets the status code. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
+        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
             mStatusCode = statusCode;
             return this;
         }
 
         /** Sets total latency in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalLatencyMillis(int totalLatencyMillis) {
+        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
             mTotalLatencyMillis = totalLatencyMillis;
             return this;
         }
 
         /** Sets native latency in millis. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeLatencyMillis(int nativeLatencyMillis) {
+        public @NonNull Builder setNativeLatencyMillis(int nativeLatencyMillis) {
             mNativeLatencyMillis = nativeLatencyMillis;
             return this;
         }
 
         /** Sets delete type for this call. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDeleteType(@DeleteType int nativeDeleteType) {
+        public @NonNull Builder setDeleteType(@DeleteType int nativeDeleteType) {
             mNativeDeleteType = nativeDeleteType;
             return this;
         }
 
         /** Sets how many documents get deleted for this call. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDeletedDocumentCount(int nativeNumDocumentsDeleted) {
+        public @NonNull Builder setDeletedDocumentCount(int nativeNumDocumentsDeleted) {
             mNativeNumDocumentsDeleted = nativeNumDocumentsDeleted;
             return this;
         }
 
         /** Creates a {@link RemoveStats}. */
-        @NonNull
-        public RemoveStats build() {
+        @Override
+        public @NonNull RemoveStats build() {
             return new RemoveStats(/* builder= */ this);
         }
     }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/SearchIntentStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/SearchIntentStats.java
index 62ad1999..df26a74e 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/SearchIntentStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/SearchIntentStats.java
@@ -17,9 +17,11 @@
 package com.android.server.appsearch.external.localstorage.stats;
 
 import android.annotation.IntDef;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
+
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -41,7 +43,7 @@ import java.util.Objects;
  *
  * @hide
  */
-public final class SearchIntentStats {
+public final class SearchIntentStats extends BaseStats {
     /** AppSearch query correction type compared with the previous query. */
     @IntDef(
             value = {
@@ -64,13 +66,13 @@ public final class SearchIntentStats {
 
     public static final int QUERY_CORRECTION_TYPE_END_SESSION = 4;
 
-    @NonNull private final String mPackageName;
+    private final @NonNull String mPackageName;
 
-    @Nullable private final String mDatabase;
+    private final @Nullable String mDatabase;
 
-    @Nullable private final String mPrevQuery;
+    private final @Nullable String mPrevQuery;
 
-    @Nullable private final String mCurrQuery;
+    private final @Nullable String mCurrQuery;
 
     private final long mTimestampMillis;
 
@@ -78,10 +80,10 @@ public final class SearchIntentStats {
 
     @QueryCorrectionType private final int mQueryCorrectionType;
 
-    @NonNull private final List<ClickStats> mClicksStats;
+    private final @NonNull List<ClickStats> mClicksStats;
 
     SearchIntentStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mPackageName = builder.mPackageName;
         mDatabase = builder.mDatabase;
         mPrevQuery = builder.mPrevQuery;
@@ -93,8 +95,7 @@ public final class SearchIntentStats {
     }
 
     /** Returns calling package name. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
@@ -103,20 +104,17 @@ public final class SearchIntentStats {
      *
      * <p>For global search, database name will be null.
      */
-    @Nullable
-    public String getDatabase() {
+    public @Nullable String getDatabase() {
         return mDatabase;
     }
 
     /** Returns the raw query string of the previous search intent. */
-    @Nullable
-    public String getPrevQuery() {
+    public @Nullable String getPrevQuery() {
         return mPrevQuery;
     }
 
     /** Returns the raw query string of this (current) search intent. */
-    @Nullable
-    public String getCurrQuery() {
+    public @Nullable String getCurrQuery() {
         return mCurrQuery;
     }
 
@@ -142,20 +140,19 @@ public final class SearchIntentStats {
     }
 
     /** Returns the list of {@link ClickStats} in this search intent. */
-    @NonNull
-    public List<ClickStats> getClicksStats() {
+    public @NonNull List<ClickStats> getClicksStats() {
         return mClicksStats;
     }
 
     /** Builder for {@link SearchIntentStats} */
-    public static final class Builder {
-        @NonNull private final String mPackageName;
+    public static final class Builder extends BaseStats.Builder<SearchIntentStats.Builder> {
+        private final @NonNull String mPackageName;
 
-        @Nullable private String mDatabase;
+        private @Nullable String mDatabase;
 
-        @Nullable private String mPrevQuery;
+        private @Nullable String mPrevQuery;
 
-        @Nullable private String mCurrQuery;
+        private @Nullable String mCurrQuery;
 
         private long mTimestampMillis;
 
@@ -163,7 +160,7 @@ public final class SearchIntentStats {
 
         @QueryCorrectionType private int mQueryCorrectionType = QUERY_CORRECTION_TYPE_UNKNOWN;
 
-        @NonNull private List<ClickStats> mClicksStats = new ArrayList<>();
+        private @NonNull List<ClickStats> mClicksStats = new ArrayList<>();
 
         private boolean mBuilt = false;
 
@@ -192,8 +189,7 @@ public final class SearchIntentStats {
          * <p>For global search, database name will be null.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDatabase(@Nullable String database) {
+        public @NonNull Builder setDatabase(@Nullable String database) {
             resetIfBuilt();
             mDatabase = database;
             return this;
@@ -201,8 +197,7 @@ public final class SearchIntentStats {
 
         /** Sets the raw query string of the previous search intent. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setPrevQuery(@Nullable String prevQuery) {
+        public @NonNull Builder setPrevQuery(@Nullable String prevQuery) {
             resetIfBuilt();
             mPrevQuery = prevQuery;
             return this;
@@ -210,8 +205,7 @@ public final class SearchIntentStats {
 
         /** Sets the raw query string of this (current) search intent. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setCurrQuery(@Nullable String currQuery) {
+        public @NonNull Builder setCurrQuery(@Nullable String currQuery) {
             resetIfBuilt();
             mCurrQuery = currQuery;
             return this;
@@ -219,8 +213,7 @@ public final class SearchIntentStats {
 
         /** Sets the search intent timestamp in milliseconds since Unix epoch. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTimestampMillis(long timestampMillis) {
+        public @NonNull Builder setTimestampMillis(long timestampMillis) {
             resetIfBuilt();
             mTimestampMillis = timestampMillis;
             return this;
@@ -230,8 +223,7 @@ public final class SearchIntentStats {
          * Sets total number of results fetched from AppSearch by the client in this search intent.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNumResultsFetched(int numResultsFetched) {
+        public @NonNull Builder setNumResultsFetched(int numResultsFetched) {
             resetIfBuilt();
             mNumResultsFetched = numResultsFetched;
             return this;
@@ -242,8 +234,8 @@ public final class SearchIntentStats {
          * search intent.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setQueryCorrectionType(@QueryCorrectionType int queryCorrectionType) {
+        public @NonNull Builder setQueryCorrectionType(
+                @QueryCorrectionType int queryCorrectionType) {
             resetIfBuilt();
             mQueryCorrectionType = queryCorrectionType;
             return this;
@@ -251,8 +243,7 @@ public final class SearchIntentStats {
 
         /** Adds one or more {@link ClickStats} objects to this search intent. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addClicksStats(@NonNull ClickStats... clicksStats) {
+        public @NonNull Builder addClicksStats(ClickStats @NonNull ... clicksStats) {
             Objects.requireNonNull(clicksStats);
             resetIfBuilt();
             return addClicksStats(Arrays.asList(clicksStats));
@@ -260,8 +251,8 @@ public final class SearchIntentStats {
 
         /** Adds a collection of {@link ClickStats} objects to this search intent. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addClicksStats(@NonNull Collection<? extends ClickStats> clicksStats) {
+        public @NonNull Builder addClicksStats(
+                @NonNull Collection<? extends ClickStats> clicksStats) {
             Objects.requireNonNull(clicksStats);
             resetIfBuilt();
             mClicksStats.addAll(clicksStats);
@@ -279,8 +270,8 @@ public final class SearchIntentStats {
         }
 
         /** Builds a new {@link SearchIntentStats} from the {@link Builder}. */
-        @NonNull
-        public SearchIntentStats build() {
+        @Override
+        public @NonNull SearchIntentStats build() {
             mBuilt = true;
             return new SearchIntentStats(/* builder= */ this);
         }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/SearchSessionStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/SearchSessionStats.java
index 4b5b5290..b87cf0c9 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/SearchSessionStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/SearchSessionStats.java
@@ -16,9 +16,11 @@
 
 package com.android.server.appsearch.external.localstorage.stats;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
+
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -37,15 +39,15 @@ import java.util.Objects;
  *
  * @hide
  */
-public final class SearchSessionStats {
-    @NonNull private final String mPackageName;
+public final class SearchSessionStats extends BaseStats {
+    private final @NonNull String mPackageName;
 
-    @Nullable private final String mDatabase;
+    private final @Nullable String mDatabase;
 
-    @NonNull private final List<SearchIntentStats> mSearchIntentsStats;
+    private final @NonNull List<SearchIntentStats> mSearchIntentsStats;
 
     SearchSessionStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mPackageName = builder.mPackageName;
         mDatabase = builder.mDatabase;
         mSearchIntentsStats = builder.mSearchIntentsStats;
@@ -65,8 +67,7 @@ public final class SearchSessionStats {
      * <p>This stats is useful to determine whether the user ended the search session with
      * satisfaction (i.e. had found desired result documents) or not.
      */
-    @Nullable
-    public SearchIntentStats getEndSessionSearchIntentStats() {
+    public @Nullable SearchIntentStats getEndSessionSearchIntentStats() {
         if (mSearchIntentsStats.isEmpty()) {
             return null;
         }
@@ -80,8 +81,7 @@ public final class SearchSessionStats {
     }
 
     /** Returns calling package name. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
@@ -90,24 +90,22 @@ public final class SearchSessionStats {
      *
      * <p>For global search, database name will be null.
      */
-    @Nullable
-    public String getDatabase() {
+    public @Nullable String getDatabase() {
         return mDatabase;
     }
 
     /** Returns the list of {@link SearchIntentStats} in this search session. */
-    @NonNull
-    public List<SearchIntentStats> getSearchIntentsStats() {
+    public @NonNull List<SearchIntentStats> getSearchIntentsStats() {
         return mSearchIntentsStats;
     }
 
     /** Builder for {@link SearchSessionStats}. */
-    public static final class Builder {
-        @NonNull private final String mPackageName;
+    public static final class Builder extends BaseStats.Builder<SearchSessionStats.Builder> {
+        private final @NonNull String mPackageName;
 
-        @Nullable private String mDatabase;
+        private @Nullable String mDatabase;
 
-        @NonNull private List<SearchIntentStats> mSearchIntentsStats = new ArrayList<>();
+        private @NonNull List<SearchIntentStats> mSearchIntentsStats = new ArrayList<>();
 
         private boolean mBuilt = false;
 
@@ -122,8 +120,7 @@ public final class SearchSessionStats {
          * <p>For global search, database name will be null.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDatabase(@Nullable String database) {
+        public @NonNull Builder setDatabase(@Nullable String database) {
             resetIfBuilt();
             mDatabase = database;
             return this;
@@ -131,8 +128,8 @@ public final class SearchSessionStats {
 
         /** Adds one or more {@link SearchIntentStats} objects to this search intent. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addSearchIntentsStats(@NonNull SearchIntentStats... searchIntentsStats) {
+        public @NonNull Builder addSearchIntentsStats(
+                SearchIntentStats @NonNull ... searchIntentsStats) {
             Objects.requireNonNull(searchIntentsStats);
             resetIfBuilt();
             return addSearchIntentsStats(Arrays.asList(searchIntentsStats));
@@ -140,8 +137,7 @@ public final class SearchSessionStats {
 
         /** Adds a collection of {@link SearchIntentStats} objects to this search intent. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder addSearchIntentsStats(
+        public @NonNull Builder addSearchIntentsStats(
                 @NonNull Collection<? extends SearchIntentStats> searchIntentsStats) {
             Objects.requireNonNull(searchIntentsStats);
             resetIfBuilt();
@@ -160,8 +156,8 @@ public final class SearchSessionStats {
         }
 
         /** Builds a new {@link SearchSessionStats} from the {@link Builder}. */
-        @NonNull
-        public SearchSessionStats build() {
+        @Override
+        public @NonNull SearchSessionStats build() {
             mBuilt = true;
             return new SearchSessionStats(/* builder= */ this);
         }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/SearchStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/SearchStats.java
index d23459b3..bc8b3be6 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/SearchStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/SearchStats.java
@@ -16,15 +16,17 @@
 package com.android.server.appsearch.external.localstorage.stats;
 
 import android.annotation.IntDef;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema.StringPropertyConfig.JoinableValueType;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
 
 import com.android.internal.util.Preconditions;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Objects;
@@ -35,7 +37,7 @@ import java.util.Objects;
  *
  * @hide
  */
-public final class SearchStats {
+public final class SearchStats extends BaseStats {
     /** Types of Visibility scopes available for search. */
     @IntDef(
             value = {
@@ -60,8 +62,8 @@ public final class SearchStats {
     // TODO(b/173532925): Add a field searchType to indicate where the search is used(normal
     //  query vs in removeByQuery vs during migration)
 
-    @NonNull private final String mPackageName;
-    @Nullable private final String mDatabase;
+    private final @NonNull String mPackageName;
+    private final @Nullable String mDatabase;
 
     /**
      * The status code returned by {@link AppSearchResult#getResultCode()} for the call or internal
@@ -161,10 +163,10 @@ public final class SearchStats {
     /** Time taken to join documents together. */
     private final int mNativeJoinLatencyMillis;
 
-    @Nullable private final String mSearchSourceLogTag;
+    private final @Nullable String mSearchSourceLogTag;
 
     SearchStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mPackageName = builder.mPackageName;
         mDatabase = builder.mDatabase;
         mStatusCode = builder.mStatusCode;
@@ -199,8 +201,7 @@ public final class SearchStats {
     }
 
     /** Returns the package name of the session. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
@@ -210,8 +211,7 @@ public final class SearchStats {
      * @return database name used by the session. {@code null} if and only if it is a global
      *     search(visibilityScope is {@link SearchStats#VISIBILITY_SCOPE_GLOBAL}).
      */
-    @Nullable
-    public String getDatabase() {
+    public @Nullable String getDatabase() {
         return mDatabase;
     }
 
@@ -369,14 +369,13 @@ public final class SearchStats {
     }
 
     /** Returns a tag to indicate the source of this search, or {code null} if never set. */
-    @Nullable
-    public String getSearchSourceLogTag() {
+    public @Nullable String getSearchSourceLogTag() {
         return mSearchSourceLogTag;
     }
 
     /** Builder for {@link SearchStats} */
-    public static class Builder {
-        @NonNull final String mPackageName;
+    public static class Builder extends BaseStats.Builder<SearchStats.Builder> {
+        final @NonNull String mPackageName;
         @Nullable String mDatabase;
         @AppSearchResult.ResultCode int mStatusCode;
         int mTotalLatencyMillis;
@@ -421,48 +420,45 @@ public final class SearchStats {
 
         /** Sets the database used by the session. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDatabase(@Nullable String database) {
+        public @NonNull Builder setDatabase(@Nullable String database) {
             mDatabase = database;
             return this;
         }
 
         /** Sets the status of the search. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
+        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
             mStatusCode = statusCode;
             return this;
         }
 
         /** Sets total latency for the search. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalLatencyMillis(int totalLatencyMillis) {
+        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
             mTotalLatencyMillis = totalLatencyMillis;
             return this;
         }
 
         /** Sets time used to rewrite the search spec. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRewriteSearchSpecLatencyMillis(int rewriteSearchSpecLatencyMillis) {
+        public @NonNull Builder setRewriteSearchSpecLatencyMillis(
+                int rewriteSearchSpecLatencyMillis) {
             mRewriteSearchSpecLatencyMillis = rewriteSearchSpecLatencyMillis;
             return this;
         }
 
         /** Sets time used to rewrite the search results. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRewriteSearchResultLatencyMillis(int rewriteSearchResultLatencyMillis) {
+        public @NonNull Builder setRewriteSearchResultLatencyMillis(
+                int rewriteSearchResultLatencyMillis) {
             mRewriteSearchResultLatencyMillis = rewriteSearchResultLatencyMillis;
             return this;
         }
 
         /** Sets time passed while waiting to acquire the lock during Java function calls. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setJavaLockAcquisitionLatencyMillis(int javaLockAcquisitionLatencyMillis) {
+        public @NonNull Builder setJavaLockAcquisitionLatencyMillis(
+                int javaLockAcquisitionLatencyMillis) {
             mJavaLockAcquisitionLatencyMillis = javaLockAcquisitionLatencyMillis;
             return this;
         }
@@ -472,64 +468,57 @@ public final class SearchStats {
          * package permissions and Android permission access.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setAclCheckLatencyMillis(int aclCheckLatencyMillis) {
+        public @NonNull Builder setAclCheckLatencyMillis(int aclCheckLatencyMillis) {
             mAclCheckLatencyMillis = aclCheckLatencyMillis;
             return this;
         }
 
         /** Sets overall time used for the native function calls. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeLatencyMillis(int nativeLatencyMillis) {
+        public @NonNull Builder setNativeLatencyMillis(int nativeLatencyMillis) {
             mNativeLatencyMillis = nativeLatencyMillis;
             return this;
         }
 
         /** Sets number of terms in the search string. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTermCount(int termCount) {
+        public @NonNull Builder setTermCount(int termCount) {
             mNativeNumTerms = termCount;
             return this;
         }
 
         /** Sets length of the search string. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setQueryLength(int queryLength) {
+        public @NonNull Builder setQueryLength(int queryLength) {
             mNativeQueryLength = queryLength;
             return this;
         }
 
         /** Sets number of namespaces filtered. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setFilteredNamespaceCount(int filteredNamespaceCount) {
+        public @NonNull Builder setFilteredNamespaceCount(int filteredNamespaceCount) {
             mNativeNumNamespacesFiltered = filteredNamespaceCount;
             return this;
         }
 
         /** Sets number of schema types filtered. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setFilteredSchemaTypeCount(int filteredSchemaTypeCount) {
+        public @NonNull Builder setFilteredSchemaTypeCount(int filteredSchemaTypeCount) {
             mNativeNumSchemaTypesFiltered = filteredSchemaTypeCount;
             return this;
         }
 
         /** Sets the requested number of results in one page. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRequestedPageSize(int requestedPageSize) {
+        public @NonNull Builder setRequestedPageSize(int requestedPageSize) {
             mNativeRequestedPageSize = requestedPageSize;
             return this;
         }
 
         /** Sets the actual number of results returned in the current page. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setCurrentPageReturnedResultCount(int currentPageReturnedResultCount) {
+        public @NonNull Builder setCurrentPageReturnedResultCount(
+                int currentPageReturnedResultCount) {
             mNativeNumResultsReturnedCurrentPage = currentPageReturnedResultCount;
             return this;
         }
@@ -539,8 +528,7 @@ public final class SearchStats {
          * the results from cache so that some steps may be skipped.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setIsFirstPage(boolean nativeIsFirstPage) {
+        public @NonNull Builder setIsFirstPage(boolean nativeIsFirstPage) {
             mNativeIsFirstPage = nativeIsFirstPage;
             return this;
         }
@@ -550,64 +538,58 @@ public final class SearchStats {
          * into an iterator tree.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setParseQueryLatencyMillis(int parseQueryLatencyMillis) {
+        public @NonNull Builder setParseQueryLatencyMillis(int parseQueryLatencyMillis) {
             mNativeParseQueryLatencyMillis = parseQueryLatencyMillis;
             return this;
         }
 
         /** Sets strategy of scoring and ranking. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRankingStrategy(@SearchSpec.RankingStrategy int rankingStrategy) {
+        public @NonNull Builder setRankingStrategy(
+                @SearchSpec.RankingStrategy int rankingStrategy) {
             mNativeRankingStrategy = rankingStrategy;
             return this;
         }
 
         /** Sets number of documents scored. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setScoredDocumentCount(int scoredDocumentCount) {
+        public @NonNull Builder setScoredDocumentCount(int scoredDocumentCount) {
             mNativeNumDocumentsScored = scoredDocumentCount;
             return this;
         }
 
         /** Sets time used to score the raw results. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setScoringLatencyMillis(int scoringLatencyMillis) {
+        public @NonNull Builder setScoringLatencyMillis(int scoringLatencyMillis) {
             mNativeScoringLatencyMillis = scoringLatencyMillis;
             return this;
         }
 
         /** Sets time used to rank the scored results. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRankingLatencyMillis(int rankingLatencyMillis) {
+        public @NonNull Builder setRankingLatencyMillis(int rankingLatencyMillis) {
             mNativeRankingLatencyMillis = rankingLatencyMillis;
             return this;
         }
 
         /** Sets time used to fetch the document protos. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDocumentRetrievingLatencyMillis(int documentRetrievingLatencyMillis) {
+        public @NonNull Builder setDocumentRetrievingLatencyMillis(
+                int documentRetrievingLatencyMillis) {
             mNativeDocumentRetrievingLatencyMillis = documentRetrievingLatencyMillis;
             return this;
         }
 
         /** Sets how many snippets are calculated. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setResultWithSnippetsCount(int resultWithSnippetsCount) {
+        public @NonNull Builder setResultWithSnippetsCount(int resultWithSnippetsCount) {
             mNativeNumResultsWithSnippets = resultWithSnippetsCount;
             return this;
         }
 
         /** Sets time passed while waiting to acquire the lock during native function calls. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeLockAcquisitionLatencyMillis(
+        public @NonNull Builder setNativeLockAcquisitionLatencyMillis(
                 int nativeLockAcquisitionLatencyMillis) {
             mNativeLockAcquisitionLatencyMillis = nativeLockAcquisitionLatencyMillis;
             return this;
@@ -615,48 +597,43 @@ public final class SearchStats {
 
         /** Sets time used to send data across the JNI boundary from java to native side. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setJavaToNativeJniLatencyMillis(int javaToNativeJniLatencyMillis) {
+        public @NonNull Builder setJavaToNativeJniLatencyMillis(int javaToNativeJniLatencyMillis) {
             mJavaToNativeJniLatencyMillis = javaToNativeJniLatencyMillis;
             return this;
         }
 
         /** Sets time used to send data across the JNI boundary from native to java side. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeToJavaJniLatencyMillis(int nativeToJavaJniLatencyMillis) {
+        public @NonNull Builder setNativeToJavaJniLatencyMillis(int nativeToJavaJniLatencyMillis) {
             mNativeToJavaJniLatencyMillis = nativeToJavaJniLatencyMillis;
             return this;
         }
 
         /** Sets whether or not this is a join query */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setJoinType(@JoinableValueType int joinType) {
+        public @NonNull Builder setJoinType(@JoinableValueType int joinType) {
             mJoinType = joinType;
             return this;
         }
 
         /** Set the total number of joined documents in a page. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeNumJoinedResultsCurrentPage(int nativeNumJoinedResultsCurrentPage) {
+        public @NonNull Builder setNativeNumJoinedResultsCurrentPage(
+                int nativeNumJoinedResultsCurrentPage) {
             mNativeNumJoinedResultsCurrentPage = nativeNumJoinedResultsCurrentPage;
             return this;
         }
 
         /** Sets time it takes to join documents together in icing. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNativeJoinLatencyMillis(int nativeJoinLatencyMillis) {
+        public @NonNull Builder setNativeJoinLatencyMillis(int nativeJoinLatencyMillis) {
             mNativeJoinLatencyMillis = nativeJoinLatencyMillis;
             return this;
         }
 
         /** Sets a tag to indicate the source of this search. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setSearchSourceLogTag(@Nullable String searchSourceLogTag) {
+        public @NonNull Builder setSearchSourceLogTag(@Nullable String searchSourceLogTag) {
             mSearchSourceLogTag = searchSourceLogTag;
             return this;
         }
@@ -665,8 +642,8 @@ public final class SearchStats {
          * Constructs a new {@link SearchStats} from the contents of this {@link
          * SearchStats.Builder}.
          */
-        @NonNull
-        public SearchStats build() {
+        @Override
+        public @NonNull SearchStats build() {
             if (mDatabase == null) {
                 Preconditions.checkState(
                         mVisibilityScope != SearchStats.VISIBILITY_SCOPE_LOCAL,
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/SetSchemaStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/SetSchemaStats.java
index 92b26087..4f8a3c51 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/SetSchemaStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/SetSchemaStats.java
@@ -19,26 +19,27 @@ package com.android.server.appsearch.external.localstorage.stats;
 import static android.app.appsearch.stats.SchemaMigrationStats.NO_MIGRATION;
 import static android.app.appsearch.stats.SchemaMigrationStats.SECOND_CALL_APPLY_NEW_SCHEMA;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
 import android.app.appsearch.stats.SchemaMigrationStats;
 
 import com.android.internal.util.Preconditions;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Objects;
 
 /**
- * Class holds detailed stats for {@link
- * android.app.appsearch.AppSearchSession#setSchema(SetSchemaRequest)}.
+ * Class holds detailed stats for {@link android.app.appsearch.AppSearchSession#setSchema}.
  *
  * @hide
  */
-public final class SetSchemaStats {
+public final class SetSchemaStats extends BaseStats {
 
-    @NonNull private final String mPackageName;
+    private final @NonNull String mPackageName;
 
-    @NonNull private final String mDatabase;
+    private final @NonNull String mDatabase;
 
     @AppSearchResult.ResultCode private final int mStatusCode;
     private final int mTotalLatencyMillis;
@@ -64,7 +65,7 @@ public final class SetSchemaStats {
     @SchemaMigrationStats.SchemaMigrationCallType private final int mSchemaMigrationCallType;
 
     SetSchemaStats(@NonNull Builder builder) {
-        Objects.requireNonNull(builder);
+        super(builder);
         mPackageName = builder.mPackageName;
         mDatabase = builder.mDatabase;
         mStatusCode = builder.mStatusCode;
@@ -94,14 +95,12 @@ public final class SetSchemaStats {
     }
 
     /** Returns calling package name. */
-    @NonNull
-    public String getPackageName() {
+    public @NonNull String getPackageName() {
         return mPackageName;
     }
 
     /** Returns calling database name. */
-    @NonNull
-    public String getDatabase() {
+    public @NonNull String getDatabase() {
         return mDatabase;
     }
 
@@ -228,9 +227,9 @@ public final class SetSchemaStats {
     }
 
     /** Builder for {@link SetSchemaStats}. */
-    public static class Builder {
-        @NonNull final String mPackageName;
-        @NonNull final String mDatabase;
+    public static class Builder extends BaseStats.Builder<SetSchemaStats.Builder> {
+        final @NonNull String mPackageName;
+        final @NonNull String mDatabase;
         @AppSearchResult.ResultCode int mStatusCode;
         int mTotalLatencyMillis;
         int mNewTypeCount;
@@ -262,56 +261,50 @@ public final class SetSchemaStats {
 
         /** Sets the status of the SetSchema action. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
+        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
             mStatusCode = statusCode;
             return this;
         }
 
         /** Sets total latency for the SetSchema action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalLatencyMillis(int totalLatencyMillis) {
+        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
             mTotalLatencyMillis = totalLatencyMillis;
             return this;
         }
 
         /** Sets number of new types. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setNewTypeCount(int newTypeCount) {
+        public @NonNull Builder setNewTypeCount(int newTypeCount) {
             mNewTypeCount = newTypeCount;
             return this;
         }
 
         /** Sets number of deleted types. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDeletedTypeCount(int deletedTypeCount) {
+        public @NonNull Builder setDeletedTypeCount(int deletedTypeCount) {
             mDeletedTypeCount = deletedTypeCount;
             return this;
         }
 
         /** Sets number of compatible type changes. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setCompatibleTypeChangeCount(int compatibleTypeChangeCount) {
+        public @NonNull Builder setCompatibleTypeChangeCount(int compatibleTypeChangeCount) {
             mCompatibleTypeChangeCount = compatibleTypeChangeCount;
             return this;
         }
 
         /** Sets number of index-incompatible type changes. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setIndexIncompatibleTypeChangeCount(int indexIncompatibleTypeChangeCount) {
+        public @NonNull Builder setIndexIncompatibleTypeChangeCount(
+                int indexIncompatibleTypeChangeCount) {
             mIndexIncompatibleTypeChangeCount = indexIncompatibleTypeChangeCount;
             return this;
         }
 
         /** Sets number of backwards-incompatible type changes. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setBackwardsIncompatibleTypeChangeCount(
+        public @NonNull Builder setBackwardsIncompatibleTypeChangeCount(
                 int backwardsIncompatibleTypeChangeCount) {
             mBackwardsIncompatibleTypeChangeCount = backwardsIncompatibleTypeChangeCount;
             return this;
@@ -319,24 +312,24 @@ public final class SetSchemaStats {
 
         /** Sets total latency for the SetSchema in native action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setVerifyIncomingCallLatencyMillis(int verifyIncomingCallLatencyMillis) {
+        public @NonNull Builder setVerifyIncomingCallLatencyMillis(
+                int verifyIncomingCallLatencyMillis) {
             mVerifyIncomingCallLatencyMillis = verifyIncomingCallLatencyMillis;
             return this;
         }
 
         /** Sets total latency for the SetSchema in native action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setExecutorAcquisitionLatencyMillis(int executorAcquisitionLatencyMillis) {
+        public @NonNull Builder setExecutorAcquisitionLatencyMillis(
+                int executorAcquisitionLatencyMillis) {
             mExecutorAcquisitionLatencyMillis = executorAcquisitionLatencyMillis;
             return this;
         }
 
         /** Sets latency for the rebuild schema object from bundle action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRebuildFromBundleLatencyMillis(int rebuildFromBundleLatencyMillis) {
+        public @NonNull Builder setRebuildFromBundleLatencyMillis(
+                int rebuildFromBundleLatencyMillis) {
             mRebuildFromBundleLatencyMillis = rebuildFromBundleLatencyMillis;
             return this;
         }
@@ -345,48 +338,45 @@ public final class SetSchemaStats {
          * Sets latency for waiting to acquire the lock during Java function calls in milliseconds.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setJavaLockAcquisitionLatencyMillis(int javaLockAcquisitionLatencyMillis) {
+        public @NonNull Builder setJavaLockAcquisitionLatencyMillis(
+                int javaLockAcquisitionLatencyMillis) {
             mJavaLockAcquisitionLatencyMillis = javaLockAcquisitionLatencyMillis;
             return this;
         }
 
         /** Sets latency for the rewrite the schema proto action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setRewriteSchemaLatencyMillis(int rewriteSchemaLatencyMillis) {
+        public @NonNull Builder setRewriteSchemaLatencyMillis(int rewriteSchemaLatencyMillis) {
             mRewriteSchemaLatencyMillis = rewriteSchemaLatencyMillis;
             return this;
         }
 
         /** Sets total latency for a single set schema in native action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTotalNativeLatencyMillis(int totalNativeLatencyMillis) {
+        public @NonNull Builder setTotalNativeLatencyMillis(int totalNativeLatencyMillis) {
             mTotalNativeLatencyMillis = totalNativeLatencyMillis;
             return this;
         }
 
         /** Sets latency for the apply visibility settings action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setVisibilitySettingLatencyMillis(int visibilitySettingLatencyMillis) {
+        public @NonNull Builder setVisibilitySettingLatencyMillis(
+                int visibilitySettingLatencyMillis) {
             mVisibilitySettingLatencyMillis = visibilitySettingLatencyMillis;
             return this;
         }
 
         /** Sets latency for converting to SetSchemaResponseInternal object in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setConvertToResponseLatencyMillis(int convertToResponseLatencyMillis) {
+        public @NonNull Builder setConvertToResponseLatencyMillis(
+                int convertToResponseLatencyMillis) {
             mConvertToResponseLatencyMillis = convertToResponseLatencyMillis;
             return this;
         }
 
         /** Sets latency for the dispatch change notification action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setDispatchChangeNotificationsLatencyMillis(
+        public @NonNull Builder setDispatchChangeNotificationsLatencyMillis(
                 int dispatchChangeNotificationsLatencyMillis) {
             mDispatchChangeNotificationsLatencyMillis = dispatchChangeNotificationsLatencyMillis;
             return this;
@@ -394,40 +384,35 @@ public final class SetSchemaStats {
 
         /** Sets latency for the optimization action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setOptimizeLatencyMillis(int optimizeLatencyMillis) {
+        public @NonNull Builder setOptimizeLatencyMillis(int optimizeLatencyMillis) {
             mOptimizeLatencyMillis = optimizeLatencyMillis;
             return this;
         }
 
         /** Sets whether this package is observed and we should prepare change notifications. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setIsPackageObserved(boolean isPackageObserved) {
+        public @NonNull Builder setIsPackageObserved(boolean isPackageObserved) {
             mIsPackageObserved = isPackageObserved;
             return this;
         }
 
         /** Sets latency for the old schema action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setGetOldSchemaLatencyMillis(int getOldSchemaLatencyMillis) {
+        public @NonNull Builder setGetOldSchemaLatencyMillis(int getOldSchemaLatencyMillis) {
             mGetOldSchemaLatencyMillis = getOldSchemaLatencyMillis;
             return this;
         }
 
         /** Sets latency for the registered observer action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setGetObserverLatencyMillis(int getObserverLatencyMillis) {
+        public @NonNull Builder setGetObserverLatencyMillis(int getObserverLatencyMillis) {
             mGetObserverLatencyMillis = getObserverLatencyMillis;
             return this;
         }
 
         /** Sets latency for the preparing change notification action in milliseconds. */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setPreparingChangeNotificationLatencyMillis(
+        public @NonNull Builder setPreparingChangeNotificationLatencyMillis(
                 int preparingChangeNotificationLatencyMillis) {
             mPreparingChangeNotificationLatencyMillis = preparingChangeNotificationLatencyMillis;
             return this;
@@ -435,8 +420,7 @@ public final class SetSchemaStats {
 
         /** Sets the type indicate how this set schema call relative to schema migration cases */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setSchemaMigrationCallType(
+        public @NonNull Builder setSchemaMigrationCallType(
                 @SchemaMigrationStats.SchemaMigrationCallType int schemaMigrationCallType) {
             Preconditions.checkArgumentInRange(
                     schemaMigrationCallType,
@@ -448,8 +432,8 @@ public final class SetSchemaStats {
         }
 
         /** Builds a new {@link SetSchemaStats} from the {@link Builder}. */
-        @NonNull
-        public SetSchemaStats build() {
+        @Override
+        public @NonNull SetSchemaStats build() {
             return new SetSchemaStats(/* builder= */ this);
         }
     }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/usagereporting/ClickActionGenericDocument.java b/service/java/com/android/server/appsearch/external/localstorage/usagereporting/ClickActionGenericDocument.java
index 9e9db31f..26bfc27e 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/usagereporting/ClickActionGenericDocument.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/usagereporting/ClickActionGenericDocument.java
@@ -16,8 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.usagereporting;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.AppSearchSession;
@@ -27,6 +25,9 @@ import android.app.appsearch.usagereporting.ActionConstants;
 
 import com.android.internal.util.Preconditions;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Objects;
 
 /**
@@ -49,8 +50,7 @@ public class ClickActionGenericDocument extends TakenActionGenericDocument {
     }
 
     /** Returns the string value of property {@code query}. */
-    @Nullable
-    public String getQuery() {
+    public @Nullable String getQuery() {
         return getPropertyString(PROPERTY_PATH_QUERY);
     }
 
@@ -119,8 +119,7 @@ public class ClickActionGenericDocument extends TakenActionGenericDocument {
          * on which the user clicked.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setQuery(@NonNull String query) {
+        public @NonNull Builder setQuery(@NonNull String query) {
             Objects.requireNonNull(query);
             setPropertyString(PROPERTY_PATH_QUERY, query);
             return this;
@@ -131,8 +130,7 @@ public class ClickActionGenericDocument extends TakenActionGenericDocument {
          * {@link android.app.appsearch.SearchResult} document among the user-defined block.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setResultRankInBlock(int resultRankInBlock) {
+        public @NonNull Builder setResultRankInBlock(int resultRankInBlock) {
             Preconditions.checkArgumentNonnegative(resultRankInBlock);
             setPropertyLong(PROPERTY_PATH_RESULT_RANK_IN_BLOCK, resultRankInBlock);
             return this;
@@ -143,8 +141,7 @@ public class ClickActionGenericDocument extends TakenActionGenericDocument {
          * clicked {@link android.app.appsearch.SearchResult} document.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setResultRankGlobal(int resultRankGlobal) {
+        public @NonNull Builder setResultRankGlobal(int resultRankGlobal) {
             Preconditions.checkArgumentNonnegative(resultRankGlobal);
             setPropertyLong(PROPERTY_PATH_RESULT_RANK_GLOBAL, resultRankGlobal);
             return this;
@@ -156,16 +153,14 @@ public class ClickActionGenericDocument extends TakenActionGenericDocument {
          * after clicking it.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setTimeStayOnResultMillis(long timeStayOnResultMillis) {
+        public @NonNull Builder setTimeStayOnResultMillis(long timeStayOnResultMillis) {
             setPropertyLong(PROPERTY_PATH_TIME_STAY_ON_RESULT_MILLIS, timeStayOnResultMillis);
             return this;
         }
 
         /** Builds a {@link ClickActionGenericDocument}. */
         @Override
-        @NonNull
-        public ClickActionGenericDocument build() {
+        public @NonNull ClickActionGenericDocument build() {
             return new ClickActionGenericDocument(super.build());
         }
     }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/usagereporting/SearchActionGenericDocument.java b/service/java/com/android/server/appsearch/external/localstorage/usagereporting/SearchActionGenericDocument.java
index aa653dbe..aa2714dd 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/usagereporting/SearchActionGenericDocument.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/usagereporting/SearchActionGenericDocument.java
@@ -16,8 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.usagereporting;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.AppSearchSession;
@@ -27,6 +25,9 @@ import android.app.appsearch.usagereporting.ActionConstants;
 
 import com.android.internal.util.Preconditions;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Objects;
 
 /**
@@ -47,8 +48,7 @@ public class SearchActionGenericDocument extends TakenActionGenericDocument {
     }
 
     /** Returns the string value of property {@code query}. */
-    @Nullable
-    public String getQuery() {
+    public @Nullable String getQuery() {
         return getPropertyString(PROPERTY_PATH_QUERY);
     }
 
@@ -106,8 +106,7 @@ public class SearchActionGenericDocument extends TakenActionGenericDocument {
          * any operators or rewriting).
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setQuery(@NonNull String query) {
+        public @NonNull Builder setQuery(@NonNull String query) {
             Objects.requireNonNull(query);
             setPropertyString(PROPERTY_PATH_QUERY, query);
             return this;
@@ -118,8 +117,7 @@ public class SearchActionGenericDocument extends TakenActionGenericDocument {
          * fetched from AppSearch by the client in this search action.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        public Builder setFetchedResultCount(int fetchedResultCount) {
+        public @NonNull Builder setFetchedResultCount(int fetchedResultCount) {
             Preconditions.checkArgumentNonnegative(fetchedResultCount);
             setPropertyLong(PROPERTY_PATH_FETCHED_RESULT_COUNT, fetchedResultCount);
             return this;
@@ -127,8 +125,7 @@ public class SearchActionGenericDocument extends TakenActionGenericDocument {
 
         /** Builds a {@link SearchActionGenericDocument}. */
         @Override
-        @NonNull
-        public SearchActionGenericDocument build() {
+        public @NonNull SearchActionGenericDocument build() {
             return new SearchActionGenericDocument(super.build());
         }
     }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/usagereporting/SearchSessionStatsExtractor.java b/service/java/com/android/server/appsearch/external/localstorage/usagereporting/SearchSessionStatsExtractor.java
index 7f5dcabc..36cf7774 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/usagereporting/SearchSessionStatsExtractor.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/usagereporting/SearchSessionStatsExtractor.java
@@ -16,8 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.usagereporting;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.usagereporting.ActionConstants;
 
@@ -25,6 +23,9 @@ import com.android.server.appsearch.external.localstorage.stats.ClickStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchIntentStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchSessionStats;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -129,12 +130,13 @@ public final class SearchSessionStatsExtractor {
      * @param packageName The package name of the caller.
      * @param database The database name of the caller.
      * @param genericDocuments a list of taken actions in generic document form.
+     * @param isVMEnabled whether the pVM is enabled in AppSearch.
      */
-    @NonNull
-    public List<SearchSessionStats> extract(
+    public @NonNull List<SearchSessionStats> extract(
             @NonNull String packageName,
             @Nullable String database,
-            @NonNull List<GenericDocument> genericDocuments) {
+            @NonNull List<GenericDocument> genericDocuments,
+            boolean isVMEnabled) {
         Objects.requireNonNull(genericDocuments);
 
         // Convert GenericDocument list to TakenActionGenericDocument list and sort them by document
@@ -227,7 +229,9 @@ public final class SearchSessionStatsExtractor {
             // session.
             if (searchSessionStatsBuilder == null) {
                 searchSessionStatsBuilder =
-                        new SearchSessionStats.Builder(packageName).setDatabase(database);
+                        new SearchSessionStats.Builder(packageName)
+                                .setDatabase(database)
+                                .setLaunchVMEnabled(isVMEnabled);
             }
             searchSessionStatsBuilder.addSearchIntentsStats(
                     createSearchIntentStats(
@@ -235,7 +239,8 @@ public final class SearchSessionStatsExtractor {
                             database,
                             currSearchAction,
                             clickActions,
-                            prevSearchAction));
+                            prevSearchAction,
+                            isVMEnabled));
             prevSearchAction = currSearchAction;
         }
         if (searchSessionStatsBuilder != null) {
@@ -253,7 +258,8 @@ public final class SearchSessionStatsExtractor {
             @Nullable String database,
             @NonNull SearchActionGenericDocument currSearchAction,
             @NonNull List<ClickActionGenericDocument> clickActions,
-            @Nullable SearchActionGenericDocument prevSearchAction) {
+            @Nullable SearchActionGenericDocument prevSearchAction,
+            boolean isVMEnabled) {
         SearchIntentStats.Builder builder =
                 new SearchIntentStats.Builder(packageName)
                         .setDatabase(database)
@@ -261,12 +267,13 @@ public final class SearchSessionStatsExtractor {
                         .setCurrQuery(currSearchAction.getQuery())
                         .setNumResultsFetched(currSearchAction.getFetchedResultCount())
                         .setQueryCorrectionType(
-                                getQueryCorrectionType(currSearchAction, prevSearchAction));
+                                getQueryCorrectionType(currSearchAction, prevSearchAction))
+                        .setLaunchVMEnabled(isVMEnabled);
         if (prevSearchAction != null) {
             builder.setPrevQuery(prevSearchAction.getQuery());
         }
         for (int i = 0; i < clickActions.size(); ++i) {
-            builder.addClicksStats(createClickStats(clickActions.get(i)));
+            builder.addClicksStats(createClickStats(clickActions.get(i), isVMEnabled));
         }
         return builder.build();
     }
@@ -274,7 +281,8 @@ public final class SearchSessionStatsExtractor {
     /**
      * Creates a {@link ClickStats} object from the given click action (in generic document form).
      */
-    private ClickStats createClickStats(ClickActionGenericDocument clickAction) {
+    private ClickStats createClickStats(
+            ClickActionGenericDocument clickAction, boolean isVMEnabled) {
         // A click is considered good if:
         // - The user spent decent amount of time on the clicked document.
         // - OR the client didn't provide timeStayOnResultMillis. In this case, the value will be 0.
@@ -288,6 +296,7 @@ public final class SearchSessionStatsExtractor {
                 .setResultRankGlobal(clickAction.getResultRankGlobal())
                 .setTimeStayOnResultMillis(clickAction.getTimeStayOnResultMillis())
                 .setIsGoodClick(isGoodClick)
+                .setLaunchVMEnabled(isVMEnabled)
                 .build();
     }
 
diff --git a/service/java/com/android/server/appsearch/external/localstorage/usagereporting/TakenActionGenericDocument.java b/service/java/com/android/server/appsearch/external/localstorage/usagereporting/TakenActionGenericDocument.java
index 8e03a54a..4e2fd251 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/usagereporting/TakenActionGenericDocument.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/usagereporting/TakenActionGenericDocument.java
@@ -16,13 +16,14 @@
 
 package com.android.server.appsearch.external.localstorage.usagereporting;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.AppSearchSession;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.usagereporting.ActionConstants;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.Objects;
 
 /**
@@ -42,8 +43,7 @@ public abstract class TakenActionGenericDocument extends GenericDocument {
      * @throws IllegalArgumentException if the integer value of property {@code actionType} is
      *     invalid.
      */
-    @NonNull
-    public static TakenActionGenericDocument create(@NonNull GenericDocument document)
+    public static @NonNull TakenActionGenericDocument create(@NonNull GenericDocument document)
             throws IllegalArgumentException {
         Objects.requireNonNull(document);
         int actionType = (int) document.getPropertyLong(PROPERTY_PATH_ACTION_TYPE);
diff --git a/service/java/com/android/server/appsearch/external/localstorage/util/MapUtil.java b/service/java/com/android/server/appsearch/external/localstorage/util/MapUtil.java
index e524673c..bbcd791d 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/util/MapUtil.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/util/MapUtil.java
@@ -16,7 +16,8 @@
 
 package com.android.server.appsearch.external.localstorage.util;
 
-import android.annotation.NonNull;
+
+import org.jspecify.annotations.NonNull;
 
 import java.util.Map;
 
diff --git a/service/java/com/android/server/appsearch/external/localstorage/util/PrefixUtil.java b/service/java/com/android/server/appsearch/external/localstorage/util/PrefixUtil.java
index c02c1d85..156edb60 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/util/PrefixUtil.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/util/PrefixUtil.java
@@ -16,7 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.util;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.util.Log;
@@ -28,6 +27,8 @@ import com.google.android.icing.proto.PropertyConfigProto;
 import com.google.android.icing.proto.PropertyProto;
 import com.google.android.icing.proto.SchemaTypeConfigProto;
 
+import org.jspecify.annotations.NonNull;
+
 /**
  * Provides utility functions for working with package + database prefixes.
  *
@@ -43,14 +44,13 @@ public class PrefixUtil {
     private PrefixUtil() {}
 
     /** Creates prefix string for given package name and database name. */
-    @NonNull
-    public static String createPrefix(@NonNull String packageName, @NonNull String databaseName) {
+    public static @NonNull String createPrefix(
+            @NonNull String packageName, @NonNull String databaseName) {
         return packageName + PACKAGE_DELIMITER + databaseName + DATABASE_DELIMITER;
     }
 
     /** Creates prefix string for given package name. */
-    @NonNull
-    public static String createPackagePrefix(@NonNull String packageName) {
+    public static @NonNull String createPackagePrefix(@NonNull String packageName) {
         return packageName + PACKAGE_DELIMITER;
     }
 
@@ -62,8 +62,7 @@ public class PrefixUtil {
      *     {@link #PACKAGE_DELIMITER}.
      * @return Valid package name.
      */
-    @NonNull
-    public static String getPackageName(@NonNull String prefix) {
+    public static @NonNull String getPackageName(@NonNull String prefix) {
         int delimiterIndex = prefix.indexOf(PACKAGE_DELIMITER);
         if (delimiterIndex == -1) {
             // This should never happen if we construct our prefixes properly
@@ -80,8 +79,7 @@ public class PrefixUtil {
      *     must be between the {@link #PACKAGE_DELIMITER} and {@link #DATABASE_DELIMITER}
      * @return Valid database name.
      */
-    @NonNull
-    public static String getDatabaseName(@NonNull String prefix) {
+    public static @NonNull String getDatabaseName(@NonNull String prefix) {
         int packageDelimiterIndex = prefix.indexOf(PACKAGE_DELIMITER);
         if (packageDelimiterIndex == -1) {
             // This should never happen if we construct our prefixes properly
@@ -104,8 +102,8 @@ public class PrefixUtil {
      * @return a string with the package and database prefix removed.
      * @throws AppSearchException if the prefixed value does not contain a valid database name.
      */
-    @NonNull
-    public static String removePrefix(@NonNull String prefixedString) throws AppSearchException {
+    public static @NonNull String removePrefix(@NonNull String prefixedString)
+            throws AppSearchException {
         // The prefix is made up of the package, then the database. So we only need to find the
         // database cutoff.
         int delimiterIndex = prefixedString.indexOf(DATABASE_DELIMITER);
@@ -128,8 +126,8 @@ public class PrefixUtil {
      * @return a string with the package and database prefix
      * @throws AppSearchException if the prefixed value does not contain a valid database name.
      */
-    @NonNull
-    public static String getPrefix(@NonNull String prefixedString) throws AppSearchException {
+    public static @NonNull String getPrefix(@NonNull String prefixedString)
+            throws AppSearchException {
         int delimiterIndex = prefixedString.indexOf(DATABASE_DELIMITER);
         if (delimiterIndex == -1) {
             throw new AppSearchException(
@@ -151,7 +149,7 @@ public class PrefixUtil {
      * @param prefix The prefix to add
      */
     public static void addPrefixToDocument(
-            @NonNull DocumentProto.Builder documentBuilder, @NonNull String prefix) {
+            DocumentProto.@NonNull Builder documentBuilder, @NonNull String prefix) {
         // Rewrite the type name to include/remove the prefix.
         String newSchema = prefix + documentBuilder.getSchema();
         documentBuilder.setSchema(newSchema);
@@ -185,9 +183,8 @@ public class PrefixUtil {
      * @return Prefix name that was removed from the document.
      * @throws AppSearchException if there are unexpected database prefixing errors.
      */
-    @NonNull
-    public static String removePrefixesFromDocument(@NonNull DocumentProto.Builder documentBuilder)
-            throws AppSearchException {
+    public static @NonNull String removePrefixesFromDocument(
+            DocumentProto.@NonNull Builder documentBuilder) throws AppSearchException {
         // Rewrite the type name and namespace to remove the prefix.
         String schemaPrefix = getPrefix(documentBuilder.getSchema());
         String namespacePrefix = getPrefix(documentBuilder.getNamespace());
@@ -241,9 +238,8 @@ public class PrefixUtil {
      * @return Prefix name that was removed from the schema type.
      * @throws AppSearchException if there are unexpected database prefixing errors.
      */
-    @NonNull
-    public static String removePrefixesFromSchemaType(
-            @NonNull SchemaTypeConfigProto.Builder typeConfigBuilder) throws AppSearchException {
+    public static @NonNull String removePrefixesFromSchemaType(
+            SchemaTypeConfigProto.@NonNull Builder typeConfigBuilder) throws AppSearchException {
         String typePrefix = PrefixUtil.getPrefix(typeConfigBuilder.getSchemaType());
         // Rewrite SchemaProto.types.schema_type
         String newSchemaType = typeConfigBuilder.getSchemaType().substring(typePrefix.length());
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/CallerAccess.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/CallerAccess.java
index 4fa5a785..9e3e8ebd 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/CallerAccess.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/CallerAccess.java
@@ -16,8 +16,8 @@
 
 package com.android.server.appsearch.external.localstorage.visibilitystore;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
 
 import java.util.Objects;
 
@@ -39,8 +39,7 @@ public class CallerAccess {
     }
 
     /** Returns the name of the package which wants to access data. */
-    @NonNull
-    public String getCallingPackageName() {
+    public @NonNull String getCallingPackageName() {
         return mCallingPackageName;
     }
 
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityChecker.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityChecker.java
index 3293b5ed..ab2e6e25 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityChecker.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityChecker.java
@@ -15,7 +15,8 @@
  */
 package com.android.server.appsearch.external.localstorage.visibilitystore;
 
-import android.annotation.NonNull;
+
+import org.jspecify.annotations.NonNull;
 
 /**
  * An interface for classes that validate document visibility data.
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityDocumentV1.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityDocumentV1.java
index 0f146cec..5469f1e7 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityDocumentV1.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityDocumentV1.java
@@ -15,14 +15,15 @@
  */
 package com.android.server.appsearch.external.localstorage.visibilitystore;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.PackageIdentifier;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.util.ArraySet;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Objects;
 import java.util.Set;
 
@@ -100,8 +101,7 @@ class VisibilityDocumentV1 extends GenericDocument {
      * get package's sha 256 certs. The same index of package names array and sha256Certs array
      * represents same package.
      */
-    @NonNull
-    String[] getPackageNames() {
+    String @NonNull [] getPackageNames() {
         return Objects.requireNonNull(getPropertyStringArray(PACKAGE_NAME_PROPERTY));
     }
 
@@ -110,8 +110,7 @@ class VisibilityDocumentV1 extends GenericDocument {
      * #getPackageNames()} to get package's name. The same index of package names array and
      * sha256Certs array represents same package.
      */
-    @NonNull
-    byte[][] getSha256Certs() {
+    byte @NonNull [][] getSha256Certs() {
         return Objects.requireNonNull(getPropertyBytesArray(SHA_256_CERT_PROPERTY));
     }
 
@@ -119,8 +118,7 @@ class VisibilityDocumentV1 extends GenericDocument {
      * Returns an array of Android Roles that have access to the schema this {@link
      * VisibilityDocumentV1} represents.
      */
-    @Nullable
-    Set<Integer> getVisibleToRoles() {
+    @Nullable Set<Integer> getVisibleToRoles() {
         return toInts(getPropertyLongArray(ROLE_PROPERTY));
     }
 
@@ -128,8 +126,7 @@ class VisibilityDocumentV1 extends GenericDocument {
      * Returns an array of Android Permissions that caller mush hold to access the schema this
      * {@link VisibilityDocumentV1} represents.
      */
-    @Nullable
-    Set<Integer> getVisibleToPermissions() {
+    @Nullable Set<Integer> getVisibleToPermissions() {
         return toInts(getPropertyLongArray(PERMISSION_PROPERTY));
     }
 
@@ -151,15 +148,13 @@ class VisibilityDocumentV1 extends GenericDocument {
 
         /** Sets whether this schema has opted out of platform surfacing. */
         @CanIgnoreReturnValue
-        @NonNull
-        Builder setNotDisplayedBySystem(boolean notDisplayedBySystem) {
+        @NonNull Builder setNotDisplayedBySystem(boolean notDisplayedBySystem) {
             return setPropertyBoolean(NOT_DISPLAYED_BY_SYSTEM_PROPERTY, notDisplayedBySystem);
         }
 
         /** Add {@link PackageIdentifier} of packages which has access to this schema. */
         @CanIgnoreReturnValue
-        @NonNull
-        Builder addVisibleToPackages(@NonNull Set<PackageIdentifier> packageIdentifiers) {
+        @NonNull Builder addVisibleToPackages(@NonNull Set<PackageIdentifier> packageIdentifiers) {
             Objects.requireNonNull(packageIdentifiers);
             mPackageIdentifiers.addAll(packageIdentifiers);
             return this;
@@ -167,8 +162,7 @@ class VisibilityDocumentV1 extends GenericDocument {
 
         /** Add {@link PackageIdentifier} of packages which has access to this schema. */
         @CanIgnoreReturnValue
-        @NonNull
-        Builder addVisibleToPackage(@NonNull PackageIdentifier packageIdentifier) {
+        @NonNull Builder addVisibleToPackage(@NonNull PackageIdentifier packageIdentifier) {
             Objects.requireNonNull(packageIdentifier);
             mPackageIdentifiers.add(packageIdentifier);
             return this;
@@ -179,8 +173,7 @@ class VisibilityDocumentV1 extends GenericDocument {
          * represents.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        Builder setVisibleToRoles(@NonNull Set<Integer> visibleToRoles) {
+        @NonNull Builder setVisibleToRoles(@NonNull Set<Integer> visibleToRoles) {
             Objects.requireNonNull(visibleToRoles);
             setPropertyLong(ROLE_PROPERTY, toLongs(visibleToRoles));
             return this;
@@ -191,8 +184,7 @@ class VisibilityDocumentV1 extends GenericDocument {
          * represents.
          */
         @CanIgnoreReturnValue
-        @NonNull
-        Builder setVisibleToPermissions(@NonNull Set<Integer> visibleToPermissions) {
+        @NonNull Builder setVisibleToPermissions(@NonNull Set<Integer> visibleToPermissions) {
             Objects.requireNonNull(visibleToPermissions);
             setPropertyLong(PERMISSION_PROPERTY, toLongs(visibleToPermissions));
             return this;
@@ -200,8 +192,7 @@ class VisibilityDocumentV1 extends GenericDocument {
 
         /** Build a {@link VisibilityDocumentV1} */
         @Override
-        @NonNull
-        public VisibilityDocumentV1 build() {
+        public @NonNull VisibilityDocumentV1 build() {
             String[] packageNames = new String[mPackageIdentifiers.size()];
             byte[][] sha256Certs = new byte[mPackageIdentifiers.size()][32];
             int i = 0;
@@ -216,8 +207,7 @@ class VisibilityDocumentV1 extends GenericDocument {
         }
     }
 
-    @NonNull
-    static long[] toLongs(@NonNull Set<Integer> properties) {
+    static long @NonNull [] toLongs(@NonNull Set<Integer> properties) {
         long[] outputs = new long[properties.size()];
         int i = 0;
         for (int property : properties) {
@@ -226,8 +216,7 @@ class VisibilityDocumentV1 extends GenericDocument {
         return outputs;
     }
 
-    @Nullable
-    private static Set<Integer> toInts(@Nullable long[] properties) {
+    private static @Nullable Set<Integer> toInts(long @Nullable [] properties) {
         if (properties == null) {
             return null;
         }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java
index 496b00ba..fc2f2023 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java
@@ -17,8 +17,6 @@ package com.android.server.appsearch.external.localstorage.visibilitystore;
 
 import static android.app.appsearch.AppSearchResult.RESULT_NOT_FOUND;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
@@ -37,7 +35,8 @@ import android.util.Log;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 
-import com.google.android.icing.proto.PersistType;
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
 
 import java.util.Arrays;
 import java.util.Collections;
@@ -87,8 +86,7 @@ public class VisibilityStore {
     private final String mAndroidVOverlayDatabaseName;
 
     /** Create a {@link VisibilityStore} instance to store document visibility settings. */
-    @NonNull
-    public static VisibilityStore createDocumentVisibilityStore(
+    public static @NonNull VisibilityStore createDocumentVisibilityStore(
             @NonNull AppSearchImpl appSearchImpl) throws AppSearchException {
         List<String> cachedSchemaTypes = appSearchImpl.getAllPrefixedSchemaTypes();
         return new VisibilityStore(
@@ -99,9 +97,8 @@ public class VisibilityStore {
     }
 
     /** Create a {@link VisibilityStore} instance to store blob visibility settings. */
-    @NonNull
-    public static VisibilityStore createBlobVisibilityStore(@NonNull AppSearchImpl appSearchImpl)
-            throws AppSearchException {
+    public static @NonNull VisibilityStore createBlobVisibilityStore(
+            @NonNull AppSearchImpl appSearchImpl) throws AppSearchException {
         List<String> cachedBlobNamespaces = appSearchImpl.getAllPrefixedBlobNamespaces();
         return new VisibilityStore(
                 appSearchImpl,
@@ -192,6 +189,7 @@ public class VisibilityStore {
      *     contains schema type's visibility information.
      * @throws AppSearchException on AppSearchImpl error.
      */
+    @SuppressWarnings("deprecation")
     public void setVisibility(@NonNull List<InternalVisibilityConfig> prefixedVisibilityConfigs)
             throws AppSearchException {
         Objects.requireNonNull(prefixedVisibilityConfigs);
@@ -203,6 +201,7 @@ public class VisibilityStore {
             InternalVisibilityConfig prefixedVisibilityConfig = prefixedVisibilityConfigs.get(i);
             InternalVisibilityConfig oldVisibilityConfig =
                     mVisibilityConfigMap.get(prefixedVisibilityConfig.getSchemaType());
+            // TODO(b/394875109) switch to use batchPut
             mAppSearchImpl.putDocument(
                     VISIBILITY_PACKAGE_NAME,
                     mDatabaseName,
@@ -215,6 +214,7 @@ public class VisibilityStore {
             GenericDocument androidVOverlay =
                     VisibilityToDocumentConverter.createAndroidVOverlay(prefixedVisibilityConfig);
             if (androidVOverlay != null) {
+                // TODO(b/394875109) switch to use batchPut
                 mAppSearchImpl.putDocument(
                         VISIBILITY_PACKAGE_NAME,
                         mAndroidVOverlayDatabaseName,
@@ -246,7 +246,7 @@ public class VisibilityStore {
                     prefixedVisibilityConfig.getSchemaType(), prefixedVisibilityConfig);
         }
         // Now that the visibility document has been written. Persist the newly written data.
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+        mAppSearchImpl.persistToDisk(mAppSearchImpl.getConfig().getLightweightPersistType());
     }
 
     /**
@@ -306,8 +306,7 @@ public class VisibilityStore {
     }
 
     /** Gets the {@link InternalVisibilityConfig} for the given prefixed schema type. */
-    @Nullable
-    public InternalVisibilityConfig getVisibility(@NonNull String prefixedSchemaType) {
+    public @Nullable InternalVisibilityConfig getVisibility(@NonNull String prefixedSchemaType) {
         return mVisibilityConfigMap.get(prefixedSchemaType);
     }
 
@@ -379,6 +378,7 @@ public class VisibilityStore {
 
     /** Set the latest version of {@link InternalVisibilityConfig} and its schema to AppSearch. */
     @RequiresNonNull("mAppSearchImpl")
+    @SuppressWarnings("deprecation")
     private void setLatestSchemaAndDocuments(
             @UnderInitialization VisibilityStore this,
             @NonNull List<InternalVisibilityConfig> migratedDocuments)
@@ -424,6 +424,7 @@ public class VisibilityStore {
         for (int i = 0; i < migratedDocuments.size(); i++) {
             InternalVisibilityConfig migratedConfig = migratedDocuments.get(i);
             mVisibilityConfigMap.put(migratedConfig.getSchemaType(), migratedConfig);
+            // TODO(b/394875109) switch to use batchPut
             mAppSearchImpl.putDocument(
                     VISIBILITY_PACKAGE_NAME,
                     mDatabaseName,
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0.java
index f3536f6f..37dff3ba 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0.java
@@ -16,7 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.visibilitystore;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
@@ -29,6 +28,8 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -121,8 +122,7 @@ public class VisibilityStoreMigrationHelperFromV0 {
      * @param databaseName Database to which the visibility doc refers.
      * @return deprecated visibility document's id.
      */
-    @NonNull
-    static String getDeprecatedVisibilityDocumentId(
+    static @NonNull String getDeprecatedVisibilityDocumentId(
             @NonNull String packageName, @NonNull String databaseName) {
         return DEPRECATED_ID_PREFIX + PrefixUtil.createPrefix(packageName, databaseName);
     }
@@ -172,8 +172,7 @@ public class VisibilityStoreMigrationHelperFromV0 {
      *
      * @param visibilityDocumentV0s The deprecated Visibility Document we found.
      */
-    @NonNull
-    static List<VisibilityDocumentV1> toVisibilityDocumentV1(
+    static @NonNull List<VisibilityDocumentV1> toVisibilityDocumentV1(
             @NonNull List<GenericDocument> visibilityDocumentV0s) {
         Map<String, VisibilityDocumentV1.Builder> documentBuilderMap = new ArrayMap<>();
 
@@ -247,8 +246,7 @@ public class VisibilityStoreMigrationHelperFromV0 {
         return false;
     }
 
-    @NonNull
-    private static VisibilityDocumentV1.Builder getOrCreateBuilder(
+    private static VisibilityDocumentV1.@NonNull Builder getOrCreateBuilder(
             @NonNull Map<String, VisibilityDocumentV1.Builder> documentBuilderMap,
             @NonNull String schemaType) {
         VisibilityDocumentV1.Builder builder = documentBuilderMap.get(schemaType);
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1.java
index c43acb7f..07e7cc39 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1.java
@@ -16,7 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.visibilitystore;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.InternalVisibilityConfig;
 import android.app.appsearch.PackageIdentifier;
@@ -28,6 +27,8 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 
+import org.jspecify.annotations.NonNull;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -89,8 +90,7 @@ public class VisibilityStoreMigrationHelperFromV1 {
      *
      * @param visibilityDocumentV1s The deprecated Visibility Document we found.
      */
-    @NonNull
-    static List<InternalVisibilityConfig> toVisibilityDocumentsV2(
+    static @NonNull List<InternalVisibilityConfig> toVisibilityDocumentsV2(
             @NonNull List<VisibilityDocumentV1> visibilityDocumentV1s) {
         List<InternalVisibilityConfig> latestVisibilityDocuments =
                 new ArrayList<>(visibilityDocumentV1s.size());
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityToDocumentConverter.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityToDocumentConverter.java
index b80c4d42..2d55b372 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityToDocumentConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityToDocumentConverter.java
@@ -16,8 +16,6 @@
 
 package com.android.server.appsearch.external.localstorage.visibilitystore;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.InternalVisibilityConfig;
@@ -34,6 +32,9 @@ import com.google.android.appsearch.proto.VisibleToPermissionProto;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.InvalidProtocolBufferException;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
@@ -182,8 +183,7 @@ public class VisibilityToDocumentConverter {
      * @param androidVOverlayDocument a {@link GenericDocument} holding visibility properties in
      *     {@link #ANDROID_V_OVERLAY_SCHEMA}
      */
-    @NonNull
-    public static InternalVisibilityConfig createInternalVisibilityConfig(
+    public static @NonNull InternalVisibilityConfig createInternalVisibilityConfig(
             @NonNull GenericDocument visibilityDocument,
             @Nullable GenericDocument androidVOverlayDocument) {
         Objects.requireNonNull(visibilityDocument);
@@ -241,8 +241,7 @@ public class VisibilityToDocumentConverter {
      *     than publiclyVisibleTargetPackage.
      * @param androidVOverlayProto the proto containing post-V visibility settings
      */
-    @NonNull
-    private static SchemaVisibilityConfig createVisibilityConfig(
+    private static @NonNull SchemaVisibilityConfig createVisibilityConfig(
             @NonNull GenericDocument visibilityDocument,
             @Nullable AndroidVOverlayProto androidVOverlayProto) {
         Objects.requireNonNull(visibilityDocument);
@@ -292,8 +291,7 @@ public class VisibilityToDocumentConverter {
     }
 
     /** Convert {@link VisibilityConfigProto} into {@link SchemaVisibilityConfig}. */
-    @NonNull
-    public static SchemaVisibilityConfig convertVisibilityConfigFromProto(
+    public static @NonNull SchemaVisibilityConfig convertVisibilityConfigFromProto(
             @NonNull VisibilityConfigProto proto) {
         SchemaVisibilityConfig.Builder builder = new SchemaVisibilityConfig.Builder();
 
@@ -323,8 +321,7 @@ public class VisibilityToDocumentConverter {
     }
 
     /** Convert {@link SchemaVisibilityConfig} into {@link VisibilityConfigProto}. */
-    @NonNull
-    public static VisibilityConfigProto convertSchemaVisibilityConfigToProto(
+    public static @NonNull VisibilityConfigProto convertSchemaVisibilityConfigToProto(
             @NonNull SchemaVisibilityConfig schemaVisibilityConfig) {
         VisibilityConfigProto.Builder builder = VisibilityConfigProto.newBuilder();
 
@@ -358,8 +355,7 @@ public class VisibilityToDocumentConverter {
      *
      * @param config the configuration to populate into the document
      */
-    @NonNull
-    public static GenericDocument createVisibilityDocument(
+    public static @NonNull GenericDocument createVisibilityDocument(
             @NonNull InternalVisibilityConfig config) {
         GenericDocument.Builder<?> builder =
                 new GenericDocument.Builder<>(
@@ -406,8 +402,7 @@ public class VisibilityToDocumentConverter {
      * Returns the {@link GenericDocument} for the Android V overlay schema if it is provided, null
      * otherwise.
      */
-    @Nullable
-    public static GenericDocument createAndroidVOverlay(
+    public static @Nullable GenericDocument createAndroidVOverlay(
             @NonNull InternalVisibilityConfig internalVisibilityConfig) {
         PackageIdentifier publiclyVisibleTargetPackage =
                 internalVisibilityConfig.getVisibilityConfig().getPubliclyVisibleTargetPackage();
@@ -454,8 +449,7 @@ public class VisibilityToDocumentConverter {
         return androidVOverlayBuilder.build();
     }
 
-    @NonNull
-    private static PackageIdentifierProto convertPackageIdentifierToProto(
+    private static @NonNull PackageIdentifierProto convertPackageIdentifierToProto(
             @NonNull PackageIdentifier packageIdentifier) {
         return PackageIdentifierProto.newBuilder()
                 .setPackageName(packageIdentifier.getPackageName())
@@ -463,8 +457,7 @@ public class VisibilityToDocumentConverter {
                 .build();
     }
 
-    @NonNull
-    private static PackageIdentifier convertPackageIdentifierFromProto(
+    private static @NonNull PackageIdentifier convertPackageIdentifierFromProto(
             @NonNull PackageIdentifierProto packageIdentifierProto) {
         return new PackageIdentifier(
                 packageIdentifierProto.getPackageName(),
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityUtil.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityUtil.java
index 6b2baf53..7ae7a52c 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityUtil.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityUtil.java
@@ -16,8 +16,8 @@
 
 package com.android.server.appsearch.external.localstorage.visibilitystore;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
 
 import java.util.Objects;
 
diff --git a/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceService.java b/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceService.java
index d7c85f9e..e860bc84 100644
--- a/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceService.java
+++ b/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceService.java
@@ -91,15 +91,36 @@ public class IndexerMaintenanceService extends JobService {
             long intervalMillis) {
         Objects.requireNonNull(context);
         Objects.requireNonNull(userHandle);
-        int jobId = getJobIdForUser(userHandle, indexerType);
+        JobInfo jobInfo = createJobInfo(context, userHandle, indexerType, periodic, intervalMillis);
         JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
+        JobInfo pendingJobInfo = jobScheduler.getPendingJob(jobInfo.getId());
+        // Don't reschedule a pending job if the parameters haven't changed.
+        if (jobInfo.equals(pendingJobInfo)) {
+            return;
+        }
+        jobScheduler.schedule(jobInfo);
+        if (LogUtil.DEBUG) {
+            Log.v(TAG, "Scheduled update job " + jobInfo.getId() + " for user " + userHandle);
+        }
+    }
+
+    /**
+     * Creates a {@link JobInfo} with the given parameters.
+     */
+    @VisibleForTesting
+    public static JobInfo createJobInfo(
+            @NonNull Context context,
+            @NonNull UserHandle userHandle,
+            @IndexerType int indexerType,
+            boolean periodic,
+            long intervalMillis) {
+        int jobId = getJobIdForUser(userHandle, indexerType);
         // For devices U and below, we have to schedule using ContactsIndexerMaintenanceService
         // as it has the proper permissions in core/res/AndroidManifest.xml.
         // IndexerMaintenanceService does not have the proper permissions on U. For simplicity, we
         // can also use the same component for scheduling maintenance on U+.
         ComponentName component =
                 new ComponentName(context, ContactsIndexerMaintenanceService.class);
-
         final PersistableBundle extras = new PersistableBundle();
         extras.putInt(EXTRA_USER_ID, userHandle.getIdentifier());
         extras.putInt(INDEXER_TYPE, indexerType);
@@ -109,7 +130,6 @@ public class IndexerMaintenanceService extends JobService {
                         .setRequiresBatteryNotLow(true)
                         .setRequiresDeviceIdle(true)
                         .setPersisted(true);
-
         if (periodic) {
             // Specify a flex value of 1/2 the interval so that the job is scheduled to run
             // in the [interval/2, interval) time window, assuming the other conditions are
@@ -117,16 +137,7 @@ public class IndexerMaintenanceService extends JobService {
             // a short duration of the previous run.
             jobInfoBuilder.setPeriodic(intervalMillis, /* flexMillis= */ intervalMillis / 2);
         }
-        JobInfo jobInfo = jobInfoBuilder.build();
-        JobInfo pendingJobInfo = jobScheduler.getPendingJob(jobId);
-        // Don't reschedule a pending job if the parameters haven't changed.
-        if (jobInfo.equals(pendingJobInfo)) {
-            return;
-        }
-        jobScheduler.schedule(jobInfo);
-        if (LogUtil.DEBUG) {
-            Log.v(TAG, "Scheduled update job " + jobId + " for user " + userHandle);
-        }
+        return jobInfoBuilder.build();
     }
 
     /**
@@ -165,6 +176,32 @@ public class IndexerMaintenanceService extends JobService {
         return jobScheduler.getPendingJob(jobId) != null;
     }
 
+    /**
+     * Check if an update job is scheduled for the given user with the expected parameters.
+     *
+     * @param userHandle The user handle for whom the check for scheduled job needs to be performed
+     * @return true if a scheduled job exists with the expected parameters
+     */
+    public static boolean isUpdateJobScheduledWithExpectedParams(
+            @NonNull Context context,
+            @NonNull UserHandle userHandle,
+            @IndexerType int indexerType,
+            long intervalMillis) {
+        Objects.requireNonNull(context);
+        Objects.requireNonNull(userHandle);
+        int jobId = getJobIdForUser(userHandle, indexerType);
+        JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
+        JobInfo jobInfo = jobScheduler.getPendingJob(jobId);
+        if (jobInfo == null) {
+            return false;
+        }
+        JobInfo periodicJobInfo = createJobInfo(context, userHandle, indexerType, /* periodic= */
+                true, intervalMillis);
+        JobInfo immediateJobInfo = createJobInfo(context, userHandle, indexerType, /* periodic= */
+                false, /* intervalMillis= */ -1);
+        return jobInfo.equals(periodicJobInfo) || jobInfo.equals(immediateJobInfo);
+    }
+
     /**
      * Cancel any scheduled update job for the given user. Checks if a update job for the given user
      * exists before trying to cancel it.
diff --git a/service/java/com/android/server/appsearch/indexer/IndexerSettings.java b/service/java/com/android/server/appsearch/indexer/IndexerSettings.java
index 4bc889a5..79151cad 100644
--- a/service/java/com/android/server/appsearch/indexer/IndexerSettings.java
+++ b/service/java/com/android/server/appsearch/indexer/IndexerSettings.java
@@ -45,6 +45,8 @@ import java.util.Objects;
 public abstract class IndexerSettings {
 
     public static final String LAST_UPDATE_TIMESTAMP_KEY = "last_update_timestamp_millis";
+    public static final String LAST_ATTEMPTED_UPDATE_TIMESTAMP_KEY =
+            "last_attempted_update_timestamp_millis";
 
     private final File mBaseDir;
     private File mFile;
@@ -92,6 +94,7 @@ public abstract class IndexerSettings {
     /** Resets all the settings to default values. */
     public void reset() {
         setLastUpdateTimestampMillis(0);
+        setLastAttemptedUpdateTimestampMillis(0);
     }
 
     /** Static util method to read a bundle from a file. */
@@ -123,4 +126,14 @@ public abstract class IndexerSettings {
             throw e;
         }
     }
+
+    /** Returns the timestamp of when the last update occurred in milliseconds. */
+    public @CurrentTimeMillisLong long getLastAttemptedUpdateTimestampMillis() {
+        return mBundle.getLong(LAST_ATTEMPTED_UPDATE_TIMESTAMP_KEY);
+    }
+
+    /** Sets the timestamp of when the last update occurred in milliseconds. */
+    public void setLastAttemptedUpdateTimestampMillis(@CurrentTimeMillisLong long timestampMillis) {
+        mBundle.putLong(LAST_ATTEMPTED_UPDATE_TIMESTAMP_KEY, timestampMillis);
+    }
 }
diff --git a/service/java/com/android/server/appsearch/isolated_storage_service/IcingSearchEngine.java b/service/java/com/android/server/appsearch/isolated_storage_service/IcingSearchEngine.java
new file mode 100644
index 00000000..f9dc93c3
--- /dev/null
+++ b/service/java/com/android/server/appsearch/isolated_storage_service/IcingSearchEngine.java
@@ -0,0 +1,665 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.isolated_storage_service;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.RemoteException;
+import android.util.Log;
+
+import com.android.isolated_storage_service.IIcingSearchEngine;
+
+import com.google.android.icing.IcingSearchEngineInterface;
+import com.google.android.icing.proto.BatchGetResultProto;
+import com.google.android.icing.proto.BatchPutResultProto;
+import com.google.android.icing.proto.BlobProto;
+import com.google.android.icing.proto.DebugInfoResultProto;
+import com.google.android.icing.proto.DebugInfoVerbosity;
+import com.google.android.icing.proto.DeleteByNamespaceResultProto;
+import com.google.android.icing.proto.DeleteByQueryResultProto;
+import com.google.android.icing.proto.DeleteBySchemaTypeResultProto;
+import com.google.android.icing.proto.DeleteResultProto;
+import com.google.android.icing.proto.DocumentProto;
+import com.google.android.icing.proto.GetAllNamespacesResultProto;
+import com.google.android.icing.proto.GetOptimizeInfoResultProto;
+import com.google.android.icing.proto.GetResultProto;
+import com.google.android.icing.proto.GetResultSpecProto;
+import com.google.android.icing.proto.GetSchemaResultProto;
+import com.google.android.icing.proto.GetSchemaTypeResultProto;
+import com.google.android.icing.proto.IcingSearchEngineOptions;
+import com.google.android.icing.proto.InitializeResultProto;
+import com.google.android.icing.proto.OptimizeResultProto;
+import com.google.android.icing.proto.PersistToDiskResultProto;
+import com.google.android.icing.proto.PersistType;
+import com.google.android.icing.proto.PropertyProto;
+import com.google.android.icing.proto.PutDocumentRequest;
+import com.google.android.icing.proto.PutResultProto;
+import com.google.android.icing.proto.ReportUsageResultProto;
+import com.google.android.icing.proto.ResetResultProto;
+import com.google.android.icing.proto.ResultSpecProto;
+import com.google.android.icing.proto.SchemaProto;
+import com.google.android.icing.proto.ScoringSpecProto;
+import com.google.android.icing.proto.SearchResultProto;
+import com.google.android.icing.proto.SearchSpecProto;
+import com.google.android.icing.proto.SetSchemaRequestProto;
+import com.google.android.icing.proto.SetSchemaResultProto;
+import com.google.android.icing.proto.StatusProto;
+import com.google.android.icing.proto.StorageInfoResultProto;
+import com.google.android.icing.proto.SuggestionResponse;
+import com.google.android.icing.proto.SuggestionSpecProto;
+import com.google.android.icing.proto.UsageReport;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+
+import java.util.Objects;
+import java.util.function.Function;
+
+/** Icing engine backed by the isolated storage service. */
+public final class IcingSearchEngine implements IcingSearchEngineInterface {
+    private static final String TAG = "IcingSearchEngine";
+
+    private final IIcingSearchEngine mEngine;
+    private final IcingSearchEngineOptions mOptions;
+
+    /** Enforces singleton class pattern. */
+    public IcingSearchEngine(
+            @NonNull IIcingSearchEngine engine, @NonNull IcingSearchEngineOptions options) {
+        Log.d(TAG, "constructing");
+        mEngine = Objects.requireNonNull(engine);
+        mOptions = Objects.requireNonNull(options);
+    }
+
+    @Override
+    public void close() {
+        Log.d(TAG, "closing");
+        try {
+            mEngine.close();
+        } catch (RemoteException e) {
+            Log.e(TAG, "failed to call close", e);
+        }
+    }
+
+    @NonNull
+    @Override
+    public InitializeResultProto initialize() {
+        byte[] resultData;
+        try {
+            resultData = mEngine.initialize(mOptions.toByteArray());
+        } catch (RemoteException e) {
+            return InitializeResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                InitializeResultProto.getDefaultInstance(),
+                status -> InitializeResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public SetSchemaResultProto setSchema(@NonNull SchemaProto schema) {
+        byte[] resultData;
+        try {
+            resultData =
+                    mEngine.setSchema(
+                            schema.toByteArray(), /* ignoreErrorsAndDeleteDocuments= */ false);
+        } catch (RemoteException e) {
+            return SetSchemaResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                SetSchemaResultProto.getDefaultInstance(),
+                status -> SetSchemaResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public SetSchemaResultProto setSchema(
+            @NonNull SchemaProto schema, boolean ignoreErrorsAndDeleteDocuments) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.setSchema(schema.toByteArray(), ignoreErrorsAndDeleteDocuments);
+        } catch (RemoteException e) {
+            return SetSchemaResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                SetSchemaResultProto.getDefaultInstance(),
+                status -> SetSchemaResultProto.newBuilder().setStatus(status).build());
+    }
+
+    /**
+     * Sets the schema for the icing instance.
+     *
+     * @param setSchemaRequest the request proto for setting the schema.
+     */
+    public SetSchemaResultProto setSchemaWithRequestProto(SetSchemaRequestProto setSchemaRequest) {
+        // TODO(b/337913932): have vm version support this api.
+        throw new UnsupportedOperationException(
+                "setSchemaWithRequestProto is temporarily unsupported.");
+    }
+
+    @NonNull
+    @Override
+    public GetSchemaResultProto getSchema() {
+        byte[] resultData;
+        try {
+            resultData = mEngine.getSchema();
+        } catch (RemoteException e) {
+            return GetSchemaResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                GetSchemaResultProto.getDefaultInstance(),
+                status -> GetSchemaResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public GetSchemaResultProto getSchemaForDatabase(@NonNull String database) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.getSchemaForDatabase(database);
+        } catch (RemoteException e) {
+            return GetSchemaResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                GetSchemaResultProto.getDefaultInstance(),
+                status -> GetSchemaResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public GetSchemaTypeResultProto getSchemaType(@NonNull String schemaType) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.getSchemaType(schemaType);
+        } catch (RemoteException e) {
+            return GetSchemaTypeResultProto.newBuilder()
+                    .setStatus(remoteExceptionStatus(e))
+                    .build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                GetSchemaTypeResultProto.getDefaultInstance(),
+                status -> GetSchemaTypeResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public PutResultProto put(@NonNull DocumentProto document) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.put(document.toByteArray());
+        } catch (RemoteException e) {
+            return PutResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                PutResultProto.getDefaultInstance(),
+                status -> PutResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public BatchPutResultProto batchPut(@NonNull PutDocumentRequest putDocumentRequest) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.batchPut(putDocumentRequest.toByteArray());
+        } catch (RemoteException e) {
+            return BatchPutResultProto.newBuilder()
+                    // TODO(b/401245113) set status when the change is available.
+                    // .setStatus(remoteExceptionStatus(e))
+                    .build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                BatchPutResultProto.getDefaultInstance(),
+                status ->
+                        BatchPutResultProto.newBuilder()
+                                // TODO(b/401245113) set status when the change is available.
+                                // .setStatus(status)
+                                .build());
+    }
+
+    @NonNull
+    @Override
+    public GetResultProto get(
+            @NonNull String namespace,
+            @NonNull String uri,
+            @NonNull GetResultSpecProto getResultSpec) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.get(namespace, uri, getResultSpec.toByteArray());
+        } catch (RemoteException e) {
+            return GetResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                GetResultProto.getDefaultInstance(),
+                status -> GetResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public BatchGetResultProto batchGet(@NonNull GetResultSpecProto getResultSpec) {
+        // TODO(b/396144272): Implement this
+        throw new UnsupportedOperationException("Not implemented yet.");
+    }
+
+    @NonNull
+    @Override
+    public ReportUsageResultProto reportUsage(@NonNull UsageReport usageReport) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.reportUsage(usageReport.toByteArray());
+        } catch (RemoteException e) {
+            return ReportUsageResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                ReportUsageResultProto.getDefaultInstance(),
+                status -> ReportUsageResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public GetAllNamespacesResultProto getAllNamespaces() {
+        byte[] resultData;
+        try {
+            resultData = mEngine.getAllNamespaces();
+        } catch (RemoteException e) {
+            return GetAllNamespacesResultProto.newBuilder()
+                    .setStatus(remoteExceptionStatus(e))
+                    .build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                GetAllNamespacesResultProto.getDefaultInstance(),
+                status -> GetAllNamespacesResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public SearchResultProto search(
+            @NonNull SearchSpecProto searchSpec,
+            @NonNull ScoringSpecProto scoringSpec,
+            @NonNull ResultSpecProto resultSpec) {
+        byte[] resultData;
+        try {
+            resultData =
+                    mEngine.search(
+                            searchSpec.toByteArray(),
+                            scoringSpec.toByteArray(),
+                            resultSpec.toByteArray());
+        } catch (RemoteException e) {
+            return SearchResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                SearchResultProto.getDefaultInstance(),
+                status -> SearchResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public SearchResultProto getNextPage(long nextPageToken) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.getNextPage(nextPageToken);
+        } catch (RemoteException e) {
+            return SearchResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                SearchResultProto.getDefaultInstance(),
+                status -> SearchResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @Override
+    public void invalidateNextPageToken(long nextPageToken) {
+        try {
+            mEngine.invalidateNextPageToken(nextPageToken);
+        } catch (RemoteException e) {
+            Log.e(TAG, "failed to call invalidateNextPageToken", e);
+        }
+    }
+
+    @NonNull
+    @Override
+    public BlobProto openWriteBlob(@NonNull PropertyProto.BlobHandleProto blobHandle) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.openWriteBlob(blobHandle.toByteArray());
+        } catch (RemoteException e) {
+            return BlobProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                BlobProto.getDefaultInstance(),
+                status -> BlobProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public BlobProto removeBlob(@NonNull PropertyProto.BlobHandleProto blobHandle) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.removeBlob(blobHandle.toByteArray());
+        } catch (RemoteException e) {
+            return BlobProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                BlobProto.getDefaultInstance(),
+                status -> BlobProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public BlobProto openReadBlob(@NonNull PropertyProto.BlobHandleProto blobHandle) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.openReadBlob(blobHandle.toByteArray());
+        } catch (RemoteException e) {
+            return BlobProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                BlobProto.getDefaultInstance(),
+                status -> BlobProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public BlobProto commitBlob(@NonNull PropertyProto.BlobHandleProto blobHandle) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.commitBlob(blobHandle.toByteArray());
+        } catch (RemoteException e) {
+            return BlobProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                BlobProto.getDefaultInstance(),
+                status -> BlobProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public DeleteResultProto delete(@NonNull String namespace, @NonNull String uri) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.deleteDoc(namespace, uri);
+        } catch (RemoteException e) {
+            return DeleteResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                DeleteResultProto.getDefaultInstance(),
+                status -> DeleteResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public SuggestionResponse searchSuggestions(@NonNull SuggestionSpecProto suggestionSpec) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.searchSuggestions(suggestionSpec.toByteArray());
+        } catch (RemoteException e) {
+            return SuggestionResponse.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                SuggestionResponse.getDefaultInstance(),
+                status -> SuggestionResponse.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public DeleteByNamespaceResultProto deleteByNamespace(@NonNull String namespace) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.deleteByNamespace(namespace);
+        } catch (RemoteException e) {
+            return DeleteByNamespaceResultProto.newBuilder()
+                    .setStatus(remoteExceptionStatus(e))
+                    .build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                DeleteByNamespaceResultProto.getDefaultInstance(),
+                status -> DeleteByNamespaceResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public DeleteBySchemaTypeResultProto deleteBySchemaType(@NonNull String schemaType) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.deleteBySchemaType(schemaType);
+        } catch (RemoteException e) {
+            return DeleteBySchemaTypeResultProto.newBuilder()
+                    .setStatus(remoteExceptionStatus(e))
+                    .build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                DeleteBySchemaTypeResultProto.getDefaultInstance(),
+                status -> DeleteBySchemaTypeResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public DeleteByQueryResultProto deleteByQuery(@NonNull SearchSpecProto searchSpec) {
+        byte[] resultData;
+        try {
+            resultData =
+                    mEngine.deleteByQuery(
+                            searchSpec.toByteArray(), /* returnDeletedDocumentInfo= */ false);
+        } catch (RemoteException e) {
+            return DeleteByQueryResultProto.newBuilder()
+                    .setStatus(remoteExceptionStatus(e))
+                    .build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                DeleteByQueryResultProto.getDefaultInstance(),
+                status -> DeleteByQueryResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public DeleteByQueryResultProto deleteByQuery(
+            @NonNull SearchSpecProto searchSpec, boolean returnDeletedDocumentInfo) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.deleteByQuery(searchSpec.toByteArray(), returnDeletedDocumentInfo);
+        } catch (RemoteException e) {
+            return DeleteByQueryResultProto.newBuilder()
+                    .setStatus(remoteExceptionStatus(e))
+                    .build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                DeleteByQueryResultProto.getDefaultInstance(),
+                status -> DeleteByQueryResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public PersistToDiskResultProto persistToDisk(@NonNull PersistType.Code persistTypeCode) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.persistToDisk(persistTypeCode.getNumber());
+        } catch (RemoteException e) {
+            return PersistToDiskResultProto.newBuilder()
+                    .setStatus(remoteExceptionStatus(e))
+                    .build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                PersistToDiskResultProto.getDefaultInstance(),
+                status -> PersistToDiskResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public OptimizeResultProto optimize() {
+        byte[] resultData;
+        try {
+            resultData = mEngine.optimize();
+        } catch (RemoteException e) {
+            return OptimizeResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                OptimizeResultProto.getDefaultInstance(),
+                status -> OptimizeResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public GetOptimizeInfoResultProto getOptimizeInfo() {
+        byte[] resultData;
+        try {
+            resultData = mEngine.getOptimizeInfo();
+        } catch (RemoteException e) {
+            return GetOptimizeInfoResultProto.newBuilder()
+                    .setStatus(remoteExceptionStatus(e))
+                    .build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                GetOptimizeInfoResultProto.getDefaultInstance(),
+                status -> GetOptimizeInfoResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public StorageInfoResultProto getStorageInfo() {
+        byte[] resultData;
+        try {
+            resultData = mEngine.getStorageInfo();
+        } catch (RemoteException e) {
+            return StorageInfoResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                StorageInfoResultProto.getDefaultInstance(),
+                status -> StorageInfoResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public DebugInfoResultProto getDebugInfo(@NonNull DebugInfoVerbosity.Code verbosity) {
+        byte[] resultData;
+        try {
+            resultData = mEngine.getDebugInfo(verbosity.getNumber());
+        } catch (RemoteException e) {
+            return DebugInfoResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                DebugInfoResultProto.getDefaultInstance(),
+                status -> DebugInfoResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public ResetResultProto reset() {
+        byte[] resultData;
+        try {
+            resultData = mEngine.reset();
+        } catch (RemoteException e) {
+            return ResetResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                ResetResultProto.getDefaultInstance(),
+                status -> ResetResultProto.newBuilder().setStatus(status).build());
+    }
+
+    private static @NonNull <M extends MessageLite> M getResponseProtoFromRawData(
+            @Nullable byte[] result,
+            @NonNull M defaultInstance,
+            @NonNull Function<StatusProto, M> createResponseWithStatus) {
+        M resultProto = defaultInstance;
+        if (result == null) return resultProto;
+
+        try {
+            resultProto = parseData(resultProto, result);
+        } catch (InvalidProtocolBufferException e) {
+            return createResponseWithStatus.apply(protoParseFailureStatus(e));
+        }
+
+        return resultProto;
+    }
+
+    private static @NonNull <M extends MessageLite> M parseData(
+            @NonNull M defaultInstance, @NonNull byte[] data)
+            throws InvalidProtocolBufferException {
+        @SuppressWarnings("unchecked") // valid by protobuf contract
+        Parser<M> parser = (Parser<M>) defaultInstance.getParserForType();
+        return parser.parseFrom(data);
+    }
+
+    private static @NonNull StatusProto remoteExceptionStatus(@NonNull Exception e) {
+        Log.e(TAG, "Failed to call isolated storage service via binder", e);
+        return StatusProto.newBuilder()
+                .setCode(StatusProto.Code.INTERNAL)
+                .setMessage("failed to call isolated storage service via binder: " + e.getMessage())
+                .build();
+    }
+
+    private static @NonNull StatusProto protoParseFailureStatus(@NonNull Exception e) {
+        Log.e(TAG, "Failed to parse proto data", e);
+        return StatusProto.newBuilder()
+                .setCode(StatusProto.Code.INTERNAL)
+                .setMessage("failed to parse proto data: " + e.getMessage())
+                .build();
+    }
+}
diff --git a/service/java/com/android/server/appsearch/isolated_storage_service/IsolatedStorageServiceManager.java b/service/java/com/android/server/appsearch/isolated_storage_service/IsolatedStorageServiceManager.java
new file mode 100644
index 00000000..5ff1ac71
--- /dev/null
+++ b/service/java/com/android/server/appsearch/isolated_storage_service/IsolatedStorageServiceManager.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.isolated_storage_service;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.WorkerThread;
+import android.app.appsearch.util.ExceptionUtil;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.os.Build;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.system.virtualmachine.VirtualMachine;
+import android.system.virtualmachine.VirtualMachineManager;
+import android.util.ArrayMap;
+import android.util.Log;
+
+import com.android.appsearch.flags.Flags;
+import com.android.internal.annotations.GuardedBy;
+import com.android.server.appsearch.ServiceAppSearchConfig;
+
+import com.google.android.icing.IcingSearchEngineInterface;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+
+/** Manages the isolated storage service and provides related services. */
+public final class IsolatedStorageServiceManager {
+    private static final String TAG = "IsolatedStorageServiceM";
+
+    // TODO: b/389105038 - remove the temporary workaround for binder transaction limit.
+    // Binder RPC max transaction allocation is 600 KiB. We use 512 KiB here since the current
+    // max doc size is 512 KiB, and also leave some room for non-page fields in the response protos.
+    public static final int DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE = 512 * 1024;
+
+    public static final String SYSTEM_PROPERTY_ENABLE_ISOLATED_STORAGE =
+            "ro.appsearch.feature.enable_isolated_storage";
+    public static final long DEFAULT_MEMORY_BYTES = 1_000_000_000;
+    private static final String ISOLATED_STORAGE_SERVICE =
+            "com.android.appsearch.ISOLATED_STORAGE_SERVICE";
+    private static final String ISOLATED_STORAGE_SERVICE_CLASS_NAME =
+            "com.android.server.appsearch.isolated_storage_service.IsolatedStorageService";
+    private static final int FUTURE_WAIT_TIMEOUT_SECONDS = 5;
+
+    private final Context mContext;
+    private final ServiceAppSearchConfig mAppSearchConfig;
+
+    // The isolated storage service implemented by the apk to manage VM and pass VM connections.
+    private IIsolatedStorageService mIsolatedStorageService;
+    // The isolated storage service implemented by the VM to access icing.
+    private com.android.isolated_storage_service.IIsolatedStorageService mVmIsolatedStorageService;
+
+    @GuardedBy("mIcingInstancesLocked")
+    private final Map<UserHandle, IcingSearchEngineInterface> mIcingInstancesLocked =
+            new ArrayMap<>();
+
+    public IsolatedStorageServiceManager(
+            @NonNull Context context, @NonNull ServiceAppSearchConfig appSearchConfig) {
+        mContext = Objects.requireNonNull(context);
+        mAppSearchConfig = Objects.requireNonNull(appSearchConfig);
+    }
+
+    /** Gets whether isolated storage should be used. */
+    public static boolean useIsolatedStorage(Context context) {
+        return isolatedStorageFlagsSet() && deviceSupportsVmsAndNewApis(context);
+    }
+
+    /** Gets whether isolated storage flags are all set. */
+    public static boolean isolatedStorageFlagsSet() {
+        return Flags.enableIsolatedStorage()
+                && SystemProperties.getBoolean(
+                        SYSTEM_PROPERTY_ENABLE_ISOLATED_STORAGE, /* def= */ false);
+    }
+
+    /** Checks whether the device supports protect VMs, and new FD->IBinder VM APIs. */
+    private static boolean deviceSupportsVmsAndNewApis(Context context) {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.BAKLAVA) {
+            Log.i(
+                    TAG,
+                    "API level too low to support isolated storage service: "
+                            + Build.VERSION.SDK_INT);
+            return false;
+        }
+        VirtualMachineManager vmm = context.getSystemService(VirtualMachineManager.class);
+        // Devices that support AVF are not required to support protected VMs.
+        return (vmm != null)
+                && ((vmm.getCapabilities() & VirtualMachineManager.CAPABILITY_PROTECTED_VM) != 0);
+    }
+
+    /** Starts the isolated storage service if not already. */
+    @WorkerThread
+    public void startIsolatedStorageService() {
+        if (mIsolatedStorageService != null) {
+            return;
+        }
+
+        String packageName = maybeGetPackageName(mContext);
+        if (packageName == null) {
+            return;
+        }
+
+        Intent intent = new Intent();
+        intent.setClassName(packageName, ISOLATED_STORAGE_SERVICE_CLASS_NAME);
+        CompletableFuture<Void> future = new CompletableFuture<>();
+        mContext.bindServiceAsUser(
+                intent,
+                new IsolatedStorageServiceConnection(future),
+                Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT,
+                UserHandle.SYSTEM);
+        try {
+            future.get(FUTURE_WAIT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
+        } catch (Exception e) {
+            Log.e(TAG, "Unable to bind to " + ISOLATED_STORAGE_SERVICE, e);
+            ExceptionUtil.handleException(e);
+            return;
+        }
+        if (mIsolatedStorageService == null) {
+            return;
+        }
+        waitForVmPayloadReady();
+        try {
+            IBinder iBinder =
+                    VirtualMachine.binderFromPreconnectedClient(
+                            () -> {
+                                try {
+                                    return mIsolatedStorageService.getVmConnection();
+                                } catch (RemoteException e) {
+                                    Log.e(TAG, "Unable to get vm connection", e);
+                                    throw new RuntimeException(e);
+                                }
+                            });
+            mVmIsolatedStorageService =
+                    com.android.isolated_storage_service.IIsolatedStorageService.Stub.asInterface(
+                            iBinder);
+        } catch (Exception e) {
+            Log.e(TAG, "Unable to connect to vm", e);
+            ExceptionUtil.handleException(e);
+        }
+    }
+
+    /**
+     * Gets the package name via service action name.
+     *
+     * <p>Return {@code null} if service not found.
+     */
+    private static @Nullable String maybeGetPackageName(@NonNull Context context) {
+        Objects.requireNonNull(context);
+
+        PackageManager pm = context.getPackageManager();
+        Intent serviceIntent = new Intent(ISOLATED_STORAGE_SERVICE);
+        List<ResolveInfo> resolveInfos =
+                pm.queryIntentServices(
+                        serviceIntent,
+                        // Matches services from system applications that are direct boot aware
+                        // or unaware.
+                        PackageManager.GET_SERVICES
+                                | PackageManager.MATCH_SYSTEM_ONLY
+                                | PackageManager.MATCH_DIRECT_BOOT_AWARE
+                                | PackageManager.MATCH_DIRECT_BOOT_UNAWARE);
+        if (resolveInfos.isEmpty()) {
+            Log.e(TAG, "Service " + ISOLATED_STORAGE_SERVICE + " not found");
+            return null;
+        }
+        return resolveInfos.get(0).serviceInfo.packageName;
+    }
+
+    private void waitForVmPayloadReady() {
+        try {
+            mIsolatedStorageService.setup(createServiceConfig());
+        } catch (RemoteException e) {
+            Log.e(TAG, "Unable to wait for pVM to be ready", e);
+            ExceptionUtil.handleRemoteException(e);
+        }
+    }
+
+    private ServiceConfig createServiceConfig() {
+        ServiceConfig config = new ServiceConfig();
+        config.pVmMemoryBytes = mAppSearchConfig.getIsolatedStorageMemoryBytes();
+        config.pCachedSamplingInterval = mAppSearchConfig.getCachedSamplingIntervalDefault();
+        config.pCachedMinTimeIntervalBetweenSamplesMillis =
+                mAppSearchConfig.getCachedMinTimeIntervalBetweenSamplesMillis();
+        return config;
+    }
+
+    /** Gets isolated storage backed icing instance for user. */
+    @WorkerThread
+    public @Nullable IcingSearchEngineInterface getIcingInstance(
+            @NonNull UserHandle userHandle, @NonNull ServiceAppSearchConfig config) {
+        Objects.requireNonNull(userHandle);
+        Objects.requireNonNull(config);
+
+        if (mIsolatedStorageService == null) {
+            return null;
+        }
+
+        IcingSearchEngineInterface instance;
+        synchronized (mIcingInstancesLocked) {
+            instance = mIcingInstancesLocked.get(userHandle);
+            if (instance == null) {
+                Log.i(TAG, "getting isolated icing instance for user " + userHandle);
+                try {
+                    instance =
+                            new IcingSearchEngine(
+                                    mVmIsolatedStorageService.getOrCreateIcingConnection(
+                                            userHandle.getIdentifier()),
+                                    config.toIcingSearchEngineOptions(/* baseDir= */ "appsearch"));
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Unable to get icing instance for " + userHandle, e);
+                    ExceptionUtil.handleRemoteException(e);
+                }
+
+                if (instance != null) {
+                    mIcingInstancesLocked.put(userHandle, instance);
+                }
+            }
+        }
+        return instance;
+    }
+
+    /** A connection to the isolated storage service. */
+    private class IsolatedStorageServiceConnection implements ServiceConnection {
+        private final CompletableFuture<Void> mFuture;
+
+        IsolatedStorageServiceConnection(@NonNull CompletableFuture<Void> future) {
+            mFuture = Objects.requireNonNull(future);
+        }
+
+        @Override
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            mIsolatedStorageService = IIsolatedStorageService.Stub.asInterface(service);
+            Log.i(TAG, "IsolatedStorageService connected");
+            mFuture.complete(null);
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName className) {
+            Log.i(TAG, "IsolatedStorageService disconnected");
+            mIsolatedStorageService = null;
+            mFuture.cancel(/* mayInterruptIfRunning= */ true);
+        }
+
+        @Override
+        public void onBindingDied(ComponentName className) {
+            Log.i(TAG, "IsolatedStorageService binding died");
+            mIsolatedStorageService = null;
+            mFuture.cancel(/* mayInterruptIfRunning= */ true);
+        }
+
+        @Override
+        public void onNullBinding(ComponentName className) {
+            Log.i(TAG, "IsolatedStorageService null binding");
+            mIsolatedStorageService = null;
+            mFuture.cancel(/* mayInterruptIfRunning= */ true);
+        }
+    }
+}
diff --git a/service/java/com/android/server/appsearch/stats/PlatformLogger.java b/service/java/com/android/server/appsearch/stats/PlatformLogger.java
index 0c7f2bb4..91ca1809 100644
--- a/service/java/com/android/server/appsearch/stats/PlatformLogger.java
+++ b/service/java/com/android/server/appsearch/stats/PlatformLogger.java
@@ -293,7 +293,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                     stats.getEstimatedBinderLatencyMillis(),
                     stats.getNumOperationsSucceeded(),
                     stats.getNumOperationsFailed(),
-                    numReportedCalls);
+                    numReportedCalls,
+                    stats.getEnabledFeatures());
         } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
             // TODO(b/184204720) report hashing error to statsd
             //  We need to set a special value(e.g. 0xFFFFFFFF) for the hashing of the database,
@@ -342,7 +343,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                     stats.getGetOldSchemaLatencyMillis(),
                     stats.getGetObserverLatencyMillis(),
                     stats.getPreparingChangeNotificationLatencyMillis(),
-                    stats.getSchemaMigrationCallType());
+                    stats.getSchemaMigrationCallType(),
+                    stats.getEnabledFeatures());
         } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
             // TODO(b/184204720) report hashing error to statsd
             //  We need to set a special value(e.g. 0xFFFFFFFF) for the hashing of the database,
@@ -367,11 +369,12 @@ public final class PlatformLogger implements InternalAppSearchLogger {
             int hashCodeForDatabase = StatsUtil.calculateHashCodeMd5(database);
             // ignore close exception
             AppSearchStatsLog.write(
-                    AppSearchStatsLog.APP_SEARCH_SET_SCHEMA_STATS_REPORTED,
+                    AppSearchStatsLog.APP_SEARCH_SCHEMA_MIGRATION_STATS_REPORTED,
                     extraStats.mSamplingInterval,
                     extraStats.mSkippedSampleCount,
                     extraStats.mPackageUid,
                     hashCodeForDatabase,
+                    stats.getStatusCode(),
                     stats.getTotalLatencyMillis(),
                     stats.getGetSchemaLatencyMillis(),
                     stats.getQueryAndTransformLatencyMillis(),
@@ -418,7 +421,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                     stats.getNativeIndexMergeLatencyMillis(),
                     stats.getNativeDocumentSizeBytes(),
                     stats.getNativeNumTokensIndexed(),
-                    /* nativeExceededMaxNumTokens= */ false /* Deprecated and removed */);
+                    /* nativeExceededMaxNumTokens= */ false /* Deprecated and removed */,
+                    stats.getEnabledFeatures());
         } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
             // TODO(b/184204720) report hashing error to statsd
             //  We need to set a special value(e.g. 0xFFFFFFFF) for the hashing of the database,
@@ -476,7 +480,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                     stats.getJoinType(),
                     stats.getNumJoinedResultsCurrentPage(),
                     stats.getJoinLatencyMillis(),
-                    hashCodeForSearchSourceLogTag);
+                    hashCodeForSearchSourceLogTag,
+                    stats.getEnabledFeatures());
         } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
             // TODO(b/184204720) report hashing error to statsd
             //  We need to set a special value(e.g. 0xFFFFFFFF) for the hashing of the database,
@@ -516,7 +521,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                 stats.getDocumentCount(),
                 stats.getSchemaTypeCount(),
                 stats.hasReset(),
-                stats.getResetStatusCode());
+                stats.getResetStatusCode(),
+                stats.getEnabledFeatures());
     }
 
     @GuardedBy("mLock")
@@ -538,7 +544,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                 stats.getExpiredDocumentCount(),
                 stats.getStorageSizeBeforeBytes(),
                 stats.getStorageSizeAfterBytes(),
-                stats.getTimeSinceLastOptimizeMillis());
+                stats.getTimeSinceLastOptimizeMillis(),
+                stats.getEnabledFeatures());
     }
 
     @GuardedBy("mLock")
@@ -578,6 +585,7 @@ public final class PlatformLogger implements InternalAppSearchLogger {
         int[] clicksResultRankGlobal = new int[clicksStats.size()];
         int numClicks = clicksStats.size();
         int numGoodClicks = 0;
+        long enabledFeatures = searchIntentStats.getEnabledFeatures();
         for (int i = 0; i < clicksStats.size(); ++i) {
             ClickStats clickStats = clicksStats.get(i);
 
@@ -614,7 +622,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                 clicksTimestampMillis,
                 clicksTimeStayOnResultMillis,
                 clicksResultRankInBlock,
-                clicksResultRankGlobal);
+                clicksResultRankGlobal,
+                enabledFeatures);
 
         // Only log restricted atoms for QUERY_CORRECTION_TYPE_ABANDONMENT to catch query correction
         // for common synonyms, abbreviation, nicknames and rebranded names, e.g. "Robert" -> "Bob".
@@ -634,7 +643,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                     searchIntentStats.getNumResultsFetched(),
                     numClicks,
                     numGoodClicks,
-                    searchIntentStats.getQueryCorrectionType());
+                    searchIntentStats.getQueryCorrectionType(),
+                    enabledFeatures);
         }
     }
 
diff --git a/service/java/com/android/server/appsearch/stats/StatsCollector.java b/service/java/com/android/server/appsearch/stats/StatsCollector.java
index 84305ac4..911f6c58 100644
--- a/service/java/com/android/server/appsearch/stats/StatsCollector.java
+++ b/service/java/com/android/server/appsearch/stats/StatsCollector.java
@@ -21,6 +21,7 @@ import android.annotation.Nullable;
 import android.annotation.UserIdInt;
 import android.app.StatsManager;
 import android.app.appsearch.exceptions.AppSearchException;
+import android.app.appsearch.stats.BaseStats;
 import android.app.appsearch.util.ExceptionUtil;
 import android.app.appsearch.util.LogUtil;
 import android.content.Context;
@@ -114,9 +115,16 @@ public final class StatsCollector implements StatsManager.StatsPullAtomCallback
             try {
                 AppSearchUserInstance userInstance =
                         userInstanceManager.getUserInstance(userHandle);
+                long enabledFeatures =
+                        new BaseStats.Builder<>()
+                                .setLaunchVMEnabled(userInstance.isVMEnabled())
+                                .build()
+                                .getEnabledFeatures();
                 StorageInfoProto storageInfoProto =
                         userInstance.getAppSearchImpl().getRawStorageInfoProto();
-                data.add(buildStatsEvent(userHandle.getIdentifier(), storageInfoProto));
+                data.add(
+                        buildStatsEvent(
+                                userHandle.getIdentifier(), storageInfoProto, enabledFeatures));
             } catch (AppSearchException | RuntimeException e) {
                 Log.e(TAG, "Failed to pull the storage info for user " + userHandle.toString(), e);
                 ExceptionUtil.handleException(e);
@@ -147,14 +155,17 @@ public final class StatsCollector implements StatsManager.StatsPullAtomCallback
     }
 
     private static StatsEvent buildStatsEvent(
-            @UserIdInt int userId, @NonNull StorageInfoProto storageInfoProto) {
+            @UserIdInt int userId,
+            @NonNull StorageInfoProto storageInfoProto,
+            long enabledFeatures) {
         return AppSearchStatsLog.buildStatsEvent(
                 AppSearchStatsLog.APP_SEARCH_STORAGE_INFO,
                 userId,
                 storageInfoProto.getTotalStorageSize(),
                 getDocumentStorageInfoBytes(storageInfoProto.getDocumentStorageInfo()),
                 getSchemaStoreStorageInfoBytes(storageInfoProto.getSchemaStoreStorageInfo()),
-                getIndexStorageInfoBytes(storageInfoProto.getIndexStorageInfo()));
+                getIndexStorageInfoBytes(storageInfoProto.getIndexStorageInfo()),
+                enabledFeatures);
     }
 
     private static byte[] getDocumentStorageInfoBytes(@NonNull DocumentStorageInfoProto proto) {
diff --git a/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java b/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java
index 87189d47..51783f28 100644
--- a/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java
+++ b/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java
@@ -16,7 +16,6 @@
 package com.android.server.appsearch.visibilitystore;
 
 import static android.Manifest.permission.EXECUTE_APP_FUNCTIONS;
-import static android.Manifest.permission.EXECUTE_APP_FUNCTIONS_TRUSTED;
 import static android.Manifest.permission.PACKAGE_USAGE_STATS;
 import static android.Manifest.permission.READ_ASSISTANT_APP_SEARCH_DATA;
 import static android.Manifest.permission.READ_CALENDAR;
@@ -391,12 +390,12 @@ public class VisibilityCheckerImpl implements VisibilityChecker {
             case SetSchemaRequest.EXECUTE_APP_FUNCTIONS:
                 permission = EXECUTE_APP_FUNCTIONS;
                 break;
-            case SetSchemaRequest.EXECUTE_APP_FUNCTIONS_TRUSTED:
-                permission = EXECUTE_APP_FUNCTIONS_TRUSTED;
-                break;
             case SetSchemaRequest.PACKAGE_USAGE_STATS:
                 permission = PACKAGE_USAGE_STATS;
                 break;
+            case SetSchemaRequest.EXECUTE_APP_FUNCTIONS_TRUSTED:
+                // Deprecated. Returning false as is this permission does not exist.
+                return false;
             default:
                 return false;
         }
diff --git a/service/proguard.flags b/service/proguard.flags
index cd56a804..14b1ab41 100644
--- a/service/proguard.flags
+++ b/service/proguard.flags
@@ -12,7 +12,10 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
--keep class * extends android.app.Service
+# TODO(b/373579455): Evaluate if <init> needs to be kept.
+-keep class * extends android.app.Service {
+  void <init>();
+}
 # Keep the Icing proto methods that are necessary for string formatting since MessageLiteToString
 # uses reflection (setters, getters, and hassers)
 # https://cs.android.com/android/platform/superproject/main/+/main:external/protobuf/java/core/src/main/java/com/google/protobuf/MessageLiteToString.java;l=82;drc=0ccbdeff847ae5390ba6632a67f6b5d2ab8632c1
@@ -35,7 +38,10 @@
 }
 
 # This prevents the obfuscation or removal of fields referenced in native.
--keep class com.google.android.icing.IcingSearchEngineImpl
+# TODO(b/373579455): Evaluate if <init> needs to be kept.
+-keep class com.google.android.icing.IcingSearchEngineImpl {
+  void <init>();
+}
 -keepclassmembers public class com.google.android.icing.IcingSearchEngineImpl {
   private long nativePointer;
   native <methods>;
diff --git a/synced_jetpack_sha.txt b/synced_jetpack_sha.txt
index f9d186e1..b7c22601 100644
--- a/synced_jetpack_sha.txt
+++ b/synced_jetpack_sha.txt
@@ -1 +1 @@
-a9beed7533d5b55322d64520113280e832ff33b6
+b2a9756a09b234e2a59d9dd603a612c7ab35c562
diff --git a/testing/appsindexertests/Android.bp b/testing/appsindexertests/Android.bp
index b1def6e7..205312b4 100644
--- a/testing/appsindexertests/Android.bp
+++ b/testing/appsindexertests/Android.bp
@@ -25,8 +25,10 @@ android_test {
         "CtsAppSearchTestUtils",
         "androidx.test.ext.junit",
         "androidx.test.rules",
-        "appsearch_flags_java_exported_lib",
+        "appsearch_flags_java_lib",
         "compatibility-device-util-axt",
+        "flag-junit",
+        "platform-test-annotations",
         "service-appsearch-for-tests",
         "services.core",
         "truth",
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImplTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImplTest.java
similarity index 56%
rename from testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImplTest.java
rename to testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImplTest.java
index 05d8b5be..75739180 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImplTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImplTest.java
@@ -25,6 +25,7 @@ import android.content.pm.PackageManager;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
 
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 
 import org.junit.Before;
@@ -41,7 +42,7 @@ import java.util.List;
 import java.util.Map;
 
 @RunWith(MockitoJUnitRunner.class)
-public class AppFunctionStaticMetadataParserImplTest {
+public class AppFunctionDocumentParserImplTest {
 
     private static final String TEST_PACKAGE_NAME = "com.example.app";
     private static final String TEST_INDEXER_PACKAGE_NAME = "com.android.test.indexer";
@@ -72,19 +73,24 @@ public class AppFunctionStaticMetadataParserImplTest {
                                     new AppSearchSchema.StringPropertyConfig.Builder(
                                                     "parameterName")
                                             .build())
+                            .addProperty(
+                                    new AppSearchSchema.DocumentPropertyConfig.Builder(
+                                                    "selfReference",
+                                                    "AppFunctionParameterMetadata-com.example.app")
+                                            .build())
                             .build());
 
     @Mock private PackageManager mPackageManager;
     @Mock private Resources mResources;
     @Mock private AssetManager mAssetManager;
 
-    private AppFunctionStaticMetadataParser mParser;
+    private AppFunctionDocumentParser mParser;
 
     @Before
     public void setUp() throws Exception {
         mParser =
-                new AppFunctionStaticMetadataParserImpl(
-                        TEST_INDEXER_PACKAGE_NAME, /* maxAppFunctions= */ 2);
+                new AppFunctionDocumentParserImpl(
+                        TEST_INDEXER_PACKAGE_NAME, new TestAppsIndexerConfig());
 
         when(mPackageManager.getResourcesForApplication(TEST_PACKAGE_NAME)).thenReturn(mResources);
         when(mResources.getAssets()).thenReturn(mAssetManager);
@@ -156,6 +162,32 @@ public class AppFunctionStaticMetadataParserImplTest {
         assertThat(appFunction1.getDisplayNameStringRes()).isEqualTo(0);
     }
 
+    @Test
+    public void parse_ignoresUnknownProperties() throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<version>1</version>\n"
+                        + "<appfunctions>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#print</function_id>\n"
+                        + "    <parameters><name>test</name></parameters>\n"
+                        + "    <unknown_property>test</unknown_property>\n"
+                        + "  </appfunction>\n"
+                        + "</appfunctions>");
+
+        List<AppFunctionStaticMetadata> appFunctions =
+                mParser.parse(mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+
+        assertThat(appFunctions).hasSize(1);
+        // Only contain known properties from XML or properties populated by default.
+        assertThat(appFunctions.get(0).getPropertyNames())
+                .containsExactly(
+                        "functionId",
+                        "packageName",
+                        "enabledByDefault",
+                        "mobileApplicationQualifiedId");
+    }
+
     @Test
     public void parse_missingFunctionId() throws Exception {
         setXmlInput(
@@ -198,7 +230,15 @@ public class AppFunctionStaticMetadataParserImplTest {
 
     @Test
     public void parse_exceedMaxNumAppFunctions() throws Exception {
-        // maxAppFunctions was set to be 2.
+        mParser =
+                new AppFunctionDocumentParserImpl(
+                        TEST_INDEXER_PACKAGE_NAME,
+                        new TestAppsIndexerConfig() {
+                            @Override
+                            public int getMaxAppFunctionsPerPackage() {
+                                return 2;
+                            }
+                        });
         setXmlInput(
                 "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
                         + "<version>1</version>\n"
@@ -229,28 +269,32 @@ public class AppFunctionStaticMetadataParserImplTest {
                 "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
                         + "<appfunctions>\n"
                         + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print</id>\n"
                         + "    <functionId>com.example.utils#print</functionId>\n"
                         + "    <enabledByDefault>true</enabledByDefault>\n"
                         + "    <schemaVersion>10</schemaVersion>\n"
                         + "  </AppFunctionStaticMetadata>\n"
                         + "</appfunctions>");
 
-        Map<String, AppFunctionStaticMetadata> appFunctions =
+        Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
                         mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(1);
-        assertThat(appFunctions).containsKey("com.example.utils#print");
-        AppFunctionStaticMetadata actualAppFunction = appFunctions.get("com.example.utils#print");
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
+        GenericDocument actualAppFunction =
+                appFunctions.get("com.example.app/com.example.utils#print");
         assertThat(actualAppFunction.getNamespace()).isEqualTo("app_functions");
-        assertThat(actualAppFunction.getId())
-                .isEqualTo("com.example.app/AppFunctionStaticMetadata");
+        assertThat(actualAppFunction.getId()).isEqualTo("com.example.app/com.example.utils#print");
         assertThat(actualAppFunction.getSchemaType())
                 .isEqualTo("AppFunctionStaticMetadata-com.example.app");
         assertThat(actualAppFunction.getPropertyString("functionId"))
                 .isEqualTo("com.example.utils#print");
         assertThat(actualAppFunction.getPropertyBoolean("enabledByDefault")).isEqualTo(true);
         assertThat(actualAppFunction.getPropertyLong("schemaVersion")).isEqualTo(10);
+        assertThat(actualAppFunction.getPropertyString("packageName")).isEqualTo(TEST_PACKAGE_NAME);
+        assertThat(actualAppFunction.getPropertyString("mobileApplicationQualifiedId"))
+                .isEqualTo("com.android.test.indexer$apps-db/apps#com.example.app");
     }
 
     @Test
@@ -259,24 +303,26 @@ public class AppFunctionStaticMetadataParserImplTest {
                 "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
                         + "<appfunctions>\n"
                         + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print</id>\n"
                         + "    <functionId>com.example.utils#print1</functionId>\n"
                         + "    <enabledByDefault>true</enabledByDefault>\n"
                         + "    <schemaVersion>10</schemaVersion>\n"
                         + "  </AppFunctionStaticMetadata>\n"
                         + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print2</id>\n"
                         + "    <functionId>com.example.utils#print2</functionId>\n"
                         + "    <enabledByDefault>true</enabledByDefault>\n"
                         + "    <schemaVersion>10</schemaVersion>\n"
                         + "  </AppFunctionStaticMetadata>\n"
                         + "</appfunctions>");
 
-        Map<String, AppFunctionStaticMetadata> appFunctions =
+        Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
                         mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(2);
-        assertThat(appFunctions).containsKey("com.example.utils#print1");
-        assertThat(appFunctions).containsKey("com.example.utils#print2");
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
     }
 
     @Test
@@ -295,7 +341,7 @@ public class AppFunctionStaticMetadataParserImplTest {
                         + "    <schemaVersion>10</schemaVersion>\n"
                         + "</appfunctions>");
 
-        Map<String, AppFunctionStaticMetadata> appFunctions =
+        Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
                         mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
 
@@ -305,33 +351,45 @@ public class AppFunctionStaticMetadataParserImplTest {
     @Test
     public void parseIntoMapForGivenSchemas_exceedMaxNumAppFunctions_parsesOnlyMaxNumAppFunctions()
             throws Exception {
+        mParser =
+                new AppFunctionDocumentParserImpl(
+                        TEST_INDEXER_PACKAGE_NAME,
+                        new TestAppsIndexerConfig() {
+                            @Override
+                            public int getMaxAppFunctionsPerPackage() {
+                                return 2;
+                            }
+                        });
         setXmlInput(
                 "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
                         + "<appfunctions>\n"
                         + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print1</id>\n"
                         + "    <functionId>com.example.utils#print1</functionId>\n"
                         + "    <enabledByDefault>true</enabledByDefault>\n"
                         + "    <schemaVersion>10</schemaVersion>\n"
                         + "  </AppFunctionStaticMetadata>\n"
                         + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print2</id>\n"
                         + "    <functionId>com.example.utils#print2</functionId>\n"
                         + "    <enabledByDefault>true</enabledByDefault>\n"
                         + "    <schemaVersion>10</schemaVersion>\n"
                         + "  </AppFunctionStaticMetadata>\n"
                         + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print3</id>\n"
                         + "    <functionId>com.example.utils#print3</functionId>\n"
                         + "    <enabledByDefault>true</enabledByDefault>\n"
                         + "    <schemaVersion>10</schemaVersion>\n"
                         + "  </AppFunctionStaticMetadata>\n"
                         + "</appfunctions>");
 
-        Map<String, AppFunctionStaticMetadata> appFunctions =
+        Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
                         mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(2);
-        assertThat(appFunctions).containsKey("com.example.utils#print1");
-        assertThat(appFunctions).containsKey("com.example.utils#print2");
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print1");
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print2");
     }
 
     @Test
@@ -341,26 +399,134 @@ public class AppFunctionStaticMetadataParserImplTest {
                 "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
                         + "<appfunctions>\n"
                         + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print</id>\n"
+                        + "    <functionId>com.example.utils#print</functionId>\n"
+                        + "    <appFunctionParameterMetadata>\n"
+                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-0"
+                        + "</id>\n"
+                        + "      <parameterName>test</parameterName>\n"
+                        + "    </appFunctionParameterMetadata>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionDocument> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).hasSize(1);
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
+        GenericDocument actualAppFunction =
+                appFunctions.get("com.example.app/com.example.utils#print");
+        assertThat(actualAppFunction.getPropertyString("functionId"))
+                .isEqualTo("com.example.utils#print");
+        assertThat(
+                        actualAppFunction.getPropertyString(
+                                "appFunctionParameterMetadata.parameterName"))
+                .isEqualTo("test");
+        assertThat(actualAppFunction.getPropertyDocument("appFunctionParameterMetadata").getId())
+                .isEqualTo(
+                        "com.example.app/com.example.utils#print/appFunctionParameterMetadata-0");
+    }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_singleAppFunctionWithSelfReferencingSchema()
+            throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print</id>\n"
                         + "    <functionId>com.example.utils#print</functionId>\n"
                         + "    <appFunctionParameterMetadata>\n"
+                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-0"
+                        + "</id>\n"
                         + "      <parameterName>test</parameterName>\n"
+                        + "    <selfReference>\n"
+                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-1"
+                        + "</id>\n"
+                        + "      <parameterName>selfReferencingParam</parameterName>\n"
+                        + "    </selfReference>\n"
                         + "    </appFunctionParameterMetadata>\n"
                         + "  </AppFunctionStaticMetadata>\n"
                         + "</appfunctions>");
 
-        Map<String, AppFunctionStaticMetadata> appFunctions =
+        Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
                         mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(1);
-        assertThat(appFunctions).containsKey("com.example.utils#print");
-        AppFunctionStaticMetadata actualAppFunction = appFunctions.get("com.example.utils#print");
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
+        GenericDocument actualAppFunction =
+                appFunctions.get("com.example.app/com.example.utils#print");
         assertThat(actualAppFunction.getPropertyString("functionId"))
                 .isEqualTo("com.example.utils#print");
         assertThat(
                         actualAppFunction.getPropertyString(
                                 "appFunctionParameterMetadata.parameterName"))
                 .isEqualTo("test");
+        assertThat(actualAppFunction.getPropertyDocument("appFunctionParameterMetadata").getId())
+                .isEqualTo(
+                        "com.example.app/com.example.utils#print/appFunctionParameterMetadata-0");
+        assertThat(
+                        actualAppFunction.getPropertyString(
+                                "appFunctionParameterMetadata.selfReference.parameterName"))
+                .isEqualTo("selfReferencingParam");
+    }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_multipleTypesOfRootDocuments() throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print</id>\n"
+                        + "    <functionId>com.example.utils#print</functionId>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "  <AppFunctionParameterMetadata>\n"
+                        + "    <id>com.example.utils#printParameterMetadata</id>\n"
+                        + "    <parameterName>message</parameterName>\n"
+                        + "  </AppFunctionParameterMetadata>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionDocument> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).hasSize(2);
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
+        GenericDocument actualAppFunction =
+                appFunctions.get("com.example.app/com.example.utils#print");
+        assertThat(actualAppFunction.getPropertyString("functionId"))
+                .isEqualTo("com.example.utils#print");
+        GenericDocument appFunctionParameterMetadataDocument =
+                appFunctions.get("com.example.app/com.example.utils#printParameterMetadata");
+        assertThat(appFunctionParameterMetadataDocument.getPropertyString("parameterName"))
+                .isEqualTo("message");
+        assertThat(appFunctionParameterMetadataDocument.getId())
+                .isEqualTo("com.example.app/com.example.utils#printParameterMetadata");
+    }
+
+    @Test
+    public void
+            parseIntoMapForGivenSchemas_singleFunctionWithDocumentProperties_missingIdInNestedDoc()
+                    throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print</id>\n"
+                        + "    <functionId>com.example.utils#print</functionId>\n"
+                        + "    <appFunctionParameterMetadata>\n"
+                        + "      <parameterName>test</parameterName>\n"
+                        + "    </appFunctionParameterMetadata>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionDocument> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).isEmpty();
     }
 
     @Test
@@ -370,24 +536,30 @@ public class AppFunctionStaticMetadataParserImplTest {
                 "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
                         + "<appfunctions>\n"
                         + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print</id>\n"
                         + "    <functionId>com.example.utils#print</functionId>\n"
                         + "    <appFunctionParameterMetadata>\n"
+                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-0"
+                        + "</id>\n"
                         + "      <parameterName>test1</parameterName>\n"
                         + "      <parameterName>test2</parameterName>\n"
                         + "    </appFunctionParameterMetadata>\n"
                         + "    <appFunctionParameterMetadata>\n"
+                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-1"
+                        + "</id>\n"
                         + "      <parameterName>test3</parameterName>\n"
                         + "    </appFunctionParameterMetadata>\n"
                         + "  </AppFunctionStaticMetadata>\n"
                         + "</appfunctions>");
 
-        Map<String, AppFunctionStaticMetadata> appFunctions =
+        Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
                         mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(1);
-        assertThat(appFunctions).containsKey("com.example.utils#print");
-        AppFunctionStaticMetadata actualAppFunction = appFunctions.get("com.example.utils#print");
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
+        GenericDocument actualAppFunction =
+                appFunctions.get("com.example.app/com.example.utils#print");
         assertThat(actualAppFunction.getPropertyString("functionId"))
                 .isEqualTo("com.example.utils#print");
         assertThat(
@@ -401,4 +573,68 @@ public class AppFunctionStaticMetadataParserImplTest {
                                         "appFunctionParameterMetadata[1].parameterName")))
                 .containsExactly("test3");
     }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_validXmlWithUnderscores_worksWithDynamicSchemas()
+            throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <appfunction>\n"
+                        + "    <id>com.example.utils#print</id>\n"
+                        + "    <function__id>com.example.utils#print</function__id>\n"
+                        + "    <enabled_by_default>true</enabled_by_default>\n"
+                        + "    <scHema_veRsion>10</scHema_veRsion>\n"
+                        + "  </appfunction>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionDocument> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).hasSize(1);
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
+        GenericDocument actualAppFunction =
+                appFunctions.get("com.example.app/com.example.utils#print");
+        assertThat(actualAppFunction.getNamespace()).isEqualTo("app_functions");
+        assertThat(actualAppFunction.getId()).isEqualTo("com.example.app/com.example.utils#print");
+        assertThat(actualAppFunction.getSchemaType())
+                .isEqualTo("AppFunctionStaticMetadata-com.example.app");
+        assertThat(actualAppFunction.getPropertyString("functionId"))
+                .isEqualTo("com.example.utils#print");
+        assertThat(actualAppFunction.getPropertyBoolean("enabledByDefault")).isEqualTo(true);
+        assertThat(actualAppFunction.getPropertyLong("schemaVersion")).isEqualTo(10);
+    }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_xmlTagWithStartingOrOnlyUnderscores_propertiesIgnored()
+            throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.example.utils#print</id>\n"
+                        + "    <functionId>com.example.utils#print</functionId>\n"
+                        + "    <___>test</___>\n"
+                        + "    <_schema_version_>test</_schema_version_>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionDocument> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).hasSize(1);
+        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
+        GenericDocument actualAppFunction =
+                appFunctions.get("com.example.app/com.example.utils#print");
+        assertThat(actualAppFunction.getNamespace()).isEqualTo("app_functions");
+        assertThat(actualAppFunction.getId()).isEqualTo("com.example.app/com.example.utils#print");
+        assertThat(actualAppFunction.getSchemaType())
+                .isEqualTo("AppFunctionStaticMetadata-com.example.app");
+        assertThat(actualAppFunction.getPropertyString("functionId"))
+                .isEqualTo("com.example.utils#print");
+        assertThat(actualAppFunction.getPropertyNames())
+                .containsExactly("functionId", "packageName", "mobileApplicationQualifiedId");
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionSchemaParserTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionSchemaParserTest.java
index 8ce59fd4..a52a1117 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionSchemaParserTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionSchemaParserTest.java
@@ -15,15 +15,18 @@
  */
 package com.android.server.appsearch.appsindexer;
 
+import static com.android.server.appsearch.appsindexer.TestUtils.APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES;
+
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.Mockito.when;
 
 import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.AppSearchSchema.BooleanPropertyConfig;
+import android.app.appsearch.AppSearchSchema.LongPropertyConfig;
 import android.app.appsearch.AppSearchSchema.PropertyConfig;
 import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
-import android.app.appsearch.AppSearchSchema.LongPropertyConfig;
-import android.app.appsearch.AppSearchSchema.BooleanPropertyConfig;
 import android.content.pm.PackageManager;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
@@ -39,7 +42,6 @@ import org.mockito.junit.MockitoJUnitRunner;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.util.List;
 import java.util.Map;
 
 @RunWith(MockitoJUnitRunner.class)
@@ -63,10 +65,12 @@ public class AppFunctionSchemaParserTest {
     }
 
     @Test
-    public void parse_singleType_withNoAttributes() throws Exception {
+    public void parse_singleType_withNoAttributesForAdditionalProperties() throws Exception {
+        assumeTrue(AppFunctionStaticMetadata.shouldSetParentType());
         String xsd =
                 "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
                         + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
                         + "        <xs:element name=\"name\" type=\"xs:string\" />"
                         + "        <xs:element name=\"age\" type=\"xs:int\" />"
                         + "        <xs:element name=\"isActive\" type=\"xs:boolean\" />"
@@ -81,7 +85,10 @@ public class AppFunctionSchemaParserTest {
         assertThat(schemas).hasSize(1);
         assertThat(schemas.get("AppFunctionStaticMetadata-com.example.app"))
                 .isEqualTo(
-                        new AppSearchSchema.Builder("AppFunctionStaticMetadata-com.example.app")
+                        new AppSearchSchema.Builder(
+                                        AppFunctionStaticMetadata.PARENT_TYPE_APPSEARCH_SCHEMA)
+                                .setSchemaType("AppFunctionStaticMetadata-com.example.app")
+                                .addParentType("AppFunctionStaticMetadata")
                                 .addProperty(new StringPropertyConfig.Builder("name").build())
                                 .addProperty(new LongPropertyConfig.Builder("age").build())
                                 .addProperty(new BooleanPropertyConfig.Builder("isActive").build())
@@ -89,10 +96,12 @@ public class AppFunctionSchemaParserTest {
     }
 
     @Test
-    public void parse_singleType_withAttributes() throws Exception {
+    public void parse_singleType_withAttributesForAdditionalProperties() throws Exception {
+        assumeTrue(AppFunctionStaticMetadata.shouldSetParentType());
         String xsd =
                 "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
                         + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
                         + "        <xs:element name=\"name\" type=\"xs:string\" indexingType=\""
                         + StringPropertyConfig.INDEXING_TYPE_EXACT_TERMS
                         + "\" tokenizerType=\""
@@ -117,7 +126,10 @@ public class AppFunctionSchemaParserTest {
         assertThat(schemas).hasSize(1);
         assertThat(schemas.get("AppFunctionStaticMetadata-com.example.app"))
                 .isEqualTo(
-                        new AppSearchSchema.Builder("AppFunctionStaticMetadata-com.example.app")
+                        new AppSearchSchema.Builder(
+                                        AppFunctionStaticMetadata.PARENT_TYPE_APPSEARCH_SCHEMA)
+                                .setSchemaType("AppFunctionStaticMetadata-com.example.app")
+                                .addParentType("AppFunctionStaticMetadata")
                                 .addProperty(
                                         new StringPropertyConfig.Builder("name")
                                                 .setIndexingType(
@@ -144,9 +156,11 @@ public class AppFunctionSchemaParserTest {
 
     @Test
     public void parse_multipleNestedTypes() throws Exception {
+        assumeTrue(AppFunctionStaticMetadata.shouldSetParentType());
         String xsd =
                 "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
                         + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
                         + "        <xs:element name=\"inner\" type=\"appfn:InnerType\" />"
                         + "    </xs:documentType>"
                         + "    <xs:documentType name=\"InnerType\">"
@@ -167,11 +181,14 @@ public class AppFunctionSchemaParserTest {
                                 .build());
         assertThat(schemas.get("AppFunctionStaticMetadata-com.example.app"))
                 .isEqualTo(
-                        new AppSearchSchema.Builder("AppFunctionStaticMetadata-com.example.app")
+                        new AppSearchSchema.Builder(
+                                        AppFunctionStaticMetadata.PARENT_TYPE_APPSEARCH_SCHEMA)
+                                .setSchemaType("AppFunctionStaticMetadata-com.example.app")
+                                .addParentType("AppFunctionStaticMetadata")
                                 .addProperty(
                                         new AppSearchSchema.DocumentPropertyConfig.Builder(
                                                         "inner", "InnerType-com.example.app")
-                                                .setShouldIndexNestedProperties(true)
+                                                .setShouldIndexNestedProperties(false)
                                                 .build())
                                 .build());
     }
@@ -180,7 +197,8 @@ public class AppFunctionSchemaParserTest {
     public void parse_exceedMaxAllowedDocumentTypes() throws Exception {
         String xsd =
                 "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
-                        + "    <xs:documentType name=\"OuterType\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
                         + "        <xs:element name=\"inner\" type=\"appfn:InnerType\" />"
                         + "    </xs:documentType>"
                         + "    <xs:documentType name=\"InnerType\">"
@@ -203,6 +221,7 @@ public class AppFunctionSchemaParserTest {
         String xsd =
                 "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
                         + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
                         + "        <xs:element name=\"name\" type=\"xs:unsupportedType\" />"
                         + "    </xs:documentType>"
                         + "</xs:schema>";
@@ -219,7 +238,65 @@ public class AppFunctionSchemaParserTest {
         String xsd =
                 "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
                         + "    <xs:documentType name=\"TestType\">"
-                        + "        <xs:element name=\"name\" type=\"xs:unsupportedType\" />"
+                        + "        <xs:element name=\"name\" type=\"xs:string\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        setXmlInput(xsd);
+
+        Map<String, AppSearchSchema> schemas =
+                mParser.parseAndCreateSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+        assertThat(schemas).isEmpty();
+    }
+
+    @Test
+    public void parse_missingNestedSchemaDefinition_returnsEmptyMap() throws Exception {
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
+                        + "        <xs:element name=\"name\" type=\"appfn:InnerType\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        setXmlInput(xsd);
+
+        Map<String, AppSearchSchema> schemas =
+                mParser.parseAndCreateSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+        assertThat(schemas).isEmpty();
+    }
+
+    @Test
+    public void parse_nonAlphaNumericPropertyName_returnsEmptyMap() throws Exception {
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
+                        + "        <xs:element name=\"name_property\" type=\"xs:string\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        setXmlInput(xsd);
+
+        Map<String, AppSearchSchema> schemas =
+                mParser.parseAndCreateSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+        assertThat(schemas).isEmpty();
+    }
+
+    @Test
+    public void parse_invalidAttributeValue_returnsEmptyMap() throws Exception {
+        // Invalid value for cardinality attribute.
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
+                        + "        <xs:element name=\"nameProperty\" type=\"xs:string\" "
+                        + " cardinality=\"foo\""
+                        + "/>"
+                        + "        <xs:element name=\"inner\" type=\"appfn:InnerType\" />"
+                        + "    </xs:documentType>"
+                        + "    <xs:documentType name=\"InnerType\">"
+                        + "        <xs:element name=\"value\" type=\"xs:string\" />"
                         + "    </xs:documentType>"
                         + "</xs:schema>";
         setXmlInput(xsd);
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceTest.java
index 304e7aae..8301dd63 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceTest.java
@@ -31,7 +31,7 @@ import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import android.annotation.UserIdInt;
@@ -324,7 +324,7 @@ public class AppOpenEventIndexerMaintenanceTest {
         mAppOpenEventIndexerMaintenanceService.doUpdateForUser(
                 mContextWrapper, mParams, DEFAULT_USER_HANDLE, new CancellationSignal());
 
-        verifyZeroInteractions(mMockJobScheduler);
+        verifyNoMoreInteractions(mMockJobScheduler);
     }
 
     @Test
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java
index 418fce52..57d20620 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java
@@ -17,6 +17,7 @@ package com.android.server.appsearch.appsindexer;
 
 import static android.Manifest.permission.OBSERVE_APP_USAGE;
 import static android.Manifest.permission.PACKAGE_USAGE_STATS;
+import static android.Manifest.permission.RECEIVE_BOOT_COMPLETED;
 
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeAppOpenEventsIndexerSession;
 import static com.android.server.appsearch.appsindexer.TestUtils.removeFakeAppOpenEventDocuments;
@@ -27,15 +28,17 @@ import android.app.UiAutomation;
 import android.app.appsearch.AppSearchEnvironmentFactory;
 import android.app.appsearch.AppSearchManager;
 import android.app.appsearch.AppSearchSessionShim;
+import android.app.appsearch.FrameworkAppSearchEnvironment;
 import android.app.appsearch.SearchResult;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.SetSchemaRequest;
+import android.app.appsearch.testutil.AppSearchFrameworkTestUtils;
+import android.app.usage.UsageEvents;
 import android.app.usage.UsageStatsManager;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.content.Intent;
 import android.content.pm.UserInfo;
-import android.os.CancellationSignal;
 import android.os.UserHandle;
 
 import androidx.test.core.app.ApplicationProvider;
@@ -46,10 +49,14 @@ import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 
 import junit.framework.Assert;
 
+import org.jspecify.annotations.NonNull;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
+import java.io.File;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
@@ -76,6 +83,8 @@ public class AppOpenEventIndexerRealDocumentsTest {
     protected Context mUserContext;
     protected UiAutomation mUiAutomation;
 
+    @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
+
     @Before
     public void setUp() throws Exception {
         mContext = new ContextWrapper(ApplicationProvider.getApplicationContext());
@@ -86,15 +95,21 @@ public class AppOpenEventIndexerRealDocumentsTest {
         mUserContext =
                 AppSearchEnvironmentFactory.getEnvironmentInstance()
                         .createContextAsUser(mContext, mUserHandle);
-        AppOpenEventIndexerSettings appOpenEventIndexerSettings =
-                new AppOpenEventIndexerSettings(
-                        AppSearchEnvironmentFactory.getEnvironmentInstance()
-                                .getAppSearchDir(mUserContext, mUserHandle));
-        appOpenEventIndexerSettings.setLastUpdateTimestampMillis(System.currentTimeMillis());
         removeFakeAppOpenEventDocuments(mContext, Executors.newSingleThreadExecutor());
 
         mUiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
-        mUiAutomation.adoptShellPermissionIdentity(PACKAGE_USAGE_STATS, OBSERVE_APP_USAGE);
+        mUiAutomation.adoptShellPermissionIdentity(
+                PACKAGE_USAGE_STATS, OBSERVE_APP_USAGE, RECEIVE_BOOT_COMPLETED);
+
+        File mAppSearchDir = mTemporaryFolder.newFolder();
+        AppSearchEnvironmentFactory.setEnvironmentInstanceForTest(
+                new FrameworkAppSearchEnvironment() {
+                    @Override
+                    public File getAppSearchDir(
+                            @NonNull Context unused, @NonNull UserHandle userHandle) {
+                        return mAppSearchDir;
+                    }
+                });
     }
 
     @After
@@ -112,6 +127,8 @@ public class AppOpenEventIndexerRealDocumentsTest {
 
     @Test
     public void testRealDocuments_check() throws Exception {
+        long testStartTimeMillis = System.currentTimeMillis();
+
         Intent launchIntent =
                 mContext.getPackageManager().getLaunchIntentForPackage(mContext.getPackageName());
         Assert.assertNotNull(launchIntent);
@@ -120,20 +137,52 @@ public class AppOpenEventIndexerRealDocumentsTest {
 
         UsageStatsManager usageStatsManager = mContext.getSystemService(UsageStatsManager.class);
 
+        boolean foundMatchingEvent = false;
+        long matchingEventTimestamp = 0;
+        long maxWaitMillis = TimeUnit.SECONDS.toMillis(10);
+        long waitStartTime = System.currentTimeMillis();
+        long sleepMillis = 100;
+
+        while (!foundMatchingEvent
+                && (System.currentTimeMillis() - waitStartTime) < maxWaitMillis) {
+            UsageEvents events =
+                    usageStatsManager.queryEvents(testStartTimeMillis, System.currentTimeMillis());
+            UsageEvents.Event event = new UsageEvents.Event();
+
+            while (events.hasNextEvent()) {
+                events.getNextEvent(event);
+                if (event.getEventType() == UsageEvents.Event.ACTIVITY_RESUMED
+                        && event.getPackageName().equals(mContext.getPackageName())
+                        && event.getTimeStamp() >= testStartTimeMillis) {
+                    foundMatchingEvent = true;
+                    matchingEventTimestamp = event.getTimeStamp();
+                    break;
+                }
+            }
+            Thread.sleep(sleepMillis);
+        }
+        // Usage stats manager does not have an observer/callback API, so we just have to wait for
+        // the event to appear.  If the test is flaky, this is likely the culprit.  Can increase the
+        // spin loop time if needed (may improve flakiness).
+        assertThat(foundMatchingEvent).isTrue();
+
         CountDownLatch latch = new CountDownLatch(1);
         AppOpenEventIndexerManagerService appOpenEventIndexerManagerService =
                 new AppOpenEventIndexerManagerService(
                         mContext, new TestAppOpenEventIndexerConfig(), latch::countDown);
+        SystemService.TargetUser targetUser = new SystemService.TargetUser(mUserInfo);
+        appOpenEventIndexerManagerService.onUserUnlocking(targetUser);
         appOpenEventIndexerManagerService.mLocalService.doUpdateForUser(
-                new SystemService.TargetUser(mUserInfo).getUserHandle(), new CancellationSignal());
+                targetUser.getUserHandle(), null);
         assertThat(latch.await(10, TimeUnit.SECONDS)).isEqualTo(true);
 
-        // Search for most recently opened app open event
+        // Search for all app open events for the package opened earlier
         SearchSpec searchSpec =
                 new SearchSpec.Builder()
                         .addFilterNamespaces(AppOpenEvent.APP_OPEN_EVENT_NAMESPACE)
                         .setOrder(SearchSpec.ORDER_DESCENDING)
                         .setRankingStrategy(SearchSpec.RANKING_STRATEGY_CREATION_TIMESTAMP)
+                        .addFilterPackageNames(mContext.getPackageName())
                         .build();
         AppSearchManager manager =
                 ApplicationProvider.getApplicationContext()
@@ -143,12 +192,9 @@ public class AppOpenEventIndexerRealDocumentsTest {
         SyncGlobalSearchSession globalSearchSession =
                 new SyncGlobalSearchSessionImpl(manager, executor);
         SyncSearchResults searchResults = globalSearchSession.search("", searchSpec);
-        List<SearchResult> results = searchResults.getNextPage();
 
-        for (int i = 0; i < results.size(); i++) {
-            assertThat(results.get(i).getGenericDocument().getSchemaType())
-                    .startsWith(AppOpenEvent.SCHEMA_TYPE);
-        }
+        List<SearchResult> results =
+                AppSearchFrameworkTestUtils.retrieveAllSearchResults(searchResults);
 
         long currentTimeMillis = System.currentTimeMillis();
         boolean hasMatchingResult = false;
@@ -169,13 +215,13 @@ public class AppOpenEventIndexerRealDocumentsTest {
             if (packageName != null
                     && timestampMillis != null
                     && mContext.getPackageName().equals(packageName)
-                    && (currentTimeMillis - timestampMillis) <= TimeUnit.SECONDS.toMillis(30)) {
+                    && (currentTimeMillis - timestampMillis) <= TimeUnit.SECONDS.toMillis(30)
+                    && timestampMillis == matchingEventTimestamp) {
                 hasMatchingResult = true;
                 break;
             }
         }
 
-        // Assert that the matching result exists
         assertThat(hasMatchingResult).isTrue();
     }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java
index 2379c633..8c643a91 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java
@@ -25,9 +25,11 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 import android.annotation.Nullable;
 import android.app.appsearch.exceptions.AppSearchException;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.app.job.JobInfo;
 import android.app.job.JobScheduler;
 import android.app.usage.UsageEvents;
@@ -35,15 +37,19 @@ import android.app.usage.UsageEvents.Event;
 import android.app.usage.UsageStatsManager;
 import android.content.Context;
 import android.content.ContextWrapper;
+import android.platform.test.annotations.RequiresFlagsDisabled;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 
 import androidx.test.core.app.ApplicationProvider;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
 import org.mockito.ArgumentCaptor;
 
@@ -58,6 +64,7 @@ public class AppOpenEventIndexerUserInstanceTest {
     private final UsageStatsManager mMockUsageStatsManager = mock(UsageStatsManager.class);
 
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
 
     private ExecutorService mSingleThreadedExecutor;
     private File mAppsDir;
@@ -219,4 +226,172 @@ public class AppOpenEventIndexerUserInstanceTest {
         assertThat(updateJob.isPersisted()).isTrue();
         assertThat(updateJob.isPeriodic()).isTrue();
     }
+
+    @Test
+    public void testStart_onShutdown_cancelsUpdateJob() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        JobScheduler mockJobScheduler = mock(JobScheduler.class);
+        mContext.setJobScheduler(mockJobScheduler);
+
+        mInstance =
+                AppOpenEventIndexerUserInstance.createInstance(
+                        mContext, mAppsDir, mAppOpenEventIndexerConfig, mSingleThreadedExecutor);
+
+        mInstance.schedulePeriodicUpdate();
+        ArgumentCaptor<JobInfo> jobInfoArgumentCaptor = ArgumentCaptor.forClass(JobInfo.class);
+        verify(mockJobScheduler).schedule(jobInfoArgumentCaptor.capture());
+        JobInfo updateJob = jobInfoArgumentCaptor.getValue();
+        assertThat(updateJob.isRequireBatteryNotLow()).isTrue();
+        assertThat(updateJob.isRequireDeviceIdle()).isTrue();
+        assertThat(updateJob.isPersisted()).isTrue();
+        assertThat(updateJob.isPeriodic()).isTrue();
+
+        // Mock the pending job to return the job we just scheduled
+        when(mockJobScheduler.getPendingJob(updateJob.getId())).thenReturn(updateJob);
+        mInstance.shutdown();
+        verify(mockJobScheduler).cancel(jobInfoArgumentCaptor.getValue().getId());
+    }
+
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_APP_OPEN_EVENTS_INDEXER_CHECK_PRIOR_ATTEMPT)
+    @Test
+    public void testFirstRun_withoutCheckPriorAttempt_doesNotWrite() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+
+        mInstance =
+                AppOpenEventIndexerUserInstance.createInstance(
+                        mContext, mAppsDir, mAppOpenEventIndexerConfig, mSingleThreadedExecutor);
+
+        Event event =
+                createIndividualUsageEvent(
+                        UsageEvents.Event.MOVE_TO_FOREGROUND,
+                        currentTimeMillis + 1000L,
+                        "com.fake.package");
+        UsageEvents events = createUsageEvents(event);
+        setupMockUsageStatsManager(mMockUsageStatsManager, events);
+
+        CountDownLatch latch = new CountDownLatch(1);
+        mInstance.updateAsync(latch::countDown);
+
+        assertThat(latch.await(1, TimeUnit.SECONDS)).isTrue();
+
+        AppOpenEventIndexerSettings settings = new AppOpenEventIndexerSettings(mAppsDir);
+        settings.load();
+        long lastAttemptedUpdatedTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+        assertThat(lastAttemptedUpdatedTimestampMillis).isEqualTo(0);
+    }
+
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APP_OPEN_EVENTS_INDEXER_CHECK_PRIOR_ATTEMPT)
+    @Test
+    public void testFirstRun_lastRunInFuture_runsSync() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        AppOpenEventIndexerSettings settings = new AppOpenEventIndexerSettings(mAppsDir);
+        settings.setLastAttemptedUpdateTimestampMillis(Long.MAX_VALUE);
+        settings.persist();
+
+        mInstance =
+                AppOpenEventIndexerUserInstance.createInstance(
+                        mContext, mAppsDir, mAppOpenEventIndexerConfig, mSingleThreadedExecutor);
+
+        Event event =
+                createIndividualUsageEvent(
+                        UsageEvents.Event.MOVE_TO_FOREGROUND,
+                        currentTimeMillis + 1000L,
+                        "com.fake.package");
+        UsageEvents events = createUsageEvents(event);
+        setupMockUsageStatsManager(mMockUsageStatsManager, events);
+
+        CountDownLatch latch = new CountDownLatch(1);
+        mInstance.updateAsync(latch::countDown);
+
+        assertThat(latch.await(1, TimeUnit.SECONDS)).isTrue();
+
+        settings = new AppOpenEventIndexerSettings(mAppsDir);
+        settings.load();
+        long lastAttemptedUpdatedTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+        // Timestamp should be set to more current value
+        assertThat(lastAttemptedUpdatedTimestampMillis).isAtMost(System.currentTimeMillis());
+    }
+
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APP_OPEN_EVENTS_INDEXER_CHECK_PRIOR_ATTEMPT)
+    @Test
+    public void testFirstRun_persistsAttemptTimestamp() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        mInstance =
+                AppOpenEventIndexerUserInstance.createInstance(
+                        mContext, mAppsDir, mAppOpenEventIndexerConfig, mSingleThreadedExecutor);
+
+        Event event =
+                createIndividualUsageEvent(
+                        UsageEvents.Event.MOVE_TO_FOREGROUND,
+                        currentTimeMillis + 1000L,
+                        "com.fake.package");
+        UsageEvents events = createUsageEvents(event);
+        setupMockUsageStatsManager(mMockUsageStatsManager, events);
+
+        CountDownLatch latch = new CountDownLatch(1);
+        mInstance.updateAsync(latch::countDown);
+
+        assertThat(latch.await(1, TimeUnit.SECONDS)).isTrue();
+
+        AppOpenEventIndexerSettings settings = new AppOpenEventIndexerSettings(mAppsDir);
+        settings.load();
+        long lastAttemptedUpdatedTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+        assertThat(lastAttemptedUpdatedTimestampMillis).isGreaterThan(0);
+    }
+
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APP_OPEN_EVENTS_INDEXER_CHECK_PRIOR_ATTEMPT)
+    @Test
+    public void testFirstRun_waitsForMinTime() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        mInstance =
+                AppOpenEventIndexerUserInstance.createInstance(
+                        mContext, mAppsDir, mAppOpenEventIndexerConfig, mSingleThreadedExecutor);
+
+        Event event =
+                createIndividualUsageEvent(
+                        UsageEvents.Event.MOVE_TO_FOREGROUND,
+                        currentTimeMillis + 1000L,
+                        "com.fake.package");
+        UsageEvents events = createUsageEvents(event);
+        setupMockUsageStatsManager(mMockUsageStatsManager, events);
+
+        CountDownLatch latch = new CountDownLatch(1);
+        mInstance.updateAsync(latch::countDown);
+
+        assertThat(latch.await(1, TimeUnit.SECONDS)).isTrue();
+
+        AppOpenEventIndexerSettings settings = new AppOpenEventIndexerSettings(mAppsDir);
+        settings.load();
+        long firstAttemptedUpdateTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+
+        // Reset the last run timestamp to 0 to simulate what would happen if the sync fails
+        settings.setLastAttemptedUpdateTimestampMillis(0);
+        settings.persist();
+
+        long secondAttemptedUpdateTimestampMillis = 0;
+
+        // Request a bunch of updates and check timestamp after each. This will stay 0 until another
+        // update runs
+        while (secondAttemptedUpdateTimestampMillis == 0) {
+            latch = new CountDownLatch(1);
+            mInstance.updateAsync(latch::countDown);
+
+            assertThat(latch.await(1, TimeUnit.SECONDS)).isTrue();
+
+            settings.load();
+            secondAttemptedUpdateTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+        }
+
+        // At this point, one of the requested firstRun updates has completed
+        mSingleThreadedExecutor.shutdown();
+
+        // Check timestamp, it should've persisted a new time that is at least
+        // TestAppsIndexerConfig.getMinTimeBetweenFirstSyncsMillis greater than the first attempt
+        // timestamp
+        assertThat(secondAttemptedUpdateTimestampMillis)
+                .isAtLeast(
+                        firstAttemptedUpdateTimestampMillis
+                                + new TestAppOpenEventIndexerConfig()
+                                        .getMinTimeBetweenSyncsMillis());
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java
index 9a268111..65c9ef91 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java
@@ -66,6 +66,7 @@ import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 
 import org.junit.After;
 import org.junit.Before;
@@ -685,4 +686,110 @@ public class AppSearchHelperTest {
                     .isEqualTo(event1.getMobileApplicationQualifiedId());
         }
     }
+
+    @Test
+    public void
+            setSchemaForPackages_setsDynamicAppFunctionSchemasWithParentType_dynamicSchemasExist()
+                    throws Exception {
+        assumeTrue(AppFunctionStaticMetadata.shouldSetParentType());
+        MobileApplication app = createFakeMobileApplication(0);
+        List<PackageIdentifier> pkgIdentifiers =
+                List.of(new PackageIdentifier(app.getPackageName(), FAKE_SIGNATURE.toByteArray()));
+        AppSearchSchema dynamicSchema =
+                new AppSearchSchema.Builder("AppFunctionStaticMetadata-" + app.getPackageName())
+                        .build();
+
+        mAppSearchHelper.setSchemasForPackages(
+                pkgIdentifiers,
+                pkgIdentifiers,
+                ImmutableMap.of(
+                        app.getPackageName(),
+                        ImmutableMap.of(
+                                "AppFunctionStaticMetadata-" + app.getPackageName(),
+                                dynamicSchema)));
+
+        AppSearchSessionShim session =
+                createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
+        GetSchemaResponse response = session.getSchemaAsync().get();
+        assertThat(response.getSchemas())
+                .containsExactly(
+                        MobileApplication.createMobileApplicationSchemaForPackage(
+                                app.getPackageName()),
+                        AppFunctionStaticMetadata.PARENT_TYPE_APPSEARCH_SCHEMA,
+                        dynamicSchema);
+    }
+
+    @Test
+    public void
+            setSchemaForPackages_setsDefaultsToHardcodedAppFunctionSchemas_dynamicSchemasIsMissing()
+                    throws Exception {
+        assumeTrue(AppFunctionStaticMetadata.shouldSetParentType());
+        MobileApplication app = createFakeMobileApplication(0);
+        List<PackageIdentifier> pkgIdentifiers =
+                List.of(new PackageIdentifier(app.getPackageName(), FAKE_SIGNATURE.toByteArray()));
+
+        mAppSearchHelper.setSchemasForPackages(
+                pkgIdentifiers,
+                pkgIdentifiers,
+                ImmutableMap.of(app.getPackageName(), ImmutableMap.of()));
+
+        AppSearchSessionShim session =
+                createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
+        GetSchemaResponse response = session.getSchemaAsync().get();
+        assertThat(response.getSchemas())
+                .containsExactly(
+                        MobileApplication.createMobileApplicationSchemaForPackage(
+                                app.getPackageName()),
+                        AppFunctionStaticMetadata.PARENT_TYPE_APPSEARCH_SCHEMA,
+                        AppFunctionStaticMetadata.createAppFunctionSchemaForPackage(
+                                app.getPackageName()));
+    }
+
+    @Test
+    public void setSchemaForPackages_dropsInvalidDynamicSchema() throws Exception {
+        assumeTrue(AppFunctionStaticMetadata.shouldSetParentType());
+        MobileApplication app = createFakeMobileApplication(0);
+        AppSearchSchema dynamicSchema =
+                new AppSearchSchema.Builder("AppFunctionStaticMetadata-" + app.getPackageName())
+                        .build();
+        MobileApplication appWithInvalidSchema = createFakeMobileApplication(1);
+        // Invalid schema with more than 64 indexable properties
+        AppSearchSchema.Builder invalidSchemaBuilder =
+                new AppSearchSchema.Builder(
+                        "AppFunctionStaticMetadata-" + appWithInvalidSchema.getPackageName());
+        for (int i = 0; i < 100; i++) {
+            invalidSchemaBuilder.addProperty(
+                    new AppSearchSchema.LongPropertyConfig.Builder("props" + i)
+                            .setIndexingType(AppSearchSchema.LongPropertyConfig.INDEXING_TYPE_RANGE)
+                            .build());
+        }
+        AppSearchSchema invalidSchema = invalidSchemaBuilder.build();
+        List<PackageIdentifier> pkgIdentifiers =
+                List.of(
+                        new PackageIdentifier(app.getPackageName(), FAKE_SIGNATURE.toByteArray()),
+                        new PackageIdentifier(
+                                appWithInvalidSchema.getPackageName(),
+                                FAKE_SIGNATURE.toByteArray()));
+
+        mAppSearchHelper.setSchemasForPackages(
+                pkgIdentifiers,
+                pkgIdentifiers,
+                ImmutableMap.of(
+                        app.getPackageName(),
+                        ImmutableMap.of(dynamicSchema.getSchemaType(), dynamicSchema),
+                        appWithInvalidSchema.getPackageName(),
+                        ImmutableMap.of(invalidSchema.getSchemaType(), invalidSchema)));
+
+        AppSearchSessionShim session =
+                createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
+        GetSchemaResponse response = session.getSchemaAsync().get();
+        assertThat(response.getSchemas())
+                .containsExactly(
+                        MobileApplication.createMobileApplicationSchemaForPackage(
+                                app.getPackageName()),
+                        MobileApplication.createMobileApplicationSchemaForPackage(
+                                appWithInvalidSchema.getPackageName()),
+                        AppFunctionStaticMetadata.PARENT_TYPE_APPSEARCH_SCHEMA,
+                        dynamicSchema);
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java
index 5b48c70c..2f03c76a 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java
@@ -16,6 +16,8 @@
 
 package com.android.server.appsearch.appsindexer;
 
+import static com.android.server.appsearch.appsindexer.TestUtils.APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES;
+import static com.android.server.appsearch.appsindexer.TestUtils.APP_FUNCTION_STATIC_METADATA_PARENT_SCHEMA_XSD;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeAppFunctionResolveInfo;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeLaunchResolveInfo;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeMobileApplication;
@@ -31,9 +33,12 @@ import static com.google.common.truth.Truth.assertThat;
 import static junit.framework.Assert.assertEquals;
 
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.when;
 
+import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.ContextWrapper;
@@ -42,18 +47,22 @@ import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 
 import androidx.test.core.app.ApplicationProvider;
 
-import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
+import com.android.appsearch.flags.Flags;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
 import org.mockito.Mockito;
 import org.mockito.MockitoSession;
@@ -62,13 +71,18 @@ import java.io.ByteArrayInputStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 public class AppsIndexerImplTest {
+
     private AppSearchHelper mAppSearchHelper;
     private Context mContext;
     @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
+
     private final ExecutorService mSingleThreadedExecutor = Executors.newSingleThreadExecutor();
     private final AppsIndexerConfig mAppsIndexerConfig = new TestAppsIndexerConfig();
     private MockitoSession mMockitoSession;
@@ -112,13 +126,7 @@ public class AppsIndexerImplTest {
                 createFakePackageInfos(1),
                 createFakeResolveInfos(1),
                 /* appFunctionServices= */ ImmutableList.of());
-        Context context =
-                new ContextWrapper(mContext) {
-                    @Override
-                    public PackageManager getPackageManager() {
-                        return pm;
-                    }
-                };
+        Context context = createContextWithPackageManager(pm);
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context, mAppsIndexerConfig)) {
             appsIndexerImpl.doUpdate(
                     new AppsIndexerSettings(temporaryFolder.newFolder("temp")),
@@ -133,13 +141,7 @@ public class AppsIndexerImplTest {
     public void testAppsIndexerImpl_updateAppsThrowsError_shouldContinueOnError() throws Exception {
         PackageManager pm = Mockito.mock(PackageManager.class);
         when(pm.getInstalledPackages(any())).thenThrow(new RuntimeException("fake"));
-        Context context =
-                new ContextWrapper(mContext) {
-                    @Override
-                    public PackageManager getPackageManager() {
-                        return pm;
-                    }
-                };
+        Context context = createContextWithPackageManager(pm);
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context, mAppsIndexerConfig)) {
             appsIndexerImpl.doUpdate(
                     new AppsIndexerSettings(temporaryFolder.newFolder("tmp")),
@@ -159,13 +161,7 @@ public class AppsIndexerImplTest {
                 createFakePackageInfos(3),
                 createFakeResolveInfos(3),
                 /* appFunctionServices= */ ImmutableList.of());
-        Context context1 =
-                new ContextWrapper(mContext) {
-                    @Override
-                    public PackageManager getPackageManager() {
-                        return pm1;
-                    }
-                };
+        Context context1 = createContextWithPackageManager(pm1);
 
         // Perform the first update
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
@@ -197,13 +193,7 @@ public class AppsIndexerImplTest {
 
         setupMockPackageManager(
                 pm2, fakePackages, fakeActivities, /* appFunctionServices= */ ImmutableList.of());
-        Context context2 =
-                new ContextWrapper(mContext) {
-                    @Override
-                    public PackageManager getPackageManager() {
-                        return pm2;
-                    }
-                };
+        Context context2 = createContextWithPackageManager(pm2);
 
         // Perform the second update
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context2, mAppsIndexerConfig)) {
@@ -271,13 +261,7 @@ public class AppsIndexerImplTest {
         when(pm1.getResourcesForApplication(any(String.class))).thenReturn(resources);
         setupMockPackageManager(pm1, fakePackages, fakeActivities, fakeAppFunctionServices);
 
-        Context context1 =
-                new ContextWrapper(mContext) {
-                    @Override
-                    public PackageManager getPackageManager() {
-                        return pm1;
-                    }
-                };
+        Context context1 = createContextWithPackageManager(pm1);
 
         List<String> packages = new ArrayList<>();
         packages.add("com.fake.package0");
@@ -390,6 +374,48 @@ public class AppsIndexerImplTest {
         }
     }
 
+    @Test
+    public void testAppsIndexerImpl_fullUpdateRequired_reIndexAllApps() throws Exception {
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        List<PackageInfo> fakePackageInfos = createFakePackageInfos(3);
+        List<ResolveInfo> fakeResolveInfos = createFakeResolveInfos(3);
+        setupMockPackageManager(
+                pm1,
+                fakePackageInfos,
+                fakeResolveInfos,
+                /* appFunctionServices= */ ImmutableList.of());
+        Context context1 = createContextWithPackageManager(pm1);
+        // Perform the first update
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats = new AppsUpdateStats();
+            appsIndexerImpl.doUpdate(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")), stats);
+
+            // Check the stats object after the first update
+            assertThat(stats.mNumberOfAppsAdded).isEqualTo(3); // Three new apps added
+            assertThat(stats.mNumberOfAppsRemoved).isEqualTo(0); // No apps deleted
+            assertThat(stats.mNumberOfAppsUnchanged).isEqualTo(0); // No apps unchanged
+            assertThat(stats.mNumberOfAppsUpdated).isEqualTo(0); // No apps updated
+        }
+
+        // Update only 1 app and run the indexer with isFullUpdateRequired=true
+        fakePackageInfos.get(1).lastUpdateTime = 1000;
+
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    stats,
+                    /* isFullUpdateRequired= */ true);
+
+            // Check the stats object after the first update
+            assertThat(stats.mNumberOfAppsAdded).isEqualTo(0);
+            assertThat(stats.mNumberOfAppsRemoved).isEqualTo(0);
+            assertThat(stats.mNumberOfAppsUnchanged).isEqualTo(0);
+            assertThat(stats.mNumberOfAppsUpdated).isEqualTo(3); // All 3 apps updated.
+        }
+    }
+
     // This does not have the @RequiresFlagEnabled annotation as it directly calls the "incremental
     // update" path.
     @Test
@@ -404,9 +430,11 @@ public class AppsIndexerImplTest {
         List<ResolveInfo> fakeActivities = ImmutableList.of(createFakeLaunchResolveInfo(0));
         List<ResolveInfo> fakeAppFunctionServices =
                 ImmutableList.of(createFakeAppFunctionResolveInfo(0));
-
         when(pm1.getProperty(any(String.class), any(ComponentName.class)))
-                .thenReturn(new PackageManager.Property("", "", "", ""));
+                .thenThrow(PackageManager.NameNotFoundException.class);
+        when(pm1.getProperty(eq("android.app.appfunctions"), any(ComponentName.class)))
+                .thenReturn(new PackageManager.Property("", "app_functions.xml", "", ""));
+
         AssetManager assetManager = Mockito.mock(AssetManager.class);
 
         // One functions initially
@@ -419,7 +447,7 @@ public class AppsIndexerImplTest {
                         + "  </appfunction>\n"
                         + "</appfunctions>";
 
-        when(assetManager.open(any(String.class)))
+        when(assetManager.open(eq("app_functions.xml")))
                 .thenReturn(new ByteArrayInputStream(xml.getBytes()));
 
         Resources resources = Mockito.mock(Resources.class);
@@ -427,21 +455,17 @@ public class AppsIndexerImplTest {
         when(pm1.getResourcesForApplication(any(String.class))).thenReturn(resources);
         setupMockPackageManager(pm1, fakePackages, fakeActivities, fakeAppFunctionServices);
 
-        Context context1 =
-                new ContextWrapper(mContext) {
-                    @Override
-                    public PackageManager getPackageManager() {
-                        return pm1;
-                    }
-                };
+        Context context1 = createContextWithPackageManager(pm1);
 
-        List<String> packages = ImmutableList.of("com.fake.package0");
+        Set<String> packages = ImmutableSet.of("com.fake.package0");
 
         // Perform the first update
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
             AppsUpdateStats stats1 = new AppsUpdateStats();
             appsIndexerImpl.doUpdateIncrementalPut(
-                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")), stats1);
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
 
             // Check the stats object after the first update
             assertThat(stats1.mNumberOfAppsAdded).isEqualTo(1);
@@ -450,15 +474,17 @@ public class AppsIndexerImplTest {
             assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(0);
 
             // Verify the state of the indexed apps after the first update
-            assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch(packages).keySet())
+            assertThat(mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages).keySet())
                     .containsExactlyElementsIn(packages);
         }
 
         // Manually modify the AppSearch function document timestamp
-        Map<String, Map<String, AppFunctionStaticMetadata>> indexedFunctions =
-                mAppSearchHelper.getAppFunctionsFromAppSearch(packages);
+        Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages);
         GenericDocument original =
-                indexedFunctions.get("com.fake.package0").get("com.example.utils#print");
+                indexedFunctions
+                        .get("com.fake.package0")
+                        .get("com.fake.package0/com.example.utils#print");
         long firstPutTimestamp = original.getCreationTimestampMillis();
 
         // Simulate an update
@@ -484,7 +510,9 @@ public class AppsIndexerImplTest {
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
             AppsUpdateStats stats1 = new AppsUpdateStats();
             appsIndexerImpl.doUpdateIncrementalPut(
-                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")), stats1);
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
 
             // Check the stats object after the first update
             assertThat(stats1.mNumberOfAppsAdded).isEqualTo(0);
@@ -492,16 +520,716 @@ public class AppsIndexerImplTest {
             assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0);
             assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(1);
 
-            assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch(packages).keySet())
+            assertThat(mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages).keySet())
                     .containsExactlyElementsIn(packages);
         }
-        indexedFunctions = mAppSearchHelper.getAppFunctionsFromAppSearch(packages);
+        indexedFunctions = mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages);
         GenericDocument unchangedFunctions =
-                indexedFunctions.get("com.fake.package0").get("com.example.utils#print");
+                indexedFunctions
+                        .get("com.fake.package0")
+                        .get("com.fake.package0/com.example.utils#print");
         GenericDocument addedFunction =
-                indexedFunctions.get("com.fake.package0").get("com.example.utils#search");
+                indexedFunctions
+                        .get("com.fake.package0")
+                        .get("com.fake.package0/com.example.utils#search");
 
         assertEquals(unchangedFunctions.getCreationTimestampMillis(), firstPutTimestamp);
         assertThat(addedFunction.getCreationTimestampMillis()).isGreaterThan(firstPutTimestamp);
     }
+
+    @Test
+    public void testAppsIndexerImpl_incrementalPut_allFunctionsRemovedButAppFunctionServicePresent()
+            throws Exception {
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        List<PackageInfo> fakePackages = ImmutableList.of(createFakePackageInfo(0));
+        List<ResolveInfo> fakeActivities = ImmutableList.of(createFakeLaunchResolveInfo(0));
+        List<ResolveInfo> fakeAppFunctionServices =
+                ImmutableList.of(createFakeAppFunctionResolveInfo(0));
+        when(pm1.getProperty(any(String.class), any(ComponentName.class)))
+                .thenThrow(PackageManager.NameNotFoundException.class);
+        when(pm1.getProperty(eq("android.app.appfunctions"), any(ComponentName.class)))
+                .thenReturn(new PackageManager.Property("", "app_functions.xml", "", ""));
+        AssetManager assetManager = Mockito.mock(AssetManager.class);
+        // One functions initially
+        String xml =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<version>1</version>\n"
+                        + "<appfunctions>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#print</function_id>\n"
+                        + "  </appfunction>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(xml.getBytes()));
+        setUpResourcesForApp(assetManager, pm1, fakePackages.get(0).packageName);
+        setupMockPackageManager(pm1, fakePackages, fakeActivities, fakeAppFunctionServices);
+        Context context1 = createContextWithPackageManager(pm1);
+        Set<String> packages = ImmutableSet.of("com.fake.package0");
+        // Perform the first update
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
+        }
+
+        // Simulate an update
+        fakePackages.get(0).lastUpdateTime = 1000;
+        // Remove the function
+        String xmlWithNoFunctions =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<version>1</version>\n"
+                        + "<appfunctions>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(xmlWithNoFunctions.getBytes()));
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
+        }
+
+        assertThat(mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages).keySet())
+                .isEmpty();
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APP_FUNCTIONS_SCHEMA_PARSER)
+    public void testAppsIndexerImpl_withDynamicAndNoSchemasDefinedInApp_indexesAppFunctions()
+            throws Exception {
+        // Dynamic schema defined in the app1.
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        PackageInfo dynamicSchemaApp = createFakePackageInfo(0);
+        ResolveInfo dynamicSchemaAppResolveInfo = createFakeLaunchResolveInfo(0);
+        ResolveInfo dynamicSchemaAppFunctionResolveInfo = createFakeAppFunctionResolveInfo(0);
+        setUpAppFunctionProperties(pm1, dynamicSchemaAppFunctionResolveInfo);
+        AssetManager assetManager = Mockito.mock(AssetManager.class);
+        when(assetManager.open(eq("app_function_schema.xml")))
+                .thenReturn(
+                        new ByteArrayInputStream(
+                                APP_FUNCTION_STATIC_METADATA_PARENT_SCHEMA_XSD.getBytes()));
+        String appFunctionsXml =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.dynamicSchemaApp.utils#print</id>\n"
+                        + "    <functionId>com.dynamicSchemaApp.utils#print</functionId>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml.getBytes()));
+        setUpResourcesForApp(assetManager, pm1, dynamicSchemaApp.packageName);
+        // No schema defined in the app2.
+        PackageInfo noSchemaApp = createFakePackageInfo(1);
+        ResolveInfo noSchemaAppResolveInfo = createFakeLaunchResolveInfo(1);
+        ResolveInfo noSchemaAppFunctionResolveInfo = createFakeAppFunctionResolveInfo(1);
+        when(pm1.getProperty(
+                        eq("android.app.appfunctions.schema"),
+                        eq(
+                                new ComponentName(
+                                        noSchemaAppFunctionResolveInfo.serviceInfo.packageName,
+                                        noSchemaAppFunctionResolveInfo.serviceInfo.name))))
+                .thenThrow(new PackageManager.NameNotFoundException());
+        when(pm1.getProperty(
+                        eq("android.app.appfunctions"),
+                        eq(
+                                new ComponentName(
+                                        noSchemaAppFunctionResolveInfo.serviceInfo.packageName,
+                                        noSchemaAppFunctionResolveInfo.serviceInfo.name))))
+                .thenReturn(new PackageManager.Property("", "app_functions.xml", "", ""));
+        AssetManager assetManager2 = Mockito.mock(AssetManager.class);
+        String appFunctionsXml2 =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.noSchemaApp.utils#print</function_id>\n"
+                        + "  </appfunction>\n"
+                        + "</appfunctions>";
+        when(assetManager2.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml2.getBytes()));
+        setUpResourcesForApp(assetManager2, pm1, noSchemaApp.packageName);
+        setupMockPackageManager(
+                pm1,
+                ImmutableList.of(dynamicSchemaApp, noSchemaApp),
+                ImmutableList.of(dynamicSchemaAppResolveInfo, noSchemaAppResolveInfo),
+                ImmutableList.of(
+                        dynamicSchemaAppFunctionResolveInfo, noSchemaAppFunctionResolveInfo));
+        Context context1 = createContextWithPackageManager(pm1);
+
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    new AppsUpdateStats(),
+                    /* isFullUpdateRequired= */ false);
+
+            Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                    mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(
+                            ImmutableSet.of(dynamicSchemaApp.packageName, noSchemaApp.packageName));
+            assertThat(indexedFunctions.keySet())
+                    .containsExactly(dynamicSchemaApp.packageName, noSchemaApp.packageName);
+            assertThat(indexedFunctions.get(dynamicSchemaApp.packageName).keySet())
+                    .containsExactly("com.fake.package0/com.dynamicSchemaApp.utils#print");
+            assertThat(indexedFunctions.get(noSchemaApp.packageName).keySet())
+                    .containsExactly("com.fake.package1/com.noSchemaApp.utils#print");
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APP_FUNCTIONS_SCHEMA_PARSER)
+    public void testAppsIndexerImpl_withValidAndInvalidSchemas_indexesOnlyValidSchemaApp()
+            throws Exception {
+        // Valid schema
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        PackageInfo validSchemaApp = createFakePackageInfo(0);
+        ResolveInfo validSchemaAppResolveInfo = createFakeLaunchResolveInfo(0);
+        ResolveInfo validSchemaAppFunctionResolveInfo = createFakeAppFunctionResolveInfo(0);
+        setUpAppFunctionProperties(pm1, validSchemaAppFunctionResolveInfo);
+        AssetManager assetManager = Mockito.mock(AssetManager.class);
+        when(assetManager.open(eq("app_function_schema.xml")))
+                .thenReturn(
+                        new ByteArrayInputStream(
+                                APP_FUNCTION_STATIC_METADATA_PARENT_SCHEMA_XSD.getBytes()));
+        String appFunctionsXml =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.validSchemaApp.utils#print</id>\n"
+                        + "    <functionId>com.validSchemaApp.utils#print</functionId>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml.getBytes()));
+        setUpResourcesForApp(assetManager, pm1, validSchemaApp.packageName);
+        // Invalid schema with more than 64 indexable properties.
+        PackageInfo invalidSchemaApp = createFakePackageInfo(1);
+        ResolveInfo invalidSchemaAppResolveInfo = createFakeLaunchResolveInfo(1);
+        ResolveInfo invalidSchemaAppFunctionResolveInfo = createFakeAppFunctionResolveInfo(1);
+        setUpAppFunctionProperties(pm1, invalidSchemaAppFunctionResolveInfo);
+        AssetManager assetManager2 = Mockito.mock(AssetManager.class);
+        StringBuilder invalidSchemaXml =
+                new StringBuilder(
+                        "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                                + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                                + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES);
+        for (int i = 0; i < 100; i++) {
+            invalidSchemaXml
+                    .append("<xs:element name=\"randomProperty")
+                    .append(i)
+                    .append("\" type=\"xs:long\" indexingType=\"")
+                    .append(AppSearchSchema.LongPropertyConfig.INDEXING_TYPE_RANGE)
+                    .append("\" />");
+        }
+        invalidSchemaXml.append("    </xs:documentType>").append("</xs:schema>");
+        when(assetManager2.open(eq("app_function_schema.xml")))
+                .thenReturn(new ByteArrayInputStream(invalidSchemaXml.toString().getBytes()));
+        String appFunctionsXml2 =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.invalidSchemaApp.utils#print</id>\n"
+                        + "    <functionId>com.invalidSchemaApp.utils#print</functionId>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>";
+        when(assetManager2.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml2.getBytes()));
+        setUpResourcesForApp(assetManager2, pm1, invalidSchemaApp.packageName);
+        setupMockPackageManager(
+                pm1,
+                ImmutableList.of(validSchemaApp, invalidSchemaApp),
+                ImmutableList.of(validSchemaAppResolveInfo, invalidSchemaAppResolveInfo),
+                ImmutableList.of(
+                        validSchemaAppFunctionResolveInfo, invalidSchemaAppFunctionResolveInfo));
+        Context context1 = createContextWithPackageManager(pm1);
+
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    new AppsUpdateStats(),
+                    /* isFullUpdateRequired= */ false);
+
+            Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                    mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(
+                            ImmutableSet.of(
+                                    validSchemaApp.packageName, invalidSchemaApp.packageName));
+            assertThat(indexedFunctions.keySet()).containsExactly(validSchemaApp.packageName);
+            assertThat(indexedFunctions.get(validSchemaApp.packageName).keySet())
+                    .containsExactly("com.fake.package0/com.validSchemaApp.utils#print");
+            assertThat(indexedFunctions.keySet()).doesNotContain(invalidSchemaApp.packageName);
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APP_FUNCTIONS_SCHEMA_PARSER)
+    public void testAppsIndexerImpl_indexesMultipleAppsWithDynamicSchema() throws Exception {
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        PackageInfo schemaApp1 = createFakePackageInfo(0);
+        ResolveInfo schemaApp1ResolveInfo = createFakeLaunchResolveInfo(0);
+        ResolveInfo schemaApp1FunctionResolveInfo = createFakeAppFunctionResolveInfo(0);
+        setUpAppFunctionProperties(pm1, schemaApp1FunctionResolveInfo);
+        AssetManager assetManager = Mockito.mock(AssetManager.class);
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
+                        + "        <xs:element name=\"inner\" type=\"appfn:InnerType\" />"
+                        + "    </xs:documentType>"
+                        + "    <xs:documentType name=\"InnerType\">"
+                        + "        <xs:element name=\"value\" type=\"xs:string\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        when(assetManager.open(eq("app_function_schema.xml")))
+                .thenReturn(new ByteArrayInputStream(xsd.getBytes()));
+        String appFunctionsXml =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.schemaApp1.utils#print</id>\n"
+                        + "    <functionId>com.schemaApp1.utils#print</functionId>\n"
+                        + "    <inner>\n"
+                        + "      <id>com.schemaApp1/com.schemaApp1.utils#print/inner</id>\n"
+                        + "      <value>test</value>\n"
+                        + "    </inner>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml.getBytes()));
+        setUpResourcesForApp(assetManager, pm1, schemaApp1.packageName);
+        PackageInfo schemaApp2 = createFakePackageInfo(1);
+        ResolveInfo schemaApp2ResolveInfo = createFakeLaunchResolveInfo(1);
+        ResolveInfo schemaApp2FunctionResolveInfo = createFakeAppFunctionResolveInfo(1);
+        setUpAppFunctionProperties(pm1, schemaApp2FunctionResolveInfo);
+        AssetManager assetManager2 = Mockito.mock(AssetManager.class);
+        when(assetManager2.open(eq("app_function_schema.xml")))
+                .thenReturn(new ByteArrayInputStream(xsd.getBytes()));
+        String appFunctionsXml2 =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.schemaApp2.utils#print</id>\n"
+                        + "    <functionId>com.schemaApp2.utils#print</functionId>\n"
+                        + "    <inner>\n"
+                        + "      <id>com.schemaApp2/com.schemaApp1.utils#print/inner</id>\n"
+                        + "      <value>test</value>\n"
+                        + "    </inner>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>";
+        when(assetManager2.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml2.getBytes()));
+        setUpResourcesForApp(assetManager2, pm1, schemaApp2.packageName);
+        setupMockPackageManager(
+                pm1,
+                ImmutableList.of(schemaApp1, schemaApp2),
+                ImmutableList.of(schemaApp1ResolveInfo, schemaApp2ResolveInfo),
+                ImmutableList.of(schemaApp1FunctionResolveInfo, schemaApp2FunctionResolveInfo));
+        Context context1 = createContextWithPackageManager(pm1);
+
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    new AppsUpdateStats(),
+                    /* isFullUpdateRequired= */ false);
+
+            Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                    mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(
+                            ImmutableSet.of(schemaApp1.packageName, schemaApp2.packageName));
+            // Verify functions from both apps are indexed successfully.
+            assertThat(indexedFunctions.keySet())
+                    .containsExactly(schemaApp1.packageName, schemaApp2.packageName);
+            assertThat(indexedFunctions.get(schemaApp1.packageName).keySet())
+                    .containsExactly("com.fake.package0/com.schemaApp1.utils#print");
+            assertThat(indexedFunctions.get(schemaApp2.packageName).keySet())
+                    .containsExactly("com.fake.package1/com.schemaApp2.utils#print");
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APP_FUNCTIONS_SCHEMA_PARSER)
+    public void testAppsIndexerImpl_incrementalPut_withDynamicSchema_doesNotPutAllDocsOnUpdate()
+            throws Exception {
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        PackageInfo dynamicSchemaApp = createFakePackageInfo(0);
+        ResolveInfo dynamicSchemaAppResolveInfo = createFakeLaunchResolveInfo(0);
+        ResolveInfo dynamicSchemaAppFunctionResolveInfo = createFakeAppFunctionResolveInfo(0);
+        List<PackageInfo> fakePackages = ImmutableList.of(dynamicSchemaApp);
+        setUpAppFunctionProperties(pm1, dynamicSchemaAppFunctionResolveInfo);
+        AssetManager assetManager = Mockito.mock(AssetManager.class);
+        String xsdWithNestedTypes =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">\n"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
+                        + "        <xs:element name=\"nested\" type=\"appfn:NestedType\" />\n"
+                        + "    </xs:documentType>\n"
+                        + "    <xs:documentType name=\"NestedType\">\n"
+                        + "        <xs:element name=\"value\" type=\"xs:string\" />\n"
+                        + "    </xs:documentType>\n"
+                        + "</xs:schema>";
+        when(assetManager.open(eq("app_function_schema.xml")))
+                .thenAnswer(inv -> new ByteArrayInputStream(xsdWithNestedTypes.getBytes()));
+        String appFunctionsXml =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.dynamicSchemaApp.utils#print</id>\n"
+                        + "    <functionId>com.dynamicSchemaApp.utils#print</functionId>\n"
+                        + "    <nested>\n"
+                        + "     <id>com.dynamicSchemaApp.utils#print/nested0</id>\n"
+                        + "     <value>innerProperty</value>\n"
+                        + "    </nested>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml.getBytes()));
+        setUpResourcesForApp(assetManager, pm1, dynamicSchemaApp.packageName);
+        setupMockPackageManager(
+                pm1,
+                fakePackages,
+                ImmutableList.of(dynamicSchemaAppResolveInfo),
+                ImmutableList.of(dynamicSchemaAppFunctionResolveInfo));
+        Context context1 = createContextWithPackageManager(pm1);
+        Set<String> packageNames = ImmutableSet.of(dynamicSchemaApp.packageName);
+        // Perform the first update
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
+        }
+        // Find first put timestamp of the AppSearch function document
+        Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packageNames);
+        GenericDocument original =
+                indexedFunctions
+                        .get("com.fake.package0")
+                        .get("com.fake.package0/com.dynamicSchemaApp.utils#print");
+        long firstPutTimestamp = original.getCreationTimestampMillis();
+        // Simulate an update
+        fakePackages.get(0).lastUpdateTime = 1000;
+        String appFunctionsXml2 =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.dynamicSchemaApp.utils#print</id>\n"
+                        + "    <functionId>com.dynamicSchemaApp.utils#print</functionId>\n"
+                        + "    <nested>\n"
+                        + "     <id>com.dynamicSchemaApp.utils#print/nested0</id>\n"
+                        + "     <value>innerProperty</value>\n"
+                        + "    </nested>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.dynamicSchemaApp.utils#search</id>\n"
+                        + "    <functionId>com.dynamicSchemaApp.utils#search</functionId>\n"
+                        + "    <nested>\n"
+                        + "     <id>com.dynamicSchemaApp.utils#search/nested0</id>\n"
+                        + "     <value>innerProperty</value>\n"
+                        + "    </nested>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml2.getBytes()));
+
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
+
+            // Check the stats object after the first update
+            assertThat(stats1.mNumberOfAppsAdded).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsRemoved).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(1);
+
+            assertThat(mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packageNames).keySet())
+                    .containsExactlyElementsIn(packageNames);
+        }
+        indexedFunctions = mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packageNames);
+        GenericDocument unchangedFunction =
+                indexedFunctions
+                        .get("com.fake.package0")
+                        .get("com.fake.package0/com.dynamicSchemaApp.utils#print");
+        GenericDocument addedFunction =
+                indexedFunctions
+                        .get("com.fake.package0")
+                        .get("com.fake.package0/com.dynamicSchemaApp.utils#search");
+        assertThat(unchangedFunction.getCreationTimestampMillis()).isEqualTo(firstPutTimestamp);
+        assertThat(addedFunction.getCreationTimestampMillis()).isGreaterThan(firstPutTimestamp);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APP_FUNCTIONS_SCHEMA_PARSER)
+    public void
+            testAppsIndexerImpl_incrementalPut_withDynamicSchema_multipleRootSchemas_indexesDocs()
+                    throws Exception {
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        PackageInfo dynamicSchemaApp = createFakePackageInfo(0);
+        ResolveInfo dynamicSchemaAppResolveInfo = createFakeLaunchResolveInfo(0);
+        ResolveInfo dynamicSchemaAppFunctionResolveInfo = createFakeAppFunctionResolveInfo(0);
+        List<PackageInfo> fakePackages = ImmutableList.of(dynamicSchemaApp);
+        setUpAppFunctionProperties(pm1, dynamicSchemaAppFunctionResolveInfo);
+        AssetManager assetManager = Mockito.mock(AssetManager.class);
+        String xsdWithNestedTypes =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">\n"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
+                        + "    </xs:documentType>\n"
+                        + "    <xs:documentType name=\"AnotherTopLevelType\">\n"
+                        + "        <xs:element name=\"value\" type=\"xs:string\" />\n"
+                        + "        <xs:element name=\"packageName\" type=\"xs:string\" cardinality="
+                        + "\""
+                        + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                        + "\" indexingType=\""
+                        + AppSearchSchema.StringPropertyConfig.INDEXING_TYPE_EXACT_TERMS
+                        + "\" tokenizerType=\""
+                        + AppSearchSchema.StringPropertyConfig.TOKENIZER_TYPE_VERBATIM
+                        + "\" />\n"
+                        + "        <xs:element name=\"mobileApplicationQualifiedId\" type=\"xs:"
+                        + "string\" cardinality=\""
+                        + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                        + "\" joinableValueType=\""
+                        + AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID
+                        + "\" />\n"
+                        + "    </xs:documentType>\n"
+                        + "</xs:schema>";
+        when(assetManager.open(eq("app_function_schema.xml")))
+                .thenAnswer(inv -> new ByteArrayInputStream(xsdWithNestedTypes.getBytes()));
+        String appFunctionsXml =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.dynamicSchemaApp.utils#print</id>\n"
+                        + "    <functionId>com.dynamicSchemaApp.utils#print</functionId>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "  <AnotherTopLevelType>\n"
+                        + "    <id>com.dynamicSchemaApp.utils#anotherTopLevelType</id>\n"
+                        + "    <value>anotherTopLevelTypeValue</value>\n"
+                        + "  </AnotherTopLevelType>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml.getBytes()));
+        setUpResourcesForApp(assetManager, pm1, dynamicSchemaApp.packageName);
+        setupMockPackageManager(
+                pm1,
+                fakePackages,
+                ImmutableList.of(dynamicSchemaAppResolveInfo),
+                ImmutableList.of(dynamicSchemaAppFunctionResolveInfo));
+        Context context1 = createContextWithPackageManager(pm1);
+        Set<String> packageNames = ImmutableSet.of(dynamicSchemaApp.packageName);
+        // Perform the first update
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
+        }
+        // Find first put timestamp of the AppSearch function document
+        Map<String, Map<String, AppFunctionDocument>> indexedFunctionDocuments =
+                mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packageNames);
+        assertThat(indexedFunctionDocuments.get("com.fake.package0").keySet()).hasSize(2);
+        assertThat(indexedFunctionDocuments.get("com.fake.package0").keySet())
+                .containsExactly(
+                        "com.fake.package0/com.dynamicSchemaApp.utils#print",
+                        "com.fake.package0/com.dynamicSchemaApp.utils#anotherTopLevelType");
+        GenericDocument fnMetadata =
+                indexedFunctionDocuments
+                        .get("com.fake.package0")
+                        .get("com.fake.package0/com.dynamicSchemaApp.utils#print");
+        assertThat(fnMetadata.getPropertyString("functionId"))
+                .isEqualTo("com.dynamicSchemaApp.utils#print");
+        GenericDocument anotherTopLevelDocument =
+                indexedFunctionDocuments
+                        .get("com.fake.package0")
+                        .get("com.fake.package0/com.dynamicSchemaApp.utils#anotherTopLevelType");
+        assertThat(anotherTopLevelDocument.getPropertyString("value"))
+                .isEqualTo("anotherTopLevelTypeValue");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APP_FUNCTIONS_SCHEMA_PARSER)
+    public void testAppsIndexerImpl_incrementalPut_newSchemaProperty_indexesTheNewProperty()
+            throws Exception {
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        PackageInfo dynamicSchemaApp = createFakePackageInfo(0);
+        ResolveInfo dynamicSchemaAppResolveInfo = createFakeLaunchResolveInfo(0);
+        ResolveInfo dynamicSchemaAppFunctionResolveInfo = createFakeAppFunctionResolveInfo(0);
+        List<PackageInfo> fakePackages = ImmutableList.of(dynamicSchemaApp);
+        setUpAppFunctionProperties(pm1, dynamicSchemaAppFunctionResolveInfo);
+        AssetManager assetManager = Mockito.mock(AssetManager.class);
+        when(assetManager.open(eq("app_function_schema.xml")))
+                .thenAnswer(
+                        inv ->
+                                new ByteArrayInputStream(
+                                        APP_FUNCTION_STATIC_METADATA_PARENT_SCHEMA_XSD.getBytes()));
+        String appFunctionsXml =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.dynamicSchemaApp.utils#print</id>\n"
+                        + "    <functionId>com.dynamicSchemaApp.utils#print</functionId>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml.getBytes()));
+        setUpResourcesForApp(assetManager, pm1, dynamicSchemaApp.packageName);
+        setupMockPackageManager(
+                pm1,
+                fakePackages,
+                ImmutableList.of(dynamicSchemaAppResolveInfo),
+                ImmutableList.of(dynamicSchemaAppFunctionResolveInfo));
+        Context context1 = createContextWithPackageManager(pm1);
+        Set<String> packageNames = ImmutableSet.of(dynamicSchemaApp.packageName);
+        // Perform the first update
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
+        }
+        // Simulate an update with new schema.
+        fakePackages.get(0).lastUpdateTime = 1000;
+        String schemaXmlWithNewProperty =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
+                        + "        <xs:element name=\"newProperty\" type=\"xs:string\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        String appFunctionsXml2 =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <id>com.dynamicSchemaApp.utils#print</id>\n"
+                        + "    <functionId>com.dynamicSchemaApp.utils#print</functionId>\n"
+                        + "    <newProperty>test_new_property</newProperty>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>";
+        when(assetManager.open(eq("app_function_schema.xml")))
+                .thenReturn(new ByteArrayInputStream(schemaXmlWithNewProperty.getBytes()));
+        when(assetManager.open(eq("app_functions.xml")))
+                .thenReturn(new ByteArrayInputStream(appFunctionsXml2.getBytes()));
+
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
+
+            // Check the stats object after the first update
+            assertThat(stats1.mNumberOfAppsAdded).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsRemoved).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(1);
+        }
+        Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packageNames);
+        GenericDocument updatedFunction =
+                indexedFunctions
+                        .get("com.fake.package0")
+                        .get("com.fake.package0/com.dynamicSchemaApp.utils#print");
+        assertThat(updatedFunction.getPropertyString("newProperty")).isEqualTo("test_new_property");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APPS_INDEXER_INCREMENTAL_PUT)
+    public void testAppsIndexerImpl_incrementalPut_differentTimestamp_reindexes() throws Exception {
+        // Simulate the first update: no changes, just adding initial apps
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        List<PackageInfo> fakePackages = new ArrayList<>(createFakePackageInfos(3));
+        List<ResolveInfo> fakeActivities = new ArrayList<>(createFakeResolveInfos(3));
+        fakePackages.get(1).lastUpdateTime = 1000;
+        fakePackages.get(2).lastUpdateTime = 1000;
+        setupMockPackageManager(
+                pm1, fakePackages, fakeActivities, /* appFunctionServices= */ ImmutableList.of());
+        Context context1 = createContextWithPackageManager(pm1);
+
+        // Perform the first update
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
+
+            // Check the stats object after the first update
+            assertThat(stats1.mNumberOfAppsAdded).isEqualTo(3); // Three new apps added
+            assertThat(stats1.mNumberOfAppsRemoved).isEqualTo(0); // No apps deleted
+            assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0); // No apps unchanged
+            assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(0); // No apps updated
+
+            // Verify the state of the indexed apps after the first update
+            assertThat(mAppSearchHelper.getAppsFromAppSearch().keySet())
+                    .containsExactly("com.fake.package0", "com.fake.package1", "com.fake.package2");
+        }
+
+        PackageManager pm2 = Mockito.mock(PackageManager.class);
+        // Simulate an update where last update time goes down due to an incorrect system clock for
+        // one package. It should still be re-indexed
+        fakePackages.get(1).lastUpdateTime = 999;
+        fakePackages.get(2).lastUpdateTime = 1001;
+
+        setupMockPackageManager(
+                pm2, fakePackages, fakeActivities, /* appFunctionServices= */ ImmutableList.of());
+        Context context2 = createContextWithPackageManager(pm2);
+
+        // Perform the second update
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context2, mAppsIndexerConfig)) {
+            AppsUpdateStats stats2 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    stats2,
+                    /* isFullUpdateRequired= */ false);
+
+            // Check the stats object after the second update
+            assertThat(stats2.mNumberOfAppsAdded).isEqualTo(0); // No apps added
+            assertThat(stats2.mNumberOfAppsRemoved).isEqualTo(0); // No apps deleted
+            assertThat(stats2.mNumberOfAppsUnchanged).isEqualTo(1); // One app unchanged
+            assertThat(stats2.mNumberOfAppsUpdated).isEqualTo(2); // Two apps updated
+
+            // Verify the state of the indexed apps after the second update
+            assertThat(mAppSearchHelper.getAppsFromAppSearch().keySet())
+                    .containsExactly("com.fake.package0", "com.fake.package1", "com.fake.package2");
+        }
+    }
+
+    private static void setUpAppFunctionProperties(PackageManager pm, ResolveInfo resolveInfo)
+            throws Exception {
+        when(pm.getProperty(
+                        eq("android.app.appfunctions.schema"),
+                        eq(
+                                new ComponentName(
+                                        resolveInfo.serviceInfo.packageName,
+                                        resolveInfo.serviceInfo.name))))
+                .thenReturn(new PackageManager.Property("", "app_function_schema.xml", "", ""));
+        when(pm.getProperty(
+                        eq("android.app.appfunctions.v2"),
+                        eq(
+                                new ComponentName(
+                                        resolveInfo.serviceInfo.packageName,
+                                        resolveInfo.serviceInfo.name))))
+                .thenReturn(new PackageManager.Property("", "app_functions.xml", "", ""));
+    }
+
+    private static void setUpResourcesForApp(
+            AssetManager assetManager, PackageManager pm1, String packageName)
+            throws PackageManager.NameNotFoundException {
+        Resources resources = Mockito.mock(Resources.class);
+        when(resources.getAssets()).thenReturn(assetManager);
+        when(pm1.getResourcesForApplication(eq(packageName))).thenReturn(resources);
+    }
+
+    private ContextWrapper createContextWithPackageManager(PackageManager pm) {
+        return new ContextWrapper(mContext) {
+            @Override
+            public PackageManager getPackageManager() {
+                return pm;
+            }
+        };
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerMaintenanceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerMaintenanceTest.java
index b74a0c01..6a02df0e 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerMaintenanceTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerMaintenanceTest.java
@@ -31,7 +31,7 @@ import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import android.annotation.UserIdInt;
@@ -321,7 +321,7 @@ public class AppsIndexerMaintenanceTest {
         mAppsIndexerMaintenanceService.doUpdateForUser(
                 mContextWrapper, mParams, DEFAULT_USER_HANDLE, new CancellationSignal());
 
-        verifyZeroInteractions(mMockJobScheduler);
+        verifyNoMoreInteractions(mMockJobScheduler);
     }
 
     @Test
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerManagerServiceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerManagerServiceTest.java
index 96cb92c2..e9cd6422 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerManagerServiceTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerManagerServiceTest.java
@@ -174,6 +174,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         UserInfo userInfo =
                 new UserInfo(
                         mContext.getUser().getIdentifier(), /* name= */ "default", /* flags= */ 0);
+        SystemService.TargetUser targetUser = new SystemService.TargetUser(userInfo);
         GlobalSearchSessionShim db =
                 GlobalSearchSessionShimImpl.createGlobalSearchSessionAsync(mContext).get();
         // Apps indexer schedules a full-update job for bootstrapping from PackageManager,
@@ -182,7 +183,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         try {
             CountDownLatch bootstrapLatch =
                     setupLatch(numFakePackages, /* listenForSchemaChanges= */ false);
-            mAppsIndexerManagerService.onUserUnlocking(new SystemService.TargetUser(userInfo));
+            mAppsIndexerManagerService.onUserUnlocking(targetUser);
             assertTrue(bootstrapLatch.await(10000L, TimeUnit.MILLISECONDS));
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -210,7 +211,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
                         "builtin:MobileApplication-com.fake.package1",
                         "builtin:MobileApplication-com.fake.package0");
 
-        mAppsIndexerManagerService.onUserStopping(new SystemService.TargetUser(userInfo));
+        mAppsIndexerManagerService.onUserStopping(targetUser);
     }
 
     @Test
@@ -229,6 +230,8 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         UserInfo userInfo =
                 new UserInfo(
                         mContext.getUser().getIdentifier(), /* name= */ "default", /* flags= */ 0);
+
+        SystemService.TargetUser targetUser = new SystemService.TargetUser(userInfo);
         GlobalSearchSessionShim db =
                 GlobalSearchSessionShimImpl.createGlobalSearchSessionAsync(mContext).get();
         // Apps indexer schedules a full-update job for bootstrapping from PackageManager,
@@ -237,7 +240,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         CountDownLatch bootstrapLatch = null;
         try {
             bootstrapLatch = setupLatch(numFakePackages, /* listenForSchemaChanges= */ false);
-            mAppsIndexerManagerService.onUserUnlocking(new SystemService.TargetUser(userInfo));
+            mAppsIndexerManagerService.onUserUnlocking(targetUser);
             assertTrue(bootstrapLatch.await(10000L, TimeUnit.MILLISECONDS));
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -246,7 +249,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         // Add a package and trigger an update directly
         Intent fakeIntent = new Intent(Intent.ACTION_PACKAGE_ADDED);
         fakeIntent.setData(Uri.parse("package:" + mContext.getPackageName()));
-        fakeIntent.putExtra(Intent.EXTRA_UID, userInfo.id);
+        fakeIntent.putExtra(Intent.EXTRA_UID, targetUser.getUserHandle().getUid(20));
 
         // Add a package at index numFakePackages
         fakePackages.add(createFakePackageInfo(numFakePackages));
@@ -268,7 +271,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         // 10 is greater than the expected number of results, which is numFakePackage + 1 = 4
         assertThat(page).hasSize(numFakePackages + 1);
 
-        mAppsIndexerManagerService.onUserStopping(new SystemService.TargetUser(userInfo));
+        mAppsIndexerManagerService.onUserStopping(targetUser);
     }
 
     @Test
@@ -287,6 +290,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         UserInfo userInfo =
                 new UserInfo(
                         mContext.getUser().getIdentifier(), /* name= */ "default", /* flags= */ 0);
+        SystemService.TargetUser targetUser = new SystemService.TargetUser(userInfo);
         GlobalSearchSessionShim db =
                 GlobalSearchSessionShimImpl.createGlobalSearchSessionAsync(mContext).get();
         // Apps indexer schedules a full-update job for bootstrapping from PackageManager,
@@ -295,7 +299,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         CountDownLatch bootstrapLatch = null;
         try {
             bootstrapLatch = setupLatch(numFakePackages, /* listenForSchemaChanges= */ false);
-            mAppsIndexerManagerService.onUserUnlocking(new SystemService.TargetUser(userInfo));
+            mAppsIndexerManagerService.onUserUnlocking(targetUser);
             assertTrue(bootstrapLatch.await(10000L, TimeUnit.MILLISECONDS));
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -304,7 +308,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         // Update a package by updating the timestamp and trigger an update
         Intent fakeIntent = new Intent(Intent.ACTION_PACKAGE_CHANGED);
         fakeIntent.setData(Uri.parse("package:" + mContext.getPackageName()));
-        fakeIntent.putExtra(Intent.EXTRA_UID, userInfo.id);
+        fakeIntent.putExtra(Intent.EXTRA_UID, targetUser.getUserHandle().getUid(20));
         // This has to match the package in data to indicate that this was not just a component
         // change, but that the entire package was changed.
         fakeIntent.putExtra(
@@ -337,7 +341,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         }
         assertThat(timestamps).contains(1000L);
 
-        mAppsIndexerManagerService.onUserStopping(new SystemService.TargetUser(userInfo));
+        mAppsIndexerManagerService.onUserStopping(targetUser);
     }
 
     @Test
@@ -356,6 +360,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         UserInfo userInfo =
                 new UserInfo(
                         mContext.getUser().getIdentifier(), /* name= */ "default", /* flags= */ 0);
+        SystemService.TargetUser targetUser = new SystemService.TargetUser(userInfo);
         GlobalSearchSessionShim db =
                 GlobalSearchSessionShimImpl.createGlobalSearchSessionAsync(mContext).get();
         // Apps indexer schedules a full-update job for bootstrapping from PackageManager,
@@ -364,7 +369,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         CountDownLatch bootstrapLatch = null;
         try {
             bootstrapLatch = setupLatch(numFakePackages, /* listenForSchemaChanges= */ false);
-            mAppsIndexerManagerService.onUserUnlocking(new SystemService.TargetUser(userInfo));
+            mAppsIndexerManagerService.onUserUnlocking(targetUser);
             assertTrue(bootstrapLatch.await(10000L, TimeUnit.MILLISECONDS));
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -373,7 +378,7 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         // Delete a package and trigger an update
         Intent fakeIntent = new Intent(Intent.ACTION_PACKAGE_FULLY_REMOVED);
         fakeIntent.setData(Uri.parse("package:" + mContext.getPackageName()));
-        fakeIntent.putExtra(Intent.EXTRA_UID, userInfo.id);
+        fakeIntent.putExtra(Intent.EXTRA_UID, targetUser.getUserHandle().getUid(20));
 
         fakePackages.remove(0);
         fakeActivities.remove(0);
@@ -394,6 +399,6 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
         // 10 is greater than the expected number of results, which is numFakePackage - 1 = 2
         assertThat(page).hasSize(numFakePackages - 1);
 
-        mAppsIndexerManagerService.onUserStopping(new SystemService.TargetUser(userInfo));
+        mAppsIndexerManagerService.onUserStopping(targetUser);
     }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerSettingsTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerSettingsTest.java
index e12d2841..a616d9db 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerSettingsTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerSettingsTest.java
@@ -43,12 +43,14 @@ public class AppsIndexerSettingsTest {
         // Set some values, persist them, and then load them back
         mIndexerSettings.setLastUpdateTimestampMillis(123456789L);
         mIndexerSettings.setLastAppUpdateTimestampMillis(987654321L);
+        mIndexerSettings.setLastAttemptedUpdateTimestampMillis(5678L);
         // Persist to file
         mIndexerSettings.persist();
 
         // Reset the settings to ensure loading happens from the file
         mIndexerSettings.setLastUpdateTimestampMillis(0);
         mIndexerSettings.setLastAppUpdateTimestampMillis(0);
+        mIndexerSettings.setLastAttemptedUpdateTimestampMillis(0);
 
         // Load from file
         mIndexerSettings.load();
@@ -56,14 +58,17 @@ public class AppsIndexerSettingsTest {
         // Check values after loading
         Assert.assertEquals(123456789L, mIndexerSettings.getLastUpdateTimestampMillis());
         Assert.assertEquals(987654321L, mIndexerSettings.getLastAppUpdateTimestampMillis());
+        Assert.assertEquals(5678L, mIndexerSettings.getLastAttemptedUpdateTimestampMillis());
     }
 
     @Test
     public void testReset() {
         mIndexerSettings.setLastUpdateTimestampMillis(123456789L);
         mIndexerSettings.setLastAppUpdateTimestampMillis(987654321L);
+        mIndexerSettings.setLastAttemptedUpdateTimestampMillis(5678L);
         mIndexerSettings.reset();
         Assert.assertEquals(0, mIndexerSettings.getLastUpdateTimestampMillis());
         Assert.assertEquals(0, mIndexerSettings.getLastAppUpdateTimestampMillis());
+        Assert.assertEquals(0, mIndexerSettings.getLastAttemptedUpdateTimestampMillis());
     }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java
index 350fbaf2..39b743c6 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java
@@ -16,6 +16,8 @@
 
 package com.android.server.appsearch.appsindexer;
 
+import static com.android.server.appsearch.appsindexer.AppIndexerVersions.APP_INDEXER_VERSION_UNKNOWN;
+import static com.android.server.appsearch.appsindexer.AppIndexerVersions.CURR_APP_INDEXER_VERSION;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakePackageInfos;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeResolveInfos;
 import static com.android.server.appsearch.appsindexer.TestUtils.removeFakePackageDocuments;
@@ -23,6 +25,8 @@ import static com.android.server.appsearch.appsindexer.TestUtils.setupMockPackag
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static junit.framework.Assert.assertTrue;
+
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
@@ -35,6 +39,7 @@ import android.app.appsearch.AppSearchManager;
 import android.app.appsearch.AppSearchSessionShim;
 import android.app.appsearch.SetSchemaRequest;
 import android.app.appsearch.testutil.AppSearchSessionShimImpl;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.app.job.JobInfo;
 import android.app.job.JobScheduler;
 import android.content.Context;
@@ -42,9 +47,12 @@ import android.content.ContextWrapper;
 import android.content.pm.PackageManager;
 import android.os.PersistableBundle;
 import android.os.UserHandle;
+import android.platform.test.annotations.RequiresFlagsDisabled;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 
 import androidx.test.core.app.ApplicationProvider;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.indexer.IndexerSettings;
 
 import com.google.common.collect.ImmutableList;
@@ -53,6 +61,7 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
 import org.mockito.ArgumentCaptor;
 
@@ -72,6 +81,8 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
 
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
 
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
+
     private ThreadPoolExecutor mSingleThreadedExecutor;
     private File mAppsDir;
     private File mSettingsFile;
@@ -95,6 +106,7 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
 
         // Setup the file path to the persisted data
         mAppsDir = new File(mTemporaryFolder.newFolder(), "appsearch/apps");
+        mAppsDir.mkdirs();
         mSettingsFile = new File(mAppsDir, AppsIndexerSettings.SETTINGS_FILE_NAME);
         mInstance =
                 AppsIndexerUserInstance.createInstance(
@@ -148,7 +160,7 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         semaphore.acquire();
 
         while (mSingleThreadedExecutor.getCompletedTaskCount() != beforeFirstRun + 1) {
-            continue;
+            Thread.sleep(100);
         }
 
         assertThat(mSingleThreadedExecutor.getCompletedTaskCount()).isEqualTo(beforeFirstRun + 1);
@@ -160,6 +172,7 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
     }
 
     @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_ALL_PACKAGE_INDEXING_ON_INDEXER_UPDATE)
     public void testFirstRun_updateAlreadyRan_doesNotUpdate() throws Exception {
         // Pretend we already ran
         AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
@@ -204,7 +217,7 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         semaphore.acquire();
 
         while (mSingleThreadedExecutor.getCompletedTaskCount() != beforeFirstRun + 1) {
-            continue;
+            Thread.sleep(100);
         }
         // One more task should've ran, checked settings, and exited
         assertThat(mSingleThreadedExecutor.getActiveCount()).isEqualTo(0);
@@ -218,6 +231,372 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         }
     }
 
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_APPS_INDEXER_CHECK_PRIOR_ATTEMPT)
+    @Test
+    public void testFirstRun_withoutCheckPriorAttempt_doesNotWrite() throws Exception {
+        // This semaphore allows us to pause test execution until we're sure the tasks in
+        // AppsIndexerUserInstance are finished.
+        final Semaphore semaphore = new Semaphore(0);
+        mSingleThreadedExecutor =
+                new ThreadPoolExecutor(
+                        /* corePoolSize= */ 1,
+                        /* maximumPoolSize= */ 1,
+                        /* KeepAliveTime= */ 0L,
+                        TimeUnit.MILLISECONDS,
+                        new LinkedBlockingQueue<>()) {
+                    @Override
+                    protected void afterExecute(Runnable r, Throwable t) {
+                        super.afterExecute(r, t);
+                        semaphore.release();
+                    }
+                };
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+
+        // Pretend there's one package on device
+        setupMockPackageManager(
+                mMockPackageManager,
+                createFakePackageInfos(1),
+                createFakeResolveInfos(1),
+                /* appFunctionServices= */ ImmutableList.of());
+
+        // Wait for file setup, as file setup uses the same ExecutorService.
+        semaphore.acquire();
+
+        mInstance.updateAsync(true);
+
+        // Wait for the task to finish
+        semaphore.acquire();
+
+        AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
+        settings.load();
+        long lastAttemptedUpdatedTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+        assertThat(lastAttemptedUpdatedTimestampMillis).isEqualTo(0);
+    }
+
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APPS_INDEXER_CHECK_PRIOR_ATTEMPT)
+    @Test
+    public void testFirstRun_lastRunInFuture_runsSync() throws Exception {
+        AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
+        settings.setLastAttemptedUpdateTimestampMillis(Long.MAX_VALUE);
+        settings.persist();
+
+        // This semaphore allows us to pause test execution until we're sure the tasks in
+        // AppsIndexerUserInstance are finished.
+        final Semaphore semaphore = new Semaphore(0);
+        mSingleThreadedExecutor =
+                new ThreadPoolExecutor(
+                        /* corePoolSize= */ 1,
+                        /* maximumPoolSize= */ 1,
+                        /* KeepAliveTime= */ 0L,
+                        TimeUnit.MILLISECONDS,
+                        new LinkedBlockingQueue<>()) {
+                    @Override
+                    protected void afterExecute(Runnable r, Throwable t) {
+                        super.afterExecute(r, t);
+                        semaphore.release();
+                    }
+                };
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+
+        // Pretend there's one package on device
+        setupMockPackageManager(
+                mMockPackageManager,
+                createFakePackageInfos(1),
+                createFakeResolveInfos(1),
+                /* appFunctionServices= */ ImmutableList.of());
+
+        // Wait for file setup, as file setup uses the same ExecutorService.
+        semaphore.acquire();
+
+        mInstance.updateAsync(true);
+
+        // Wait for the task to finish
+        semaphore.acquire();
+
+        settings = new AppsIndexerSettings(mAppsDir);
+        settings.load();
+        long lastAttemptedUpdatedTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+        // Timestamp should be set to more current value
+        assertThat(lastAttemptedUpdatedTimestampMillis).isAtMost(System.currentTimeMillis());
+    }
+
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APPS_INDEXER_CHECK_PRIOR_ATTEMPT)
+    @Test
+    public void testFirstRun_persistsAttemptTimestamp() throws Exception {
+        // This semaphore allows us to pause test execution until we're sure the tasks in
+        // AppsIndexerUserInstance are finished.
+        final Semaphore semaphore = new Semaphore(0);
+        mSingleThreadedExecutor =
+                new ThreadPoolExecutor(
+                        /* corePoolSize= */ 1,
+                        /* maximumPoolSize= */ 1,
+                        /* KeepAliveTime= */ 0L,
+                        TimeUnit.MILLISECONDS,
+                        new LinkedBlockingQueue<>()) {
+                    @Override
+                    protected void afterExecute(Runnable r, Throwable t) {
+                        super.afterExecute(r, t);
+                        semaphore.release();
+                    }
+                };
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+
+        // Pretend there's one package on device
+        setupMockPackageManager(
+                mMockPackageManager,
+                createFakePackageInfos(1),
+                createFakeResolveInfos(1),
+                /* appFunctionServices= */ ImmutableList.of());
+
+        // Wait for file setup, as file setup uses the same ExecutorService.
+        semaphore.acquire();
+
+        mInstance.updateAsync(true);
+
+        // Wait for the task to finish
+        semaphore.acquire();
+
+        AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
+        settings.load();
+        long lastAttemptedUpdatedTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+        assertThat(lastAttemptedUpdatedTimestampMillis).isGreaterThan(0);
+    }
+
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_APPS_INDEXER_CHECK_PRIOR_ATTEMPT)
+    @Test
+    public void testFirstRun_waitsForMinTime() throws Exception {
+        // This semaphore allows us to pause test execution until we're sure the tasks in
+        // AppsIndexerUserInstance are finished.
+        final Semaphore semaphore = new Semaphore(0);
+        mSingleThreadedExecutor =
+                new ThreadPoolExecutor(
+                        /* corePoolSize= */ 1,
+                        /* maximumPoolSize= */ 1,
+                        /* KeepAliveTime= */ 0L,
+                        TimeUnit.MILLISECONDS,
+                        new LinkedBlockingQueue<>()) {
+                    @Override
+                    protected void afterExecute(Runnable r, Throwable t) {
+                        super.afterExecute(r, t);
+                        semaphore.release();
+                    }
+                };
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+
+        // Pretend there's one package on device
+        setupMockPackageManager(
+                mMockPackageManager,
+                createFakePackageInfos(1),
+                createFakeResolveInfos(1),
+                /* appFunctionServices= */ ImmutableList.of());
+
+        // Wait for file setup, as file setup uses the same ExecutorService.
+        semaphore.acquire();
+
+        mInstance.updateAsync(true);
+
+        // Wait for the task to finish
+        semaphore.acquire();
+
+        AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
+        settings.load();
+        long firstAttemptedUpdateTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+
+        // Reset the last run timestamp to 0 to simulate what would happen if the sync fails
+        settings.setLastAppUpdateTimestampMillis(0);
+        settings.persist();
+
+        long secondAttemptedUpdateTimestampMillis = firstAttemptedUpdateTimestampMillis;
+
+        // Request a bunch of updates and check timestamp after each
+        while (secondAttemptedUpdateTimestampMillis == firstAttemptedUpdateTimestampMillis) {
+            mInstance.updateAsync(true);
+            assertTrue(semaphore.tryAcquire(100L, TimeUnit.MILLISECONDS));
+            settings.load();
+            secondAttemptedUpdateTimestampMillis = settings.getLastAttemptedUpdateTimestampMillis();
+        }
+
+        // At this point, one of the requested firstRun updates has completed
+        mSingleThreadedExecutor.shutdown();
+
+        // Check timestamp, it should've persisted a new time that is at least
+        // TestAppsIndexerConfig.getMinTimeBetweenFirstSyncsMillis greater than the first attempt
+        // timestamp
+        assertThat(secondAttemptedUpdateTimestampMillis)
+                .isAtLeast(
+                        firstAttemptedUpdateTimestampMillis
+                                + new TestAppsIndexerConfig().getMinTimeBetweenFirstSyncsMillis());
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_ALL_PACKAGE_INDEXING_ON_INDEXER_UPDATE)
+    public void testFirstRun_withIndexerUpdate_updateAlreadyRan_indexesApp() throws Exception {
+        // Pretend we already ran with a old indexer version.
+        AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
+        mAppsDir.mkdirs();
+        settings.setLastUpdateTimestampMillis(1000);
+        settings.setPreviousIndexerVersionCode(APP_INDEXER_VERSION_UNKNOWN);
+        settings.persist();
+
+        // This semaphore allows us to pause test execution until we're sure the tasks in
+        // AppsIndexerUserInstance are finished.
+        final Semaphore semaphore = new Semaphore(0);
+        mSingleThreadedExecutor =
+                new ThreadPoolExecutor(
+                        /* corePoolSize= */ 1,
+                        /* maximumPoolSize= */ 1,
+                        /* KeepAliveTime= */ 0L,
+                        TimeUnit.MILLISECONDS,
+                        new LinkedBlockingQueue<>()) {
+                    @Override
+                    protected void afterExecute(Runnable r, Throwable t) {
+                        super.afterExecute(r, t);
+                        semaphore.release();
+                    }
+                };
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+
+        // Pretend there's one package on device
+        setupMockPackageManager(
+                mMockPackageManager,
+                createFakePackageInfos(1),
+                createFakeResolveInfos(1),
+                /* appFunctionServices= */ ImmutableList.of());
+
+        // Wait for file setup, as file setup uses the same ExecutorService.
+        semaphore.acquire();
+
+        long beforeFirstRun = mSingleThreadedExecutor.getCompletedTaskCount();
+
+        mInstance.updateAsync(/* firstRun= */ true);
+        // Wait for the task to finish
+        semaphore.acquire();
+
+        while (mSingleThreadedExecutor.getCompletedTaskCount() != beforeFirstRun + 1) {
+            Thread.sleep(100);
+        }
+
+        // One more task should've ran and indexed the functions.
+        assertThat(mSingleThreadedExecutor.getActiveCount()).isEqualTo(0);
+        assertThat(mSingleThreadedExecutor.getTaskCount()).isEqualTo(beforeFirstRun + 1);
+        assertThat(mSingleThreadedExecutor.getCompletedTaskCount()).isEqualTo(beforeFirstRun + 1);
+        try (AppSearchHelper searchHelper = new AppSearchHelper(mTestContext)) {
+            Map<String, Long> appsTimestampMap = searchHelper.getAppsFromAppSearch();
+            assertThat(appsTimestampMap).hasSize(1);
+            assertThat(appsTimestampMap.keySet()).containsExactly("com.fake.package0");
+        }
+        // Previous indexer version is updated in settings.
+        AppsIndexerSettings currSettings = new AppsIndexerSettings(mAppsDir);
+        currSettings.load();
+        assertThat(currSettings.getPreviousIndexerVersionCode())
+                .isEqualTo((long) CURR_APP_INDEXER_VERSION);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_ALL_PACKAGE_INDEXING_ON_INDEXER_UPDATE)
+    public void testFirstRun_noIndexerUpdate_updateAlreadyRan_doesNotUpdate() throws Exception {
+        // Pretend we already ran
+        AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
+        mAppsDir.mkdirs();
+        settings.setLastUpdateTimestampMillis(1000);
+        settings.setPreviousIndexerVersionCode(CURR_APP_INDEXER_VERSION);
+        settings.persist();
+
+        // This semaphore allows us to pause test execution until we're sure the tasks in
+        // AppsIndexerUserInstance are finished.
+        final Semaphore semaphore = new Semaphore(0);
+        mSingleThreadedExecutor =
+                new ThreadPoolExecutor(
+                        /* corePoolSize= */ 1,
+                        /* maximumPoolSize= */ 1,
+                        /* KeepAliveTime= */ 0L,
+                        TimeUnit.MILLISECONDS,
+                        new LinkedBlockingQueue<>()) {
+                    @Override
+                    protected void afterExecute(Runnable r, Throwable t) {
+                        super.afterExecute(r, t);
+                        semaphore.release();
+                    }
+                };
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+
+        // Pretend there's one package on device
+        setupMockPackageManager(
+                mMockPackageManager,
+                createFakePackageInfos(1),
+                createFakeResolveInfos(1),
+                /* appFunctionServices= */ ImmutableList.of());
+
+        // Wait for file setup, as file setup uses the same ExecutorService.
+        semaphore.acquire();
+
+        long beforeFirstRun = mSingleThreadedExecutor.getCompletedTaskCount();
+
+        mInstance.updateAsync(/* firstRun= */ true);
+        // Wait for the task to finish
+        semaphore.acquire();
+
+        while (mSingleThreadedExecutor.getCompletedTaskCount() != beforeFirstRun + 1) {
+            Thread.sleep(100);
+        }
+        // One more task should've ran, checked settings, and exited
+        assertThat(mSingleThreadedExecutor.getActiveCount()).isEqualTo(0);
+        assertThat(mSingleThreadedExecutor.getTaskCount()).isEqualTo(beforeFirstRun + 1);
+        assertThat(mSingleThreadedExecutor.getCompletedTaskCount()).isEqualTo(beforeFirstRun + 1);
+
+        // Even though a task ran and we got 1 app ready, we requested a "firstRun" but the
+        // timestamp was not 0, so nothing should've been indexed
+        try (AppSearchHelper searchHelper = new AppSearchHelper(mTestContext)) {
+            assertThat(searchHelper.getAppsFromAppSearch()).isEmpty();
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_ALL_PACKAGE_INDEXING_ON_INDEXER_UPDATE)
+    public void testSubsequentRun_withIndexerUpdate_previouslyIndexedAppIsReIndexed()
+            throws Exception {
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+        // Pretend there's one package on device
+        setupMockPackageManager(
+                mMockPackageManager,
+                createFakePackageInfos(1),
+                createFakeResolveInfos(1),
+                /* appFunctionServices= */ ImmutableList.of());
+        AppsUpdateStats stats = new AppsUpdateStats();
+        mInstance.doUpdate(/* firstRun= */ true, stats);
+        assertThat(stats.mNumberOfAppsAdded).isEqualTo(1);
+
+        // Pretend indexer version is updated
+        AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
+        settings.setPreviousIndexerVersionCode(APP_INDEXER_VERSION_UNKNOWN);
+        settings.persist();
+        // Create new instance that uses the updated settings.
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+
+        // Run indexer again
+        AppsUpdateStats stats1 = new AppsUpdateStats();
+        mInstance.doUpdate(/* firstRun= */ false, stats1);
+
+        // App is re-indexed.
+        assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(1);
+    }
+
     @Test
     public void testHandleMultipleNotifications_onlyOneUpdateCanBeScheduledAndRun()
             throws Exception {
@@ -314,7 +693,7 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         // relies on a count that is updated a little bit AFTER afterExecute is called, which is
         // where the semaphore is released. See ThreadPoolExecutor#runWorker
         while (mSingleThreadedExecutor.getCompletedTaskCount() != 2) {
-            continue;
+            Thread.sleep(100);
         }
 
         assertThat(mSingleThreadedExecutor.getCompletedTaskCount()).isEqualTo(2);
@@ -325,7 +704,7 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
 
         // Only two updates ran even though many were scheduled
         while (mSingleThreadedExecutor.getCompletedTaskCount() != 3) {
-            continue;
+            Thread.sleep(100);
         }
         assertThat(mSingleThreadedExecutor.getCompletedTaskCount()).isEqualTo(3);
         assertThat(mSingleThreadedExecutor.getActiveCount()).isEqualTo(0);
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java
index 3e305af2..5abc87e6 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java
@@ -212,8 +212,7 @@ public class AppsUtilTest {
 
         setupMockPackageManager(pm, fakePackages, fakeActivities, fakeAppFunctionServices);
 
-        AppFunctionStaticMetadataParser parser =
-                Mockito.mock(AppFunctionStaticMetadataParser.class);
+        AppFunctionDocumentParser parser = Mockito.mock(AppFunctionDocumentParser.class);
         for (PackageInfo packageInfo : fakePackages) {
             when(parser.parse(any(), eq(packageInfo.packageName), any()))
                     .thenReturn(
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java
index eb0eab28..ac7359f5 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java
@@ -26,4 +26,9 @@ public class TestAppOpenEventIndexerConfig implements AppOpenEventIndexerConfig
     public long getAppOpenEventMaintenanceUpdateIntervalMillis() {
         return 24 * 60 * 60 * 1000L; // 1 day
     }
+
+    @Override
+    public long getMinTimeBetweenSyncsMillis() {
+        return 100L;
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppsIndexerConfig.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppsIndexerConfig.java
index ea1356e8..621447e1 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppsIndexerConfig.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppsIndexerConfig.java
@@ -36,4 +36,9 @@ public class TestAppsIndexerConfig implements AppsIndexerConfig {
     public int getMaxAllowedAppFunctionSchemasPerPackage() {
         return 5;
     }
+
+    @Override
+    public long getMinTimeBetweenFirstSyncsMillis() {
+        return 500;
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java
index abbb2f3e..90196ab6 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java
@@ -141,6 +141,75 @@ class TestUtils {
                                     .build())
                     .build();
 
+    /**
+     * Represents all properties of {@link AppFunctionStaticMetadata#PARENT_TYPE_APPSEARCH_SCHEMA}
+     * in XSD format understandable by {@link AppFunctionSchemaParser}.
+     */
+    public static final String APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES =
+            "        <xs:element name=\"functionId\" type=\"xs:string\" cardinality=\""
+                    + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                    + "\" indexingType=\""
+                    + AppSearchSchema.StringPropertyConfig.INDEXING_TYPE_EXACT_TERMS
+                    + "\" tokenizerType=\""
+                    + AppSearchSchema.StringPropertyConfig.TOKENIZER_TYPE_VERBATIM
+                    + "\" />\n"
+                    + "        <xs:element name=\"packageName\" type=\"xs:string\" cardinality=\""
+                    + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                    + "\" indexingType=\""
+                    + AppSearchSchema.StringPropertyConfig.INDEXING_TYPE_EXACT_TERMS
+                    + "\" tokenizerType=\""
+                    + AppSearchSchema.StringPropertyConfig.TOKENIZER_TYPE_VERBATIM
+                    + "\" />\n"
+                    + "        <xs:element name=\"schemaName\" type=\"xs:string\" cardinality=\""
+                    + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                    + "\" indexingType=\""
+                    + AppSearchSchema.StringPropertyConfig.INDEXING_TYPE_EXACT_TERMS
+                    + "\" tokenizerType=\""
+                    + AppSearchSchema.StringPropertyConfig.TOKENIZER_TYPE_VERBATIM
+                    + "\" />\n"
+                    + "        <xs:element name=\"schemaVersion\" type=\"xs:long\" cardinality=\""
+                    + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                    + "\" indexingType=\""
+                    + AppSearchSchema.LongPropertyConfig.INDEXING_TYPE_RANGE
+                    + "\" />\n"
+                    + "        <xs:element name=\"schemaCategory\" type=\"xs:string\" "
+                    + "cardinality=\""
+                    + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                    + "\" indexingType=\""
+                    + AppSearchSchema.StringPropertyConfig.INDEXING_TYPE_EXACT_TERMS
+                    + "\" tokenizerType=\""
+                    + AppSearchSchema.StringPropertyConfig.TOKENIZER_TYPE_VERBATIM
+                    + "\" />\n"
+                    + "        <xs:element name=\"enabledByDefault\" type=\"xs:boolean\" "
+                    + "cardinality=\""
+                    + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                    + "\" />\n"
+                    + "        <xs:element name=\"restrictCallersWithExecuteAppFunctions\" type=\""
+                    + "xs:boolean\" cardinality=\""
+                    + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                    + "\" />\n"
+                    + "        <xs:element name=\"displayNameStringRes\" type=\"xs:long\" "
+                    + "cardinality=\""
+                    + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                    + "\" />\n"
+                    + "        <xs:element name=\"mobileApplicationQualifiedId\" type=\"xs:string"
+                    + "\" cardinality=\""
+                    + AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL
+                    + "\" joinableValueType=\""
+                    + AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID
+                    + "\" />\n";
+
+    /**
+     * Represents {@link AppFunctionStaticMetadata#PARENT_TYPE_APPSEARCH_SCHEMA} in XSD format
+     * understandable by {@link AppFunctionSchemaParser}.
+     */
+    public static final String APP_FUNCTION_STATIC_METADATA_PARENT_SCHEMA_XSD =
+            "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                    + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                    + APP_FUNCTION_STATIC_METADATA_PARENT_PROPERTIES
+                    + "    </xs:documentType>"
+                    + "</xs:schema>";
+
     /**
      * Creates a fake {@link PackageInfo} object.
      *
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionDocumentTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionDocumentTest.java
new file mode 100644
index 00000000..2f7478bc
--- /dev/null
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionDocumentTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer.appsearchtypes;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.appsearch.util.DocumentIdUtil;
+
+import org.junit.Test;
+
+public class AppFunctionDocumentTest {
+
+    private static final String TEST_PACKAGE_NAME = "com.example.test";
+    private static final String TEST_DOCUMENT_ID = "testDocumentId";
+    private static final String TEST_INDEXER_PACKAGE_NAME = "android";
+    private static final String TEST_SCHEMA_TYPE = "TestSchema";
+
+    @Test
+    public void testGetSchemaNameForPackage_withSchemaType() {
+        String schemaName =
+                AppFunctionDocument.getSchemaNameForPackage(TEST_PACKAGE_NAME, TEST_SCHEMA_TYPE);
+        assertThat(schemaName).isEqualTo(TEST_SCHEMA_TYPE + "-" + TEST_PACKAGE_NAME);
+    }
+
+    @Test
+    public void testBuilder_build() {
+        AppFunctionDocument document =
+                new AppFunctionDocument.Builder<>(
+                                TEST_PACKAGE_NAME,
+                                TEST_DOCUMENT_ID,
+                                TEST_INDEXER_PACKAGE_NAME,
+                                TEST_SCHEMA_TYPE)
+                        .build();
+
+        assertThat(document.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
+        assertThat(document.getId()).isEqualTo(TEST_PACKAGE_NAME + "/" + TEST_DOCUMENT_ID);
+        assertThat(document.getSchemaType()).isEqualTo(TEST_SCHEMA_TYPE + "-" + TEST_PACKAGE_NAME);
+        String expectedQualifiedId =
+                DocumentIdUtil.createQualifiedId(
+                        TEST_INDEXER_PACKAGE_NAME,
+                        /* databaseName= */ "apps-db",
+                        /* namespace= */ "apps",
+                        TEST_PACKAGE_NAME);
+        assertThat(document.getMobileApplicationQualifiedId()).isEqualTo(expectedQualifiedId);
+    }
+}
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadataTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadataTest.java
index b4a75a9a..0939fc14 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadataTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadataTest.java
@@ -57,15 +57,6 @@ public class AppFunctionStaticMetadataTest {
                 .isEqualTo("android$apps-db/apps#com.example.message");
     }
 
-    @Test
-    public void testSchemaName() {
-        String packageName = "com.example.message";
-        String schemaName =
-                AppFunctionStaticMetadata.getSchemaNameForPackage(
-                        packageName, /** schemaType= */ null);
-        assertThat(schemaName).isEqualTo("AppFunctionStaticMetadata-com.example.message");
-    }
-
     @Test
     public void testChildSchema() {
         AppSearchSchema appSearchSchema =
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppsIndexerSchemaTests.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppsIndexerSchemaTests.java
index 2ae16d9e..f087ddf3 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppsIndexerSchemaTests.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppsIndexerSchemaTests.java
@@ -16,6 +16,8 @@
 
 package com.android.server.appsearch.appsindexer.appsearchtypes;
 
+import static com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent.APP_OPEN_EVENT_TTL_MILLIS;
+
 import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
@@ -57,13 +59,15 @@ public class AppsIndexerSchemaTests {
         String mobileApplicationQualifiedId = "android$apps-db/apps#com.android.apps.food";
         long appOpenEventTimestampMillis = System.currentTimeMillis();
 
-        AppOpenEvent appOpenEvent =
-                AppOpenEvent.create(packageName, appOpenEventTimestampMillis);
+        AppOpenEvent appOpenEvent = AppOpenEvent.create(packageName, appOpenEventTimestampMillis);
 
         assertThat(appOpenEvent.getPackageName()).isEqualTo(packageName);
         assertThat(appOpenEvent.getMobileApplicationQualifiedId())
                 .isEqualTo(mobileApplicationQualifiedId);
         assertThat(appOpenEvent.getAppOpenEventTimestampMillis())
                 .isEqualTo(appOpenEventTimestampMillis);
+        assertThat(appOpenEvent.getTtlMillis()).isEqualTo(APP_OPEN_EVENT_TTL_MILLIS);
+        assertThat(appOpenEvent.getCreationTimestampMillis())
+                .isEqualTo(appOpenEventTimestampMillis);
     }
 }
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/AppSearchHelperTest.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/AppSearchHelperTest.java
index 03e8aa3a..1e6a1345 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/AppSearchHelperTest.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/AppSearchHelperTest.java
@@ -38,11 +38,10 @@ import android.app.appsearch.SearchSpec;
 import android.app.appsearch.SetSchemaRequest;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.testutil.AppSearchSessionShimImpl;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.content.Context;
 import android.platform.test.annotations.RequiresFlagsDisabled;
 import android.platform.test.annotations.RequiresFlagsEnabled;
-import android.platform.test.flag.junit.CheckFlagsRule;
-import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 
 import androidx.test.core.app.ApplicationProvider;
 
@@ -56,6 +55,7 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.mockito.Mockito;
 
 import java.util.ArrayList;
@@ -79,8 +79,7 @@ public class AppSearchHelperTest {
 
     private AppSearchSessionShim mDb;
 
-    @Rule
-    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
 
     @Before
     public void setUp() throws Exception {
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java
index f329276d..d5006971 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java
@@ -18,28 +18,31 @@ package com.android.server.appsearch.contactsindexer;
 
 import static android.Manifest.permission.RECEIVE_BOOT_COMPLETED;
 
-import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.CONTACTS_INDEXER;
 import static com.android.server.appsearch.contactsindexer.ContactsIndexerMaintenanceConfig.MIN_CONTACTS_INDEXER_JOB_ID;
+import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.CONTACTS_INDEXER;
 
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.timeout;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import android.annotation.UserIdInt;
+import android.app.appsearch.testutil.TestContactsIndexerConfig;
 import android.app.UiAutomation;
 import android.app.job.JobInfo;
 import android.app.job.JobParameters;
 import android.app.job.JobScheduler;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.content.pm.UserInfo;
@@ -54,17 +57,20 @@ import androidx.test.platform.app.InstrumentationRegistry;
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.server.LocalManagerRegistry;
 import com.android.server.SystemService;
+import com.android.server.appsearch.indexer.IndexerMaintenanceConfig;
 import com.android.server.appsearch.indexer.IndexerMaintenanceService;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
 
+import java.io.File;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
@@ -346,7 +352,7 @@ public class ContactsIndexerMaintenanceTest {
         mIndexerMaintenanceService.doUpdateForUser(
                 mContextWrapper, mParams, DEFAULT_USER_HANDLE, new CancellationSignal());
 
-        verifyZeroInteractions(mockJobScheduler);
+        verifyNoMoreInteractions(mockJobScheduler);
     }
 
     @Test
@@ -385,6 +391,97 @@ public class ContactsIndexerMaintenanceTest {
         mIndexerMaintenanceService.onStopJob(null);
     }
 
+    @Test
+    public void testScheduleAndRunJob_unsetIndexerType_indexerTypeIsSet() throws Exception {
+        Context context = ApplicationProvider.getApplicationContext();
+        JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
+        JobScheduler spyScheduler = Mockito.spy(jobScheduler);
+
+        Context contextWrapper =
+                new ContextWrapper(context) {
+                    @Override
+                    @Nullable
+                    public Object getSystemService(String name) {
+                        if (Context.JOB_SCHEDULER_SERVICE.equals(name)) {
+                            return spyScheduler;
+                        }
+                        return super.getSystemService(name);
+                    }
+                };
+
+        TemporaryFolder temporaryFolder = new TemporaryFolder();
+        temporaryFolder.create();
+        File contactsDir = new File(temporaryFolder.newFolder(), "contacts");
+        ContactsIndexerUserInstance instance =
+                ContactsIndexerUserInstance.createInstance(
+                        contextWrapper, contactsDir, new TestContactsIndexerConfig());
+
+        // Latch to ensure that a contacts indexer update is ran
+        ContactsIndexerManagerService.LocalService mockLocalService =
+                Mockito.mock(ContactsIndexerManagerService.LocalService.class);
+        doAnswer(
+                        invocation -> {
+                            instance.doFullUpdateAsync(new CancellationSignal());
+                            return null;
+                        })
+                .when(mockLocalService)
+                .doUpdateForUser(any(), any());
+
+        ExtendedMockito.doReturn(mockLocalService)
+                .when(
+                        () ->
+                                LocalManagerRegistry.getManager(
+                                        ContactsIndexerManagerService.LocalService.class));
+
+        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity(RECEIVE_BOOT_COMPLETED);
+
+        try {
+            // Create a PersistableBundle with unset indexer_type
+            PersistableBundle jobExtras = new PersistableBundle();
+            // Do not set INDEXER_TYPE
+            jobExtras.putInt(IndexerMaintenanceService.EXTRA_USER_ID, DEFAULT_USER_ID);
+
+            // Directly schedule a job without the indexer type set
+            JobInfo noTypeJob =
+                    new JobInfo.Builder(
+                                    IndexerMaintenanceConfig.getConfigForIndexer(CONTACTS_INDEXER)
+                                                    .getMinJobId()
+                                            + DEFAULT_USER_ID,
+                                    new ComponentName(
+                                            mContextWrapper,
+                                            ContactsIndexerMaintenanceService.class))
+                            .setExtras(jobExtras)
+                            // Run as soon as possible
+                            .setMinimumLatency(1)
+                            .setOverrideDeadline(1)
+                            .build();
+            jobScheduler.schedule(noTypeJob);
+            // -1 defaultValue because the default defaultValue is 0, which is the same as
+            // CONTACTS_INDEXER and doesn't help us check the extra value
+            assertThat(
+                            jobScheduler
+                                    .getPendingJob(MIN_CONTACTS_INDEXER_JOB_ID + DEFAULT_USER_ID)
+                                    .getExtras()
+                                    .getInt("indexer_type", -1))
+                    .isEqualTo(-1);
+
+            verify(mockLocalService, timeout(10000L)).doUpdateForUser(any(), any());
+            // Scheduler should be called after the update is done and we re-schedule the job
+            verify(spyScheduler, timeout(10000L)).schedule(any(JobInfo.class));
+
+            // It should be rescheduled with the proper extra value.
+            assertThat(
+                            jobScheduler
+                                    .getPendingJob(MIN_CONTACTS_INDEXER_JOB_ID + DEFAULT_USER_ID)
+                                    .getExtras()
+                                    .getInt("indexer_type", -1))
+                    .isEqualTo(CONTACTS_INDEXER);
+        } finally {
+            uiAutomation.dropShellPermissionIdentity();
+        }
+    }
+
     @Nullable
     private JobInfo getPendingFullUpdateJob(@UserIdInt int userId) {
         int jobId = MIN_CONTACTS_INDEXER_JOB_ID + userId;
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerManagerServiceTest.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerManagerServiceTest.java
index 159b77c8..a40c67ef 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerManagerServiceTest.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerManagerServiceTest.java
@@ -23,6 +23,10 @@ import static com.android.server.appsearch.contactsindexer.ContactsIndexerMainte
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.mockito.ArgumentMatchers.any;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.app.UiAutomation;
 import android.app.appsearch.AppSearchManager;
 import android.app.appsearch.AppSearchSessionShim;
@@ -35,27 +39,36 @@ import android.app.appsearch.observer.SchemaChangeInfo;
 import android.app.appsearch.testutil.AppSearchSessionShimImpl;
 import android.app.appsearch.testutil.GlobalSearchSessionShimImpl;
 import android.app.appsearch.testutil.TestContactsIndexerConfig;
+import android.app.job.JobScheduler;
 import android.content.ContentResolver;
-import android.content.ContentUris;
 import android.content.ContentValues;
+import android.content.pm.PackageManager;
+import android.content.pm.ProviderInfo;
 import android.content.pm.UserInfo;
 import android.provider.ContactsContract;
 
-import androidx.annotation.NonNull;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.platform.app.InstrumentationRegistry;
 
 import com.android.compatibility.common.util.SystemUtil;
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+import com.android.dx.mockito.inline.extended.StaticMockitoSessionBuilder;
+import com.android.modules.utils.testing.ExtendedMockitoRule;
+import com.android.modules.utils.testing.StaticMockFixture;
+import com.android.server.LocalManagerRegistry;
 import com.android.server.SystemService;
 
 import org.junit.After;
+import org.junit.Assume;
 import org.junit.Before;
-import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -63,35 +76,32 @@ import java.util.concurrent.TimeUnit;
 
 @RunWith(AndroidJUnit4.class)
 public class ContactsIndexerManagerServiceTest extends FakeContactsProviderTestBase {
-    private static final String TAG = "ContactsIndexerManagerServiceTest";
-
     private final ExecutorService mSingleThreadedExecutor = Executors.newSingleThreadExecutor();
     private ContactsIndexerManagerService mContactsIndexerManagerService;
     private UiAutomation mUiAutomation;
+    private JobScheduler mJobScheduler;
+    // Job id for full update job for the test context's user id
+    private int mJobId = -1;
+
+    private final MockLocalManagerRegistry mMockLocalManagerRegistry =
+            new MockLocalManagerRegistry();
+
+    @Rule
+    public ExtendedMockitoRule mExtendedMockitoRule = new ExtendedMockitoRule.Builder()
+            .addStaticMockFixtures(() -> mMockLocalManagerRegistry)
+            .build();
 
     @Override
     @Before
     public void setUp() throws Exception {
         super.setUp();
         mUiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
-        // INTERACT_ACROSS_USERS_FULL: needed when we do registerReceiverForAllUsers for getting
-        // package change notifications.
-        mUiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_USERS_FULL);
-
-        // TODO(b/276401961) right now we can't have more than one test in this class because in
-        //  ContactsIndexerManagerService.onStart we register a local service, and it will throw
-        //  an exception if we try to register another one in a 2nd test.
-        //  Unfortunately catching the exception doesn't work because the registered
-        //  manager/LocalService will still point to the previous ContactsIndexerManagerService,
-        //  making the 2nd test fail.
-        //  If I make ContactsIndexerManagerService static and only initialize it once in setUp
-        //  by checking nullness, it seems working. However, it will make the tests run 3X slower,
-        //  and we need to investigate that.
-        //  UPDATE: mContactsIndexerManagerService.onStart() has been moved to the test
-        //  testCP2Clear_runsFullUpdate specifically because currently that's the only test that
-        //  needs mContactsIndexerManagerService to be fully functional.
         mContactsIndexerManagerService = new ContactsIndexerManagerService(mContext,
                 new TestContactsIndexerConfig());
+        // Ensure no scheduled job
+        mJobScheduler = mContext.getSystemService(JobScheduler.class);
+        mJobId = MIN_CONTACTS_INDEXER_JOB_ID + mContext.getUserId();
+        mJobScheduler.cancel(mJobId);
     }
 
     @Override
@@ -102,90 +112,173 @@ public class ContactsIndexerManagerServiceTest extends FakeContactsProviderTestB
                 new AppSearchManager.SearchContext.Builder(AppSearchHelper.DATABASE_NAME).build(),
                 mSingleThreadedExecutor).get();
         db.setSchemaAsync(new SetSchemaRequest.Builder().setForceOverride(true).build()).get();
-        mUiAutomation.dropShellPermissionIdentity();
+        // Clean up scheduled job
+        if (mJobScheduler != null && mJobId != -1) {
+            mJobScheduler.cancel(mJobId);
+        }
         super.tearDown();
     }
 
-    // TODO(b/282073711) This test is flaky, figure out the root cause and fix it.
     @Test
-    @Ignore
     public void testCP2Clear_runsFullUpdate() throws Exception {
-        // TODO(b/276401961) onStart is being called here instead of the setUp method because setUp
-        //  is called before every test and running onStart more than once will throw an exception
-        //  (see the note in setUp method for more context). The other tests in this class don't
-        //  really need the mContactsIndexerManagerService to function fully so onStart can be
-        //  skipped there, but if we later need to add more tests that need
-        //  mContactsIndexerManagerService to be fully functional, onStart will need to be moved
-        //  back to setUp after figuring out a better way to handle multiple calls to it.
-        mContactsIndexerManagerService.onStart();
-        int userId = mContext.getUserId();
-
-        // Populate fake CP2 with 100 contacts.
-        ContentResolver resolver = mContext.getContentResolver();
-        ContentValues values = new ContentValues();
-        for (int i = 0; i < 100; i++) {
-            resolver.insert(ContactsContract.Contacts.CONTENT_URI, values);
-        }
+        String contactsProviderPackageName = getContactsProviderPackageName();
+        Assume.assumeNotNull(contactsProviderPackageName);
+
+        // This config prevents delta updates from indexing any contacts
+        ContactsIndexerConfig config = new TestContactsIndexerConfig() {
+            @Override
+            public int getContactsFirstRunIndexingLimit() {
+                return 0;
+            }
 
-        // Contacts indexer schedules a full-update job for bootstrapping from CP2,
-        // and JobScheduler API requires BOOT_COMPLETED permission for persisting the job.
-        mUiAutomation.adoptShellPermissionIdentity(RECEIVE_BOOT_COMPLETED);
+            @Override
+            public int getContactsDeltaUpdateLimit() {
+                return 0;
+            }
+        };
+        mContactsIndexerManagerService = new ContactsIndexerManagerService(mContext, config);
+        UserInfo userInfo = new UserInfo(mContext.getUser().getIdentifier(),
+                /* name= */ "default", /* flags= */ 0);
+        SystemService.TargetUser targetUser = new SystemService.TargetUser(userInfo);
+
+        // Permissions required for registering receivers and scheduling jobs
+        mUiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_USERS_FULL,
+                RECEIVE_BOOT_COMPLETED);
         try {
-            CountDownLatch bootstrapLatch = countDownAppSearchDocumentChanges(100);
-            UserInfo userInfo = new UserInfo(mContext.getUser().getIdentifier(),
-                    /*name=*/ "default", /*flags=*/ 0);
-            mContactsIndexerManagerService.onUserUnlocking(new SystemService.TargetUser(userInfo));
-            bootstrapLatch.await(30L, TimeUnit.SECONDS);
+            mContactsIndexerManagerService.onStart();
+
+            // Contacts indexer does an initial delta update on the first run but we've set the
+            // limits to 0 so don't need to worry about a race condition where the delta update
+            // indexes the contacts added below before the full update runs
+            mContactsIndexerManagerService.onUserUnlocking(targetUser);
+
+            // Verify full update has not run before (timestamp is 0)
+            assertThat(getLastFullUpdateTimestampFromContactsIndexerDump()).isEqualTo(0);
+
+            // Populate fake CP2 with 100 contacts.
+            ContentResolver resolver = mContext.getContentResolver();
+            ContentValues values = new ContentValues();
+            for (int i = 0; i < 100; i++) {
+                resolver.insert(ContactsContract.Contacts.CONTENT_URI, values);
+            }
+
+            CountDownLatch fullUpdateLatch = countDownAppSearchDocumentChanges(100);
+            // Clear the user data for the CP2 package which should trigger a full update
+            SystemUtil.runShellCommand("pm clear --user " + mContext.getUserId() + " "
+                    + contactsProviderPackageName);
+            // Wait for full update to run and index all 100 contacts.
+            assertThat(fullUpdateLatch.await(10L, TimeUnit.SECONDS)).isTrue();
+
+            // Spin for 10 seconds max to wait for full update to update timestamps; the timestamps
+            // are updated at the end after the contacts are indexed in a chained future so we
+            // cannot guarantee a point in time in which the timestamps have been updated
+            long endTimeMillis = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(10);
+            long fullUpdateTimestampMillis = -1;
+            while (System.currentTimeMillis() < endTimeMillis) {
+                fullUpdateTimestampMillis = getLastFullUpdateTimestampFromContactsIndexerDump();
+                if (fullUpdateTimestampMillis > 0) {
+                    break;
+                }
+                // Sleep otherwise it's a tight loop since there's no i/o
+                Thread.sleep(10);
+            }
+            assertThat(fullUpdateTimestampMillis).isGreaterThan(0);
         } finally {
+            mContactsIndexerManagerService.onUserStopping(targetUser);
             mUiAutomation.dropShellPermissionIdentity();
         }
+    }
 
-        long prevTimestampMillis = System.currentTimeMillis();
-        // Clear fake CP2 first 50 contacts.
-        for (int i = 0; i < 50; i++) {
-            resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, i),
-                    /*extras=*/ null);
-        }
-        CountDownLatch fullUpdateLatch = countDownAppSearchDocumentChanges(50);
-        SystemUtil.runShellCommand("pm clear --user " + userId + " com.android.providers.contacts");
-        // Wait for full-update to run and delete all 100 contacts.
-        fullUpdateLatch.await(30L, TimeUnit.SECONDS);
-
-        // Clear fake CP2 last 50 contacts.
-        // We trigger the 2nd update so the timestamps for the 1st update can be persisted.
-        for (int i = 50; i < 100; i++) {
-            resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, i),
-                    /*extras=*/ null);
+    /** Returns null if the contacts provider package cannot be queried. */
+    @Nullable private String getContactsProviderPackageName() {
+        PackageManager pm = mContext.getPackageManager();
+        List<ProviderInfo> providers =
+                pm.queryContentProviders(
+                        /* processName= */ null,
+                        /* uid= */ 0,
+                        PackageManager.ComponentInfoFlags.of(0));
+        for (int i = 0; i < providers.size(); i++) {
+            ProviderInfo providerInfo = providers.get(i);
+            if (ContactsContract.AUTHORITY.equals(providerInfo.authority)) {
+                return providerInfo.packageName;
+            }
         }
-        fullUpdateLatch = countDownAppSearchDocumentChanges(50);
-        SystemUtil.runShellCommand("pm clear --user " + userId + " com.android.providers.contacts");
-        // Wait for full-update to run and delete all 100 contacts.
-        fullUpdateLatch.await(30L, TimeUnit.SECONDS);
+        return null;
+    }
+
+    // This tests a local scheduled job for Contacts Indexer in the test package
+    @Test
+    public void testLocalScheduledJob_runsFullUpdate() throws Exception {
+        // Allow first run delta update to index contacts but prevent following delta updates from
+        // indexing contacts
+        ContactsIndexerConfig config = new TestContactsIndexerConfig() {
+            @Override
+            public int getContactsFirstRunIndexingLimit() {
+                return 100;
+            }
+
+            @Override
+            public int getContactsDeltaUpdateLimit() {
+                return 0;
+            }
+        };
+        mContactsIndexerManagerService = new ContactsIndexerManagerService(mContext, config);
+        UserInfo userInfo = new UserInfo(mContext.getUser().getIdentifier(),
+                /* name= */ "default", /* flags= */ 0);
+        SystemService.TargetUser targetUser = new SystemService.TargetUser(userInfo);
+
+        // Permissions required for registering receivers and scheduling jobs
+        mUiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_USERS_FULL,
+                RECEIVE_BOOT_COMPLETED);
+        try {
+            mContactsIndexerManagerService.onStart();
+
+            // Populate fake CP2 and allow the first run delta update to index contacts; since a
+            // full update job is scheduled right before this first run delta update, waiting for
+            // the delta update to finish guarantees that the full update job is scheduled
+            ContentResolver resolver = mContext.getContentResolver();
+            ContentValues values = new ContentValues();
+            for (int i = 0; i < 100; i++) {
+                resolver.insert(ContactsContract.Contacts.CONTENT_URI, values);
+            }
+
+            CountDownLatch bootstrapLatch = countDownAppSearchDocumentChanges(100);
+            mContactsIndexerManagerService.onUserUnlocking(targetUser);
+            assertThat(bootstrapLatch.await(10L, TimeUnit.SECONDS)).isTrue();
+
+            // Verify full update job was scheduled
+            assertThat(mJobScheduler.getPendingJob(mJobId)).isNotNull();
+
+            // Add more contacts and force the full update job to run immediately
+            for (int i = 0; i < 100; i++) {
+                resolver.insert(ContactsContract.Contacts.CONTENT_URI, values);
+            }
 
-        // Verify that a periodic full-update job is scheduled still.
-        assertThat(getJobState(MIN_CONTACTS_INDEXER_JOB_ID + userId)).contains("waiting");
+            CountDownLatch fullUpdateLatch = countDownAppSearchDocumentChanges(100);
+            // Force scheduled job in test package to run immediately
+            SystemUtil.runShellCommand(mUiAutomation,
+                    "cmd jobscheduler run -f " + mContext.getPackageName() + " " + mJobId);
+            assertThat(fullUpdateLatch.await(10L, TimeUnit.SECONDS)).isTrue();
+        } finally {
+            mContactsIndexerManagerService.onUserStopping(targetUser);
+            mUiAutomation.dropShellPermissionIdentity();
+        }
+    }
 
-        // Verify the stats for the ContactsIndexer. Two full updates are triggered at this
-        // point, and the timestamps for 1st update must have been persisted.
+    private long getLastFullUpdateTimestampFromContactsIndexerDump() {
         StringWriter stringWriter = new StringWriter();
         PrintWriter pw = new PrintWriter(stringWriter);
-        mContactsIndexerManagerService.dumpContactsIndexerForUser(
-                mContext.getUser(), pw, /* verbose= */ false);
+        mContactsIndexerManagerService.dumpContactsIndexerForUser(mContext.getUser(), pw,
+                /* verbose= */ false);
         String[] output = stringWriter.toString().split(System.lineSeparator());
-
-        assertThat(output).hasLength(3);
-        // DeltaDeleteTimestamp
-        assertThat(getTimestampOutOfDump(output[0])).isGreaterThan(prevTimestampMillis);
-        // DeltaUpdateTimestamp
-        assertThat(getTimestampOutOfDump(output[1])).isGreaterThan(prevTimestampMillis);
-        // FullUpdateTimestamp
-        assertThat(getTimestampOutOfDump(output[2])).isGreaterThan(prevTimestampMillis);
+        return getTimestampOutOfDump(output[0]);
     }
 
     private long getTimestampOutOfDump(String dumpOutputOneLine) {
+        // e.g. "last_full_update_timestamp_millis: 12345"
         String[] arrs = dumpOutputOneLine.split(" ");
-        assertThat(arrs.length).isAtLeast(2);
-        return Long.parseLong(arrs[arrs.length - 2]);
+        assertThat(arrs).hasLength(2);
+        return Long.parseLong(arrs[1]);
     }
 
     @Test
@@ -235,13 +328,33 @@ public class ContactsIndexerManagerServiceTest extends FakeContactsProviderTestB
     }
 
     /**
-     * Returns the current state of a job, which may be "pending", "active", "ready", or "waiting".
-     *
-     * <p>See "adb shell cmd jobscheduler -h" for more details.
+     * Prevents actually adding a manager to the registry since the registry is static and will
+     * throw an exception across tests if multiple ContactsIndexerManagerServices try to register
+     * a LocalService from onStart(). Instead, captures the LocalService and does nothing on
+     * addManager and supplies the captured LocalService during getManager.
      */
-    @NonNull
-    private String getJobState(int jobId) throws Exception {
-        return SystemUtil.runShellCommand(mUiAutomation,
-                "cmd jobscheduler get-job-state android " + jobId).trim();
+    private static class MockLocalManagerRegistry implements StaticMockFixture {
+        ArgumentCaptor<ContactsIndexerManagerService.LocalService> mLocalServiceCaptor =
+                ArgumentCaptor.forClass(ContactsIndexerManagerService.LocalService.class);
+
+        @Override
+        public StaticMockitoSessionBuilder setUpMockedClasses(
+                @NonNull StaticMockitoSessionBuilder sessionBuilder) {
+            sessionBuilder.mockStatic(LocalManagerRegistry.class);
+            return sessionBuilder;
+        }
+
+        @Override
+        public void setUpMockBehaviors() {
+            ExtendedMockito.doNothing().when(
+                    () -> LocalManagerRegistry.addManager(any(), mLocalServiceCaptor.capture()));
+            ExtendedMockito.doAnswer(invocation -> mLocalServiceCaptor.getValue()).when(
+                    () -> LocalManagerRegistry.getManager(
+                            ContactsIndexerManagerService.LocalService.class));
+        }
+
+        @Override
+        public void tearDown() {
+        }
     }
 }
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerUserInstanceTest.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerUserInstanceTest.java
index a57baf35..a8b66ae0 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerUserInstanceTest.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerUserInstanceTest.java
@@ -16,8 +16,6 @@
 
 package com.android.server.appsearch.contactsindexer;
 
-import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.CONTACTS_INDEXER;
-
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.mockito.ArgumentMatchers.any;
@@ -25,7 +23,7 @@ import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 import android.annotation.NonNull;
 import android.app.appsearch.AppSearchManager;
@@ -38,6 +36,7 @@ import android.app.appsearch.observer.ObserverCallback;
 import android.app.appsearch.observer.ObserverSpec;
 import android.app.appsearch.observer.SchemaChangeInfo;
 import android.app.appsearch.testutil.AppSearchSessionShimImpl;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.app.appsearch.testutil.GlobalSearchSessionShimImpl;
 import android.app.appsearch.testutil.TestContactsIndexerConfig;
 import android.app.job.JobInfo;
@@ -47,10 +46,14 @@ import android.content.ContentUris;
 import android.content.ContentValues;
 import android.os.CancellationSignal;
 import android.os.PersistableBundle;
+import android.platform.test.annotations.RequiresFlagsDisabled;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 import android.provider.ContactsContract;
 
+import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 
+import com.android.appsearch.flags.Flags;
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.dx.mockito.inline.extended.StaticMockitoSessionBuilder;
 import com.android.modules.utils.testing.ExtendedMockitoRule;
@@ -63,6 +66,7 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
@@ -83,6 +87,19 @@ import java.util.concurrent.atomic.AtomicReference;
 
 @RunWith(AndroidJUnit4.class)
 public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBase {
+    private static final JobInfo PERIODIC_JOB_INFO = IndexerMaintenanceService.createJobInfo(
+            ApplicationProvider.getApplicationContext(),
+            ApplicationProvider.getApplicationContext().getUser(),
+            ContactsIndexerMaintenanceConfig.CONTACTS_INDEXER, /* periodic= */
+            true, /* intervalMillis= */
+            ContactsIndexerConfig.DEFAULT_CONTACTS_FULL_UPDATE_INTERVAL_MILLIS);
+
+    private static final JobInfo IMMEDIATE_JOB_INFO = IndexerMaintenanceService.createJobInfo(
+            ApplicationProvider.getApplicationContext(),
+            ApplicationProvider.getApplicationContext().getUser(),
+            ContactsIndexerMaintenanceConfig.CONTACTS_INDEXER, /* periodic= */
+            false, /* intervalMillis= */ -1);
+
     @Rule
     public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
 
@@ -91,6 +108,9 @@ public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBas
             .addStaticMockFixtures(TestMockFixture::new)
             .build();
 
+    @Rule
+    public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
+
     private final ExecutorService mSingleThreadedExecutor = Executors.newSingleThreadExecutor();
     private File mContactsDir;
     private File mSettingsFile;
@@ -237,13 +257,7 @@ public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBas
     }
 
     @Test
-    public void testStart_initialRun_schedulesFullUpdateJob() throws Exception {
-        JobScheduler mockJobScheduler = mock(JobScheduler.class);
-        mContext.setJobScheduler(mockJobScheduler);
-        ContactsIndexerUserInstance instance = ContactsIndexerUserInstance.createInstance(
-                mContext,
-                mContactsDir, mConfigForTest, mSingleThreadedExecutor);
-
+    public void testStartAsync_initialRun_schedulesFullUpdateJob() throws Exception {
         int docCount = 100;
         CountDownLatch latch = new CountDownLatch(docCount);
         GlobalSearchSessionShim shim =
@@ -265,33 +279,34 @@ public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBas
                 new ObserverSpec.Builder().addFilterSchemas("builtin:Person").build(),
                 mSingleThreadedExecutor,
                 callback);
-        // Insert contacts to trigger delta update.
+        // Insert contacts for delta update
         ContentResolver resolver = mContext.getContentResolver();
         ContentValues dummyValues = new ContentValues();
         for (int i = 0; i < docCount; i++) {
             resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
         }
 
+        JobScheduler mockJobScheduler = mock(JobScheduler.class);
+        mContext.setJobScheduler(mockJobScheduler);
+
         try {
-            instance.startAsync();
+            mInstance.startAsync();
 
-            // Wait for all async tasks to complete
+            // Wait for initial delta update to index contacts
             latch.await(30L, TimeUnit.SECONDS);
 
             ArgumentCaptor<JobInfo> jobInfoArgumentCaptor = ArgumentCaptor.forClass(JobInfo.class);
             verify(mockJobScheduler).schedule(jobInfoArgumentCaptor.capture());
             JobInfo fullUpdateJob = jobInfoArgumentCaptor.getValue();
-            assertThat(fullUpdateJob.isRequireBatteryNotLow()).isTrue();
-            assertThat(fullUpdateJob.isRequireDeviceIdle()).isTrue();
-            assertThat(fullUpdateJob.isPersisted()).isTrue();
-            assertThat(fullUpdateJob.isPeriodic()).isFalse();
+            assertThat(fullUpdateJob).isEqualTo(IMMEDIATE_JOB_INFO);
         } finally {
-            instance.shutdown();
+            // unregisters observers registered by startAsync()
+            mInstance.shutdown();
         }
     }
 
     @Test
-    public void testStart_subsequentRunWithNoScheduledJob_schedulesFullUpdateJob()
+    public void testCp2SyncFirstRun_subsequentRunWithNoScheduledJob_schedulesFullUpdateJob()
             throws Exception {
         // Trigger an initial full update.
         executeAndWaitForCompletion(
@@ -303,57 +318,41 @@ public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBas
         // due to some reason.
         JobScheduler mockJobScheduler = mock(JobScheduler.class);
         mContext.setJobScheduler(mockJobScheduler);
-        ContactsIndexerUserInstance instance = ContactsIndexerUserInstance.createInstance(
-                mContext, mContactsDir, mConfigForTest, mSingleThreadedExecutor);
 
-        int docCount = 100;
-        CountDownLatch latch = new CountDownLatch(docCount);
-        GlobalSearchSessionShim shim =
-                GlobalSearchSessionShimImpl.createGlobalSearchSessionAsync(mContext).get();
-        ObserverCallback callback = new ObserverCallback() {
-            @Override
-            public void onSchemaChanged(SchemaChangeInfo changeInfo) {
-                // Do nothing
-            }
+        mInstance.doCp2SyncFirstRun();
 
-            @Override
-            public void onDocumentChanged(DocumentChangeInfo changeInfo) {
-                for (int i = 0; i < changeInfo.getChangedDocumentIds().size(); i++) {
-                    latch.countDown();
-                }
-            }
-        };
-        shim.registerObserverCallback(mContext.getPackageName(),
-                new ObserverSpec.Builder().addFilterSchemas("builtin:Person").build(),
-                mSingleThreadedExecutor,
-                callback);
-        // Insert contacts to trigger delta update.
-        ContentResolver resolver = mContext.getContentResolver();
-        ContentValues dummyValues = new ContentValues();
-        for (int i = 0; i < docCount; i++) {
-            resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
-        }
+        ArgumentCaptor<JobInfo> jobInfoArgumentCaptor = ArgumentCaptor.forClass(JobInfo.class);
+        verify(mockJobScheduler).schedule(jobInfoArgumentCaptor.capture());
+        JobInfo fullUpdateJob = jobInfoArgumentCaptor.getValue();
+        assertThat(fullUpdateJob).isEqualTo(IMMEDIATE_JOB_INFO);
+    }
 
-        try {
-            instance.startAsync();
+    @Test
+    public void
+    testCp2SyncFirstRun_subsequentRunWithMatchingPeriodicJob_doesNotScheduleFullUpdateJob()
+            throws Exception {
+        // Trigger an initial full update.
+        executeAndWaitForCompletion(
+                mInstance.doFullUpdateInternalAsync(new CancellationSignal(), mUpdateStats),
+                mSingleThreadedExecutor);
 
-            // Wait for all async tasks to complete
-            latch.await(30L, TimeUnit.SECONDS);
+        JobScheduler mockJobScheduler = mock(JobScheduler.class);
+        mContext.setJobScheduler(mockJobScheduler);
+        // Simulate getPendingJob() returning a periodic job with expected parameters
+        doReturn(PERIODIC_JOB_INFO)
+                .when(mockJobScheduler)
+                .getPendingJob(
+                        ContactsIndexerMaintenanceConfig.MIN_CONTACTS_INDEXER_JOB_ID
+                                + mContext.getUser().getIdentifier());
 
-            ArgumentCaptor<JobInfo> jobInfoArgumentCaptor = ArgumentCaptor.forClass(JobInfo.class);
-            verify(mockJobScheduler).schedule(jobInfoArgumentCaptor.capture());
-            JobInfo fullUpdateJob = jobInfoArgumentCaptor.getValue();
-            assertThat(fullUpdateJob.isRequireBatteryNotLow()).isTrue();
-            assertThat(fullUpdateJob.isRequireDeviceIdle()).isTrue();
-            assertThat(fullUpdateJob.isPersisted()).isTrue();
-            assertThat(fullUpdateJob.isPeriodic()).isFalse();
-        } finally {
-            instance.shutdown();
-        }
+        mInstance.doCp2SyncFirstRun();
+
+        verify(mockJobScheduler, never()).schedule(any());
     }
 
     @Test
-    public void testStart_subsequentRunWithScheduledJob_doesNotScheduleFullUpdateJob()
+    public void
+    testCp2SyncFirstRun_subsequentRunWithMatchingImmediateJob_doesNotScheduleFullUpdateJob()
             throws Exception {
         // Trigger an initial full update.
         executeAndWaitForCompletion(
@@ -361,56 +360,74 @@ public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBas
                 mSingleThreadedExecutor);
 
         JobScheduler mockJobScheduler = mock(JobScheduler.class);
-        JobInfo mockJobInfo = mock(JobInfo.class);
-        // getPendingJob() should return a non-null value to simulate the scenario where a
-        // background job is already scheduled.
-        doReturn(mockJobInfo)
+        mContext.setJobScheduler(mockJobScheduler);
+        // Simulate getPendingJob() returning an immediate job with expected parameters
+        doReturn(IMMEDIATE_JOB_INFO)
                 .when(mockJobScheduler)
                 .getPendingJob(
                         ContactsIndexerMaintenanceConfig.MIN_CONTACTS_INDEXER_JOB_ID
                                 + mContext.getUser().getIdentifier());
+
+        mInstance.doCp2SyncFirstRun();
+
+        verify(mockJobScheduler, never()).schedule(any());
+    }
+
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_CHECK_CONTACTS_INDEXER_UPDATE_JOB_PARAMS)
+    @Test
+    public void
+    testCp2SyncFirstRun_subsequentRunWithNonMatchingScheduledJob_withCheck_schedulesJob()
+            throws Exception {
+        // Trigger an initial full update.
+        executeAndWaitForCompletion(
+                mInstance.doFullUpdateInternalAsync(new CancellationSignal(), mUpdateStats),
+                mSingleThreadedExecutor);
+
+        JobScheduler mockJobScheduler = mock(JobScheduler.class);
         mContext.setJobScheduler(mockJobScheduler);
-        ContactsIndexerUserInstance instance = ContactsIndexerUserInstance.createInstance(
-                mContext, mContactsDir, mConfigForTest, mSingleThreadedExecutor);
+        // Create matching JobInfo but with missing params
+        JobInfo fakeJobInfo = new JobInfo.Builder(PERIODIC_JOB_INFO)
+                .setExtras(new PersistableBundle())
+                .build();
+        // Simulate getPendingJob() returning a job with missing params
+        doReturn(fakeJobInfo)
+                .when(mockJobScheduler)
+                .getPendingJob(ContactsIndexerMaintenanceConfig.MIN_CONTACTS_INDEXER_JOB_ID
+                        + mContext.getUser().getIdentifier());
 
-        int docCount = 100;
-        CountDownLatch latch = new CountDownLatch(docCount);
-        GlobalSearchSessionShim shim =
-                GlobalSearchSessionShimImpl.createGlobalSearchSessionAsync(mContext).get();
-        ObserverCallback callback = new ObserverCallback() {
-            @Override
-            public void onSchemaChanged(SchemaChangeInfo changeInfo) {
-                // Do nothing
-            }
+        mInstance.doCp2SyncFirstRun();
 
-            @Override
-            public void onDocumentChanged(DocumentChangeInfo changeInfo) {
-                for (int i = 0; i < changeInfo.getChangedDocumentIds().size(); i++) {
-                    latch.countDown();
-                }
-            }
-        };
-        shim.registerObserverCallback(mContext.getPackageName(),
-                new ObserverSpec.Builder().addFilterSchemas("builtin:Person").build(),
-                mSingleThreadedExecutor,
-                callback);
-        // Insert contacts to trigger delta update.
-        ContentResolver resolver = mContext.getContentResolver();
-        ContentValues dummyValues = new ContentValues();
-        for (int i = 0; i < docCount; i++) {
-            resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
-        }
+        ArgumentCaptor<JobInfo> jobInfoArgumentCaptor = ArgumentCaptor.forClass(JobInfo.class);
+        verify(mockJobScheduler).schedule(jobInfoArgumentCaptor.capture());
+        JobInfo fullUpdateJob = jobInfoArgumentCaptor.getValue();
+        assertThat(fullUpdateJob).isEqualTo(IMMEDIATE_JOB_INFO);
+    }
 
-        try {
-            instance.startAsync();
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_CHECK_CONTACTS_INDEXER_UPDATE_JOB_PARAMS)
+    @Test
+    public void
+    testCp2SyncFirstRun_subsequentRunWithNonMatchingScheduledJob_withoutCheck_doesNotScheduleJob()
+            throws Exception {
+        // Trigger an initial full update.
+        executeAndWaitForCompletion(
+                mInstance.doFullUpdateInternalAsync(new CancellationSignal(), mUpdateStats),
+                mSingleThreadedExecutor);
 
-            // Wait for all async tasks to complete
-            latch.await(30L, TimeUnit.SECONDS);
+        JobScheduler mockJobScheduler = mock(JobScheduler.class);
+        mContext.setJobScheduler(mockJobScheduler);
+        // Create matching JobInfo but with missing params
+        JobInfo fakeJobInfo = new JobInfo.Builder(PERIODIC_JOB_INFO)
+                .setExtras(new PersistableBundle())
+                .build();
+        // Simulate getPendingJob() returning a job with missing params
+        doReturn(fakeJobInfo)
+                .when(mockJobScheduler)
+                .getPendingJob(ContactsIndexerMaintenanceConfig.MIN_CONTACTS_INDEXER_JOB_ID
+                        + mContext.getUser().getIdentifier());
 
-            verify(mockJobScheduler, never()).schedule(any());
-        } finally {
-            instance.shutdown();
-        }
+        mInstance.doCp2SyncFirstRun();
+
+        verify(mockJobScheduler, never()).schedule(any());
     }
 
     @Test
@@ -741,18 +758,13 @@ public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBas
                 settingsBundle.getLong(ContactsIndexerSettings.LAST_CONTACT_DELETE_TIMESTAMP_KEY));
     }
 
+    // This test tests whether a full update job will be run to prune the person corpus when
+    // AppSearch reaches its max document limit. Since there are issues with obtaining the
+    // permissions to change the device config for max document limit, and we don't want to
+    // index 10000+ documents in this test, we simulate the out of space error by manually
+    // adding it to update stats beforehand.
     @Test
     public void testDeltaUpdate_outOfSpaceError_fullUpdateScheduled() throws Exception {
-        // This tests whether a full update job will be run to prune the person corpus when
-        // AppSearch reaches its max document limit. Since there are issues with obtaining the
-        // permissions to change the device config for max document limit, and we don't want to
-        // index 10000+ documents in this test, we simulate the out of space error by manually
-        // adding it to update stats beforehand.
-
-        // Cancel any existing jobs.
-        IndexerMaintenanceService.cancelUpdateJobIfScheduled(
-                mContext, mContext.getUser(), CONTACTS_INDEXER);
-
         JobScheduler mockJobScheduler = mock(JobScheduler.class);
         mContext.setJobScheduler(mockJobScheduler);
 
@@ -801,12 +813,14 @@ public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBas
         // schedule a full update job.
         JobScheduler mockJobScheduler = mock(JobScheduler.class);
         mContext.setJobScheduler(mockJobScheduler);
+        // Initializes an AppSearchHelper
         mInstance = ContactsIndexerUserInstance.createInstance(mContext, mContactsDir,
                 mConfigForTest, mSingleThreadedExecutor);
         try {
             mInstance.startAsync();
-            verifyZeroInteractions(mockJobScheduler);
+            verifyNoMoreInteractions(mockJobScheduler);
         } finally {
+            // unregisters observers registered by startAsync()
             mInstance.shutdown();
         }
     }
@@ -872,6 +886,7 @@ public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBas
         // doCp2SyncFirstRun again.
         JobScheduler mockJobScheduler = mock(JobScheduler.class);
         mContext.setJobScheduler(mockJobScheduler);
+        // Initializes an AppSearchHelper
         mInstance = ContactsIndexerUserInstance.createInstance(mContext, mContactsDir,
                 mConfigForTest, mSingleThreadedExecutor);
         try {
@@ -879,10 +894,160 @@ public class ContactsIndexerUserInstanceTest extends FakeContactsProviderTestBas
             latch.await(30L, TimeUnit.SECONDS);
             verify(mockJobScheduler).schedule(any());
         } finally {
+            // unregisters observers registered by startAsync()
             mInstance.shutdown();
         }
     }
 
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_CHECK_CONTACTS_INDEXER_DELTA_TIMESTAMPS)
+    @Test
+    public void testDeltaUpdate_inconsistentTimestamps_withDeltaTimestampCheck() throws Exception {
+        // Insert and delete future contacts
+        mFakeContactsProvider.setContactUpdatedTimestampOffsetMs(TimeUnit.DAYS.toMillis(1));
+        ContentResolver resolver = mContext.getContentResolver();
+        ContentValues dummyValues = new ContentValues();
+        for (int i = 0; i < 10; i++) {
+            resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+        }
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 2),
+                /*extras=*/ null);
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 3),
+                /*extras=*/ null);
+
+        executeAndWaitForCompletion(
+                mInstance.doDeltaUpdateAsync(ContactsProviderUtil.UPDATE_LIMIT_NONE,
+                        mUpdateStats),
+                mSingleThreadedExecutor);
+
+        // Verify future contacts were indexed
+        AppSearchHelper searchHelper =
+                AppSearchHelper.createAppSearchHelper(mContext, mSingleThreadedExecutor);
+        List<String> contactIds = searchHelper.getAllContactIdsAsync().get();
+        assertThat(contactIds.size()).isEqualTo(8);
+
+        // Verify saved delta timestamps were not updated since the contacts were in the future
+        ContactsIndexerSettings settings = mInstance.getSettings();
+        assertThat(settings.getLastContactUpdateTimestampMillis()).isEqualTo(0);
+        assertThat(settings.getLastContactDeleteTimestampMillis()).isEqualTo(0);
+
+        // Spoof the delta timestamps to be in the future
+        settings.setLastContactUpdateTimestampMillis(
+                System.currentTimeMillis() + TimeUnit.DAYS.toMillis(1));
+        settings.setLastContactDeleteTimestampMillis(
+                System.currentTimeMillis() + TimeUnit.DAYS.toMillis(1));
+
+        // Insert and delete contacts in the present
+        mFakeContactsProvider.setContactUpdatedTimestampOffsetMs(0);
+        for (int i = 0; i < 10; i++) {
+            resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+        }
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 5),
+                /*extras=*/ null);
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 7),
+                /*extras=*/ null);
+        long presentUpdateTimestamp =
+                mFakeContactsProvider.getMostRecentContactUpdateTimestampMillis();
+        long presentDeleteTimestamp =
+                mFakeContactsProvider.getMostRecentDeletedContactTimestampMillis();
+        // Verify timestamps are not in the future
+        assertThat(presentUpdateTimestamp).isAtMost(System.currentTimeMillis());
+        assertThat(presentDeleteTimestamp).isAtMost(System.currentTimeMillis());
+
+        JobScheduler mockJobScheduler = mock(JobScheduler.class);
+        mContext.setJobScheduler(mockJobScheduler);
+
+        mUpdateStats.clear();
+        executeAndWaitForCompletion(
+                mInstance.doDeltaUpdateAsync(ContactsProviderUtil.UPDATE_LIMIT_NONE,
+                        mUpdateStats),
+                mSingleThreadedExecutor);
+
+        // Verify contacts were indexed
+        contactIds = searchHelper.getAllContactIdsAsync().get();
+        assertThat(contactIds.size()).isEqualTo(16);
+
+        // Verify the deltas timestamps were updated to the present timestamps
+        assertThat(settings.getLastContactUpdateTimestampMillis()).isEqualTo(
+                presentUpdateTimestamp);
+        assertThat(settings.getLastContactDeleteTimestampMillis()).isEqualTo(
+                presentDeleteTimestamp);
+
+        // Verify the full update job was scheduled due to inconsistent timestamps
+        verify(mockJobScheduler).schedule(any());
+    }
+
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_CHECK_CONTACTS_INDEXER_DELTA_TIMESTAMPS)
+    @Test
+    public void testDeltaUpdate_inconsistentTimestamps_withoutDeltaTimestampCheck()
+            throws Exception {
+        long startTimeMillis = System.currentTimeMillis();
+
+        // Insert and delete future contacts
+        mFakeContactsProvider.setContactUpdatedTimestampOffsetMs(TimeUnit.DAYS.toMillis(1));
+        ContentResolver resolver = mContext.getContentResolver();
+        ContentValues dummyValues = new ContentValues();
+        for (int i = 0; i < 10; i++) {
+            resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+        }
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 2),
+                /*extras=*/ null);
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 3),
+                /*extras=*/ null);
+        long futureUpdateTimestamp =
+                mFakeContactsProvider.getMostRecentContactUpdateTimestampMillis();
+        long futureDeleteTimestamp =
+                mFakeContactsProvider.getMostRecentDeletedContactTimestampMillis();
+        // Verify timestamps are in the future
+        assertThat(futureUpdateTimestamp).isAtLeast(startTimeMillis + TimeUnit.DAYS.toMillis(1));
+        assertThat(futureDeleteTimestamp).isAtLeast(startTimeMillis + TimeUnit.DAYS.toMillis(1));
+
+        executeAndWaitForCompletion(
+                mInstance.doDeltaUpdateAsync(ContactsProviderUtil.UPDATE_LIMIT_NONE,
+                        mUpdateStats),
+                mSingleThreadedExecutor);
+
+        // Verify future contacts were indexed
+        AppSearchHelper searchHelper =
+                AppSearchHelper.createAppSearchHelper(mContext, mSingleThreadedExecutor);
+        List<String> contactIds = searchHelper.getAllContactIdsAsync().get();
+        assertThat(contactIds.size()).isEqualTo(8);
+
+        // Verify saved delta timestamps match those of the future contacts
+        ContactsIndexerSettings settings = mInstance.getSettings();
+        assertThat(settings.getLastContactUpdateTimestampMillis()).isEqualTo(futureUpdateTimestamp);
+        assertThat(settings.getLastContactDeleteTimestampMillis()).isEqualTo(futureDeleteTimestamp);
+
+        // Insert and delete contacts in the present
+        mFakeContactsProvider.setContactUpdatedTimestampOffsetMs(0);
+        for (int i = 0; i < 10; i++) {
+            resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+        }
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 5),
+                /*extras=*/ null);
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 7),
+                /*extras=*/ null);
+
+        JobScheduler mockJobScheduler = mock(JobScheduler.class);
+        mContext.setJobScheduler(mockJobScheduler);
+
+        mUpdateStats.clear();
+        executeAndWaitForCompletion(
+                mInstance.doDeltaUpdateAsync(ContactsProviderUtil.UPDATE_LIMIT_NONE,
+                        mUpdateStats),
+                mSingleThreadedExecutor);
+
+        // Verify contacts were not indexed
+        contactIds = searchHelper.getAllContactIdsAsync().get();
+        assertThat(contactIds.size()).isEqualTo(8);
+
+        // Verify the delta timestamps did not change
+        assertThat(settings.getLastContactUpdateTimestampMillis()).isEqualTo(futureUpdateTimestamp);
+        assertThat(settings.getLastContactDeleteTimestampMillis()).isEqualTo(futureDeleteTimestamp);
+
+        // Verify no full update job was scheduled
+        verifyNoMoreInteractions(mockJobScheduler);
+    }
+
     @Test
     public void testLogStats_succeedsWhenMoreUpdateStatusCodesThanDeleteStatusCodes() {
         // This test exists since there was a typo/bug where we logged the update status codes
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsProviderUtilTest.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsProviderUtilTest.java
index a2c67b22..198be11c 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsProviderUtilTest.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsProviderUtilTest.java
@@ -18,17 +18,28 @@ package com.android.server.appsearch.contactsindexer;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.content.ContentResolver;
 import android.content.ContentUris;
 import android.content.ContentValues;
+import android.platform.test.annotations.RequiresFlagsDisabled;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 import android.provider.ContactsContract;
 
+import com.android.appsearch.flags.Flags;
+
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 public class ContactsProviderUtilTest extends FakeContactsProviderTestBase {
+    @Rule
+    public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
+
     @Test
     public void testGetUpdatedContactIds_getAll() throws Exception {
         ContentResolver resolver = mContext.getContentResolver();
@@ -98,6 +109,55 @@ public class ContactsProviderUtilTest extends FakeContactsProviderTestBase {
         assertThat(ids).isEqualTo(expectedIds);
     }
 
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_CHECK_CONTACTS_INDEXER_DELTA_TIMESTAMPS)
+    @Test
+    public void testGetUpdatedContactIds_futureTimestamp_withDeltaTimestampCheck() {
+        ContentResolver resolver = mContext.getContentResolver();
+        ContentValues dummyValues = new ContentValues();
+
+        // Insert a contact in the present
+        resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+        long presentUpdateTimestamp =
+                mFakeContactsProvider.getMostRecentContactUpdateTimestampMillis();
+        assertThat(presentUpdateTimestamp).isAtMost(System.currentTimeMillis());
+
+        // Insert another contact one day into the future
+        mFakeContactsProvider.setContactUpdatedTimestampOffsetMs(TimeUnit.DAYS.toMillis(1));
+        resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+
+        List<String> ids = new ArrayList<>();
+        long lastUpdatedTime = ContactsProviderUtil.getUpdatedContactIds(mContext,
+                /*sinceFilter=*/ 0, ContactsProviderUtil.UPDATE_LIMIT_NONE,
+                ids, /*stats=*/ null);
+        // Verify the last updated time is not in the future (matches the first inserted contact)
+        assertThat(lastUpdatedTime).isEqualTo(presentUpdateTimestamp);
+    }
+
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_CHECK_CONTACTS_INDEXER_DELTA_TIMESTAMPS)
+    @Test
+    public void testGetUpdatedContactIds_futureTimestamp_withoutDeltaTimestampCheck() {
+        ContentResolver resolver = mContext.getContentResolver();
+        ContentValues dummyValues = new ContentValues();
+
+        // Insert a contact in the present
+        resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+
+        // Insert another contact one day into the future
+        long startTimeMillis = System.currentTimeMillis();
+        mFakeContactsProvider.setContactUpdatedTimestampOffsetMs(TimeUnit.DAYS.toMillis(1));
+        resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+        long futureUpdateTimestamp =
+                mFakeContactsProvider.getMostRecentContactUpdateTimestampMillis();
+        assertThat(futureUpdateTimestamp).isAtLeast(startTimeMillis + TimeUnit.DAYS.toMillis(1));
+
+        List<String> ids = new ArrayList<>();
+        long lastUpdatedTime = ContactsProviderUtil.getUpdatedContactIds(mContext,
+                /*sinceFilter=*/ 0, ContactsProviderUtil.UPDATE_LIMIT_NONE,
+                ids, /*stats=*/ null);
+        // Verify the last updated time is in the future (matches the second inserted contact)
+        assertThat(lastUpdatedTime).isEqualTo(futureUpdateTimestamp);
+    }
+
     @Test
     public void testGetDeletedContactIds_getAll() {
         ContentResolver resolver = mContext.getContentResolver();
@@ -171,4 +231,59 @@ public class ContactsProviderUtilTest extends FakeContactsProviderTestBase {
                 mFakeContactsProvider.getMostRecentDeletedContactTimestampMillis());
         assertThat(ids).isEqualTo(expectedIds);
     }
+
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_CHECK_CONTACTS_INDEXER_DELTA_TIMESTAMPS)
+    @Test
+    public void testGetDeletedContactIds_futureTimestamp_withDeltaTimestampCheck() {
+        ContentResolver resolver = mContext.getContentResolver();
+        ContentValues dummyValues = new ContentValues();
+        resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+        resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+
+        // Delete a contact in the present
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 0),
+                /*extras=*/ null);
+        long presentDeleteTimestamp =
+                mFakeContactsProvider.getMostRecentDeletedContactTimestampMillis();
+        assertThat(presentDeleteTimestamp).isAtMost(System.currentTimeMillis());
+
+        // Delete another contact one day into the future
+        mFakeContactsProvider.setContactUpdatedTimestampOffsetMs(TimeUnit.DAYS.toMillis(1));
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 1),
+                /*extras=*/ null);
+
+        List<String> ids = new ArrayList<>();
+        long lastDeleteTime = ContactsProviderUtil.getDeletedContactIds(mContext,
+                /*sinceFilter=*/ 0, ids, /*stats=*/ null);
+        // Verify the last deleted time is not in the future (matches the first deleted contact)
+        assertThat(lastDeleteTime).isEqualTo(presentDeleteTimestamp);
+    }
+
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_CHECK_CONTACTS_INDEXER_DELTA_TIMESTAMPS)
+    @Test
+    public void testGetDeletedContactIds_futureTimestamp_withoutDeltaTimestampCheck() {
+        ContentResolver resolver = mContext.getContentResolver();
+        ContentValues dummyValues = new ContentValues();
+        resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+        resolver.insert(ContactsContract.Contacts.CONTENT_URI, dummyValues);
+
+        // Delete a contact in the present
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 0),
+                /*extras=*/ null);
+
+        // Delete another contact one day into the future
+        long startTimeMillis = System.currentTimeMillis();
+        mFakeContactsProvider.setContactUpdatedTimestampOffsetMs(TimeUnit.DAYS.toMillis(1));
+        resolver.delete(ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, 1),
+                /*extras=*/ null);
+        long futureDeleteTimestamp =
+                mFakeContactsProvider.getMostRecentDeletedContactTimestampMillis();
+        assertThat(futureDeleteTimestamp).isAtLeast(startTimeMillis + TimeUnit.DAYS.toMillis(1));
+
+        List<String> ids = new ArrayList<>();
+        long lastDeleteTime = ContactsProviderUtil.getDeletedContactIds(mContext,
+                /*sinceFilter=*/ 0, ids, /*stats=*/ null);
+        // Verify the last updated time is in the future (matches the second deleted contact)
+        assertThat(lastDeleteTime).isEqualTo(futureDeleteTimestamp);
+    }
 }
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/EnterpriseContactsTest.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/EnterpriseContactsTest.java
index 8435d7f6..4de70946 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/EnterpriseContactsTest.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/EnterpriseContactsTest.java
@@ -485,6 +485,9 @@ public class EnterpriseContactsTest {
 
     @Test
     public void testEnterpriseContactsInSystemPackage_transformPerson() throws Exception {
+        // This test can be flaky due to the CP2 for the main user sometimes returning null in
+        // response to the enterprise contacts query, so only run this test if CP2 is available
+        assumeTrue(isCP2Available(ApplicationProvider.getApplicationContext()));
         // The other tests in this class test behavior against contacts indexed in the local
         // package. This test however creates a test contact in CP2 which will be indexed in the
         // android package.
@@ -577,6 +580,18 @@ public class EnterpriseContactsTest {
         }
     }
 
+    /** Checks if CP2 is available for the given user context. */
+    private boolean isCP2Available(Context context) {
+        ContentResolver resolver = context.getContentResolver();
+        String[] projection =
+                new String[]{ContactsContract.Contacts._ID, ContactsContract.Data.LOOKUP_KEY};
+        String selection = ContactsContract.Contacts._ID + " = 0";
+        try (Cursor cursor = resolver.query(ContactsContract.Contacts.ENTERPRISE_CONTENT_URI,
+                projection, selection, /*selectionArgs=*/ null, /*sortOrder=*/ null)) {
+            return cursor != null;
+        }
+    }
+
     /** Deletes all raw contacts belonging to this test. */
     private void cleanupTestContacts(ContentResolver resolver) {
         String where =
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/FakeContactsProvider.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/FakeContactsProvider.java
index 6e2f4c83..8987357f 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/FakeContactsProvider.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/FakeContactsProvider.java
@@ -137,6 +137,9 @@ public class FakeContactsProvider extends ContentProvider {
     // Data Query delay in millis added for testing
     private long mDataQueryDelayMs = 0;
 
+    // Contact updated timestamp offset in millis added for testing inconsistent timestamps
+    private long mContactUpdatedTimestampOffsetMs = 0;
+
     // Only odd contactIds should have additional data.
     private static boolean shouldhaveAdditionalData(long contactId) {
         return (contactId & 1) > 0;
@@ -287,6 +290,10 @@ public class FakeContactsProvider extends ContentProvider {
         mDataQueryDelayMs = dataQueryDelayMs;
     }
 
+    public void setContactUpdatedTimestampOffsetMs(long contactUpdatedTimestampOffsetMs) {
+        mContactUpdatedTimestampOffsetMs = contactUpdatedTimestampOffsetMs;
+    }
+
     FakeContactsProvider(Resources resources) {
         mResources = resources;
     }
@@ -488,7 +495,8 @@ public class FakeContactsProvider extends ContentProvider {
             throw new IllegalArgumentException("delete: unknown URI " + uri);
         }
         // Insert tombstone into deleted_contacts table
-        mMostRecentDeletedContactTimestampMillis = System.currentTimeMillis();
+        mMostRecentDeletedContactTimestampMillis =
+                System.currentTimeMillis() + mContactUpdatedTimestampOffsetMs;
         long contactId = ContentUris.parseId(uri);
         ContentValues values = new ContentValues();
         values.put(DeletedContacts.CONTACT_ID, contactId);
@@ -509,7 +517,8 @@ public class FakeContactsProvider extends ContentProvider {
             throw new IllegalArgumentException("insert: unknown URI " + uri);
         }
 
-        mMostRecentContactLastUpdatedTimestampMillis = System.currentTimeMillis();
+        mMostRecentContactLastUpdatedTimestampMillis =
+                System.currentTimeMillis() + mContactUpdatedTimestampOffsetMs;
         values.put(Contacts._ID, mNumContacts++);
         values.put(Contacts.CONTACT_LAST_UPDATED_TIMESTAMP,
                 mMostRecentContactLastUpdatedTimestampMillis);
diff --git a/testing/coretests/src/android/app/appsearch/external/app/AppSearchSchemaInternalTest.java b/testing/coretests/src/android/app/appsearch/external/app/AppSearchSchemaInternalTest.java
new file mode 100644
index 00000000..2a83cf8f
--- /dev/null
+++ b/testing/coretests/src/android/app/appsearch/external/app/AppSearchSchemaInternalTest.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import android.app.appsearch.AppSearchSchema.PropertyConfig;
+import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
+import android.platform.test.annotations.RequiresFlagsEnabled;
+
+import com.android.appsearch.flags.Flags;
+
+import org.junit.Test;
+
+import java.util.List;
+
+public class AppSearchSchemaInternalTest {
+    // TODO(b/384947619): move delete propagation tests back to AppSearchSchemaCtsTest once the API
+    //   is ready.
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testStringPropertyConfigDefaultValues_withDeletePropagationType() {
+        StringPropertyConfig builder = new StringPropertyConfig.Builder("test").build();
+        assertThat(builder.getIndexingType()).isEqualTo(StringPropertyConfig.INDEXING_TYPE_NONE);
+        assertThat(builder.getTokenizerType()).isEqualTo(StringPropertyConfig.TOKENIZER_TYPE_NONE);
+        assertThat(builder.getCardinality()).isEqualTo(PropertyConfig.CARDINALITY_OPTIONAL);
+        assertThat(builder.getJoinableValueType())
+                .isEqualTo(StringPropertyConfig.JOINABLE_VALUE_TYPE_NONE);
+        assertThat(builder.getDeletePropagationType())
+                .isEqualTo(StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testPropertyConfig_withDeletePropagationType() {
+        AppSearchSchema schema =
+                new AppSearchSchema.Builder("Test")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("qualifiedId1")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig
+                                                        .DELETE_PROPAGATION_TYPE_PROPAGATE_FROM)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("qualifiedId2")
+                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE)
+                                        .build())
+                        .build();
+
+        assertThat(schema.getSchemaType()).isEqualTo("Test");
+        List<PropertyConfig> properties = schema.getProperties();
+        assertThat(properties).hasSize(2);
+
+        assertThat(properties.get(0).getName()).isEqualTo("qualifiedId1");
+        assertThat(properties.get(0).getCardinality())
+                .isEqualTo(PropertyConfig.CARDINALITY_OPTIONAL);
+        assertThat(((StringPropertyConfig) properties.get(0)).getJoinableValueType())
+                .isEqualTo(StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID);
+        assertThat(((StringPropertyConfig) properties.get(0)).getDeletePropagationType())
+                .isEqualTo(StringPropertyConfig.DELETE_PROPAGATION_TYPE_PROPAGATE_FROM);
+
+        assertThat(properties.get(1).getName()).isEqualTo("qualifiedId2");
+        assertThat(properties.get(1).getCardinality())
+                .isEqualTo(PropertyConfig.CARDINALITY_REQUIRED);
+        assertThat(((StringPropertyConfig) properties.get(1)).getJoinableValueType())
+                .isEqualTo(StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID);
+        assertThat(((StringPropertyConfig) properties.get(1)).getDeletePropagationType())
+                .isEqualTo(StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testSetDeletePropagationTypeWithoutJoinableValueTypeQualifiedId_throwsException() {
+        // Setting delete propagation type PROPAGATE_FROM with joinable value type other than
+        // QUALIFIED_ID should fail.
+        final StringPropertyConfig.Builder builder =
+                new StringPropertyConfig.Builder("qualifiedId")
+                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                        .setDeletePropagationType(
+                                StringPropertyConfig.DELETE_PROPAGATION_TYPE_PROPAGATE_FROM);
+        IllegalStateException e = assertThrows(IllegalStateException.class, () -> builder.build());
+        assertThat(e)
+                .hasMessageThat()
+                .contains(
+                        "Cannot set delete propagation without setting"
+                                + " JOINABLE_VALUE_TYPE_QUALIFIED_ID.");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testAppSearchSchema_toString_withDeletePropagationType() {
+        AppSearchSchema schema =
+                new AppSearchSchema.Builder("testSchema")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("qualifiedId1")
+                                        .setDescription("first qualifiedId")
+                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig
+                                                        .DELETE_PROPAGATION_TYPE_PROPAGATE_FROM)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("qualifiedId2")
+                                        .setDescription("second qualifiedId")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE)
+                                        .build())
+                        .build();
+
+        String schemaString = schema.toString();
+
+        String expectedString =
+                "{\n"
+                        + "  schemaType: \"testSchema\",\n"
+                        + "  properties: [\n"
+                        + "    {\n"
+                        + "      name: \"qualifiedId1\",\n"
+                        + "      description: \"first qualifiedId\",\n"
+                        + "      indexingType: INDEXING_TYPE_NONE,\n"
+                        + "      tokenizerType: TOKENIZER_TYPE_NONE,\n"
+                        + "      joinableValueType: JOINABLE_VALUE_TYPE_QUALIFIED_ID,\n"
+                        + "      deletePropagationType: DELETE_PROPAGATION_TYPE_PROPAGATE_FROM,\n"
+                        + "      cardinality: CARDINALITY_REQUIRED,\n"
+                        + "      dataType: DATA_TYPE_STRING,\n"
+                        + "    },\n"
+                        + "    {\n"
+                        + "      name: \"qualifiedId2\",\n"
+                        + "      description: \"second qualifiedId\",\n"
+                        + "      indexingType: INDEXING_TYPE_NONE,\n"
+                        + "      tokenizerType: TOKENIZER_TYPE_NONE,\n"
+                        + "      joinableValueType: JOINABLE_VALUE_TYPE_QUALIFIED_ID,\n"
+                        + "      deletePropagationType: DELETE_PROPAGATION_TYPE_NONE,\n"
+                        + "      cardinality: CARDINALITY_OPTIONAL,\n"
+                        + "      dataType: DATA_TYPE_STRING,\n"
+                        + "    }\n"
+                        + "  ]\n"
+                        + "}";
+
+        String[] lines = expectedString.split("\n");
+        for (String line : lines) {
+            assertThat(schemaString).contains(line);
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testStringPropertyConfig_setDeletePropagationType() {
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        new StringPropertyConfig.Builder("qualifiedId")
+                                .setDeletePropagationType(5)
+                                .build());
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        new StringPropertyConfig.Builder("qualifiedId")
+                                .setDeletePropagationType(2)
+                                .build());
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        new StringPropertyConfig.Builder("qualifiedId")
+                                .setDeletePropagationType(-1)
+                                .build());
+    }
+}
diff --git a/testing/coretests/src/android/app/appsearch/external/app/AppSearchSessionInternalTestBase.java b/testing/coretests/src/android/app/appsearch/external/app/AppSearchSessionInternalTestBase.java
index 90bb6ea1..e629376f 100644
--- a/testing/coretests/src/android/app/appsearch/external/app/AppSearchSessionInternalTestBase.java
+++ b/testing/coretests/src/android/app/appsearch/external/app/AppSearchSessionInternalTestBase.java
@@ -18,22 +18,33 @@ package android.app.appsearch;
 
 import static android.app.appsearch.testutil.AppSearchTestUtils.checkIsBatchResultSuccess;
 import static android.app.appsearch.testutil.AppSearchTestUtils.convertSearchResultsToDocuments;
+import static android.app.appsearch.testutil.AppSearchTestUtils.doGet;
 
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
 
-import android.annotation.NonNull;
 import android.app.appsearch.AppSearchSchema.PropertyConfig;
 import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
+import android.app.appsearch.testutil.AppSearchTestUtils;
+import android.app.appsearch.util.DocumentIdUtil;
+import android.content.Context;
+import android.platform.test.annotations.RequiresFlagsEnabled;
+
+import androidx.test.core.app.ApplicationProvider;
+
+import com.android.appsearch.flags.Flags;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.ListenableFuture;
 
+import org.jspecify.annotations.NonNull;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 
 import java.util.Collections;
 import java.util.List;
@@ -47,12 +58,16 @@ public abstract class AppSearchSessionInternalTestBase {
 
     protected AppSearchSessionShim mDb1;
 
+    private final Context mContext = ApplicationProvider.getApplicationContext();
+
     protected abstract ListenableFuture<AppSearchSessionShim> createSearchSessionAsync(
             @NonNull String dbName);
 
     protected abstract ListenableFuture<AppSearchSessionShim> createSearchSessionAsync(
             @NonNull String dbName, @NonNull ExecutorService executor);
 
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
+
     @Before
     public void setUp() throws Exception {
         mDb1 = createSearchSessionAsync(DB_NAME_1).get();
@@ -238,4 +253,559 @@ public abstract class AppSearchSessionInternalTestBase {
                         musicianDocWithParent,
                         messageDocWithParent);
     }
+
+    // TODO(b/384947619): move delete propagation tests back to AppSearchSessionCtsTestBase once the
+    //   API is ready.
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testGetSchema_deletePropagationTypePropagateFrom() throws Exception {
+        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.JOIN_SPEC_AND_QUALIFIED_ID));
+        assumeTrue(
+                mDb1.getFeatures()
+                        .isFeatureSupported(
+                                Features
+                                        .SCHEMA_STRING_PROPERTY_CONFIG_DELETE_PROPAGATION_TYPE_PROPAGATE_FROM));
+
+        AppSearchSchema inSchema =
+                new AppSearchSchema.Builder("Test")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("normalStr")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("qualifiedId")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig
+                                                        .DELETE_PROPAGATION_TYPE_PROPAGATE_FROM)
+                                        .build())
+                        .build();
+
+        SetSchemaRequest request = new SetSchemaRequest.Builder().addSchemas(inSchema).build();
+
+        mDb1.setSchemaAsync(request).get();
+
+        Set<AppSearchSchema> actual = mDb1.getSchemaAsync().get().getSchemas();
+        assertThat(actual).hasSize(1);
+        assertThat(actual).containsExactlyElementsIn(request.getSchemas());
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testGetSchema_deletePropagationTypeNoneWithNonJoinable_succeeds() throws Exception {
+        AppSearchSchema inSchema =
+                new AppSearchSchema.Builder("Test")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("optionalString")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig.JOINABLE_VALUE_TYPE_NONE)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("requiredString")
+                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig.JOINABLE_VALUE_TYPE_NONE)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("repeatedString")
+                                        .setCardinality(PropertyConfig.CARDINALITY_REPEATED)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig.JOINABLE_VALUE_TYPE_NONE)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE)
+                                        .build())
+                        .build();
+
+        SetSchemaRequest request = new SetSchemaRequest.Builder().addSchemas(inSchema).build();
+
+        mDb1.setSchemaAsync(request).get();
+
+        Set<AppSearchSchema> actual = mDb1.getSchemaAsync().get().getSchemas();
+        assertThat(actual).hasSize(1);
+        assertThat(actual).containsExactlyElementsIn(request.getSchemas());
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testGetSchema_deletePropagationTypeNoneWithJoinable_succeeds() throws Exception {
+        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.JOIN_SPEC_AND_QUALIFIED_ID));
+
+        AppSearchSchema inSchema =
+                new AppSearchSchema.Builder("Test")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("optionalString")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("requiredString")
+                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE)
+                                        .build())
+                        .build();
+
+        SetSchemaRequest request = new SetSchemaRequest.Builder().addSchemas(inSchema).build();
+
+        mDb1.setSchemaAsync(request).get();
+
+        Set<AppSearchSchema> actual = mDb1.getSchemaAsync().get().getSchemas();
+        assertThat(actual).hasSize(1);
+        assertThat(actual).containsExactlyElementsIn(request.getSchemas());
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testRemove_withDeletePropagationFromParentToChildren() throws Exception {
+        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.JOIN_SPEC_AND_QUALIFIED_ID));
+        assumeTrue(
+                mDb1.getFeatures()
+                        .isFeatureSupported(
+                                Features
+                                        .SCHEMA_STRING_PROPERTY_CONFIG_DELETE_PROPAGATION_TYPE_PROPAGATE_FROM));
+
+        // Person (parent) schema.
+        AppSearchSchema personSchema =
+                new AppSearchSchema.Builder("Person")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("name")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .build();
+        // Email (child) schema: "sender" has delete propagation type PROPAGATE_FROM, and "receiver"
+        // doesn't have delete propagation.
+        AppSearchSchema emailSchema =
+                new AppSearchSchema.Builder("Email")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("subject")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("sender")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig
+                                                        .DELETE_PROPAGATION_TYPE_PROPAGATE_FROM)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("receiver")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .build())
+                        .build();
+
+        // Schema registration
+        mDb1.setSchemaAsync(
+                        new SetSchemaRequest.Builder()
+                                .addSchemas(personSchema, emailSchema)
+                                .build())
+                .get();
+
+        // Put 1 person and 2 email documents.
+        GenericDocument person =
+                new GenericDocument.Builder<>("namespace", "person", "Person")
+                        .setPropertyString("name", "test person")
+                        .build();
+        String personQualifiedId =
+                DocumentIdUtil.createQualifiedId(
+                        mContext.getPackageName(), DB_NAME_1, "namespace", "person");
+        GenericDocument email1 =
+                new GenericDocument.Builder<>("namespace", "email1", "Email")
+                        .setPropertyString("subject", "test email subject")
+                        .setPropertyString("sender", personQualifiedId)
+                        .build();
+        GenericDocument email2 =
+                new GenericDocument.Builder<>("namespace", "email2", "Email")
+                        .setPropertyString("subject", "test email subject")
+                        .setPropertyString("receiver", personQualifiedId)
+                        .build();
+        checkIsBatchResultSuccess(
+                mDb1.putAsync(
+                        new PutDocumentsRequest.Builder()
+                                .addGenericDocuments(person, email1, email2)
+                                .build()));
+
+        // Check the presence of the documents
+        assertThat(doGet(mDb1, "namespace", "person")).hasSize(1);
+        assertThat(doGet(mDb1, "namespace", "email1")).hasSize(1);
+        assertThat(doGet(mDb1, "namespace", "email2")).hasSize(1);
+
+        // Delete the person (parent) document
+        checkIsBatchResultSuccess(
+                mDb1.removeAsync(
+                        new RemoveByDocumentIdRequest.Builder("namespace")
+                                .addIds("person")
+                                .build()));
+
+        // Verify that:
+        // - Person document is deleted.
+        // - Email1 document is also deleted due to the delete propagation via "sender".
+        // - Email2 document is still present since "receiver" does not have delete propagation.
+        AppSearchBatchResult<String, GenericDocument> getResult1 =
+                mDb1.getByDocumentIdAsync(
+                                new GetByDocumentIdRequest.Builder("namespace")
+                                        .addIds("person", "email1")
+                                        .build())
+                        .get();
+        assertThat(getResult1.isSuccess()).isFalse();
+        assertThat(getResult1.getFailures()).hasSize(2);
+        assertThat(getResult1.getFailures().get("person").getResultCode())
+                .isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(getResult1.getFailures().get("email1").getResultCode())
+                .isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+
+        AppSearchBatchResult<String, GenericDocument> getResult2 =
+                mDb1.getByDocumentIdAsync(
+                                new GetByDocumentIdRequest.Builder("namespace")
+                                        .addIds("email2")
+                                        .build())
+                        .get();
+        assertThat(getResult2.isSuccess()).isTrue();
+        assertThat(getResult2.getSuccesses()).hasSize(1);
+        assertThat(getResult2.getSuccesses().get("email2")).isEqualTo(email2);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testRemove_withDeletePropagationFromParentToGrandchildren() throws Exception {
+        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.JOIN_SPEC_AND_QUALIFIED_ID));
+        assumeTrue(
+                mDb1.getFeatures()
+                        .isFeatureSupported(
+                                Features
+                                        .SCHEMA_STRING_PROPERTY_CONFIG_DELETE_PROPAGATION_TYPE_PROPAGATE_FROM));
+
+        // Person (parent) schema.
+        AppSearchSchema personSchema =
+                new AppSearchSchema.Builder("Person")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("name")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .build();
+        // Email (child) schema: "sender" has delete propagation type PROPAGATE_FROM, and "receiver"
+        // doesn't have delete propagation.
+        AppSearchSchema emailSchema =
+                new AppSearchSchema.Builder("Email")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("subject")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("sender")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig
+                                                        .DELETE_PROPAGATION_TYPE_PROPAGATE_FROM)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("receiver")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .build())
+                        .build();
+
+        // Label (grandchild) schema: "object" has delete propagation type PROPAGATE_FROM, and
+        // "softLink" doesn't have delete propagation.
+        AppSearchSchema labelSchema =
+                new AppSearchSchema.Builder("Label")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("text")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("object")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig
+                                                        .DELETE_PROPAGATION_TYPE_PROPAGATE_FROM)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("softLink")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .build())
+                        .build();
+
+        // Schema registration
+        mDb1.setSchemaAsync(
+                        new SetSchemaRequest.Builder()
+                                .addSchemas(personSchema, emailSchema, labelSchema)
+                                .build())
+                .get();
+
+        // Put 1 person, 2 email, and 4 label documents with the following relations:
+        //
+        //                           ("object") - label1
+        //                         /
+        //               email1 <-
+        //             /           \
+        //       ("sender")          ("softLink") - label2
+        //           /
+        // person <-
+        //           \
+        //       ("receiver")        ("object") - label3
+        //             \           /
+        //               email2 <-
+        //                         \
+        //                           ("softLink") - label4
+        GenericDocument person =
+                new GenericDocument.Builder<>("namespace", "person", "Person")
+                        .setPropertyString("name", "test person")
+                        .build();
+        String personQualifiedId =
+                DocumentIdUtil.createQualifiedId(
+                        mContext.getPackageName(), DB_NAME_1, "namespace", "person");
+
+        GenericDocument email1 =
+                new GenericDocument.Builder<>("namespace", "email1", "Email")
+                        .setPropertyString("subject", "test email subject")
+                        .setPropertyString("sender", personQualifiedId)
+                        .build();
+        GenericDocument email2 =
+                new GenericDocument.Builder<>("namespace", "email2", "Email")
+                        .setPropertyString("subject", "test email subject")
+                        .setPropertyString("receiver", personQualifiedId)
+                        .build();
+        String emailQualifiedId1 =
+                DocumentIdUtil.createQualifiedId(
+                        mContext.getPackageName(), DB_NAME_1, "namespace", "email1");
+        String emailQualifiedId2 =
+                DocumentIdUtil.createQualifiedId(
+                        mContext.getPackageName(), DB_NAME_1, "namespace", "email2");
+
+        GenericDocument label1 =
+                new GenericDocument.Builder<>("namespace", "label1", "Label")
+                        .setPropertyString("text", "label1")
+                        .setPropertyString("object", emailQualifiedId1)
+                        .build();
+        GenericDocument label2 =
+                new GenericDocument.Builder<>("namespace", "label2", "Label")
+                        .setPropertyString("text", "label2")
+                        .setPropertyString("softLink", emailQualifiedId1)
+                        .build();
+        GenericDocument label3 =
+                new GenericDocument.Builder<>("namespace", "label3", "Label")
+                        .setPropertyString("text", "label3")
+                        .setPropertyString("object", emailQualifiedId2)
+                        .build();
+        GenericDocument label4 =
+                new GenericDocument.Builder<>("namespace", "label4", "Label")
+                        .setPropertyString("text", "label4")
+                        .setPropertyString("softLink", emailQualifiedId2)
+                        .build();
+
+        checkIsBatchResultSuccess(
+                mDb1.putAsync(
+                        new PutDocumentsRequest.Builder()
+                                .addGenericDocuments(
+                                        person, email1, email2, label1, label2, label3, label4)
+                                .build()));
+
+        // Check the presence of the documents
+        assertThat(doGet(mDb1, "namespace", "person")).hasSize(1);
+        assertThat(doGet(mDb1, "namespace", "email1")).hasSize(1);
+        assertThat(doGet(mDb1, "namespace", "email2")).hasSize(1);
+        assertThat(doGet(mDb1, "namespace", "label1")).hasSize(1);
+        assertThat(doGet(mDb1, "namespace", "label2")).hasSize(1);
+        assertThat(doGet(mDb1, "namespace", "label3")).hasSize(1);
+        assertThat(doGet(mDb1, "namespace", "label4")).hasSize(1);
+
+        // Delete the person (parent) document
+        checkIsBatchResultSuccess(
+                mDb1.removeAsync(
+                        new RemoveByDocumentIdRequest.Builder("namespace")
+                                .addIds("person")
+                                .build()));
+
+        // Verify that:
+        // - Person document is deleted.
+        // - Email1 document is also deleted due to the delete propagation via "sender".
+        // - Label1 document is also deleted due to the delete propagation via "object".
+        // - Label2 document is still present since "softLink" does not have delete propagation.
+        // - Email2 document is still present since "receiver" does not have delete propagation.
+        // - Label3 document is still present since Email2 is not deleted.
+        // - Label4 document is still present since Email2 is not deleted.
+        AppSearchBatchResult<String, GenericDocument> getResult1 =
+                mDb1.getByDocumentIdAsync(
+                                new GetByDocumentIdRequest.Builder("namespace")
+                                        .addIds("person", "email1", "label1")
+                                        .build())
+                        .get();
+        assertThat(getResult1.isSuccess()).isFalse();
+        assertThat(getResult1.getFailures()).hasSize(3);
+        assertThat(getResult1.getFailures().get("person").getResultCode())
+                .isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(getResult1.getFailures().get("email1").getResultCode())
+                .isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(getResult1.getFailures().get("label1").getResultCode())
+                .isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+
+        AppSearchBatchResult<String, GenericDocument> getResult2 =
+                mDb1.getByDocumentIdAsync(
+                                new GetByDocumentIdRequest.Builder("namespace")
+                                        .addIds("email2", "label2", "label3", "label4")
+                                        .build())
+                        .get();
+        assertThat(getResult2.isSuccess()).isTrue();
+        assertThat(getResult2.getSuccesses()).hasSize(4);
+        assertThat(getResult2.getSuccesses().get("email2")).isEqualTo(email2);
+        assertThat(getResult2.getSuccesses().get("label2")).isEqualTo(label2);
+        assertThat(getResult2.getSuccesses().get("label3")).isEqualTo(label3);
+        assertThat(getResult2.getSuccesses().get("label4")).isEqualTo(label4);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+    public void testRemove_withDeletePropagationFromParentToChildren_fromMultipleProperties()
+            throws Exception {
+        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.JOIN_SPEC_AND_QUALIFIED_ID));
+        assumeTrue(
+                mDb1.getFeatures()
+                        .isFeatureSupported(
+                                Features
+                                        .SCHEMA_STRING_PROPERTY_CONFIG_DELETE_PROPAGATION_TYPE_PROPAGATE_FROM));
+
+        // Person (parent) schema.
+        AppSearchSchema personSchema =
+                new AppSearchSchema.Builder("Person")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("name")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .build();
+        // Email (child) schema: "sender" has delete propagation type PROPAGATE_FROM, and "receiver"
+        // doesn't have delete propagation.
+        AppSearchSchema emailSchema =
+                new AppSearchSchema.Builder("Email")
+                        .addProperty(
+                                new StringPropertyConfig.Builder("subject")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("sender")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                StringPropertyConfig
+                                                        .DELETE_PROPAGATION_TYPE_PROPAGATE_FROM)
+                                        .build())
+                        .addProperty(
+                                new StringPropertyConfig.Builder("receiver")
+                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setJoinableValueType(
+                                                StringPropertyConfig
+                                                        .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .build())
+                        .build();
+
+        // Schema registration
+        mDb1.setSchemaAsync(
+                        new SetSchemaRequest.Builder()
+                                .addSchemas(personSchema, emailSchema)
+                                .build())
+                .get();
+
+        // Put 1 person and 1 email document.
+        // Email document has both "sender" and "receiver" referring to the person document.
+        GenericDocument person =
+                new GenericDocument.Builder<>("namespace", "person", "Person")
+                        .setPropertyString("name", "test person")
+                        .build();
+        String personQualifiedId =
+                DocumentIdUtil.createQualifiedId(
+                        mContext.getPackageName(), DB_NAME_1, "namespace", "person");
+        GenericDocument email =
+                new GenericDocument.Builder<>("namespace", "email", "Email")
+                        .setPropertyString("subject", "test email subject")
+                        .setPropertyString("sender", personQualifiedId)
+                        .setPropertyString("receiver", personQualifiedId)
+                        .build();
+        checkIsBatchResultSuccess(
+                mDb1.putAsync(
+                        new PutDocumentsRequest.Builder()
+                                .addGenericDocuments(person, email)
+                                .build()));
+
+        // Check the presence of the documents
+        assertThat(doGet(mDb1, "namespace", "person")).hasSize(1);
+        assertThat(doGet(mDb1, "namespace", "email")).hasSize(1);
+
+        // Delete the person (parent) document
+        checkIsBatchResultSuccess(
+                mDb1.removeAsync(
+                        new RemoveByDocumentIdRequest.Builder("namespace")
+                                .addIds("person")
+                                .build()));
+
+        // Verify that:
+        // - Person document is deleted.
+        // - Email document is also deleted since there is at least one property ("sender") with
+        //   DELETE_PROPAGATION_TYPE_PROPAGATE_FROM.
+        AppSearchBatchResult<String, GenericDocument> getResult1 =
+                mDb1.getByDocumentIdAsync(
+                                new GetByDocumentIdRequest.Builder("namespace")
+                                        .addIds("person", "email")
+                                        .build())
+                        .get();
+        assertThat(getResult1.isSuccess()).isFalse();
+        assertThat(getResult1.getFailures()).hasSize(2);
+        assertThat(getResult1.getFailures().get("person").getResultCode())
+                .isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(getResult1.getFailures().get("email").getResultCode())
+                .isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+    }
 }
diff --git a/testing/coretests/src/android/app/appsearch/external/app/SearchResultInternalTest.java b/testing/coretests/src/android/app/appsearch/external/app/SearchResultInternalTest.java
index bf3239a2..85c9edc7 100644
--- a/testing/coretests/src/android/app/appsearch/external/app/SearchResultInternalTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/app/SearchResultInternalTest.java
@@ -134,4 +134,50 @@ public class SearchResultInternalTest {
         assertThat(matchInfoCopy.getSubmatchRange()).isEqualTo(submatchRange);
         assertThat(matchInfoCopy.getSnippetRange()).isEqualTo(snippetMatchRange);
     }
+
+    @Test
+    public void testMatchInfoBuilderCopyConstructor_embeddingMatchInfoEnabled() {
+        SearchResult.MatchRange exactMatchRange = new SearchResult.MatchRange(3, 8);
+        SearchResult.MatchRange submatchRange = new SearchResult.MatchRange(3, 5);
+        SearchResult.MatchRange snippetMatchRange = new SearchResult.MatchRange(1, 10);
+
+        double semanticScore = 1.1d;
+        int queryEmbeddingVectorIndex = 1;
+        int embeddingSearchMetricType = SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_COSINE;
+        SearchResult.EmbeddingMatchInfo embeddingMatchInfo =
+                new SearchResult.EmbeddingMatchInfo(
+                        semanticScore, queryEmbeddingVectorIndex, embeddingSearchMetricType);
+
+        SearchResult.MatchInfo matchInfo1 =
+                new SearchResult.MatchInfo.Builder("propertyPath1")
+                        .setExactMatchRange(exactMatchRange)
+                        .setSubmatchRange(submatchRange)
+                        .setSnippetRange(snippetMatchRange)
+                        .build();
+
+        SearchResult.MatchInfo matchInfo2 =
+                new SearchResult.MatchInfo.Builder("propertyPath2")
+                        .setEmbeddingMatch(embeddingMatchInfo)
+                        .build();
+
+        SearchResult.MatchInfo matchInfoCopy1 =
+                new SearchResult.MatchInfo.Builder(matchInfo1).build();
+        assertThat(matchInfoCopy1.getPropertyPath()).isEqualTo("propertyPath1");
+        assertThat(matchInfoCopy1.getTextMatch()).isNotNull();
+        assertThat(matchInfoCopy1.getTextMatch().getExactMatchRange()).isEqualTo(exactMatchRange);
+        assertThat(matchInfoCopy1.getTextMatch().getSubmatchRange()).isEqualTo(submatchRange);
+        assertThat(matchInfoCopy1.getTextMatch().getSnippetRange()).isEqualTo(snippetMatchRange);
+        assertThat(matchInfoCopy1.getEmbeddingMatch()).isNull();
+
+        SearchResult.MatchInfo matchInfoCopy2 =
+                new SearchResult.MatchInfo.Builder(matchInfo2).build();
+        assertThat(matchInfoCopy2.getPropertyPath()).isEqualTo("propertyPath2");
+        assertThat(matchInfoCopy2.getEmbeddingMatch()).isNotNull();
+        assertThat(matchInfoCopy2.getEmbeddingMatch().getSemanticScore()).isEqualTo(semanticScore);
+        assertThat(matchInfoCopy2.getEmbeddingMatch().getQueryEmbeddingVectorIndex())
+                .isEqualTo(queryEmbeddingVectorIndex);
+        assertThat(matchInfoCopy2.getEmbeddingMatch().getEmbeddingSearchMetricType())
+                .isEqualTo(embeddingSearchMetricType);
+        assertThat(matchInfoCopy2.getTextMatch()).isNull();
+    }
 }
diff --git a/testing/coretests/src/android/app/appsearch/external/app/SearchSpecInternalTest.java b/testing/coretests/src/android/app/appsearch/external/app/SearchSpecInternalTest.java
index 4487057f..d1bee813 100644
--- a/testing/coretests/src/android/app/appsearch/external/app/SearchSpecInternalTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/app/SearchSpecInternalTest.java
@@ -42,6 +42,7 @@ public class SearchSpecInternalTest {
                         .setSnippetCount(5)
                         .setSnippetCountPerProperty(10)
                         .setMaxSnippetSize(15)
+                        .setRetrieveEmbeddingMatchInfos(true)
                         .setResultCountPerPage(42)
                         .setOrder(SearchSpec.ORDER_ASCENDING)
                         .setRankingStrategy(SearchSpec.RANKING_STRATEGY_DOCUMENT_SCORE)
@@ -58,6 +59,7 @@ public class SearchSpecInternalTest {
         assertThat(searchSpec.getSnippetCount()).isEqualTo(5);
         assertThat(searchSpec.getSnippetCountPerProperty()).isEqualTo(10);
         assertThat(searchSpec.getMaxSnippetSize()).isEqualTo(15);
+        assertThat(searchSpec.shouldRetrieveEmbeddingMatchInfos()).isTrue();
         assertThat(searchSpec.getResultCountPerPage()).isEqualTo(42);
         assertThat(searchSpec.getOrder()).isEqualTo(SearchSpec.ORDER_ASCENDING);
         assertThat(searchSpec.getRankingStrategy())
diff --git a/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java b/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java
index b0853349..36efc3a8 100644
--- a/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java
@@ -188,4 +188,56 @@ public class FlagsTest {
         assertThat(Flags.FLAG_ENABLE_SEARCH_RESULT_PARENT_TYPES)
                 .isEqualTo("com.android.appsearch.flags.enable_search_result_parent_types");
     }
+
+    @Test
+    public void testFlagValue_enableDeletePropagationType() {
+        assertThat(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+                .isEqualTo("com.android.appsearch.flags.enable_delete_propagation_type");
+    }
+
+    @Test
+    public void testFlagValue_enableAppSearchManageBlobFiles() {
+        assertThat(Flags.FLAG_ENABLE_APP_SEARCH_MANAGE_BLOB_FILES)
+                .isEqualTo("com.android.appsearch.flags.enable_app_search_manage_blob_files");
+    }
+
+    @Test
+    public void testFlagValue_enableCalculateTimeSinceLastAttemptedOptimize() {
+        assertThat(Flags.FLAG_ENABLE_CALCULATE_TIME_SINCE_LAST_ATTEMPTED_OPTIMIZE)
+                .isEqualTo(
+                        "com.android.appsearch.flags"
+                                + ".enable_calculate_time_since_last_attempted_optimize");
+    }
+
+    @Test
+    public void testFlagValue_enableQualifiedIdJoinIndexV3() {
+        assertThat(Flags.FLAG_ENABLE_QUALIFIED_ID_JOIN_INDEX_V3)
+                .isEqualTo("com.android.appsearch.flags.enable_qualified_id_join_index_v3");
+    }
+
+    @Test
+    public void testFlagValue_enableSoftIndexRestoration() {
+        assertThat(Flags.FLAG_ENABLE_SOFT_INDEX_RESTORATION)
+                .isEqualTo("com.android.appsearch.flags.enable_soft_index_restoration");
+    }
+
+    @Test
+    public void testFlagValue_enableMarkerFileForOptimize() {
+        assertThat(Flags.FLAG_ENABLE_MARKER_FILE_FOR_OPTIMIZE)
+                .isEqualTo("com.android.appsearch.flags.enable_marker_file_for_optimize");
+    }
+
+    @Test
+    public void testFlagValue_enableReleaseBackupSchemaFileIfOverlayPresent() {
+        assertThat(Flags.FLAG_ENABLE_RELEASE_BACKUP_SCHEMA_FILE_IF_OVERLAY_PRESENT)
+                .isEqualTo(
+                        "com.android.appsearch.flags"
+                                + ".enable_release_backup_schema_file_if_overlay_present");
+    }
+
+    @Test
+    public void testFlagValue_enableEmbeddingMatchInfo() {
+        assertThat(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
+                .isEqualTo("com.android.appsearch.flags.enable_embedding_match_info");
+    }
 }
diff --git a/testing/mockingservicestests/Android.bp b/testing/mockingservicestests/Android.bp
index a7a078ed..767f7bbe 100644
--- a/testing/mockingservicestests/Android.bp
+++ b/testing/mockingservicestests/Android.bp
@@ -25,6 +25,7 @@ android_test {
         "CtsAppSearchTestUtils",
         "androidx.test.ext.junit",
         "androidx.test.rules",
+        "appsearch-apk-for-tests",
         "appsearch_flags_java_lib",
         "flag-junit",
         "mockito-target-minus-junit4",
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java
index 1f8f4cb6..59a74fe3 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java
@@ -31,6 +31,8 @@ import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_R
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
@@ -94,9 +96,11 @@ import android.app.appsearch.aidl.SearchSuggestionAidlRequest;
 import android.app.appsearch.aidl.SetSchemaAidlRequest;
 import android.app.appsearch.aidl.UnregisterObserverCallbackAidlRequest;
 import android.app.appsearch.aidl.WriteSearchResultsToFileAidlRequest;
+import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.observer.ObserverSpec;
 import android.app.appsearch.safeparcel.GenericDocumentParcel;
 import android.app.appsearch.stats.SchemaMigrationStats;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.app.role.RoleManager;
 import android.content.AttributionSource;
 import android.content.BroadcastReceiver;
@@ -111,11 +115,8 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.os.UserHandle;
-import android.os.UserManager;
 import android.platform.test.annotations.RequiresFlagsDisabled;
 import android.platform.test.annotations.RequiresFlagsEnabled;
-import android.platform.test.flag.junit.CheckFlagsRule;
-import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 import android.provider.DeviceConfig;
 
 import androidx.test.core.app.ApplicationProvider;
@@ -135,16 +136,18 @@ import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 import com.android.server.appsearch.external.localstorage.usagereporting.ClickActionGenericDocument;
 import com.android.server.appsearch.external.localstorage.usagereporting.SearchActionGenericDocument;
+import com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager;
 import com.android.server.usage.StorageStatsManagerLocal;
 
-import libcore.io.IoBridge;
-
 import com.google.common.util.concurrent.SettableFuture;
 
+import libcore.io.IoBridge;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
 import org.mockito.ArgumentCaptor;
 
@@ -168,8 +171,7 @@ public class AppSearchManagerServiceTest {
     private final RoleManager mRoleManager = mock(RoleManager.class);
     private final DevicePolicyManager mDevicePolicyManager = mock(DevicePolicyManager.class);
 
-    @Rule
-    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
 
     @Rule
     public ExtendedMockitoRule mExtendedMockitoRule = new ExtendedMockitoRule.Builder()
@@ -179,7 +181,7 @@ public class AppSearchManagerServiceTest {
     @Rule
     public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
 
-    private Context mContext;
+    private TestContext mContext;
     private AppSearchManagerService mAppSearchManagerService;
     private UserHandle mUserHandle;
     private UiAutomation mUiAutomation;
@@ -194,49 +196,8 @@ public class AppSearchManagerServiceTest {
         Context context = ApplicationProvider.getApplicationContext();
         mUserHandle = context.getUser();
         mUiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
-        mContext = new ContextWrapper(context) {
-            // Mock-able package manager for testing
-            final PackageManager mPackageManager = spy(context.getPackageManager());
-            final UserManager mUserManager = spy(context.getSystemService(UserManager.class));
-
-            @Override
-            public Intent registerReceiverForAllUsers(@Nullable BroadcastReceiver receiver,
-                    @NonNull IntentFilter filter, @Nullable String broadcastPermission,
-                    @Nullable Handler scheduler) {
-                // Do nothing
-                return null;
-            }
-
-            @Override
-            public Context createContextAsUser(UserHandle user, int flags) {
-                return new ContextWrapper(super.createContextAsUser(user, flags)) {
-                    @Override
-                    public PackageManager getPackageManager() {
-                        return mPackageManager;
-                    }
-                };
-            }
-
-            @Override
-            public PackageManager getPackageManager() {
-                return mPackageManager;
-            }
-
-            @Nullable
-            @Override
-            public Object getSystemService(String name) {
-                if (Context.ROLE_SERVICE.equals(name)) {
-                    return mRoleManager;
-                }
-                if (Context.DEVICE_POLICY_SERVICE.equals(name)) {
-                    return mDevicePolicyManager;
-                }
-                if (Context.USER_SERVICE.equals(name)) {
-                    return mUserManager;
-                }
-                return super.getSystemService(name);
-            }
-        };
+        final boolean useIsolatedStorage = false;
+        mContext = new TestContext(context, mRoleManager, mDevicePolicyManager, useIsolatedStorage);
 
         // Set a test environment that provides a temporary folder for AppSearch
         File mAppSearchDir = mTemporaryFolder.newFolder();
@@ -1005,30 +966,17 @@ public class AppSearchManagerServiceTest {
         verifyLocalCallsResults(RESULT_DENIED);
         verifyGlobalCallsResults(AppSearchResult.RESULT_OK);
 
-        // Add mocking to spy'd package manager to return current uid for package foo
-        // This is necessary to pass call verification using a different package name
-        PackageManager spyPackageManager = mContext.getPackageManager();
+        // Mock the package manager to return current uid for package foo; this is necessary to pass
+        // call verification using a different package name
+        PackageManager spyPackageManager = spy(mContext.getPackageManager());
         int uid = AppSearchAttributionSource.createAttributionSource(mContext,
                 mCallingPid).getUid();
         doReturn(uid).when(spyPackageManager).getPackageUid(FOO_PACKAGE_NAME, /* flags= */ 0);
         // Specifically grant permission for report system usage to package foo
         doReturn(PackageManager.PERMISSION_GRANTED).when(spyPackageManager).checkPermission(
                 READ_GLOBAL_APP_SEARCH_DATA, FOO_PACKAGE_NAME);
-
-        // Change the calling package name used in the helper methods indirectly through a newly
-        // wrapped context
-        Context context = ApplicationProvider.getApplicationContext();
-        mContext = new ContextWrapper(context) {
-            @Override
-            public String getPackageName() {
-                return FOO_PACKAGE_NAME;
-            }
-
-            @Override
-            public AttributionSource getAttributionSource() {
-                return super.getAttributionSource().withPackageName(FOO_PACKAGE_NAME);
-            }
-        };
+        mContext.mPackageManager = spyPackageManager;
+        mContext.mPackageName = FOO_PACKAGE_NAME;
 
         // Confirm that we're using a different package name
         assertThat(mContext.getPackageName()).isEqualTo(FOO_PACKAGE_NAME);
@@ -1291,7 +1239,7 @@ public class AppSearchManagerServiceTest {
                 false);
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_RATE_LIMIT_API_COSTS,
-                "localSearch:6;localSetSchema:9;localGetSchema:15",
+                "localSearch:3;localSetSchema:9;localGetSchema:15",
                 false);
         verifySetSchemaResult(RESULT_RATE_LIMITED);
         verifyLocalGetSchemaResult(RESULT_RATE_LIMITED);
@@ -1508,6 +1456,26 @@ public class AppSearchManagerServiceTest {
         verify(mLogger, timeout(1000).times(0)).logStats(any(CallStats.class));
     }
 
+    @Test
+    public void testIsolatedStorageNotAvailable() throws Exception {
+        assumeTrue(IsolatedStorageServiceManager.isolatedStorageFlagsSet());
+        // Ensure that AppSearch fails if the isolated storage service fails
+        final boolean useIsolatedStorage = true;
+        Context context = ApplicationProvider.getApplicationContext();
+        // Create a new user, one was already created during setUp()
+        UserHandle testUserHandle = new UserHandle(1);
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+        TestContext testContext =
+                new TestContext(context, mRoleManager, mDevicePolicyManager, useIsolatedStorage);
+        assertThrows(
+                AppSearchException.class,
+                () -> {
+                    AppSearchUserInstanceManager.getInstance()
+                            .getOrCreateUserInstance(testContext, testUserHandle, appSearchConfig);
+                });
+    }
+
     private void verifyLocalCallsResults(int resultCode) throws Exception {
         // These APIs are local calls since they specify a database. If the API specifies a target
         // package, then the target package matches the calling package
@@ -1956,6 +1924,82 @@ public class AppSearchManagerServiceTest {
         }
     }
 
+    private static final class TestContext extends ContextWrapper {
+        private final RoleManager mRoleManager;
+        private final DevicePolicyManager mDevicePolicyManager;
+        private final boolean mUseIsolatedStorage;
+
+        @Nullable private PackageManager mPackageManager;
+        @Nullable private String mPackageName;
+
+        TestContext(
+                Context base,
+                RoleManager roleManager,
+                DevicePolicyManager devicePolicyManager,
+                boolean useIsolatedStorage) {
+            super(base);
+            mRoleManager = roleManager;
+            mDevicePolicyManager = devicePolicyManager;
+            mUseIsolatedStorage = useIsolatedStorage;
+        }
+
+        @Override
+        public Intent registerReceiverForAllUsers(@Nullable BroadcastReceiver receiver,
+                @NonNull IntentFilter filter, @Nullable String broadcastPermission,
+                @Nullable Handler scheduler) {
+            // Do nothing
+            return null;
+        }
+
+        @Override
+        public Context createContextAsUser(UserHandle user, int flags) {
+            return this;
+        }
+
+        @Override
+        public PackageManager getPackageManager() {
+            if (mPackageManager != null) {
+                return mPackageManager;
+            }
+            return super.getPackageManager();
+        }
+
+        @Override
+        public String getPackageName() {
+            if (mPackageName != null) {
+                return mPackageName;
+            }
+            return super.getPackageName();
+        }
+
+        @Override
+        public AttributionSource getAttributionSource() {
+            if (mPackageName != null) {
+                return super.getAttributionSource().withPackageName(mPackageName);
+            }
+            return super.getAttributionSource();
+        }
+
+        @Nullable
+        @Override
+        public Object getSystemService(String name) {
+            if (Context.ROLE_SERVICE.equals(name)) {
+                return mRoleManager;
+            }
+            if (Context.DEVICE_POLICY_SERVICE.equals(name)) {
+                return mDevicePolicyManager;
+            }
+            /* TODO (b/399479359)
+             * Force use of native icing for AppSearchManagerServiceTests, which mocks
+             * servives and does have the isolated storage service
+             */
+            if (Context.VIRTUALIZATION_SERVICE.equals(name) && !mUseIsolatedStorage) {
+                return null;
+            }
+            return super.getSystemService(name);
+        }
+    };
+
     private static final class TestResultCallback extends IAppSearchResultCallback.Stub {
         private final SettableFuture<AppSearchResult<?>> future = SettableFuture.create();
 
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java
index d696b43e..61fa4bc6 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java
@@ -32,11 +32,10 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 import android.annotation.NonNull;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.content.Context;
 import android.content.pm.UserInfo;
 import android.platform.test.annotations.RequiresFlagsEnabled;
-import android.platform.test.flag.junit.CheckFlagsRule;
-import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 import android.provider.DeviceConfig;
 
 import androidx.test.core.app.ApplicationProvider;
@@ -58,6 +57,7 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.mockito.MockitoSession;
 import org.mockito.quality.Strictness;
 
@@ -72,8 +72,7 @@ public class AppSearchModuleTest {
     public static final String KEY_APP_OPEN_EVENT_INDEXER_ENABLED =
             "app_open_event_indexer_enabled";
 
-    @Rule
-    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
 
     private final ContactsIndexerManagerService mContactsIndexerService =
             mock(ContactsIndexerManagerService.class);
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java
index 1f19ba25..656d0b0f 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java
@@ -34,6 +34,7 @@ import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_I
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_ICING_USE_PERSISTENT_HASHMAP;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_ICING_USE_PRE_MAPPING_WITH_FILE_BACKED_VECTOR;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_ICING_USE_READ_ONLY_SEARCH;
+import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_LIGHTWEIGHT_PERSIST_TYPE;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_LIMIT_CONFIG_MAX_SUGGESTION_COUNT;
@@ -69,31 +70,53 @@ import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LITE_I
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LITE_INDEX_SORT_SIZE;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_MAX_OPEN_BLOB_COUNT;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_MIN_TIME_INTERVAL_BETWEEN_SAMPLES_MILLIS;
+import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_RATE_LIMIT_ENABLED;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_RATE_LIMIT_TASK_QUEUE_PER_PACKAGE_CAPACITY_PERCENTAGE;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_RATE_LIMIT_TASK_QUEUE_TOTAL_CAPACITY;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_SAMPLING_INTERVAL;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_TIME_OPTIMIZE_THRESHOLD_MILLIS;
+import static com.android.server.appsearch.external.localstorage.IcingOptionsConfig.DEFAULT_ICU_DATA_FILE_ABSOLUTE_PATH;
 import static com.android.server.appsearch.external.localstorage.IcingOptionsConfig.DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS;
 import static com.android.server.appsearch.external.localstorage.IcingOptionsConfig.DEFAULT_USE_NEW_QUALIFIED_ID_JOIN_INDEX;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.appsearch.testutil.AppSearchTestUtils;
+import android.platform.test.annotations.RequiresFlagsDisabled;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 import android.provider.DeviceConfig;
 
+import com.android.appsearch.flags.Flags;
 import com.android.modules.utils.testing.TestableDeviceConfig;
 import com.android.server.appsearch.external.localstorage.AppSearchConfig;
 import com.android.server.appsearch.external.localstorage.IcingOptionsConfig;
 import com.android.server.appsearch.external.localstorage.stats.CallStats;
+import com.android.server.appsearch.icing.proto.PersistType;
+import com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager;
 
 import org.junit.Assert;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 
 public class ServiceAppSearchConfigTest {
     @Rule
-    public final TestableDeviceConfig.TestableDeviceConfigRule
-            mDeviceConfigRule = new TestableDeviceConfig.TestableDeviceConfigRule();
+    public final RuleChain mRuleChain =
+        AppSearchTestUtils.createCommonTestRules()
+            .around(new TestableDeviceConfig.TestableDeviceConfigRule());
+
+    @Test
+    public void testDefaultValues_cachedMinTimeOptimizeThreshold() {
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+
+        // TODO (b/385020106): figure out how to make the default 0 timeSinceLastOptimize work
+        //  with a higher threshold and return 4 hours when
+        //  Flags.enable_four_hour_min_optimize_threshold is true
+        assertThat(appSearchConfig.getCachedMinTimeOptimizeThresholdMs())
+                .isEqualTo(DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS);
+    }
 
     @Test
     public void testDefaultValues_allCachedValue() {
@@ -149,8 +172,12 @@ public class ServiceAppSearchConfigTest {
                 IcingOptionsConfig.DEFAULT_USE_PREMAPPING_WITH_FILE_BACKED_VECTOR);
         assertThat(appSearchConfig.getUsePersistentHashMap()).isEqualTo(
                 IcingOptionsConfig.DEFAULT_USE_PERSISTENT_HASH_MAP);
-        assertThat(appSearchConfig.getMaxPageBytesLimit()).isEqualTo(
-                IcingOptionsConfig.DEFAULT_MAX_PAGE_BYTES_LIMIT);
+        // TODO: b/389105038 - remove this temporary workaround for binder transaction limit.
+        assertThat(appSearchConfig.getMaxPageBytesLimit())
+                .isAnyOf(
+                        IcingOptionsConfig.DEFAULT_MAX_PAGE_BYTES_LIMIT,
+                        IsolatedStorageServiceManager
+                                .DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE);
         assertThat(appSearchConfig.getCachedRateLimitEnabled()).isEqualTo(
                 DEFAULT_RATE_LIMIT_ENABLED);
         AppSearchRateLimitConfig rateLimitConfig = appSearchConfig.getCachedRateLimitConfig();
@@ -180,6 +207,8 @@ public class ServiceAppSearchConfigTest {
         assertThat(appSearchConfig.getMaxOpenBlobCount()).isEqualTo(DEFAULT_MAX_OPEN_BLOB_COUNT);
         assertThat(appSearchConfig.getOrphanBlobTimeToLiveMs())
                 .isEqualTo(DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS);
+        assertThat(appSearchConfig.getIcuDataFileAbsolutePath())
+                .isEqualTo(DEFAULT_ICU_DATA_FILE_ABSOLUTE_PATH);
     }
 
     @Test
@@ -945,6 +974,63 @@ public class ServiceAppSearchConfigTest {
         assertThat(appSearchConfig.getOrphanBlobTimeToLiveMs()).isEqualTo(1778);
     }
 
+    @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_RECOVERY_PROOF_PERSISTENCE)
+    public void testGetLightweightPersistType_defaultValue_returnsLite() {
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+        assertThat(appSearchConfig.getLightweightPersistType())
+                .isEqualTo(PersistType.Code.LITE);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_RECOVERY_PROOF_PERSISTENCE)
+    public void testGetLightweightPersistType_defaultValue_returnsRecoveryProof() {
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+        assertThat(appSearchConfig.getLightweightPersistType())
+                .isEqualTo(PersistType.Code.RECOVERY_PROOF);
+    }
+
+    @Test
+    public void testGetLightweightPersistType_valueOverride_returnsOverrideValue() {
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_LIGHTWEIGHT_PERSIST_TYPE,
+                Integer.toString(PersistType.Code.FULL.getNumber()),
+                /* makeDefault= */ false);
+
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+        assertThat(appSearchConfig.getLightweightPersistType())
+                .isEqualTo(PersistType.Code.FULL);
+    }
+
+    @Test
+    public void testGetLightweightPersistType_invalidValueOverride_doesntReturnOverrideValue() {
+        // Override value to FULL so that we have a predictable value.
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_LIGHTWEIGHT_PERSIST_TYPE,
+                Integer.toString(PersistType.Code.FULL.getNumber()),
+                /* makeDefault= */ false);
+
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+        assertThat(appSearchConfig.getLightweightPersistType())
+                .isEqualTo(PersistType.Code.FULL);
+
+        // Now try to override it with a value that is outside of the range of PersistType.Code.
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_LIGHTWEIGHT_PERSIST_TYPE,
+                Integer.toString(123),
+                /* makeDefault= */ false);
+
+        assertThat(appSearchConfig.getLightweightPersistType())
+                .isEqualTo(PersistType.Code.FULL);
+    }
+
     @Test
     public void testNotUsable_afterClose() {
         ServiceAppSearchConfig appSearchConfig =
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/stats/MockingIsolatedStorageServiceLoggerTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/stats/MockingIsolatedStorageServiceLoggerTest.java
new file mode 100644
index 00000000..e3b96507
--- /dev/null
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/stats/MockingIsolatedStorageServiceLoggerTest.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.stats;
+
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_ERROR;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_FINISH;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_READY;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_START;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_STOP;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.annotation.NonNull;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+import com.android.dx.mockito.inline.extended.StaticMockitoSessionBuilder;
+import com.android.modules.utils.testing.ExtendedMockitoRule;
+import com.android.modules.utils.testing.StaticMockFixture;
+import com.android.server.appsearch.isolated_storage_service.ServiceConfig;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mockito;
+
+public class MockingIsolatedStorageServiceLoggerTest {
+
+    @Rule
+    public ExtendedMockitoRule mExtendedMockitoRule =
+            new ExtendedMockitoRule.Builder().addStaticMockFixtures(TestMockFixture::new).build();
+
+    @Test
+    public void testLogStats_start() throws Exception {
+        ServiceConfig config = new ServiceConfig();
+        config.pCachedSamplingInterval = 1;
+        IsolateStorageServiceLogger logger = new IsolateStorageServiceLogger(config);
+        VMPayloadStats stats = new VMPayloadStats.Builder(CALLBACK_TYPE_START).build();
+        logger.logStats(stats);
+
+        ArgumentCaptor<Integer> callType = ArgumentCaptor.forClass(int.class);
+        ExtendedMockito.verify(
+                () ->
+                        AppSearchStatsLog.write(
+                                Mockito.eq(AppSearchStatsLog.APP_SEARCH_VM_PAYLOAD_STATS_REPORTED),
+                                Mockito.anyInt(),
+                                Mockito.anyInt(),
+                                callType.capture(),
+                                Mockito.anyInt(),
+                                Mockito.anyInt(),
+                                Mockito.anyInt()));
+
+        assertThat(callType.getValue()).isEqualTo(CALLBACK_TYPE_START);
+    }
+
+    @Test
+    public void testLogStats_ready() throws Exception {
+        ServiceConfig config = new ServiceConfig();
+        config.pCachedSamplingInterval = 1;
+        IsolateStorageServiceLogger logger = new IsolateStorageServiceLogger(config);
+        VMPayloadStats stats = new VMPayloadStats.Builder(CALLBACK_TYPE_READY).build();
+        logger.logStats(stats);
+
+        ArgumentCaptor<Integer> callType = ArgumentCaptor.forClass(int.class);
+        ExtendedMockito.verify(
+                () ->
+                        AppSearchStatsLog.write(
+                                Mockito.eq(AppSearchStatsLog.APP_SEARCH_VM_PAYLOAD_STATS_REPORTED),
+                                Mockito.anyInt(),
+                                Mockito.anyInt(),
+                                callType.capture(),
+                                Mockito.anyInt(),
+                                Mockito.anyInt(),
+                                Mockito.anyInt()));
+
+        assertThat(callType.getValue()).isEqualTo(CALLBACK_TYPE_READY);
+    }
+
+    @Test
+    public void testLogStats_finish() throws Exception {
+        ServiceConfig config = new ServiceConfig();
+        config.pCachedSamplingInterval = 1;
+        IsolateStorageServiceLogger logger = new IsolateStorageServiceLogger(config);
+        VMPayloadStats stats =
+                new VMPayloadStats.Builder(CALLBACK_TYPE_FINISH).setExitCode(2).build();
+        logger.logStats(stats);
+
+        ArgumentCaptor<Integer> callType = ArgumentCaptor.forClass(int.class);
+        ArgumentCaptor<Integer> exitCode = ArgumentCaptor.forClass(int.class);
+        ExtendedMockito.verify(
+                () ->
+                        AppSearchStatsLog.write(
+                                Mockito.eq(AppSearchStatsLog.APP_SEARCH_VM_PAYLOAD_STATS_REPORTED),
+                                Mockito.anyInt(),
+                                Mockito.anyInt(),
+                                callType.capture(),
+                                Mockito.anyInt(),
+                                exitCode.capture(),
+                                Mockito.anyInt()));
+
+        assertThat(callType.getValue()).isEqualTo(CALLBACK_TYPE_FINISH);
+        assertThat(exitCode.getValue()).isEqualTo(2);
+    }
+
+    @Test
+    public void testLogStats_error() throws Exception {
+        ServiceConfig config = new ServiceConfig();
+        config.pCachedSamplingInterval = 1;
+        IsolateStorageServiceLogger logger = new IsolateStorageServiceLogger(config);
+        VMPayloadStats stats =
+                new VMPayloadStats.Builder(CALLBACK_TYPE_ERROR).setErrorCode(3).build();
+        logger.logStats(stats);
+
+        ArgumentCaptor<Integer> callType = ArgumentCaptor.forClass(int.class);
+        ArgumentCaptor<Integer> errorCode = ArgumentCaptor.forClass(int.class);
+        ExtendedMockito.verify(
+                () ->
+                        AppSearchStatsLog.write(
+                                Mockito.eq(AppSearchStatsLog.APP_SEARCH_VM_PAYLOAD_STATS_REPORTED),
+                                Mockito.anyInt(),
+                                Mockito.anyInt(),
+                                callType.capture(),
+                                errorCode.capture(),
+                                Mockito.anyInt(),
+                                Mockito.anyInt()));
+
+        assertThat(callType.getValue()).isEqualTo(CALLBACK_TYPE_ERROR);
+        assertThat(errorCode.getValue()).isEqualTo(3);
+    }
+
+    @Test
+    public void testLogStats_stop() throws Exception {
+        ServiceConfig config = new ServiceConfig();
+        config.pCachedSamplingInterval = 1;
+        IsolateStorageServiceLogger logger = new IsolateStorageServiceLogger(config);
+        VMPayloadStats stats =
+                new VMPayloadStats.Builder(CALLBACK_TYPE_STOP).setStopReason(4).build();
+        logger.logStats(stats);
+
+        ArgumentCaptor<Integer> callType = ArgumentCaptor.forClass(int.class);
+        ArgumentCaptor<Integer> stopReason = ArgumentCaptor.forClass(int.class);
+        ExtendedMockito.verify(
+                () ->
+                        AppSearchStatsLog.write(
+                                Mockito.eq(AppSearchStatsLog.APP_SEARCH_VM_PAYLOAD_STATS_REPORTED),
+                                Mockito.anyInt(),
+                                Mockito.anyInt(),
+                                callType.capture(),
+                                Mockito.anyInt(),
+                                Mockito.anyInt(),
+                                stopReason.capture()));
+
+        assertThat(callType.getValue()).isEqualTo(CALLBACK_TYPE_STOP);
+        assertThat(stopReason.getValue()).isEqualTo(4);
+    }
+
+    private static class TestMockFixture implements StaticMockFixture {
+        @Override
+        public StaticMockitoSessionBuilder setUpMockedClasses(
+                @NonNull StaticMockitoSessionBuilder sessionBuilder) {
+            sessionBuilder.spyStatic(AppSearchStatsLog.class);
+            return sessionBuilder;
+        }
+
+        @Override
+        public void setUpMockBehaviors() {}
+
+        @Override
+        public void tearDown() {}
+    }
+}
diff --git a/testing/safeparceltests/src/android/app/appsearch/safeparcel/TestSafeParcelableWithTypeUseAnnotation.java b/testing/safeparceltests/src/android/app/appsearch/safeparcel/TestSafeParcelableWithTypeUseAnnotation.java
new file mode 100644
index 00000000..4dd86d6e
--- /dev/null
+++ b/testing/safeparceltests/src/android/app/appsearch/safeparcel/TestSafeParcelableWithTypeUseAnnotation.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.safeparcel;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+@SafeParcelable.Class(creator = "TestSafeParcelableWithTypeUseAnnotationCreator")
+public class TestSafeParcelableWithTypeUseAnnotation extends AbstractSafeParcelable {
+
+    public static final
+            Parcelable.@TypeUseAnnotation Creator<TestSafeParcelableWithTypeUseAnnotation>
+            CREATOR = new TestSafeParcelableWithTypeUseAnnotationCreator();
+
+    @Field(id = 1)
+    public String publicString;
+
+    @Constructor
+    public TestSafeParcelableWithTypeUseAnnotation(@Param(id = 1) String publicString) {
+        this.publicString = publicString;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int flags) {
+        TestSafeParcelableWithTypeUseAnnotationCreator.writeToParcel(this, out, flags);
+    }
+
+    @Target(ElementType.TYPE_USE)
+    public static @interface TypeUseAnnotation {}
+}
diff --git a/testing/servicestests/Android.bp b/testing/servicestests/Android.bp
index 83b3d087..02518112 100644
--- a/testing/servicestests/Android.bp
+++ b/testing/servicestests/Android.bp
@@ -25,6 +25,7 @@ android_test {
         "android.app.appfunctions.flags-aconfig-java",
         "androidx.test.ext.junit",
         "androidx.test.rules",
+        "appsearch-apk-for-tests",
         "appsearch_flags_java_lib",
         "compatibility-device-util-axt",
         "flag-junit",
diff --git a/testing/servicestests/src/com/android/server/appsearch/AdbDumpUtilTest.java b/testing/servicestests/src/com/android/server/appsearch/AdbDumpUtilTest.java
index 6c2ef764..12151da6 100644
--- a/testing/servicestests/src/com/android/server/appsearch/AdbDumpUtilTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/AdbDumpUtilTest.java
@@ -135,6 +135,7 @@ public class AdbDumpUtilTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         optimizeInfo -> true);
         List<AppSearchSchema> schemas = Collections.singletonList(new AppSearchSchema.Builder(
                 PERSON_TYPE).addProperty(new AppSearchSchema.StringPropertyConfig.Builder(
diff --git a/testing/servicestests/src/com/android/server/appsearch/ServiceOptimizeStrategyTest.java b/testing/servicestests/src/com/android/server/appsearch/ServiceOptimizeStrategyTest.java
index a70f8aa7..d48b54fb 100644
--- a/testing/servicestests/src/com/android/server/appsearch/ServiceOptimizeStrategyTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/ServiceOptimizeStrategyTest.java
@@ -17,12 +17,20 @@ package com.android.server.appsearch;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.app.appsearch.testutil.FakeAppSearchConfig;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.icing.proto.GetOptimizeInfoResultProto;
 import com.android.server.appsearch.icing.proto.StatusProto;
 
+import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
+
+import java.util.concurrent.TimeUnit;
 
 // NOTE: The tests in this class are based on the underlying assumption that
 // time_optimize_threshold > min_time_optimize_threshold. This ensures that setting
@@ -33,6 +41,7 @@ public class ServiceOptimizeStrategyTest {
     ServiceAppSearchConfig mAppSearchConfig = new FakeAppSearchConfig();
     ServiceOptimizeStrategy mServiceOptimizeStrategy =
             new ServiceOptimizeStrategy(mAppSearchConfig);
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
 
     @Test
     public void testTimeOptimizeThreshold_isGreaterThan_minTimeOptimizeThreshold() {
@@ -112,4 +121,22 @@ public class ServiceOptimizeStrategyTest {
                         .build();
         assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isFalse();
     }
+
+    // TODO (b/385020106): figure out how to make the default 0 timeSinceLastOptimize work
+    //  with a higher threshold and return 4 hours when
+    //  Flags.enable_four_hour_min_optimize_threshold is true and reenable
+    @Ignore
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_FOUR_HOUR_MIN_TIME_OPTIMIZE_THRESHOLD)
+    public void testShouldNotOptimize_underFourHourMinTimeThreshold() {
+        GetOptimizeInfoResultProto optimizeInfo =
+                GetOptimizeInfoResultProto.newBuilder()
+                        .setTimeSinceLastOptimizeMs(TimeUnit.HOURS.toMillis(4) - 1)
+                        .setEstimatedOptimizableBytes(
+                                mAppSearchConfig.getCachedBytesOptimizeThreshold())
+                        .setOptimizableDocs(mAppSearchConfig.getCachedDocCountOptimizeThreshold())
+                        .setStatus(StatusProto.newBuilder().setCode(StatusProto.Code.OK).build())
+                        .build();
+        assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isFalse();
+    }
 }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java
index ce300c53..2c89d3e5 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java
@@ -36,7 +36,7 @@ import static com.google.common.truth.Truth.assertThat;
 
 import static org.junit.Assert.assertThrows;
 
-import android.annotation.NonNull;
+import android.app.appsearch.AppSearchBatchResult;
 import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
@@ -77,6 +77,10 @@ import com.android.server.appsearch.appsearch.proto.PackageIdentifierProto;
 import com.android.server.appsearch.appsearch.proto.VisibilityConfigProto;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
+import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
+import com.android.server.appsearch.external.localstorage.stats.RemoveStats;
+import com.android.server.appsearch.external.localstorage.stats.SearchStats;
+import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 import com.android.server.appsearch.external.localstorage.visibilitystore.CallerAccess;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityChecker;
@@ -86,6 +90,8 @@ import com.android.server.appsearch.icing.proto.DebugInfoProto;
 import com.android.server.appsearch.icing.proto.DebugInfoVerbosity;
 import com.android.server.appsearch.icing.proto.DocumentProto;
 import com.android.server.appsearch.icing.proto.GetOptimizeInfoResultProto;
+import com.android.server.appsearch.icing.proto.GetSchemaResultProto;
+import com.android.server.appsearch.icing.proto.IcingSearchEngineOptions;
 import com.android.server.appsearch.icing.proto.PersistType;
 import com.android.server.appsearch.icing.proto.PropertyConfigProto;
 import com.android.server.appsearch.icing.proto.PropertyProto;
@@ -98,11 +104,14 @@ import com.android.server.appsearch.icing.proto.StringIndexingConfig;
 import com.android.server.appsearch.icing.proto.TermMatchType;
 import com.android.server.appsearch.protobuf.ByteString;
 
+import com.google.android.icing.IcingSearchEngine;
+import com.google.android.icing.IcingSearchEngineInterface;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.MoreExecutors;
 
+import org.jspecify.annotations.NonNull;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -112,16 +121,18 @@ import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
 
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-@SuppressWarnings("GuardedBy")
+@SuppressWarnings({"GuardedBy", "deprecation"})
 public class AppSearchImplTest {
     /**
      * Always trigger optimize in this class. OptimizeStrategy will be tested in its own test class.
@@ -153,6 +164,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
     }
 
@@ -623,6 +635,7 @@ public class AppSearchImplTest {
                         initStatsBuilder,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Check recovery state
@@ -699,6 +712,152 @@ public class AppSearchImplTest {
         assertThat(searchResultPage.getResults()).isEmpty();
     }
 
+    @Test
+    public void testBatchPut_emptyList_noDocInserted() throws Exception {
+        // Insert package1 schema
+        List<AppSearchSchema> schema1 =
+                ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schema1,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert no documents
+        List<GenericDocument> documents = new ArrayList<>();
+
+        AppSearchBatchResult.Builder<String, Void> resultBuilder =
+                new AppSearchBatchResult.Builder<>();
+        mAppSearchImpl.batchPutDocuments(
+                "package1",
+                "database1",
+                documents,
+                resultBuilder,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null,
+                PersistType.Code.LITE);
+
+        assertThat(resultBuilder.build().getAll()).isEmpty();
+        SearchSpec searchSpec =
+                new SearchSpec.Builder().setTermMatch(TermMatchType.Code.PREFIX_VALUE).build();
+        SearchResultPage searchResultPage =
+                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
+
+        assertThat(searchResultPage.getResults()).isEmpty();
+    }
+
+    @Test
+    public void testBatchPut_docsInsertedCorrectly() throws Exception {
+        // Insert package1 schema
+        List<AppSearchSchema> schema1 =
+                ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schema1,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert three package1 documents
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace", "id1", "schema1").build();
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "schema1").build();
+        GenericDocument document3 =
+                new GenericDocument.Builder<>("namespace", "id3", "schema1").build();
+        List<GenericDocument> documents = Arrays.asList(document1, document2, document3);
+
+        AppSearchBatchResult.Builder<String, Void> batchResultBuilder =
+                new AppSearchBatchResult.Builder<>();
+        mAppSearchImpl.batchPutDocuments(
+                "package1",
+                "database1",
+                documents,
+                batchResultBuilder,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null,
+                PersistType.Code.LITE);
+        AppSearchBatchResult<String, Void> batchResult = batchResultBuilder.build();
+
+        // Check batchResult
+        assertThat(batchResult.getSuccesses())
+                .containsExactly("id1", null, "id2", null, "id3", null)
+                .inOrder();
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder().setTermMatch(TermMatchType.Code.PREFIX_VALUE).build();
+        SearchResultPage searchResultPage =
+                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
+
+        assertThat(searchResultPage.getResults()).hasSize(3);
+        assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document3);
+        assertThat(searchResultPage.getResults().get(1).getGenericDocument()).isEqualTo(document2);
+        assertThat(searchResultPage.getResults().get(2).getGenericDocument()).isEqualTo(document1);
+    }
+
+    @Test
+    public void testBatchPut_docsInsertedCorrectly_withoutPersistToDisk() throws Exception {
+        // Insert package1 schema
+        List<AppSearchSchema> schema1 =
+                ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schema1,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert three package1 documents
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace", "id1", "schema1").build();
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "schema1").build();
+        GenericDocument document3 =
+                new GenericDocument.Builder<>("namespace", "id3", "schema1").build();
+        List<GenericDocument> documents = Arrays.asList(document1, document2, document3);
+
+        AppSearchBatchResult.Builder<String, Void> batchResultBuilder =
+                new AppSearchBatchResult.Builder<>();
+        mAppSearchImpl.batchPutDocuments(
+                "package1",
+                "database1",
+                documents,
+                batchResultBuilder,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null,
+                // Specify UNKNOWN PersistType to indicate not to call persistToDisk at the end.
+                PersistType.Code.UNKNOWN);
+        AppSearchBatchResult<String, Void> batchResult = batchResultBuilder.build();
+
+        // Check batchResult
+        assertThat(batchResult.getSuccesses())
+                .containsExactly("id1", null, "id2", null, "id3", null)
+                .inOrder();
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder().setTermMatch(TermMatchType.Code.PREFIX_VALUE).build();
+        SearchResultPage searchResultPage =
+                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
+
+        assertThat(searchResultPage.getResults()).hasSize(3);
+        assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document3);
+        assertThat(searchResultPage.getResults().get(1).getGenericDocument()).isEqualTo(document2);
+        assertThat(searchResultPage.getResults().get(2).getGenericDocument()).isEqualTo(document1);
+    }
+
     /**
      * TODO(b/169883602): This should be an integration test at the cts-level. This is a short-term
      * test until we have official support for multiple-apps indexing at once.
@@ -870,6 +1029,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert package1 schema
@@ -1052,6 +1212,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         AppSearchSchema.StringPropertyConfig personField =
@@ -2556,6 +2717,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
         byte[] digest = calculateDigest(data);
@@ -2579,6 +2741,45 @@ public class AppSearchImplTest {
         assertThat(readBytes).isEqualTo(data);
     }
 
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testWriteAfterCommit_notAllowed() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+        // Open a pfd for write, write the blob data without close the pfd.
+        ParcelFileDescriptor writePfd = mAppSearchImpl.openWriteBlob("package", "db1", handle);
+        try (FileOutputStream outputStream = new FileOutputStream(writePfd.getFileDescriptor())) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+
+        // Commit the blob.
+        mAppSearchImpl.commitBlob("package", "db1", handle);
+
+        // Keep writing to the pfd for write.
+        assertThrows(
+                IOException.class,
+                () -> {
+                    try (FileOutputStream outputStream =
+                            new FileOutputStream(writePfd.getFileDescriptor())) {
+                        outputStream.write(data);
+                        outputStream.flush();
+                    }
+                });
+    }
+
     @Test
     @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
     public void testRemovePendingBlob() throws Exception {
@@ -2590,6 +2791,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
         byte[] digest = calculateDigest(data);
@@ -2628,6 +2830,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
         byte[] digest = calculateDigest(data);
@@ -2664,6 +2867,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
         byte[] wrongData = generateRandomBytes(10 * 1024); // 10 KiB
@@ -2712,6 +2916,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         byte[] data = generateRandomBytes(20); // 20 Bytes
         byte[] digest = calculateDigest(data);
@@ -2752,6 +2957,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         byte[] data = generateRandomBytes(20); // 20 Bytes
         byte[] digest = calculateDigest(data);
@@ -2765,6 +2971,70 @@ public class AppSearchImplTest {
         }
     }
 
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testOpenMultipleBlobForWrite() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20); // 20 Bytes
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+
+        // only allow open 1 fd for writing.
+        try (ParcelFileDescriptor writePfd1 =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle);
+                ParcelFileDescriptor writePfd2 =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle)) {
+            assertThat(writePfd1).isEqualTo(writePfd2);
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testOpenMultipleBlobForRead() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20); // 20 Bytes
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+
+        // write a blob first.
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+        // commit the change and read the blob.
+        mAppSearchImpl.commitBlob("package", "db1", handle);
+
+        // allow open multiple fd for reading.
+        try (ParcelFileDescriptor readPfd1 = mAppSearchImpl.openReadBlob("package", "db1", handle);
+                ParcelFileDescriptor readPfd2 =
+                        mAppSearchImpl.openReadBlob("package", "db1", handle)) {
+            assertThat(readPfd1).isNotEqualTo(readPfd2);
+        }
+    }
+
     @Test
     @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
     public void testOptimizeBlob() throws Exception {
@@ -2786,6 +3056,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Write the blob and commit it.
@@ -2836,6 +3107,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Write the blob and commit it.
@@ -2917,6 +3189,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
         byte[] digest = calculateDigest(data);
@@ -2969,6 +3242,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
         byte[] digest = calculateDigest(data);
@@ -3007,6 +3281,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         SchemaVisibilityConfig visibleToConfig =
@@ -3068,6 +3343,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         SchemaVisibilityConfig visibleToConfig =
@@ -3107,6 +3383,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         SchemaVisibilityConfig visibleToConfig1 =
@@ -3268,6 +3545,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
@@ -3300,6 +3578,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Set mock visibility setting.
@@ -3366,6 +3645,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Set mock visibility setting.
@@ -3708,6 +3988,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         // Insert schema
         List<AppSearchSchema> schemas1 =
@@ -3914,16 +4195,18 @@ public class AppSearchImplTest {
     }
 
     @Test
-    public void testGetStorageInfoForPackage_nonexistentPackage() throws Exception {
+    public void testGetStorageInfoForPackages_nonexistentPackage() throws Exception {
         // "package2" doesn't exist yet, so it shouldn't have any storage size
-        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForPackage("nonexistent.package");
+        StorageInfo storageInfo =
+                mAppSearchImpl.getStorageInfoForPackages(
+                        new ArraySet<>(Collections.singleton("nonexistent.package")));
         assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
         assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
         assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
     }
 
     @Test
-    public void testGetStorageInfoForPackage_withoutDocument() throws Exception {
+    public void testGetStorageInfoForPackages_withoutDocument() throws Exception {
         // Insert schema for "package1"
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
@@ -3939,14 +4222,16 @@ public class AppSearchImplTest {
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
         // Since "package1" doesn't have a document, it get any space attributed to it.
-        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForPackage("package1");
+        StorageInfo storageInfo =
+                mAppSearchImpl.getStorageInfoForPackages(
+                        new ArraySet<>(Collections.singleton("package1")));
         assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
         assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
         assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
     }
 
     @Test
-    public void testGetStorageInfoForPackage_proportionalToDocuments() throws Exception {
+    public void testGetStorageInfoForPackages_proportionalToDocuments() throws Exception {
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
 
@@ -4000,13 +4285,17 @@ public class AppSearchImplTest {
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForPackage("package1");
+        StorageInfo storageInfo =
+                mAppSearchImpl.getStorageInfoForPackages(
+                        new ArraySet<>(Collections.singleton("package1")));
         long size1 = storageInfo.getSizeBytes();
         assertThat(size1).isGreaterThan(0);
         assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(1);
         assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(1);
 
-        storageInfo = mAppSearchImpl.getStorageInfoForPackage("package2");
+        storageInfo =
+                mAppSearchImpl.getStorageInfoForPackages(
+                        new ArraySet<>(Collections.singleton("package2")));
         long size2 = storageInfo.getSizeBytes();
         assertThat(size2).isGreaterThan(0);
         assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(2);
@@ -4146,7 +4435,7 @@ public class AppSearchImplTest {
 
     @Test
     @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
-    public void testGetStorageInfoForPackage_withBlob() throws Exception {
+    public void testGetStorageInfoForPackages_withBlob() throws Exception {
         mAppSearchImpl =
                 AppSearchImpl.create(
                         mAppSearchDir,
@@ -4155,6 +4444,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         byte[] data1 = generateRandomBytes(5 * 1024); // 5 KiB
@@ -4190,12 +4480,16 @@ public class AppSearchImplTest {
             outputStream.flush();
         }
 
-        StorageInfo storageInfo1 = mAppSearchImpl.getStorageInfoForPackage("package1");
-        assertThat(storageInfo1.getBlobSizeBytes()).isEqualTo(15 * 1024);
-        assertThat(storageInfo1.getBlobCount()).isEqualTo(2);
-        StorageInfo storageInfo2 = mAppSearchImpl.getStorageInfoForPackage("package2");
-        assertThat(storageInfo2.getBlobSizeBytes()).isEqualTo(20 * 1024);
-        assertThat(storageInfo2.getBlobCount()).isEqualTo(1);
+        StorageInfo storageInfo1 =
+                mAppSearchImpl.getStorageInfoForPackages(
+                        new ArraySet<>(Collections.singleton("package1")));
+        assertThat(storageInfo1.getBlobsSizeBytes()).isEqualTo(15 * 1024);
+        assertThat(storageInfo1.getBlobsCount()).isEqualTo(2);
+        StorageInfo storageInfo2 =
+                mAppSearchImpl.getStorageInfoForPackages(
+                        new ArraySet<>(Collections.singleton("package2")));
+        assertThat(storageInfo2.getBlobsSizeBytes()).isEqualTo(20 * 1024);
+        assertThat(storageInfo2.getBlobsCount()).isEqualTo(1);
     }
 
     @Test
@@ -4209,6 +4503,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         byte[] data1 = generateRandomBytes(5 * 1024); // 5 KiB
         byte[] digest1 = calculateDigest(data1);
@@ -4244,11 +4539,11 @@ public class AppSearchImplTest {
         }
 
         StorageInfo storageInfo1 = mAppSearchImpl.getStorageInfoForDatabase("package", "db1");
-        assertThat(storageInfo1.getBlobSizeBytes()).isEqualTo(15 * 1024);
-        assertThat(storageInfo1.getBlobCount()).isEqualTo(2);
+        assertThat(storageInfo1.getBlobsSizeBytes()).isEqualTo(15 * 1024);
+        assertThat(storageInfo1.getBlobsCount()).isEqualTo(2);
         StorageInfo storageInfo2 = mAppSearchImpl.getStorageInfoForDatabase("package", "db2");
-        assertThat(storageInfo2.getBlobSizeBytes()).isEqualTo(20 * 1024);
-        assertThat(storageInfo2.getBlobCount()).isEqualTo(1);
+        assertThat(storageInfo2.getBlobsSizeBytes()).isEqualTo(20 * 1024);
+        assertThat(storageInfo2.getBlobsCount()).isEqualTo(1);
     }
 
     @Test
@@ -4368,7 +4663,9 @@ public class AppSearchImplTest {
 
         assertThrows(
                 IllegalStateException.class,
-                () -> mAppSearchImpl.getStorageInfoForPackage("package"));
+                () ->
+                        mAppSearchImpl.getStorageInfoForPackages(
+                                new ArraySet<>(Collections.singleton("package"))));
 
         assertThrows(
                 IllegalStateException.class,
@@ -4410,16 +4707,288 @@ public class AppSearchImplTest {
                         "package", "database", "namespace1", "id1", Collections.emptyMap());
         assertThat(getResult).isEqualTo(document);
 
+        // Initialize a new instance of AppSearch to test initialization.
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        AppSearchImpl appSearchImpl2 =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Initialization should trigger a recovery
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats.getDocumentStoreRecoveryCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
+        assertThat(initStats.getIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
+
         // That document should be visible even from another instance.
+        getResult =
+                appSearchImpl2.getDocument(
+                        "package", "database", "namespace1", "id1", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document);
+        appSearchImpl2.close();
+    }
+
+    @Test
+    public void testDeletePersistsWithLiteFlush() throws Exception {
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Add two documents and persist them.
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document1,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace1", "id2", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document2,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+
+        GenericDocument getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id1", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document1);
+        getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
+
+        // Delete the first document
+        mAppSearchImpl.remove("package", "database", "namespace1", "id1", /* statsBuilder= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        mAppSearchImpl.getDocument(
+                                "package",
+                                "database",
+                                "namespace1",
+                                "id1",
+                                Collections.emptyMap()));
+        getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
+
+        // Initialize a new instance of AppSearch to test initialization.
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        AppSearchImpl appSearchImpl2 =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Initialization should trigger a recovery
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats.getDocumentStoreRecoveryCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
+        assertThat(initStats.getIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
+
+        // Only the second document should be retrievable from another instance.
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        appSearchImpl2.getDocument(
+                                "package",
+                                "database",
+                                "namespace1",
+                                "id1",
+                                Collections.emptyMap()));
+        getResult =
+                appSearchImpl2.getDocument(
+                        "package", "database", "namespace1", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
+        appSearchImpl2.close();
+    }
+
+    @Test
+    public void testDeleteByQueryPersistsWithLiteFlush() throws Exception {
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Add two documents and persist them.
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document1,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace2", "id2", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document2,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+
+        GenericDocument getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id1", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document1);
+        getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace2", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
+
+        // Delete the first document
+        mAppSearchImpl.removeByQuery(
+                "package",
+                "database",
+                "",
+                new SearchSpec.Builder()
+                        .addFilterNamespaces("namespace1")
+                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                        .build(),
+                /* statsBuilder= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        mAppSearchImpl.getDocument(
+                                "package",
+                                "database",
+                                "namespace1",
+                                "id1",
+                                Collections.emptyMap()));
+        getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace2", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
+
+        // Initialize a new instance of AppSearch to test initialization.
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        AppSearchImpl appSearchImpl2 =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Initialization should trigger a recovery
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats.getDocumentStoreRecoveryCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
+        assertThat(initStats.getIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
+
+        // Only the second document should be retrievable from another instance.
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        appSearchImpl2.getDocument(
+                                "package",
+                                "database",
+                                "namespace1",
+                                "id1",
+                                Collections.emptyMap()));
+        getResult =
+                appSearchImpl2.getDocument(
+                        "package", "database", "namespace2", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
+        appSearchImpl2.close();
+    }
+
+    @Test
+    public void testPutPersistsWithoutRecoveryWithRecoveryProofFlush() throws Exception {
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Add a document and persist it.
+        GenericDocument document =
+                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.RECOVERY_PROOF);
+
+        GenericDocument getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id1", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document);
+
+        // Initialize a new instance of AppSearch to test initialization.
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
         AppSearchImpl appSearchImpl2 =
                 AppSearchImpl.create(
                         mAppSearchDir,
                         new AppSearchConfigImpl(
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
-                        /* initStatsBuilder= */ null,
+                        /* initStatsBuilder= */ initStatsBuilder,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
+
+        // Initialization should NOT trigger a recovery
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats.getDocumentStoreRecoveryCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(initStats.getIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+
+        // That document should be visible even from another instance.
         getResult =
                 appSearchImpl2.getDocument(
                         "package", "database", "namespace1", "id1", Collections.emptyMap());
@@ -4428,7 +4997,7 @@ public class AppSearchImplTest {
     }
 
     @Test
-    public void testDeletePersistsWithLiteFlush() throws Exception {
+    public void testDeletePersistsWithoutRecoveryWithRecoveryProofFlush() throws Exception {
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -4459,7 +5028,7 @@ public class AppSearchImplTest {
                 document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+        mAppSearchImpl.persistToDisk(PersistType.Code.RECOVERY_PROOF);
 
         GenericDocument getResult =
                 mAppSearchImpl.getDocument(
@@ -4472,7 +5041,7 @@ public class AppSearchImplTest {
 
         // Delete the first document
         mAppSearchImpl.remove("package", "database", "namespace1", "id1", /* statsBuilder= */ null);
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+        mAppSearchImpl.persistToDisk(PersistType.Code.RECOVERY_PROOF);
         assertThrows(
                 AppSearchException.class,
                 () ->
@@ -4487,16 +5056,27 @@ public class AppSearchImplTest {
                         "package", "database", "namespace1", "id2", Collections.emptyMap());
         assertThat(getResult).isEqualTo(document2);
 
-        // Only the second document should be retrievable from another instance.
+        // Initialize a new instance of AppSearch to test initialization.
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
         AppSearchImpl appSearchImpl2 =
                 AppSearchImpl.create(
                         mAppSearchDir,
                         new AppSearchConfigImpl(
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
-                        /* initStatsBuilder= */ null,
+                        /* initStatsBuilder= */ initStatsBuilder,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
+
+        // Initialization should NOT trigger a recovery.
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats.getDocumentStoreRecoveryCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(initStats.getIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+
+        // Only the second document should be retrievable from another instance.
         assertThrows(
                 AppSearchException.class,
                 () ->
@@ -4514,7 +5094,7 @@ public class AppSearchImplTest {
     }
 
     @Test
-    public void testDeleteByQueryPersistsWithLiteFlush() throws Exception {
+    public void testDeleteByQueryPersistsWithoutRecoveryWithRecoveryProofFlush() throws Exception {
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -4545,7 +5125,7 @@ public class AppSearchImplTest {
                 document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+        mAppSearchImpl.persistToDisk(PersistType.Code.RECOVERY_PROOF);
 
         GenericDocument getResult =
                 mAppSearchImpl.getDocument(
@@ -4566,7 +5146,7 @@ public class AppSearchImplTest {
                         .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
                         .build(),
                 /* statsBuilder= */ null);
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+        mAppSearchImpl.persistToDisk(PersistType.Code.RECOVERY_PROOF);
         assertThrows(
                 AppSearchException.class,
                 () ->
@@ -4581,16 +5161,27 @@ public class AppSearchImplTest {
                         "package", "database", "namespace2", "id2", Collections.emptyMap());
         assertThat(getResult).isEqualTo(document2);
 
-        // Only the second document should be retrievable from another instance.
+        // Initialize a new instance of AppSearch to test initialization.
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
         AppSearchImpl appSearchImpl2 =
                 AppSearchImpl.create(
                         mAppSearchDir,
                         new AppSearchConfigImpl(
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
-                        /* initStatsBuilder= */ null,
+                        /* initStatsBuilder= */ initStatsBuilder,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
+
+        // Initialization should NOT trigger a recovery.
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats.getDocumentStoreRecoveryCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(initStats.getIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+
+        // Only the second document should be retrievable from another instance.
         assertThrows(
                 AppSearchException.class,
                 () ->
@@ -4662,6 +5253,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
@@ -4761,6 +5353,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
@@ -4805,6 +5398,193 @@ public class AppSearchImplTest {
         assertThat(debugInfo.getSchemaInfo().getSchema().getTypesList()).hasSize(7);
     }
 
+    @Test
+    public void testStatsIsLaunchVM() throws Exception {
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        IcingSearchEngineOptions options =
+                mUnlimitedConfig.toIcingSearchEngineOptions(mAppSearchDir.getAbsolutePath());
+        IcingSearchEngine icingSearchEngine = new IcingSearchEngine(options);
+        // the bit mask for only enable launch VM feature.
+        int onlyLaunchVMFeature = 1;
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        mUnlimitedConfig,
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        icingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Initialization and check initStats
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats.getEnabledFeatures()).isEqualTo(onlyLaunchVMFeature);
+
+        // Set a schema and check SetSchemaStats
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        SetSchemaStats.Builder setSchemaStatsBuilder =
+                new SetSchemaStats.Builder("package", "database");
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        setSchemaStatsBuilder);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        SetSchemaStats setSchemaStats = setSchemaStatsBuilder.build();
+        assertThat(setSchemaStats.getEnabledFeatures()).isEqualTo(onlyLaunchVMFeature);
+
+        // Add documents and test putDocumentStats.
+        AppSearchLogger fakeLogger =
+                new AppSearchLogger() {
+                    @Override
+                    public void logStats(@NonNull PutDocumentStats stats) {
+                        assertThat(stats.getEnabledFeatures()).isEqualTo(onlyLaunchVMFeature);
+                    }
+
+                    @Override
+                    public void logStats(@NonNull SearchStats stats) {
+                        assertThat(stats.getEnabledFeatures()).isEqualTo(onlyLaunchVMFeature);
+                    }
+                };
+        GenericDocument document =
+                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package", "database", document, /* sendChangeNotifications= */ false, fakeLogger);
+
+        List<GenericDocument> documents = new ArrayList<>();
+        documents.add(document);
+        AppSearchBatchResult.Builder<String, Void> resultBuilder =
+                new AppSearchBatchResult.Builder<>();
+        mAppSearchImpl.batchPutDocuments(
+                "package1",
+                "database1",
+                documents,
+                resultBuilder,
+                /* sendChangeNotifications= */ false,
+                fakeLogger,
+                PersistType.Code.LITE);
+
+        mAppSearchImpl.query(
+                "package", "database", "", new SearchSpec.Builder().build(), fakeLogger);
+
+        // Delete the document and check remove stats
+        RemoveStats.Builder removeStatsBuilder = new RemoveStats.Builder("package", "database");
+        mAppSearchImpl.removeByQuery(
+                "package",
+                "database",
+                "",
+                new SearchSpec.Builder()
+                        .addFilterNamespaces("namespace1")
+                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                        .build(),
+                removeStatsBuilder);
+        RemoveStats removeStats = removeStatsBuilder.build();
+        assertThat(removeStats.getEnabledFeatures()).isEqualTo(onlyLaunchVMFeature);
+
+        // Trigger optimize and check optimize stats
+        OptimizeStats.Builder optimizeStatsBuilder = new OptimizeStats.Builder();
+        mAppSearchImpl.optimize(optimizeStatsBuilder);
+        OptimizeStats optimizeStats = optimizeStatsBuilder.build();
+        assertThat(optimizeStats.getEnabledFeatures()).isEqualTo(onlyLaunchVMFeature);
+    }
+
+    @Test
+    public void testStatsIsNotLaunchVM() throws Exception {
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        // the bit mask for nothing enabled feature.
+        int noLaunchFeature = 0;
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        mUnlimitedConfig,
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Initialization and check initStats
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats.getEnabledFeatures()).isEqualTo(noLaunchFeature);
+
+        // Set a schema and check SetSchemaStats
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        SetSchemaStats.Builder setSchemaStatsBuilder =
+                new SetSchemaStats.Builder("package", "database");
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        setSchemaStatsBuilder);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        SetSchemaStats setSchemaStats = setSchemaStatsBuilder.build();
+        assertThat(setSchemaStats.getEnabledFeatures()).isEqualTo(noLaunchFeature);
+
+        // Add documents and test putDocumentStats.
+        AppSearchLogger fakeLogger =
+                new AppSearchLogger() {
+                    @Override
+                    public void logStats(@NonNull PutDocumentStats stats) {
+                        assertThat(stats.getEnabledFeatures()).isEqualTo(noLaunchFeature);
+                    }
+
+                    @Override
+                    public void logStats(@NonNull SearchStats stats) {
+                        assertThat(stats.getEnabledFeatures()).isEqualTo(noLaunchFeature);
+                    }
+                };
+        GenericDocument document =
+                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package", "database", document, /* sendChangeNotifications= */ false, fakeLogger);
+
+        List<GenericDocument> documents = new ArrayList<>();
+        documents.add(document);
+        AppSearchBatchResult.Builder<String, Void> resultBuilder =
+                new AppSearchBatchResult.Builder<>();
+        mAppSearchImpl.batchPutDocuments(
+                "package1",
+                "database1",
+                documents,
+                resultBuilder,
+                /* sendChangeNotifications= */ false,
+                fakeLogger,
+                PersistType.Code.LITE);
+
+        mAppSearchImpl.query(
+                "package", "database", "", new SearchSpec.Builder().build(), fakeLogger);
+
+        // Delete the document and check remove stats
+        RemoveStats.Builder removeStatsBuilder = new RemoveStats.Builder("package", "database");
+        mAppSearchImpl.removeByQuery(
+                "package",
+                "database",
+                "",
+                new SearchSpec.Builder()
+                        .addFilterNamespaces("namespace1")
+                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                        .build(),
+                removeStatsBuilder);
+        RemoveStats removeStats = removeStatsBuilder.build();
+        assertThat(removeStats.getEnabledFeatures()).isEqualTo(noLaunchFeature);
+
+        // Trigger optimize and check optimize stats
+        OptimizeStats.Builder optimizeStatsBuilder = new OptimizeStats.Builder();
+        mAppSearchImpl.optimize(optimizeStatsBuilder);
+        OptimizeStats optimizeStats = optimizeStatsBuilder.build();
+        assertThat(optimizeStats.getEnabledFeatures()).isEqualTo(noLaunchFeature);
+    }
+
     @Test
     public void testLimitConfig_DocumentSize() throws Exception {
         // Create a new mAppSearchImpl with a lower limit
@@ -4838,11 +5618,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -4945,11 +5731,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -5023,11 +5815,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Make sure the limit is maintained
@@ -5080,11 +5878,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -5230,11 +6034,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -5351,11 +6161,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // package1 should still be out of space
@@ -5434,11 +6250,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -5626,11 +6448,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -5732,11 +6560,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -5808,11 +6642,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Index id2. This should pass but only because we check for replacements.
@@ -5875,11 +6715,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         AppSearchException e =
@@ -5932,11 +6778,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -6007,11 +6859,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schemas for thress packages
@@ -6154,11 +7012,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -6246,11 +7110,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -6396,11 +7266,17 @@ public class AppSearchImplTest {
                                     public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxByteLimitForBatchPut() {
+                                        return getMaxDocumentSizeBytes();
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -6568,6 +7444,11 @@ public class AppSearchImplTest {
                             public int getMaxOpenBlobCount() {
                                 return 2;
                             }
+
+                            @Override
+                            public int getMaxByteLimitForBatchPut() {
+                                return getMaxDocumentSizeBytes();
+                            }
                         },
                         new LocalStorageIcingOptionsConfig());
         mAppSearchImpl =
@@ -6577,6 +7458,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(config),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         // We could open only 2 fds per package.
         byte[] data1 = generateRandomBytes(20 * 1024); // 20 KiB
@@ -6640,6 +7522,11 @@ public class AppSearchImplTest {
                             public int getMaxOpenBlobCount() {
                                 return 2;
                             }
+
+                            @Override
+                            public int getMaxByteLimitForBatchPut() {
+                                return getMaxDocumentSizeBytes();
+                            }
                         },
                         new LocalStorageIcingOptionsConfig());
         mAppSearchImpl =
@@ -6649,6 +7536,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(config),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Write and commit one blob
@@ -6686,6 +7574,27 @@ public class AppSearchImplTest {
                                 + "\" exceeded limit of 2 opened file descriptors. Some file"
                                 + " descriptors must be closed to open additional ones.");
 
+        // Open new fd for write will also fail since read and write share the same limit.
+        byte[] data2 = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest2 = calculateDigest(data2);
+        AppSearchBlobHandle handle2 =
+                AppSearchBlobHandle.createWithSha256(
+                        digest2, mContext.getPackageName(), "db1", "ns");
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.openWriteBlob(
+                                        mContext.getPackageName(), "db1", handle2));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains(
+                        "Package \""
+                                + mContext.getPackageName()
+                                + "\" exceeded limit of 2 opened file descriptors. Some file"
+                                + " descriptors must be closed to open additional ones.");
+
         // Close 1st fd and open 3rd fd will success
         reader1.close();
         ParcelFileDescriptor reader3 =
@@ -6834,6 +7743,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -6890,6 +7800,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -6942,6 +7853,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -7013,6 +7925,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -7399,6 +8312,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         String prefix = PrefixUtil.createPrefix("packageName", "databaseName");
@@ -7444,6 +8358,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix + "Email"))
@@ -7481,6 +8396,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema type that is not displayed by the system
@@ -7603,6 +8519,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add two schema types that are not displayed by the system.
@@ -7689,6 +8606,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         publicAclMockChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         List<InternalVisibilityConfig> visibilityConfigs =
@@ -7795,6 +8713,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         publicAclMockChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         List<InternalVisibilityConfig> visibilityConfigs =
@@ -8003,6 +8922,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         rejectChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema type
@@ -8122,6 +9042,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema type
@@ -8185,6 +9106,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         rejectChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema type
@@ -8559,6 +9481,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Register an observer
@@ -8746,6 +9669,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema.
@@ -8859,6 +9783,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema.
@@ -8967,6 +9892,7 @@ public class AppSearchImplTest {
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema.
@@ -9156,4 +10082,69 @@ public class AppSearchImplTest {
                                 ImmutableSet.of("Type1", "Type2")));
         assertThat(observer.getDocumentChanges()).isEmpty();
     }
+
+    @Test
+    public void testProvideIcingInstance_setSchema() throws Exception {
+        SchemaTypeConfigProto additionalConfigProto =
+                SchemaTypeConfigProto.newBuilder()
+                        .setSchemaType("nopackage$nodatabase/notype")
+                        .setDescription("From modified icing instance")
+                        .setVersion(0)
+                        .build();
+        IcingSearchEngineInterface modifiedIcingInstance =
+                new IcingSearchEngine(
+                        mUnlimitedConfig.toIcingSearchEngineOptions(
+                                mAppSearchDir.getAbsolutePath())) {
+                    @Override
+                    public GetSchemaResultProto getSchema() {
+                        GetSchemaResultProto.Builder resultBuilder = super.getSchema().toBuilder();
+                        resultBuilder.setSchema(
+                                resultBuilder.getSchema().toBuilder()
+                                        .addTypes(additionalConfigProto));
+                        return resultBuilder.build();
+                    }
+                };
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        mUnlimitedConfig,
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        modifiedIcingInstance,
+                        ALWAYS_OPTIMIZE);
+        List<SchemaTypeConfigProto> existingSchemas =
+                mAppSearchImpl.getSchemaProtoLocked().getTypesList();
+
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("Email").build());
+        // Set schema Email to AppSearch database1
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database1",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Create expected schemaType proto.
+        SchemaProto expectedProto =
+                SchemaProto.newBuilder()
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("package$database1/Email")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .addTypes(additionalConfigProto)
+                        .build();
+
+        List<SchemaTypeConfigProto> expectedTypes = new ArrayList<>();
+        expectedTypes.addAll(existingSchemas);
+        expectedTypes.addAll(expectedProto.getTypesList());
+        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
+                .containsExactlyElementsIn(expectedTypes);
+    }
 }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java
index a1b672ad..7d741ada 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java
@@ -93,6 +93,7 @@ public class AppSearchLoggerTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         mLogger = new SimpleTestLogger();
     }
@@ -391,6 +392,7 @@ public class AppSearchLoggerTest {
                         initStatsBuilder,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         InitializeStats iStats = initStatsBuilder.build();
         appSearchImpl.close();
@@ -412,6 +414,7 @@ public class AppSearchLoggerTest {
 
     @Test
     @RequiresFlagsDisabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testLoggingStats_initializeWithDocuments_success() throws Exception {
         final String testPackageName = "testPackage";
         final String testDatabase = "testDatabase";
@@ -424,6 +427,7 @@ public class AppSearchLoggerTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         List<AppSearchSchema> schemas =
                 ImmutableList.of(
@@ -456,6 +460,7 @@ public class AppSearchLoggerTest {
                         initStatsBuilder,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         InitializeStats iStats = initStatsBuilder.build();
 
@@ -478,6 +483,7 @@ public class AppSearchLoggerTest {
 
     @Test
     @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testLoggingStats_enableBlobStore_initializeWithDocuments_success()
             throws Exception {
         final String testPackageName = "testPackage";
@@ -491,6 +497,7 @@ public class AppSearchLoggerTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         new JetpackRevocableFileDescriptorStore(mConfig),
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         List<AppSearchSchema> schemas =
@@ -524,6 +531,7 @@ public class AppSearchLoggerTest {
                         initStatsBuilder,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         InitializeStats iStats = initStatsBuilder.build();
 
@@ -546,6 +554,7 @@ public class AppSearchLoggerTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testLoggingStats_initialize_failure() throws Exception {
         final String testPackageName = "testPackage";
         final String testDatabase = "testDatabase";
@@ -558,6 +567,7 @@ public class AppSearchLoggerTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         List<AppSearchSchema> schemas =
@@ -600,6 +610,7 @@ public class AppSearchLoggerTest {
                         initStatsBuilder,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         InitializeStats iStats = initStatsBuilder.build();
 
@@ -611,6 +622,7 @@ public class AppSearchLoggerTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testLoggingStats_putDocument_success() throws Exception {
         // Insert schema
         final String testPackageName = "testPackage";
@@ -664,6 +676,7 @@ public class AppSearchLoggerTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testLoggingStats_putDocument_failure() throws Exception {
         // Insert schema
         final String testPackageName = "testPackage";
@@ -719,6 +732,7 @@ public class AppSearchLoggerTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testLoggingStats_search_success() throws Exception {
         // Insert schema
         final String testPackageName = "testPackage";
@@ -857,6 +871,7 @@ public class AppSearchLoggerTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testLoggingStats_search_join() throws Exception {
         AppSearchSchema actionSchema =
                 new AppSearchSchema.Builder("ViewAction")
@@ -1024,6 +1039,7 @@ public class AppSearchLoggerTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testLoggingStats_remove_success() throws Exception {
         // Insert schema
         final String testPackageName = "testPackage";
@@ -1064,6 +1080,7 @@ public class AppSearchLoggerTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testLoggingStats_remove_failure() throws Exception {
         // Insert schema
         final String testPackageName = "testPackage";
@@ -1116,7 +1133,7 @@ public class AppSearchLoggerTest {
     }
 
     @Test
-    @SuppressWarnings("deprecation") // DEPRECATED_QUERY_VALUE
+    @SuppressWarnings("deprecation") // DEPRECATED_QUERY_VALUE, AppSearchImpl.putDocument
     public void testLoggingStats_removeByQuery_success() throws Exception {
         // Insert schema
         final String testPackageName = "testPackage";
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverterTest.java
index 0bebdb81..14ca3179 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverterTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverterTest.java
@@ -470,7 +470,8 @@ public class GenericDocumentToProtoConverterTest {
                                 new UnlimitedLimitConfig(),
                                 new LocalStorageIcingOptionsConfig(),
                                 /* storeParentInfoAsSyntheticProperty= */ false,
-                                /* shouldRetrieveParentInfo= */ true));
+                                /* shouldRetrieveParentInfo= */ true,
+                                /* persistToDiskRecoveryProof= */ false));
         GenericDocument actualDoc2 =
                 GenericDocumentToProtoConverter.toGenericDocument(
                         documentProto,
@@ -480,7 +481,8 @@ public class GenericDocumentToProtoConverterTest {
                                 new UnlimitedLimitConfig(),
                                 new LocalStorageIcingOptionsConfig(),
                                 /* storeParentInfoAsSyntheticProperty= */ true,
-                                /* shouldRetrieveParentInfo= */ true));
+                                /* shouldRetrieveParentInfo= */ true,
+                                /* persistToDiskRecoveryProof= */ false));
         assertThat(actualDoc1).isEqualTo(expectedDoc);
         assertThat(actualDoc2).isEqualTo(expectedDoc);
     }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverterTest.java
index a82fd93d..4c82be9e 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverterTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverterTest.java
@@ -63,7 +63,8 @@ public class SearchResultToProtoConverterTest {
                         new UnlimitedLimitConfig(),
                         new LocalStorageIcingOptionsConfig(),
                         /* storeParentInfoAsSyntheticProperty= */ false,
-                        /* shouldRetrieveParentInfo= */ true);
+                        /* shouldRetrieveParentInfo= */ true,
+                        /* persistToDiskRecoveryProof= */ false);
 
         // Building the SearchResult received from query.
         DocumentProto.Builder documentProtoBuilder =
@@ -131,6 +132,7 @@ public class SearchResultToProtoConverterTest {
         if (Flags.enableSearchResultParentTypes()) {
             assertThat(result.getParentTypeMap())
                     .isEqualTo(ImmutableMap.of(schemaType, ImmutableList.of(parentSchemaType)));
+
         } else {
             assertThat(result.getParentTypeMap()).isEmpty();
         }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java
index 292f37f1..0bb7a22e 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java
@@ -24,12 +24,15 @@ import static com.android.server.appsearch.external.localstorage.util.PrefixUtil
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assume.assumeTrue;
+
 import android.app.appsearch.JoinSpec;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchConfig;
 import com.android.server.appsearch.external.localstorage.AppSearchConfigImpl;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
@@ -102,6 +105,7 @@ public class SearchSpecToProtoConverterTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
     }
 
@@ -467,6 +471,36 @@ public class SearchSpecToProtoConverterTest {
         assertThat(resultSpecProto.getSnippetSpec().getMaxWindowUtf32Length()).isEqualTo(456);
     }
 
+    @Test
+    public void testToResultSpecProto_withEmbeddingMatchInfo() {
+        assumeTrue(Flags.enableEmbeddingMatchInfo());
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setResultCountPerPage(123)
+                        .setSnippetCount(234)
+                        .setSnippetCountPerProperty(345)
+                        .setMaxSnippetSize(456)
+                        .setRetrieveEmbeddingMatchInfos(true)
+                        .build();
+
+        SearchSpecToProtoConverter convert =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "query",
+                        searchSpec,
+                        /* prefixes= */ ImmutableSet.of(),
+                        new NamespaceCache(ImmutableMap.of()),
+                        new SchemaCache(),
+                        mLocalStorageIcingOptionsConfig);
+        ResultSpecProto resultSpecProto =
+                convert.toResultSpecProto(new NamespaceCache(ImmutableMap.of()), new SchemaCache());
+
+        assertThat(resultSpecProto.getNumPerPage()).isEqualTo(123);
+        assertThat(resultSpecProto.getSnippetSpec().getNumToSnippet()).isEqualTo(234);
+        assertThat(resultSpecProto.getSnippetSpec().getNumMatchesPerProperty()).isEqualTo(345);
+        assertThat(resultSpecProto.getSnippetSpec().getMaxWindowUtf32Length()).isEqualTo(456);
+        assertThat(resultSpecProto.getSnippetSpec().getGetEmbeddingMatchInfo()).isTrue();
+    }
+
     @Test
     public void testToResultSpecProtoWithJoinSpec() throws Exception {
         SearchSpec nestedSearchSpec =
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SnippetTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SnippetTest.java
index 8844dcbe..b77a06f1 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SnippetTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SnippetTest.java
@@ -18,24 +18,30 @@ package com.android.server.appsearch.external.localstorage.converter;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assume.assumeTrue;
+
 import android.app.appsearch.PropertyPath;
 import android.app.appsearch.SearchResult;
 import android.app.appsearch.SearchResultPage;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchConfigImpl;
 import com.android.server.appsearch.external.localstorage.LocalStorageIcingOptionsConfig;
 import com.android.server.appsearch.external.localstorage.SchemaCache;
 import com.android.server.appsearch.external.localstorage.UnlimitedLimitConfig;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 import com.android.server.appsearch.icing.proto.DocumentProto;
+import com.android.server.appsearch.icing.proto.EmbeddingMatchSnippetProto;
 import com.android.server.appsearch.icing.proto.PropertyProto;
 import com.android.server.appsearch.icing.proto.SchemaTypeConfigProto;
 import com.android.server.appsearch.icing.proto.SearchResultProto;
+import com.android.server.appsearch.icing.proto.SearchSpecProto;
 import com.android.server.appsearch.icing.proto.SnippetMatchProto;
 import com.android.server.appsearch.icing.proto.SnippetProto;
 
 import org.junit.Test;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Map;
 
@@ -121,6 +127,213 @@ public class SnippetTest {
         assertThat(match.getSnippetRange())
                 .isEqualTo(new SearchResult.MatchRange(/* lower= */ 26, /* upper= */ 32));
         assertThat(match.getSnippet()).isEqualTo(window);
+
+        if (Flags.enableEmbeddingMatchInfo()) {
+            assertThat(match.getTextMatch()).isNotNull();
+            assertThat(match.getTextMatch().getFullText()).isEqualTo(propertyValueString);
+            assertThat(match.getTextMatch().getExactMatch()).isEqualTo(exactMatch);
+            assertThat(match.getTextMatch().getExactMatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 29, /* upper= */ 32));
+            assertThat(match.getTextMatch().getSubmatch()).isEqualTo("foo");
+            assertThat(match.getTextMatch().getSubmatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 29, /* upper= */ 32));
+            assertThat(match.getTextMatch().getFullText()).isEqualTo(propertyValueString);
+            assertThat(match.getTextMatch().getSnippetRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 26, /* upper= */ 32));
+            assertThat(match.getTextMatch().getSnippet()).isEqualTo(window);
+        }
+    }
+
+    @Test
+    public void testEmbeddingSnippet() throws Exception {
+        assumeTrue(Flags.enableSchemaEmbeddingPropertyConfig());
+        assumeTrue(Flags.enableEmbeddingMatchInfo());
+
+        final String propertyKeyEmbedding = "embedding1[1]";
+        final String id = "id1";
+        final double semanticScore = 1.3f;
+        final int embeddingQueryVectorIndex = 0;
+        final SearchSpecProto.EmbeddingQueryMetricType.Code embeddingQueryMetricType =
+                SearchSpecProto.EmbeddingQueryMetricType.Code.COSINE;
+
+        // Building the SearchResult received from query.
+        DocumentProto documentProto =
+                DocumentProto.newBuilder()
+                        .setUri(id)
+                        .setNamespace(PREFIXED_NAMESPACE)
+                        .setSchema(PREFIXED_SCHEMA_TYPE)
+                        .addProperties(
+                                PropertyProto.newBuilder()
+                                        .setName(propertyKeyEmbedding)
+                                        .addVectorValues(
+                                                PropertyProto.VectorProto.newBuilder()
+                                                        .addAllValues(
+                                                                Arrays.asList(1.1f, 2.2f, 3.3f))
+                                                        .setModelSignature("my_model_v1"))
+                                        .addVectorValues(
+                                                PropertyProto.VectorProto.newBuilder()
+                                                        .addAllValues(
+                                                                Arrays.asList(
+                                                                        4.4f, 5.5f, 6.6f, 7.7f))
+                                                        .setModelSignature("my_model_v2")))
+                        .build();
+        SnippetProto snippetProto =
+                SnippetProto.newBuilder()
+                        .addEntries(
+                                SnippetProto.EntryProto.newBuilder()
+                                        .setPropertyName(propertyKeyEmbedding)
+                                        .addEmbeddingMatches(
+                                                EmbeddingMatchSnippetProto.newBuilder()
+                                                        .setSemanticScore(semanticScore)
+                                                        .setEmbeddingQueryVectorIndex(
+                                                                embeddingQueryVectorIndex)
+                                                        .setEmbeddingQueryMetricType(
+                                                                embeddingQueryMetricType)))
+                        .build();
+
+        SearchResultProto searchResultProto =
+                SearchResultProto.newBuilder()
+                        .addResults(
+                                SearchResultProto.ResultProto.newBuilder()
+                                        .setDocument(documentProto)
+                                        .setSnippet(snippetProto))
+                        .build();
+
+        // Making ResultReader and getting Snippet values.
+        SearchResultPage searchResultPage =
+                SearchResultToProtoConverter.toSearchResultPage(
+                        searchResultProto,
+                        new SchemaCache(SCHEMA_MAP),
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()));
+        assertThat(searchResultPage.getResults()).hasSize(1);
+        SearchResult.MatchInfo match = searchResultPage.getResults().get(0).getMatchInfos().get(0);
+        assertThat(match.getPropertyPath()).isEqualTo(propertyKeyEmbedding);
+        assertThat(match.getEmbeddingMatch()).isNotNull();
+        assertThat(match.getEmbeddingMatch().getSemanticScore()).isEqualTo(semanticScore);
+        assertThat(match.getEmbeddingMatch().getQueryEmbeddingVectorIndex())
+                .isEqualTo(embeddingQueryVectorIndex);
+        assertThat(match.getEmbeddingMatch().getEmbeddingSearchMetricType())
+                .isEqualTo(embeddingQueryMetricType.getNumber());
+    }
+
+    @Test
+    public void testHybridSnippet() throws Exception {
+        assumeTrue(Flags.enableSchemaEmbeddingPropertyConfig());
+        assumeTrue(Flags.enableEmbeddingMatchInfo());
+
+        final String id = "id1";
+        final String propertyKeyString = "content";
+        final String propertyValueString =
+                "A commonly used fake word is foo.\n"
+                        + "   Another nonsense word thats used a lot\n"
+                        + "   is bar.\n";
+        final String exactMatch = "foo";
+        final String window = "is foo";
+
+        final String propertyKeyEmbedding = "embedding1[1]";
+        final double semanticScore = 1.3f;
+        final int embeddingQueryVectorIndex = 0;
+        final SearchSpecProto.EmbeddingQueryMetricType.Code embeddingQueryMetricType =
+                SearchSpecProto.EmbeddingQueryMetricType.Code.COSINE;
+
+        // Building the SearchResult received from query.
+        DocumentProto documentProto =
+                DocumentProto.newBuilder()
+                        .setUri(id)
+                        .setNamespace(PREFIXED_NAMESPACE)
+                        .setSchema(PREFIXED_SCHEMA_TYPE)
+                        .addProperties(
+                                PropertyProto.newBuilder()
+                                        .setName(propertyKeyString)
+                                        .addVectorValues(
+                                                PropertyProto.VectorProto.newBuilder()
+                                                        .addAllValues(
+                                                                Arrays.asList(1.1f, 2.2f, 3.3f))
+                                                        .setModelSignature("my_model_v1"))
+                                        .addVectorValues(
+                                                PropertyProto.VectorProto.newBuilder()
+                                                        .addAllValues(
+                                                                Arrays.asList(
+                                                                        4.4f, 5.5f, 6.6f, 7.7f))
+                                                        .setModelSignature("my_model_v2")))
+                        .addProperties(
+                                PropertyProto.newBuilder()
+                                        .setName(propertyKeyString)
+                                        .addStringValues(propertyValueString))
+                        .build();
+
+        SnippetProto snippetProto =
+                SnippetProto.newBuilder()
+                        .addEntries(
+                                SnippetProto.EntryProto.newBuilder()
+                                        .setPropertyName(propertyKeyString)
+                                        .addSnippetMatches(
+                                                SnippetMatchProto.newBuilder()
+                                                        .setExactMatchBytePosition(29)
+                                                        .setExactMatchByteLength(3)
+                                                        .setExactMatchUtf16Position(29)
+                                                        .setExactMatchUtf16Length(3)
+                                                        .setSubmatchByteLength(3)
+                                                        .setSubmatchUtf16Length(3)
+                                                        .setWindowBytePosition(26)
+                                                        .setWindowByteLength(6)
+                                                        .setWindowUtf16Position(26)
+                                                        .setWindowUtf16Length(6)))
+                        .addEntries(
+                                SnippetProto.EntryProto.newBuilder()
+                                        .setPropertyName(propertyKeyEmbedding)
+                                        .addEmbeddingMatches(
+                                                EmbeddingMatchSnippetProto.newBuilder()
+                                                        .setSemanticScore(semanticScore)
+                                                        .setEmbeddingQueryVectorIndex(
+                                                                embeddingQueryVectorIndex)
+                                                        .setEmbeddingQueryMetricType(
+                                                                embeddingQueryMetricType)))
+                        .build();
+
+        SearchResultProto searchResultProto =
+                SearchResultProto.newBuilder()
+                        .addResults(
+                                SearchResultProto.ResultProto.newBuilder()
+                                        .setDocument(documentProto)
+                                        .setSnippet(snippetProto))
+                        .build();
+
+        // Making ResultReader and getting Snippet values.
+        SearchResultPage searchResultPage =
+                SearchResultToProtoConverter.toSearchResultPage(
+                        searchResultProto,
+                        new SchemaCache(SCHEMA_MAP),
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()));
+        assertThat(searchResultPage.getResults()).hasSize(1);
+
+        // TextMatchInfo
+        SearchResult.MatchInfo match1 = searchResultPage.getResults().get(0).getMatchInfos().get(0);
+        assertThat(match1.getPropertyPath()).isEqualTo(propertyKeyString);
+        assertThat(match1.getTextMatch()).isNotNull();
+        assertThat(match1.getTextMatch().getFullText()).isEqualTo(propertyValueString);
+        assertThat(match1.getTextMatch().getExactMatch()).isEqualTo(exactMatch);
+        assertThat(match1.getTextMatch().getExactMatchRange())
+                .isEqualTo(new SearchResult.MatchRange(/* lower= */ 29, /* upper= */ 32));
+        assertThat(match1.getTextMatch().getSubmatch()).isEqualTo("foo");
+        assertThat(match1.getTextMatch().getSubmatchRange())
+                .isEqualTo(new SearchResult.MatchRange(/* lower= */ 29, /* upper= */ 32));
+        assertThat(match1.getTextMatch().getFullText()).isEqualTo(propertyValueString);
+        assertThat(match1.getTextMatch().getSnippetRange())
+                .isEqualTo(new SearchResult.MatchRange(/* lower= */ 26, /* upper= */ 32));
+        assertThat(match1.getTextMatch().getSnippet()).isEqualTo(window);
+
+        // EmbeddingMatchInfo
+        SearchResult.MatchInfo match2 = searchResultPage.getResults().get(0).getMatchInfos().get(1);
+        assertThat(match2.getPropertyPath()).isEqualTo(propertyKeyEmbedding);
+        assertThat(match2.getEmbeddingMatch()).isNotNull();
+        assertThat(match2.getEmbeddingMatch().getSemanticScore()).isEqualTo(semanticScore);
+        assertThat(match2.getEmbeddingMatch().getQueryEmbeddingVectorIndex())
+                .isEqualTo(embeddingQueryVectorIndex);
+        assertThat(match2.getEmbeddingMatch().getEmbeddingSearchMetricType())
+                .isEqualTo(embeddingQueryMetricType.getNumber());
     }
 
     @Test
@@ -239,6 +452,20 @@ public class SnippetTest {
                 .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 9));
         assertThat(match1.getSnippet()).isEqualTo("Test Name");
 
+        if (Flags.enableEmbeddingMatchInfo()) {
+            assertThat(match1.getTextMatch()).isNotNull();
+            assertThat(match1.getTextMatch().getFullText()).isEqualTo("Test Name Jr.");
+            assertThat(match1.getTextMatch().getExactMatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 4));
+            assertThat(match1.getTextMatch().getExactMatch()).isEqualTo("Test");
+            assertThat(match1.getTextMatch().getSubmatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 4));
+            assertThat(match1.getTextMatch().getSubmatch()).isEqualTo("Test");
+            assertThat(match1.getTextMatch().getSnippetRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 9));
+            assertThat(match1.getTextMatch().getSnippet()).isEqualTo("Test Name");
+        }
+
         SearchResult.MatchInfo match2 = searchResultPage.getResults().get(0).getMatchInfos().get(1);
         assertThat(match2.getPropertyPath()).isEqualTo("senderEmail");
         assertThat(match2.getFullText()).isEqualTo("TestNameJr@gmail.com");
@@ -251,6 +478,20 @@ public class SnippetTest {
         assertThat(match2.getSnippetRange())
                 .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 20));
         assertThat(match2.getSnippet()).isEqualTo("TestNameJr@gmail.com");
+
+        if (Flags.enableEmbeddingMatchInfo()) {
+            assertThat(match2.getTextMatch()).isNotNull();
+            assertThat(match2.getTextMatch().getFullText()).isEqualTo("TestNameJr@gmail.com");
+            assertThat(match2.getTextMatch().getExactMatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 20));
+            assertThat(match2.getTextMatch().getExactMatch()).isEqualTo("TestNameJr@gmail.com");
+            assertThat(match2.getTextMatch().getSubmatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 4));
+            assertThat(match2.getTextMatch().getSubmatch()).isEqualTo("Test");
+            assertThat(match2.getTextMatch().getSnippetRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 20));
+            assertThat(match2.getTextMatch().getSnippet()).isEqualTo("TestNameJr@gmail.com");
+        }
     }
 
     @Test
@@ -344,6 +585,20 @@ public class SnippetTest {
                 .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 9));
         assertThat(match1.getSnippet()).isEqualTo("Test Name");
 
+        if (Flags.enableEmbeddingMatchInfo()) {
+            assertThat(match1.getTextMatch()).isNotNull();
+            assertThat(match1.getTextMatch().getFullText()).isEqualTo("Test Name Jr.");
+            assertThat(match1.getTextMatch().getExactMatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 4));
+            assertThat(match1.getTextMatch().getExactMatch()).isEqualTo("Test");
+            assertThat(match1.getTextMatch().getSubmatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 4));
+            assertThat(match1.getTextMatch().getSubmatch()).isEqualTo("Test");
+            assertThat(match1.getTextMatch().getSnippetRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 9));
+            assertThat(match1.getTextMatch().getSnippet()).isEqualTo("Test Name");
+        }
+
         SearchResult.MatchInfo match2 = searchResultPage.getResults().get(0).getMatchInfos().get(1);
         assertThat(match2.getPropertyPath()).isEqualTo("sender.email[1]");
         assertThat(match2.getPropertyPathObject()).isEqualTo(new PropertyPath("sender.email[1]"));
@@ -357,5 +612,19 @@ public class SnippetTest {
         assertThat(match2.getSnippetRange())
                 .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 21));
         assertThat(match2.getSnippet()).isEqualTo("TestNameJr2@gmail.com");
+
+        if (Flags.enableEmbeddingMatchInfo()) {
+            assertThat(match2.getTextMatch()).isNotNull();
+            assertThat(match2.getTextMatch().getFullText()).isEqualTo("TestNameJr2@gmail.com");
+            assertThat(match2.getTextMatch().getExactMatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 21));
+            assertThat(match2.getTextMatch().getExactMatch()).isEqualTo("TestNameJr2@gmail.com");
+            assertThat(match2.getTextMatch().getSubmatchRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 4));
+            assertThat(match2.getTextMatch().getSubmatch()).isEqualTo("Test");
+            assertThat(match2.getTextMatch().getSnippetRange())
+                    .isEqualTo(new SearchResult.MatchRange(/* lower= */ 0, /* upper= */ 21));
+            assertThat(match2.getTextMatch().getSnippet()).isEqualTo("TestNameJr2@gmail.com");
+        }
     }
 }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/stats/AppSearchStatsTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/stats/AppSearchStatsTest.java
index ff2fd62f..97963ec7 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/stats/AppSearchStatsTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/stats/AppSearchStatsTest.java
@@ -46,6 +46,7 @@ public class AppSearchStatsTest {
                         .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
                         .setNumOperationsSucceeded(numOperationsSucceeded)
                         .setNumOperationsFailed(numOperationsFailed)
+                        .setLaunchVMEnabled(true)
                         .build();
 
         assertThat(cStats.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
@@ -57,6 +58,25 @@ public class AppSearchStatsTest {
         assertThat(cStats.getCallType()).isEqualTo(callType);
         assertThat(cStats.getNumOperationsSucceeded()).isEqualTo(numOperationsSucceeded);
         assertThat(cStats.getNumOperationsFailed()).isEqualTo(numOperationsFailed);
+        assertThat(cStats.getEnabledFeatures()).isEqualTo(1);
+    }
+
+    @Test
+    public void testAppSearchStats_setLaunchVMEnabled_false() {
+        final CallStats cStats =
+                new CallStats.Builder()
+                        .setPackageName(TEST_PACKAGE_NAME)
+                        .setDatabase(TEST_DATA_BASE)
+                        .setStatusCode(TEST_STATUS_CODE)
+                        .setTotalLatencyMillis(TEST_TOTAL_LATENCY_MILLIS)
+                        .setLaunchVMEnabled(false)
+                        .build();
+
+        assertThat(cStats.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
+        assertThat(cStats.getDatabase()).isEqualTo(TEST_DATA_BASE);
+        assertThat(cStats.getStatusCode()).isEqualTo(TEST_STATUS_CODE);
+        assertThat(cStats.getTotalLatencyMillis()).isEqualTo(TEST_TOTAL_LATENCY_MILLIS);
+        assertThat(cStats.getEnabledFeatures()).isEqualTo(0);
     }
 
     @Test
@@ -87,6 +107,7 @@ public class AppSearchStatsTest {
         final int nativeIntegerIndexLatencyMillis = 10;
         final int nativeQualifiedIdJoinIndexLatencyMillis = 11;
         final int nativeLiteIndexSortLatencyMillis = 12;
+        final int enabledFeatures = 1;
         final PutDocumentStats.Builder pStatsBuilder =
                 new PutDocumentStats.Builder(TEST_PACKAGE_NAME, TEST_DATA_BASE)
                         .setStatusCode(TEST_STATUS_CODE)
@@ -103,7 +124,8 @@ public class AppSearchStatsTest {
                         .setNativeIntegerIndexLatencyMillis(nativeIntegerIndexLatencyMillis)
                         .setNativeQualifiedIdJoinIndexLatencyMillis(
                                 nativeQualifiedIdJoinIndexLatencyMillis)
-                        .setNativeLiteIndexSortLatencyMillis(nativeLiteIndexSortLatencyMillis);
+                        .setNativeLiteIndexSortLatencyMillis(nativeLiteIndexSortLatencyMillis)
+                        .setLaunchVMEnabled(true);
 
         final PutDocumentStats pStats = pStatsBuilder.build();
 
@@ -131,6 +153,7 @@ public class AppSearchStatsTest {
                 .isEqualTo(nativeQualifiedIdJoinIndexLatencyMillis);
         assertThat(pStats.getNativeLiteIndexSortLatencyMillis())
                 .isEqualTo(nativeLiteIndexSortLatencyMillis);
+        assertThat(pStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
     }
 
     @Test
@@ -147,6 +170,7 @@ public class AppSearchStatsTest {
         int nativeDocumentStoreDataStatus = 10;
         int nativeNumDocuments = 11;
         int nativeNumSchemaTypes = 12;
+        int enabledFeatures = 1;
 
         final InitializeStats.Builder iStatsBuilder =
                 new InitializeStats.Builder()
@@ -168,7 +192,8 @@ public class AppSearchStatsTest {
                         .setDocumentCount(nativeNumDocuments)
                         .setSchemaTypeCount(nativeNumSchemaTypes)
                         .setHasReset(true)
-                        .setResetStatusCode(AppSearchResult.RESULT_INVALID_SCHEMA);
+                        .setResetStatusCode(AppSearchResult.RESULT_INVALID_SCHEMA)
+                        .setLaunchVMEnabled(true);
         final InitializeStats iStats = iStatsBuilder.build();
 
         assertThat(iStats.getStatusCode()).isEqualTo(TEST_STATUS_CODE);
@@ -194,6 +219,7 @@ public class AppSearchStatsTest {
         assertThat(iStats.getSchemaTypeCount()).isEqualTo(nativeNumSchemaTypes);
         assertThat(iStats.hasReset()).isTrue();
         assertThat(iStats.getResetStatusCode()).isEqualTo(AppSearchResult.RESULT_INVALID_SCHEMA);
+        assertThat(iStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
     }
 
     @Test
@@ -222,6 +248,7 @@ public class AppSearchStatsTest {
         int javaToNativeJniLatencyMillis = 21;
         int nativeToJavaJniLatencyMillis = 22;
         String searchSourceLogTag = "tag";
+        int enabledFeatures = 1;
         final SearchStats.Builder sStatsBuilder =
                 new SearchStats.Builder(visibilityScope, TEST_PACKAGE_NAME)
                         .setDatabase(TEST_DATA_BASE)
@@ -249,7 +276,8 @@ public class AppSearchStatsTest {
                         .setNativeLockAcquisitionLatencyMillis(nativeLockAcquisitionLatencyMillis)
                         .setJavaToNativeJniLatencyMillis(javaToNativeJniLatencyMillis)
                         .setNativeToJavaJniLatencyMillis(nativeToJavaJniLatencyMillis)
-                        .setSearchSourceLogTag(searchSourceLogTag);
+                        .setSearchSourceLogTag(searchSourceLogTag)
+                        .setLaunchVMEnabled(true);
         final SearchStats sStats = sStatsBuilder.build();
 
         assertThat(sStats.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
@@ -288,6 +316,7 @@ public class AppSearchStatsTest {
         assertThat(sStats.getNativeToJavaJniLatencyMillis())
                 .isEqualTo(nativeToJavaJniLatencyMillis);
         assertThat(sStats.getSearchSourceLogTag()).isEqualTo(searchSourceLogTag);
+        assertThat(sStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
     }
 
     @Test
@@ -311,6 +340,7 @@ public class AppSearchStatsTest {
         int getOldSchemaLatencyMillis = 16;
         int getObserverLatencyMillis = 17;
         int sendNotificationLatencyMillis = 18;
+        int enabledFeatures = 1;
         SetSchemaStats sStats =
                 new SetSchemaStats.Builder(TEST_PACKAGE_NAME, TEST_DATA_BASE)
                         .setStatusCode(TEST_STATUS_CODE)
@@ -338,6 +368,7 @@ public class AppSearchStatsTest {
                         .setPreparingChangeNotificationLatencyMillis(sendNotificationLatencyMillis)
                         .setSchemaMigrationCallType(
                                 SchemaMigrationStats.SECOND_CALL_APPLY_NEW_SCHEMA)
+                        .setLaunchVMEnabled(true)
                         .build();
 
         assertThat(sStats.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
@@ -375,6 +406,7 @@ public class AppSearchStatsTest {
                 .isEqualTo(sendNotificationLatencyMillis);
         assertThat(sStats.getSchemaMigrationCallType())
                 .isEqualTo(SchemaMigrationStats.SECOND_CALL_APPLY_NEW_SCHEMA);
+        assertThat(sStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
     }
 
     @Test
@@ -427,6 +459,7 @@ public class AppSearchStatsTest {
         int nativeLatencyMillis = 1;
         @RemoveStats.DeleteType int deleteType = 2;
         int documentDeletedCount = 3;
+        int enabledFeatures = 1;
 
         final RemoveStats rStats =
                 new RemoveStats.Builder(TEST_PACKAGE_NAME, TEST_DATA_BASE)
@@ -435,6 +468,7 @@ public class AppSearchStatsTest {
                         .setNativeLatencyMillis(nativeLatencyMillis)
                         .setDeleteType(deleteType)
                         .setDeletedDocumentCount(documentDeletedCount)
+                        .setLaunchVMEnabled(true)
                         .build();
 
         assertThat(rStats.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
@@ -444,6 +478,7 @@ public class AppSearchStatsTest {
         assertThat(rStats.getNativeLatencyMillis()).isEqualTo(nativeLatencyMillis);
         assertThat(rStats.getDeleteType()).isEqualTo(deleteType);
         assertThat(rStats.getDeletedDocumentCount()).isEqualTo(documentDeletedCount);
+        assertThat(rStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
     }
 
     @Test
@@ -454,6 +489,7 @@ public class AppSearchStatsTest {
         int nativeNumOriginalDocuments = 4;
         int nativeNumDeletedDocuments = 5;
         int nativeNumExpiredDocuments = 6;
+        int enabledFeatures = 1;
         long nativeStorageSizeBeforeBytes = Integer.MAX_VALUE + 1;
         long nativeStorageSizeAfterBytes = Integer.MAX_VALUE + 2;
         long nativeTimeSinceLastOptimizeMillis = Integer.MAX_VALUE + 3;
@@ -472,6 +508,7 @@ public class AppSearchStatsTest {
                         .setStorageSizeBeforeBytes(nativeStorageSizeBeforeBytes)
                         .setStorageSizeAfterBytes(nativeStorageSizeAfterBytes)
                         .setTimeSinceLastOptimizeMillis(nativeTimeSinceLastOptimizeMillis)
+                        .setLaunchVMEnabled(true)
                         .build();
 
         assertThat(oStats.getStatusCode()).isEqualTo(TEST_STATUS_CODE);
@@ -489,5 +526,6 @@ public class AppSearchStatsTest {
         assertThat(oStats.getStorageSizeAfterBytes()).isEqualTo(nativeStorageSizeAfterBytes);
         assertThat(oStats.getTimeSinceLastOptimizeMillis())
                 .isEqualTo(nativeTimeSinceLastOptimizeMillis);
+        assertThat(oStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
     }
 }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/usagereporting/SearchSessionStatsExtractorTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/usagereporting/SearchSessionStatsExtractorTest.java
index d7c78af1..7d0ded48 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/usagereporting/SearchSessionStatsExtractorTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/usagereporting/SearchSessionStatsExtractorTest.java
@@ -107,7 +107,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -139,6 +143,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats0.getClicksStats().get(1).getTimeStayOnResultMillis())
                 .isEqualTo(1024);
         assertThat(searchIntentStats0.getClicksStats().get(1).isGoodClick()).isFalse();
+        assertThat(searchIntentStats0.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 1
         SearchIntentStats searchIntentStats1 = searchSessionStats0.getSearchIntentsStats().get(1);
@@ -169,6 +174,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats1.getClicksStats().get(2).getTimeStayOnResultMillis())
                 .isEqualTo(2048);
         assertThat(searchIntentStats1.getClicksStats().get(2).isGoodClick()).isTrue();
+        assertThat(searchIntentStats1.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -198,7 +204,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
         assertThat(result).isEmpty();
     }
 
@@ -236,7 +246,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -264,6 +278,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats0.getClicksStats().get(0).getTimeStayOnResultMillis())
                 .isEqualTo(1024);
         assertThat(searchIntentStats0.getClicksStats().get(0).isGoodClick()).isFalse();
+        assertThat(searchIntentStats0.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -310,7 +325,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -333,6 +352,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats0.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_FIRST_QUERY);
         assertThat(searchIntentStats0.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats0.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 1
         SearchIntentStats searchIntentStats1 = searchSessionStats0.getSearchIntentsStats().get(1);
@@ -345,6 +365,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats1.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_REFINEMENT);
         assertThat(searchIntentStats1.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats1.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 2
         SearchIntentStats searchIntentStats2 = searchSessionStats0.getSearchIntentsStats().get(2);
@@ -357,6 +378,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats2.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_REFINEMENT);
         assertThat(searchIntentStats2.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats2.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -403,7 +425,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -426,6 +452,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats0.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_FIRST_QUERY);
         assertThat(searchIntentStats0.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats0.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 1
         SearchIntentStats searchIntentStats1 = searchSessionStats0.getSearchIntentsStats().get(1);
@@ -438,6 +465,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats1.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_ABANDONMENT);
         assertThat(searchIntentStats1.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats1.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 2
         SearchIntentStats searchIntentStats2 = searchSessionStats0.getSearchIntentsStats().get(2);
@@ -450,6 +478,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats2.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_REFINEMENT);
         assertThat(searchIntentStats2.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats2.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -481,7 +510,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -503,6 +536,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats0.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_FIRST_QUERY);
         assertThat(searchIntentStats0.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats0.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 1
         SearchIntentStats searchIntentStats1 = searchSessionStats0.getSearchIntentsStats().get(1);
@@ -515,6 +549,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats1.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_REFINEMENT);
         assertThat(searchIntentStats1.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats1.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 2
         SearchIntentStats searchIntentStats2 = searchSessionStats0.getSearchIntentsStats().get(2);
@@ -527,6 +562,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats2.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_REFINEMENT);
         assertThat(searchIntentStats2.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats2.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -565,7 +601,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -588,6 +628,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats0.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_FIRST_QUERY);
         assertThat(searchIntentStats0.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats0.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 1
         SearchIntentStats searchIntentStats1 = searchSessionStats0.getSearchIntentsStats().get(1);
@@ -600,6 +641,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats1.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_REFINEMENT);
         assertThat(searchIntentStats1.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats1.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 2
         SearchIntentStats searchIntentStats2 = searchSessionStats0.getSearchIntentsStats().get(2);
@@ -612,6 +654,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats2.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_ABANDONMENT);
         assertThat(searchIntentStats2.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats2.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 3
         SearchIntentStats searchIntentStats3 = searchSessionStats0.getSearchIntentsStats().get(3);
@@ -624,6 +667,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats3.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_ABANDONMENT);
         assertThat(searchIntentStats3.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats3.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -648,7 +692,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -714,7 +762,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         // searchAction2 should not be considered as noise:
         // - searchAction3 is independent from searchAction2 and therefore forms an independent
@@ -727,11 +779,13 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchSessionStats0.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
         assertThat(searchSessionStats0.getDatabase()).isEqualTo(TEST_DATABASE);
         assertThat(searchSessionStats0.getSearchIntentsStats()).hasSize(2);
+        assertThat(searchSessionStats0.getEnabledFeatures()).isEqualTo(1);
 
         SearchSessionStats searchSessionStats1 = result.get(1);
         assertThat(searchSessionStats1.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
         assertThat(searchSessionStats1.getDatabase()).isEqualTo(TEST_DATABASE);
         assertThat(searchSessionStats1.getSearchIntentsStats()).hasSize(1);
+        assertThat(searchSessionStats1.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 0
         SearchIntentStats searchIntentStats0 = searchSessionStats0.getSearchIntentsStats().get(0);
@@ -744,6 +798,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats0.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_FIRST_QUERY);
         assertThat(searchIntentStats0.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats0.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 1
         SearchIntentStats searchIntentStats1 = searchSessionStats0.getSearchIntentsStats().get(1);
@@ -756,6 +811,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats1.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_REFINEMENT);
         assertThat(searchIntentStats1.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats1.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 1, search intent 0
         SearchIntentStats searchIntentStats2 = searchSessionStats1.getSearchIntentsStats().get(0);
@@ -768,6 +824,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats2.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_FIRST_QUERY);
         assertThat(searchIntentStats2.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats2.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -808,7 +865,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -816,6 +877,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchSessionStats0.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
         assertThat(searchSessionStats0.getDatabase()).isEqualTo(TEST_DATABASE);
         assertThat(searchSessionStats0.getSearchIntentsStats()).hasSize(3);
+        assertThat(searchSessionStats0.getEnabledFeatures()).isEqualTo(1);
 
         // Even though searchAction2 is an intermediate search action, it should not be considered
         // as noise since there is at least 1 valid click action associated with it.
@@ -831,6 +893,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats0.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_FIRST_QUERY);
         assertThat(searchIntentStats0.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats0.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 1
         SearchIntentStats searchIntentStats1 = searchSessionStats0.getSearchIntentsStats().get(1);
@@ -843,6 +906,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats1.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_REFINEMENT);
         assertThat(searchIntentStats1.getClicksStats()).hasSize(1);
+        assertThat(searchIntentStats1.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 0, search intent 2
         SearchIntentStats searchIntentStats2 = searchSessionStats0.getSearchIntentsStats().get(2);
@@ -855,6 +919,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats2.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_REFINEMENT);
         assertThat(searchIntentStats2.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats2.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -879,7 +944,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         // Since time difference between searchAction1 and searchAction2 exceeds the threshold,
         // searchAction2 should be considered as an independent search intent and therefore a new
@@ -901,6 +970,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats0.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_FIRST_QUERY);
         assertThat(searchIntentStats0.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats0.getEnabledFeatures()).isEqualTo(1);
 
         // Search session 1
         SearchSessionStats searchSessionStats1 = result.get(1);
@@ -917,6 +987,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats1.getQueryCorrectionType())
                 .isEqualTo(SearchIntentStats.QUERY_CORRECTION_TYPE_FIRST_QUERY);
         assertThat(searchIntentStats1.getClicksStats()).isEmpty();
+        assertThat(searchIntentStats1.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -955,7 +1026,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -982,6 +1057,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats.getClicksStats().get(3).getTimeStayOnResultMillis())
                 .isEqualTo(2000);
         assertThat(searchIntentStats.getClicksStats().get(3).isGoodClick()).isTrue();
+        assertThat(searchIntentStats.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -1003,7 +1079,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -1021,6 +1101,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats.getClicksStats().get(0).getTimeStayOnResultMillis())
                 .isEqualTo(0);
         assertThat(searchIntentStats.getClicksStats().get(0).isGoodClick()).isTrue();
+        assertThat(searchIntentStats.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
@@ -1048,7 +1129,11 @@ public class SearchSessionStatsExtractorTest {
 
         List<SearchSessionStats> result =
                 new SearchSessionStatsExtractor()
-                        .extract(TEST_PACKAGE_NAME, TEST_DATABASE, takenActionGenericDocuments);
+                        .extract(
+                                TEST_PACKAGE_NAME,
+                                TEST_DATABASE,
+                                takenActionGenericDocuments,
+                                /* isVMEnabled= */ true);
 
         assertThat(result).hasSize(1);
 
@@ -1067,6 +1152,7 @@ public class SearchSessionStatsExtractorTest {
         assertThat(searchIntentStats.getClicksStats().get(1).getTimeStayOnResultMillis())
                 .isEqualTo(0);
         assertThat(searchIntentStats.getClicksStats().get(1).isGoodClick()).isTrue();
+        assertThat(searchIntentStats.getEnabledFeatures()).isEqualTo(1);
     }
 
     @Test
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationFromV2Test.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationFromV2Test.java
index e2a1be43..3caeb1f6 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationFromV2Test.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationFromV2Test.java
@@ -71,6 +71,7 @@ public class VisibilityStoreMigrationFromV2Test {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testVisibilityMigration_from2() throws Exception {
         // As such, we can treat V2 documents as V3 documents when upgrading, but we need to test
         // this.
@@ -95,6 +96,7 @@ public class VisibilityStoreMigrationFromV2Test {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Erase overlay schemas since it doesn't exist in released V2 schema.
@@ -176,6 +178,7 @@ public class VisibilityStoreMigrationFromV2Test {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalVisibilityConfig actualConfig =
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0Test.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0Test.java
index c964983b..c3b2ee7a 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0Test.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0Test.java
@@ -70,6 +70,7 @@ public class VisibilityStoreMigrationHelperFromV0Test {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testVisibilityMigration_from0() throws Exception {
         // Values for a "foo" client
         String packageNameFoo = "packageFoo";
@@ -153,6 +154,7 @@ public class VisibilityStoreMigrationHelperFromV0Test {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         GenericDocument actualDocument1 =
@@ -247,6 +249,7 @@ public class VisibilityStoreMigrationHelperFromV0Test {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         InternalSetSchemaResponse internalSetSchemaResponse =
                 appSearchImpl.setSchema(
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1Test.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1Test.java
index 03f7f213..f5e3e43a 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1Test.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1Test.java
@@ -66,6 +66,7 @@ public class VisibilityStoreMigrationHelperFromV1Test {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testVisibilityMigration_from1() throws Exception {
         // Values for a "foo" client
         String packageNameFoo = "packageFoo";
@@ -87,6 +88,7 @@ public class VisibilityStoreMigrationHelperFromV1Test {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         InternalSetSchemaResponse internalSetSchemaResponse =
                 appSearchImplInV1.setSchema(
@@ -142,6 +144,7 @@ public class VisibilityStoreMigrationHelperFromV1Test {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalVisibilityConfig actualConfig =
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreTest.java
index aad7a542..8f544cd9 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreTest.java
@@ -74,6 +74,7 @@ public class VisibilityStoreTest {
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         mVisibilityStore = VisibilityStore.createDocumentVisibilityStore(mAppSearchImpl);
     }
@@ -278,6 +279,7 @@ public class VisibilityStoreTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // AppSearchImpl.putDocument
     public void testSetVisibility_avoidRemoveOverlay() throws Exception {
         // Set a visibility config w/o overlay
         InternalVisibilityConfig visibilityConfig =
diff --git a/testing/servicestests/src/com/android/server/appsearch/stats/IsolatedStorageServiceLoggerTest.java b/testing/servicestests/src/com/android/server/appsearch/stats/IsolatedStorageServiceLoggerTest.java
new file mode 100644
index 00000000..830d5607
--- /dev/null
+++ b/testing/servicestests/src/com/android/server/appsearch/stats/IsolatedStorageServiceLoggerTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.stats;
+
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_ERROR;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_FINISH;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_READY;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_START;
+import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_STOP;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertTrue;
+
+import com.android.server.appsearch.isolated_storage_service.ServiceConfig;
+
+import org.junit.Test;
+
+public class IsolatedStorageServiceLoggerTest {
+
+    @Test
+    @SuppressWarnings("GuardedBy")
+    public void testShouldLogForTypeLocked_true() throws Exception {
+        ServiceConfig config = new ServiceConfig();
+        config.pCachedSamplingInterval = 1;
+        IsolateStorageServiceLogger logger = new IsolateStorageServiceLogger(config);
+        assertTrue(logger.shouldLogForTypeLocked(CALLBACK_TYPE_START));
+        assertTrue(logger.shouldLogForTypeLocked(CALLBACK_TYPE_READY));
+        assertTrue(logger.shouldLogForTypeLocked(CALLBACK_TYPE_FINISH));
+        assertTrue(logger.shouldLogForTypeLocked(CALLBACK_TYPE_ERROR));
+        assertTrue(logger.shouldLogForTypeLocked(CALLBACK_TYPE_STOP));
+        assertThat(logger.mSkippedSampleCountLocked).hasSize(6); // 5 types + unknown.
+    }
+}
diff --git a/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java b/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java
index 705b43a9..5d57e228 100644
--- a/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java
@@ -17,7 +17,6 @@
 package com.android.server.appsearch.visibilitystore;
 
 import static android.Manifest.permission.EXECUTE_APP_FUNCTIONS;
-import static android.Manifest.permission.EXECUTE_APP_FUNCTIONS_TRUSTED;
 import static android.Manifest.permission.PACKAGE_USAGE_STATS;
 import static android.Manifest.permission.READ_ASSISTANT_APP_SEARCH_DATA;
 import static android.Manifest.permission.READ_CALENDAR;
@@ -44,14 +43,13 @@ import android.app.appsearch.InternalVisibilityConfig;
 import android.app.appsearch.PackageIdentifier;
 import android.app.appsearch.SetSchemaRequest;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.app.appsearch.testutil.FakeAppSearchConfig;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.content.pm.PackageManager;
 import android.os.UserHandle;
 import android.platform.test.annotations.RequiresFlagsEnabled;
-import android.platform.test.flag.junit.CheckFlagsRule;
-import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 import android.util.ArrayMap;
 
 import androidx.test.core.app.ApplicationProvider;
@@ -69,6 +67,7 @@ import com.google.common.collect.ImmutableSet;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
 import org.mockito.Mockito;
 
@@ -89,8 +88,7 @@ public class VisibilityCheckerImplTest {
     private static final int SET_SCHEMA_REQUEST_EXECUTE_APP_FUNCTIONS_TRUSTED = 10;
     private static final int SET_SCHEMA_REQUEST_PACKAGE_USAGE_STATS = 11;
 
-    @Rule
-    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
 
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
     private final Map<UserHandle, PackageManager> mMockPackageManagers = new ArrayMap<>();
@@ -132,6 +130,7 @@ public class VisibilityCheckerImplTest {
                         /* initStatsBuilder= */ null,
                         mVisibilityChecker,
                         /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
                         ALWAYS_OPTIMIZE);
         mVisibilityStore = VisibilityStore.createDocumentVisibilityStore(appSearchImpl);
     }
@@ -621,14 +620,11 @@ public class VisibilityCheckerImplTest {
     public void testSetSchema_visibleToAppFunctionsPermissions() throws Exception {
         String prefix = PrefixUtil.createPrefix("package", "database");
 
-        // Create a VDoc that require either EXECUTE_APP_FUNCTIONS or EXECUTE_APP_FUNCTIONS_TRUSTED
-        // permissions only.
+        // Create a VDoc that require either EXECUTE_APP_FUNCTIONS permissions only.
         InternalVisibilityConfig visibilityConfig =
                 new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
                         .addVisibleToPermissions(
                                 ImmutableSet.of(SET_SCHEMA_REQUEST_EXECUTE_APP_FUNCTIONS))
-                        .addVisibleToPermissions(
-                                ImmutableSet.of(SET_SCHEMA_REQUEST_EXECUTE_APP_FUNCTIONS_TRUSTED))
                         .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
@@ -646,12 +642,6 @@ public class VisibilityCheckerImplTest {
                                 prefix + "Schema",
                                 mVisibilityStore))
                 .isTrue();
-        // Grant the EXECUTE_APP_FUNCTIONS_TRUSTED permission along with EXECUTE_APP_FUNCTIONS, we
-        // should still be able to access.
-        doReturn(true)
-                .when(mVisibilityChecker)
-                .checkPermissionForDataDeliveryGranted(
-                        eq(EXECUTE_APP_FUNCTIONS_TRUSTED), any(), any());
         assertThat(
                         mVisibilityChecker.isSchemaSearchableByCaller(
                                 new FrameworkCallerAccess(
@@ -662,8 +652,7 @@ public class VisibilityCheckerImplTest {
                                 prefix + "Schema",
                                 mVisibilityStore))
                 .isTrue();
-        // Drop the EXECUTE_APP_FUNCTIONS permission so only EXECUTE_APP_FUNCTIONS_TRUSTED is held,
-        // we should still be able to access.
+        // Ungrant the EXECUTE_APP_FUNCTIONS permsision. Can no longer access.
         doReturn(false)
                 .when(mVisibilityChecker)
                 .checkPermissionForDataDeliveryGranted(eq(EXECUTE_APP_FUNCTIONS), any(), any());
@@ -676,12 +665,23 @@ public class VisibilityCheckerImplTest {
                                 "package",
                                 prefix + "Schema",
                                 mVisibilityStore))
-                .isTrue();
-        // Drop both permissions, it becomes invisible.
-        doReturn(false)
-                .when(mVisibilityChecker)
-                .checkPermissionForDataDeliveryGranted(
-                        eq(EXECUTE_APP_FUNCTIONS_TRUSTED), any(), any());
+                .isFalse();
+    }
+
+    @Test
+    @RequiresFlagsEnabled(FLAG_ENABLE_APP_FUNCTION_MANAGER)
+    public void testSetSchema_executeAppFunctionsTrusted() throws Exception {
+        String prefix = PrefixUtil.createPrefix("package", "database");
+
+        // Create a VDoc that require either EXECUTE_APP_FUNCTIONS_TRUSTED permissions only.
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(
+                                ImmutableSet.of(SET_SCHEMA_REQUEST_EXECUTE_APP_FUNCTIONS_TRUSTED))
+                        .build();
+        mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
+
+        // The permission is deprecated and so the check should always return false (without crash).
         assertThat(
                         mVisibilityChecker.isSchemaSearchableByCaller(
                                 new FrameworkCallerAccess(
```

