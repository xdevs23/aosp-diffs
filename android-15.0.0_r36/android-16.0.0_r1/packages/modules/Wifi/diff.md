```diff
diff --git a/WIFI_OWNERS b/WIFI_OWNERS
index caa458790e..a8e1626bd1 100644
--- a/WIFI_OWNERS
+++ b/WIFI_OWNERS
@@ -2,3 +2,4 @@
 
 arabawy@google.com
 satk@google.com
+xshu@google.com
diff --git a/aidl/mainline_supplicant/Android.bp b/aidl/mainline_supplicant/Android.bp
index 285af3d6cf..00600440eb 100644
--- a/aidl/mainline_supplicant/Android.bp
+++ b/aidl/mainline_supplicant/Android.bp
@@ -26,6 +26,11 @@ aidl_interface {
                 "com.android.wifi",
             ],
             min_sdk_version: "30",
+            lint: {
+                // Disable linter to avoid error about fixed size arrays.
+                // Interface will only be accessed on devices >= B.
+                enabled: false,
+            },
         },
         ndk: {
             enabled: true,
diff --git a/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IMainlineSupplicant.aidl b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IMainlineSupplicant.aidl
index 4179b06279..40ed698b7d 100644
--- a/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IMainlineSupplicant.aidl
+++ b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IMainlineSupplicant.aidl
@@ -16,23 +16,25 @@
 
 package android.system.wifi.mainline_supplicant;
 
+import android.system.wifi.mainline_supplicant.IStaInterface;
+
 /**
  * Root of the mainline supplicant interface. This is an unstable AIDL interface used
  * to interact with the supplicant binary stored in the mainline module.
  */
 interface IMainlineSupplicant {
     /**
-     * Register an interface for use by USD.
+     * Register a STA interface with the supplicant.
      *
      * @param ifaceName Name of the interface (ex. wlan0)
      * @throws ServiceSpecificException with one of the following values:
      *         |SupplicantStatusCode.FAILURE_UNKNOWN|
      *         |SupplicantStatusCode.FAILURE_ARGS_INVALID|
      */
-    void addUsdInterface(String ifaceName);
+    @PropagateAllowBlocking IStaInterface addStaInterface(String ifaceName);
 
     /**
-     * Remove an interface that is being used for USD.
+     * Remove a STA interface from the supplicant.
      *
      * @param ifaceName Name of the interface (ex. wlan0)
      * @throws ServiceSpecificException with one of the following values:
@@ -40,7 +42,7 @@ interface IMainlineSupplicant {
      *         |SupplicantStatusCode.FAILURE_ARGS_INVALID|
      *         |SupplicantStatusCode.FAILURE_IFACE_UNKNOWN|
      */
-    void removeUsdInterface(String ifaceName);
+    void removeStaInterface(String ifaceName);
 
     /**
      * Terminate the service.
diff --git a/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IStaInterface.aidl b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IStaInterface.aidl
new file mode 100644
index 0000000000..05ead87d6f
--- /dev/null
+++ b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IStaInterface.aidl
@@ -0,0 +1,338 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.system.wifi.mainline_supplicant;
+
+import android.system.wifi.mainline_supplicant.IStaInterfaceCallback;
+import android.system.wifi.mainline_supplicant.UsdMessageInfo;
+import android.system.wifi.mainline_supplicant.UsdServiceProtoType;
+
+/**
+ * Interface exposed by the supplicant for each station mode network
+ * interface (ex. wlan0) it controls.
+ */
+interface IStaInterface {
+    /**
+     * Capabilities supported by USD. Values are only valid if |isUsdPublisherSupported|
+     * and/or |isUsdSubscriberSupported| are true.
+     */
+    parcelable UsdCapabilities {
+        /**
+         * Whether USD Publisher is supported on this device.
+         */
+        boolean isUsdPublisherSupported;
+
+        /**
+         * Whether USD Subscriber is supported on this device.
+         */
+        boolean isUsdSubscriberSupported;
+
+        /**
+         * Maximum allowed length (in bytes) for the Service Specific Info (SSI).
+         */
+        int maxLocalSsiLengthBytes;
+
+        /**
+         * Maximum allowed length (in bytes) for the service name.
+         */
+        int maxServiceNameLengthBytes;
+
+        /**
+         * Maximum allowed length (in bytes) for a match filter.
+         */
+        int maxMatchFilterLengthBytes;
+
+        /**
+         * Maximum number of allowed publish sessions.
+         */
+        int maxNumPublishSessions;
+
+        /**
+         * Maximum number of allowed subscribe sessions.
+         */
+        int maxNumSubscribeSessions;
+    }
+
+    /**
+     * Data used in both USD publish and subscribe configurations.
+     */
+    parcelable UsdBaseConfig {
+        /**
+         * Service name of the USD session. A UTF-8 encoded string from 1 to 255 bytes in length.
+         * The only acceptable single-byte UTF-8 symbols for a Service Name are alphanumeric
+         * values (A-Z, a-z, 0-9), hyphen ('-'), period ('.'), and underscore ('_'). All
+         * valid multi-byte UTF-8 characters are acceptable in a Service Name.
+         */
+        @utf8InCpp String serviceName;
+
+        /**
+         * Service protocol type for the USD session (ex. Generic, CSA Matter).
+         */
+        UsdServiceProtoType serviceProtoType;
+
+        /**
+         * Details about the service being offered or being looked for. This information is
+         * transmitted within Service Discovery frames, and is used to help devices find each other
+         * and establish connections. The format and content of the service specific information are
+         * flexible and can be determined by the application.
+         */
+        byte[] serviceSpecificInfo;
+
+        /**
+         * Ordered sequence of <length, value> pairs (|length| uses 1 byte and contains the number
+         * of bytes in the |value| field) which specify further match criteria (beyond the service
+         * name).
+         *
+         * The match behavior is specified in details in the NAN spec.
+         * Publisher: used if provided.
+         * Subscriber: used (if provided) only in ACTIVE sessions.
+         *
+         * Max length: |UsdCapabilities.maxMatchFilterLength|.
+         * NAN Spec: matching_filter_tx and Service Descriptor Attribute (SDA) / Matching Filter
+         */
+        @nullable byte[] txMatchFilter;
+
+        /**
+         * Ordered sequence of <length, value> pairs (|length| uses 1 byte and contains the number
+         * of bytes in the |value| field) which specify further match criteria (beyond the service
+         * name).
+         *
+         * The match behavior is specified in details in the NAN spec.
+         * Publisher: used in SOLICITED or SOLICITED_UNSOLICITED sessions.
+         * Subscriber: used in ACTIVE or PASSIVE sessions.
+         *
+         * Max length: |UsdCapabilities.maxMatchFilterLength|.
+         * NAN Spec: matching_filter_rx
+         */
+        @nullable byte[] rxMatchFilter;
+
+        /**
+         * Time interval (in seconds) that a USD session will be alive.
+         * The session will be terminated when the time to live (TTL) is reached, triggering either
+         * |IStaInterfaceCallback.onPublishTerminated| for Publish, or
+         * |IStaInterfaceCallback.onSubscribeTerminated| for Subscribe.
+         */
+        int ttlSec;
+
+        /**
+         * Frequency where the device should begin to dwell. Default value is channel 6 (2.437 GHz),
+         * but other values may be selected per regulation in the geographical location.
+         */
+        int defaultFreqMhz;
+
+        /**
+         * Channels which can be switched to. May contain any of the 20 MHz channels in the
+         * 2.4 Ghz and/or 5 Ghz bands, per regulation in the geographical location.
+         */
+        int[] freqsMhz;
+    }
+
+    /**
+     * Subscribe modes that this USD session can be configured in.
+     */
+    @Backing(type="byte")
+    enum UsdSubscribeType {
+        /**
+         * Subscribe function does not request transmission of any Subscribe messages, but checks
+         * for matches in received Publish messages.
+         */
+        PASSIVE_MODE = 0,
+        /**
+         * Subscribe function additionally requests transmission of Subscribe messages and processes
+         * Publish messages.
+         */
+        ACTIVE_MODE = 1,
+    }
+
+    /**
+     * Parameters for configuring a USD subscribe session.
+     */
+    parcelable UsdSubscribeConfig {
+        /**
+         * Base USD session parameters.
+         */
+        UsdBaseConfig baseConfig;
+
+        /**
+         * Subscribe mode that this session should be configured in.
+         */
+        UsdSubscribeType subscribeType;
+
+        /**
+         * Recommended periodicity (in milliseconds) of query transmissions for the session.
+         */
+        int queryPeriodMillis;
+    }
+
+    /**
+     * Type of USD publishing.
+     */
+    @Backing(type="byte")
+    enum UsdPublishType {
+        /**
+         * Only transmissions that are triggered by a specific event.
+         */
+        SOLICITED_ONLY = 0,
+
+        /**
+         * Only transmissions that are not requested.
+         */
+        UNSOLICITED_ONLY = 1,
+
+        /**
+         * Both solicited and unsolicited transmissions.
+         */
+        SOLICITED_AND_UNSOLICITED = 2,
+    }
+
+    /**
+     * Types of USD publish transmissions.
+     */
+    @Backing(type="byte")
+    enum UsdPublishTransmissionType {
+        /**
+         * Sends data from one device to a single, specific destination device.
+         */
+        UNICAST = 0,
+
+        /**
+         * Sends data from one device to a group of devices on the network simultaneously.
+         */
+        MULTICAST = 1,
+    }
+
+    /**
+     * Parameters for configuring a USD publish session.
+     */
+    parcelable UsdPublishConfig {
+        /**
+         * Base USD session parameters.
+         */
+        UsdBaseConfig baseConfig;
+
+        /**
+         * Types of transmissions (solicited vs. unsolicited) which should be generated.
+         */
+        UsdPublishType publishType;
+
+        /**
+         * Whether Further Service Discovery (FSD) is enabled.
+         */
+        boolean isFsd;
+
+        /**
+         * Interval (in milliseconds) for sending unsolicited publish transmissions.
+         */
+        int announcementPeriodMillis;
+
+        /**
+         * Type of the publish transmission (ex. unicast, multicast).
+         */
+        UsdPublishTransmissionType transmissionType;
+
+        /**
+         * Whether to enable publish replied events. If disabled, then
+         * |IStaInterfaceCallback.onUsdPublishReplied| will not be
+         * called for this session.
+         */
+        boolean eventsEnabled;
+    }
+
+    /**
+     * Register for callbacks on this interface.
+     *
+     * @param callback Callback object to invoke.
+     */
+    void registerCallback(in IStaInterfaceCallback callback);
+
+    /**
+     * Retrieve capabilities related to Unsynchronized Service Discovery (USD).
+     *
+     * @return Instance of |UsdCapabilities| containing the capability info.
+     */
+    UsdCapabilities getUsdCapabilities();
+
+    /**
+     * Start a USD publish session. Triggers a response via |IStaInterfaceCallback.onPublishStarted|
+     * if successful, or |IStaInterfaceCallback.onUsdPublishConfigFailed| if failed.
+     *
+     * @param cmdId Identifier for this request. Will be returned in the callback to identify
+     *              the request.
+     * @param publishConfig Parameters for the requested publish session.
+     * @throws ServiceSpecificException with one of the following values:
+     *         |SupplicantStatusCode.FAILURE_UNKNOWN|
+     *         |SupplicantStatusCode.FAILURE_UNSUPPORTED|
+     */
+    void startUsdPublish(in int cmdId, in UsdPublishConfig publishConfig);
+
+    /**
+     * Start a USD subscribe session. Triggers a response via
+     * |IStaInterfaceCallback.onSubscribeStarted| if successful, or
+     * |IStaInterfaceCallback.onUsdSubscribeConfigFailed| if failed.
+     *
+     * @param cmdId Identifier for this request. Will be returned in the callback to identify
+     *              the request.
+     * @param subscribeConfig Parameters for the requested subscribe session.
+     * @throws ServiceSpecificException with one of the following values:
+     *         |SupplicantStatusCode.FAILURE_UNKNOWN|
+     *         |SupplicantStatusCode.FAILURE_UNSUPPORTED|
+     */
+    void startUsdSubscribe(in int cmdId, in UsdSubscribeConfig subscribeConfig);
+
+    /**
+     * Update the service-specific info for an active publish session.
+     *
+     * @param publishId Identifier for the active publish session.
+     * @param serviceSpecificInfo Byte array containing the service-specific info. Note that the
+     *                            maximum info length is |UsdCapabilities.maxLocalSsiLengthBytes|.
+     * @throws ServiceSpecificException with one of the following values:
+     *         |SupplicantStatusCode.FAILURE_UNKNOWN|
+     *         |SupplicantStatusCode.FAILURE_UNSUPPORTED|
+     */
+    void updateUsdPublish(in int publishId, in byte[] serviceSpecificInfo);
+
+    /**
+     * Cancel an existing USD publish session.
+     * |IStaInterfaceCallback.onPublishTerminated| will be called upon completion.
+     *
+     * @param publishId Identifier for the publish session to cancel.
+     * @throws ServiceSpecificException with one of the following values:
+     *         |SupplicantStatusCode.FAILURE_UNKNOWN|
+     *         |SupplicantStatusCode.FAILURE_UNSUPPORTED|
+     */
+    void cancelUsdPublish(in int publishId);
+
+    /**
+     * Cancel an existing USD subscribe session.
+     * |IStaInterfaceCallback.onSubscribeTerminated| will be called upon completion.
+     *
+     * @param subscribeId Identifier for the subscribe session to cancel.
+     * @throws ServiceSpecificException with one of the following values:
+     *         |SupplicantStatusCode.FAILURE_UNKNOWN|
+     *         |SupplicantStatusCode.FAILURE_UNSUPPORTED|
+     */
+    void cancelUsdSubscribe(in int subscribeId);
+
+    /**
+     * Send a message to a peer device across an active USD link.
+     *
+     * @param messageInfo Information for the message to be sent.
+     * @throws ServiceSpecificException with one of the following values:
+     *         |SupplicantStatusCode.FAILURE_UNKNOWN|
+     *         |SupplicantStatusCode.FAILURE_UNSUPPORTED|
+     */
+    void sendUsdMessage(in UsdMessageInfo messageInfo);
+}
diff --git a/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IStaInterfaceCallback.aidl b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IStaInterfaceCallback.aidl
new file mode 100644
index 0000000000..6309925a03
--- /dev/null
+++ b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/IStaInterfaceCallback.aidl
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.system.wifi.mainline_supplicant;
+
+import android.system.wifi.mainline_supplicant.UsdMessageInfo;
+import android.system.wifi.mainline_supplicant.UsdServiceProtoType;
+
+/**
+ * Callback interface exposed by the mainline supplicant service
+ * for each station mode interface (IStaInterface).
+ *
+ * Clients need to host an instance of this AIDL interface object and
+ * pass a reference of the object to the mainline supplicant via the
+ * corresponding |IStaInterface.registerCallback| method.
+ */
+interface IStaInterfaceCallback {
+    /**
+     * Information about a USD discovery session with a specific peer.
+     */
+    @VintfStability
+    parcelable UsdServiceDiscoveryInfo {
+        /**
+         * Identifier for this device.
+         */
+        int ownId;
+
+        /**
+         * Identifier for the discovered peer device.
+         */
+        int peerId;
+
+        /**
+         * MAC address of the discovered peer device.
+         */
+        byte[6] peerMacAddress;
+
+        /**
+         * Match filter from the discovery packet (publish or subscribe) which caused service
+         * discovery.
+         */
+        byte[] matchFilter;
+
+        /**
+         * Service protocol that is being used (ex. Generic, CSA Matter).
+         */
+        UsdServiceProtoType serviceProtoType;
+
+        /**
+         * Arbitrary service specific information communicated in discovery packets.
+         * There is no semantic meaning to these bytes. They are passed-through from publisher to
+         * subscriber as-is with no parsing.
+         */
+        byte[] serviceSpecificInfo;
+
+        /**
+         * Whether Further Service Discovery (FSD) is enabled.
+         */
+        boolean isFsd;
+    }
+
+    /**
+     * Codes indicating the reason for terminating a USD session.
+     * Returned by |onUsdPublishTerminated| and |onUsdSubscribeTerminated|.
+     */
+    @Backing(type="int")
+    enum UsdTerminateReasonCode {
+        /**
+         * Unknown failure occurred.
+         */
+        FAILURE_UNKNOWN = 0,
+
+        /**
+         * The operation timed out.
+         */
+        TIMEOUT = 1,
+
+        /**
+         * The operation was requested by the user.
+         */
+        USER_REQUESTED = 2,
+
+        /**
+         * Invalid arguments were provided.
+         */
+        INVALID_ARGS = 3
+    }
+
+    /**
+     * Error codes returned by |onUsdPublishConfigFailed| and |onUsdSubscribeConfigFailed|.
+     */
+    @Backing(type="int")
+    enum UsdConfigErrorCode {
+        /**
+         * Unknown failure.
+         */
+        FAILURE_UNKNOWN = 0,
+        /**
+         * The requested operation timed out.
+         */
+        FAILURE_TIMEOUT = 1,
+        /**
+         * The requested operation is currently not available.
+         */
+        FAILURE_NOT_AVAILABLE = 2,
+    }
+
+    /**
+     * Called in response to |IUsdInterface.startPublish| to indicate that the
+     * publish session was started successfully.
+     *
+     * @param cmdId Identifier for the original request.
+     * @param publishId Identifier for the publish session.
+     */
+    void onUsdPublishStarted(in int cmdId, in int publishId);
+
+    /**
+     * Called in response to |IUsdInterface.startSubscribe| to indicate that the
+     * subscribe session was started successfully.
+     *
+     * @param cmdId Identifier for the original request.
+     * @param subscribeId Identifier for the subscribe session.
+     */
+    void onUsdSubscribeStarted(in int cmdId, in int subscribeId);
+
+    /**
+     * Called in response to |IUsdInterface.startPublish| to indicate that the
+     * publish session could not be configured.
+     *
+     * @param cmdId Identifier for the original request.
+     * @param errorCode Code indicating the failure reason.
+     */
+    void onUsdPublishConfigFailed(in int cmdId, in UsdConfigErrorCode errorCode);
+
+    /**
+     * Called in response to |IUsdInterface.startSubscribe| to indicate that the
+     * subscribe session could not be configured.
+     *
+     * @param cmdId Identifier for the original request.
+     * @param errorCode Code indicating the failure reason.
+     */
+    void onUsdSubscribeConfigFailed(in int cmdId, in UsdConfigErrorCode errorCode);
+
+    /**
+     * Called in response to |IUsdInterface.cancelPublish| to indicate that the session
+     * was cancelled successfully. May also be called unsolicited if the session terminated
+     * by supplicant.
+     *
+     * @param publishId Identifier for the publish session.
+     * @param reasonCode Code indicating the reason for the session cancellation.
+     */
+    void onUsdPublishTerminated(in int publishId, in UsdTerminateReasonCode reasonCode);
+
+    /**
+     * Called in response to |IUsdInterface.cancelSubscribe| to indicate that the session
+     * was cancelled successfully. May also be called unsolicited if the session terminated
+     * by supplicant.
+     *
+     * @param subscribeId Identifier for the subscribe session.
+     * @param reasonCode Code indicating the reason for the session cancellation.
+     */
+    void onUsdSubscribeTerminated(in int subscribeId, in UsdTerminateReasonCode reasonCode);
+
+    /**
+     * Indicates that the publisher sent solicited publish message to the subscriber.
+     *
+     * @param info Instance of |UsdServiceDiscoveryInfo| containing information about the reply.
+     */
+    void onUsdPublishReplied(in UsdServiceDiscoveryInfo info);
+
+    /**
+     * Indicates that a publisher was discovered. Only called if this device is acting as a
+     * subscriber.
+     *
+     * @param info Instance of |UsdServiceDiscoveryInfo| containing information about the service.
+     */
+    void onUsdServiceDiscovered(in UsdServiceDiscoveryInfo info);
+
+    /**
+     * Indicates that a message was received on an active USD link.
+     *
+     * @param messageInfo Information about the message that was received.
+     */
+    void onUsdMessageReceived(in UsdMessageInfo messageInfo);
+}
diff --git a/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/SupplicantStatusCode.aidl b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/SupplicantStatusCode.aidl
index 2086bc884c..11bd6ca937 100644
--- a/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/SupplicantStatusCode.aidl
+++ b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/SupplicantStatusCode.aidl
@@ -40,4 +40,8 @@ enum SupplicantStatusCode {
      * Interface with the provided name does not exist.
      */
     FAILURE_IFACE_UNKNOWN = 4,
+    /**
+     * Operation is not supported by the service.
+     */
+    FAILURE_UNSUPPORTED = 5,
 }
diff --git a/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/UsdMessageInfo.aidl b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/UsdMessageInfo.aidl
new file mode 100644
index 0000000000..0b26d6540c
--- /dev/null
+++ b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/UsdMessageInfo.aidl
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.system.wifi.mainline_supplicant;
+
+/**
+ * Information for sending a USD message.
+ */
+parcelable UsdMessageInfo {
+    /**
+     * Identifier for this device, retrieved from |ServiceDiscoveryInfo|.
+     */
+    int ownId;
+
+    /**
+     * Identifier for the peer device, retrieved from |ServiceDiscoveryInfo|.
+     */
+    int peerId;
+
+    /**
+     * MAC address for the peer device.
+     */
+    byte[6] peerMacAddress;
+
+    /**
+     * Message contents. Note that the maximum message length is
+     * |UsdCapabilities.maxLocalSsiLengthBytes|.
+     */
+    byte[] message;
+}
diff --git a/framework/java/android/net/wifi/usd/IAvailabilityCallback.aidl b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/UsdServiceProtoType.aidl
similarity index 58%
rename from framework/java/android/net/wifi/usd/IAvailabilityCallback.aidl
rename to aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/UsdServiceProtoType.aidl
index 691ec093ef..4e6bbe7392 100644
--- a/framework/java/android/net/wifi/usd/IAvailabilityCallback.aidl
+++ b/aidl/mainline_supplicant/android/system/wifi/mainline_supplicant/UsdServiceProtoType.aidl
@@ -14,20 +14,28 @@
  * limitations under the License.
  */
 
-package android.net.wifi.usd;
+package android.system.wifi.mainline_supplicant;
 
 /**
- * Interface for USD availability callback.
- *
- * @hide
+ * Service protocols that use USD.
  */
-oneway interface IAvailabilityCallback {
+@Backing(type="int")
+enum UsdServiceProtoType {
     /**
-     * Called when subscriber is available
+     * Unknown service type.
      */
-    void onSubscriberAvailable();
+    UNKNOWN = 0,
+
+    /**
+     * Generic service.
+     */
+    GENERIC = 1,
+
     /**
-     * Called when publisher is available
+     * CSA (Connectivity Standards Alliance) Matter.
+     *
+     * Note: CSA Matter is an open-source, royalty-free standard for smart home technology that
+     * allows devices to work with any Matter-certified ecosystem.
      */
-    void onPublisherAvailable();
+    CSA_MATTER = 2,
 }
diff --git a/flags/Android.bp b/flags/Android.bp
index 99ba39a590..3052a39aef 100644
--- a/flags/Android.bp
+++ b/flags/Android.bp
@@ -37,6 +37,7 @@ java_aconfig_library {
         "//frameworks/opt/net/wifi/libs/WifiTrackerLib:__subpackages__",
         "//packages/modules/Wifi:__subpackages__",
         "//cts/tests/tests/wifi:__subpackages__",
+        "//cts/tests/tests/security",
     ],
 }
 
diff --git a/flags/wifi_flags.aconfig b/flags/wifi_flags.aconfig
index e914e9d225..edaf96cd37 100644
--- a/flags/wifi_flags.aconfig
+++ b/flags/wifi_flags.aconfig
@@ -8,22 +8,6 @@ flag {
     bug: "301145404"
 }
 
-flag {
-    name: "p2p_ownership"
-    namespace: "wifi"
-    description: "Control the P2P group ownership feature"
-    bug: "215045910"
-    is_fixed_read_only: true
-}
-
-flag {
-    name: "p2p_dual"
-    namespace: "wifi"
-    description: "Control the dual P2P group feature"
-    bug: "296063280"
-    is_fixed_read_only: true
-}
-
 flag {
     name: "delay_save_to_store"
     namespace: "wifi"
@@ -279,3 +263,22 @@ flag {
     bug: "349253691"
     is_fixed_read_only: true
 }
+
+
+flag {
+    name: "multiple_mld_on_sap_supported"
+    is_exported: false
+    namespace: "wifi"
+    description: "Check driver capability when determining the number of supported MLD"
+    bug: "382023801"
+    is_fixed_read_only: true
+}
+
+flag {
+    name: "monitor_intent_for_all_users"
+    is_exported: false
+    namespace: "wifi"
+    description: "IntentReceiver should monitor intent from all users"
+    bug: "390257834"
+    is_fixed_read_only: true
+}
diff --git a/framework/Android.bp b/framework/Android.bp
index c0280f0988..40e1003792 100644
--- a/framework/Android.bp
+++ b/framework/Android.bp
@@ -111,6 +111,7 @@ java_defaults {
         "PlatformProperties",
         "android.net.wifi.flags-aconfig-java",
         "ranging_aconfig_flags_lib",
+        "android.security.flags-aconfig-java-export",
     ],
     libs: [
         "androidx.annotation_annotation",
@@ -121,7 +122,6 @@ java_defaults {
         // library for generated flag code read new storage
         "aconfig_storage_stub",
         "framework-configinfrastructure.stubs.module_lib",
-        "android.security.flags-aconfig-java-export",
     ],
     aidl: {
         generate_get_transaction_name: true,
diff --git a/framework/api/current.txt b/framework/api/current.txt
index 41062f1c6b..c8d8685bf8 100644
--- a/framework/api/current.txt
+++ b/framework/api/current.txt
@@ -1295,7 +1295,7 @@ package android.net.wifi.p2p {
     method @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") @Nullable public android.net.wifi.p2p.WifiP2pPairingBootstrappingConfig getPairingBootstrappingConfig();
     method @Nullable public String getPassphrase();
     method @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") public int getPccModeConnectionType();
-    method @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") public boolean isAuthorizeConnectionFromPeer();
+    method @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") public boolean isAuthorizeConnectionFromPeerEnabled();
     method @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") public void setGroupOwnerVersion(int);
     method public void writeToParcel(android.os.Parcel, int);
     field @NonNull public static final android.os.Parcelable.Creator<android.net.wifi.p2p.WifiP2pConfig> CREATOR;
@@ -1322,7 +1322,7 @@ package android.net.wifi.p2p {
     ctor public WifiP2pConfig.Builder();
     method @NonNull public android.net.wifi.p2p.WifiP2pConfig build();
     method @NonNull public android.net.wifi.p2p.WifiP2pConfig.Builder enablePersistentMode(boolean);
-    method @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") @NonNull public android.net.wifi.p2p.WifiP2pConfig.Builder setAuthorizeConnectionFromPeer(boolean);
+    method @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") @NonNull public android.net.wifi.p2p.WifiP2pConfig.Builder setAuthorizeConnectionFromPeerEnabled(boolean);
     method @NonNull public android.net.wifi.p2p.WifiP2pConfig.Builder setDeviceAddress(@Nullable android.net.MacAddress);
     method @NonNull public android.net.wifi.p2p.WifiP2pConfig.Builder setGroupClientIpProvisioningMode(int);
     method @NonNull public android.net.wifi.p2p.WifiP2pConfig.Builder setGroupOperatingBand(int);
@@ -1640,7 +1640,7 @@ package android.net.wifi.p2p {
   public static final class WifiP2pUsdBasedLocalServiceAdvertisementConfig.Builder {
     ctor public WifiP2pUsdBasedLocalServiceAdvertisementConfig.Builder();
     method @NonNull public android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig build();
-    method @NonNull public android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig.Builder setFrequencyMhz(@IntRange(from=0) int);
+    method @NonNull public android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig.Builder setFrequencyMhz(@IntRange(from=1) int);
   }
 
   @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") public final class WifiP2pUsdBasedServiceDiscoveryConfig implements android.os.Parcelable {
@@ -1751,6 +1751,7 @@ package android.net.wifi.p2p.nsd {
   @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") public final class WifiP2pUsdBasedServiceConfig implements android.os.Parcelable {
     ctor public WifiP2pUsdBasedServiceConfig();
     method public int describeContents();
+    method public static int getMaxAllowedServiceSpecificInfoLength();
     method @NonNull public String getServiceName();
     method @IntRange(from=0, to=255) public int getServiceProtocolType();
     method @Nullable public byte[] getServiceSpecificInfo();
@@ -1761,10 +1762,10 @@ package android.net.wifi.p2p.nsd {
   }
 
   public static final class WifiP2pUsdBasedServiceConfig.Builder {
-    ctor public WifiP2pUsdBasedServiceConfig.Builder(@NonNull String);
+    ctor public WifiP2pUsdBasedServiceConfig.Builder(@NonNull @Size(min=1) String);
     method @NonNull public android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig build();
     method @NonNull public android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig.Builder setServiceProtocolType(@IntRange(from=0, to=255) int);
-    method @NonNull public android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig.Builder setServiceSpecificInfo(@Nullable byte[]);
+    method @NonNull public android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig.Builder setServiceSpecificInfo(@Nullable @Size(min=1) byte[]);
   }
 
   @FlaggedApi("com.android.wifi.flags.wifi_direct_r2") public final class WifiP2pUsdBasedServiceResponse implements android.os.Parcelable {
diff --git a/framework/api/system-current.txt b/framework/api/system-current.txt
index 55bd9eb3a4..937fbe95bc 100644
--- a/framework/api/system-current.txt
+++ b/framework/api/system-current.txt
@@ -1528,7 +1528,7 @@ package android.net.wifi.aware {
   }
 
   public final class Characteristics implements android.os.Parcelable {
-    method @FlaggedApi("com.android.ranging.flags.ranging_rtt_enabled") public int getMaxSupportedRangingPktBandwidth();
+    method @FlaggedApi("com.android.ranging.flags.ranging_rtt_enabled") public int getMaxSupportedRangingPacketBandwidth();
     method @FlaggedApi("com.android.ranging.flags.ranging_rtt_enabled") public int getMaxSupportedRxChains();
     method @FlaggedApi("com.android.ranging.flags.ranging_rtt_enabled") public boolean isPeriodicRangingSupported();
     field @FlaggedApi("com.android.ranging.flags.ranging_rtt_enabled") public static final int SUPPORTED_RX_CHAINS_1 = 1; // 0x1
@@ -2015,17 +2015,12 @@ package android.net.wifi.usd {
 
   @FlaggedApi("android.net.wifi.flags.usd") public class UsdManager {
     method @Nullable @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public android.net.wifi.usd.Characteristics getCharacteristics();
-    method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public boolean isPublisherAvailable();
-    method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public boolean isSubscriberAvailable();
     method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public void publish(@NonNull android.net.wifi.usd.PublishConfig, @NonNull java.util.concurrent.Executor, @NonNull android.net.wifi.usd.PublishSessionCallback);
-    method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public void registerAvailabilityCallback(@NonNull java.util.concurrent.Executor, @NonNull android.net.wifi.usd.UsdManager.AvailabilityCallback);
+    method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public void registerPublisherStatusListener(@NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<java.lang.Boolean>);
+    method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public void registerSubscriberStatusListener(@NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<java.lang.Boolean>);
     method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public void subscribe(@NonNull android.net.wifi.usd.SubscribeConfig, @NonNull java.util.concurrent.Executor, @NonNull android.net.wifi.usd.SubscribeSessionCallback);
-    method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public void unregisterAvailabilityCallback(@NonNull android.net.wifi.usd.UsdManager.AvailabilityCallback);
-  }
-
-  public static interface UsdManager.AvailabilityCallback {
-    method public default void onPublisherAvailable();
-    method public default void onSubscriberAvailable();
+    method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public void unregisterPublisherStatusListener(@NonNull java.util.function.Consumer<java.lang.Boolean>);
+    method @RequiresPermission(android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION) public void unregisterSubscriberStatusListener(@NonNull java.util.function.Consumer<java.lang.Boolean>);
   }
 
 }
diff --git a/framework/jarjar-rules.txt b/framework/jarjar-rules.txt
index dbd5811d7d..c842b0bb26 100644
--- a/framework/jarjar-rules.txt
+++ b/framework/jarjar-rules.txt
@@ -104,6 +104,10 @@ rule android.security.*FeatureFlags* com.android.wifi.x.@0
 rule android.security.FeatureFlags* com.android.wifi.x.@0
 rule android.security.Flags com.android.wifi.x.@0
 
+rule com.android.internal.telephony.flags.*FeatureFlags* com.android.wifi.x.@0
+rule com.android.internal.telephony.flags.FeatureFlags* com.android.wifi.x.@0
+rule com.android.internal.telephony.flags.Flags com.android.wifi.x.@0
+
 # Use our statically linked bouncy castle library
 rule org.bouncycastle.** com.android.wifi.x.@0
 # Use our statically linked protobuf library
diff --git a/framework/java/android/net/wifi/IWifiManager.aidl b/framework/java/android/net/wifi/IWifiManager.aidl
index 2382f94382..9e126e3c95 100644
--- a/framework/java/android/net/wifi/IWifiManager.aidl
+++ b/framework/java/android/net/wifi/IWifiManager.aidl
@@ -228,9 +228,10 @@ interface IWifiManager {
 
     boolean isMulticastEnabled();
 
-    void acquireMulticastLock(IBinder binder, String tag);
+    void acquireMulticastLock(
+            IBinder binder, String lockTag, String attributionTag, String packageName);
 
-    void releaseMulticastLock(IBinder binder, String tag);
+    void releaseMulticastLock(IBinder binder, String lockTag);
 
     void updateInterfaceIpState(String ifaceName, int mode);
 
diff --git a/framework/java/android/net/wifi/IWifiScannerListener.aidl b/framework/java/android/net/wifi/IWifiScannerListener.aidl
index bd19ac2d0f..74b22a1bbf 100644
--- a/framework/java/android/net/wifi/IWifiScannerListener.aidl
+++ b/framework/java/android/net/wifi/IWifiScannerListener.aidl
@@ -15,14 +15,14 @@
 
 package android.net.wifi;
 
-import android.net.wifi.WifiScanner;
 import android.net.wifi.ScanResult;
+import android.net.wifi.WifiScanner;
+import com.android.modules.utils.ParceledListSlice;
 
 /**
  * @hide
  */
-oneway interface IWifiScannerListener
-{
+oneway interface IWifiScannerListener {
     void onSuccess();
 
     void onFailure(int reason, String description);
@@ -46,5 +46,5 @@ oneway interface IWifiScannerListener
     /**
      * reports full scan result for all access points found in scan
      */
-    void onFullResults(in List<ScanResult> scanResult);
-}
\ No newline at end of file
+    void onFullResults(in ParceledListSlice<ScanResult> scanResult);
+}
diff --git a/framework/java/android/net/wifi/ScanResult.java b/framework/java/android/net/wifi/ScanResult.java
index a93ab7b41e..e4c91c4c75 100644
--- a/framework/java/android/net/wifi/ScanResult.java
+++ b/framework/java/android/net/wifi/ScanResult.java
@@ -32,6 +32,8 @@ import android.os.Parcel;
 import android.os.Parcelable;
 import android.util.Log;
 
+import androidx.annotation.Keep;
+
 import com.android.modules.utils.build.SdkLevel;
 import com.android.wifi.flags.Flags;
 
@@ -440,6 +442,12 @@ public final class ScanResult implements Parcelable {
      */
     @SystemApi
     public static final int CIPHER_BIP_CMAC_256 = 9;
+    /**
+     * @hide
+     * Cipher suite: CCMP_256
+     */
+    public static final int CIPHER_CCMP_256 = 10;
+
 
     /**
      * The detected signal level in dBm, also known as the RSSI.
@@ -979,6 +987,7 @@ public final class ScanResult implements Parcelable {
      *
      * @hide
      */
+    @Keep
     public static boolean is24GHz(int freqMhz) {
         return freqMhz >= BAND_24_GHZ_START_FREQ_MHZ && freqMhz <= BAND_24_GHZ_END_FREQ_MHZ;
     }
@@ -990,6 +999,7 @@ public final class ScanResult implements Parcelable {
      *
      * @hide
      */
+    @Keep
     public static boolean is5GHz(int freqMhz) {
         return freqMhz >=  BAND_5_GHZ_START_FREQ_MHZ && freqMhz <= BAND_5_GHZ_END_FREQ_MHZ;
     }
@@ -1001,6 +1011,7 @@ public final class ScanResult implements Parcelable {
      *
      * @hide
      */
+    @Keep
     public static boolean is6GHz(int freqMhz) {
         if (freqMhz == BAND_6_GHZ_OP_CLASS_136_CH_2_FREQ_MHZ) {
             return true;
diff --git a/framework/java/android/net/wifi/SoftApCapability.java b/framework/java/android/net/wifi/SoftApCapability.java
index e52ed530eb..151c07c63e 100644
--- a/framework/java/android/net/wifi/SoftApCapability.java
+++ b/framework/java/android/net/wifi/SoftApCapability.java
@@ -26,6 +26,8 @@ import android.net.wifi.SoftApConfiguration.BandType;
 import android.os.Parcel;
 import android.os.Parcelable;
 
+import androidx.annotation.Keep;
+
 import com.android.wifi.flags.Flags;
 
 import java.lang.annotation.Retention;
@@ -271,6 +273,7 @@ public final class SoftApCapability implements Parcelable {
      * @throws IllegalArgumentException when band type is invalid.
      * @hide
      */
+    @Keep
     public boolean setSupportedChannelList(@BandType int band,
             @Nullable int[] supportedChannelList) {
         if (supportedChannelList == null)  return false;
diff --git a/framework/java/android/net/wifi/SoftApConfiguration.java b/framework/java/android/net/wifi/SoftApConfiguration.java
index 2a51231fa0..086c816b71 100644
--- a/framework/java/android/net/wifi/SoftApConfiguration.java
+++ b/framework/java/android/net/wifi/SoftApConfiguration.java
@@ -35,6 +35,7 @@ import android.text.TextUtils;
 import android.util.Log;
 import android.util.SparseIntArray;
 
+import androidx.annotation.Keep;
 import androidx.annotation.RequiresApi;
 import androidx.annotation.VisibleForTesting;
 
@@ -869,6 +870,7 @@ public final class SoftApConfiguration implements Parcelable {
      *
      * @hide
      */
+    @Keep
     public @NonNull int[] getBands() {
         int[] bands = new int[mChannels.size()];
         for (int i = 0; i < bands.length; i++) {
@@ -1424,6 +1426,45 @@ public final class SoftApConfiguration implements Parcelable {
             mIsClientIsolationEnabled = other.mIsClientIsolationEnabled;
         }
 
+       /**
+         * Builds the {@link SoftApConfiguration} without any check.
+         *
+         * @return A new {@link SoftApConfiguration}, as configured by previous method calls.
+         *
+         * @hide
+         */
+        @VisibleForTesting
+        @NonNull
+        public SoftApConfiguration buildWithoutCheck() {
+            return new SoftApConfiguration(
+                    mWifiSsid,
+                    mBssid,
+                    mPassphrase,
+                    mHiddenSsid,
+                    mChannels,
+                    mSecurityType,
+                    mMaxNumberOfClients,
+                    mAutoShutdownEnabled,
+                    mShutdownTimeoutMillis,
+                    mClientControlByUser,
+                    mBlockedClientList,
+                    mAllowedClientList,
+                    mMacRandomizationSetting,
+                    mBridgedModeOpportunisticShutdownEnabled,
+                    mIeee80211axEnabled,
+                    mIeee80211beEnabled,
+                    mIsUserConfiguration,
+                    mBridgedModeOpportunisticShutdownTimeoutMillis,
+                    mVendorElements,
+                    mPersistentRandomizedMacAddress,
+                    mAllowedAcsChannels2g,
+                    mAllowedAcsChannels5g,
+                    mAllowedAcsChannels6g,
+                    mMaxChannelBandwidth,
+                    mVendorData,
+                    mIsClientIsolationEnabled);
+        }
+
         /**
          * Builds the {@link SoftApConfiguration}.
          *
@@ -1449,6 +1490,11 @@ public final class SoftApConfiguration implements Parcelable {
                     REMOVE_ZERO_FOR_TIMEOUT_SETTING) && mShutdownTimeoutMillis == DEFAULT_TIMEOUT) {
                 mShutdownTimeoutMillis = 0; // Use 0 for legacy app.
             }
+
+            if (SdkLevel.isAtLeastB() && !mIeee80211axEnabled) {
+                // Force 11BE to false since 11ax has dependency with 11AX.
+                mIeee80211beEnabled = false;
+            }
             return new SoftApConfiguration(
                     mWifiSsid,
                     mBssid,
@@ -1818,41 +1864,21 @@ public final class SoftApConfiguration implements Parcelable {
         /**
          * Specifies the channels and associated bands for the APs.
          * <p>
-         * When more than 1 channel is set, this will bring up concurrent APs on the requested
-         * channels and bands (if possible).
-         * <p>
-         * Valid channels are country dependent.
-         * The {@code SoftApCapability#getSupportedChannelList(int)} can be used to obtain
-         * valid channels in each band.
-         * <p>
-         * Use {@link WifiManager#isBridgedApConcurrencySupported()} to determine
-         * whether or not concurrent APs are supported.
-         *
-         * <p>
-         * If not set, the default for the channel is the special value 0 which has the framework
-         * auto-select a valid channel from the band configured with {@code #setBands(int[])}.
-         * <p>
-         * The channel auto selection will be offloaded to driver when
-         * {@code SoftApCapability#areFeaturesSupported(long)}
-         * with {@code SoftApCapability.SOFTAP_FEATURE_ACS_OFFLOAD}
-         * returns true. The driver will auto select the best channel (e.g. best performance)
-         * based on environment interference. Check {@code SoftApCapability} for more detail.
-         * <p>
-         * Requires the driver to support {@code SoftApCapability.SOFTAP_FEATURE_ACS_OFFLOAD}
-         * when multiple bands are configured without specified channel value (i.e. channel is
-         * the special value 0). Otherwise,
-         * {@code WifiManager#startTetheredHotspot(SoftApConfiguration)} will report error code
-         * {@code WifiManager#SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION}.
-         * <p>
-         * Note: Only supports 2.4GHz + 5GHz bands. If any other band is set, will report error
-         * {@code WifiManager#SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION}.
-         * <p>
          * The API contains (band, channel) input since the 6GHz band uses the same channel
          * numbering scheme as is used in the 2.4GHz and 5GHz band. Therefore, both are needed to
          * uniquely identify individual channels.
          * <p>
          * Reference the Wi-Fi channel numbering and the channelization in IEEE 802.11-2016
          * specifications, section 17.3.8.4.2, 17.3.8.4.3 and Table 15-6.
+         * <p>
+         * Using the special value 0 which has the framework auto-select a valid channel
+         * from the band configured.
+         * When more than 1 channel/band is set, this will bring up concurrent APs on the requested
+         * channels and bands (if possible).
+         * Use {@link WifiManager#isBridgedApConcurrencySupported()} to determine
+         * whether concurrent APs are supported.
+         * If not set, the default value is {@link #BAND_2GHZ} with the special channel value 0
+         * which has the framework auto-select from {@link #BAND_2GHZ}.
          *
          * <p>
          * @param channels SparseIntArray (key: {@code #BandType} , value: channel) consists of
diff --git a/framework/java/android/net/wifi/SoftApInfo.java b/framework/java/android/net/wifi/SoftApInfo.java
index fac3fd428c..3e974c06fe 100644
--- a/framework/java/android/net/wifi/SoftApInfo.java
+++ b/framework/java/android/net/wifi/SoftApInfo.java
@@ -454,7 +454,7 @@ public final class SoftApInfo implements Parcelable {
         sbuf.append(", mApInstanceIdentifier= ").append(mApInstanceIdentifier);
         sbuf.append(", mIdleShutdownTimeoutMillis= ").append(mIdleShutdownTimeoutMillis);
         sbuf.append(", mVendorData= ").append(mVendorData);
-        if (mMldAddress != null) sbuf.append(",mMldAddress=").append(mBssid.toString());
+        if (mMldAddress != null) sbuf.append(",mMldAddress=").append(mMldAddress.toString());
         sbuf.append("}");
         return sbuf.toString();
     }
diff --git a/framework/java/android/net/wifi/SupplicantState.java b/framework/java/android/net/wifi/SupplicantState.java
index de7e2b556b..eee70a2bc8 100644
--- a/framework/java/android/net/wifi/SupplicantState.java
+++ b/framework/java/android/net/wifi/SupplicantState.java
@@ -19,6 +19,8 @@ package android.net.wifi;
 import android.os.Parcel;
 import android.os.Parcelable;
 
+import androidx.annotation.Keep;
+
 /**
  * From <code>defs.h</code> in <code>wpa_supplicant</code>.
  * <p/>
@@ -195,6 +197,7 @@ public enum SupplicantState implements Parcelable {
     }
 
     /** @hide */
+    @Keep
     public static boolean isConnecting(SupplicantState state) {
         switch(state) {
             case AUTHENTICATING:
diff --git a/framework/java/android/net/wifi/WifiConfiguration.java b/framework/java/android/net/wifi/WifiConfiguration.java
index 88582dde76..028756862c 100644
--- a/framework/java/android/net/wifi/WifiConfiguration.java
+++ b/framework/java/android/net/wifi/WifiConfiguration.java
@@ -45,6 +45,7 @@ import android.text.TextUtils;
 import android.util.Log;
 import android.util.SparseArray;
 
+import androidx.annotation.Keep;
 import androidx.annotation.RequiresApi;
 
 import com.android.internal.annotations.VisibleForTesting;
@@ -664,6 +665,7 @@ public class WifiConfiguration implements Parcelable {
      *
      * @hide
      */
+    @Keep
     public void addSecurityParams(@SecurityType int securityType) {
         // This ensures that there won't be duplicate security types.
         for (SecurityParams params : mSecurityParamsList) {
@@ -738,6 +740,7 @@ public class WifiConfiguration implements Parcelable {
      * If there is no security params, generate one according to legacy fields.
      * @hide
      */
+    @Keep
     public void convertLegacyFieldsToSecurityParamsIfNeeded() {
         if (!mSecurityParamsList.isEmpty()) return;
         if (allowedKeyManagement.get(KeyMgmt.WAPI_CERT)) {
@@ -886,6 +889,7 @@ public class WifiConfiguration implements Parcelable {
      * @return true if there is a security params matches the type.
      * @hide
      */
+    @Keep
     public boolean isSecurityType(@SecurityType int securityType) {
         for (SecurityParams p : mSecurityParamsList) {
             if (p.isSecurityType(securityType)) {
@@ -913,6 +917,7 @@ public class WifiConfiguration implements Parcelable {
      * @return the default security params.
      * @hide
      */
+    @Keep
     public @NonNull SecurityParams getDefaultSecurityParams() {
         return new SecurityParams(mSecurityParamsList.get(0));
     }
@@ -2721,6 +2726,7 @@ public class WifiConfiguration implements Parcelable {
         }
 
         /** @hide */
+        @Keep
         public boolean hasNeverDetectedCaptivePortal() {
             return mHasNeverDetectedCaptivePortal;
         }
@@ -3943,6 +3949,7 @@ public class WifiConfiguration implements Parcelable {
 
     /** @hide */
     @UnsupportedAppUsage
+    @Keep
     public void setStaticIpConfiguration(StaticIpConfiguration staticIpConfiguration) {
         mIpConfiguration.setStaticIpConfiguration(staticIpConfiguration);
     }
@@ -3953,12 +3960,14 @@ public class WifiConfiguration implements Parcelable {
      */
     @NonNull
     @UnsupportedAppUsage
+    @Keep
     public IpConfiguration.IpAssignment getIpAssignment() {
         return mIpConfiguration.getIpAssignment();
     }
 
     /** @hide */
     @UnsupportedAppUsage
+    @Keep
     public void setIpAssignment(IpConfiguration.IpAssignment ipAssignment) {
         mIpConfiguration.setIpAssignment(ipAssignment);
     }
@@ -4466,6 +4475,7 @@ public class WifiConfiguration implements Parcelable {
      * @return true if preSharedKey is needed, false otherwise.
      * @hide
      */
+    @Keep
     public boolean needsPreSharedKey() {
         for (SecurityParams params : mSecurityParamsList) {
             if (params.isSecurityType(SECURITY_TYPE_PSK)
@@ -4526,6 +4536,7 @@ public class WifiConfiguration implements Parcelable {
      * @return true if preSharedKey encryption is needed, false otherwise.
      * @hide
      */
+    @Keep
     public boolean hasPreSharedKeyChanged() {
         return mHasPreSharedKeyChanged;
     }
diff --git a/framework/java/android/net/wifi/WifiFrameworkInitializer.java b/framework/java/android/net/wifi/WifiFrameworkInitializer.java
index d6117ba565..e942d74f74 100644
--- a/framework/java/android/net/wifi/WifiFrameworkInitializer.java
+++ b/framework/java/android/net/wifi/WifiFrameworkInitializer.java
@@ -29,10 +29,6 @@ import android.net.wifi.rtt.WifiRttManager;
 import android.net.wifi.usd.IUsdManager;
 import android.net.wifi.usd.UsdManager;
 import android.net.wifi.util.Environment;
-import android.os.HandlerThread;
-import android.os.Looper;
-
-import androidx.annotation.VisibleForTesting;
 
 /**
  * Class for performing registration for all Wifi services.
@@ -41,32 +37,6 @@ import androidx.annotation.VisibleForTesting;
  */
 @SystemApi
 public class WifiFrameworkInitializer {
-
-    /**
-     * A class implementing the lazy holder idiom: the unique static instance
-     * of {@link #INSTANCE} is instantiated in a thread-safe way (guaranteed by
-     * the language specs) the first time that NoPreloadHolder is referenced in getInstanceLooper().
-     *
-     * This is necessary because we can't spawn a new thread in {@link #registerServiceWrappers()}.
-     * {@link #registerServiceWrappers()} is called during the Zygote phase, which disallows
-     * spawning new threads. Naming the class "NoPreloadHolder" ensures that the classloader will
-     * not preload this class, inadvertently spawning the thread too early.
-     */
-    private static class NoPreloadHolder {
-        private static final HandlerThread INSTANCE = createInstance();
-
-        private static HandlerThread createInstance() {
-            HandlerThread thread = new HandlerThread("WifiManagerThread");
-            thread.start();
-            return thread;
-        }
-    }
-    /** @hide */
-    @VisibleForTesting
-    public static Looper getInstanceLooper() {
-        return NoPreloadHolder.INSTANCE.getLooper();
-    }
-
     private WifiFrameworkInitializer() {}
 
     /**
@@ -86,7 +56,7 @@ public class WifiFrameworkInitializer {
                         return null;
                     }
                     IWifiManager service = IWifiManager.Stub.asInterface(serviceBinder);
-                    return new WifiManager(context, service, getInstanceLooper());
+                    return new WifiManager(context, service);
                 }
         );
         SystemServiceRegistry.registerContextAwareService(
@@ -122,7 +92,7 @@ public class WifiFrameworkInitializer {
                         return null;
                     }
                     IWifiScanner service = IWifiScanner.Stub.asInterface(serviceBinder);
-                    return new WifiScanner(context, service, getInstanceLooper());
+                    return new WifiScanner(context, service);
                 }
         );
         SystemServiceRegistry.registerContextAwareService(
@@ -152,10 +122,10 @@ public class WifiFrameworkInitializer {
         if (Flags.usd() && Environment.isSdkAtLeastB()) {
             SystemServiceRegistry.registerContextAwareService(
                     Context.WIFI_USD_SERVICE,
-                    UsdManager.class,
-                    (context, serviceBinder) -> {
-                        if (!context.getPackageManager().hasSystemFeature(
-                                PackageManager.FEATURE_WIFI)) {
+                    UsdManager.class, (context, serviceBinder) -> {
+                        if (!context.getResources().getBoolean(
+                                context.getResources().getIdentifier("config_deviceSupportsWifiUsd",
+                                        "bool", "android"))) {
                             return null;
                         }
                         IUsdManager service = IUsdManager.Stub.asInterface(serviceBinder);
diff --git a/framework/java/android/net/wifi/WifiInfo.java b/framework/java/android/net/wifi/WifiInfo.java
index 11be2118d4..2b34b7b80b 100644
--- a/framework/java/android/net/wifi/WifiInfo.java
+++ b/framework/java/android/net/wifi/WifiInfo.java
@@ -44,6 +44,7 @@ import android.telephony.SubscriptionManager;
 import android.text.TextUtils;
 import android.util.SparseArray;
 
+import androidx.annotation.Keep;
 import androidx.annotation.RequiresApi;
 
 import com.android.modules.utils.build.SdkLevel;
@@ -1147,6 +1148,7 @@ public class WifiInfo implements TransportInfo, Parcelable {
     /**
      * @hide
      */
+    @Keep
     public boolean is24GHz() {
         return ScanResult.is24GHz(mFrequency);
     }
@@ -1154,6 +1156,7 @@ public class WifiInfo implements TransportInfo, Parcelable {
     /**
      * @hide
      */
+    @Keep
     @UnsupportedAppUsage
     public boolean is5GHz() {
         return ScanResult.is5GHz(mFrequency);
@@ -1162,6 +1165,7 @@ public class WifiInfo implements TransportInfo, Parcelable {
     /**
      * @hide
      */
+    @Keep
     public boolean is6GHz() {
         return ScanResult.is6GHz(mFrequency);
     }
@@ -1212,6 +1216,7 @@ public class WifiInfo implements TransportInfo, Parcelable {
 
     /** @hide */
     @UnsupportedAppUsage
+    @Keep
     public boolean getMeteredHint() {
         return mMeteredHint;
     }
@@ -1531,6 +1536,7 @@ public class WifiInfo implements TransportInfo, Parcelable {
     /** @hide */
     @UnsupportedAppUsage
     @Nullable
+    @Keep
     public static String removeDoubleQuotes(@Nullable String string) {
         if (string == null) return null;
         final int length = string.length();
diff --git a/framework/java/android/net/wifi/WifiManager.java b/framework/java/android/net/wifi/WifiManager.java
index c1e6646eeb..c642e04dc8 100644
--- a/framework/java/android/net/wifi/WifiManager.java
+++ b/framework/java/android/net/wifi/WifiManager.java
@@ -46,6 +46,7 @@ import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
+import android.content.pm.PackageManager;
 import android.net.ConnectivityManager;
 import android.net.ConnectivityManager.NetworkCallback;
 import android.net.DhcpInfo;
@@ -81,6 +82,7 @@ import android.os.RemoteException;
 import android.os.WorkSource;
 import android.os.connectivity.WifiActivityEnergyInfo;
 import android.security.advancedprotection.AdvancedProtectionFeature;
+import android.security.advancedprotection.AdvancedProtectionManager;
 import android.telephony.SubscriptionInfo;
 import android.text.TextUtils;
 import android.util.ArraySet;
@@ -2216,15 +2218,12 @@ public class WifiManager {
      *
      * @param context the application context
      * @param service the Binder interface
-     * @param looper the Looper used to deliver callbacks
      * @hide - hide this because it takes in a parameter of type IWifiManager, which
      * is a system private class.
      */
-    public WifiManager(@NonNull Context context, @NonNull IWifiManager service,
-        @NonNull Looper looper) {
+    public WifiManager(@NonNull Context context, @NonNull IWifiManager service) {
         mContext = context;
         mService = service;
-        mLooper = looper;
         mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;
         updateVerboseLoggingEnabledFromService();
     }
@@ -4063,6 +4062,17 @@ public class WifiManager {
      */
     public static final int WIFI_FEATURE_SOFTAP_MLO = 63;
 
+    /**
+     * Supports multiple Wi-Fi 7 multi-link devices (MLD) on SoftAp.
+     * @hide
+     */
+    public static final int WIFI_FEATURE_MULTIPLE_MLD_ON_SAP = 64;
+
+    /**
+     * NOTE: When adding a new WIFI_FEATURE_ value, also be sure to update
+     * {@link com.android.server.wifi.util.FeatureBitsetUtils}
+     */
+
     private boolean isFeatureSupported(int feature) {
         try {
             return mService.isFeatureSupported(feature);
@@ -4076,14 +4086,18 @@ public class WifiManager {
      * @hide
      */
     public boolean isPasspointSupported() {
-        return isFeatureSupported(WIFI_FEATURE_PASSPOINT);
+        // Both OEM and chip support are required
+        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_PASSPOINT)
+                && isFeatureSupported(WIFI_FEATURE_PASSPOINT);
     }
 
     /**
      * @return true if this adapter supports WifiP2pManager (Wi-Fi Direct)
      */
     public boolean isP2pSupported() {
-        return isFeatureSupported(WIFI_FEATURE_P2P);
+        // Both OEM and chip support are required
+        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_DIRECT)
+                && isFeatureSupported(WIFI_FEATURE_P2P);
     }
 
     /**
@@ -4109,7 +4123,9 @@ public class WifiManager {
      * @hide
      */
     public boolean isWifiAwareSupported() {
-        return isFeatureSupported(WIFI_FEATURE_AWARE);
+        // Both OEM and chip support are required
+        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE)
+                && isFeatureSupported(WIFI_FEATURE_AWARE);
     }
 
     /**
@@ -7554,7 +7570,7 @@ public class WifiManager {
             @Nullable ActionListener listener) {
         ActionListenerProxy listenerProxy = null;
         if (listener != null) {
-            listenerProxy = new ActionListenerProxy("connect", mLooper, listener);
+            listenerProxy = new ActionListenerProxy("connect", mContext.getMainLooper(), listener);
         }
         try {
             Bundle extras = new Bundle();
@@ -7703,7 +7719,7 @@ public class WifiManager {
         if (config == null) throw new IllegalArgumentException("config cannot be null");
         ActionListenerProxy listenerProxy = null;
         if (listener != null) {
-            listenerProxy = new ActionListenerProxy("save", mLooper, listener);
+            listenerProxy = new ActionListenerProxy("save", mContext.getMainLooper(), listener);
         }
         try {
             mService.save(config, listenerProxy, mContext.getOpPackageName());
@@ -7741,7 +7757,7 @@ public class WifiManager {
         if (netId < 0) throw new IllegalArgumentException("Network id cannot be negative");
         ActionListenerProxy listenerProxy = null;
         if (listener != null) {
-            listenerProxy = new ActionListenerProxy("forget", mLooper, listener);
+            listenerProxy = new ActionListenerProxy("forget", mContext.getMainLooper(), listener);
         }
         try {
             mService.forget(netId, listenerProxy);
@@ -8449,7 +8465,8 @@ public class WifiManager {
             synchronized (mBinder) {
                 if (mRefCounted ? (++mRefCount == 1) : (!mHeld)) {
                     try {
-                        mService.acquireMulticastLock(mBinder, mTag);
+                        mService.acquireMulticastLock(mBinder, mTag,
+                                mContext.getAttributionTag(), mContext.getOpPackageName());
                         synchronized (WifiManager.this) {
                             if (mActiveLockCount >= MAX_ACTIVE_LOCKS) {
                                 mService.releaseMulticastLock(mBinder, mTag);
@@ -13209,14 +13226,15 @@ public class WifiManager {
     @FlaggedApi(android.security.Flags.FLAG_AAPM_API)
     @RequiresApi(Build.VERSION_CODES.BAKLAVA)
     @NonNull
+    @SuppressLint("NewApi")
     public List<AdvancedProtectionFeature> getAvailableAdvancedProtectionFeatures() {
         if (!Environment.isSdkAtLeastB()) {
             throw new UnsupportedOperationException();
         }
         List<AdvancedProtectionFeature> features = new ArrayList<>();
-        if (Flags.wepDisabledInApm()) {
-            // TODO: b/362586268 Change to AdvancedProtectionManager.FEATURE_ID_DISALLOW_WEP
-            features.add(new AdvancedProtectionFeature("WEP"));
+        if (Flags.wepDisabledInApm() && android.security.Flags.aapmApi()) {
+            features.add(new AdvancedProtectionFeature(
+                    AdvancedProtectionManager.FEATURE_ID_DISALLOW_WEP));
         }
         return features;
     }
diff --git a/framework/java/android/net/wifi/WifiNetworkSpecifier.java b/framework/java/android/net/wifi/WifiNetworkSpecifier.java
index 199969d9c7..abb8734ca2 100644
--- a/framework/java/android/net/wifi/WifiNetworkSpecifier.java
+++ b/framework/java/android/net/wifi/WifiNetworkSpecifier.java
@@ -22,6 +22,7 @@ import static com.android.internal.util.Preconditions.checkNotNull;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.compat.annotation.UnsupportedAppUsage;
 import android.net.ConnectivityManager;
 import android.net.ConnectivityManager.NetworkCallback;
 import android.net.MacAddress;
@@ -192,6 +193,8 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
 
         private int[] mChannels;
 
+        private boolean mPreferSecondarySta;
+
         public Builder() {
             mSsidPatternMatcher = null;
             mBssidPatternMatcher = null;
@@ -480,6 +483,19 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
             return this;
         }
 
+        /**
+         * Hint the Wifi service to prefer using secondary STA for this connection.
+         *
+         * @param value - true to prefer this connection to be started on a secondary STA.
+         *                false to let the wifi framework decide
+         * @return Instance of {@link Builder} to enable chaining of the builder method.
+         * @hide
+         */
+        @NonNull @UnsupportedAppUsage public Builder setPreferSecondarySta(boolean value) {
+            mPreferSecondarySta = value;
+            return this;
+        }
+
         private void setSecurityParamsInWifiConfiguration(
                 @NonNull WifiConfiguration configuration) {
             if (!TextUtils.isEmpty(mWpa2PskPassphrase)) { // WPA-PSK network.
@@ -684,7 +700,8 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
                     mBssidPatternMatcher,
                     mBand,
                     buildWifiConfiguration(),
-                    mChannels);
+                    mChannels,
+                    mPreferSecondarySta);
         }
     }
 
@@ -707,6 +724,7 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
     @WifiBand private final int mBand;
 
     private final int[] mChannelFreqs;
+    private boolean mPreferSecondarySta;
 
     /**
      * Security credentials for the network.
@@ -729,7 +747,8 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
             @NonNull Pair<MacAddress, MacAddress> bssidPatternMatcher,
             @WifiBand int band,
             @NonNull WifiConfiguration wifiConfiguration,
-            @NonNull int[] channelFreqs) {
+            @NonNull int[] channelFreqs,
+            boolean preferSecondarySta) {
         checkNotNull(ssidPatternMatcher);
         checkNotNull(bssidPatternMatcher);
         checkNotNull(wifiConfiguration);
@@ -739,6 +758,7 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
         this.mBand = band;
         this.wifiConfiguration = wifiConfiguration;
         this.mChannelFreqs = channelFreqs;
+        this.mPreferSecondarySta = preferSecondarySta;
     }
 
     /**
@@ -756,6 +776,14 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
         return mChannelFreqs.clone();
     }
 
+    /**
+     * @see Builder#setPreferSecondarySta(boolean)
+     * @hide
+     */
+    @UnsupportedAppUsage public boolean isPreferSecondarySta() {
+        return mPreferSecondarySta;
+    }
+
     public static final @NonNull Creator<WifiNetworkSpecifier> CREATOR =
             new Creator<WifiNetworkSpecifier>() {
                 @Override
@@ -767,9 +795,10 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
                             Pair.create(baseAddress, mask);
                     int band = in.readInt();
                     WifiConfiguration wifiConfiguration = in.readParcelable(null);
-                    int[] mChannels = in.createIntArray();
+                    int[] channels = in.createIntArray();
+                    boolean preferSecondarySta = in.readBoolean();
                     return new WifiNetworkSpecifier(ssidPatternMatcher, bssidPatternMatcher, band,
-                            wifiConfiguration, mChannels);
+                            wifiConfiguration, channels, preferSecondarySta);
                 }
 
                 @Override
@@ -791,13 +820,15 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
         dest.writeInt(mBand);
         dest.writeParcelable(wifiConfiguration, flags);
         dest.writeIntArray(mChannelFreqs);
+        dest.writeBoolean(mPreferSecondarySta);
     }
 
     @Override
     public int hashCode() {
         return Objects.hash(
                 ssidPatternMatcher.getPath(), ssidPatternMatcher.getType(), bssidPatternMatcher,
-                mBand, wifiConfiguration.allowedKeyManagement, Arrays.hashCode(mChannelFreqs));
+                mBand, wifiConfiguration.allowedKeyManagement, Arrays.hashCode(mChannelFreqs),
+                mPreferSecondarySta);
     }
 
     @Override
@@ -818,7 +849,8 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
                 && this.mBand == lhs.mBand
                 && Objects.equals(this.wifiConfiguration.allowedKeyManagement,
                     lhs.wifiConfiguration.allowedKeyManagement)
-                && Arrays.equals(mChannelFreqs, lhs.mChannelFreqs);
+                && Arrays.equals(mChannelFreqs, lhs.mChannelFreqs)
+                && mPreferSecondarySta == lhs.mPreferSecondarySta;
     }
 
     @Override
@@ -831,6 +863,7 @@ public final class WifiNetworkSpecifier extends NetworkSpecifier implements Parc
                 .append(", BSSID=").append(wifiConfiguration.BSSID)
                 .append(", channels=").append(Arrays.toString(mChannelFreqs))
                 .append(", band=").append(mBand)
+                .append(", preferSecondarySta=").append(mPreferSecondarySta)
                 .append("]")
                 .toString();
     }
diff --git a/framework/java/android/net/wifi/WifiScanner.java b/framework/java/android/net/wifi/WifiScanner.java
index 1dffa8a3c7..b5cc3b0976 100644
--- a/framework/java/android/net/wifi/WifiScanner.java
+++ b/framework/java/android/net/wifi/WifiScanner.java
@@ -34,7 +34,6 @@ import android.content.Context;
 import android.os.Binder;
 import android.os.Build;
 import android.os.Bundle;
-import android.os.Looper;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.os.Process;
@@ -46,6 +45,7 @@ import android.util.Log;
 import androidx.annotation.RequiresApi;
 
 import com.android.internal.util.Protocol;
+import com.android.modules.utils.ParceledListSlice;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.wifi.flags.Flags;
 
@@ -388,14 +388,14 @@ public class WifiScanner {
          * reports full scan result for all access points found in scan
          */
         @Override
-        public void onFullResults(List<ScanResult> fullScanResult) {
+        public void onFullResults(ParceledListSlice<ScanResult> fullScanResult) {
             Log.i(TAG, "onFullResults");
             if (mActionListener == null) return;
             if (!(mActionListener instanceof ScanListener)) return;
             ScanListener scanListener = (ScanListener) mActionListener;
             Binder.clearCallingIdentity();
             mExecutor.execute(
-                    () -> fullScanResult.forEach(scanListener::onFullResult));
+                    () -> fullScanResult.getList().forEach(scanListener::onFullResult));
         }
 
         @Override
@@ -1022,7 +1022,8 @@ public class WifiScanner {
             dest.writeInt(mFlags);
             dest.writeInt(mBucketsScanned);
             dest.writeInt(mScannedBands);
-            dest.writeParcelableList(mResults, 0);
+            ParceledListSlice<ScanResult> parceledListSlice = new ParceledListSlice<>(mResults);
+            parceledListSlice.writeToParcel(dest, flags);
         }
 
         /** Implement the Parcelable interface {@hide} */
@@ -1033,9 +1034,10 @@ public class WifiScanner {
                         int flags = in.readInt();
                         int bucketsScanned = in.readInt();
                         int bandsScanned = in.readInt();
-                        List<ScanResult> results = new ArrayList<>();
-                        in.readParcelableList(results, ScanResult.class.getClassLoader());
-                        return new ScanData(id, flags, bucketsScanned, bandsScanned, results);
+                        ParceledListSlice<ScanResult> parceledListSlice =
+                                ParceledListSlice.CREATOR.createFromParcel(in);
+                        return new ScanData(id, flags, bucketsScanned, bandsScanned,
+                                parceledListSlice.getList());
                     }
 
                     public ScanData[] newArray(int size) {
@@ -2022,12 +2024,9 @@ public class WifiScanner {
      *
      * @param context the application context
      * @param service the Binder interface for {@link Context#WIFI_SCANNING_SERVICE}
-     * @param looper the Looper used to deliver callbacks
-     *
      * @hide
      */
-    public WifiScanner(@NonNull Context context, @NonNull IWifiScanner service,
-            @NonNull Looper looper) {
+    public WifiScanner(@NonNull Context context, @NonNull IWifiScanner service) {
         mContext = context;
         mService = service;
     }
diff --git a/framework/java/android/net/wifi/aware/Characteristics.java b/framework/java/android/net/wifi/aware/Characteristics.java
index fa8c4ed6fc..37fc1702dd 100644
--- a/framework/java/android/net/wifi/aware/Characteristics.java
+++ b/framework/java/android/net/wifi/aware/Characteristics.java
@@ -183,9 +183,22 @@ public final class Characteristics implements Parcelable {
         return mCharacteristics.getBoolean(KEY_IS_INSTANT_COMMUNICATION_MODE_SUPPORTED);
     }
 
+
     /**
-     * Check if the Aware Pairing is supported. The Aware Pairing is defined as per Wi-Fi Alliance
-     * (WFA) Wi-Fi Aware specifications version 4.0 Section 7.6.
+     * Check if the Aware Pairing and all associated security features as defined in Wi-Fi Alliance
+     * (WFA) Wi-Fi Aware Specification version 4.0 are supported.
+     * This includes:
+     * <ol>
+     * <li>NAN Pairing (as in Wi-Fi Aware Specification Version 4.0 section 7.6) with NIK caching
+     * <li>NDP unicast data frame encryption (as in Wi-Fi Aware Specification Version 4.0 section
+     * 7.3.1)
+     * <li>Group addressed data frame encryption (as in Wi-Fi Aware Specification Version 4.0
+     * section 7.3.3)
+     * <li>Management frame protection (as in Wi-Fi Aware Specification Version 4.0 section 7.3.2
+     * for both unicast and multicast frames)
+     * <li>Beacon integrity protection (as in Wi-Fi Aware Specification Version 4.0 section 7.3.4)
+     * </ol>
+     *
      * @return True if supported, false otherwise.
      */
     public boolean isAwarePairingSupported() {
@@ -270,7 +283,7 @@ public final class Characteristics implements Parcelable {
      */
     @FlaggedApi(FLAG_RANGING_RTT_ENABLED)
     @SystemApi
-    public @WifiAnnotations.ChannelWidth int getMaxSupportedRangingPktBandwidth() {
+    public @WifiAnnotations.ChannelWidth int getMaxSupportedRangingPacketBandwidth() {
         return mCharacteristics.getInt(KEY_MAX_SUPPORTED_RANGING_PKT_BANDWIDTH);
     }
 
diff --git a/framework/java/android/net/wifi/aware/SubscribeConfig.java b/framework/java/android/net/wifi/aware/SubscribeConfig.java
index e9d680623b..13fd049113 100644
--- a/framework/java/android/net/wifi/aware/SubscribeConfig.java
+++ b/framework/java/android/net/wifi/aware/SubscribeConfig.java
@@ -100,50 +100,75 @@ public final class SubscribeConfig implements Parcelable {
     @Retention(RetentionPolicy.SOURCE)
     public @interface PeriodicRangingInterval {
     }
-    /* Ranging is not repeated */
-    /** @hide */
+
+    /**
+     * Ranging is not repeated
+     *
+     * @hide
+     */
     @FlaggedApi(FLAG_RANGING_RTT_ENABLED)
     @SystemApi
     public static final int PERIODIC_RANGING_INTERVAL_NONE = 0;
 
-    /* Ranging interval is 128TU [= (128 * 1024) / 1000 = 131.072 ms] */
-    /** @hide */
+    /**
+     * Ranging interval is 128TU [= (128 * 1024) / 1000 = 131.072 ms]
+     *
+     * @hide
+     */
     @FlaggedApi(FLAG_RANGING_RTT_ENABLED)
     @SystemApi
     public static final int PERIODIC_RANGING_INTERVAL_128TU = 128;
 
-    /* Ranging interval is 256TU [= (256 * 1024) / 1000 = 262.144 ms] */
-    /** @hide */
+    /**
+     * Ranging interval is 256TU [= (256 * 1024) / 1000 = 262.144 ms]
+     *
+     * @hide
+     */
     @FlaggedApi(FLAG_RANGING_RTT_ENABLED)
     @SystemApi
     public static final int PERIODIC_RANGING_INTERVAL_256TU = 256;
 
-    /* Ranging interval is 512TU [= (512 * 1024) / 1000 = 524.288 ms] */
-    /** @hide */
+    /**
+     * Ranging interval is 512TU [= (512 * 1024) / 1000 = 524.288 ms]
+     *
+     * @hide
+     */
     @FlaggedApi(FLAG_RANGING_RTT_ENABLED)
     @SystemApi
     public static final int PERIODIC_RANGING_INTERVAL_512TU = 512;
 
-    /* Ranging interval is 1024TU [= (1024 * 1024) / 1000 = 1048.576 ms] */
-    /** @hide */
+    /**
+     * Ranging interval is 1024TU [= (1024 * 1024) / 1000 = 1048.576 ms]
+     *
+     * @hide
+     */
     @FlaggedApi(FLAG_RANGING_RTT_ENABLED)
     @SystemApi
     public static final int PERIODIC_RANGING_INTERVAL_1024TU = 1024;
 
-    /* Ranging interval is 2048TU [= (2048 * 1024) / 1000 = 2097.152 ms] */
-    /** @hide */
+    /**
+     * Ranging interval is 2048TU [= (2048 * 1024) / 1000 = 2097.152 ms]
+     *
+     * @hide
+     */
     @FlaggedApi(FLAG_RANGING_RTT_ENABLED)
     @SystemApi
     public static final int PERIODIC_RANGING_INTERVAL_2048TU = 2048;
 
-    /* Ranging interval is 4096TU [= (4096 * 1024) / 1000 = 4194.304 ms] */
-    /** @hide */
+    /**
+     * Ranging interval is 4096TU [= (4096 * 1024) / 1000 = 4194.304 ms]
+     *
+     * @hide
+     */
     @FlaggedApi(FLAG_RANGING_RTT_ENABLED)
     @SystemApi
     public static final int PERIODIC_RANGING_INTERVAL_4096TU = 4096;
 
-    /* Ranging interval is 8192TU [= (8192 * 1024) / 1000 = 8388.608 ms] */
-    /** @hide */
+    /**
+     * Ranging interval is 8192TU [= (8192 * 1024) / 1000 = 8388.608 ms]
+     *
+     * @hide
+     */
     @FlaggedApi(FLAG_RANGING_RTT_ENABLED)
     @SystemApi
     public static final int PERIODIC_RANGING_INTERVAL_8192TU = 8192;
@@ -482,10 +507,6 @@ public final class SubscribeConfig implements Parcelable {
         if (mMaxDistanceMmSet && mMaxDistanceMm < 0) {
             throw new IllegalArgumentException("Maximum distance must be non-negative");
         }
-        if (mMinDistanceMmSet && mMaxDistanceMmSet && mMaxDistanceMm <= mMinDistanceMm) {
-            throw new IllegalArgumentException(
-                    "Maximum distance must be greater than minimum distance");
-        }
 
         if (mPeriodicRangingEnabled && (mMinDistanceMmSet || mMaxDistanceMmSet)) {
             throw new IllegalArgumentException(
@@ -861,6 +882,10 @@ public final class SubscribeConfig implements Parcelable {
          * <p>
          * The device must support Wi-Fi RTT for this feature to be used. Feature support is checked
          * as described in {@link android.net.wifi.rtt}.
+         * <p>
+         * Note: The minimum distance is same as outer threshold of egress geofence. This can be
+         * more than {@link #setMaxDistanceMm(int)} which is same as inner threshold of ingress
+         * geofence i.e. discovery with  distance <= max or distance >= min.
          *
          * @param minDistanceMm Minimum distance, in mm, to the publisher above which to trigger
          *                      discovery.
@@ -896,6 +921,10 @@ public final class SubscribeConfig implements Parcelable {
          * <p>
          * The device must support Wi-Fi RTT for this feature to be used. Feature support is checked
          * as described in {@link android.net.wifi.rtt}.
+         * <p>
+         * Note: The maximum distance is same as inner threshold of ingress geofence. This can be
+         * less than {@link #setMinDistanceMm(int)} which is same as outer threshold of egress
+         * geofence i.e. discovery with  distance <= max or distance >= min.
          *
          * @param maxDistanceMm Maximum distance, in mm, to the publisher below which to trigger
          *                      discovery.
diff --git a/framework/java/android/net/wifi/hotspot2/pps/Credential.java b/framework/java/android/net/wifi/hotspot2/pps/Credential.java
index 658588ae8b..25d20f14ae 100644
--- a/framework/java/android/net/wifi/hotspot2/pps/Credential.java
+++ b/framework/java/android/net/wifi/hotspot2/pps/Credential.java
@@ -145,7 +145,7 @@ public final class Credential implements Parcelable {
          * Maximum string length for username.  Refer to Credential/UsernamePassword/Username
          * node in Hotspot 2.0 Release 2 Technical Specification Section 9.1 for more info.
          */
-        private static final int MAX_USERNAME_BYTES = 63;
+        private static final int MAX_USERNAME_BYTES = 253;
 
         /**
          * Maximum string length for password.  Refer to Credential/UsernamePassword/Password
diff --git a/framework/java/android/net/wifi/p2p/WifiP2pConfig.java b/framework/java/android/net/wifi/p2p/WifiP2pConfig.java
index 67f1e6cd3a..8e0805797f 100644
--- a/framework/java/android/net/wifi/p2p/WifiP2pConfig.java
+++ b/framework/java/android/net/wifi/p2p/WifiP2pConfig.java
@@ -397,22 +397,22 @@ public class WifiP2pConfig implements Parcelable {
     /**
      * Used to authorize a connection request from the peer device.
      */
-    private boolean mAuthorizeConnectionFromPeer = false;
+    private boolean mIsAuthorizeConnectionFromPeerEnabled = false;
 
     /**
      * Query to check if the configuration is for authorizing a connection request
-     * from the peer device. @see {@link Builder#setAuthorizeConnectionFromPeer(boolean)}
+     * from the peer device. @see {@link Builder#setAuthorizeConnectionFromPeerEnabled(boolean)}
      *
      * @return true if configured to authorize a connection request from the Peer device,
      * False otherwise.
      */
     @RequiresApi(Build.VERSION_CODES.BAKLAVA)
     @FlaggedApi(Flags.FLAG_WIFI_DIRECT_R2)
-    public boolean isAuthorizeConnectionFromPeer() {
+    public boolean isAuthorizeConnectionFromPeerEnabled() {
         if (!Environment.isSdkAtLeastB()) {
             throw new UnsupportedOperationException();
         }
-        return mAuthorizeConnectionFromPeer;
+        return mIsAuthorizeConnectionFromPeerEnabled;
     }
 
     public WifiP2pConfig() {
@@ -498,7 +498,8 @@ public class WifiP2pConfig implements Parcelable {
                     .append((mPairingBootstrappingConfig == null)
                             ? "<null>" : mPairingBootstrappingConfig.toString());
         }
-        sbuf.append("\n authorizeConnectionFromPeer: ").append(mAuthorizeConnectionFromPeer);
+        sbuf.append("\n authorizeConnectionFromPeerEnabled: ")
+                .append(mIsAuthorizeConnectionFromPeerEnabled);
         return sbuf.toString();
     }
 
@@ -523,7 +524,7 @@ public class WifiP2pConfig implements Parcelable {
             mVendorData = new ArrayList<>(source.mVendorData);
             mGroupOwnerVersion = source.mGroupOwnerVersion;
             mPairingBootstrappingConfig = source.mPairingBootstrappingConfig;
-            mAuthorizeConnectionFromPeer = source.mAuthorizeConnectionFromPeer;
+            mIsAuthorizeConnectionFromPeerEnabled = source.mIsAuthorizeConnectionFromPeerEnabled;
         }
     }
 
@@ -544,7 +545,7 @@ public class WifiP2pConfig implements Parcelable {
         if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()) {
             dest.writeParcelable(mPairingBootstrappingConfig, flags);
         }
-        dest.writeBoolean(mAuthorizeConnectionFromPeer);
+        dest.writeBoolean(mIsAuthorizeConnectionFromPeerEnabled);
     }
 
     /** Implement the Parcelable interface */
@@ -569,7 +570,7 @@ public class WifiP2pConfig implements Parcelable {
                         config.mPairingBootstrappingConfig = in.readParcelable(
                                 WifiP2pPairingBootstrappingConfig.class.getClassLoader());
                     }
-                    config.mAuthorizeConnectionFromPeer = in.readBoolean();
+                    config.mIsAuthorizeConnectionFromPeerEnabled = in.readBoolean();
                     return config;
             }
 
@@ -610,7 +611,7 @@ public class WifiP2pConfig implements Parcelable {
         @PccModeConnectionType
         private int mPccModeConnectionType = PCC_MODE_DEFAULT_CONNECTION_TYPE_LEGACY_ONLY;
         private @Nullable WifiP2pPairingBootstrappingConfig mPairingBootstrappingConfig;
-        private boolean mAuthorizeConnectionFromPeer = false;
+        private boolean mIsAuthorizeConnectionFromPeerEnabled = false;
 
         /**
          * Specify the peer's MAC address. If not set, the device will
@@ -954,15 +955,15 @@ public class WifiP2pConfig implements Parcelable {
          * WifiP2pManager.ActionListener)}. The device will then wait for the connection request
          * from the peer device.
          *
-         * @param authorize true to authorize a connection request from the peer device, false to
+         * @param enabled true to authorize a connection request from the peer device, false to
          *                  let the device join a group or form a group.
          * @return The builder to facilitate chaining {@code builder.setXXX(..).setXXX(..)}.
          */
         @RequiresApi(Build.VERSION_CODES.BAKLAVA)
         @FlaggedApi(Flags.FLAG_WIFI_DIRECT_R2)
         @NonNull
-        public Builder setAuthorizeConnectionFromPeer(boolean authorize) {
-            mAuthorizeConnectionFromPeer = authorize;
+        public Builder setAuthorizeConnectionFromPeerEnabled(boolean enabled) {
+            mIsAuthorizeConnectionFromPeerEnabled = enabled;
             return this;
         }
 
@@ -1016,8 +1017,13 @@ public class WifiP2pConfig implements Parcelable {
             config.netId = mNetId;
             config.mGroupClientIpProvisioningMode = mGroupClientIpProvisioningMode;
             config.mJoinExistingGroup = mJoinExistingGroup;
-            config.mPairingBootstrappingConfig = mPairingBootstrappingConfig;
-            config.mAuthorizeConnectionFromPeer = mAuthorizeConnectionFromPeer;
+            if (mPairingBootstrappingConfig != null) {
+                config.mPairingBootstrappingConfig = mPairingBootstrappingConfig;
+                config.mGroupClientIpProvisioningMode =
+                        GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL;
+                config.wps.setup = WpsInfo.INVALID;
+            }
+            config.mIsAuthorizeConnectionFromPeerEnabled = mIsAuthorizeConnectionFromPeerEnabled;
             return config;
         }
     }
diff --git a/framework/java/android/net/wifi/p2p/WifiP2pDevice.java b/framework/java/android/net/wifi/p2p/WifiP2pDevice.java
index a6d8048e4e..78a13d1217 100644
--- a/framework/java/android/net/wifi/p2p/WifiP2pDevice.java
+++ b/framework/java/android/net/wifi/p2p/WifiP2pDevice.java
@@ -543,6 +543,17 @@ public class WifiP2pDevice implements Parcelable {
                 .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE) != 0;
     }
 
+    /**
+     * Get the supported pairing bootstrapping methods for framework internal usage.
+     * @hide
+     */
+    public int getPairingBootStrappingMethods() {
+        if (!Environment.isSdkAtLeastB()) {
+            throw new UnsupportedOperationException();
+        }
+        return mPairingBootstrappingMethods;
+    }
+
     /**
      * Set the supported pairing bootstrapping methods.
      *
@@ -558,6 +569,14 @@ public class WifiP2pDevice implements Parcelable {
         mPairingBootstrappingMethods = methods;
     }
 
+    /**
+     * Store the Device Identity Resolution (DIR) Info received in USD frame for framework
+     * internal usage.
+     * @hide
+     */
+    @Nullable
+    public WifiP2pDirInfo dirInfo;
+
     @Override
     public boolean equals(Object obj) {
         if (this == obj) return true;
diff --git a/framework/java/android/net/wifi/p2p/WifiP2pDeviceList.java b/framework/java/android/net/wifi/p2p/WifiP2pDeviceList.java
index e7866e6180..411c2a83a7 100644
--- a/framework/java/android/net/wifi/p2p/WifiP2pDeviceList.java
+++ b/framework/java/android/net/wifi/p2p/WifiP2pDeviceList.java
@@ -17,6 +17,7 @@
 package android.net.wifi.p2p;
 
 import android.compat.annotation.UnsupportedAppUsage;
+import android.net.wifi.util.Environment;
 import android.os.Build;
 import android.os.Parcel;
 import android.os.Parcelable;
@@ -102,6 +103,10 @@ public class WifiP2pDeviceList implements Parcelable {
             d.deviceCapability = device.deviceCapability;
             d.groupCapability = device.groupCapability;
             d.wfdInfo = device.wfdInfo;
+            if (Environment.isSdkAtLeastB()) {
+                d.setPairingBootStrappingMethods(device.getPairingBootStrappingMethods());
+                d.dirInfo = device.dirInfo;
+            }
             return;
         }
         //Not found, add a new one
diff --git a/framework/java/android/net/wifi/p2p/WifiP2pManager.java b/framework/java/android/net/wifi/p2p/WifiP2pManager.java
index 717bde6a80..ff973dedae 100644
--- a/framework/java/android/net/wifi/p2p/WifiP2pManager.java
+++ b/framework/java/android/net/wifi/p2p/WifiP2pManager.java
@@ -975,6 +975,17 @@ public class WifiP2pManager {
     @FlaggedApi(Flags.FLAG_WIFI_DIRECT_R2)
     public static final int NO_PERMISSION = 4;
 
+    /** @hide */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(value = {
+            ERROR,
+            P2P_UNSUPPORTED,
+            BUSY,
+            NO_PERMISSION
+    })
+    public @interface FailureReason{}
+
+
     /** Interface for callback invocation when framework channel is lost */
     public interface ChannelListener {
         /**
@@ -2021,8 +2032,13 @@ public class WifiP2pManager {
                 }
             } else {
                 if (mServRspListener != null) {
-                    mServRspListener.onServiceAvailable(resp.getServiceType(),
-                            resp.getRawData(), resp.getSrcDevice());
+                    if (Flags.wifiDirectR2() && resp.getWifiP2pUsdBasedServiceResponse() != null) {
+                        mServRspListener.onUsdBasedServiceAvailable(
+                                resp.getSrcDevice(), resp.getWifiP2pUsdBasedServiceResponse());
+                    } else {
+                        mServRspListener.onServiceAvailable(resp.getServiceType(),
+                                resp.getRawData(), resp.getSrcDevice());
+                    }
                 }
             }
         }
@@ -2721,6 +2737,12 @@ public class WifiP2pManager {
             ActionListener listener) {
         checkChannel(channel);
         checkServiceInfo(servInfo);
+        if (Environment.isSdkAtLeastB()) {
+            if (servInfo.getWifiP2pUsdBasedServiceConfig() != null) {
+                throw new UnsupportedOperationException("Application must call"
+                        + " WifiP2pManager#startUsdBasedLocalServiceAdvertisement for USD config");
+            }
+        }
         Bundle extras = prepareExtrasBundle(channel);
         extras.putParcelable(EXTRA_PARAM_KEY_SERVICE_INFO, servInfo);
         channel.mAsyncChannel.sendMessage(prepareMessage(ADD_LOCAL_SERVICE, 0,
@@ -2746,6 +2768,10 @@ public class WifiP2pManager {
      * <p>The service information can be cleared with calls to
      *  {@link #removeLocalService} or {@link #clearLocalServices}.
      * <p>
+     * Use {@link #isWiFiDirectR2Supported()} to determine whether the device supports
+     * this feature. If {@link #isWiFiDirectR2Supported()} return {@code false} then
+     * this method will throw {@link UnsupportedOperationException}.
+     * <p>
      * The application must have {@link android.Manifest.permission#NEARBY_WIFI_DEVICES} with
      * android:usesPermissionFlags="neverForLocation". If the application does not declare
      * android:usesPermissionFlags="neverForLocation", then it must also have
@@ -2770,6 +2796,9 @@ public class WifiP2pManager {
         if (!Environment.isSdkAtLeastB()) {
             throw new UnsupportedOperationException();
         }
+        if (!isWiFiDirectR2Supported()) {
+            throw new UnsupportedOperationException();
+        }
         checkChannel(channel);
         Objects.requireNonNull(servInfo, "service info cannot be null");
         Objects.requireNonNull(config, "Advertisement config cannot be null");
@@ -2929,6 +2958,10 @@ public class WifiP2pManager {
      * {@link #setServiceResponseListener(Channel, ServiceResponseListener)} .
      *
      * <p>
+     * Use {@link #isWiFiDirectR2Supported()} to determine whether the device supports
+     * this feature. If {@link #isWiFiDirectR2Supported()} return {@code false} then
+     * this method will throw {@link UnsupportedOperationException}.
+     * <p>
      * The application must have {@link android.Manifest.permission#NEARBY_WIFI_DEVICES} with
      * android:usesPermissionFlags="neverForLocation". If the application does not declare
      * android:usesPermissionFlags="neverForLocation", then it must also have
@@ -2951,6 +2984,9 @@ public class WifiP2pManager {
         if (!Environment.isSdkAtLeastB()) {
             throw new UnsupportedOperationException();
         }
+        if (!isWiFiDirectR2Supported()) {
+            throw new UnsupportedOperationException();
+        }
         checkChannel(channel);
         Objects.requireNonNull(config, "Service discovery config cannot be null");
         Bundle extras = prepareExtrasBundle(channel);
@@ -2968,6 +3004,13 @@ public class WifiP2pManager {
      * add service through listener callbacks {@link ActionListener#onSuccess} or
      * {@link ActionListener#onFailure}.
      *
+     * <p> The USD based service information are set in the service request through
+     * {@link WifiP2pServiceRequest#WifiP2pServiceRequest(WifiP2pUsdBasedServiceConfig)}.
+     * Application must use {@link #isWiFiDirectR2Supported()} to determine whether the device
+     * supports USD based service discovery. If {@link #isWiFiDirectR2Supported()} return
+     * {@code false} then this method will throw {@link UnsupportedOperationException} for service
+     * request information containing USD service configuration.
+     *
      * <p>After service discovery request is added, you can initiate service discovery by
      * {@link #discoverServices}.
      *
@@ -2983,6 +3026,11 @@ public class WifiP2pManager {
             WifiP2pServiceRequest req, ActionListener listener) {
         checkChannel(channel);
         checkServiceRequest(req);
+        if (Environment.isSdkAtLeastB()) {
+            if (req.getWifiP2pUsdBasedServiceConfig() != null && !isWiFiDirectR2Supported()) {
+                throw new UnsupportedOperationException();
+            }
+        }
         channel.mAsyncChannel.sendMessage(ADD_SERVICE_REQUEST, 0,
                 channel.putListener(listener), req);
     }
@@ -4000,7 +4048,7 @@ public class WifiP2pManager {
          * The operation failed.
          * @param reason The reason for failure.
          */
-        void onFailure(int reason);
+        void onFailure(@FailureReason int reason);
     }
 
     /**
@@ -4064,7 +4112,7 @@ public class WifiP2pManager {
                     }
 
                     @Override
-                    public void onFailure(int reason) {
+                    public void onFailure(@FailureReason int reason) {
                         Binder.clearCallingIdentity();
                         executor.execute(() -> {
                             callback.onError(reasonCodeToException(reason));
diff --git a/framework/java/android/net/wifi/p2p/WifiP2pPairingBootstrappingConfig.java b/framework/java/android/net/wifi/p2p/WifiP2pPairingBootstrappingConfig.java
index 4579cd2261..7ef07cb856 100644
--- a/framework/java/android/net/wifi/p2p/WifiP2pPairingBootstrappingConfig.java
+++ b/framework/java/android/net/wifi/p2p/WifiP2pPairingBootstrappingConfig.java
@@ -23,6 +23,7 @@ import android.annotation.Nullable;
 import android.os.Build;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.text.TextUtils;
 
 import androidx.annotation.RequiresApi;
 
@@ -32,7 +33,7 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
 /**
- * A class representing Wi-Fi Direct pairing bootstrapping config
+ * A class representing Wi-Fi Direct pairing bootstrapping configuration.
  *
  * @see android.net.wifi.p2p.WifiP2pConfig
  */
@@ -92,19 +93,80 @@ public final class WifiP2pPairingBootstrappingConfig implements Parcelable {
     private int mPairingBootstrappingMethod;
 
     /**
-     * Password for pairing setup, if |pairingBootstrappingMethod| uses one of the
-     * |PAIRING_BOOTSTRAPPING_METHOD_*| methods other than
-     * PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC, null otherwise.
+     * Password for pairing setup, if {@code mPairingBootstrappingMethod} uses
+     * {@link #PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE},
+     * {@link #PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE} or
+     * {@link #PAIRING_BOOTSTRAPPING_METHOD_OUT_OF_BAND}.
+     * Must be set to null for {@link #PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC},
+     * {@link #PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE}
+     * or {@link #PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE}.
      */
     @Nullable private String mPassword;
 
+    private static boolean isValidPairingBootstrappingMethod(@WifiP2pPairingBootstrappingConfig
+            .PairingBootstrappingMethod int method) {
+        switch (method) {
+            case PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC:
+            case PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE:
+            case PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE:
+            case PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE:
+            case PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE:
+            case PAIRING_BOOTSTRAPPING_METHOD_OUT_OF_BAND:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /** @hide */
+    public int getPairingBootstrappingMethod() {
+        return mPairingBootstrappingMethod;
+    }
+
+    /** @hide */
+    public String getPairingBootstrappingPassword() {
+        return mPassword;
+    }
+
+    /** @hide */
+    public void setPairingBootstrappingPassword(@NonNull String password) {
+        mPassword = password;
+    }
+
     /**
      * Constructor for a WifiP2pPairingBootstrappingConfig.
+     * @param method One of the {@code PAIRING_BOOTSTRAPPING_METHOD_*}.
+     * @param password Password or PIN for pairing setup. if {@code method} is
+     *                 {@link #PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE}, the password must be
+     *                 a string containing 4 or more digits (0-9). For example: "1234", "56789". if
+     *                 {@code method} is {@link #PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE}
+     *                 or {@link #PAIRING_BOOTSTRAPPING_METHOD_OUT_OF_BAND}, the password must be a
+     *                 UTF-8 string of minimum of 1 character.
+     *                 The password must be set to null if the
+     *                 {@code method} is {@link #PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC},
+     *                 {@link #PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE} or
+     *                 {@link #PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE}.
+     *
+     * @throws IllegalArgumentException if the input pairing bootstrapping method is not
+     * one of the {@code PAIRING_BOOTSTRAPPING_METHOD_*}.
+     * @throws IllegalArgumentException if a non-null password is set for pairing bootstrapping
+     * method {@link #PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC},
+     * {@link #PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE} or
+     * {@link #PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE}.
      */
     public WifiP2pPairingBootstrappingConfig(
             @WifiP2pPairingBootstrappingConfig.PairingBootstrappingMethod int method,
             @Nullable String password) {
+        if (!isValidPairingBootstrappingMethod(method)) {
+            throw new IllegalArgumentException("Invalid PairingBootstrappingMethod =" + method);
+        }
         mPairingBootstrappingMethod = method;
+        if (!TextUtils.isEmpty(password)
+                && (method == PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC
+                || method == PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE
+                || method == PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE)) {
+            throw new IllegalArgumentException("Password is not required for =" + method);
+        }
         mPassword = password;
     }
 
diff --git a/framework/java/android/net/wifi/p2p/WifiP2pProvDiscEvent.java b/framework/java/android/net/wifi/p2p/WifiP2pProvDiscEvent.java
index 481075b9ac..a5e7ef15bd 100644
--- a/framework/java/android/net/wifi/p2p/WifiP2pProvDiscEvent.java
+++ b/framework/java/android/net/wifi/p2p/WifiP2pProvDiscEvent.java
@@ -38,21 +38,40 @@ public class WifiP2pProvDiscEvent {
 
     private static final String TAG = "WifiP2pProvDiscEvent";
 
-    public static final int PBC_REQ     = 1;
-    public static final int PBC_RSP     = 2;
-    public static final int ENTER_PIN   = 3;
-    public static final int SHOW_PIN    = 4;
-
-    /* One of PBC_REQ, PBC_RSP, ENTER_PIN or SHOW_PIN */
+    public static final int WPS_PBC_REQ     = 1;
+    public static final int WPS_PBC_RSP     = 2;
+    public static final int WPS_ENTER_PIN   = 3;
+    public static final int WPS_SHOW_PIN    = 4;
+    public static final int PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ = 5;
+    public static final int PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP = 6;
+    public static final int PAIRING_BOOTSTRAPPING_ENTER_PIN = 7;
+    public static final int PAIRING_BOOTSTRAPPING_SHOW_PIN = 8;
+    public static final int PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE = 9;
+    public static final int PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE = 10;
+
+    /*
+     * One of WPS_PBC_REQ, WPS_PBC_RSP, WPS_ENTER_PIN, WPS_SHOW_PIN,
+     * PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ, PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP,
+     * PAIRING_BOOTSTRAPPING_ENTER_PIN, PAIRING_BOOTSTRAPPING_SHOW_PIN,
+     * PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE or PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE.
+     */
     @UnsupportedAppUsage
     public int event;
 
     @UnsupportedAppUsage
     public WifiP2pDevice device;
 
-    /* Valid when event = SHOW_PIN */
+    /*
+     * Valid when event = WPS_SHOW_PIN
+     */
+    @UnsupportedAppUsage
+    public String wpsPin;
+
+    /*
+     * Whether the provision discovery frame is with a comeback request.
+     */
     @UnsupportedAppUsage
-    public String pin;
+    public boolean isComeback;
 
     /** List of {@link OuiKeyedData} providing vendor-specific configuration data. */
     private @NonNull List<OuiKeyedData> mVendorData = Collections.emptyList();
@@ -114,18 +133,24 @@ public class WifiP2pProvDiscEvent {
             throw new IllegalArgumentException("Malformed event " + string);
         }
 
-        if (tokens[0].endsWith("PBC-REQ")) event = PBC_REQ;
-        else if (tokens[0].endsWith("PBC-RESP")) event = PBC_RSP;
-        else if (tokens[0].endsWith("ENTER-PIN")) event = ENTER_PIN;
-        else if (tokens[0].endsWith("SHOW-PIN")) event = SHOW_PIN;
-        else throw new IllegalArgumentException("Malformed event " + string);
+        if (tokens[0].endsWith("PBC-REQ")) {
+            event = WPS_PBC_REQ;
+        } else if (tokens[0].endsWith("PBC-RESP")) {
+            event = WPS_PBC_RSP;
+        } else if (tokens[0].endsWith("ENTER-PIN")) {
+            event = WPS_ENTER_PIN;
+        } else if (tokens[0].endsWith("SHOW-PIN")) {
+            event = WPS_SHOW_PIN;
+        } else {
+            throw new IllegalArgumentException("Malformed event " + string);
+        }
 
 
         device = new WifiP2pDevice();
         device.deviceAddress = tokens[1];
 
-        if (event == SHOW_PIN) {
-            pin = tokens[2];
+        if (event == WPS_SHOW_PIN) {
+            wpsPin = tokens[2];
         }
     }
 
@@ -133,8 +158,9 @@ public class WifiP2pProvDiscEvent {
         StringBuffer sbuf = new StringBuffer();
         sbuf.append(device);
         sbuf.append("\n event: ").append(event);
-        sbuf.append("\n pin: ").append(pin);
+        sbuf.append("\n wpsPin: ").append(wpsPin);
         sbuf.append("\n vendorData: ").append(mVendorData);
+        sbuf.append("\n isComeback: ").append(isComeback);
         return sbuf.toString();
     }
 }
diff --git a/framework/java/android/net/wifi/p2p/WifiP2pUsdBasedLocalServiceAdvertisementConfig.java b/framework/java/android/net/wifi/p2p/WifiP2pUsdBasedLocalServiceAdvertisementConfig.java
index 4d5a369047..3845f45c70 100644
--- a/framework/java/android/net/wifi/p2p/WifiP2pUsdBasedLocalServiceAdvertisementConfig.java
+++ b/framework/java/android/net/wifi/p2p/WifiP2pUsdBasedLocalServiceAdvertisementConfig.java
@@ -118,7 +118,7 @@ public final class WifiP2pUsdBasedLocalServiceAdvertisementConfig implements Par
          *
          */
         @NonNull
-        public Builder setFrequencyMhz(@IntRange(from = 0) int frequencyMhz) {
+        public Builder setFrequencyMhz(@IntRange(from = 1) int frequencyMhz) {
             if (frequencyMhz <= 0) {
                 throw new IllegalArgumentException("Frequency must be greater than 0");
             }
diff --git a/framework/java/android/net/wifi/p2p/WifiP2pUsdBasedServiceDiscoveryConfig.java b/framework/java/android/net/wifi/p2p/WifiP2pUsdBasedServiceDiscoveryConfig.java
index ed0d9b804f..dfbe54c2ee 100644
--- a/framework/java/android/net/wifi/p2p/WifiP2pUsdBasedServiceDiscoveryConfig.java
+++ b/framework/java/android/net/wifi/p2p/WifiP2pUsdBasedServiceDiscoveryConfig.java
@@ -47,11 +47,10 @@ public final class WifiP2pUsdBasedServiceDiscoveryConfig implements Parcelable {
 
     /**
      * Frequencies on which the service needs to be scanned for.
-     * Used when band is set to WIFI_BAND_UNSPECIFIED.
+     * Used when band is set to ScanResult.UNSPECIFIED.
      */
     private int[] mFrequenciesMhz;
 
-
     private WifiP2pUsdBasedServiceDiscoveryConfig(int band, @NonNull int[] frequencies) {
         mBand = band;
         mFrequenciesMhz = frequencies;
@@ -125,6 +124,8 @@ public final class WifiP2pUsdBasedServiceDiscoveryConfig implements Parcelable {
      * Builder for {@link WifiP2pUsdBasedServiceDiscoveryConfig}.
      */
     public static final class Builder {
+        /** Maximum allowed number of channel frequencies */
+        private static final int MAXIMUM_CHANNEL_FREQUENCIES = 48;
         private int mBand;
         private int[] mFrequenciesMhz;
 
@@ -169,12 +170,18 @@ public final class WifiP2pUsdBasedServiceDiscoveryConfig implements Parcelable {
          *     mutually exclusive. Setting band and frequencies both is invalid.
          * <p>
          *     Optional. 2437 by default.
-         * @param frequenciesMhz Frequencies in MHz to scan for services.
+         * @param frequenciesMhz Frequencies in MHz to scan for services. This value cannot be an
+         *                       empty array of frequencies.
          * @return Instance of {@link Builder} to enable chaining of the builder method.
          */
         @NonNull
         public Builder setFrequenciesMhz(@NonNull int[] frequenciesMhz) {
             Objects.requireNonNull(frequenciesMhz, "Frequencies cannot be null");
+            if (frequenciesMhz.length < 1 || frequenciesMhz.length > MAXIMUM_CHANNEL_FREQUENCIES) {
+                throw new IllegalArgumentException("Number of frequencies: "
+                        + frequenciesMhz.length
+                        + " must be between 1 and " + MAXIMUM_CHANNEL_FREQUENCIES);
+            }
             mFrequenciesMhz = frequenciesMhz;
             return this;
         }
diff --git a/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceInfo.java b/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceInfo.java
index 6cf3031c8d..40dc1803b9 100644
--- a/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceInfo.java
+++ b/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceInfo.java
@@ -103,6 +103,21 @@ public class WifiP2pServiceInfo implements Parcelable {
      */
     private WifiP2pUsdBasedServiceConfig mUsdServiceConfig;
 
+    /**
+     * Service advertisement session ID / Publish ID for USD based service advertisement.
+     * This is a nonzero value used to identify the instance of service advertisement.
+     * This value is filled in the service discovery response frame (USD publish frame),
+     * Service descriptor attribute (SDA) - instance ID field.
+     */
+    /**
+     * Service advertisement session ID (Advertiser ID) for USD based service discovery response.
+     * The session ID is used to identify a local advertisement session.
+     * It is a nonzero ID in the range of 1 to 255 filled in the Service descriptor attribute (SDA)
+     * - instance ID field of the service discovery response frame (Publish frame).
+     * Zero by default indicates that the USD session for this service is not running.
+     */
+    private int mUsdSessionId;
+
     /**
      * This is only used in subclass.
      *
@@ -122,12 +137,13 @@ public class WifiP2pServiceInfo implements Parcelable {
      *
      * @param queryList query string for wpa_supplicant
      * @param usdConfig See {@link WifiP2pUsdBasedServiceConfig}
-     *
+     * @param usdSessionId The USD based service advertisement session ID.
      */
     private WifiP2pServiceInfo(List<String> queryList,
-            @NonNull WifiP2pUsdBasedServiceConfig usdConfig) {
+            @NonNull WifiP2pUsdBasedServiceConfig usdConfig, int usdSessionId) {
         mQueryList = queryList;
         mUsdServiceConfig = usdConfig;
+        mUsdSessionId = usdSessionId;
     }
 
     /**
@@ -178,6 +194,34 @@ public class WifiP2pServiceInfo implements Parcelable {
         return mUsdServiceConfig;
     }
 
+    /**
+     * Return the Service advertisement session ID for USD based service advertisement.
+     *
+     * @return session id
+     * @hide
+     */
+    /**
+     * Return the Service advertisement session ID for USD based service advertisement.
+     * This ID is used to identify a service advertisement session.
+     *
+     * @return A nonzero ID in the range of 1 to 255 when the session is running.
+     * @hide
+     */
+    public int getUsdSessionId() {
+        return mUsdSessionId;
+    }
+
+    /**
+     * Set the service advertisement session ID for USD based service advertisement.
+     * Default value is zero.
+     *
+     * @param sessionId nonzero session ID is set when the USD session for this service is started.
+     * @hide
+     */
+    public void setUsdSessionId(int sessionId) {
+        mUsdSessionId = sessionId;
+    }
+
    /**
     * Converts byte array to hex string.
     *
@@ -214,6 +258,10 @@ public class WifiP2pServiceInfo implements Parcelable {
             return false;
         }
 
+       /*
+        * Don't compare USD based service advertisement session ID.
+        * The session ID may be changed on each service discovery advertisement.
+        */
         WifiP2pServiceInfo servInfo = (WifiP2pServiceInfo) o;
         return Objects.equals(mQueryList, servInfo.mQueryList)
                 && Objects.equals(mUsdServiceConfig, servInfo.mUsdServiceConfig);
@@ -237,6 +285,7 @@ public class WifiP2pServiceInfo implements Parcelable {
         dest.writeStringList(mQueryList);
         if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()) {
             dest.writeParcelable(mUsdServiceConfig, flags);
+            dest.writeInt(mUsdSessionId);
         }
     }
 
@@ -248,11 +297,13 @@ public class WifiP2pServiceInfo implements Parcelable {
                     List<String> data = new ArrayList<String>();
                     in.readStringList(data);
                     WifiP2pUsdBasedServiceConfig config = null;
+                    int usdSessionId = 0;
                     if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()) {
                         config = in.readParcelable(
                                 WifiP2pUsdBasedServiceConfig.class.getClassLoader());
+                        usdSessionId = in.readInt();
                     }
-                    return new WifiP2pServiceInfo(data, config);
+                    return new WifiP2pServiceInfo(data, config, usdSessionId);
                 }
                 public WifiP2pServiceInfo[] newArray(int size) {
                     return new WifiP2pServiceInfo[size];
diff --git a/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceRequest.java b/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceRequest.java
index 039d93d53a..f76c17da46 100644
--- a/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceRequest.java
+++ b/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceRequest.java
@@ -82,6 +82,17 @@ public class WifiP2pServiceRequest implements Parcelable {
      */
     private WifiP2pUsdBasedServiceConfig mUsdServiceConfig;
 
+    /**
+     * Service discovery request session ID (Seeker ID) for USD based service discovery.
+     * The session ID is used to match the USD based service discovery request/response frames.
+     * A nonzero ID in the range of 1 to 255 is filled in the Service descriptor attribute (SDA) -
+     * instance ID field of the service discovery request frame (Subscribe frame). The responding
+     * device copies this ID in the Service descriptor attribute (SDA) - requester instance ID
+     * field of the service discovery response frame (Publish frame).
+     * Zero by default indicates that the USD session for this service is not running.
+     */
+    private int mUsdSessionId = 0;
+
     /**
      * This constructor is only used in newInstance().
      *
@@ -110,14 +121,17 @@ public class WifiP2pServiceRequest implements Parcelable {
      * @param transId the transaction id
      * @param query The part of service specific query.
      * @param usdConfig The USD based service config.
+     * @param usdSessionId The USD based service discovery request session ID.
      */
     private WifiP2pServiceRequest(int serviceType, int length,
-            int transId, String query, @NonNull WifiP2pUsdBasedServiceConfig usdConfig) {
+            int transId, String query, @NonNull WifiP2pUsdBasedServiceConfig usdConfig,
+            int usdSessionId) {
         mProtocolType = serviceType;
         mLength = length;
         mTransId = transId;
         mQuery = query;
         mUsdServiceConfig = usdConfig;
+        mUsdSessionId = usdSessionId;
     }
 
     /**
@@ -167,6 +181,28 @@ public class WifiP2pServiceRequest implements Parcelable {
         return sb.toString();
     }
 
+    /**
+     * Return the USD based service discovery request session ID.
+     * This ID is used to match the USD based service request/response frames.
+     *
+     * @return A nonzero ID in the range of 1 to 255 when the session is running.
+     * @hide
+     */
+    public int getUsdSessionId() {
+        return mUsdSessionId;
+    }
+
+    /**
+     * Set the USD based service discovery request session ID.
+     * Default value is zero.
+     *
+     * @param sessionId nonzero session ID is set when the USD session for this service is started.
+     * @hide
+     */
+    public void setUsdSessionId(int sessionId) {
+        mUsdSessionId = sessionId;
+    }
+
     /**
      /**
      * Get the service information configured to discover a service using un-synchronized service
@@ -314,6 +350,7 @@ public class WifiP2pServiceRequest implements Parcelable {
         dest.writeString(mQuery);
         if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()) {
             dest.writeParcelable(mUsdServiceConfig, flags);
+            dest.writeInt(mUsdSessionId);
         }
     }
 
@@ -327,11 +364,14 @@ public class WifiP2pServiceRequest implements Parcelable {
                     int transId = in.readInt();
                     String query = in.readString();
                     WifiP2pUsdBasedServiceConfig config = null;
+                    int usdSessionId = 0;
                     if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()) {
                         config = in.readParcelable(
                                 WifiP2pUsdBasedServiceConfig.class.getClassLoader());
+                        usdSessionId = in.readInt();
                     }
-                    return new WifiP2pServiceRequest(servType, length, transId, query, config);
+                    return new WifiP2pServiceRequest(servType, length, transId, query, config,
+                            usdSessionId);
                 }
                 public WifiP2pServiceRequest[] newArray(int size) {
                     return new WifiP2pServiceRequest[size];
diff --git a/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceResponse.java b/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceResponse.java
index b0ef358321..16025d512e 100644
--- a/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceResponse.java
+++ b/framework/java/android/net/wifi/p2p/nsd/WifiP2pServiceResponse.java
@@ -76,6 +76,17 @@ public class WifiP2pServiceResponse implements Parcelable {
      */
     private WifiP2pUsdBasedServiceResponse mUsdBasedServiceResponse;
 
+    /**
+     * Service discovery response requester session ID (Seeker ID) for USD based service discovery.
+     * The session ID is used to match the USD based service discovery request/response frames.
+     * A nonzero ID in the range of 1 to 255 is filled in the Service descriptor attribute (SDA) -
+     * instance ID field of the service discovery request frame (Subscribe frame). The responding
+     * device copies this ID in the Service descriptor attribute (SDA) - requester instance ID
+     * field of the service discovery response frame (Publish frame).
+     *
+     */
+    private int mUsdSessionId;
+
 
     /**
      * The status code of service discovery response.
@@ -140,16 +151,38 @@ public class WifiP2pServiceResponse implements Parcelable {
      *
      * @param device source device.
      * @param usdResponseData USD based service response data.
+     * @param usdSessionId The USD based service discovery request/response session ID.
      * @hide
      */
     public WifiP2pServiceResponse(WifiP2pDevice device,
-            @NonNull WifiP2pUsdBasedServiceResponse usdResponseData) {
+            @NonNull WifiP2pUsdBasedServiceResponse usdResponseData, int usdSessionId) {
         mServiceType = 0;
         mStatus = 0;
         mTransId = 0;
         mDevice = device;
         mData = null;
         mUsdBasedServiceResponse = usdResponseData;
+        mUsdSessionId = usdSessionId;
+    }
+
+    /**
+     * Return the USD based service discovery session ID.
+     *
+     * @return A nonzero ID in the range of 1 to 255.
+     * @hide
+     */
+    public int getUsdSessionId() {
+        return mUsdSessionId;
+    }
+
+    /**
+     * Set the USD based service discovery session ID.
+     *
+     * @param sessionId A nonzero ID in the range of 1 to 255.
+     * @hide
+     */
+    public void setUsdSessionId(int sessionId) {
+        mUsdSessionId = sessionId;
     }
 
     /**
@@ -399,6 +432,7 @@ public class WifiP2pServiceResponse implements Parcelable {
         }
         if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()) {
             dest.writeParcelable(mUsdBasedServiceResponse, flags);
+            dest.writeInt(mUsdSessionId);
         }
     }
 
@@ -416,17 +450,19 @@ public class WifiP2pServiceResponse implements Parcelable {
                         data = new byte[len];
                         in.readByteArray(data);
                     }
-                    WifiP2pUsdBasedServiceResponse response = null;
+                    WifiP2pUsdBasedServiceResponse usdServResponse = null;
+                    int usdSessionId = 0;
                     if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()) {
-                        response = in.readParcelable(
+                        usdServResponse = in.readParcelable(
                                 WifiP2pUsdBasedServiceResponse.class.getClassLoader());
+                        usdSessionId = in.readInt();
                     }
                     if (type ==  WifiP2pServiceInfo.SERVICE_TYPE_BONJOUR) {
                         return WifiP2pDnsSdServiceResponse.newInstance(status, transId, dev, data);
                     } else if (type == WifiP2pServiceInfo.SERVICE_TYPE_UPNP) {
                         return WifiP2pUpnpServiceResponse.newInstance(status, transId, dev, data);
-                    } else if (response != null) {
-                        return new WifiP2pServiceResponse(dev, response);
+                    } else if (usdServResponse != null) {
+                        return new WifiP2pServiceResponse(dev, usdServResponse, usdSessionId);
                     }
                     return new WifiP2pServiceResponse(type, status, transId, dev, data);
                 }
diff --git a/framework/java/android/net/wifi/p2p/nsd/WifiP2pUsdBasedServiceConfig.java b/framework/java/android/net/wifi/p2p/nsd/WifiP2pUsdBasedServiceConfig.java
index 41b8783d67..74834f3d44 100644
--- a/framework/java/android/net/wifi/p2p/nsd/WifiP2pUsdBasedServiceConfig.java
+++ b/framework/java/android/net/wifi/p2p/nsd/WifiP2pUsdBasedServiceConfig.java
@@ -22,6 +22,7 @@ import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresApi;
+import android.annotation.Size;
 import android.os.Build;
 import android.os.Parcel;
 import android.os.Parcelable;
@@ -44,6 +45,9 @@ import java.util.Objects;
 @RequiresApi(Build.VERSION_CODES.BAKLAVA)
 @FlaggedApi(Flags.FLAG_WIFI_DIRECT_R2)
 public final class WifiP2pUsdBasedServiceConfig implements Parcelable {
+    /** Maximum allowed length of service specific information */
+    private static final int SERVICE_SPECIFIC_INFO_MAXIMUM_LENGTH = 1024;
+
     /** Bonjour service protocol type */
     public static final int SERVICE_PROTOCOL_TYPE_BONJOUR = 1;
 
@@ -95,7 +99,7 @@ public final class WifiP2pUsdBasedServiceConfig implements Parcelable {
         return mServiceName;
     }
 
-    /** Get the service specific info of this USD service configuration. see also
+    /** Get the service specific info of this USD service configuration. See also
      * {@link Builder#setServiceSpecificInfo(byte[])} .
      *
      *
@@ -106,6 +110,15 @@ public final class WifiP2pUsdBasedServiceConfig implements Parcelable {
         return mServiceSpecificInfo;
     }
 
+    /**
+     * Maximum allowed length of service specific information that can be set in the USD service
+     * configuration.
+     * See also {@link Builder#setServiceSpecificInfo(byte[])}.
+     */
+    public static int getMaxAllowedServiceSpecificInfoLength() {
+        return SERVICE_SPECIFIC_INFO_MAXIMUM_LENGTH;
+    }
+
     /**
      * Generates a string of all the defined elements.
      *
@@ -156,9 +169,6 @@ public final class WifiP2pUsdBasedServiceConfig implements Parcelable {
     public static final class Builder {
         /** Maximum allowed length of service name */
         private static final int SERVICE_NAME_MAXIMUM_LENGTH = 100;
-
-        /** Maximum allowed length of service specific information */
-        private static final int SERVICE_SPECIFIC_INFO_MAXIMUM_LENGTH = 1024;
         private int mServiceProtocolType = SERVICE_PROTOCOL_TYPE_GENERIC;
         private @NonNull String mServiceName;
         byte[] mServiceSpecificInfo;
@@ -167,9 +177,9 @@ public final class WifiP2pUsdBasedServiceConfig implements Parcelable {
          * Constructor for {@link Builder}.
          *
          * @param serviceName The service name defining the service. The maximum
-         *                    allowed length of the service name is 100 bytes.
+         *                    allowed length of the service name is 100 characters.
          */
-        public Builder(@NonNull String serviceName) {
+        public Builder(@Size(min = 1) @NonNull String serviceName) {
             Objects.requireNonNull(serviceName, "Service name cannot be null");
             if (TextUtils.isEmpty(serviceName)) {
                 throw new IllegalArgumentException("Service name cannot be empty!");
@@ -209,18 +219,20 @@ public final class WifiP2pUsdBasedServiceConfig implements Parcelable {
          *     Optional. Empty by default.
          *
          * @param serviceSpecificInfo A byte-array of service-specific information available to the
-         *                            application to send additional information. The maximum
-         *                            allowed length of this byte-array is 1024 bytes.
+         *                            application to send additional information. Users must call
+         *                            {@link #getMaxAllowedServiceSpecificInfoLength()} method to
+         *                            know maximum allowed legth.
          *
          * @return The builder to facilitate chaining {@code builder.setXXX(..).setXXX(..)}.
          */
         @NonNull
-        public Builder setServiceSpecificInfo(@Nullable byte[] serviceSpecificInfo) {
+        public Builder setServiceSpecificInfo(
+                @Size(min = 1) @Nullable byte[] serviceSpecificInfo) {
             if (serviceSpecificInfo != null
-                    && serviceSpecificInfo.length > SERVICE_SPECIFIC_INFO_MAXIMUM_LENGTH) {
+                    && serviceSpecificInfo.length > getMaxAllowedServiceSpecificInfoLength()) {
                 throw new IllegalArgumentException("Service specific info length: "
                         + serviceSpecificInfo.length
-                        + " must be less than " + SERVICE_SPECIFIC_INFO_MAXIMUM_LENGTH);
+                        + " must be less than " + getMaxAllowedServiceSpecificInfoLength());
             }
             mServiceSpecificInfo = serviceSpecificInfo;
             return this;
diff --git a/framework/java/android/net/wifi/rtt/PasnConfig.java b/framework/java/android/net/wifi/rtt/PasnConfig.java
index 9688f5eee3..291a963f5b 100644
--- a/framework/java/android/net/wifi/rtt/PasnConfig.java
+++ b/framework/java/android/net/wifi/rtt/PasnConfig.java
@@ -120,17 +120,14 @@ public final class PasnConfig implements Parcelable {
 
     static {
         sStringToAkm.put("None", AKM_NONE);
-        sStringToAkm.put("PASN-", AKM_PASN);
-        // Transition mode. e.g. "[RSN-SAE+SAE_EXT_KEY-CCMP]"
-        sStringToAkm.put("SAE+", AKM_SAE);
-        // SAE mode only. e.g. "[RSN-PSK+SAE-CCMP]"
-        sStringToAkm.put("SAE-", AKM_SAE);
-        sStringToAkm.put("EAP-FILS-SHA256-", AKM_FILS_EAP_SHA256);
-        sStringToAkm.put("EAP-FILS-SHA384-", AKM_FILS_EAP_SHA384);
-        sStringToAkm.put("FT/EAP-", AKM_FT_EAP_SHA256);
-        sStringToAkm.put("FT/PSK-", AKM_FT_PSK_SHA256);
-        sStringToAkm.put("EAP-FT-SHA384-", AKM_FT_EAP_SHA384);
-        sStringToAkm.put("FT/PSK-SHA384-", AKM_FT_PSK_SHA384);
+        sStringToAkm.put("PASN", AKM_PASN);
+        sStringToAkm.put("SAE", AKM_SAE);
+        sStringToAkm.put("EAP-FILS-SHA256", AKM_FILS_EAP_SHA256);
+        sStringToAkm.put("EAP-FILS-SHA384", AKM_FILS_EAP_SHA384);
+        sStringToAkm.put("FT/EAP", AKM_FT_EAP_SHA256);
+        sStringToAkm.put("FT/PSK", AKM_FT_PSK_SHA256);
+        sStringToAkm.put("EAP-FT-SHA384", AKM_FT_EAP_SHA384);
+        sStringToAkm.put("FT/PSK-SHA384", AKM_FT_PSK_SHA384);
     }
 
     /**
@@ -174,17 +171,17 @@ public final class PasnConfig implements Parcelable {
 
     static {
         sStringToCipher.put("None", CIPHER_NONE);
-        sStringToCipher.put("-CCMP]", CIPHER_CCMP_128);
-        sStringToCipher.put("-CCMP-256]", CIPHER_CCMP_256);
-        sStringToCipher.put("-GCMP-128]", CIPHER_GCMP_128);
-        sStringToCipher.put("-GCMP-256]", CIPHER_GCMP_256);
+        sStringToCipher.put("CCMP-128", CIPHER_CCMP_128);
+        sStringToCipher.put("CCMP-256", CIPHER_CCMP_256);
+        sStringToCipher.put("GCMP-128", CIPHER_GCMP_128);
+        sStringToCipher.put("GCMP-256", CIPHER_GCMP_256);
     }
 
     @AkmType
     private final int mBaseAkms;
     @Cipher
     private final int mCiphers;
-    private final String mPassword;
+    private String mPassword;
     private final WifiSsid mWifiSsid;
     private final byte[] mPasnComebackCookie;
 
@@ -212,6 +209,13 @@ public final class PasnConfig implements Parcelable {
         return mPassword;
     }
 
+    /**
+     * @hide
+     */
+    public void setPassword(String password) {
+        mPassword = password;
+    }
+
     /**
      * Get Wifi SSID which is used to retrieve saved network profile if {@link #getPassword()}
      * is null. If Wifi SSID and password are not set and there is no saved profile corresponding to
@@ -263,6 +267,7 @@ public final class PasnConfig implements Parcelable {
         dest.writeInt(mBaseAkms);
         dest.writeInt(mCiphers);
         dest.writeString(mPassword);
+        dest.writeParcelable(mWifiSsid, flags);
         dest.writeByteArray(mPasnComebackCookie);
     }
 
@@ -425,8 +430,9 @@ public final class PasnConfig implements Parcelable {
 
     @Override
     public String toString() {
+        String password = (mPassword != null ? "*" : "null");
         return "PasnConfig{" + "mBaseAkms=" + mBaseAkms + ", mCiphers=" + mCiphers + ", mPassword='"
-                + mPassword + '\'' + ", mWifiSsid=" + mWifiSsid + ", mPasnComebackCookie="
+                + password + '\'' + ", mWifiSsid=" + mWifiSsid + ", mPasnComebackCookie="
                 + Arrays.toString(mPasnComebackCookie) + '}';
     }
 }
diff --git a/framework/java/android/net/wifi/rtt/RangingRequest.java b/framework/java/android/net/wifi/rtt/RangingRequest.java
index 31c07151b3..bca71db208 100644
--- a/framework/java/android/net/wifi/rtt/RangingRequest.java
+++ b/framework/java/android/net/wifi/rtt/RangingRequest.java
@@ -20,6 +20,7 @@ import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.net.MacAddress;
 import android.net.wifi.OuiKeyedData;
@@ -34,6 +35,7 @@ import android.os.Build;
 import android.os.Handler;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.util.Log;
 
 import androidx.annotation.RequiresApi;
 
@@ -44,6 +46,7 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.StringJoiner;
@@ -59,6 +62,7 @@ import java.util.StringJoiner;
  * {@link RangingRequest.Builder#addAccessPoints(List)}).
  */
 public final class RangingRequest implements Parcelable {
+    private static final String TAG = "RangingRequest";
     private static final int MAX_PEERS = 10;
     private static final int DEFAULT_RTT_BURST_SIZE = 8;
     private static final int MIN_RTT_BURST_SIZE = 2;
@@ -600,11 +604,45 @@ public final class RangingRequest implements Parcelable {
         }
 
 
+        /**
+         * Filter the peer list for the security modes SECURITY_MODE_SECURE_AUTH and
+         * SECURITY_MODE_OPEN.
+         */
+        @SuppressLint("NewApi")
+        private void filterRttPeersBasedOnSecurityMode() {
+            Iterator<ResponderConfig> peers = mRttPeers.iterator();
+            while (peers.hasNext()) {
+                ResponderConfig peer = peers.next();
+                SecureRangingConfig config = peer.getSecureRangingConfig();
+                // For SECURITY_MODE_SECURE_AUTH, remove any non-authenticated peer.
+                if (mSecurityMode == SECURITY_MODE_SECURE_AUTH) {
+                    PasnConfig pasn = (config != null) ? config.getPasnConfig() : null;
+                    if (pasn == null || pasn.getBaseAkms() == PasnConfig.AKM_PASN) {
+                        peers.remove();
+                        Log.i(TAG, "SECURITY_MODE_SECURE_AUTH is set, removing non-secure peer: "
+                                + peer.getMacAddress());
+                    }
+                } else if (mSecurityMode == SECURITY_MODE_OPEN) {
+                    // For SECURITY_MODE_OPEN, remove any frame protection enabled peer.
+                    // At AIDL level, secure config will not be passed to HAL.
+                    if (config.isRangingFrameProtectionEnabled()) {
+                        peers.remove();
+                        Log.i(TAG, "SECURITY_MODE_OPEN is set, removing secure peer: "
+                                + peer.getMacAddress());
+                    }
+                }
+            }
+        }
+
+
         /**
          * Build {@link RangingRequest} given the current configurations made on the
          * builder.
          */
         public RangingRequest build() {
+            if (mSecurityMode != SECURITY_MODE_OPPORTUNISTIC) {
+                filterRttPeersBasedOnSecurityMode();
+            }
             return new RangingRequest(mRttPeers, mRttBurstSize, mSecurityMode, mVendorData);
         }
     }
diff --git a/framework/java/android/net/wifi/rtt/RangingResult.java b/framework/java/android/net/wifi/rtt/RangingResult.java
index 604c879daa..09d196ab44 100644
--- a/framework/java/android/net/wifi/rtt/RangingResult.java
+++ b/framework/java/android/net/wifi/rtt/RangingResult.java
@@ -197,6 +197,14 @@ public final class RangingResult implements Parcelable {
             mR2iTxLtfRepetitions = other.mR2iTxLtfRepetitions;
             mNumTxSpatialStreams = other.mNumTxSpatialStreams;
             mNumRxSpatialStreams = other.mNumRxSpatialStreams;
+            mIsRangingAuthenticated = other.mIsRangingAuthenticated;
+            mIsRangingFrameProtected = other.mIsRangingFrameProtected;
+            mIsSecureHeLtfEnabled = other.mIsSecureHeLtfEnabled;
+            mSecureHeLtfProtocolVersion = other.mSecureHeLtfProtocolVersion;
+            if (other.mPasnComebackCookie != null) {
+                mPasnComebackCookie = other.mPasnComebackCookie.clone();
+                mPasnComebackAfterMillis = other.mPasnComebackAfterMillis;
+            }
             mVendorData = new ArrayList<>(other.mVendorData);
         }
 
@@ -1168,6 +1176,12 @@ public final class RangingResult implements Parcelable {
         if (SdkLevel.isAtLeastV()) {
             dest.writeList(mVendorData);
         }
+        dest.writeBoolean(mIsRangingAuthenticated);
+        dest.writeBoolean(mIsRangingFrameProtected);
+        dest.writeBoolean(mIsSecureHeLtfEnabled);
+        dest.writeLong(mPasnComebackAfterMillis);
+        dest.writeByteArray(mPasnComebackCookie);
+        dest.writeInt(mSecureHeLtfProtocolVersion);
     }
 
     public static final @android.annotation.NonNull Creator<RangingResult> CREATOR =
@@ -1208,6 +1222,12 @@ public final class RangingResult implements Parcelable {
                     if (SdkLevel.isAtLeastV()) {
                         builder.setVendorData(ParcelUtil.readOuiKeyedDataList(in));
                     }
+                    builder.setRangingAuthenticated(in.readBoolean())
+                            .setRangingFrameProtected(in.readBoolean())
+                            .setSecureHeLtfEnabled(in.readBoolean())
+                            .setPasnComebackAfterMillis(in.readLong())
+                            .setPasnComebackCookie(in.createByteArray())
+                            .setSecureHeLtfProtocolVersion(in.readInt());
                     return builder.build();
                 }
             };
@@ -1239,11 +1259,11 @@ public final class RangingResult implements Parcelable {
                 .append(", numTxSpatialStreams=").append(mNumTxSpatialStreams)
                 .append(", numRxSpatialStreams=").append(mNumRxSpatialStreams)
                 .append(", vendorData=").append(mVendorData)
-                .append(", isRangingAuthenticated").append(mIsRangingAuthenticated)
-                .append(", isRangingFrameProtected").append(mIsRangingFrameProtected)
-                .append(", isSecureHeLtfEnabled").append(mIsSecureHeLtfEnabled)
-                .append(", pasnComebackCookie").append(Arrays.toString(mPasnComebackCookie))
-                .append(", pasnComebackAfterMillis").append(mPasnComebackAfterMillis)
+                .append(", isRangingAuthenticated=").append(mIsRangingAuthenticated)
+                .append(", isRangingFrameProtected=").append(mIsRangingFrameProtected)
+                .append(", isSecureHeLtfEnabled=").append(mIsSecureHeLtfEnabled)
+                .append(", pasnComebackCookie=").append(Arrays.toString(mPasnComebackCookie))
+                .append(", pasnComebackAfterMillis=").append(mPasnComebackAfterMillis)
                 .append("]").toString();
     }
 
diff --git a/framework/java/android/net/wifi/rtt/ResponderConfig.java b/framework/java/android/net/wifi/rtt/ResponderConfig.java
index a8fd2d5b5a..7d950eeabd 100644
--- a/framework/java/android/net/wifi/rtt/ResponderConfig.java
+++ b/framework/java/android/net/wifi/rtt/ResponderConfig.java
@@ -439,6 +439,10 @@ public final class ResponderConfig implements Parcelable {
         int centerFreq1 = scanResult.centerFreq1;
 
         int preamble;
+        // The IEEE 802.11mc is only compatible with HE and EHT when using the 6 GHz band.
+        // However, the IEEE 802.11az supports HE and EHT across all Wi-Fi bands (2.4GHz, 5 GHz,
+        // and 6 GHz).
+        boolean isHeOrEhtAllowed = supports80211azNtbRanging || ScanResult.is6GHz(frequency);
         if (scanResult.informationElements != null && scanResult.informationElements.length != 0) {
             boolean htCapabilitiesPresent = false;
             boolean vhtCapabilitiesPresent = false;
@@ -457,9 +461,9 @@ public final class ResponderConfig implements Parcelable {
                 }
             }
 
-            if (ehtCapabilitiesPresent && ScanResult.is6GHz(frequency)) {
+            if (ehtCapabilitiesPresent && isHeOrEhtAllowed) {
                 preamble = ScanResult.PREAMBLE_EHT;
-            } else if (heCapabilitiesPresent && ScanResult.is6GHz(frequency)) {
+            } else if (heCapabilitiesPresent && isHeOrEhtAllowed) {
                 preamble = ScanResult.PREAMBLE_HE;
             } else if (vhtCapabilitiesPresent) {
                 preamble = ScanResult.PREAMBLE_VHT;
@@ -470,9 +474,10 @@ public final class ResponderConfig implements Parcelable {
             }
         } else {
             Log.e(TAG, "Scan Results do not contain IEs - using backup method to select preamble");
-            if (channelWidth == ScanResult.CHANNEL_WIDTH_320MHZ) {
+            if (channelWidth == ScanResult.CHANNEL_WIDTH_320MHZ && isHeOrEhtAllowed) {
                 preamble = ScanResult.PREAMBLE_EHT;
-            } else if (channelWidth == ScanResult.CHANNEL_WIDTH_80MHZ
+            } else if (channelWidth == ScanResult.CHANNEL_WIDTH_320MHZ
+                    || channelWidth == ScanResult.CHANNEL_WIDTH_80MHZ
                     || channelWidth == ScanResult.CHANNEL_WIDTH_160MHZ) {
                 preamble = ScanResult.PREAMBLE_VHT;
             } else {
@@ -509,13 +514,14 @@ public final class ResponderConfig implements Parcelable {
         if (scanResult.getWifiSsid() != null) {
             pasnConfigBuilder.setWifiSsid(scanResult.getWifiSsid());
         }
+        // If the responder is capable of PASN, always enable frame protection for secure ranging
+        // irrespective of responder mandates or not.
         return new SecureRangingConfig.Builder(pasnConfigBuilder.build())
                 .setSecureHeLtfEnabled(scanResult.isSecureHeLtfSupported())
                 .setRangingFrameProtectionEnabled(true)
                 .build();
     }
 
-
     /**
      * Creates a Responder configuration from a MAC address corresponding to a Wi-Fi Aware
      * Responder. The Responder parameters are set to defaults.
@@ -1027,6 +1033,7 @@ public final class ResponderConfig implements Parcelable {
         dest.writeInt(preamble);
         dest.writeLong(mNtbMinMeasurementTime);
         dest.writeLong(mNtbMaxMeasurementTime);
+        dest.writeParcelable(mSecureRangingConfig, flags);
     }
 
     public static final @android.annotation.NonNull Creator<ResponderConfig> CREATOR = new Creator<ResponderConfig>() {
@@ -1048,7 +1055,7 @@ public final class ResponderConfig implements Parcelable {
                 peerHandle = new PeerHandle(in.readInt());
             }
 
-            return new ResponderConfig.Builder()
+            ResponderConfig.Builder builder = new Builder()
                     .setMacAddress(macAddress)
                     .setPeerHandle(peerHandle)
                     .setResponderType(in.readInt())
@@ -1060,8 +1067,15 @@ public final class ResponderConfig implements Parcelable {
                     .setCenterFreq1Mhz(in.readInt())
                     .setPreamble(in.readInt())
                     .setNtbMinTimeBetweenMeasurementsMicros(in.readLong())
-                    .setNtbMaxTimeBetweenMeasurementsMicros(in.readLong())
-                    .build();
+                    .setNtbMaxTimeBetweenMeasurementsMicros(in.readLong());
+            SecureRangingConfig secureRangingConfig = in.readParcelable(
+                    SecureRangingConfig.class.getClassLoader());
+
+            if (secureRangingConfig != null) {
+                builder.setSecureRangingConfig(secureRangingConfig);
+            }
+            return new ResponderConfig(builder);
+
         }
     };
 
@@ -1084,14 +1098,15 @@ public final class ResponderConfig implements Parcelable {
                 && centerFreq1 == lhs.centerFreq1 && preamble == lhs.preamble
                 && supports80211azNtb == lhs.supports80211azNtb
                 && mNtbMinMeasurementTime == lhs.mNtbMinMeasurementTime
-                && mNtbMaxMeasurementTime == lhs.mNtbMaxMeasurementTime;
+                && mNtbMaxMeasurementTime == lhs.mNtbMaxMeasurementTime
+                && Objects.equals(mSecureRangingConfig, lhs.mSecureRangingConfig);
     }
 
     @Override
     public int hashCode() {
         return Objects.hash(macAddress, peerHandle, responderType, supports80211mc, channelWidth,
                 frequency, centerFreq0, centerFreq1, preamble, supports80211azNtb,
-                mNtbMinMeasurementTime, mNtbMaxMeasurementTime);
+                mNtbMinMeasurementTime, mNtbMaxMeasurementTime, mSecureRangingConfig);
     }
 
     @Override
diff --git a/framework/java/android/net/wifi/usd/IUsdManager.aidl b/framework/java/android/net/wifi/usd/IUsdManager.aidl
index 030b240002..9e5812ccab 100644
--- a/framework/java/android/net/wifi/usd/IUsdManager.aidl
+++ b/framework/java/android/net/wifi/usd/IUsdManager.aidl
@@ -18,7 +18,6 @@ package android.net.wifi.usd;
 
 import android.net.wifi.IBooleanListener;
 import android.net.wifi.usd.Characteristics;
-import android.net.wifi.usd.IAvailabilityCallback;
 import android.net.wifi.usd.IPublishSessionCallback;
 import android.net.wifi.usd.ISubscribeSessionCallback;
 import android.net.wifi.usd.PublishConfig;
@@ -30,15 +29,15 @@ import android.net.wifi.usd.SubscribeConfig;
  * {@hide}
  */
 interface IUsdManager {
-    boolean isSubscriberAvailable();
-    boolean isPublisherAvailable();
-    void registerAvailabilityCallback(IAvailabilityCallback callback);
-    void unregisterAvailabilityCallback(IAvailabilityCallback callback);
     Characteristics getCharacteristics();
-    void sendMessage(int peerId, in byte[] message, in IBooleanListener listener);
+    void sendMessage(int sessionId, int peerId, in byte[] message, in IBooleanListener listener);
     void cancelSubscribe(int sessionId);
     void cancelPublish(int sessionId);
     void updatePublish(int sessionId, in byte[] ssi);
     void publish(in PublishConfig publishConfig, IPublishSessionCallback callback);
     void subscribe(in SubscribeConfig subscribeConfig, ISubscribeSessionCallback callback);
+    void registerSubscriberStatusListener(IBooleanListener listener);
+    void unregisterSubscriberStatusListener(IBooleanListener listener);
+    void registerPublisherStatusListener(IBooleanListener listener);
+    void unregisterPublisherStatusListener(IBooleanListener listener);
 }
diff --git a/framework/java/android/net/wifi/usd/PublishConfig.java b/framework/java/android/net/wifi/usd/PublishConfig.java
index 000235a61e..1428d1214d 100644
--- a/framework/java/android/net/wifi/usd/PublishConfig.java
+++ b/framework/java/android/net/wifi/usd/PublishConfig.java
@@ -364,7 +364,7 @@ public final class PublishConfig extends Config implements Parcelable {
         public Builder setOperatingFrequenciesMhz(@NonNull int[] operatingFrequencies) {
             Objects.requireNonNull(operatingFrequencies, "operatingFrequencies must not be null");
             if ((operatingFrequencies.length > MAX_NUM_OF_OPERATING_FREQUENCIES)
-                    || WifiNetworkSpecifier.validateChannelFrequencyInMhz(operatingFrequencies)) {
+                    || !WifiNetworkSpecifier.validateChannelFrequencyInMhz(operatingFrequencies)) {
                 throw new IllegalArgumentException("Invalid operatingFrequencies");
             }
             mOperatingFrequencies = operatingFrequencies.clone();
diff --git a/framework/java/android/net/wifi/usd/PublishSession.java b/framework/java/android/net/wifi/usd/PublishSession.java
index 5887c0c822..cc2ef59e5d 100644
--- a/framework/java/android/net/wifi/usd/PublishSession.java
+++ b/framework/java/android/net/wifi/usd/PublishSession.java
@@ -123,6 +123,6 @@ public class PublishSession {
             executor.execute(() -> resultCallback.accept(false));
             return;
         }
-        usdManager.sendMessage(peerId, message, executor, resultCallback);
+        usdManager.sendMessage(mSessionId, peerId, message, executor, resultCallback);
     }
 }
diff --git a/framework/java/android/net/wifi/usd/SubscribeConfig.java b/framework/java/android/net/wifi/usd/SubscribeConfig.java
index 546d2dc2c6..2aa935025c 100644
--- a/framework/java/android/net/wifi/usd/SubscribeConfig.java
+++ b/framework/java/android/net/wifi/usd/SubscribeConfig.java
@@ -334,7 +334,8 @@ public final class SubscribeConfig extends Config implements Parcelable {
             Objects.requireNonNull(recommendedFrequencies,
                     "recommendedFrequencies must not be null");
             if ((recommendedFrequencies.length > MAX_NUM_OF_OPERATING_FREQUENCIES)
-                    || WifiNetworkSpecifier.validateChannelFrequencyInMhz(recommendedFrequencies)) {
+                    || !WifiNetworkSpecifier.validateChannelFrequencyInMhz(
+                    recommendedFrequencies)) {
                 throw new IllegalArgumentException("Invalid recommendedFrequencies");
             }
             this.mRecommendedFrequencies = recommendedFrequencies.clone();
@@ -386,7 +387,7 @@ public final class SubscribeConfig extends Config implements Parcelable {
         public Builder setOperatingFrequenciesMhz(@NonNull int[] operatingFrequencies) {
             Objects.requireNonNull(operatingFrequencies, "operatingFrequencies must not be null");
             if ((operatingFrequencies.length > MAX_NUM_OF_OPERATING_FREQUENCIES)
-                    || WifiNetworkSpecifier.validateChannelFrequencyInMhz(operatingFrequencies)) {
+                    || !WifiNetworkSpecifier.validateChannelFrequencyInMhz(operatingFrequencies)) {
                 throw new IllegalArgumentException("Invalid operatingFrequencies");
             }
             mOperatingFrequencies = operatingFrequencies.clone();
diff --git a/framework/java/android/net/wifi/usd/SubscribeSession.java b/framework/java/android/net/wifi/usd/SubscribeSession.java
index ce039d17ac..f5d8d534e5 100644
--- a/framework/java/android/net/wifi/usd/SubscribeSession.java
+++ b/framework/java/android/net/wifi/usd/SubscribeSession.java
@@ -100,6 +100,6 @@ public class SubscribeSession {
             executor.execute(() -> resultCallback.accept(false));
             return;
         }
-        usdManager.sendMessage(peerId, message, executor, resultCallback);
+        usdManager.sendMessage(mSessionId, peerId, message, executor, resultCallback);
     }
 }
diff --git a/framework/java/android/net/wifi/usd/UsdManager.java b/framework/java/android/net/wifi/usd/UsdManager.java
index 98601ee5c8..1e77dfdd6e 100644
--- a/framework/java/android/net/wifi/usd/UsdManager.java
+++ b/framework/java/android/net/wifi/usd/UsdManager.java
@@ -68,8 +68,9 @@ public class UsdManager {
     private final Context mContext;
     private final IUsdManager mService;
     private static final String TAG = UsdManager.class.getName();
-
-    private static final SparseArray<IAvailabilityCallback> sAvailabilityCallbackMap =
+    private static final SparseArray<IBooleanListener> sPublisherAvailabilityListenerMap =
+            new SparseArray<>();
+    private static final SparseArray<IBooleanListener> sSubscriberAvailabilityListenerMap =
             new SparseArray<>();
 
     /** @hide */
@@ -79,10 +80,10 @@ public class UsdManager {
     }
 
     /** @hide */
-    public void sendMessage(int peerId, @NonNull byte[] message, @NonNull Executor executor,
-            @NonNull Consumer<Boolean> resultCallback) {
+    public void sendMessage(int sessionId, int peerId, @NonNull byte[] message,
+            @NonNull Executor executor, @NonNull Consumer<Boolean> resultCallback) {
         try {
-            mService.sendMessage(peerId, message, new IBooleanListener.Stub() {
+            mService.sendMessage(sessionId, peerId, message, new IBooleanListener.Stub() {
                 @Override
                 public void onResult(boolean value) throws RemoteException {
                     Binder.clearCallingIdentity();
@@ -121,148 +122,6 @@ public class UsdManager {
         }
     }
 
-    /**
-     * Checks if the subscriber feature is currently available or not. Due to concurrent operations
-     * such as Station, SoftAP, Wi-Fi Aware, Wi-Fi Direct ..etc. the subscriber functionality
-     * may not be available.
-     *
-     * @return true if subscriber feature is available, otherwise false.
-     */
-    @RequiresPermission(MANAGE_WIFI_NETWORK_SELECTION)
-    public boolean isSubscriberAvailable() {
-        if (!Environment.isSdkAtLeastB()) {
-            throw new UnsupportedOperationException();
-        }
-        try {
-            return mService.isSubscriberAvailable();
-        } catch (RemoteException e) {
-            throw e.rethrowFromSystemServer();
-        }
-    }
-
-
-    /**
-     * Checks if the publisher feature is currently available or not. Due to concurrent
-     * operations such as Station, SoftAP, Wi-Fi Aware, Wi-Fi Direct ..etc.  the publisher
-     * functionality may not be available.
-     *
-     * @return true if publisher feature is available, otherwise false.
-     */
-    @RequiresPermission(MANAGE_WIFI_NETWORK_SELECTION)
-    public boolean isPublisherAvailable() {
-        if (!Environment.isSdkAtLeastB()) {
-            throw new UnsupportedOperationException();
-        }
-        try {
-            return mService.isPublisherAvailable();
-        } catch (RemoteException e) {
-            throw e.rethrowFromSystemServer();
-        }
-    }
-
-    private static class AvailabilityCallbackProxy extends IAvailabilityCallback.Stub {
-        private final Executor mExecutor;
-        private final AvailabilityCallback mAvailabilityCallback;
-
-        private AvailabilityCallbackProxy(Executor executor,
-                AvailabilityCallback availabilityCallback) {
-            mExecutor = executor;
-            mAvailabilityCallback = availabilityCallback;
-        }
-
-        @Override
-        public void onSubscriberAvailable() {
-            Log.d(TAG, "onSubscriberAvailable");
-            Binder.clearCallingIdentity();
-            mExecutor.execute(mAvailabilityCallback::onSubscriberAvailable);
-        }
-
-        @Override
-        public void onPublisherAvailable() {
-            Log.d(TAG, "onPublisherAvailable");
-            Binder.clearCallingIdentity();
-            mExecutor.execute(mAvailabilityCallback::onPublisherAvailable);
-        }
-    }
-
-    /**
-     * Interface for indicating publisher or subscriber availability.
-     */
-    public interface AvailabilityCallback {
-        /**
-         * Callback to notify subscriber functionality is available.
-         */
-        default void onSubscriberAvailable() {
-        }
-
-        /**
-         * Callback to notify publisher functionality is available.
-         */
-        default void onPublisherAvailable() {
-        }
-    }
-
-    /**
-     * Register for publisher or subscriber availability. Concurrent operations such as Station,
-     * SoftAP, Wi-Fi Aware, Wi-Fi Direct ..etc. impact the current availability of publisher or
-     * subscriber functionality.
-     *
-     * @param executor The Executor on whose thread to execute the callbacks of the {@code
-     *                 callback} object
-     * @param callback Callback for USD roles availability
-     * @throws NullPointerException if executor or callback is null
-     */
-    @RequiresPermission(MANAGE_WIFI_NETWORK_SELECTION)
-    public void registerAvailabilityCallback(@NonNull @CallbackExecutor Executor executor,
-            @NonNull AvailabilityCallback callback) {
-        Objects.requireNonNull(executor, "executor must not be null");
-        Objects.requireNonNull(callback, "callback must not be null");
-        if (!Environment.isSdkAtLeastB()) {
-            throw new UnsupportedOperationException();
-        }
-        final int callbackHash = System.identityHashCode(callback);
-        synchronized (sAvailabilityCallbackMap) {
-            try {
-                IAvailabilityCallback.Stub availabilityCallbackProxy =
-                        new AvailabilityCallbackProxy(executor, callback);
-                sAvailabilityCallbackMap.put(callbackHash, availabilityCallbackProxy);
-                mService.registerAvailabilityCallback(availabilityCallbackProxy);
-            } catch (RemoteException e) {
-                sAvailabilityCallbackMap.remove(callbackHash);
-                throw e.rethrowFromSystemServer();
-            }
-        }
-    }
-
-    /**
-     * Unregister the callback previously registered with
-     * {@link #registerAvailabilityCallback(Executor, AvailabilityCallback)}.
-     *
-     * @param callback a registered callback
-     * @throws NullPointerException if callback is null
-     */
-    @RequiresPermission(MANAGE_WIFI_NETWORK_SELECTION)
-    public void unregisterAvailabilityCallback(@NonNull AvailabilityCallback callback) {
-        Objects.requireNonNull(callback, "callback must not be null");
-        if (!Environment.isSdkAtLeastB()) {
-            throw new UnsupportedOperationException();
-        }
-        final int callbackHash = System.identityHashCode(callback);
-        synchronized (sAvailabilityCallbackMap) {
-            try {
-                if (!sAvailabilityCallbackMap.contains(callbackHash)) {
-                    Log.w(TAG, "Unknown callback");
-                    return;
-                }
-                mService.unregisterAvailabilityCallback(sAvailabilityCallbackMap.get(callbackHash));
-            } catch (RemoteException e) {
-                throw e.rethrowFromSystemServer();
-            } finally {
-                sAvailabilityCallbackMap.remove(callbackHash);
-            }
-        }
-    }
-
     /**
      * Gets the characteristics of USD: a set of parameters which specify limitations on
      * configurations, e.g. maximum service name length.
@@ -466,4 +325,134 @@ public class UsdManager {
             throw e.rethrowFromSystemServer();
         }
     }
+
+    /**
+     * Register for subscriber availability. Concurrent operations such as Station, SoftAP, Wi-Fi
+     * Aware, Wi-Fi Direct ..etc. impact the current availability of subscriber functionality.
+     * Current availability status will be returned immediately after registering.
+     *
+     * @param executor The executor on which callback will be invoked.
+     * @param callback An asynchronous callback that will return {@code Boolean} indicating
+     *                 whether subscriber is available or not. {@code true} if subscriber is
+     *                 available, otherwise unavailable.
+     */
+    @RequiresPermission(MANAGE_WIFI_NETWORK_SELECTION)
+    public void registerSubscriberStatusListener(@NonNull Executor executor,
+            @NonNull Consumer<Boolean> callback) {
+        Objects.requireNonNull(executor, "executor must not be null");
+        Objects.requireNonNull(callback, "callback must not be null");
+        if (!Environment.isSdkAtLeastB()) {
+            throw new UnsupportedOperationException();
+        }
+        final int callbackHash = System.identityHashCode(callback);
+        synchronized (sSubscriberAvailabilityListenerMap) {
+            try {
+                IBooleanListener listener = new IBooleanListener.Stub() {
+                    @Override
+                    public void onResult(boolean value) throws RemoteException {
+                        Binder.clearCallingIdentity();
+                        executor.execute(() -> callback.accept(value));
+                    }
+                };
+                sSubscriberAvailabilityListenerMap.put(callbackHash, listener);
+                mService.registerSubscriberStatusListener(listener);
+            } catch (RemoteException e) {
+                sSubscriberAvailabilityListenerMap.remove(callbackHash);
+                throw e.rethrowFromSystemServer();
+            }
+        }
+    }
+
+    /**
+     * Unregister the callback previously registered for subscriber availability.
+     *
+     * @param callback A registered callback.
+     */
+    @RequiresPermission(MANAGE_WIFI_NETWORK_SELECTION)
+    public void unregisterSubscriberStatusListener(@NonNull Consumer<Boolean> callback) {
+        Objects.requireNonNull(callback, "callback must not be null");
+        if (!Environment.isSdkAtLeastB()) {
+            throw new UnsupportedOperationException();
+        }
+        final int callbackHash = System.identityHashCode(callback);
+        synchronized (sSubscriberAvailabilityListenerMap) {
+            if (!sSubscriberAvailabilityListenerMap.contains(callbackHash)) {
+                Log.w(TAG, "Unknown callback");
+                return;
+            }
+            try {
+                mService.unregisterSubscriberStatusListener(
+                        sSubscriberAvailabilityListenerMap.get(callbackHash));
+            } catch (RemoteException e) {
+                throw e.rethrowFromSystemServer();
+            } finally {
+                sSubscriberAvailabilityListenerMap.remove(callbackHash);
+            }
+        }
+    }
+
+    /**
+     * Register for publisher availability. Concurrent operations such as Station, SoftAP, Wi-Fi
+     * Aware, Wi-Fi Direct ..etc. impact the current availability of publisher functionality.
+     * Current availability status will be returned immediately after registering.
+     *
+     * @param executor The executor on which callback will be invoked.
+     * @param callback An asynchronous callback that will return {@code Boolean} indicating
+     *                 whether publisher is available or not. {@code true} if publisher is
+     *                 available, otherwise unavailable.
+     */
+    @RequiresPermission(MANAGE_WIFI_NETWORK_SELECTION)
+    public void registerPublisherStatusListener(@NonNull Executor executor,
+            @NonNull Consumer<Boolean> callback) {
+        Objects.requireNonNull(executor, "executor must not be null");
+        Objects.requireNonNull(callback, "callback must not be null");
+        if (!Environment.isSdkAtLeastB()) {
+            throw new UnsupportedOperationException();
+        }
+        final int callbackHash = System.identityHashCode(callback);
+        synchronized (sPublisherAvailabilityListenerMap) {
+            try {
+                IBooleanListener listener = new IBooleanListener.Stub() {
+                    @Override
+                    public void onResult(boolean value) throws RemoteException {
+                        Binder.clearCallingIdentity();
+                        executor.execute(() -> callback.accept(value));
+                    }
+                };
+                sPublisherAvailabilityListenerMap.put(callbackHash, listener);
+                mService.registerPublisherStatusListener(listener);
+            } catch (RemoteException e) {
+                sPublisherAvailabilityListenerMap.remove(callbackHash);
+                throw e.rethrowFromSystemServer();
+            }
+        }
+    }
+
+    /**
+     * Unregister the callback previously registered for publisher availability.
+     *
+     * @param callback A registered callback.
+     */
+    @RequiresPermission(MANAGE_WIFI_NETWORK_SELECTION)
+    public void unregisterPublisherStatusListener(@NonNull Consumer<Boolean> callback) {
+        Objects.requireNonNull(callback, "callback must not be null");
+        if (!Environment.isSdkAtLeastB()) {
+            throw new UnsupportedOperationException();
+        }
+        final int callbackHash = System.identityHashCode(callback);
+        synchronized (sPublisherAvailabilityListenerMap) {
+            if (!sPublisherAvailabilityListenerMap.contains(callbackHash)) {
+                Log.w(TAG, "Unknown callback");
+                return;
+            }
+            try {
+                mService.unregisterPublisherStatusListener(
+                        sPublisherAvailabilityListenerMap.get(callbackHash));
+            } catch (RemoteException e) {
+                throw e.rethrowFromSystemServer();
+            } finally {
+                sPublisherAvailabilityListenerMap.remove(callbackHash);
+            }
+        }
+    }
 }
diff --git a/framework/java/android/net/wifi/util/Environment.java b/framework/java/android/net/wifi/util/Environment.java
index f98265845a..a20b24744d 100644
--- a/framework/java/android/net/wifi/util/Environment.java
+++ b/framework/java/android/net/wifi/util/Environment.java
@@ -45,6 +45,12 @@ public class Environment {
     private static final String WIFI_APEX_PATH =
             new File("/apex", WIFI_APEX_NAME).getAbsolutePath();
 
+    /**
+     * Path to the mainline supplicant binary.
+     */
+    private static final String MAINLINE_SUPPLICANT_BINARY_PATH =
+            WIFI_APEX_PATH + "/bin/wpa_supplicant_mainline";
+
     /**
      * Wifi shared folder.
      */
@@ -68,6 +74,13 @@ public class Environment {
         return appInfo.sourceDir.startsWith(WIFI_APEX_PATH);
     }
 
+    /**
+     * Returns true if the mainline supplicant binary is in the Wifi Apex.
+     */
+    public static boolean isMainlineSupplicantBinaryInWifiApex() {
+        return new File(MAINLINE_SUPPLICANT_BINARY_PATH).isFile();
+    }
+
     /**
      * Return whether the VNDK version of the vendor partition is newer than the given API level.
      * If the property is set to non-integer value, this means the vendor partition is using
diff --git a/framework/java/android/net/wifi/util/ScanResultUtil.java b/framework/java/android/net/wifi/util/ScanResultUtil.java
index ca8d62b3d3..5ee576ce1a 100644
--- a/framework/java/android/net/wifi/util/ScanResultUtil.java
+++ b/framework/java/android/net/wifi/util/ScanResultUtil.java
@@ -26,6 +26,8 @@ import android.net.wifi.SecurityParams;
 import android.net.wifi.WifiConfiguration;
 import android.util.Log;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.VisibleForTesting;
 
 import java.io.PrintWriter;
@@ -314,6 +316,7 @@ public class ScanResultUtil {
     /**
      * Creates a network configuration object using the provided |scanResult|.
      */
+    @Keep
     public static @Nullable WifiConfiguration createNetworkFromScanResult(
             @NonNull ScanResult scanResult) {
         WifiConfiguration config = new WifiConfiguration();
diff --git a/framework/java/android/net/wifi/util/WifiResourceCache.java b/framework/java/android/net/wifi/util/WifiResourceCache.java
index 1d987d3fb4..88d57f040e 100644
--- a/framework/java/android/net/wifi/util/WifiResourceCache.java
+++ b/framework/java/android/net/wifi/util/WifiResourceCache.java
@@ -67,11 +67,13 @@ public class WifiResourceCache {
             String resourceName = mContext.getResources().getResourceEntryName(resourceId);
             if (mResourceNameMap.containsKey(resourceName)) {
                 int tempId = mResourceNameMap.get(resourceName);
-                boolean value = mBooleanResourceMap.get(tempId);
-                mBooleanResourceMap.put(resourceId, value);
-                mBooleanResourceMap.remove(tempId);
-                mResourceNameMap.put(resourceName, resourceId);
-                return value;
+                if (mBooleanResourceMap.containsKey(tempId)) {
+                    boolean value = mBooleanResourceMap.get(tempId);
+                    mBooleanResourceMap.put(resourceId, value);
+                    mBooleanResourceMap.remove(tempId);
+                    mResourceNameMap.put(resourceName, resourceId);
+                    return value;
+                }
             }
             mResourceNameMap.put(resourceName, resourceId);
             return mBooleanResourceMap.computeIfAbsent(resourceId,
@@ -91,11 +93,13 @@ public class WifiResourceCache {
             String resourceName = mContext.getResources().getResourceEntryName(resourceId);
             if (mResourceNameMap.containsKey(resourceName)) {
                 int tempId = mResourceNameMap.get(resourceName);
-                int value = mIntegerResourceMap.get(tempId);
-                mIntegerResourceMap.put(resourceId, value);
-                mIntegerResourceMap.remove(tempId);
-                mResourceNameMap.put(resourceName, resourceId);
-                return value;
+                if (mIntegerResourceMap.containsKey(tempId)) {
+                    int value = mIntegerResourceMap.get(tempId);
+                    mIntegerResourceMap.put(resourceId, value);
+                    mIntegerResourceMap.remove(tempId);
+                    mResourceNameMap.put(resourceName, resourceId);
+                    return value;
+                }
             }
             mResourceNameMap.put(resourceName, resourceId);
             return mIntegerResourceMap.computeIfAbsent(resourceId,
@@ -115,11 +119,13 @@ public class WifiResourceCache {
             String resourceName = mContext.getResources().getResourceEntryName(resourceId);
             if (mResourceNameMap.containsKey(resourceName)) {
                 int tempId = mResourceNameMap.get(resourceName);
-                String value = mStringResourceMap.get(tempId);
-                mStringResourceMap.put(resourceId, value);
-                mStringResourceMap.remove(tempId);
-                mResourceNameMap.put(resourceName, resourceId);
-                return value;
+                if (mStringResourceMap.containsKey(tempId)) {
+                    String value = mStringResourceMap.get(tempId);
+                    mStringResourceMap.put(resourceId, value);
+                    mStringResourceMap.remove(tempId);
+                    mResourceNameMap.put(resourceName, resourceId);
+                    return value;
+                }
             }
             mResourceNameMap.put(resourceName, resourceId);
             return mStringResourceMap.computeIfAbsent(resourceId,
@@ -139,11 +145,13 @@ public class WifiResourceCache {
             String resourceName = mContext.getResources().getResourceEntryName(resourceId);
             if (mResourceNameMap.containsKey(resourceName)) {
                 int tempId = mResourceNameMap.get(resourceName);
-                String[] value = mStringArrayResourceMap.get(tempId);
-                mStringArrayResourceMap.put(resourceId, value);
-                mStringArrayResourceMap.remove(tempId);
-                mResourceNameMap.put(resourceName, resourceId);
-                return value;
+                if (mStringArrayResourceMap.containsKey(tempId)) {
+                    String[] value = mStringArrayResourceMap.get(tempId);
+                    mStringArrayResourceMap.put(resourceId, value);
+                    mStringArrayResourceMap.remove(tempId);
+                    mResourceNameMap.put(resourceName, resourceId);
+                    return value;
+                }
             }
             mResourceNameMap.put(resourceName, resourceId);
             return mStringArrayResourceMap.computeIfAbsent(resourceId,
@@ -163,11 +171,13 @@ public class WifiResourceCache {
             String resourceName = mContext.getResources().getResourceEntryName(resourceId);
             if (mResourceNameMap.containsKey(resourceName)) {
                 int tempId = mResourceNameMap.get(resourceName);
-                int[] value = mIntArrayResourceMap.get(tempId);
-                mIntArrayResourceMap.put(resourceId, value);
-                mIntArrayResourceMap.remove(tempId);
-                mResourceNameMap.put(resourceName, resourceId);
-                return value;
+                if (mIntArrayResourceMap.containsKey(tempId)) {
+                    int[] value = mIntArrayResourceMap.get(tempId);
+                    mIntArrayResourceMap.put(resourceId, value);
+                    mIntArrayResourceMap.remove(tempId);
+                    mResourceNameMap.put(resourceName, resourceId);
+                    return value;
+                }
             }
             mResourceNameMap.put(resourceName, resourceId);
             return mIntArrayResourceMap.computeIfAbsent(resourceId,
@@ -319,4 +329,12 @@ public class WifiResourceCache {
             mResourceNameMap.clear();
         }
     }
+
+    /**
+     * Handle the locale change to apply the translation
+     */
+    public void handleLocaleChange() {
+        mStringResourceMap.clear();
+        mStringArrayResourceMap.clear();
+    }
 }
diff --git a/framework/tests/Android.bp b/framework/tests/Android.bp
index 825fdabf2c..0959110209 100644
--- a/framework/tests/Android.bp
+++ b/framework/tests/Android.bp
@@ -42,6 +42,7 @@ android_test {
         "frameworks-base-testutils",
         "guava",
         "wifi-modules-utils",
+        "mockito-target-extended-minus-junit4",
         "net-tests-utils",
         "net-utils-framework-common",
         "truth",
@@ -54,7 +55,6 @@ android_test {
     ],
 
     // These are required for mockito static/final mocking
-    // mockito-target-extended-minus-junit4 is already included in frameworks-base-testutils
     jni_libs: [
         "libdexmakerjvmtiagent",
         "libstaticjvmtiagent",
diff --git a/framework/tests/src/android/net/wifi/ScanResultTest.java b/framework/tests/src/android/net/wifi/ScanResultTest.java
index 32265c3279..c18a66b096 100644
--- a/framework/tests/src/android/net/wifi/ScanResultTest.java
+++ b/framework/tests/src/android/net/wifi/ScanResultTest.java
@@ -435,4 +435,18 @@ public class ScanResultTest {
         assertEquals(WifiScanner.WIFI_BAND_5_GHZ, ScanResult.getBandFromOpClass(120, 149));
         assertEquals(WifiScanner.WIFI_BAND_6_GHZ, ScanResult.getBandFromOpClass(131, 32));
     }
+
+    /**
+     * Test IEEE 802.11az NTB Secure Ranging Parameters.
+     */
+    @Test
+    public void testIeee80211azNtbSecureRangingParameters() {
+        ScanResult scanResult = new ScanResult();
+        scanResult.setFlag(ScanResult.FLAG_80211az_NTB_RESPONDER
+                | ScanResult.FLAG_SECURE_HE_LTF_SUPPORTED
+                | ScanResult.FLAG_RANGING_FRAME_PROTECTION_REQUIRED);
+        assertTrue(scanResult.is80211azNtbResponder());
+        assertTrue(scanResult.isRangingFrameProtectionRequired());
+        assertTrue(scanResult.isSecureHeLtfSupported());
+    }
 }
diff --git a/framework/tests/src/android/net/wifi/SoftApConfigurationTest.java b/framework/tests/src/android/net/wifi/SoftApConfigurationTest.java
index 7e4f5ea310..9938a6a990 100644
--- a/framework/tests/src/android/net/wifi/SoftApConfigurationTest.java
+++ b/framework/tests/src/android/net/wifi/SoftApConfigurationTest.java
@@ -962,4 +962,21 @@ public class SoftApConfigurationTest {
         OuiKeyedData unparceledOuiKeyedData = unparceled.getVendorData().get(0);
         assertEquals(bundle.getInt(fieldKey), unparceledOuiKeyedData.getData().getInt(fieldKey));
     }
+
+    @Test
+    public void testForce11BeToFalseWhen11AxIsFalse() {
+        assumeTrue(SdkLevel.isAtLeastB());
+        // Only 11be is false, it should be ok.
+        SoftApConfiguration config = new SoftApConfiguration.Builder()
+                .setIeee80211axEnabled(true)
+                .setIeee80211beEnabled(false).build();
+        assertTrue(config.isIeee80211axEnabled());
+        assertFalse(config.isIeee80211beEnabled());
+        // Only 11ax is false, 11be should force to false too.
+        config = new SoftApConfiguration.Builder()
+                .setIeee80211axEnabled(false)
+                .setIeee80211beEnabled(true).build();
+        assertFalse(config.isIeee80211axEnabled());
+        assertFalse(config.isIeee80211beEnabled());
+    }
 }
diff --git a/framework/tests/src/android/net/wifi/WifiManagerTest.java b/framework/tests/src/android/net/wifi/WifiManagerTest.java
index a029be2267..497bc3dc33 100644
--- a/framework/tests/src/android/net/wifi/WifiManagerTest.java
+++ b/framework/tests/src/android/net/wifi/WifiManagerTest.java
@@ -88,7 +88,6 @@ import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 import android.annotation.NonNull;
@@ -316,7 +315,8 @@ public class WifiManagerTest {
         mApplicationInfo.targetSdkVersion = Build.VERSION_CODES.Q;
         when(mContext.getApplicationInfo()).thenReturn(mApplicationInfo);
         when(mContext.getOpPackageName()).thenReturn(TEST_PACKAGE_NAME);
-        mWifiManager = new WifiManager(mContext, mWifiService, mLooper.getLooper());
+        when(mContext.getMainLooper()).thenReturn(mLooper.getLooper());
+        mWifiManager = new WifiManager(mContext, mWifiService);
         verify(mWifiService).getVerboseLoggingLevel();
         mWifiNetworkSuggestion = new WifiNetworkSuggestion();
         mScanResultsCallback = new ScanResultsCallback() {
@@ -2055,7 +2055,7 @@ public class WifiManagerTest {
     @Test
     public void testUnregisterWifiServiceImplNotCalledWithoutRegisteredObserver() throws Exception {
         mWifiManager.unregisterLocalOnlyHotspotObserver();
-        verifyZeroInteractions(mWifiService);
+        verifyNoMoreInteractions(mWifiService);
     }
 
     /**
diff --git a/framework/tests/src/android/net/wifi/WifiNetworkAgentSpecifierTest.java b/framework/tests/src/android/net/wifi/WifiNetworkAgentSpecifierTest.java
index bc22b808c5..a6718c1f11 100644
--- a/framework/tests/src/android/net/wifi/WifiNetworkAgentSpecifierTest.java
+++ b/framework/tests/src/android/net/wifi/WifiNetworkAgentSpecifierTest.java
@@ -195,7 +195,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_5_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
 
         assertTrue(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertTrue(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
@@ -224,7 +224,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_5_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
 
         assertTrue(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertTrue(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
@@ -253,7 +253,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_5_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
 
         assertTrue(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertTrue(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
@@ -285,7 +285,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_24_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
 
         assertFalse(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertFalse(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
@@ -316,7 +316,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_5_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
         assertTrue(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertTrue(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
 
@@ -325,7 +325,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_24_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
         assertFalse(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertFalse(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
 
@@ -334,7 +334,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.UNSPECIFIED,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
         assertTrue(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertTrue(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
     }
@@ -373,17 +373,17 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_5_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
         WifiNetworkSpecifier wifi5GLowNetworkSpecifier = new WifiNetworkSpecifier(
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_5_GHZ_LOW,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
         WifiNetworkSpecifier wifi5GHighNetworkSpecifier = new WifiNetworkSpecifier(
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_5_GHZ_HIGH,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
 
         // mBand = WIFI_BAND_5_GHZ_LOW
         // Same band matches.
@@ -435,7 +435,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_5_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
         assertFalse(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertFalse(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
 
@@ -454,7 +454,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_24_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
         assertFalse(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertFalse(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
 
@@ -464,7 +464,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.UNSPECIFIED,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
         assertFalse(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertFalse(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
     }
@@ -496,7 +496,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_5_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
 
         assertFalse(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertFalse(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
@@ -529,7 +529,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.WIFI_BAND_24_GHZ,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
 
         assertFalse(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertFalse(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
@@ -557,7 +557,7 @@ public class WifiNetworkAgentSpecifierTest {
                 ssidPattern,
                 bssidPattern,
                 ScanResult.UNSPECIFIED,
-                wificonfigurationNetworkSpecifier, new int[0]);
+                wificonfigurationNetworkSpecifier, new int[0], false);
 
         assertFalse(wifiNetworkSpecifier.canBeSatisfiedBy(wifiNetworkAgentSpecifier));
         assertFalse(wifiNetworkAgentSpecifier.canBeSatisfiedBy(wifiNetworkSpecifier));
diff --git a/framework/tests/src/android/net/wifi/WifiNetworkSpecifierTest.java b/framework/tests/src/android/net/wifi/WifiNetworkSpecifierTest.java
index 12dfd6e9a5..cc6d008cb2 100644
--- a/framework/tests/src/android/net/wifi/WifiNetworkSpecifierTest.java
+++ b/framework/tests/src/android/net/wifi/WifiNetworkSpecifierTest.java
@@ -657,7 +657,7 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         WIFI_BAND_5_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         Parcel parcelW = Parcel.obtain();
         specifier.writeToParcel(parcelW, 0);
@@ -689,7 +689,7 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         ScanResult.UNSPECIFIED,  /* band */
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         assertFalse(specifier.canBeSatisfiedBy(null));
         assertFalse(specifier.canBeSatisfiedBy(new MatchAllNetworkSpecifier()));
@@ -712,14 +712,14 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         WIFI_BAND_5_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         WifiNetworkSpecifier specifier2 =
                 new WifiNetworkSpecifier(new PatternMatcher(TEST_SSID, PATTERN_LITERAL),
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         WIFI_BAND_5_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         assertTrue(specifier2.canBeSatisfiedBy(specifier1));
     }
@@ -741,7 +741,7 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         ScanResult.WIFI_BAND_24_GHZ,
-                        wifiConfiguration1, new int[0]);
+                        wifiConfiguration1, new int[0], false);
 
         WifiConfiguration wifiConfiguration2 = new WifiConfiguration();
         wifiConfiguration2.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
@@ -750,7 +750,7 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         ScanResult.WIFI_BAND_24_GHZ,
-                        wifiConfiguration2, new int[0]);
+                        wifiConfiguration2, new int[0], false);
 
         assertFalse(specifier2.canBeSatisfiedBy(specifier1));
     }
@@ -772,14 +772,14 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         WIFI_BAND_5_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         WifiNetworkSpecifier specifier2 =
                 new WifiNetworkSpecifier(new PatternMatcher(TEST_SSID, PATTERN_LITERAL),
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         WIFI_BAND_5_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         assertFalse(specifier2.canBeSatisfiedBy(specifier1));
     }
@@ -801,14 +801,14 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         ScanResult.WIFI_BAND_24_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         WifiNetworkSpecifier specifier2 =
                 new WifiNetworkSpecifier(new PatternMatcher(TEST_SSID, PATTERN_LITERAL),
                         Pair.create(WifiManager.ALL_ZEROS_MAC_ADDRESS,
                                 WifiManager.ALL_ZEROS_MAC_ADDRESS),
                         ScanResult.WIFI_BAND_24_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         assertFalse(specifier2.canBeSatisfiedBy(specifier1));
     }
@@ -827,14 +827,14 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         ScanResult.WIFI_BAND_24_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         WifiNetworkSpecifier specifier2 =
                 new WifiNetworkSpecifier(new PatternMatcher(TEST_SSID, PATTERN_LITERAL),
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         ScanResult.WIFI_BAND_24_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         // Same band matches.
         assertTrue(specifier2.canBeSatisfiedBy(specifier1));
@@ -845,7 +845,7 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(WifiManager.ALL_ZEROS_MAC_ADDRESS,
                                 WifiManager.ALL_ZEROS_MAC_ADDRESS),
                         WIFI_BAND_5_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         // Different band does not match.
         assertFalse(specifier2.canBeSatisfiedBy(specifier1));
@@ -856,7 +856,7 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(WifiManager.ALL_ZEROS_MAC_ADDRESS,
                                 WifiManager.ALL_ZEROS_MAC_ADDRESS),
                         ScanResult.UNSPECIFIED,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         // An UNSPECIFIED band does not match a specified band, because a WifiNetworkSpecifier
         // satisfies another only if they are equal.
@@ -878,7 +878,7 @@ public class WifiNetworkSpecifierTest {
                         Pair.create(MacAddress.fromString(TEST_BSSID_OUI_BASE_ADDRESS),
                                 MacAddress.fromString(TEST_BSSID_OUI_MASK)),
                         WIFI_BAND_5_GHZ,
-                        wifiConfiguration, new int[0]);
+                        wifiConfiguration, new int[0], false);
 
         final NetworkSpecifier redacted = specifier.redact();
         if (SdkLevel.isAtLeastS()) {
@@ -902,4 +902,14 @@ public class WifiNetworkSpecifierTest {
         builder.setBand(WIFI_BAND_5_GHZ);
         assertThrows(IllegalStateException.class, builder::build);
     }
+
+    @Test
+    public void testSetPreferSecondarySta() {
+        WifiNetworkSpecifier.Builder builder = new WifiNetworkSpecifier.Builder()
+                .setSsidPattern(new PatternMatcher(TEST_SSID, PATTERN_PREFIX));
+        // By default this should be false
+        assertEquals(false, builder.build().isPreferSecondarySta());
+        // It should be true if set to true
+        assertEquals(true, builder.setPreferSecondarySta(true).build().isPreferSecondarySta());
+    }
 }
diff --git a/framework/tests/src/android/net/wifi/WifiScannerTest.java b/framework/tests/src/android/net/wifi/WifiScannerTest.java
index 25a0cb6df3..237dc5dbf8 100644
--- a/framework/tests/src/android/net/wifi/WifiScannerTest.java
+++ b/framework/tests/src/android/net/wifi/WifiScannerTest.java
@@ -105,7 +105,7 @@ public class WifiScannerTest {
         MockitoAnnotations.initMocks(this);
         mLooper = new TestLooper();
         mHandler = spy(new Handler(mLooper.getLooper()));
-        mWifiScanner = new WifiScanner(mContext, mService, mLooper.getLooper());
+        mWifiScanner = new WifiScanner(mContext, mService);
         mLooper.dispatchAll();
         when(mParcelableScanData.getResults()).thenReturn(mScanData);
         when(mContext.getOpPackageName()).thenReturn(TEST_PACKAGE_NAME);
@@ -597,12 +597,12 @@ public class WifiScannerTest {
     @Test
     public void testWifiScannerConcurrentServiceStart() {
         WifiScanner wifiScanner = new WifiScanner(
-                mContext, mService, WifiFrameworkInitializer.getInstanceLooper());
+                mContext, mService);
 
         Thread thread1 = new Thread(() -> {
             try {
                 WifiScanner wifiScanner1 = new WifiScanner(
-                        mContext, mService, WifiFrameworkInitializer.getInstanceLooper());
+                        mContext, mService);
             }  catch (NullPointerException e) {
                 fail("WifiScanner can't be initialized! " + e);
             }
diff --git a/framework/tests/src/android/net/wifi/aware/WifiAwareManagerTest.java b/framework/tests/src/android/net/wifi/aware/WifiAwareManagerTest.java
index e24fa354ad..3c891ff949 100644
--- a/framework/tests/src/android/net/wifi/aware/WifiAwareManagerTest.java
+++ b/framework/tests/src/android/net/wifi/aware/WifiAwareManagerTest.java
@@ -120,6 +120,8 @@ public class WifiAwareManagerTest {
     private static final String PASSPHRASE_TOO_SHORT = "012";
     private static final String PASSPHRASE_TOO_LONG =
             "0123456789012345678901234567890123456789012345678901234567890123456789";
+    @Mock
+    private Characteristics mCharacteristics;
 
     @Before
     public void setUp() throws Exception {
@@ -134,6 +136,14 @@ public class WifiAwareManagerTest {
         mDut = new WifiAwareManager(mockContext, mockAwareService);
         mMockLooper = new TestLooper();
         mMockLooperHandler = new Handler(mMockLooper.getLooper());
+        // Set default values for mock object
+        when(mCharacteristics.getMaxServiceNameLength()).thenReturn(255);
+        when(mCharacteristics.getMaxServiceSpecificInfoLength()).thenReturn(255);
+        when(mCharacteristics.getMaxMatchFilterLength()).thenReturn(255);
+        when(mCharacteristics.isInstantCommunicationModeSupported()).thenReturn(true);
+        when(mCharacteristics.isSuspensionSupported()).thenReturn(true);
+        when(mCharacteristics.isAwarePairingSupported()).thenReturn(true);
+        when(mCharacteristics.isPeriodicRangingSupported()).thenReturn(true);
     }
 
     /*
@@ -1982,4 +1992,18 @@ public class WifiAwareManagerTest {
         captor.getValue().onResult(true);
         verify(resultsCallback).accept(true);
     }
+
+    /**
+     * Verify that SubscribeConfig.assertValid() does not throw an exception when min distance is
+     * greater than max distance
+     */
+    @Test
+    public void testSubscribeConfigAssertValidMinDistanceGreaterThanMaxDistance() {
+        SubscribeConfig config = new SubscribeConfig.Builder()
+                .setServiceName("TestService")
+                .setMinDistanceMm(1000)
+                .setMaxDistanceMm(100)
+                .build();
+        config.assertValid(mCharacteristics, true);
+    }
 }
diff --git a/framework/tests/src/android/net/wifi/p2p/WifiP2pConfigTest.java b/framework/tests/src/android/net/wifi/p2p/WifiP2pConfigTest.java
index b11daabac5..afdcd66142 100644
--- a/framework/tests/src/android/net/wifi/p2p/WifiP2pConfigTest.java
+++ b/framework/tests/src/android/net/wifi/p2p/WifiP2pConfigTest.java
@@ -461,6 +461,8 @@ public class WifiP2pConfigTest {
                 c.getPairingBootstrappingConfig();
         assertNotNull(pairingBootstrappingConfig);
         assertEquals(expectedPairingBootstrappingConfig, pairingBootstrappingConfig);
+        assertEquals(c.getGroupClientIpProvisioningMode(),
+                GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL);
     }
 
     /**
@@ -477,12 +479,12 @@ public class WifiP2pConfigTest {
                 .setDeviceAddress(MacAddress.fromString(DEVICE_ADDRESS))
                 .setPairingBootstrappingConfig(expectedPairingBootstrappingConfig)
                 .setGroupOperatingFrequency(2437)
-                .setAuthorizeConnectionFromPeer(true)
+                .setAuthorizeConnectionFromPeerEnabled(true)
                 .build();
         WifiP2pPairingBootstrappingConfig pairingBootstrappingConfig =
                 c.getPairingBootstrappingConfig();
         assertNotNull(pairingBootstrappingConfig);
         assertEquals(expectedPairingBootstrappingConfig, pairingBootstrappingConfig);
-        assertTrue(c.isAuthorizeConnectionFromPeer());
+        assertTrue(c.isAuthorizeConnectionFromPeerEnabled());
     }
 }
diff --git a/framework/tests/src/android/net/wifi/p2p/WifiP2pProvDiscEventTest.java b/framework/tests/src/android/net/wifi/p2p/WifiP2pProvDiscEventTest.java
index e3b10a7a52..6a1705fb44 100644
--- a/framework/tests/src/android/net/wifi/p2p/WifiP2pProvDiscEventTest.java
+++ b/framework/tests/src/android/net/wifi/p2p/WifiP2pProvDiscEventTest.java
@@ -43,7 +43,7 @@ public class WifiP2pProvDiscEventTest {
     public void testPbcReqEvent() throws Exception {
         WifiP2pProvDiscEvent event =
                 new WifiP2pProvDiscEvent(EVENT_PBC_REQ_STRING + " " + DEVICE_ADDRESS);
-        assertEquals(WifiP2pProvDiscEvent.PBC_REQ, event.event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_PBC_REQ, event.event);
         assertEquals(DEVICE_ADDRESS, event.device.deviceAddress);
     }
 
@@ -55,7 +55,7 @@ public class WifiP2pProvDiscEventTest {
     public void testPbcRespEvent() throws Exception {
         WifiP2pProvDiscEvent event =
                 new WifiP2pProvDiscEvent(EVENT_PBC_RSP_STRING + " " + DEVICE_ADDRESS);
-        assertEquals(WifiP2pProvDiscEvent.PBC_RSP, event.event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_PBC_RSP, event.event);
         assertEquals(DEVICE_ADDRESS, event.device.deviceAddress);
     }
 
@@ -66,7 +66,7 @@ public class WifiP2pProvDiscEventTest {
     public void testEnterPinEvent() throws Exception {
         WifiP2pProvDiscEvent event =
                 new WifiP2pProvDiscEvent(EVENT_ENTER_PIN_STRING + " " + DEVICE_ADDRESS);
-        assertEquals(WifiP2pProvDiscEvent.ENTER_PIN, event.event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_ENTER_PIN, event.event);
         assertEquals(DEVICE_ADDRESS, event.device.deviceAddress);
     }
 
@@ -78,9 +78,9 @@ public class WifiP2pProvDiscEventTest {
         WifiP2pProvDiscEvent event =
                 new WifiP2pProvDiscEvent(
                         EVENT_SHOW_PIN_STRING + " " + DEVICE_ADDRESS + " " + TEST_PIN);
-        assertEquals(WifiP2pProvDiscEvent.SHOW_PIN, event.event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_SHOW_PIN, event.event);
         assertEquals(DEVICE_ADDRESS, event.device.deviceAddress);
-        assertEquals(TEST_PIN, event.pin);
+        assertEquals(TEST_PIN, event.wpsPin);
     }
 
     /**
diff --git a/framework/tests/src/android/net/wifi/rtt/PasnConfigTest.java b/framework/tests/src/android/net/wifi/rtt/PasnConfigTest.java
new file mode 100644
index 0000000000..d6a52be8c8
--- /dev/null
+++ b/framework/tests/src/android/net/wifi/rtt/PasnConfigTest.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.wifi.rtt;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import android.net.wifi.WifiSsid;
+import android.os.Parcel;
+
+import androidx.test.filters.SmallTest;
+
+import org.junit.Test;
+
+import java.util.Arrays;
+
+/**
+ * Tests PasnConfig class.
+ */
+@SmallTest
+public class PasnConfigTest {
+    private static final int TEST_AKM = PasnConfig.AKM_SAE;
+    private static final int TEST_CIPHER = PasnConfig.CIPHER_CCMP_128;
+    private static final String TEST_SSID = "\"Test_SSID\"";
+    private static final String TEST_PASSWORD = "password";
+    private static final String TEST_PASSWORD_MASKED = "*";
+    private static final byte[] TEST_COOKIE = new byte[]{1, 2, 3};
+
+    /**
+     * Verifies builder and getter methods work as expected.
+     */
+    @Test
+    public void testBuilderAndGetters() {
+        WifiSsid ssid = WifiSsid.fromString(TEST_SSID);
+        PasnConfig config = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setPassword(TEST_PASSWORD)
+                .setWifiSsid(ssid)
+                .setPasnComebackCookie(TEST_COOKIE)
+                .build();
+
+        assertEquals(TEST_AKM, config.getBaseAkms());
+        assertEquals(TEST_CIPHER, config.getCiphers());
+        assertEquals(TEST_PASSWORD, config.getPassword());
+        assertEquals(ssid, config.getWifiSsid());
+        assertArrayEquals(TEST_COOKIE, config.getPasnComebackCookie());
+    }
+
+    /**
+     * Verifies parceling round trip returns an identical object.
+     */
+    @Test
+    public void testParcelableRoundTrip() {
+        WifiSsid ssid = WifiSsid.fromString(TEST_SSID);
+        PasnConfig config = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setPassword(TEST_PASSWORD)
+                .setWifiSsid(ssid)
+                .setPasnComebackCookie(TEST_COOKIE)
+                .build();
+
+        Parcel parcel = Parcel.obtain();
+        config.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        PasnConfig fromParcel = PasnConfig.CREATOR.createFromParcel(parcel);
+        assertEquals(config, fromParcel);
+    }
+
+    /**
+     * Tests that null SSID and password result in unauthenticated PASN being used.
+     */
+    @Test
+    public void testNullSsidAndPassword() {
+        PasnConfig config = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER).build();
+        assertNull(config.getPassword());
+        assertNull(config.getWifiSsid());
+    }
+
+    /**
+     * Tests equality and non-equality of objects.
+     */
+    @Test
+    public void testEqualsAndHashCode() {
+        WifiSsid ssid1 = WifiSsid.fromString(TEST_SSID);
+        WifiSsid ssid2 = WifiSsid.fromString("\"Another_SSID\"");
+        PasnConfig config1 = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setWifiSsid(ssid1)
+                .setPassword(TEST_PASSWORD)
+                .setPasnComebackCookie(TEST_COOKIE)
+                .build();
+        PasnConfig config2 = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setWifiSsid(ssid1)
+                .setPassword(TEST_PASSWORD)
+                .setPasnComebackCookie(TEST_COOKIE)
+                .build();
+        PasnConfig config3 = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setWifiSsid(ssid2)
+                .setPassword(TEST_PASSWORD)
+                .setPasnComebackCookie(TEST_COOKIE)
+                .build();
+
+        assertEquals(config1, config2);
+        assertNotEquals(config1, config3);
+        assertEquals(config1.hashCode(), config2.hashCode());
+    }
+
+
+    /**
+     * Tests toString() method.
+     */
+    @Test
+    public void testToString() {
+        WifiSsid ssid = WifiSsid.fromString(TEST_SSID);
+        PasnConfig config = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setPassword(TEST_PASSWORD)
+                .setWifiSsid(ssid)
+                .setPasnComebackCookie(TEST_COOKIE)
+                .build();
+
+        String expectedString = "PasnConfig{" + "mBaseAkms=" + TEST_AKM + ", mCiphers="
+                + TEST_CIPHER + ", mPassword='" + TEST_PASSWORD_MASKED + '\'' + ", mWifiSsid="
+                + ssid + ", mPasnComebackCookie=" + Arrays.toString(TEST_COOKIE) + '}';
+        assertEquals(expectedString, config.toString());
+    }
+
+
+    /**
+     * Verifies that builder methods return a non-null builder instance.
+     */
+    @Test
+    public void testBuilderMethodsReturnNonNull() {
+        PasnConfig.Builder builder = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER);
+        assertNotNull(builder.setPassword(TEST_PASSWORD));
+        assertNotNull(builder.setWifiSsid(WifiSsid.fromString(TEST_SSID)));
+        assertNotNull(builder.setPasnComebackCookie(TEST_COOKIE));
+    }
+
+    /**
+     * Tests the validation when setting an empty comeback cookie.
+     */
+    @Test(expected = IllegalArgumentException.class)
+    public void testSetPasnComebackCookie_emptyCookie() {
+        new PasnConfig.Builder(TEST_AKM, TEST_CIPHER).setPasnComebackCookie(new byte[0]);
+    }
+
+    /**
+     * Tests the validation when setting a long comeback cookie.
+     */
+    @Test(expected = IllegalArgumentException.class)
+    public void testSetPasnComebackCookie_longCookie() {
+        new PasnConfig.Builder(TEST_AKM, TEST_CIPHER).setPasnComebackCookie(new byte[256]);
+    }
+
+    /**
+     * Tests the validation when setting a null comeback cookie.
+     */
+    @Test(expected = NullPointerException.class)
+    public void testSetPasnComebackCookie_nullCookie() {
+        new PasnConfig.Builder(TEST_AKM, TEST_CIPHER).setPasnComebackCookie(null);
+    }
+
+    /**
+     * Tests {@link PasnConfig#getBaseAkmsFromCapabilities(String)} method.
+     */
+    @Test
+    public void testGetBaseAkmsFromCapabilities() {
+        assertEquals(PasnConfig.AKM_NONE, PasnConfig.getBaseAkmsFromCapabilities(null));
+        assertEquals(PasnConfig.AKM_NONE, PasnConfig.getBaseAkmsFromCapabilities(""));
+        assertEquals(PasnConfig.AKM_SAE,
+                PasnConfig.getBaseAkmsFromCapabilities("[RSN-SAE+SAE_EXT_KEY-CCMP-128]"));
+        assertEquals(PasnConfig.AKM_SAE,
+                PasnConfig.getBaseAkmsFromCapabilities("[RSN-PSK+SAE-CCMP-128]"));
+        assertEquals(PasnConfig.AKM_FT_PSK_SHA256,
+                PasnConfig.getBaseAkmsFromCapabilities("[RSN-FT/PSK-CCMP-128]"));
+        assertEquals(PasnConfig.AKM_SAE | PasnConfig.AKM_PASN,
+                PasnConfig.getBaseAkmsFromCapabilities("[RSN-PSK+SAE+PASN-CCMP-128]"));
+    }
+
+    /**
+     * Tests {@link PasnConfig#getCiphersFromCapabilities(String)} method.
+     */
+    @Test
+    public void testGetCiphersFromCapabilities() {
+        assertEquals(PasnConfig.CIPHER_NONE, PasnConfig.getCiphersFromCapabilities(null));
+        assertEquals(PasnConfig.CIPHER_NONE, PasnConfig.getCiphersFromCapabilities(""));
+        assertEquals(PasnConfig.CIPHER_CCMP_128,
+                PasnConfig.getCiphersFromCapabilities("[RSN-SAE+SAE_EXT_KEY-CCMP-128]"));
+        assertEquals(PasnConfig.CIPHER_CCMP_256,
+                PasnConfig.getCiphersFromCapabilities("[RSN-SAE+SAE_EXT_KEY-CCMP-256]"));
+        assertEquals(PasnConfig.CIPHER_GCMP_128,
+                PasnConfig.getCiphersFromCapabilities("[RSN-SAE+SAE_EXT_KEY-GCMP-128]"));
+        assertEquals(PasnConfig.CIPHER_GCMP_256,
+                PasnConfig.getCiphersFromCapabilities("[RSN-SAE+SAE_EXT_KEY-GCMP-256]"));
+        assertEquals(PasnConfig.CIPHER_GCMP_256 | PasnConfig.CIPHER_CCMP_128,
+                PasnConfig.getCiphersFromCapabilities("[RSN-SAE+SAE_EXT_KEY-GCMP-256+CCMP-128]"));
+    }
+
+    /**
+     * Tests {@link PasnConfig#isAkmRequiresPassword(int)} method.
+     */
+    @Test
+    public void testIsAkmRequiresPassword() {
+        assertTrue(PasnConfig.isAkmRequiresPassword(PasnConfig.AKM_SAE));
+    }
+}
diff --git a/framework/tests/src/android/net/wifi/rtt/SecureRangingConfigTest.java b/framework/tests/src/android/net/wifi/rtt/SecureRangingConfigTest.java
new file mode 100644
index 0000000000..fd661d824c
--- /dev/null
+++ b/framework/tests/src/android/net/wifi/rtt/SecureRangingConfigTest.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.net.wifi.rtt;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import android.net.wifi.WifiSsid;
+import android.os.Parcel;
+
+import androidx.test.filters.SmallTest;
+
+import org.junit.Test;
+
+
+/**
+ * Unit tests for {@link SecureRangingConfig}.
+ */
+@SmallTest
+public class SecureRangingConfigTest {
+
+    private static final boolean TEST_SECURE_HE_LTF = true;
+    private static final boolean TEST_RANGING_FRAME_PROTECTION = false;
+    private static final int TEST_AKM = PasnConfig.AKM_SAE;
+    private static final int TEST_CIPHER = PasnConfig.CIPHER_CCMP_128;
+    private static final byte[] TEST_COOKIE = new byte[]{1, 2, 3};
+    private static final String TEST_SSID = "\"Test SSID\"";
+    private static final String TEST_PASSWORD = "password";
+
+    /**
+     * Verify builder and getter methods work as expected.
+     */
+    @Test
+    public void testBuilderAndGetters() {
+        WifiSsid ssid = WifiSsid.fromString(TEST_SSID);
+        PasnConfig pasnConfig = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setPassword(TEST_PASSWORD)
+                .setWifiSsid(ssid)
+                .setPasnComebackCookie(TEST_COOKIE).build();
+        SecureRangingConfig config = new SecureRangingConfig.Builder(pasnConfig)
+                .setSecureHeLtfEnabled(TEST_SECURE_HE_LTF)
+                .setRangingFrameProtectionEnabled(TEST_RANGING_FRAME_PROTECTION)
+                .build();
+
+        assertEquals(TEST_SECURE_HE_LTF, config.isSecureHeLtfEnabled());
+        assertEquals(TEST_RANGING_FRAME_PROTECTION, config.isRangingFrameProtectionEnabled());
+        assertEquals(pasnConfig, config.getPasnConfig());
+    }
+
+    /**
+     * Verify parceling round trip returns an identical object.
+     */
+    @Test
+    public void testParcelableRoundTrip() {
+        WifiSsid ssid = WifiSsid.fromString(TEST_SSID);
+        PasnConfig pasnConfig = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setPassword(TEST_PASSWORD)
+                .setWifiSsid(ssid)
+                .setPasnComebackCookie(TEST_COOKIE).build();
+
+        SecureRangingConfig config = new SecureRangingConfig.Builder(pasnConfig)
+                .setSecureHeLtfEnabled(TEST_SECURE_HE_LTF)
+                .setRangingFrameProtectionEnabled(TEST_RANGING_FRAME_PROTECTION)
+                .build();
+
+        Parcel parcel = Parcel.obtain();
+        config.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        SecureRangingConfig fromParcel =
+                SecureRangingConfig.CREATOR.createFromParcel(parcel);
+        assertEquals(config, fromParcel);
+    }
+
+    /**
+     * Verify default values when not set through the builder.
+     */
+    @Test
+    public void testDefaultValues() {
+        PasnConfig pasnConfig = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER).build();
+        SecureRangingConfig config = new SecureRangingConfig.Builder(pasnConfig).build();
+
+        assertTrue(config.isSecureHeLtfEnabled());
+        assertTrue(config.isRangingFrameProtectionEnabled());
+    }
+
+    /**
+     * Tests equality and non-equality of objects.
+     */
+    @Test
+    public void testEqualsAndHashCode() {
+        PasnConfig pasnConfig1 = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setPasnComebackCookie(TEST_COOKIE).build();
+        PasnConfig pasnConfig2 = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER).build();
+        SecureRangingConfig config1 = new SecureRangingConfig.Builder(pasnConfig1)
+                .setSecureHeLtfEnabled(TEST_SECURE_HE_LTF)
+                .setRangingFrameProtectionEnabled(TEST_RANGING_FRAME_PROTECTION)
+                .build();
+        SecureRangingConfig config2 = new SecureRangingConfig.Builder(pasnConfig1)
+                .setSecureHeLtfEnabled(TEST_SECURE_HE_LTF)
+                .setRangingFrameProtectionEnabled(TEST_RANGING_FRAME_PROTECTION)
+                .build();
+        SecureRangingConfig config3 = new SecureRangingConfig.Builder(pasnConfig2)
+                .setSecureHeLtfEnabled(TEST_SECURE_HE_LTF)
+                .setRangingFrameProtectionEnabled(TEST_RANGING_FRAME_PROTECTION)
+                .build();
+
+        assertEquals(config1, config2);
+        assertNotEquals(config1, config3);
+        assertEquals(config1.hashCode(), config2.hashCode());
+    }
+
+    /**
+     * Tests toString() method.
+     */
+    @Test
+    public void testToString() {
+        WifiSsid ssid = WifiSsid.fromString(TEST_SSID);
+        PasnConfig pasnConfig = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER)
+                .setPassword(TEST_PASSWORD)
+                .setWifiSsid(ssid)
+                .setPasnComebackCookie(TEST_COOKIE).build();
+        SecureRangingConfig config = new SecureRangingConfig.Builder(pasnConfig)
+                .setSecureHeLtfEnabled(TEST_SECURE_HE_LTF)
+                .setRangingFrameProtectionEnabled(TEST_RANGING_FRAME_PROTECTION)
+                .build();
+
+        String configString = config.toString();
+
+        assertNotNull(configString);
+        assertNotEquals("", configString);
+    }
+
+    @Test
+    public void testBuilderMethodsReturnNonNull() {
+        PasnConfig pasnConfig = new PasnConfig.Builder(TEST_AKM, TEST_CIPHER).build();
+        SecureRangingConfig.Builder builder = new SecureRangingConfig.Builder(pasnConfig);
+        assertNotNull(builder.setSecureHeLtfEnabled(TEST_SECURE_HE_LTF));
+        assertNotNull(builder.setRangingFrameProtectionEnabled(TEST_RANGING_FRAME_PROTECTION));
+    }
+
+
+    @Test(expected = NullPointerException.class)
+    public void testBuilder_nullPasnConfigThrowsException() {
+        new SecureRangingConfig.Builder(null);
+    }
+
+}
diff --git a/framework/tests/src/android/net/wifi/rtt/WifiRttManagerTest.java b/framework/tests/src/android/net/wifi/rtt/WifiRttManagerTest.java
index 5514224ce6..08d5f40385 100644
--- a/framework/tests/src/android/net/wifi/rtt/WifiRttManagerTest.java
+++ b/framework/tests/src/android/net/wifi/rtt/WifiRttManagerTest.java
@@ -16,9 +16,11 @@
 
 package android.net.wifi.rtt;
 
+import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.fail;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.eq;
@@ -32,6 +34,7 @@ import android.net.MacAddress;
 import android.net.wifi.OuiKeyedData;
 import android.net.wifi.OuiKeyedDataUtil;
 import android.net.wifi.ScanResult;
+import android.net.wifi.WifiSsid;
 import android.net.wifi.aware.PeerHandle;
 import android.os.Bundle;
 import android.os.IBinder;
@@ -519,6 +522,64 @@ public class WifiRttManagerTest {
         assertEquals(result, rereadResult);
     }
 
+    /**
+     * Validate that RangingResults parcel works with secure ranging enabled (produces same
+     * object on write/read).
+     */
+    @Test
+    public void testSecureRangingResultsParcel() {
+        int status = RangingResult.STATUS_SUCCESS;
+        final MacAddress mac = MacAddress.fromString("00:01:02:03:04:05");
+        int distanceCm = 105;
+        int distanceStdDevCm = 10;
+        int rssi = 5;
+        int numAttemptedMeasurements = 8;
+        int numSuccessfulMeasurements = 3;
+        long timestamp = System.currentTimeMillis();
+        byte[] lci = { 0x5, 0x6, 0x7 };
+        byte[] lcr = { 0x1, 0x2, 0x3, 0xA, 0xB, 0xC };
+        List<OuiKeyedData> vendorData = OuiKeyedDataUtil.createTestOuiKeyedDataList(5);
+
+        RangingResult.Builder resultBuilder = new RangingResult.Builder()
+                .setStatus(status)
+                .setMacAddress(mac)
+                .setDistanceMm(distanceCm)
+                .setDistanceStdDevMm(distanceStdDevCm)
+                .setRssi(rssi)
+                .setNumAttemptedMeasurements(numAttemptedMeasurements)
+                .setNumSuccessfulMeasurements(numSuccessfulMeasurements)
+                .setLci(lci)
+                .setLcr(lcr)
+                .setRangingTimestampMillis(timestamp)
+                .set80211mcMeasurement(false)
+                .set80211azNtbMeasurement(true)
+                .set80211azInitiatorTxLtfRepetitionsCount(2)
+                .set80211azResponderTxLtfRepetitionsCount(2)
+                .set80211azNumberOfRxSpatialStreams(2)
+                .setPasnComebackCookie(new byte[] {1, 2, 3})
+                .setMaxTimeBetweenNtbMeasurementsMicros(1000)
+                .setMinTimeBetweenNtbMeasurementsMicros(100)
+                .setRangingAuthenticated(true)
+                .setRangingFrameProtected(true);
+
+        if (SdkLevel.isAtLeastV()) {
+            resultBuilder.setVendorData(vendorData);
+        }
+        RangingResult result = resultBuilder.build();
+
+        Parcel parcelW = Parcel.obtain();
+        result.writeToParcel(parcelW, 0);
+        byte[] bytes = parcelW.marshall();
+        parcelW.recycle();
+
+        Parcel parcelR = Parcel.obtain();
+        parcelR.unmarshall(bytes, 0, bytes.length);
+        parcelR.setDataPosition(0);
+        RangingResult rereadResult = RangingResult.CREATOR.createFromParcel(parcelR);
+
+        assertEquals(result, rereadResult);
+    }
+
     /**
      * Validate that RangingResults tests equal even if LCI/LCR is empty (length == 0) and null.
      */
@@ -568,6 +629,17 @@ public class WifiRttManagerTest {
      */
     @Test
     public void testResponderConfigParcel() {
+        // Create SecureRangingConfig
+        PasnConfig pasnConfig = new PasnConfig.Builder(PasnConfig.AKM_SAE | PasnConfig.AKM_PASN,
+                PasnConfig.CIPHER_CCMP_256 | PasnConfig.CIPHER_GCMP_256)
+                .setPassword("password")
+                .setWifiSsid(WifiSsid.fromString("\"SSID\""))
+                .setPasnComebackCookie(new byte[]{1, 2, 3})
+                .build();
+        SecureRangingConfig secureRangingConfig = new SecureRangingConfig.Builder(pasnConfig)
+                .setSecureHeLtfEnabled(true)
+                .setRangingFrameProtectionEnabled(true)
+                .build();
         // ResponderConfig constructed with a MAC address
         ResponderConfig config = new ResponderConfig.Builder()
                 .setMacAddress(MacAddress.fromString("00:01:02:03:04:05"))
@@ -577,6 +649,10 @@ public class WifiRttManagerTest {
                 .setCenterFreq0Mhz(2345)
                 .setCenterFreq1Mhz(2555)
                 .setPreamble(ScanResult.PREAMBLE_LEGACY)
+                .set80211azNtbSupported(true)
+                .setNtbMaxTimeBetweenMeasurementsMicros(10000)
+                .setNtbMinTimeBetweenMeasurementsMicros(100)
+                .setSecureRangingConfig(secureRangingConfig)
                 .build();
 
         Parcel parcelW = Parcel.obtain();
@@ -634,6 +710,10 @@ public class WifiRttManagerTest {
         heCap.id = ScanResult.InformationElement.EID_EXTENSION_PRESENT;
         heCap.idExt = ScanResult.InformationElement.EID_EXT_HE_CAPABILITIES;
 
+        ScanResult.InformationElement ehtCap = new ScanResult.InformationElement();
+        ehtCap.id = ScanResult.InformationElement.EID_EXTENSION_PRESENT;
+        ehtCap.idExt = ScanResult.InformationElement.EID_EXT_EHT_CAPABILITIES;
+
         // no IE
         ScanResult scan = new ScanResult();
         scan.BSSID = "00:01:02:03:04:05";
@@ -689,6 +769,57 @@ public class WifiRttManagerTest {
         config = ResponderConfig.fromScanResult(scan);
 
         assertEquals(ResponderConfig.PREAMBLE_HE, config.preamble);
+
+        ScanResult.InformationElement[] ie = new ScanResult.InformationElement[3];
+        ie[0] = vhtCap;
+        ie[1] = heCap;
+        ie[2] = ehtCap;
+
+        ScanResult.Builder builder = new ScanResult.Builder()
+                .setBssid("00:01:02:03:04:05")
+                .setChannelWidth(ResponderConfig.CHANNEL_WIDTH_80MHZ);
+
+        // Validate 11az & 11mc ranging in 5 Ghz and EHT
+        scan =  builder.setFrequency(5200).setIs80211azNtbRTTResponder(true)
+                .setIs80211McRTTResponder(true).build();
+        scan.informationElements = ie;
+        config = ResponderConfig.fromScanResult(scan);
+        assertEquals(ResponderConfig.PREAMBLE_EHT, config.preamble);
+
+        // Validate 11az & 11mc ranging in 6 Ghz and EHT
+        scan =  builder.setFrequency(5935).setIs80211azNtbRTTResponder(true)
+                .setIs80211McRTTResponder(true).build();
+        scan.informationElements = ie;
+        config = ResponderConfig.fromScanResult(scan);
+        assertEquals(ResponderConfig.PREAMBLE_EHT, config.preamble);
+
+        // Validate 11mc ranging in 5 Ghz with EHT
+        scan =  builder.setFrequency(5200).setIs80211azNtbRTTResponder(false)
+                .setIs80211McRTTResponder(true).build();
+        scan.informationElements = ie;
+        config = ResponderConfig.fromScanResult(scan);
+        assertEquals(ResponderConfig.PREAMBLE_VHT, config.preamble);
+
+        // Validate one-sided ranging in 5 Ghz with EHT; Same result as 11mc.
+        scan =  builder.setFrequency(5200).setIs80211azNtbRTTResponder(false)
+                .setIs80211McRTTResponder(false).build();
+        scan.informationElements = ie;
+        config = ResponderConfig.fromScanResult(scan);
+        assertEquals(ResponderConfig.PREAMBLE_VHT, config.preamble);
+
+        // Validate 11mc ranging in 6 Ghz with EHT
+        scan =  builder.setFrequency(5935).setIs80211azNtbRTTResponder(false)
+                .setIs80211McRTTResponder(true).build();
+        scan.informationElements = ie;
+        config = ResponderConfig.fromScanResult(scan);
+        assertEquals(ResponderConfig.PREAMBLE_EHT, config.preamble);
+
+        // Validate one-sided ranging in 6 Ghz with EHT; Same result as 11mc.
+        scan =  builder.setFrequency(5935).setIs80211azNtbRTTResponder(false)
+                .setIs80211McRTTResponder(false).build();
+        scan.informationElements = ie;
+        config = ResponderConfig.fromScanResult(scan);
+        assertEquals(ResponderConfig.PREAMBLE_EHT, config.preamble);
     }
 
     @Test
@@ -698,4 +829,96 @@ public class WifiRttManagerTest {
         verify(mockRttService).getRttCharacteristics();
         assertEquals(0, characteristics.size());
     }
+
+    /**
+     * Validate secure ranging request call flow with successful results.
+     */
+    @Test
+    public void testSecureRangeSuccess() throws Exception {
+        // Build a scan result with secure ranging support
+        ScanResult.InformationElement htCap = new ScanResult.InformationElement();
+        htCap.id = ScanResult.InformationElement.EID_HT_CAPABILITIES;
+
+        ScanResult.InformationElement vhtCap = new ScanResult.InformationElement();
+        vhtCap.id = ScanResult.InformationElement.EID_VHT_CAPABILITIES;
+
+        ScanResult.InformationElement vsa = new ScanResult.InformationElement();
+        vsa.id = ScanResult.InformationElement.EID_VSA;
+
+        ScanResult.InformationElement heCap = new ScanResult.InformationElement();
+        heCap.id = ScanResult.InformationElement.EID_EXTENSION_PRESENT;
+        heCap.idExt = ScanResult.InformationElement.EID_EXT_HE_CAPABILITIES;
+
+        ScanResult.InformationElement ehtCap = new ScanResult.InformationElement();
+        ehtCap.id = ScanResult.InformationElement.EID_EXTENSION_PRESENT;
+        ehtCap.idExt = ScanResult.InformationElement.EID_EXT_EHT_CAPABILITIES;
+
+        ScanResult.InformationElement[] ie = new ScanResult.InformationElement[3];
+        ie[0] = vhtCap;
+        ie[1] = heCap;
+        ie[2] = ehtCap;
+
+        // Build a secure ranging request
+        ScanResult scanResult = new ScanResult();
+        scanResult.BSSID = "00:01:02:03:04:05";
+        scanResult.setFlag(
+                ScanResult.FLAG_80211az_NTB_RESPONDER | ScanResult.FLAG_SECURE_HE_LTF_SUPPORTED);
+        scanResult.informationElements = ie;
+        scanResult.capabilities = "[RSN-PASN-SAE+SAE_EXT_KEY-GCMP-128]";
+        scanResult.setWifiSsid(WifiSsid.fromString("\"TEST_SSID\""));
+
+        RangingRequest.Builder builder = new RangingRequest.Builder();
+        builder.addAccessPoint(scanResult);
+        builder.setSecurityMode(RangingRequest.SECURITY_MODE_SECURE_AUTH);
+        RangingRequest secureRangingRequest = builder.build();
+
+        // Make sure responder is configured correctly for secure ranging
+        ResponderConfig responderConfig = secureRangingRequest.getRttResponders().get(0);
+        assertNotNull(responderConfig);
+        SecureRangingConfig secureRangingConfig = responderConfig.getSecureRangingConfig();
+        assertNotNull(secureRangingConfig);
+        assertTrue(secureRangingConfig.isRangingFrameProtectionEnabled());
+        assertTrue(secureRangingConfig.isSecureHeLtfEnabled());
+        PasnConfig pasnConfig = secureRangingConfig.getPasnConfig();
+        assertNotNull(pasnConfig);
+        assertEquals(PasnConfig.AKM_PASN | PasnConfig.AKM_SAE, pasnConfig.getBaseAkms());
+        assertEquals(PasnConfig.CIPHER_GCMP_128, pasnConfig.getCiphers());
+        assertNull(pasnConfig.getPasnComebackCookie());
+        assertEquals(WifiSsid.fromString("\"TEST_SSID\""), pasnConfig.getWifiSsid());
+        assertEquals(RangingRequest.SECURITY_MODE_SECURE_AUTH,
+                secureRangingRequest.getSecurityMode());
+
+        List<RangingResult> results = new ArrayList<>();
+        results.add(new RangingResult.Builder()
+                .setStatus(RangingResult.STATUS_SUCCESS)
+                .setMacAddress(MacAddress.fromString(scanResult.BSSID))
+                .setDistanceMm(15)
+                .setDistanceStdDevMm(5)
+                .setRssi(10)
+                .setNumAttemptedMeasurements(8)
+                .setNumSuccessfulMeasurements(5)
+                .setRangingTimestampMillis(666)
+                .set80211mcMeasurement(false)
+                .set80211azNtbMeasurement(true)
+                .setRangingFrameProtected(true)
+                .setSecureHeLtfEnabled(true)
+                .setSecureHeLtfProtocolVersion(0)
+                .build());
+        RangingResultCallback callbackMock = mock(RangingResultCallback.class);
+        ArgumentCaptor<IRttCallback> callbackCaptor = ArgumentCaptor.forClass(IRttCallback.class);
+
+        // verify ranging request passed to service
+        mDut.startRanging(secureRangingRequest, mMockLooperExecutor, callbackMock);
+        verify(mockRttService).startRanging(any(IBinder.class), eq(packageName), eq(featureId),
+                eq(null),  eq(secureRangingRequest), callbackCaptor.capture(),
+                any(Bundle.class));
+
+        // service calls back with success
+        callbackCaptor.getValue().onRangingResults(results);
+        mMockLooper.dispatchAll();
+        verify(callbackMock).onRangingResults(results);
+
+        verifyNoMoreInteractions(mockRttService, callbackMock);
+    }
+
 }
diff --git a/framework/tests/src/android/net/wifi/usd/SubscribeConfigTest.java b/framework/tests/src/android/net/wifi/usd/SubscribeConfigTest.java
new file mode 100644
index 0000000000..fa76b12551
--- /dev/null
+++ b/framework/tests/src/android/net/wifi/usd/SubscribeConfigTest.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.wifi.usd;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThrows;
+
+import android.os.Parcel;
+
+import androidx.test.filters.SmallTest;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Unit test harness for SubscribeConfig class.
+ */
+@SmallTest
+public class SubscribeConfigTest {
+    private static final String USD_SERVICE_NAME = "USD_UNIT_TEST";
+    private static final byte[] TEST_SSI = new byte[]{1, 2, 3, 4};
+    private static final int TEST_TTL_SECONDS = 3000;
+    private static final int TEST_QUERY_PERIOD_MILLIS = 200;
+    private static final int[] TEST_FREQUENCIES = new int[]{2412, 2437, 2462};
+    private List<byte[]> mFilter;
+
+    @Before
+    public void setUp() throws Exception {
+        mFilter = new ArrayList<>();
+        mFilter.add(new byte[]{10, 11});
+        mFilter.add(new byte[]{12, 13, 14});
+    }
+
+    /**
+     * Tests set and get for SubscribeConfig.
+     */
+    @Test
+    public void testSubscribeConfig() {
+        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder(
+                USD_SERVICE_NAME).setQueryPeriodMillis(TEST_QUERY_PERIOD_MILLIS).setSubscribeType(
+                SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE).setServiceProtoType(
+                SubscribeConfig.SERVICE_PROTO_TYPE_GENERIC).setTtlSeconds(
+                TEST_TTL_SECONDS).setRecommendedOperatingFrequenciesMhz(
+                TEST_FREQUENCIES).setServiceSpecificInfo(TEST_SSI).setTxMatchFilter(
+                mFilter).setRxMatchFilter(mFilter).setOperatingFrequenciesMhz(
+                TEST_FREQUENCIES).build();
+        assertArrayEquals(USD_SERVICE_NAME.getBytes(), subscribeConfig.getServiceName());
+        assertEquals(200, subscribeConfig.getQueryPeriodMillis());
+        assertEquals(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE, subscribeConfig.getSubscribeType());
+        assertEquals(SubscribeConfig.SERVICE_PROTO_TYPE_GENERIC,
+                subscribeConfig.getServiceProtoType());
+        assertEquals(TEST_TTL_SECONDS, subscribeConfig.getTtlSeconds());
+        assertArrayEquals(TEST_FREQUENCIES,
+                subscribeConfig.getRecommendedOperatingFrequenciesMhz());
+        assertArrayEquals(TEST_SSI, subscribeConfig.getServiceSpecificInfo());
+        assertEquals(mFilter.size(), subscribeConfig.getRxMatchFilter().size());
+        assertEquals(mFilter.size(), subscribeConfig.getTxMatchFilter().size());
+        for (int i = 0; i < mFilter.size(); i++) {
+            assertArrayEquals(mFilter.get(i), subscribeConfig.getRxMatchFilter().get(i));
+            assertArrayEquals(mFilter.get(i), subscribeConfig.getTxMatchFilter().get(i));
+        }
+        assertArrayEquals(TEST_FREQUENCIES, subscribeConfig.getOperatingFrequenciesMhz());
+    }
+
+    /**
+     * Tests SubscribeConfig with invalid arguments.
+     */
+    @Test
+    public void testSubscribeConfigWithInvalidArgs() {
+        assertThrows(NullPointerException.class, () -> new SubscribeConfig.Builder(null));
+        assertThrows(IllegalArgumentException.class, () -> new SubscribeConfig.Builder(""));
+        assertThrows(IllegalArgumentException.class,
+                () -> new SubscribeConfig.Builder("a".repeat(258)));
+        SubscribeConfig.Builder builder = new SubscribeConfig.Builder(USD_SERVICE_NAME);
+        assertThrows(IllegalArgumentException.class, () -> builder.setQueryPeriodMillis(-1));
+        assertThrows(IllegalArgumentException.class, () -> builder.setSubscribeType(4));
+        assertThrows(IllegalArgumentException.class, () -> builder.setServiceProtoType(4));
+        assertThrows(IllegalArgumentException.class, () -> builder.setTtlSeconds(-1));
+        assertThrows(NullPointerException.class,
+                () -> builder.setRecommendedOperatingFrequenciesMhz(null));
+        assertThrows(IllegalArgumentException.class,
+                () -> builder.setRecommendedOperatingFrequenciesMhz(new int[]{1, 2, 3}));
+        assertThrows(IllegalArgumentException.class,
+                () -> builder.setRecommendedOperatingFrequenciesMhz(
+                        new int[Config.MAX_NUM_OF_OPERATING_FREQUENCIES + 1]));
+        assertThrows(IllegalArgumentException.class, () -> builder.setQueryPeriodMillis(-1));
+        assertThrows(NullPointerException.class, () -> builder.setServiceSpecificInfo(null));
+        assertThrows(NullPointerException.class, () -> builder.setRxMatchFilter(null));
+        assertThrows(NullPointerException.class, () -> builder.setTxMatchFilter(null));
+        assertThrows(NullPointerException.class, () -> builder.setOperatingFrequenciesMhz(null));
+        assertThrows(IllegalArgumentException.class,
+                () -> builder.setOperatingFrequenciesMhz(new int[]{1, 2, 3}));
+        assertThrows(IllegalArgumentException.class, () -> builder.setOperatingFrequenciesMhz(
+                new int[Config.MAX_NUM_OF_OPERATING_FREQUENCIES + 1]));
+    }
+
+    /**
+     * Tests SubscribeConfig object is correctly serialized and deserialized when using parcel.
+     */
+    @Test
+    public void testSubscribeConfigParcel() {
+        // Create SubscribeConfig
+        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder(
+                USD_SERVICE_NAME).setQueryPeriodMillis(TEST_QUERY_PERIOD_MILLIS).setSubscribeType(
+                SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE).setServiceProtoType(
+                SubscribeConfig.SERVICE_PROTO_TYPE_GENERIC).setTtlSeconds(
+                TEST_TTL_SECONDS).setRecommendedOperatingFrequenciesMhz(
+                TEST_FREQUENCIES).setServiceSpecificInfo(TEST_SSI).setTxMatchFilter(
+                mFilter).setRxMatchFilter(mFilter).setOperatingFrequenciesMhz(
+                TEST_FREQUENCIES).build();
+        // Serialize SubscribeConfig to parcel
+        Parcel parcel = Parcel.obtain();
+        subscribeConfig.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+        // Deserialize SubscribeConfig from parcel
+        SubscribeConfig deserializedSubscribeConfig = SubscribeConfig.CREATOR.createFromParcel(
+                parcel);
+        // Validate deserialized SubscribeConfig is equal to original SubscribeConfig
+        assertEquals(subscribeConfig, deserializedSubscribeConfig);
+        assertEquals(subscribeConfig.hashCode(), deserializedSubscribeConfig.hashCode());
+        // Release the parcel
+        parcel.recycle();
+    }
+}
diff --git a/framework/tests/src/android/net/wifi/util/WifiResourceCacheTest.java b/framework/tests/src/android/net/wifi/util/WifiResourceCacheTest.java
index f1a7578211..c05b49f778 100644
--- a/framework/tests/src/android/net/wifi/util/WifiResourceCacheTest.java
+++ b/framework/tests/src/android/net/wifi/util/WifiResourceCacheTest.java
@@ -155,11 +155,11 @@ public class WifiResourceCacheTest {
     public void testOverrideStringArrayResource() {
         mWifiResourceCache.restoreStringArrayValue(String.valueOf(TEST_ID));
         when(mResources.getStringArray(TEST_ID)).thenReturn(STRINGS_1);
-        assertEquals(STRINGS_1, mWifiResourceCache.getStringArray(TEST_ID));
+        assertArrayEquals(STRINGS_1, mWifiResourceCache.getStringArray(TEST_ID));
         mWifiResourceCache.overrideStringArrayValue(String.valueOf(TEST_ID), STRINGS_2);
-        assertEquals(STRINGS_2, mWifiResourceCache.getStringArray(TEST_ID));
+        assertArrayEquals(STRINGS_2, mWifiResourceCache.getStringArray(TEST_ID));
         mWifiResourceCache.restoreStringArrayValue(String.valueOf(TEST_ID));
-        assertEquals(STRINGS_1, mWifiResourceCache.getStringArray(TEST_ID));
+        assertArrayEquals(STRINGS_1, mWifiResourceCache.getStringArray(TEST_ID));
         verify(mResources, times(2)).getStringArray(TEST_ID);
     }
 
@@ -180,4 +180,17 @@ public class WifiResourceCacheTest {
         verify(mResources, times(2)).getBoolean(TEST_ID);
         verify(mResources, times(2)).getInteger(TEST_ID + 1);
     }
+
+    @Test
+    public void testHandleLocaleChange() {
+        when(mResources.getStringArray(TEST_ID)).thenReturn(STRINGS_1);
+        when(mResources.getString(TEST_ID + 1)).thenReturn(STRING_1);
+        assertArrayEquals(STRINGS_1, mWifiResourceCache.getStringArray(TEST_ID));
+        assertEquals(STRING_1, mWifiResourceCache.getString(TEST_ID + 1));
+        when(mResources.getStringArray(TEST_ID)).thenReturn(STRINGS_2);
+        when(mResources.getString(TEST_ID + 1)).thenReturn(STRING_2);
+        mWifiResourceCache.handleLocaleChange();
+        assertArrayEquals(STRINGS_2, mWifiResourceCache.getStringArray(TEST_ID));
+        assertEquals(STRING_2, mWifiResourceCache.getString(TEST_ID + 1));
+    }
 }
diff --git a/service/Android.bp b/service/Android.bp
index 797fc73ff7..520ef7b230 100644
--- a/service/Android.bp
+++ b/service/Android.bp
@@ -123,8 +123,10 @@ java_library {
         "service-entitlement",
         "wifi-lite-protos",
         "wifi-nano-protos",
+        "com.android.net.flags-aconfig-java-export",
         "android.net.wifi.flags-aconfig-java",
         "android.security.flags-aconfig-java-export",
+        "telephony_flags_core_java_exported_lib",
         "net-utils-service-wifi",
     ],
     apex_available: ["com.android.wifi"],
diff --git a/service/ServiceWifiResources/res/values-es-rUS/strings.xml b/service/ServiceWifiResources/res/values-es-rUS/strings.xml
index 77d1c5f410..b1137fbb87 100644
--- a/service/ServiceWifiResources/res/values-es-rUS/strings.xml
+++ b/service/ServiceWifiResources/res/values-es-rUS/strings.xml
@@ -177,10 +177,10 @@
     <string name="wifi_enable_request_dialog_message" msgid="6395169178524938278">"Puedes desactivar el WiFi en la Configuracin rpida"</string>
     <string name="wifi_enable_request_dialog_positive_button" msgid="6050832555821470466">"Permitir"</string>
     <string name="wifi_enable_request_dialog_negative_button" msgid="4754219902374918882">"No permitir"</string>
-    <string name="wifi_enabled_apm_first_time_title" msgid="4814302384637588804">"Wi-Fi activado en modo de avin"</string>
-    <string name="wifi_enabled_apm_first_time_message" msgid="6416193199042203037">"Si mantienes el Wi-Fi activado, el dispositivo recordar mantenerlo activado la prxima vez que actives el modo de avin"</string>
+    <string name="wifi_enabled_apm_first_time_title" msgid="4814302384637588804">"Wi-Fi activado en modo avin"</string>
+    <string name="wifi_enabled_apm_first_time_message" msgid="6416193199042203037">"Si mantienes el Wi-Fi activado, el dispositivo recordar mantenerlo activado la prxima vez que actives el modo avin"</string>
     <string name="apm_enabled_first_time_title" msgid="2534167413190488009">"El Wi-Fi permanece activado"</string>
-    <string name="apm_enabled_first_time_message" msgid="6093911536874954410">"El dispositivo dejar activado el Wi-Fi en el modo de avin. Desactiva el Wi-Fi si no quieres que permanezca activado."</string>
+    <string name="apm_enabled_first_time_message" msgid="6093911536874954410">"El dispositivo dejar activado el Wi-Fi en el modo avin. Desactiva el Wi-Fi si no quieres que permanezca activado."</string>
     <string name="wifi_network_disabled_by_admin_title" msgid="9057697656855227293">"Red no disponible"</string>
     <string name="wifi_network_disabled_by_admin_message" msgid="7830360441333155462">"Tu administrador inhabilit <xliff:g id="SSID">%1$s</xliff:g>."</string>
     <string name="wifi_network_disabled_by_admin_button" msgid="3350310756265122689">"Cerrar"</string>
diff --git a/service/ServiceWifiResources/res/values-fr-rCA-feminine/strings.xml b/service/ServiceWifiResources/res/values-fr-rCA-feminine/strings.xml
new file mode 100644
index 0000000000..e90236a14b
--- /dev/null
+++ b/service/ServiceWifiResources/res/values-fr-rCA-feminine/strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+  <string-array name="wifi_eap_error_message_code_32763_carrier_overrides">
+    <item msgid="591026649262091217">"<xliff:g id="CARRIER_ID_PREFIX">:::1839:::</xliff:g><xliff:g id="SSID">%1$s</xliff:g>: vous tes dj connecte  Verizon Wi-Fi Access. (Erreur=32763)"</item>
+  </string-array>
+    <string name="wifi_ca_cert_dialog_preT_continue_text" msgid="9118713368838029797">"Rester connecte"</string>
+</resources>
diff --git a/service/ServiceWifiResources/res/values-fr-rCA-masculine/strings.xml b/service/ServiceWifiResources/res/values-fr-rCA-masculine/strings.xml
new file mode 100644
index 0000000000..6d357d7e41
--- /dev/null
+++ b/service/ServiceWifiResources/res/values-fr-rCA-masculine/strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+  <string-array name="wifi_eap_error_message_code_32763_carrier_overrides">
+    <item msgid="591026649262091217">"<xliff:g id="CARRIER_ID_PREFIX">:::1839:::</xliff:g><xliff:g id="SSID">%1$s</xliff:g>: vous tes dj connect  Verizon Wi-Fi Access. (Erreur=32763)"</item>
+  </string-array>
+    <string name="wifi_ca_cert_dialog_preT_continue_text" msgid="9118713368838029797">"Rester connect"</string>
+</resources>
diff --git a/service/ServiceWifiResources/res/values-fr-rCA-neuter/strings.xml b/service/ServiceWifiResources/res/values-fr-rCA-neuter/strings.xml
new file mode 100644
index 0000000000..1c3e4f2f68
--- /dev/null
+++ b/service/ServiceWifiResources/res/values-fr-rCA-neuter/strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+  <string-array name="wifi_eap_error_message_code_32763_carrier_overrides">
+    <item msgid="591026649262091217">"<xliff:g id="CARRIER_ID_PREFIX">:::1839:::</xliff:g><xliff:g id="SSID">%1$s</xliff:g>: votre connexion  Verizon Wi-Fi Access est dj tablie. (Erreur=32763)"</item>
+  </string-array>
+    <string name="wifi_ca_cert_dialog_preT_continue_text" msgid="9118713368838029797">"Rester connecte"</string>
+</resources>
diff --git a/service/ServiceWifiResources/res/values-hr/strings.xml b/service/ServiceWifiResources/res/values-hr/strings.xml
index bf88b909a3..044d6f082a 100644
--- a/service/ServiceWifiResources/res/values-hr/strings.xml
+++ b/service/ServiceWifiResources/res/values-hr/strings.xml
@@ -146,7 +146,7 @@
     <string name="wifi_interface_priority_interface_name_sta" msgid="5107477901500010776">"STA"</string>
     <string name="wifi_interface_priority_interface_name_ap" msgid="161777054136866061">"WiFi arina toka"</string>
     <string name="wifi_interface_priority_interface_name_ap_bridge" msgid="1270364818879977821">"WiFi arina toka"</string>
-    <string name="wifi_interface_priority_interface_name_p2p" msgid="1278122698099149708">"Izravni Wi-Fi"</string>
+    <string name="wifi_interface_priority_interface_name_p2p" msgid="1278122698099149708">"Wi-Fi Direct"</string>
     <string name="wifi_interface_priority_interface_name_nan" msgid="8812888073122966870">"WiFi Aware"</string>
     <string name="wifi_ca_cert_dialog_title" msgid="3872340345882915806">"Je li ova mrea pouzdana?"</string>
     <string name="wifi_ca_cert_dialog_continue_text" msgid="1674156611893471003">"Da, povei"</string>
diff --git a/service/ServiceWifiResources/res/values-mcc310-mnc950 b/service/ServiceWifiResources/res/values-mcc310-mnc950
deleted file mode 120000
index 179ce02a94..0000000000
--- a/service/ServiceWifiResources/res/values-mcc310-mnc950
+++ /dev/null
@@ -1 +0,0 @@
-values-mcc310-mnc030
\ No newline at end of file
diff --git a/service/ServiceWifiResources/res/values-mcc310-mnc950/config.xml b/service/ServiceWifiResources/res/values-mcc310-mnc950/config.xml
new file mode 100644
index 0000000000..c6fdb89325
--- /dev/null
+++ b/service/ServiceWifiResources/res/values-mcc310-mnc950/config.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <integer name="config_wifiFrameworkSecureNetworkBonus">540</integer>
+
+    <string-array translatable="false" name="config_wifiOobPseudonymEnabled_carrier_overrides">
+        <item><xliff:g id="carrier_id_prefix">:::1187:::</xliff:g>true</item>
+    </string-array>
+
+    <!-- Carrier specific override for the URL of entitlement server retrieving OOB pseudonym. -->
+    <string-array translatable="false" name="config_wifiOobPseudonymEntitlementServerUrl_carrier_overrides">
+        <item><xliff:g id="carrier_id_prefix">:::1187:::</xliff:g>https://sentitlement2.npc.mobilephone.net/WFC</item>
+    </string-array>
+</resources>
diff --git a/service/ServiceWifiResources/res/values-mcc311-mnc180 b/service/ServiceWifiResources/res/values-mcc311-mnc180
index 179ce02a94..c885455563 120000
--- a/service/ServiceWifiResources/res/values-mcc311-mnc180
+++ b/service/ServiceWifiResources/res/values-mcc311-mnc180
@@ -1 +1 @@
-values-mcc310-mnc030
\ No newline at end of file
+values-mcc310-mnc950
\ No newline at end of file
diff --git a/service/ServiceWifiResources/res/values-mcc312-mnc670/config.xml b/service/ServiceWifiResources/res/values-mcc312-mnc670/config.xml
new file mode 100644
index 0000000000..a605db28c3
--- /dev/null
+++ b/service/ServiceWifiResources/res/values-mcc312-mnc670/config.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string-array translatable="false" name="config_wifiOobPseudonymEnabled_carrier_overrides">
+        <item><xliff:g id="carrier_id_prefix">:::2119:::</xliff:g>true</item>
+    </string-array>
+
+    <!-- Carrier specific override for the URL of entitlement server retrieving OOB pseudonym. -->
+    <string-array translatable="false" name="config_wifiOobPseudonymEntitlementServerUrl_carrier_overrides">
+        <item><xliff:g id="carrier_id_prefix">:::2119:::</xliff:g>https://sentitlement2.npc.mobilephone.net/WFC</item>
+    </string-array>
+</resources>
diff --git a/service/ServiceWifiResources/res/values-mcc313-mnc140 b/service/ServiceWifiResources/res/values-mcc313-mnc140
new file mode 120000
index 0000000000..2d21ee5bae
--- /dev/null
+++ b/service/ServiceWifiResources/res/values-mcc313-mnc140
@@ -0,0 +1 @@
+values-mcc313-mnc100
\ No newline at end of file
diff --git a/service/ServiceWifiResources/res/values-mr/strings.xml b/service/ServiceWifiResources/res/values-mr/strings.xml
index ec418c2c5f..35a0c9a5f0 100644
--- a/service/ServiceWifiResources/res/values-mr/strings.xml
+++ b/service/ServiceWifiResources/res/values-mr/strings.xml
@@ -16,7 +16,7 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="wifiResourcesAppLabel" product="default" msgid="3120115613525263696">" - "</string>
+    <string name="wifiResourcesAppLabel" product="default" msgid="3120115613525263696">" - "</string>
     <string name="wifi_available_title" msgid="3899472737467127635">" -   "</string>
     <string name="wifi_available_title_connecting" msgid="7233590022728579868">"-    "</string>
     <string name="wifi_available_title_connected" msgid="6329493859989844201">"-   "</string>
diff --git a/service/ServiceWifiResources/res/values-nb/strings.xml b/service/ServiceWifiResources/res/values-nb/strings.xml
index 888e70154e..36a08e500a 100644
--- a/service/ServiceWifiResources/res/values-nb/strings.xml
+++ b/service/ServiceWifiResources/res/values-nb/strings.xml
@@ -173,7 +173,7 @@
     <string name="wifi_ca_cert_notification_preT_message" msgid="4565553176090475724">"Nettverket <xliff:g id="SSID">%1$s</xliff:g> mangler et sertifikat. Trykk for  finne ut hvordan du legger til sertifikater."</string>
     <string name="wifi_ca_cert_notification_preT_continue_text" msgid="1525418430746943670">"Koble til likevel"</string>
     <string name="wifi_ca_cert_notification_preT_abort_text" msgid="8307996031461071854">"Ikke koble til"</string>
-    <string name="wifi_enable_request_dialog_title" msgid="3577459145316177148">"Vil du gi <xliff:g id="APP_NAME">%1$s</xliff:g> tillatelse til  sl p WiFi?"</string>
+    <string name="wifi_enable_request_dialog_title" msgid="3577459145316177148">"Vil du gi <xliff:g id="APP_NAME">%1$s</xliff:g> tillatelse til  sl p wifi?"</string>
     <string name="wifi_enable_request_dialog_message" msgid="6395169178524938278">"Du kan sl av WiFi i hurtiginnstillingene"</string>
     <string name="wifi_enable_request_dialog_positive_button" msgid="6050832555821470466">"Tillat"</string>
     <string name="wifi_enable_request_dialog_negative_button" msgid="4754219902374918882">"Ikke tillat"</string>
diff --git a/service/ServiceWifiResources/res/values/config.xml b/service/ServiceWifiResources/res/values/config.xml
index 5390b48e86..92aac8ffc4 100644
--- a/service/ServiceWifiResources/res/values/config.xml
+++ b/service/ServiceWifiResources/res/values/config.xml
@@ -1019,9 +1019,9 @@
 
     <!-- Indicate whether the verbose logging is always on -->
     <!-- 0: verbose logging controlled by user
-         1: verbose logging on by default for userdebug
+         1: verbose logging on by default for userdebug/eng
          2: verbose logging on by default for all builds -->
-    <integer translatable="false" name="config_wifiVerboseLoggingAlwaysOnLevel">0</integer>
+    <integer translatable="false" name="config_wifiVerboseLoggingAlwaysOnLevel">1</integer>
 
     <!-- Indicate the help page link for the Root CA certifiate installation. -->
     <string translatable="false" name="config_wifiCertInstallationHelpLink">https://support.google.com/pixelphone/answer/2844832</string>
@@ -1268,8 +1268,8 @@
     <string translatable="false" name="config_wifiP2pGoEapolIpAddressRangeStart"/>
     <string translatable="false" name="config_wifiP2pGoEapolIpAddressRangeEnd"/>
     <!-- Boolean indicating whether to disable firmware roaming when the device goes into idle mode.
-         true: firmware roaming will be disabled when the device goes into idle mode, and then
-               re-activated when the device exits idle mode.
+         true: firmware roaming will be disabled when the device goes into idle mode and screen
+               is off, and then re-activated when the device exits idle mode or screen is on.
          false: firmware roaming will not be affected. -->
     <bool translatable="false" name ="config_wifiDisableFirmwareRoamingInIdleMode">false</bool>
     <!-- Boolean indicating whether the framework updates country from scan results when there is
@@ -1412,7 +1412,12 @@
     <!-- Boolean indicating whether to trigger bugreport for WiFi subsystem restart issue -->
     <bool translatable="false" name ="config_wifi_subsystem_restart_bugreport_enabled">true</bool>
 
-    <!-- Boolean indicating whether to use the common nl80211 implementation of the WiFi Hal. This
-         will be used instead of the AIDL or HIDL implementation if enabled. -->
-    <bool translatable="false" name="config_wifiNl80211HalEnabled">false</bool>
+    <!-- Boolean indicating whether to use wifi VoIP detection module to detect VoIP over Wi-FI to
+         ehance Wi-Fi VoIP quality -->
+    <bool translatable="false" name="config_wifiVoipDetectionEnabled">false</bool>
+    <!-- Boolean indicating whether USD publisher is supported. This flag overrides device's USD
+         publisher support capability if set to false. It is disabled by default since USD publisher
+         has longer off-channel dwell time (500 milliseconds to 1 sec) and a much longer pause
+         timeout (60 sec) once it finds a subscriber. -->
+    <bool translatable="false" name="config_wifiUsdPublisherSupported">false</bool>
 </resources>
diff --git a/service/ServiceWifiResources/res/values/overlayable.xml b/service/ServiceWifiResources/res/values/overlayable.xml
index 5d0cf847d6..dcca1a6b0b 100644
--- a/service/ServiceWifiResources/res/values/overlayable.xml
+++ b/service/ServiceWifiResources/res/values/overlayable.xml
@@ -355,7 +355,8 @@
           <item type="integer" name="config_wifiDelayedCarrierSelectionTimeMs" />
           <item type="bool" name="config_wifiRsnOverridingEnabled" />
           <item type="bool" name="config_wifi_subsystem_restart_bugreport_enabled" />
-          <item type="bool" name="config_wifiNl80211HalEnabled" />
+          <item type="bool" name="config_wifiVoipDetectionEnabled" />
+          <item type="bool" name="config_wifiUsdPublisherSupported" />
 
           <!-- Params from config.xml that can be overlayed -->
 
@@ -428,8 +429,6 @@
           <item type="string" name="wifi_eap_error_message_code_32765" />
           <item type="string" name="wifi_eap_error_message_code_32766" />
           <item type="string" name="wifi_eap_error_message_code_32767" />
-          <item type="string" name="wifi_eap_error_message_code_32768" />
-          <item type="string" name="wifi_eap_error_message_code_32769" />
           <item type="string" name="wifi_eap_error_message_code_16384" />
           <item type="string" name="wifi_eap_error_message_code_16385" />
           <item type="string" name="wifi_eap_error_message_unknown_error_code" />
diff --git a/service/art-profile b/service/art-profile
index 51aa211b75..0d857bedd7 100644
--- a/service/art-profile
+++ b/service/art-profile
@@ -1,5 +1,5 @@
 #
-# Copyright (C) 2024 The Android Open Source Project
+# Copyright (C) 2025 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -14,44 +14,18 @@
 # limitations under the License.
 #
 HSPLcom/android/server/wifi/ActiveModeWarden;->getClientModeManagerInRole(Lcom/android/server/wifi/ActiveModeManager$ClientRole;)Lcom/android/server/wifi/ConcreteClientModeManager;+]Lcom/android/server/wifi/ConcreteClientModeManager;Lcom/android/server/wifi/ConcreteClientModeManager;]Ljava/util/Iterator;Landroid/util/MapCollections$ArrayIterator;]Ljava/util/Set;Landroid/util/ArraySet;
-HSPLcom/android/server/wifi/ActiveModeWarden;->getPrimaryClientModeManager()Lcom/android/server/wifi/ClientModeManager;+]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;
-HSPLcom/android/server/wifi/ActiveModeWarden;->getPrimaryClientModeManagerNullable()Lcom/android/server/wifi/ConcreteClientModeManager;+]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;
-HSPLcom/android/server/wifi/ActiveModeWarden;->getWifiState()I
-HSPLcom/android/server/wifi/ActiveModeWarden;->updateCurrentConnectionInfo()V+]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;]Lcom/android/server/wifi/ClientMode;Lcom/android/server/wifi/ConcreteClientModeManager;
-HSPLcom/android/server/wifi/ClientModeImpl$ConnectableState;->getMessageLogRec(I)Ljava/lang/String;+]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;
-HSPLcom/android/server/wifi/ClientModeImpl$ConnectableState;->processMessageImpl(Landroid/os/Message;)Z+]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;]Landroid/net/wifi/WifiContext;Landroid/net/wifi/WifiContext;]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;]Lcom/android/server/wifi/ConcreteClientModeManager;Lcom/android/server/wifi/ConcreteClientModeManager;]Lcom/android/server/wifi/ExtendedWifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/InsecureEapNetworkHandler;Lcom/android/server/wifi/InsecureEapNetworkHandler;]Lcom/android/server/wifi/NetworkUpdateResult;Lcom/android/server/wifi/NetworkUpdateResult;]Lcom/android/server/wifi/WifiBlocklistMonitor;Lcom/android/server/wifi/WifiBlocklistMonitor;]Lcom/android/server/wifi/WifiConfigManager;Lcom/android/server/wifi/WifiConfigManager;]Lcom/android/server/wifi/WifiConnectivityManager;Lcom/android/server/wifi/WifiConnectivityManager;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;]Lcom/android/server/wifi/WifiHealthMonitor;Lcom/android/server/wifi/WifiHealthMonitor;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiNative;Lcom/android/server/wifi/WifiNative;]Lcom/android/server/wifi/WifiScoreCard;Lcom/android/server/wifi/WifiScoreCard;]Lcom/android/server/wifi/hotspot2/PasspointManager;Lcom/android/server/wifi/hotspot2/PasspointManager;]Lcom/android/server/wifi/util/ActionListenerWrapper;Lcom/android/server/wifi/util/ActionListenerWrapper;]Lcom/android/wifi/x/android/net/ip/IpClientManager;Lcom/android/wifi/x/android/net/ip/IpClientManager;]Lcom/android/wifi/x/com/android/internal/util/IState;Lcom/android/server/wifi/ClientModeImpl$DisconnectedState;,Lcom/android/server/wifi/ClientModeImpl$L2ConnectingState;,Lcom/android/server/wifi/ClientModeImpl$L3ConnectedState;,Lcom/android/server/wifi/ClientModeImpl$L3ProvisioningState;
-HPLcom/android/server/wifi/ClientModeImpl$ConnectingOrConnectedState;->getMessageLogRec(I)Ljava/lang/String;+]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;
 HPLcom/android/server/wifi/ClientModeImpl$L2ConnectedState;->getMessageLogRec(I)Ljava/lang/String;+]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;
-HPLcom/android/server/wifi/ClientModeImpl$L2ConnectedState;->processMessageImpl(Landroid/os/Message;)Z+]Landroid/net/wifi/WifiEnterpriseConfig;Landroid/net/wifi/WifiEnterpriseConfig;]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;]Lcom/android/server/wifi/ApplicationQosPolicyRequestHandler;Lcom/android/server/wifi/ApplicationQosPolicyRequestHandler;]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;]Lcom/android/server/wifi/ExtendedWifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/FrameworkFacade;Lcom/android/server/wifi/FrameworkFacade;]Lcom/android/server/wifi/MultiInternetManager;Lcom/android/server/wifi/MultiInternetManager;]Lcom/android/server/wifi/RssiMonitor;Lcom/android/server/wifi/RssiMonitor;]Lcom/android/server/wifi/ScanDetailCache;Lcom/android/server/wifi/ScanDetailCache;]Lcom/android/server/wifi/WifiCarrierInfoManager;Lcom/android/server/wifi/WifiCarrierInfoManager;]Lcom/android/server/wifi/WifiConfigManager;Lcom/android/server/wifi/WifiConfigManager;]Lcom/android/server/wifi/WifiDiagnostics;Lcom/android/server/wifi/WifiDiagnostics;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;]Lcom/android/server/wifi/WifiInjector;Lcom/android/server/wifi/WifiInjector;]Lcom/android/server/wifi/WifiLastResortWatchdog;Lcom/android/server/wifi/WifiLastResortWatchdog;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiNative;Lcom/android/server/wifi/WifiNative;]Lcom/android/server/wifi/WifiScoreCard;Lcom/android/server/wifi/WifiScoreCard;]Lcom/android/server/wifi/WifiTrafficPoller;Lcom/android/server/wifi/WifiTrafficPoller;]Lcom/android/wifi/x/android/net/ip/IpClientManager;Lcom/android/wifi/x/android/net/ip/IpClientManager;]Lcom/android/wifi/x/com/android/internal/util/StateMachine;Lcom/android/server/wifi/ClientModeImpl;
-HPLcom/android/server/wifi/ClientModeImpl$L2ConnectedState;->updateLinkLayerStatsRssiDataStallScoreReport()Lcom/android/server/wifi/WifiLinkLayerStats;+]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/FrameworkFacade;Lcom/android/server/wifi/FrameworkFacade;]Lcom/android/server/wifi/WifiCarrierInfoManager;Lcom/android/server/wifi/WifiCarrierInfoManager;]Lcom/android/server/wifi/WifiDataStall;Lcom/android/server/wifi/WifiDataStall;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;]Lcom/android/server/wifi/WifiInjector;Lcom/android/server/wifi/WifiInjector;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiScoreReport;Lcom/android/server/wifi/WifiScoreReport;]Lcom/android/wifi/x/android/net/ip/IpClientManager;Lcom/android/wifi/x/android/net/ip/IpClientManager;
+HPLcom/android/server/wifi/ClientModeImpl$L2ConnectedState;->updateLinkLayerStatsRssiDataStallScoreReport(Z)Lcom/android/server/wifi/WifiLinkLayerStats;+]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;]Lcom/android/server/wifi/FrameworkFacade;Lcom/android/server/wifi/FrameworkFacade;]Lcom/android/server/wifi/WifiCarrierInfoManager;Lcom/android/server/wifi/WifiCarrierInfoManager;]Lcom/android/server/wifi/WifiDataStall;Lcom/android/server/wifi/WifiDataStall;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;]Lcom/android/server/wifi/WifiInjector;Lcom/android/server/wifi/WifiInjector;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiScoreReport;Lcom/android/server/wifi/WifiScoreReport;]Lcom/android/wifi/x/android/net/ip/IpClientManager;Lcom/android/wifi/x/android/net/ip/IpClientManager;
 HPLcom/android/server/wifi/ClientModeImpl$L3ConnectedState;->getMessageLogRec(I)Ljava/lang/String;+]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;
-HPLcom/android/server/wifi/ClientModeImpl;->getCapabilities(Landroid/net/wifi/WifiConfiguration;Ljava/lang/String;)Landroid/net/NetworkCapabilities;+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/WifiNetworkFactory;Lcom/android/server/wifi/WifiNetworkFactory;
-HSPLcom/android/server/wifi/ClientModeImpl;->getConnectionInfo()Landroid/net/wifi/WifiInfo;
 HPLcom/android/server/wifi/ClientModeImpl;->getLogRecString(Landroid/os/Message;)Ljava/lang/String;+]Landroid/net/NetworkInfo;Landroid/net/NetworkInfo;]Landroid/net/wifi/WifiConfiguration$NetworkSelectionStatus;Landroid/net/wifi/WifiConfiguration$NetworkSelectionStatus;]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;]Lcom/android/server/wifi/FrameworkFacade;Lcom/android/server/wifi/FrameworkFacade;]Lcom/android/server/wifi/MboOceController$BtmFrameData;Lcom/android/server/wifi/MboOceController$BtmFrameData;]Lcom/android/server/wifi/NetworkUpdateResult;Lcom/android/server/wifi/NetworkUpdateResult;]Lcom/android/server/wifi/StateChangeResult;Lcom/android/server/wifi/StateChangeResult;]Lcom/android/server/wifi/SupplicantEventInfo;Lcom/android/server/wifi/SupplicantEventInfo;]Lcom/android/server/wifi/WifiConfigManager;Lcom/android/server/wifi/WifiConfigManager;
 HSPLcom/android/server/wifi/ClientModeImpl;->getTag()Ljava/lang/String;
 HPLcom/android/server/wifi/ClientModeImpl;->getWifiLinkLayerStats()Lcom/android/server/wifi/WifiLinkLayerStats;+]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/ExtendedWifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/FrameworkFacade;Lcom/android/server/wifi/FrameworkFacade;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiNative;Lcom/android/server/wifi/WifiNative;
-HSPLcom/android/server/wifi/ClientModeImpl;->isPrimary()Z+]Lcom/android/server/wifi/ConcreteClientModeManager;Lcom/android/server/wifi/ConcreteClientModeManager;
 HPLcom/android/server/wifi/ClientModeImpl;->logStateAndMessage(Landroid/os/Message;Lcom/android/wifi/x/com/android/internal/util/State;)V+]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;
-HSPLcom/android/server/wifi/ClientModeImpl;->logd(Ljava/lang/String;)V
-HPLcom/android/server/wifi/ClientModeImpl;->reportOnTime()Ljava/lang/String;+]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;
-HSPLcom/android/server/wifi/ClientModeImpl;->setSuspendOptimizationsNative(IZ)V
 HSPLcom/android/server/wifi/ClientModeImpl;->updateCurrentConnectionInfo()V+]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;]Lcom/android/server/wifi/WifiInjector;Lcom/android/server/wifi/WifiInjector;
-HPLcom/android/server/wifi/ClientModeImpl;->updateLinkBandwidth(Landroid/net/NetworkCapabilities$Builder;)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;]Lcom/android/server/wifi/WifiScoreCard;Lcom/android/server/wifi/WifiScoreCard;
-HPLcom/android/server/wifi/ClientModeImpl;->updateLinkBandwidthAndCapabilities(Lcom/android/server/wifi/WifiLinkLayerStats;ZJJ)V+]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/net/wifi/WifiContext;Landroid/net/wifi/WifiContext;]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;]Lcom/android/server/wifi/WifiDataStall;Lcom/android/server/wifi/WifiDataStall;]Lcom/android/server/wifi/WifiScoreCard;Lcom/android/server/wifi/WifiScoreCard;
-HPLcom/android/server/wifi/ClientModeImpl;->updateLinkLayerStatsRssiSpeedFrequencyCapabilities(JJ)Lcom/android/server/wifi/WifiLinkLayerStats;+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ClientModeImpl;Lcom/android/server/wifi/ClientModeImpl;]Lcom/android/server/wifi/ExtendedWifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/WifiConfigManager;Lcom/android/server/wifi/WifiConfigManager;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiNative;Lcom/android/server/wifi/WifiNative;]Lcom/android/server/wifi/WifiSignalPollResults;Lcom/android/server/wifi/WifiSignalPollResults;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;]Ljava/util/List;Ljava/util/ArrayList;
-HSPLcom/android/server/wifi/Clock;->getElapsedSinceBootMillis()J
-HSPLcom/android/server/wifi/Clock;->getWallClockMillis()J
-HSPLcom/android/server/wifi/ConcreteClientModeManager;->getConnectionInfo()Landroid/net/wifi/WifiInfo;+]Lcom/android/server/wifi/ClientMode;Lcom/android/server/wifi/ClientModeImpl;,Lcom/android/server/wifi/DefaultClientModeManager;,Lcom/android/server/wifi/ScanOnlyModeImpl;
-HSPLcom/android/server/wifi/ConcreteClientModeManager;->getRole()Lcom/android/server/wifi/ActiveModeManager$ClientRole;
-HSPLcom/android/server/wifi/ConfigurationMap;->getForCurrentUser(I)Landroid/net/wifi/WifiConfiguration;+]Ljava/util/Map;Ljava/util/HashMap;
 HPLcom/android/server/wifi/ExtendedWifiInfo;->updatePacketRates(Lcom/android/server/wifi/WifiLinkLayerStats;J)V
 HPLcom/android/server/wifi/ExtendedWifiInfo;->updateWifiInfoRates(IJJJJJ)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ExtendedWifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;
-HSPLcom/android/server/wifi/HalDeviceManager;->expandCreateTypeCombo(Lcom/android/server/wifi/hal/WifiChip$ChipConcurrencyCombination;)[[I+]Landroid/util/SparseIntArray;Lcom/android/server/wifi/HalDeviceManager$2;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;]Ljava/util/List;Ljava/util/ArrayList;
-HSPLcom/android/server/wifi/HalDeviceManager;->getAllChipInfo(Z)[Lcom/android/server/wifi/HalDeviceManager$WifiChipInfo;+]Lcom/android/server/wifi/HalDeviceManagerUtil$StaticChipInfo;Lcom/android/server/wifi/HalDeviceManagerUtil$StaticChipInfo;]Lcom/android/server/wifi/hal/WifiApIface;Lcom/android/server/wifi/hal/WifiApIface;]Lcom/android/server/wifi/hal/WifiChip$Response;Lcom/android/server/wifi/hal/WifiChip$Response;]Lcom/android/server/wifi/hal/WifiChip;Lcom/android/server/wifi/hal/WifiChip;]Lcom/android/server/wifi/hal/WifiHal;Lcom/android/server/wifi/hal/WifiHal;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;,Ljava/util/Arrays$ArrayItr;]Ljava/util/List;Ljava/util/ArrayList;,Ljava/util/Arrays$ArrayList;
-HPLcom/android/server/wifi/HalDeviceManager;->selectInterfacesToDelete(IILandroid/os/WorkSource;I[Lcom/android/server/wifi/HalDeviceManager$WifiIfaceInfo;)Ljava/util/List;+]Lcom/android/server/wifi/WifiInjector;Lcom/android/server/wifi/WifiInjector;]Lcom/android/server/wifi/util/WorkSourceHelper;Lcom/android/server/wifi/util/WorkSourceHelper;]Ljava/util/List;Ljava/util/ArrayList;]Ljava/util/Map;Ljava/util/HashMap;
 HSPLcom/android/server/wifi/LogcatLog$RealLogMessage;-><init>(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
 HSPLcom/android/server/wifi/LogcatLog$RealLogMessage;->c(J)Lcom/android/server/wifi/WifiLog$LogMessage;
-HSPLcom/android/server/wifi/LogcatLog$RealLogMessage;->c(Ljava/lang/String;)Lcom/android/server/wifi/WifiLog$LogMessage;
 HSPLcom/android/server/wifi/LogcatLog$RealLogMessage;->copyUntilPlaceholder()V
 HSPLcom/android/server/wifi/LogcatLog$RealLogMessage;->flush()V
 HSPLcom/android/server/wifi/LogcatLog;->info(Ljava/lang/String;)Lcom/android/server/wifi/WifiLog$LogMessage;
@@ -59,226 +33,63 @@ HSPLcom/android/server/wifi/RunnerHandler;->dispatchMessage(Landroid/os/Message;
 HSPLcom/android/server/wifi/RunnerHandler;->getSignature([Ljava/lang/StackTraceElement;Ljava/lang/Runnable;)Ljava/lang/String;+]Ljava/util/Set;Ljava/util/HashSet;
 HSPLcom/android/server/wifi/RunnerHandler;->sendMessageAtTime(Landroid/os/Message;J)Z
 HSPLcom/android/server/wifi/RunnerState;->processMessage(Landroid/os/Message;)Z+]Lcom/android/server/wifi/RunnerState;megamorphic_types
-HPLcom/android/server/wifi/ScanDetail;-><init>(Landroid/net/wifi/ScanResult;)V
 HPLcom/android/server/wifi/ScanDetail;-><init>(Lcom/android/server/wifi/hotspot2/NetworkDetail;Landroid/net/wifi/WifiSsid;Ljava/lang/String;Ljava/lang/String;IIJ[Landroid/net/wifi/ScanResult$InformationElement;Ljava/util/List;[B)V+]Lcom/android/server/wifi/hotspot2/NetworkDetail;Lcom/android/server/wifi/hotspot2/NetworkDetail;
-HPLcom/android/server/wifi/ScanDetail;->getNetworkDetail()Lcom/android/server/wifi/hotspot2/NetworkDetail;
-HPLcom/android/server/wifi/ScanDetail;->getScanResult()Landroid/net/wifi/ScanResult;
-HSPLcom/android/server/wifi/ScanResultMatchInfo;-><init>()V
-HSPLcom/android/server/wifi/ScanResultMatchInfo;->equals(Ljava/lang/Object;)Z+]Lcom/android/server/wifi/ScanResultMatchInfo;Lcom/android/server/wifi/ScanResultMatchInfo;]Ljava/lang/Object;Ljava/util/ArrayList;,Ljava/util/Collections$UnmodifiableRandomAccessList;
-HPLcom/android/server/wifi/ScanResultMatchInfo;->findBestMatchingSecurityParams(Ljava/util/List;Ljava/util/List;)Landroid/net/wifi/SecurityParams;+]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;,Ljava/util/Collections$UnmodifiableCollection$1;]Ljava/util/List;Ljava/util/ArrayList;,Ljava/util/Collections$UnmodifiableRandomAccessList;
-HPLcom/android/server/wifi/ScanResultMatchInfo;->fromScanResult(Landroid/net/wifi/ScanResult;)Lcom/android/server/wifi/ScanResultMatchInfo;
-HPLcom/android/server/wifi/ScoringParams;->getRssiArray(I)[I
-HPLcom/android/server/wifi/SupplicantStaIfaceHalAidlImpl;->getSignalPollResults(Ljava/lang/String;)Lcom/android/server/wifi/WifiSignalPollResults;+]Lcom/android/server/wifi/SupplicantStaIfaceHalAidlImpl;Lcom/android/server/wifi/SupplicantStaIfaceHalAidlImpl;]Lcom/android/server/wifi/WifiInjector;Lcom/android/server/wifi/WifiInjector;]Lcom/android/wifi/x/android/hardware/wifi/supplicant/ISupplicantStaIface;Lcom/android/wifi/x/android/hardware/wifi/supplicant/ISupplicantStaIface$Stub$Proxy;
-HSPLcom/android/server/wifi/SupplicantStaIfaceHalAidlImpl;->getStaIface(Ljava/lang/String;)Lcom/android/wifi/x/android/hardware/wifi/supplicant/ISupplicantStaIface;+]Ljava/util/Map;Ljava/util/HashMap;
-HPLcom/android/server/wifi/ThroughputPredictor;->calculateAirTimeFraction(II)I
-HPLcom/android/server/wifi/ThroughputPredictor;->getValidChannelUtilization(IIIZ)I
 HPLcom/android/server/wifi/ThroughputPredictor;->predictThroughputInternal(IZIIIII[B)I+]Landroid/content/Context;Landroid/net/wifi/WifiContext;]Landroid/content/res/Resources;Landroid/content/res/Resources;
-HPLcom/android/server/wifi/ThroughputScorer;->scoreCandidate(Lcom/android/server/wifi/WifiCandidates$Candidate;Z)Lcom/android/server/wifi/WifiCandidates$ScoredCandidate;+]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/net/wifi/WifiContext;Landroid/net/wifi/WifiContext;]Lcom/android/server/wifi/ScoringParams;Lcom/android/server/wifi/ScoringParams;]Lcom/android/server/wifi/WifiCandidates$Candidate;Lcom/android/server/wifi/WifiCandidates$CandidateImpl;
-HPLcom/android/server/wifi/VelocityBasedConnectedScore;->generateScore()I+]Lcom/android/server/wifi/ConnectedScore;Lcom/android/server/wifi/VelocityBasedConnectedScore;]Lcom/android/server/wifi/ScoringParams;Lcom/android/server/wifi/ScoringParams;]Lcom/android/server/wifi/VelocityBasedConnectedScore;Lcom/android/server/wifi/VelocityBasedConnectedScore;]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/VelocityBasedConnectedScore;->setDeltaTimeSeconds(D)V+]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/VelocityBasedConnectedScore;->updateUsingRssi(IJD)V+]Lcom/android/server/wifi/util/KalmanFilter;Lcom/android/server/wifi/util/KalmanFilter;]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/WifiApConfigStore;->sanitizePersistentApConfig(Landroid/net/wifi/SoftApConfiguration;)Landroid/net/wifi/SoftApConfiguration;+]Landroid/util/SparseIntArray;Landroid/util/SparseIntArray;
 HPLcom/android/server/wifi/WifiChannelUtilization;->calculateChannelUtilization(Lcom/android/server/wifi/WifiLinkLayerStats$ChannelStats;)V+]Landroid/util/SparseIntArray;Landroid/util/SparseIntArray;
-HPLcom/android/server/wifi/WifiChannelUtilization;->findChanStatsReference(II)Lcom/android/server/wifi/WifiLinkLayerStats$ChannelStats;+]Landroid/util/SparseArray;Landroid/util/SparseArray;]Ljava/util/ArrayDeque;Ljava/util/ArrayDeque;]Ljava/util/Iterator;Ljava/util/ArrayDeque$DeqIterator;
-HPLcom/android/server/wifi/WifiChannelUtilization;->getUtilizationRatio(I)I+]Landroid/content/Context;Landroid/net/wifi/WifiContext;]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/util/SparseIntArray;Landroid/util/SparseIntArray;
-HPLcom/android/server/wifi/WifiChannelUtilization;->refreshChannelStatsAndChannelUtilization(Lcom/android/server/wifi/WifiLinkLayerStats;I)V+]Landroid/content/Context;Landroid/net/wifi/WifiContext;]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/util/SparseArray;Landroid/util/SparseArray;
-HPLcom/android/server/wifi/WifiChannelUtilization;->updateChannelStatsCache(Landroid/util/SparseArray;I)V+]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Ljava/util/ArrayDeque;Ljava/util/ArrayDeque;
-HSPLcom/android/server/wifi/WifiConfigManager;->createExternalWifiConfiguration(Landroid/net/wifi/WifiConfiguration;ZI)Landroid/net/wifi/WifiConfiguration;
-HSPLcom/android/server/wifi/WifiConfigManager;->getConfiguredNetworks(ZZI)Ljava/util/List;+]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;]Ljava/util/Collection;Ljava/util/HashMap$Values;]Ljava/util/Iterator;Ljava/util/HashMap$ValueIterator;
-HPLcom/android/server/wifi/WifiConfigManager;->getInternalConfiguredNetwork(I)Landroid/net/wifi/WifiConfiguration;+]Lcom/android/server/wifi/ConfigurationMap;Lcom/android/server/wifi/ConfigurationMap;
-HPLcom/android/server/wifi/WifiConfigManager;->getSavedNetworkForScanResult(Landroid/net/wifi/ScanResult;)Landroid/net/wifi/WifiConfiguration;+]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;]Lcom/android/server/wifi/ConfigurationMap;Lcom/android/server/wifi/ConfigurationMap;
-HPLcom/android/server/wifi/WifiConfigManager;->getScanDetailCacheForNetwork(I)Lcom/android/server/wifi/ScanDetailCache;+]Ljava/util/Map;Ljava/util/HashMap;
 HSPLcom/android/server/wifi/WifiConfigManager;->maskPasswordsInWifiConfiguration(Landroid/net/wifi/WifiConfiguration;)V+]Landroid/net/wifi/WifiEnterpriseConfig;Landroid/net/wifi/WifiEnterpriseConfig;
-HPLcom/android/server/wifi/WifiConfigManager;->updateScanDetailCacheFromWifiInfo(Landroid/net/wifi/WifiInfo;)V+]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ScanDetail;Lcom/android/server/wifi/ScanDetail;]Lcom/android/server/wifi/ScanDetailCache;Lcom/android/server/wifi/ScanDetailCache;]Lcom/android/server/wifi/WifiConfigManager;Lcom/android/server/wifi/WifiConfigManager;
-HPLcom/android/server/wifi/WifiConnectivityManager$AllSingleScanListener;->onFullResult(Landroid/net/wifi/ScanResult;)V+]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/net/wifi/WifiContext;Landroid/net/wifi/WifiContext;]Ljava/util/List;Ljava/util/ArrayList;
-HPLcom/android/server/wifi/WifiConnectivityManager;->handleScanResults(Ljava/util/List;Ljava/lang/String;ZLcom/android/server/wifi/WifiConnectivityManager$HandleScanResultsListener;)V+]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/net/wifi/WifiConfiguration$NetworkSelectionStatus;Landroid/net/wifi/WifiConfiguration$NetworkSelectionStatus;]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;]Landroid/net/wifi/WifiContext;Landroid/net/wifi/WifiContext;]Landroid/net/wifi/WifiInfo;Landroid/net/wifi/WifiInfo;]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;]Lcom/android/server/wifi/ClientMode;Lcom/android/server/wifi/ConcreteClientModeManager;]Lcom/android/server/wifi/ClientModeManager;Lcom/android/server/wifi/ConcreteClientModeManager;]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/DppManager;Lcom/android/server/wifi/DppManager;]Lcom/android/server/wifi/WifiBlocklistMonitor;Lcom/android/server/wifi/WifiBlocklistMonitor;]Lcom/android/server/wifi/WifiChannelUtilization;Lcom/android/server/wifi/WifiChannelUtilization;]Lcom/android/server/wifi/WifiConfigManager;Lcom/android/server/wifi/WifiConfigManager;]Lcom/android/server/wifi/WifiConnectivityManager;Lcom/android/server/wifi/WifiConnectivityManager;]Lcom/android/server/wifi/WifiCountryCode;Lcom/android/server/wifi/WifiCountryCode;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;]Lcom/android/server/wifi/WifiInjector;Lcom/android/server/wifi/WifiInjector;]Lcom/android/server/wifi/WifiLastResortWatchdog;Lcom/android/server/wifi/WifiLastResortWatchdog;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiNetworkSelector;Lcom/android/server/wifi/WifiNetworkSelector;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;]Ljava/util/List;Ljava/util/ArrayList;
-HSPLcom/android/server/wifi/WifiConnectivityManager;->startConnectivityScan(Z)V
 HPLcom/android/server/wifi/WifiDataStall;->checkDataStallAndThroughputSufficiency(Ljava/lang/String;Lcom/android/server/wifi/WifiNative$ConnectionCapabilities;Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/server/wifi/WifiLinkLayerStats;Landroid/net/wifi/WifiInfo;JJ)I+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/DeviceConfigFacade;Lcom/android/server/wifi/DeviceConfigFacade;]Lcom/android/server/wifi/ThroughputPredictor;Lcom/android/server/wifi/ThroughputPredictor;]Lcom/android/server/wifi/WifiChannelUtilization;Lcom/android/server/wifi/WifiChannelUtilization;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;
-HPLcom/android/server/wifi/WifiDataStall;->getRxThroughputKbps()I
-HPLcom/android/server/wifi/WifiDataStall;->getThrouhgputPredictorSpeeds(Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/WifiNative$ConnectionCapabilities;)Lcom/android/server/wifi/WifiDataStall$Speeds;+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ThroughputPredictor;Lcom/android/server/wifi/ThroughputPredictor;]Lcom/android/server/wifi/WifiChannelUtilization;Lcom/android/server/wifi/WifiChannelUtilization;
-HPLcom/android/server/wifi/WifiDataStall;->getTxThroughputKbps()I
-HPLcom/android/server/wifi/WifiDataStall;->isL2ThroughputSufficient(IIZ)Z+]Lcom/android/server/wifi/DeviceConfigFacade;Lcom/android/server/wifi/DeviceConfigFacade;
-HPLcom/android/server/wifi/WifiDataStall;->isThroughputSufficientInternal(IIZZIJJ)Z
-HSPLcom/android/server/wifi/WifiInjector;->getActiveModeWarden()Lcom/android/server/wifi/ActiveModeWarden;
 HPLcom/android/server/wifi/WifiLinkLayerStats;->aggregateLinkLayerStats()V
 HPLcom/android/server/wifi/WifiLinkLayerStats;->aggregatePacketStats()V
 HPLcom/android/server/wifi/WifiLinkLayerStats;->aggregatePeerStats()V
 HPLcom/android/server/wifi/WifiLinkLayerStats;->clearAggregatedPacketStats()V
-HPLcom/android/server/wifi/WifiMetrics;->convertContentionTimeStats(Lcom/android/server/wifi/WifiLinkLayerStats$LinkSpecificStats;)[Landroid/net/wifi/WifiUsabilityStatsEntry$ContentionTimeStats;
-HPLcom/android/server/wifi/WifiMetrics;->convertLinkStats(Lcom/android/server/wifi/WifiLinkLayerStats;Landroid/net/wifi/WifiInfo;)Landroid/util/SparseArray;+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Landroid/util/SparseArray;Landroid/util/SparseArray;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;]Ljava/util/List;Ljava/util/ArrayList;
-HPLcom/android/server/wifi/WifiMetrics;->convertRateStats(Lcom/android/server/wifi/WifiLinkLayerStats$LinkSpecificStats;)[Landroid/net/wifi/WifiUsabilityStatsEntry$RateStats;
-HPLcom/android/server/wifi/WifiMetrics;->countScanResults(Ljava/util/List;)V+]Lcom/android/server/wifi/ScanDetail;Lcom/android/server/wifi/ScanDetail;]Lcom/android/server/wifi/hotspot2/NetworkDetail;Lcom/android/server/wifi/hotspot2/NetworkDetail;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;]Ljava/util/List;Ljava/util/ArrayList;
-HPLcom/android/server/wifi/WifiMetrics;->createNewContentionTimeStatsParcelable([Landroid/net/wifi/WifiUsabilityStatsEntry$ContentionTimeStats;[Lcom/android/server/wifi/proto/nano/WifiMetricsProto$ContentionTimeStats;)V
-HPLcom/android/server/wifi/WifiMetrics;->createNewRadioStatsParcelable([Landroid/net/wifi/WifiUsabilityStatsEntry$RadioStats;[Lcom/android/server/wifi/proto/nano/WifiMetricsProto$RadioStats;)V
-HPLcom/android/server/wifi/WifiMetrics;->createNewRateStatsParcelable([Landroid/net/wifi/WifiUsabilityStatsEntry$RateStats;[Lcom/android/server/wifi/proto/nano/WifiMetricsProto$RateStats;)V
-HPLcom/android/server/wifi/WifiMetrics;->createNewWifiUsabilityStatsEntryParcelable(Lcom/android/server/wifi/proto/nano/WifiMetricsProto$WifiUsabilityStatsEntry;Lcom/android/server/wifi/WifiLinkLayerStats;Landroid/net/wifi/WifiInfo;)Landroid/net/wifi/WifiUsabilityStatsEntry;
-HPLcom/android/server/wifi/WifiMetrics;->getNetworkCapabilitiesSpeeds()Lcom/android/server/wifi/WifiMetrics$Speeds;+]Landroid/net/ConnectivityManager;Landroid/net/ConnectivityManager;]Lcom/android/server/wifi/WifiMetrics$ConnectivityManagerCache;Lcom/android/server/wifi/WifiMetrics$ConnectivityManagerCache;
-HPLcom/android/server/wifi/WifiMetrics;->handlePollResult(Ljava/lang/String;Landroid/net/wifi/WifiInfo;)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/WifiMetrics$WifiStatusBuilder;Lcom/android/server/wifi/WifiMetrics$WifiStatusBuilder;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;
-HPLcom/android/server/wifi/WifiMetrics;->incrementAvailableNetworksHistograms(Ljava/util/List;Z)V+]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;]Lcom/android/server/wifi/ScanDetail;Lcom/android/server/wifi/ScanDetail;]Lcom/android/server/wifi/WifiConfigManager;Lcom/android/server/wifi/WifiConfigManager;]Lcom/android/server/wifi/WifiNetworkSelector;Lcom/android/server/wifi/WifiNetworkSelector;]Lcom/android/server/wifi/hotspot2/NetworkDetail;Lcom/android/server/wifi/hotspot2/NetworkDetail;]Lcom/android/server/wifi/hotspot2/PasspointManager;Lcom/android/server/wifi/hotspot2/PasspointManager;]Ljava/util/Collection;Ljava/util/HashMap$Values;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;,Ljava/util/HashMap$ValueIterator;]Ljava/util/List;Ljava/util/ArrayList;
-HPLcom/android/server/wifi/WifiMetrics;->incrementConnectionDuration(Ljava/lang/String;IZZIII)V+]Lcom/android/server/wifi/WifiMetrics$ConnectionDurationStats;Lcom/android/server/wifi/WifiMetrics$ConnectionDurationStats;]Ljava/util/Map;Landroid/util/ArrayMap;
-HPLcom/android/server/wifi/WifiMetrics;->incrementLinkSpeedCount(II)V+]Landroid/content/Context;Landroid/net/wifi/WifiContext;]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/util/SparseArray;Landroid/util/SparseArray;
 HPLcom/android/server/wifi/WifiMetrics;->incrementPerRadioUsageStats(Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/server/wifi/WifiLinkLayerStats;)V+]Landroid/util/SparseArray;Landroid/util/SparseArray;
-HPLcom/android/server/wifi/WifiMetrics;->incrementRssiPollRssiCount(II)V+]Landroid/util/SparseIntArray;Landroid/util/SparseIntArray;]Ljava/util/Map;Ljava/util/HashMap;
-HPLcom/android/server/wifi/WifiMetrics;->incrementRxLinkSpeedBandCount(II)V+]Landroid/content/Context;Landroid/net/wifi/WifiContext;]Landroid/content/res/Resources;Landroid/content/res/Resources;]Lcom/android/server/wifi/util/IntCounter;Lcom/android/server/wifi/util/IntCounter;
-HPLcom/android/server/wifi/WifiMetrics;->incrementThroughputKbpsCount(III)V+]Lcom/android/server/wifi/WifiMetrics$WifiStatusBuilder;Lcom/android/server/wifi/WifiMetrics$WifiStatusBuilder;]Lcom/android/server/wifi/util/IntHistogram;Lcom/android/server/wifi/util/IntHistogram;
-HPLcom/android/server/wifi/WifiMetrics;->incrementTxLinkSpeedBandCount(II)V+]Landroid/content/Context;Landroid/net/wifi/WifiContext;]Landroid/content/res/Resources;Landroid/content/res/Resources;]Lcom/android/server/wifi/util/IntCounter;Lcom/android/server/wifi/util/IntCounter;
 HPLcom/android/server/wifi/WifiMetrics;->incrementWifiLinkLayerUsageStats(Ljava/lang/String;Lcom/android/server/wifi/WifiLinkLayerStats;)V
-HPLcom/android/server/wifi/WifiMetrics;->incrementWifiScoreCount(Ljava/lang/String;I)V+]Landroid/util/SparseIntArray;Landroid/util/SparseIntArray;]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;
 HPLcom/android/server/wifi/WifiMetrics;->newLinkLayerStatsIsValid(Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/server/wifi/WifiLinkLayerStats;)Z
-HPLcom/android/server/wifi/WifiMetrics;->sendWifiUsabilityStats(IZLandroid/net/wifi/WifiUsabilityStatsEntry;)V+]Landroid/net/wifi/IOnWifiUsabilityStatsListener;Landroid/net/wifi/IOnWifiUsabilityStatsListener$Stub$Proxy;]Landroid/os/RemoteCallbackList;Landroid/os/RemoteCallbackList;
-HPLcom/android/server/wifi/WifiMetrics;->updateWifiIsUnusableLinkLayerStats(JJJJJ)V+]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;
-HPLcom/android/server/wifi/WifiMetrics;->updateWifiUsabilityStatsEntries(Ljava/lang/String;Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/WifiLinkLayerStats;)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Landroid/util/SparseArray;Landroid/util/SparseArray;]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/WifiChannelUtilization;Lcom/android/server/wifi/WifiChannelUtilization;]Lcom/android/server/wifi/WifiDataStall;Lcom/android/server/wifi/WifiDataStall;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiSettingsStore;Lcom/android/server/wifi/WifiSettingsStore;]Ljava/util/LinkedList;Ljava/util/LinkedList;]Ljava/util/Map;Landroid/util/ArrayMap;
+HPLcom/android/server/wifi/WifiMetrics;->updateWifiUsabilityStatsEntries(Ljava/lang/String;Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/WifiLinkLayerStats;ZI)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Landroid/util/SparseArray;Landroid/util/SparseArray;]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/WifiChannelUtilization;Lcom/android/server/wifi/WifiChannelUtilization;]Lcom/android/server/wifi/WifiDataStall;Lcom/android/server/wifi/WifiDataStall;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiSettingsStore;Lcom/android/server/wifi/WifiSettingsStore;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;]Ljava/util/LinkedList;Ljava/util/LinkedList;]Ljava/util/List;Ljava/util/ArrayList;]Ljava/util/Map;Landroid/util/ArrayMap;
+HSPLcom/android/server/wifi/WifiMulticastLockManager;->uidIsLockOwner(I)Z+]Ljava/util/Map;Ljava/util/HashMap;
 HSPLcom/android/server/wifi/WifiNative$IfaceManager;->getIface(Ljava/lang/String;)Lcom/android/server/wifi/WifiNative$Iface;+]Ljava/util/Collection;Ljava/util/HashMap$Values;]Ljava/util/HashMap;Ljava/util/HashMap;]Ljava/util/Iterator;Ljava/util/HashMap$ValueIterator;
 HPLcom/android/server/wifi/WifiNative;->convertNativeScanResults(Ljava/lang/String;Ljava/util/List;)Ljava/util/ArrayList;+]Lcom/android/server/wifi/SsidTranslator;Lcom/android/server/wifi/SsidTranslator;]Lcom/android/server/wifi/WifiInjector;Lcom/android/server/wifi/WifiInjector;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;,Ljava/util/Arrays$ArrayItr;]Ljava/util/List;Ljava/util/ArrayList;,Ljava/util/Arrays$ArrayList;
-HSPLcom/android/server/wifi/WifiNative;->getCompleteFeatureSetFromConfigStore()Ljava/util/BitSet;
-HPLcom/android/server/wifi/WifiNative;->getWifiLinkLayerStats(Ljava/lang/String;)Lcom/android/server/wifi/WifiLinkLayerStats;+]Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/server/wifi/WifiLinkLayerStats;]Lcom/android/server/wifi/WifiNative;Lcom/android/server/wifi/WifiNative;]Lcom/android/server/wifi/WifiVendorHal;Lcom/android/server/wifi/WifiVendorHal;
-HPLcom/android/server/wifi/WifiNetworkFactory;->acceptRequest(Landroid/net/NetworkRequest;)Z+]Landroid/net/NetworkRequest;Landroid/net/NetworkRequest;]Lcom/android/server/wifi/FrameworkFacade;Lcom/android/server/wifi/FrameworkFacade;]Lcom/android/server/wifi/MultiInternetManager;Lcom/android/server/wifi/MultiInternetManager;]Lcom/android/server/wifi/WifiNetworkFactory;Lcom/android/server/wifi/WifiNetworkFactory;]Lcom/android/server/wifi/util/WifiPermissionsUtil;Lcom/android/server/wifi/util/WifiPermissionsUtil;
-HPLcom/android/server/wifi/WifiNetworkSelector;->selectNetwork(Ljava/util/List;Z)Landroid/net/wifi/WifiConfiguration;+]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/WifiCandidates$CandidateScorer;Lcom/android/server/wifi/BubbleFunScorer;,Lcom/android/server/wifi/CompatibilityScorer;,Lcom/android/server/wifi/ScoreCardBasedScorer;,Lcom/android/server/wifi/ThroughputScorer;]Lcom/android/server/wifi/WifiConfigManager;Lcom/android/server/wifi/WifiConfigManager;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Ljava/lang/Object;Lcom/android/server/wifi/WifiCandidates$CandidateImpl;]Ljava/util/Collection;Landroid/util/MapCollections$ValuesCollection;,Ljava/util/ArrayList;]Ljava/util/Iterator;Landroid/util/MapCollections$ArrayIterator;,Landroid/util/MapCollections$MapIterator;,Ljava/util/ArrayList$Itr;]Ljava/util/List;Ljava/util/ArrayList;]Ljava/util/Map$Entry;Landroid/util/MapCollections$MapIterator;]Ljava/util/Map;Landroid/util/ArrayMap;]Ljava/util/Set;Landroid/util/MapCollections$EntrySet;]Ljava/util/stream/Stream;Ljava/util/stream/ReferencePipeline$Head;,Ljava/util/stream/SortedOps$OfRef;
-HPLcom/android/server/wifi/WifiNetworkSuggestionsManager;->getNetworkSuggestionsForScanResultMatchInfo(Lcom/android/server/wifi/ScanResultMatchInfo;Landroid/net/MacAddress;)Ljava/util/Set;+]Ljava/util/Map;Ljava/util/HashMap;
-HPLcom/android/server/wifi/WifiScoreCard$MemoryStoreAccessBase;->finishPendingReadBytes()[B
-HPLcom/android/server/wifi/WifiScoreCard$PerBssid;->lookupSignal(Lcom/android/server/wifi/proto/WifiScoreCardProto$Event;I)Lcom/android/server/wifi/WifiScoreCard$PerSignal;+]Ljava/util/Map;Landroid/util/ArrayMap;
-HPLcom/android/server/wifi/WifiScoreCard$PerBssid;->updateEventStats(Lcom/android/server/wifi/proto/WifiScoreCardProto$Event;IIILjava/lang/String;)V+]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;
-HPLcom/android/server/wifi/WifiScoreCard$PerNetwork;->getAvgUsedLinkBandwidthKbps(I)I+]Lcom/android/server/wifi/WifiScoreCard;Lcom/android/server/wifi/WifiScoreCard;
-HPLcom/android/server/wifi/WifiScoreCard$PerNetwork;->getByteDeltaAccThr(I)I+]Lcom/android/server/wifi/DeviceConfigFacade;Lcom/android/server/wifi/DeviceConfigFacade;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;
-HPLcom/android/server/wifi/WifiScoreCard$PerNetwork;->updateBandwidthWithFilterApplied(ILcom/android/server/wifi/ExtendedWifiInfo;)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/DeviceConfigFacade;Lcom/android/server/wifi/DeviceConfigFacade;
-HPLcom/android/server/wifi/WifiScoreCard$PerNetwork;->updateEventStats(Lcom/android/server/wifi/proto/WifiScoreCardProto$Event;IIILcom/android/server/wifi/WifiScoreCard$IfaceInfo;)V+]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/DeviceConfigFacade;Lcom/android/server/wifi/DeviceConfigFacade;]Lcom/android/server/wifi/WifiScoreCard$NetworkConnectionStats;Lcom/android/server/wifi/WifiScoreCard$NetworkConnectionStats;
-HPLcom/android/server/wifi/WifiScoreCard$PerNetwork;->updateLinkBandwidth(Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/server/wifi/ExtendedWifiInfo;JJ)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;
-HPLcom/android/server/wifi/WifiScoreCard$PerNetwork;->updateLinkBandwidthTxRxSample(Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/server/wifi/ExtendedWifiInfo;JJ)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;
-HPLcom/android/server/wifi/WifiScoreCard$PerNetwork;->updateWifiInfo(Lcom/android/server/wifi/ExtendedWifiInfo;)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;
-HPLcom/android/server/wifi/WifiScoreCard$PerSignal;->toSignal()Lcom/android/server/wifi/proto/WifiScoreCardProto$Signal;+]Lcom/android/server/wifi/util/IntHistogram;Lcom/android/server/wifi/util/IntHistogram;
+HSPLcom/android/server/wifi/WifiNative;->getSupportedFeatureSet(Ljava/lang/String;)Ljava/util/BitSet;+]Ljava/util/BitSet;Ljava/util/BitSet;
+HPLcom/android/server/wifi/WifiNative;->getWifiLinkLayerStats(Ljava/lang/String;)Lcom/android/server/wifi/WifiLinkLayerStats;+]Landroid/net/wifi/WifiScanner$ScanData;Landroid/net/wifi/WifiScanner$ScanData;]Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/server/wifi/WifiLinkLayerStats;]Lcom/android/server/wifi/WifiNative;Lcom/android/server/wifi/WifiNative;]Lcom/android/server/wifi/WifiVendorHal;Lcom/android/server/wifi/WifiVendorHal;
 HPLcom/android/server/wifi/WifiScoreCard$PerUnivariateStatistic;->toUnivariateStatistic()Lcom/android/server/wifi/proto/WifiScoreCardProto$UnivariateStatistic;+]Lcom/android/server/wifi/util/IntHistogram;Lcom/android/server/wifi/util/IntHistogram;]Ljava/util/Iterator;Lcom/android/server/wifi/util/IntHistogram$1;
-HPLcom/android/server/wifi/WifiScoreCard$PerUnivariateStatistic;->update(D)V+]Lcom/android/server/wifi/util/IntHistogram;Lcom/android/server/wifi/util/IntHistogram;
-HPLcom/android/server/wifi/WifiScoreCard;->geTxLinkSpeedWithSufficientTxRate(Lcom/android/server/wifi/ExtendedWifiInfo;)I+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;
-HPLcom/android/server/wifi/WifiScoreCard;->lookupBssid(Ljava/lang/String;Ljava/lang/String;)Lcom/android/server/wifi/WifiScoreCard$PerBssid;+]Ljava/util/Map;Landroid/util/ArrayMap;
-HPLcom/android/server/wifi/WifiScoreCard;->lookupNetwork(Ljava/lang/String;)Lcom/android/server/wifi/WifiScoreCard$PerNetwork;+]Lcom/android/server/wifi/WifiScoreCard;Lcom/android/server/wifi/WifiScoreCard;]Ljava/util/Map;Landroid/util/ArrayMap;
-HPLcom/android/server/wifi/WifiScoreCard;->noteSignalPoll(Lcom/android/server/wifi/ExtendedWifiInfo;)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ExtendedWifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;
-HPLcom/android/server/wifi/WifiScoreCard;->updatePerBssid(Lcom/android/server/wifi/proto/WifiScoreCardProto$Event;Lcom/android/server/wifi/ExtendedWifiInfo;)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ExtendedWifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/WifiScoreCard;Lcom/android/server/wifi/WifiScoreCard;
-HPLcom/android/server/wifi/WifiScoreCard;->updatePerNetwork(Lcom/android/server/wifi/proto/WifiScoreCardProto$Event;Ljava/lang/String;IIILcom/android/server/wifi/WifiScoreCard$IfaceInfo;)V+]Lcom/android/server/wifi/WifiScoreCard;Lcom/android/server/wifi/WifiScoreCard;
-HPLcom/android/server/wifi/WifiScoreReport$ScoreUpdateObserverProxy;->notifyScoreUpdate(II)V+]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;
-HPLcom/android/server/wifi/WifiScoreReport$ScoreUpdateObserverProxy;->notifyStatusUpdate(IZ)V+]Landroid/content/Context;Landroid/net/wifi/WifiContext;]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/net/NetworkAgent;Lcom/android/server/wifi/WifiNetworkAgent;]Lcom/android/server/wifi/AdaptiveConnectivityEnabledSettingObserver;Lcom/android/server/wifi/AdaptiveConnectivityEnabledSettingObserver;]Lcom/android/server/wifi/ExtendedWifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/WifiConnectivityManager;Lcom/android/server/wifi/WifiConnectivityManager;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiSettingsStore;Lcom/android/server/wifi/WifiSettingsStore;
-HPLcom/android/server/wifi/WifiScoreReport;->calculateAndReportScore()V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/ScoringParams;Lcom/android/server/wifi/ScoringParams;]Lcom/android/server/wifi/VelocityBasedConnectedScore;Lcom/android/server/wifi/VelocityBasedConnectedScore;]Lcom/android/server/wifi/WifiConnectivityManager;Lcom/android/server/wifi/WifiConnectivityManager;]Lcom/android/server/wifi/WifiGlobals;Lcom/android/server/wifi/WifiGlobals;
-HPLcom/android/server/wifi/WifiScoreReport;->getScoreBuilder()Landroid/net/NetworkScore$Builder;
-HPLcom/android/server/wifi/WifiScoreReport;->logLinkMetrics(JIIII)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/VelocityBasedConnectedScore;Lcom/android/server/wifi/VelocityBasedConnectedScore;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/WifiScoreCard;Lcom/android/server/wifi/WifiScoreCard;]Ljava/util/Calendar;Ljava/util/GregorianCalendar;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;]Ljava/util/LinkedList;Ljava/util/LinkedList;]Ljava/util/List;Ljava/util/ArrayList;
-HPLcom/android/server/wifi/WifiScoreReport;->shouldCheckIpLayer()Z+]Lcom/android/server/wifi/AdaptiveConnectivityEnabledSettingObserver;Lcom/android/server/wifi/AdaptiveConnectivityEnabledSettingObserver;]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;]Lcom/android/server/wifi/ScoringParams;Lcom/android/server/wifi/ScoringParams;]Lcom/android/server/wifi/WifiSettingsStore;Lcom/android/server/wifi/WifiSettingsStore;
-HPLcom/android/server/wifi/WifiScoreReport;->updateWifiMetrics(JI)V+]Landroid/net/wifi/WifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/AggressiveConnectedScore;Lcom/android/server/wifi/AggressiveConnectedScore;]Lcom/android/server/wifi/ConnectedScore;Lcom/android/server/wifi/AggressiveConnectedScore;]Lcom/android/server/wifi/ExtendedWifiInfo;Lcom/android/server/wifi/ExtendedWifiInfo;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;
-HSPLcom/android/server/wifi/WifiServiceImpl;->enforceAccessPermission()V+]Landroid/net/wifi/WifiContext;Landroid/net/wifi/WifiContext;
-HPLcom/android/server/wifi/WifiServiceImpl;->getConnectionInfo(Ljava/lang/String;Ljava/lang/String;)Landroid/net/wifi/WifiInfo;+]Landroid/net/wifi/WifiInfo;Landroid/net/wifi/WifiInfo;]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;]Lcom/android/server/wifi/WifiLog$LogMessage;Lcom/android/server/wifi/LogcatLog$RealLogMessage;]Lcom/android/server/wifi/WifiLog;Lcom/android/server/wifi/LogcatLog;]Lcom/android/server/wifi/WifiThreadRunner;Lcom/android/server/wifi/WifiThreadRunner;]Lcom/android/server/wifi/util/WifiPermissionsUtil;Lcom/android/server/wifi/util/WifiPermissionsUtil;
-HPLcom/android/server/wifi/WifiServiceImpl;->getSoftApConfiguration()Landroid/net/wifi/SoftApConfiguration;+]Lcom/android/server/wifi/WifiApConfigStore;Lcom/android/server/wifi/WifiApConfigStore;]Lcom/android/server/wifi/WifiLog$LogMessage;Lcom/android/server/wifi/LogcatLog$RealLogMessage;]Lcom/android/server/wifi/WifiLog;Lcom/android/server/wifi/LogcatLog;]Lcom/android/server/wifi/util/WifiPermissionsUtil;Lcom/android/server/wifi/util/WifiPermissionsUtil;
+HSPLcom/android/server/wifi/WifiServiceImpl;->getConnectionInfo(Ljava/lang/String;Ljava/lang/String;)Landroid/net/wifi/WifiInfo;+]Landroid/net/wifi/WifiInfo;Landroid/net/wifi/WifiInfo;]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;]Lcom/android/server/wifi/WifiLog$LogMessage;Lcom/android/server/wifi/LogcatLog$RealLogMessage;]Lcom/android/server/wifi/WifiLog;Lcom/android/server/wifi/LogcatLog;]Lcom/android/server/wifi/WifiThreadRunner;Lcom/android/server/wifi/WifiThreadRunner;]Lcom/android/server/wifi/util/WifiPermissionsUtil;Lcom/android/server/wifi/util/WifiPermissionsUtil;
 HSPLcom/android/server/wifi/WifiServiceImpl;->getWifiActivityEnergyInfo()Landroid/os/connectivity/WifiActivityEnergyInfo;+]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;]Lcom/android/server/wifi/ClientMode;Lcom/android/server/wifi/ConcreteClientModeManager;,Lcom/android/server/wifi/DefaultClientModeManager;]Lcom/android/server/wifi/Clock;Lcom/android/server/wifi/Clock;
-HSPLcom/android/server/wifi/WifiServiceImpl;->getWifiActivityEnergyInfoAsync(Landroid/net/wifi/IOnWifiActivityEnergyInfoListener;)V+]Lcom/android/server/wifi/WifiLog$LogMessage;Lcom/android/server/wifi/LogcatLog$RealLogMessage;]Lcom/android/server/wifi/WifiLog;Lcom/android/server/wifi/LogcatLog;]Lcom/android/server/wifi/WifiServiceImpl;Lcom/android/server/wifi/WifiServiceImpl;]Lcom/android/server/wifi/WifiThreadRunner;Lcom/android/server/wifi/WifiThreadRunner;]Ljava/util/BitSet;Ljava/util/BitSet;
+HSPLcom/android/server/wifi/WifiServiceImpl;->getWifiActivityEnergyInfoAsync(Landroid/net/wifi/IOnWifiActivityEnergyInfoListener;)V+]Lcom/android/server/wifi/WifiLog$LogMessage;Lcom/android/server/wifi/LogcatLog$RealLogMessage;]Lcom/android/server/wifi/WifiLog;Lcom/android/server/wifi/LogcatLog;]Lcom/android/server/wifi/WifiServiceImpl;Lcom/android/server/wifi/WifiServiceImpl;]Lcom/android/server/wifi/WifiThreadRunner;Lcom/android/server/wifi/WifiThreadRunner;
 HSPLcom/android/server/wifi/WifiServiceImpl;->getWifiEnabledState()I+]Lcom/android/server/wifi/ActiveModeWarden;Lcom/android/server/wifi/ActiveModeWarden;]Lcom/android/server/wifi/WifiLog$LogMessage;Lcom/android/server/wifi/LogcatLog$RealLogMessage;]Lcom/android/server/wifi/WifiLog;Lcom/android/server/wifi/LogcatLog;
-HPLcom/android/server/wifi/WifiServiceImpl;->updateWifiUsabilityScore(III)V+]Landroid/net/wifi/WifiContext;Landroid/net/wifi/WifiContext;]Lcom/android/server/wifi/WifiLog$LogMessage;Lcom/android/server/wifi/LogcatLog$RealLogMessage;]Lcom/android/server/wifi/WifiLog;Lcom/android/server/wifi/LogcatLog;]Lcom/android/server/wifi/WifiThreadRunner;Lcom/android/server/wifi/WifiThreadRunner;
-HSPLcom/android/server/wifi/WifiSettingsConfigStore;->get(Lcom/android/server/wifi/WifiSettingsConfigStore$Key;)Ljava/lang/Object;+]Ljava/util/Map;Ljava/util/HashMap;
-HPLcom/android/server/wifi/WifiSettingsStore;->getPersistedWifiScoringEnabled()Z+]Lcom/android/server/wifi/WifiSettingsConfigStore;Lcom/android/server/wifi/WifiSettingsConfigStore;
-HPLcom/android/server/wifi/WifiSignalPollResults;-><init>()V
-HPLcom/android/server/wifi/WifiSignalPollResults;->addEntry(IIIII)V+]Ljava/util/Map;Ljava/util/HashMap;
-HPLcom/android/server/wifi/WifiSignalPollResults;->getFrequency()I+]Ljava/util/Map;Ljava/util/HashMap;
-HPLcom/android/server/wifi/WifiSignalPollResults;->getRssi()I+]Ljava/util/Map;Ljava/util/HashMap;
-HPLcom/android/server/wifi/WifiSignalPollResults;->getRxLinkSpeed()I+]Ljava/util/Map;Ljava/util/HashMap;
-HPLcom/android/server/wifi/WifiSignalPollResults;->getTxLinkSpeed()I+]Ljava/util/Map;Ljava/util/HashMap;
+HSPLcom/android/server/wifi/WifiServiceImpl;->isFeatureSupported(I)Z+]Lcom/android/server/wifi/WifiLog$LogMessage;Lcom/android/server/wifi/LogcatLog$RealLogMessage;]Lcom/android/server/wifi/WifiLog;Lcom/android/server/wifi/LogcatLog;]Ljava/util/BitSet;Ljava/util/BitSet;
 HSPLcom/android/server/wifi/WifiThreadRunner;->post(Ljava/lang/Runnable;Ljava/lang/String;)Z
-HPLcom/android/server/wifi/WifiTrafficPoller;->notifyOnDataActivity(JJ)V+]Landroid/content/Context;Landroid/net/wifi/WifiContext;]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/net/wifi/ITrafficStateCallback;Landroid/net/wifi/ITrafficStateCallback$Stub$Proxy;]Landroid/os/RemoteCallbackList;Landroid/os/RemoteCallbackList;]Landroid/util/SparseBooleanArray;Landroid/util/SparseBooleanArray;]Ljava/lang/Object;Landroid/net/wifi/ITrafficStateCallback$Stub$Proxy;
 HSPLcom/android/server/wifi/WifiVendorHal;->getStaIface(Ljava/lang/String;)Lcom/android/server/wifi/hal/WifiStaIface;+]Ljava/util/HashMap;Ljava/util/HashMap;
-HPLcom/android/server/wifi/WifiVendorHal;->getWifiLinkLayerStats(Ljava/lang/String;)Lcom/android/server/wifi/WifiLinkLayerStats;+]Lcom/android/server/wifi/hal/WifiStaIface;Lcom/android/server/wifi/hal/WifiStaIface;
-HPLcom/android/server/wifi/coex/CoexManager;->updateCoexUnsafeChannels(Ljava/util/List;)V+]Landroid/content/Context;Landroid/net/wifi/WifiContext;]Landroid/content/res/Resources;Landroid/content/res/Resources;]Landroid/util/SparseArray;Landroid/util/SparseArray;]Landroid/util/SparseBooleanArray;Landroid/util/SparseBooleanArray;]Lcom/android/server/wifi/coex/CoexManager;Lcom/android/server/wifi/coex/CoexManager;]Lcom/android/server/wifi/coex/CoexUtils$CoexCellChannel;Lcom/android/server/wifi/coex/CoexUtils$CoexCellChannel;]Lcom/android/server/wifi/coex/Entry;Lcom/android/server/wifi/coex/Entry;]Lcom/android/server/wifi/coex/HarmonicParams;Lcom/android/server/wifi/coex/HarmonicParams;]Lcom/android/server/wifi/coex/IntermodParams;Lcom/android/server/wifi/coex/IntermodParams;]Lcom/android/server/wifi/coex/NeighborThresholds;Lcom/android/server/wifi/coex/NeighborThresholds;]Lcom/android/server/wifi/coex/Params;Lcom/android/server/wifi/coex/Params;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;,Ljava/util/TreeMap$KeyIterator;]Ljava/util/List;Ljava/util/ArrayList;]Ljava/util/NavigableSet;Ljava/util/TreeSet;
-HPLcom/android/server/wifi/hal/WifiStaIface;->getLinkLayerStats()Lcom/android/server/wifi/WifiLinkLayerStats;
-HSPLcom/android/server/wifi/hal/WifiStaIface;->validateAndCall(Ljava/lang/String;Ljava/lang/Object;Ljava/util/function/Supplier;)Ljava/lang/Object;+]Ljava/util/function/Supplier;megamorphic_types
 HPLcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;->aggregateFrameworkRadioStatsFromAidl(ILcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerRadioStats;)V+]Landroid/util/SparseArray;Landroid/util/SparseArray;
+HPLcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;->getCachedScanData()Landroid/net/wifi/WifiScanner$ScanData;+]Lcom/android/wifi/x/android/hardware/wifi/IWifiStaIface;Lcom/android/wifi/x/android/hardware/wifi/IWifiStaIface$Stub$Proxy;
 HPLcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;->getLinkLayerStats()Lcom/android/server/wifi/WifiLinkLayerStats;+]Lcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;Lcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;]Lcom/android/wifi/x/android/hardware/wifi/IWifiStaIface;Lcom/android/wifi/x/android/hardware/wifi/IWifiStaIface$Stub$Proxy;
 HPLcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;->halToFrameworkLinkLayerStats(Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerStats;)Lcom/android/server/wifi/WifiLinkLayerStats;
 HPLcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;->setFrameworkPerRadioStatsFromAidl(Lcom/android/server/wifi/WifiLinkLayerStats$RadioStat;Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerRadioStats;)V+]Landroid/util/SparseArray;Landroid/util/SparseArray;
-HPLcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;->setIfaceStats(Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfaceStats;)V
 HPLcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;->setIfaceStatsPerLinkFromAidl(Lcom/android/server/wifi/WifiLinkLayerStats;Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerLinkStats;I)V
 HPLcom/android/server/wifi/hal/WifiStaIfaceAidlImpl;->setRadioStats(Lcom/android/server/wifi/WifiLinkLayerStats;[Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerRadioStats;)V
 HPLcom/android/server/wifi/hotspot2/NetworkDetail;-><init>(Ljava/lang/String;[Landroid/net/wifi/ScanResult$InformationElement;Ljava/util/List;I)V+]Ljava/nio/CharBuffer;Ljava/nio/HeapCharBuffer;]Ljava/nio/charset/Charset;Lcom/android/icu/charset/CharsetICU;]Ljava/util/ArrayList;Ljava/util/ArrayList;]Ljava/util/List;Ljava/util/ArrayList;,Ljava/util/Collections$EmptyList;
-HPLcom/android/server/wifi/hotspot2/Utils;->fromHex(CZ)I
-HPLcom/android/server/wifi/hotspot2/Utils;->parseMac(Ljava/lang/String;)J
-HPLcom/android/server/wifi/proto/WifiScoreCardProto$HistogramBucket;->dynamicMethod(Lcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite$MethodToInvoke;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
-HSPLcom/android/server/wifi/proto/WifiStatsLog;->write(IIILjava/lang/String;)V
-HPLcom/android/server/wifi/proto/WifiStatsLog;->write(IIZZIIIIIZI)V
-HPLcom/android/server/wifi/proto/WifiStatsLog;->write(I[I[Ljava/lang/String;IIZIIIIIII)V
-HPLcom/android/server/wifi/proto/nano/WifiMetricsProto$ContentionTimeStats;->clear()Lcom/android/server/wifi/proto/nano/WifiMetricsProto$ContentionTimeStats;
-HPLcom/android/server/wifi/proto/nano/WifiMetricsProto$RadioStats;->clear()Lcom/android/server/wifi/proto/nano/WifiMetricsProto$RadioStats;
 HPLcom/android/server/wifi/proto/nano/WifiMetricsProto$RateStats;->clear()Lcom/android/server/wifi/proto/nano/WifiMetricsProto$RateStats;
 HPLcom/android/server/wifi/proto/nano/WifiMetricsProto$WifiUsabilityStatsEntry;->clear()Lcom/android/server/wifi/proto/nano/WifiMetricsProto$WifiUsabilityStatsEntry;
-HSPLcom/android/server/wifi/scanner/WifiScanningServiceImpl$ClientInfo;->toString()Ljava/lang/String;
-HSPLcom/android/server/wifi/scanner/WifiScanningServiceImpl$WifiSingleScanStateMachine;->tryToStartNewScan()V+]Lcom/android/server/wifi/WifiMetrics$ScanMetrics;Lcom/android/server/wifi/WifiMetrics$ScanMetrics;]Lcom/android/server/wifi/WifiMetrics;Lcom/android/server/wifi/WifiMetrics;]Lcom/android/server/wifi/scanner/ChannelHelper$ChannelCollection;Lcom/android/server/wifi/scanner/KnownBandsChannelHelper$KnownBandsChannelCollection;]Lcom/android/server/wifi/scanner/ChannelHelper;Lcom/android/server/wifi/scanner/WificondChannelHelper;]Lcom/android/server/wifi/scanner/WifiScanningServiceImpl$WifiSingleScanStateMachine;Lcom/android/server/wifi/scanner/WifiScanningServiceImpl$WifiSingleScanStateMachine;]Ljava/util/ArrayList;Lcom/android/server/wifi/scanner/WifiScanningServiceImpl$RequestList;]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;]Ljava/util/List;Ljava/util/ArrayList;
-HPLcom/android/server/wifi/scanner/WifiScanningServiceImpl;->describeTo(Ljava/lang/StringBuilder;Landroid/net/wifi/WifiScanner$ScanSettings;)Ljava/lang/String;+]Landroid/net/wifi/WifiScanner$ScanSettings;Landroid/net/wifi/WifiScanner$ScanSettings;
-HSPLcom/android/server/wifi/util/ApConfigUtil;->isSoftApBandSupported(Landroid/net/wifi/WifiContext;I)Z+]Landroid/net/wifi/WifiContext;Landroid/net/wifi/WifiContext;]Landroid/net/wifi/util/WifiResourceCache;Landroid/net/wifi/util/WifiResourceCache;
-HPLcom/android/server/wifi/util/InformationElementUtil$BssLoad;->from(Landroid/net/wifi/ScanResult$InformationElement;)V+]Ljava/nio/ByteBuffer;Ljava/nio/HeapByteBuffer;
+HSPLcom/android/server/wifi/util/FeatureBitsetUtils;->formatSupportedFeatures(Ljava/util/BitSet;)Ljava/lang/String;+]Landroid/util/SparseArray;Lcom/android/server/wifi/util/FeatureBitsetUtils$1;]Ljava/util/BitSet;Ljava/util/BitSet;
 HPLcom/android/server/wifi/util/InformationElementUtil$Capabilities;->from([Landroid/net/wifi/ScanResult$InformationElement;IZZILandroid/util/SparseIntArray;)V+]Ljava/util/List;Ljava/util/ArrayList;
-HPLcom/android/server/wifi/util/InformationElementUtil$Capabilities;->generateCapabilitiesString()Ljava/lang/String;+]Ljava/util/List;Ljava/util/ArrayList;
 HPLcom/android/server/wifi/util/InformationElementUtil$Capabilities;->generateCapabilitiesStringPerProtocol(I)Ljava/lang/String;+]Ljava/util/List;Ljava/util/ArrayList;
 HPLcom/android/server/wifi/util/InformationElementUtil$Capabilities;->generateWPA2CapabilitiesString(Ljava/lang/String;I)Ljava/lang/String;+]Ljava/util/List;Ljava/util/ArrayList;
-HPLcom/android/server/wifi/util/InformationElementUtil$Capabilities;->isWpsElement(Landroid/net/wifi/ScanResult$InformationElement;)Z+]Ljava/nio/ByteBuffer;Ljava/nio/HeapByteBuffer;
 HPLcom/android/server/wifi/util/InformationElementUtil$Capabilities;->parseRsnElement(Ljava/nio/ByteBuffer;Landroid/util/SparseIntArray;)V+]Ljava/nio/ByteBuffer;Ljava/nio/HeapByteBuffer;]Ljava/util/List;Ljava/util/ArrayList;
 HPLcom/android/server/wifi/util/InformationElementUtil$Country;->from(Landroid/net/wifi/ScanResult$InformationElement;)V+]Ljava/nio/ByteBuffer;Ljava/nio/HeapByteBuffer;
-HPLcom/android/server/wifi/util/InformationElementUtil$EhtCapabilities$EhtMacCapabilitiesInformation;-><init>()V
-HPLcom/android/server/wifi/util/InformationElementUtil$HeCapabilities$HeMacCapabilitiesInformation;-><init>()V
-HPLcom/android/server/wifi/util/InformationElementUtil$HeCapabilities$HeMacCapabilitiesInformation;->from([B)V+]Ljava/util/BitSet;Ljava/util/BitSet;
-HPLcom/android/server/wifi/util/InformationElementUtil$HeCapabilities;->from(Landroid/net/wifi/ScanResult$InformationElement;)V+]Lcom/android/server/wifi/util/InformationElementUtil$HeCapabilities$HeMacCapabilitiesInformation;Lcom/android/server/wifi/util/InformationElementUtil$HeCapabilities$HeMacCapabilitiesInformation;
-HPLcom/android/server/wifi/util/InformationElementUtil$HeOperation;->from(Landroid/net/wifi/ScanResult$InformationElement;)V
-HPLcom/android/server/wifi/util/InformationElementUtil$HtCapabilities;->from(Landroid/net/wifi/ScanResult$InformationElement;)V
-HPLcom/android/server/wifi/util/InformationElementUtil$HtOperation;->from(Landroid/net/wifi/ScanResult$InformationElement;)V
 HPLcom/android/server/wifi/util/InformationElementUtil$SupportedRates;->from(Landroid/net/wifi/ScanResult$InformationElement;)V+]Ljava/nio/ByteBuffer;Ljava/nio/HeapByteBuffer;]Ljava/util/ArrayList;Ljava/util/ArrayList;
-HPLcom/android/server/wifi/util/InformationElementUtil$TrafficIndicationMap;->from(Landroid/net/wifi/ScanResult$InformationElement;)V+]Ljava/nio/ByteBuffer;Ljava/nio/HeapByteBuffer;
-HPLcom/android/server/wifi/util/InformationElementUtil$VhtCapabilities;->from(Landroid/net/wifi/ScanResult$InformationElement;)V
-HPLcom/android/server/wifi/util/InformationElementUtil$VhtOperation;->from(Landroid/net/wifi/ScanResult$InformationElement;)V
-HPLcom/android/server/wifi/util/InformationElementUtil$Vsa;-><init>()V
-HPLcom/android/server/wifi/util/InformationElementUtil$Vsa;->from(Landroid/net/wifi/ScanResult$InformationElement;)V
 HPLcom/android/server/wifi/util/InformationElementUtil;->parseInformationElements([B)[Landroid/net/wifi/ScanResult$InformationElement;+]Ljava/nio/ByteBuffer;Ljava/nio/HeapByteBuffer;
-HPLcom/android/server/wifi/util/IntCounter;->add(II)V+]Landroid/util/SparseIntArray;Lcom/android/server/wifi/util/IntCounter;
-HPLcom/android/server/wifi/util/IntHistogram;->add(II)V+]Landroid/util/SparseIntArray;Landroid/util/SparseIntArray;
-HPLcom/android/server/wifi/util/KalmanFilter;->predict()V+]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/KalmanFilter;->update(Lcom/android/server/wifi/util/Matrix;)V+]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/Matrix;-><init>(Lcom/android/server/wifi/util/Matrix;)V
-HPLcom/android/server/wifi/util/Matrix;->dot(Lcom/android/server/wifi/util/Matrix;)Lcom/android/server/wifi/util/Matrix;+]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/Matrix;->dot(Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;)Lcom/android/server/wifi/util/Matrix;+]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/Matrix;->dotTranspose(Lcom/android/server/wifi/util/Matrix;)Lcom/android/server/wifi/util/Matrix;+]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/Matrix;->dotTranspose(Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;)Lcom/android/server/wifi/util/Matrix;+]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/Matrix;->get(II)D
-HPLcom/android/server/wifi/util/Matrix;->inverse()Lcom/android/server/wifi/util/Matrix;+]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/Matrix;->inverse(Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;)Lcom/android/server/wifi/util/Matrix;+]Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/Matrix;->minus(Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;)Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/Matrix;->plus(Lcom/android/server/wifi/util/Matrix;Lcom/android/server/wifi/util/Matrix;)Lcom/android/server/wifi/util/Matrix;
-HPLcom/android/server/wifi/util/Matrix;->put(IID)V
-HPLcom/android/server/wifi/util/StringUtil;->calendarToString(Ljava/util/Calendar;)Ljava/lang/String;+]Ljava/util/Calendar;Ljava/util/GregorianCalendar;
-HPLcom/android/server/wifi/util/StringUtil;->doubleToString(DI)Ljava/lang/String;
-HPLcom/android/server/wifi/util/WifiPermissionsUtil;->checkCallersLocationPermission(Ljava/lang/String;Ljava/lang/String;IZLjava/lang/String;)Z+]Lcom/android/server/wifi/util/WifiPermissionsUtil;Lcom/android/server/wifi/util/WifiPermissionsUtil;]Lcom/android/server/wifi/util/WifiPermissionsWrapper;Lcom/android/server/wifi/util/WifiPermissionsWrapper;
-HSPLcom/android/server/wifi/util/WifiPermissionsUtil;->checkNetworkSettingsPermission(I)Z+]Lcom/android/server/wifi/util/WifiPermissionsWrapper;Lcom/android/server/wifi/util/WifiPermissionsWrapper;
-HSPLcom/android/server/wifi/util/WifiPermissionsUtil;->createPackageContextAsUser(I)Landroid/content/Context;+]Landroid/content/Context;Landroid/net/wifi/WifiContext;
-HPLcom/android/server/wifi/util/WifiPermissionsUtil;->enforceCanAccessScanResults(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;)V+]Lcom/android/server/wifi/util/WifiPermissionsUtil;Lcom/android/server/wifi/util/WifiPermissionsUtil;]Lcom/android/server/wifi/util/WifiPermissionsWrapper;Lcom/android/server/wifi/util/WifiPermissionsWrapper;
-HSPLcom/android/server/wifi/util/WifiPermissionsUtil;->isLocationModeEnabled()Z+]Landroid/location/LocationManager;Landroid/location/LocationManager;]Lcom/android/server/wifi/util/WifiPermissionsWrapper;Lcom/android/server/wifi/util/WifiPermissionsWrapper;
-HSPLcom/android/server/wifi/util/WifiPermissionsWrapper;->getUidPermission(Ljava/lang/String;II)I+]Landroid/content/Context;Landroid/net/wifi/WifiContext;
-HSPLcom/android/server/wifi/util/XmlUtil$WifiConfigurationXmlUtil;->parseFromXml(Lorg/xmlpull/v1/XmlPullParser;IZLcom/android/server/wifi/util/WifiConfigStoreEncryptionUtil;Z)Landroid/util/Pair;+]Lorg/xmlpull/v1/XmlPullParser;Lcom/android/org/kxml2/io/KXmlParser;
-HPLcom/android/server/wifi/util/XmlUtil$WifiConfigurationXmlUtil;->writeCommonElementsToXml(Lorg/xmlpull/v1/XmlSerializer;Landroid/net/wifi/WifiConfiguration;Lcom/android/server/wifi/util/WifiConfigStoreEncryptionUtil;)V+]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;]Ljava/util/BitSet;Ljava/util/BitSet;
-HPLcom/android/server/wifi/util/XmlUtil$WifiConfigurationXmlUtil;->writeSecurityParamsListToXml(Lorg/xmlpull/v1/XmlSerializer;Landroid/net/wifi/WifiConfiguration;)V+]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;]Ljava/util/BitSet;Ljava/util/BitSet;]Ljava/util/Iterator;Ljava/util/Collections$UnmodifiableCollection$1;]Ljava/util/List;Ljava/util/Collections$UnmodifiableRandomAccessList;
-HPLcom/android/server/wifi/util/XmlUtil$WifiConfigurationXmlUtil;->writeToXmlForConfigStore(Lorg/xmlpull/v1/XmlSerializer;Landroid/net/wifi/WifiConfiguration;Lcom/android/server/wifi/util/WifiConfigStoreEncryptionUtil;)V+]Landroid/net/wifi/WifiConfiguration;Landroid/net/wifi/WifiConfiguration;
-HSPLcom/android/server/wifi/util/XmlUtilHelper;->readThisPrimitiveValueXml(Lorg/xmlpull/v1/XmlPullParser;Ljava/lang/String;)Ljava/lang/Object;+]Lorg/xmlpull/v1/XmlPullParser;Lcom/android/org/kxml2/io/KXmlParser;
 HSPLcom/android/server/wifi/util/XmlUtilHelper;->readThisValueXml(Lorg/xmlpull/v1/XmlPullParser;[Ljava/lang/String;Lcom/android/server/wifi/util/XmlUtilHelper$ReadMapCallback;Z)Ljava/lang/Object;+]Lorg/xmlpull/v1/XmlPullParser;Lcom/android/org/kxml2/io/KXmlParser;
-HPLcom/android/server/wifi/util/XmlUtilHelper;->writeByteArrayXml([BLjava/lang/String;Lorg/xmlpull/v1/XmlSerializer;)V+]Lorg/xmlpull/v1/XmlSerializer;Lcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;
 HPLcom/android/server/wifi/util/XmlUtilHelper;->writeValueXml(Ljava/lang/Object;Ljava/lang/String;Lorg/xmlpull/v1/XmlSerializer;Lcom/android/server/wifi/util/XmlUtilHelper$WriteMapCallback;)V+]Ljava/lang/Object;Ljava/lang/Boolean;,Ljava/lang/Float;,Ljava/lang/Integer;,Ljava/lang/Long;]Lorg/xmlpull/v1/XmlSerializer;Lcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;
+HPLcom/android/wifi/x/android/hardware/wifi/IWifiStaIface$Stub$Proxy;->getCachedScanData()Lcom/android/wifi/x/android/hardware/wifi/CachedScanData;+]Landroid/os/IBinder;Landroid/os/BinderProxy;
 HPLcom/android/wifi/x/android/hardware/wifi/IWifiStaIface$Stub$Proxy;->getLinkLayerStats()Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerStats;+]Landroid/os/IBinder;Landroid/os/BinderProxy;
-HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfaceContentionTimeStats$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfaceContentionTimeStats;
-HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfaceContentionTimeStats;-><init>()V
 HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfaceContentionTimeStats;->readFromParcel(Landroid/os/Parcel;)V
-HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfacePacketStats$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfacePacketStats;
-HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfacePacketStats;-><init>()V
 HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfacePacketStats;->readFromParcel(Landroid/os/Parcel;)V
-HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfaceStats$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfaceStats;
 HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerIfaceStats;->readFromParcel(Landroid/os/Parcel;)V
-HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerLinkStats$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerLinkStats;
 HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerLinkStats;-><init>()V
 HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerLinkStats;->readFromParcel(Landroid/os/Parcel;)V
-HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerRadioStats$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerRadioStats;
 HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerRadioStats;-><init>()V
 HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerRadioStats;->readFromParcel(Landroid/os/Parcel;)V
-HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerStats$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/StaLinkLayerStats;
 HPLcom/android/wifi/x/android/hardware/wifi/StaLinkLayerStats;->readFromParcel(Landroid/os/Parcel;)V
-HPLcom/android/wifi/x/android/hardware/wifi/StaPeerInfo$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/StaPeerInfo;
 HPLcom/android/wifi/x/android/hardware/wifi/StaPeerInfo;->readFromParcel(Landroid/os/Parcel;)V
-HPLcom/android/wifi/x/android/hardware/wifi/StaRateStat$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/StaRateStat;
-HPLcom/android/wifi/x/android/hardware/wifi/StaRateStat$1;->createFromParcel(Landroid/os/Parcel;)Ljava/lang/Object;+]Lcom/android/wifi/x/android/hardware/wifi/StaRateStat$1;Lcom/android/wifi/x/android/hardware/wifi/StaRateStat$1;
 HPLcom/android/wifi/x/android/hardware/wifi/StaRateStat;-><init>()V
 HPLcom/android/wifi/x/android/hardware/wifi/StaRateStat;->readFromParcel(Landroid/os/Parcel;)V
 HPLcom/android/wifi/x/android/hardware/wifi/WifiChannelInfo$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/WifiChannelInfo;
@@ -287,38 +98,65 @@ HPLcom/android/wifi/x/android/hardware/wifi/WifiChannelInfo;->readFromParcel(Lan
 HPLcom/android/wifi/x/android/hardware/wifi/WifiChannelStats$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/WifiChannelStats;
 HPLcom/android/wifi/x/android/hardware/wifi/WifiChannelStats$1;->createFromParcel(Landroid/os/Parcel;)Ljava/lang/Object;+]Lcom/android/wifi/x/android/hardware/wifi/WifiChannelStats$1;Lcom/android/wifi/x/android/hardware/wifi/WifiChannelStats$1;
 HPLcom/android/wifi/x/android/hardware/wifi/WifiChannelStats;->readFromParcel(Landroid/os/Parcel;)V
-HPLcom/android/wifi/x/android/hardware/wifi/WifiRateInfo$1;->createFromParcel(Landroid/os/Parcel;)Lcom/android/wifi/x/android/hardware/wifi/WifiRateInfo;
-HPLcom/android/wifi/x/android/hardware/wifi/WifiRateInfo$1;->createFromParcel(Landroid/os/Parcel;)Ljava/lang/Object;+]Lcom/android/wifi/x/android/hardware/wifi/WifiRateInfo$1;Lcom/android/wifi/x/android/hardware/wifi/WifiRateInfo$1;
 HPLcom/android/wifi/x/android/hardware/wifi/WifiRateInfo;-><init>()V
 HPLcom/android/wifi/x/android/hardware/wifi/WifiRateInfo;->readFromParcel(Landroid/os/Parcel;)V
-HPLcom/android/wifi/x/android/hardware/wifi/supplicant/ISupplicantStaIface$Stub$Proxy;->getSignalPollResults()[Lcom/android/wifi/x/android/hardware/wifi/supplicant/SignalPollResult;+]Landroid/os/IBinder;Landroid/os/BinderProxy;
-HPLcom/android/wifi/x/android/hardware/wifi/supplicant/SignalPollResult;->readFromParcel(Landroid/os/Parcel;)V
 HSPLcom/android/wifi/x/android/net/INetdUnsolicitedEventListener$Stub;->onTransact(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z+]Lcom/android/wifi/x/android/net/INetdUnsolicitedEventListener;Lcom/android/server/wifi/util/NetdWrapper$NetdUnsolicitedEventListener;
 HPLcom/android/wifi/x/android/net/NetworkFactoryImpl;->handleAddRequest(Landroid/net/NetworkRequest;)V+]Lcom/android/wifi/x/android/net/NetworkFactory;megamorphic_types]Ljava/util/Map;Ljava/util/LinkedHashMap;
 HSPLcom/android/wifi/x/android/util/LocalLog;->append(Ljava/lang/String;)V+]Ljava/util/Deque;Ljava/util/ArrayDeque;
 HSPLcom/android/wifi/x/android/util/LocalLog;->log(Ljava/lang/String;)V
-HPLcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;->append(C)V+]Lcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;Lcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;
-HPLcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;->append(Ljava/lang/String;)V
 HPLcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;->append(Ljava/lang/String;II)V+]Lcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;Lcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;
-HPLcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;->attribute(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/xmlpull/v1/XmlSerializer;
-HPLcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;->endTag(Ljava/lang/String;Ljava/lang/String;)Lorg/xmlpull/v1/XmlSerializer;
 HPLcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;->escapeAndAppendString(Ljava/lang/String;)V
-HPLcom/android/wifi/x/com/android/internal/util/FastXmlSerializer;->startTag(Ljava/lang/String;Ljava/lang/String;)Lorg/xmlpull/v1/XmlSerializer;
-HPLcom/android/wifi/x/com/google/protobuf/CodedOutputStream$ArrayEncoder;->writeMessage(ILcom/android/wifi/x/com/google/protobuf/MessageLite;Lcom/android/wifi/x/com/google/protobuf/Schema;)V+]Lcom/android/wifi/x/com/google/protobuf/AbstractMessageLite;megamorphic_types]Lcom/android/wifi/x/com/google/protobuf/Schema;Lcom/android/wifi/x/com/google/protobuf/MessageSchema;
-HPLcom/android/wifi/x/com/google/protobuf/CodedOutputStream$ArrayEncoder;->writeUInt32NoTag(I)V
-HPLcom/android/wifi/x/com/google/protobuf/CodedOutputStream$ArrayEncoder;->writeUInt64NoTag(J)V
-HPLcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite$Builder;-><init>(Lcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;)V+]Lcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;megamorphic_types
-HPLcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite$Builder;->buildPartial()Lcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;+]Lcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;megamorphic_types
-HPLcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;-><init>()V
-HPLcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;->isInitialized(Lcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;Z)Z+]Lcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;megamorphic_types
-HPLcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;->isMutable()Z
-HPLcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;->setMemoizedSerializedSize(I)V
 HPLcom/android/wifi/x/com/google/protobuf/MessageSchema;->getSerializedSizeProto2(Ljava/lang/Object;)I
-HPLcom/android/wifi/x/com/google/protobuf/MessageSchema;->isMutable(Ljava/lang/Object;)Z+]Lcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;megamorphic_types
 HPLcom/android/wifi/x/com/google/protobuf/MessageSchema;->makeImmutable(Ljava/lang/Object;)V+]Lcom/android/wifi/x/com/google/protobuf/GeneratedMessageLite;megamorphic_types]Lcom/android/wifi/x/com/google/protobuf/ListFieldSchema;Lcom/android/wifi/x/com/google/protobuf/ListFieldSchema$ListFieldSchemaLite;]Lcom/android/wifi/x/com/google/protobuf/Schema;Lcom/android/wifi/x/com/google/protobuf/MessageSchema;]Lcom/android/wifi/x/com/google/protobuf/UnknownFieldSchema;Lcom/android/wifi/x/com/google/protobuf/UnknownFieldSetLiteSchema;
-HPLcom/android/wifi/x/com/google/protobuf/MessageSchema;->parseProto2Message(Ljava/lang/Object;[BIIILcom/android/wifi/x/com/google/protobuf/ArrayDecoders$Registers;)I+]Lcom/android/wifi/x/com/google/protobuf/Internal$EnumVerifier;Lcom/android/server/wifi/proto/WifiScoreCardProto$Event$EventVerifier;,Lcom/android/server/wifi/proto/WifiScoreCardProto$SecurityType$SecurityTypeVerifier;]Lcom/android/wifi/x/com/google/protobuf/Internal$ProtobufList;Lcom/android/wifi/x/com/google/protobuf/ProtobufArrayList;]Ljava/util/List;Lcom/android/wifi/x/com/google/protobuf/ProtobufArrayList;
 HPLcom/android/wifi/x/com/google/protobuf/MessageSchema;->writeFieldsInAscendingOrderProto2(Ljava/lang/Object;Lcom/android/wifi/x/com/google/protobuf/Writer;)V+]Lcom/android/wifi/x/com/google/protobuf/Writer;Lcom/android/wifi/x/com/google/protobuf/CodedOutputStreamWriter;
-HPLcom/android/wifi/x/com/google/protobuf/Protobuf;->schemaFor(Ljava/lang/Class;)Lcom/android/wifi/x/com/google/protobuf/Schema;+]Lcom/android/wifi/x/com/google/protobuf/SchemaFactory;Lcom/android/wifi/x/com/google/protobuf/ManifestSchemaFactory;]Ljava/util/concurrent/ConcurrentMap;Ljava/util/concurrent/ConcurrentHashMap;
 HPLcom/android/wifi/x/com/google/protobuf/ProtobufArrayList;->add(Ljava/lang/Object;)Z
-HPLcom/android/wifi/x/com/google/protobuf/UnknownFieldSetLiteSchema;->getFromMessage(Ljava/lang/Object;)Lcom/android/wifi/x/com/google/protobuf/UnknownFieldSetLite;
-HPLcom/android/wifi/x/com/google/protobuf/UnknownFieldSetLiteSchema;->makeImmutable(Ljava/lang/Object;)V+]Lcom/android/wifi/x/com/google/protobuf/UnknownFieldSetLiteSchema;Lcom/android/wifi/x/com/google/protobuf/UnknownFieldSetLiteSchema;
+HSPLcom/android/wifi/x/com/google/protobuf/nano/MessageNano;-><init>()V
+Landroid/app/ApplicationPackageManager;
+Landroid/app/ContextImpl;
+Landroid/net/wifi/IOnWifiUsabilityStatsListener$Stub$Proxy;
+Landroid/net/wifi/ITrafficStateCallback$Stub$Proxy;
+Landroid/net/wifi/WifiManager$OnDriverCountryCodeChangedProxy;
+Landroid/net/wifi/WifiManager$OnWifiActivityEnergyInfoProxy;
+Landroid/net/wifi/WifiScanner$ServiceListener;
+Landroid/os/BinderProxy;
+Landroid/util/MapCollections$ArrayIterator;
+Landroid/util/MapCollections$EntrySet;
+Landroid/util/MapCollections$MapIterator;
+Landroid/util/MapCollections$ValuesCollection;
+Lcom/android/icu/charset/CharsetICU;
+Lcom/android/internal/util/FastPrintWriter;
+Lcom/android/org/kxml2/io/KXmlParser;
+Ljava/nio/HeapByteBuffer;
+Ljava/nio/HeapCharBuffer;
+Ljava/security/MessageDigest$Delegate;
+Ljava/util/AbstractList$Itr;
+Ljava/util/ArrayDeque$DeqIterator;
+Ljava/util/ArrayList$Itr;
+Ljava/util/Arrays$ArrayItr;
+Ljava/util/Arrays$ArrayList;
+Ljava/util/Collections$EmptyIterator;
+Ljava/util/Collections$EmptyList;
+Ljava/util/Collections$EmptySet;
+Ljava/util/Collections$UnmodifiableCollection$1;
+Ljava/util/Collections$UnmodifiableMap;
+Ljava/util/Collections$UnmodifiableRandomAccessList;
+Ljava/util/GregorianCalendar;
+Ljava/util/HashMap$EntryIterator;
+Ljava/util/HashMap$EntrySet;
+Ljava/util/HashMap$KeyIterator;
+Ljava/util/HashMap$KeySet;
+Ljava/util/HashMap$Node;
+Ljava/util/HashMap$ValueIterator;
+Ljava/util/HashMap$Values;
+Ljava/util/ImmutableCollections$Set12;
+Ljava/util/LinkedHashMap$LinkedKeyIterator;
+Ljava/util/LinkedList$ListItr;
+Ljava/util/TreeMap$KeyIterator;
+Ljava/util/TreeMap$NavigableSubMap$SubMapKeyIterator;
+Ljava/util/stream/ReferencePipeline$2;
+Ljava/util/stream/ReferencePipeline$3;
+Ljava/util/stream/ReferencePipeline$4;
+Ljava/util/stream/ReferencePipeline$7;
+Ljava/util/stream/ReferencePipeline$Head;
+Ljava/util/stream/SortedOps$OfRef;
+Ljava/util/stream/Streams$StreamBuilderImpl;
diff --git a/service/java/com/android/server/wifi/ActiveModeManager.java b/service/java/com/android/server/wifi/ActiveModeManager.java
index fddfbd449a..f987cd738b 100644
--- a/service/java/com/android/server/wifi/ActiveModeManager.java
+++ b/service/java/com/android/server/wifi/ActiveModeManager.java
@@ -20,6 +20,8 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.os.WorkSource;
 
+import androidx.annotation.Keep;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 
@@ -144,6 +146,7 @@ public interface ActiveModeManager {
     /**
      * Method to get the role for a mode manager.
      */
+    @Keep
     @Nullable Role getRole();
 
     /**
@@ -159,6 +162,7 @@ public interface ActiveModeManager {
     /**
      * Method to get the iface name for the mode manager.
      */
+    @Keep
     String getInterfaceName();
 
     /**
diff --git a/service/java/com/android/server/wifi/ActiveModeWarden.java b/service/java/com/android/server/wifi/ActiveModeWarden.java
index a2877c0e1f..4636099d20 100644
--- a/service/java/com/android/server/wifi/ActiveModeWarden.java
+++ b/service/java/com/android/server/wifi/ActiveModeWarden.java
@@ -78,6 +78,8 @@ import android.util.LocalLog;
 import android.util.Log;
 import android.util.Pair;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.IState;
@@ -93,6 +95,7 @@ import com.android.server.wifi.util.ApConfigUtil;
 import com.android.server.wifi.util.LastCallerInfoManager;
 import com.android.server.wifi.util.NativeUtil;
 import com.android.server.wifi.util.WifiPermissionsUtil;
+import com.android.wifi.flags.FeatureFlags;
 import com.android.wifi.resources.R;
 
 import java.io.FileDescriptor;
@@ -146,6 +149,7 @@ public class ActiveModeWarden {
     private final UserManager mUserManager;
     private final LastCallerInfoManager mLastCallerInfoManager;
     private final WifiGlobals mWifiGlobals;
+    private final FeatureFlags mFeatureFlags;
 
     private WifiServiceImpl.SoftApCallbackInternal mSoftApCallback;
     private WifiServiceImpl.SoftApCallbackInternal mLohsCallback;
@@ -279,6 +283,11 @@ public class ActiveModeWarden {
      */
     public void addWifiStateChangedListener(@NonNull IWifiStateChangedListener listener) {
         mWifiStateChangedListeners.register(listener);
+        try {
+            listener.onWifiStateChanged();
+        } catch (RemoteException e) {
+            Log.e(TAG, "onWifiStateChanged: remote exception -- " + e);
+        }
     }
 
     /**
@@ -445,6 +454,7 @@ public class ActiveModeWarden {
         mUserManager = mWifiInjector.getUserManager();
         mLastCallerInfoManager = mWifiInjector.getLastCallerInfoManager();
         mWifiGlobals = wifiGlobals;
+        mFeatureFlags = mWifiInjector.getDeviceConfigFacade().getFeatureFlags();
 
         wifiNative.registerStatusListener(isReady -> {
             if (!isReady && !mIsShuttingdown) {
@@ -713,15 +723,16 @@ public class ActiveModeWarden {
 
     /** Begin listening to broadcasts and start the internal state machine. */
     public void start() {
-        mContext.registerReceiverForAllUsers(new BroadcastReceiver() {
+        BroadcastReceiver locationChangeReceiver = new BroadcastReceiver() {
             @Override
             public void onReceive(Context context, Intent intent) {
                 // Location mode has been toggled...  trigger with the scan change
                 // update to make sure we are in the correct mode
                 scanAlwaysModeChanged();
             }
-        }, new IntentFilter(LocationManager.MODE_CHANGED_ACTION), null, mHandler);
-        mContext.registerReceiver(new BroadcastReceiver() {
+        };
+
+        BroadcastReceiver airplaneChangedReceiver = new BroadcastReceiver() {
             @Override
             public void onReceive(Context context, Intent intent) {
                 boolean airplaneModeUpdated = mSettingsStore.updateAirplaneModeTracker();
@@ -734,26 +745,51 @@ public class ActiveModeWarden {
                     airplaneModeToggled();
                 }
             }
-        }, new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
-        mContext.registerReceiver(new BroadcastReceiver() {
+        };
+
+        BroadcastReceiver emergencyCallbackModeChangedReceiver = new BroadcastReceiver() {
             @Override
             public void onReceive(Context context, Intent intent) {
                 boolean emergencyMode =
                         intent.getBooleanExtra(TelephonyManager.EXTRA_PHONE_IN_ECM_STATE, false);
                 emergencyCallbackModeChanged(emergencyMode);
             }
-        }, new IntentFilter(TelephonyManager.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED));
+        };
+
+        BroadcastReceiver emergencyCallStateChangedReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                boolean inCall = intent.getBooleanExtra(
+                        TelephonyManager.EXTRA_PHONE_IN_EMERGENCY_CALL, false);
+                emergencyCallStateChanged(inCall);
+            }
+        };
+
+
+        mContext.registerReceiverForAllUsers(locationChangeReceiver,
+                new IntentFilter(LocationManager.MODE_CHANGED_ACTION), null, mHandler);
         boolean trackEmergencyCallState = mResourceCache.getBoolean(
                 R.bool.config_wifi_turn_off_during_emergency_call);
-        if (trackEmergencyCallState) {
-            mContext.registerReceiver(new BroadcastReceiver() {
-                @Override
-                public void onReceive(Context context, Intent intent) {
-                    boolean inCall = intent.getBooleanExtra(
-                            TelephonyManager.EXTRA_PHONE_IN_EMERGENCY_CALL, false);
-                    emergencyCallStateChanged(inCall);
-                }
-            }, new IntentFilter(TelephonyManager.ACTION_EMERGENCY_CALL_STATE_CHANGED));
+        if (mFeatureFlags.monitorIntentForAllUsers()) {
+            mContext.registerReceiverForAllUsers(airplaneChangedReceiver,
+                    new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED), null, mHandler);
+            mContext.registerReceiverForAllUsers(emergencyCallbackModeChangedReceiver,
+                    new IntentFilter(TelephonyManager.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED),
+                    null, mHandler);
+            if (trackEmergencyCallState) {
+                mContext.registerReceiverForAllUsers(emergencyCallStateChangedReceiver,
+                        new IntentFilter(TelephonyManager.ACTION_EMERGENCY_CALL_STATE_CHANGED),
+                        null, mHandler);
+            }
+        } else {
+            mContext.registerReceiver(airplaneChangedReceiver,
+                    new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
+            mContext.registerReceiver(emergencyCallbackModeChangedReceiver,
+                    new IntentFilter(TelephonyManager.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED));
+            if (trackEmergencyCallState) {
+                mContext.registerReceiver(emergencyCallStateChangedReceiver,
+                        new IntentFilter(TelephonyManager.ACTION_EMERGENCY_CALL_STATE_CHANGED));
+            }
         }
         mWifiGlobals.setD2dStaConcurrencySupported(
                 mWifiNative.isP2pStaConcurrencySupported()
@@ -849,6 +885,7 @@ public class ActiveModeWarden {
     }
 
     /** Wifi has been toggled. */
+    @Keep
     public void wifiToggled(WorkSource requestorWs) {
         mWifiController.sendMessage(WifiController.CMD_WIFI_TOGGLED, requestorWs);
     }
@@ -929,6 +966,7 @@ public class ActiveModeWarden {
         @NonNull public final String ssid;
         @Nullable public final String bssid;
         public final boolean didUserApprove;
+        public boolean preferSecondarySta = false;
 
         AdditionalClientModeManagerRequestInfo(
                 @NonNull ExternalClientModeManagerRequestListener listener,
@@ -944,7 +982,6 @@ public class ActiveModeWarden {
             this.ssid = ssid;
             this.bssid = bssid;
             this.didUserApprove = didUserApprove;
-
         }
     }
 
@@ -957,11 +994,12 @@ public class ActiveModeWarden {
      *                 3. The new ClientModeManager - if it was created successfully.
      * @param requestorWs the WorkSource for this request
      * @param didUserApprove if user explicitly approve on this request
+     * @param preferSecondarySta prefer to use secondary CMM for this request if possible
      */
     public void requestLocalOnlyClientModeManager(
             @NonNull ExternalClientModeManagerRequestListener listener,
             @NonNull WorkSource requestorWs, @NonNull String ssid, @NonNull String bssid,
-            boolean didUserApprove) {
+            boolean didUserApprove, boolean preferSecondarySta) {
         if (listener == null) {
             Log.wtf(TAG, "Cannot provide a null ExternalClientModeManagerRequestListener");
             return;
@@ -971,10 +1009,14 @@ public class ActiveModeWarden {
             return;
         }
 
+        AdditionalClientModeManagerRequestInfo additionalClientModeManagerRequestInfo =
+                new AdditionalClientModeManagerRequestInfo(listener, requestorWs,
+                        ROLE_CLIENT_LOCAL_ONLY, ssid, bssid, didUserApprove);
+        additionalClientModeManagerRequestInfo.preferSecondarySta = preferSecondarySta;
+
         mWifiController.sendMessage(
                 WifiController.CMD_REQUEST_ADDITIONAL_CLIENT_MODE_MANAGER,
-                new AdditionalClientModeManagerRequestInfo(listener, requestorWs,
-                        ROLE_CLIENT_LOCAL_ONLY, ssid, bssid, didUserApprove));
+                additionalClientModeManagerRequestInfo);
     }
 
     /**
@@ -1073,6 +1115,7 @@ public class ActiveModeWarden {
      * calls.
      * @return Instance of {@link ConcreteClientModeManager} or null.
      */
+    @Keep
     @Nullable
     public ConcreteClientModeManager getPrimaryClientModeManagerNullable() {
         return getClientModeManagerInRole(ROLE_CLIENT_PRIMARY);
@@ -1085,6 +1128,7 @@ public class ActiveModeWarden {
      * calls.
      * @return Instance of {@link ClientModeManager}.
      */
+    @Keep
     @NonNull
     public ClientModeManager getPrimaryClientModeManager() {
         ClientModeManager cm = getPrimaryClientModeManagerNullable();
@@ -1120,6 +1164,7 @@ public class ActiveModeWarden {
     }
 
     @NonNull
+    @Keep
     public List<ClientModeManager> getClientModeManagers() {
         return new ArrayList<>(mClientModeManagers);
     }
@@ -1185,6 +1230,7 @@ public class ActiveModeWarden {
     }
 
     /** Get any client mode manager in the given role, or null if none was found. */
+    @Keep
     @Nullable
     public ConcreteClientModeManager getClientModeManagerInRole(ClientRole role) {
         for (ConcreteClientModeManager manager : mClientModeManagers) {
@@ -1373,6 +1419,9 @@ public class ActiveModeWarden {
     private void stopAllClientModeManagers() {
         Log.d(TAG, "Shutting down all client mode managers");
         for (ConcreteClientModeManager clientModeManager : getClientModeManagersPrimaryLast()) {
+            if (clientModeManager.getRole() == ROLE_CLIENT_PRIMARY) {
+                setWifiStateForApiCalls(WIFI_STATE_DISABLING);
+            }
             clientModeManager.stop();
         }
     }
@@ -1505,6 +1554,9 @@ public class ActiveModeWarden {
     private void shutdownWifi() {
         Log.d(TAG, "Shutting down all mode managers");
         for (ActiveModeManager manager : getActiveModeManagers()) {
+            if (manager.getRole() == ROLE_CLIENT_PRIMARY) {
+                setWifiStateForApiCalls(WIFI_STATE_DISABLING);
+            }
             manager.stop();
         }
     }
@@ -2000,6 +2052,13 @@ public class ActiveModeWarden {
                 setInitialState(mDisabledState);
             }
             mWifiMetrics.noteWifiEnabledDuringBoot(mSettingsStore.isWifiToggleEnabled());
+            if (mSettingsStore.isWifiToggleEnabled()) {
+                boolean isWifiWakeOn = mWifiInjector.getWakeupController().isUsable();
+                mWifiMetrics.reportWifiStateChanged(true, isWifiWakeOn, false);
+                if (mVerboseLoggingEnabled) {
+                    Log.d(TAG, "logging wifi is on after boot. wifi wake state=" + isWifiWakeOn);
+                }
+            }
 
             // Initialize the lower layers before we start.
             mWifiNative.initialize();
@@ -2413,9 +2472,6 @@ public class ActiveModeWarden {
         }
 
         class EnabledState extends BaseState {
-
-            private boolean mIsDisablingDueToAirplaneMode;
-
             EnabledState(int threshold) {
                 super(threshold, mWifiInjector.getWifiHandlerLocalLog());
             }
@@ -2427,7 +2483,6 @@ public class ActiveModeWarden {
                 if (!hasAnyModeManager()) {
                     Log.e(TAG, "Entered EnabledState, but no active mode managers");
                 }
-                mIsDisablingDueToAirplaneMode = false;
             }
 
             @Override
@@ -2467,7 +2522,8 @@ public class ActiveModeWarden {
                 // Special case for holders with ENTER_CAR_MODE_PRIORITIZED. Only give them the
                 // primary STA to avoid the device getting into STA+STA state.
                 // In STA+STA wifi scans will result in high latency in the secondary STA.
-                if (requestInfo.clientRole == ROLE_CLIENT_LOCAL_ONLY
+                if (!requestInfo.preferSecondarySta
+                        && requestInfo.clientRole == ROLE_CLIENT_LOCAL_ONLY
                         && requestInfo.requestorWs != null) {
                     WorkSource workSource = requestInfo.requestorWs;
                     for (int i = 0; i < workSource.size(); i++) {
@@ -2609,15 +2665,15 @@ public class ActiveModeWarden {
                     case CMD_AIRPLANE_TOGGLED:
                         // airplane mode toggled on is handled in the default state
                         if (mSettingsStore.isAirplaneModeOn()) {
-                            mIsDisablingDueToAirplaneMode = true;
                             return NOT_HANDLED;
                         } else {
-                            if (mIsDisablingDueToAirplaneMode) {
+                            if (mWifiState.get() == WIFI_STATE_DISABLING) {
                                 // Previous airplane mode toggle on is being processed, defer the
                                 // message toggle off until previous processing is completed.
                                 // Once previous airplane mode toggle is complete, we should
                                 // transition to DisabledState. There, we will process the deferred
                                 // airplane mode toggle message to disable airplane mode.
+                                Log.i(TAG, "Deferring CMD_AIRPLANE_TOGGLED.");
                                 deferMessage(msg);
                             } else {
                                 if (!hasPrimaryOrScanOnlyModeManager()) {
@@ -2690,6 +2746,26 @@ public class ActiveModeWarden {
                             transitionTo(mDisabledState);
                         } else {
                             log("STA disabled, remain in EnabledState.");
+                            // Handle any deferred airplane toggle off messages that didn't
+                            // trigger due to no state change
+                            if (hasDeferredMessages(CMD_AIRPLANE_TOGGLED)
+                                    && !hasPrimaryOrScanOnlyModeManager()) {
+                                removeDeferredMessages(CMD_AIRPLANE_TOGGLED);
+                                if (mSettingsStore.isAirplaneModeOn()) {
+                                    // deferred APM toggle is only meant to be done for APM off, so
+                                    // no-op if APM is already on here.
+                                    break;
+                                }
+                                log("Airplane mode disabled, determine next state");
+                                if (shouldEnableSta()) {
+                                    startPrimaryOrScanOnlyClientModeManager(
+                                            // Assumes user toggled it on from settings before.
+                                            mFacade.getSettingsWorkSource(mContext));
+                                    mLastCallerInfoManager.put(WifiManager.API_WIFI_ENABLED,
+                                            Process.myTid(), Process.WIFI_UID, -1, "android_apm",
+                                            true);
+                                }
+                            }
                         }
                         break;
                     case  CMD_DEFERRED_RECOVERY_RESTART_WIFI:
diff --git a/service/java/com/android/server/wifi/ApplicationQosPolicyTrackingTable.java b/service/java/com/android/server/wifi/ApplicationQosPolicyTrackingTable.java
index d8509d4b3d..4a7dd77ea4 100644
--- a/service/java/com/android/server/wifi/ApplicationQosPolicyTrackingTable.java
+++ b/service/java/com/android/server/wifi/ApplicationQosPolicyTrackingTable.java
@@ -28,6 +28,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 /**
@@ -230,7 +231,7 @@ public class ApplicationQosPolicyTrackingTable {
             policyStream = policyStream.filter(p ->
                     shouldContainQosChars == (p.getQosCharacteristics() != null));
         }
-        return policyStream.toList();
+        return policyStream.collect(Collectors.toList());
     }
 
     /**
diff --git a/service/java/com/android/server/wifi/ClientMode.java b/service/java/com/android/server/wifi/ClientMode.java
index d5c7c82e8a..b371884718 100644
--- a/service/java/com/android/server/wifi/ClientMode.java
+++ b/service/java/com/android/server/wifi/ClientMode.java
@@ -16,6 +16,8 @@
 
 package com.android.server.wifi;
 
+import static com.android.server.wifi.util.GeneralUtil.bitsetToLong;
+
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -36,6 +38,8 @@ import android.os.IBinder;
 import android.os.Message;
 import android.os.WorkSource;
 
+import androidx.annotation.Keep;
+
 import com.android.server.wifi.WifiNative.RxFateReport;
 import com.android.server.wifi.WifiNative.TxFateReport;
 import com.android.server.wifi.util.ActionListenerWrapper;
@@ -67,20 +71,24 @@ public interface ClientMode {
 
     void enableVerboseLogging(boolean verbose);
 
+    @Keep
     void connectNetwork(NetworkUpdateResult result, ActionListenerWrapper wrapper, int callingUid,
             @NonNull String packageName, @Nullable String attributionTag);
 
     void saveNetwork(NetworkUpdateResult result, ActionListenerWrapper wrapper, int callingUid,
             @NonNull String packageName);
 
+    @Keep
     void disconnect();
 
     void reconnect(WorkSource ws);
 
     void reassociate();
 
+    @Keep
     void startConnectToNetwork(int networkId, int uid, String bssid);
 
+    @Keep
     void startRoamToNetwork(int networkId, String bssid);
 
     /** When the device mobility changes, update the RSSI polling interval accordingly */
@@ -125,6 +133,7 @@ public interface ClientMode {
      * Get current Wifi connection information
      * @return Wifi info
      */
+    @Keep
     WifiInfo getConnectionInfo();
 
     boolean syncQueryPasspointIcon(long bssid, String fileName);
@@ -133,13 +142,23 @@ public interface ClientMode {
      * Get the current Wifi network information
      * @return network
      */
+    @Keep
     Network getCurrentNetwork();
 
     DhcpResultsParcelable syncGetDhcpResultsParcelable();
 
     /** Get the supported feature set synchronously */
     @NonNull
-    BitSet getSupportedFeatures();
+    BitSet getSupportedFeaturesBitSet();
+
+    /**
+     * Do not use this method, new features will not be supported by this method. This method is
+     * only for backward compatible for some OEMs. Please use {@link #getSupportedFeaturesBitSet()}
+     */
+    @Keep
+    default long getSupportedFeatures() {
+        return bitsetToLong(getSupportedFeaturesBitSet());
+    }
 
     boolean syncStartSubscriptionProvisioning(int callingUid, OsuProvider provider,
             IProvisioningCallback callback);
@@ -190,6 +209,7 @@ public interface ClientMode {
      */
     @Nullable String getConnectingBssid();
 
+    @Keep
     WifiLinkLayerStats getWifiLinkLayerStats();
 
     boolean setPowerSave(@PowerSaveClientType int client, boolean ps);
@@ -199,12 +219,14 @@ public interface ClientMode {
 
     WifiMulticastLockManager.FilterController getMcastLockManagerFilterController();
 
+    @Keep
     boolean isConnected();
 
     boolean isConnecting();
 
     boolean isRoaming();
 
+    @Keep
     boolean isDisconnected();
 
     boolean isSupplicantTransientState();
diff --git a/service/java/com/android/server/wifi/ClientModeImpl.java b/service/java/com/android/server/wifi/ClientModeImpl.java
index ba671d0218..08e93bdf7f 100644
--- a/service/java/com/android/server/wifi/ClientModeImpl.java
+++ b/service/java/com/android/server/wifi/ClientModeImpl.java
@@ -17,9 +17,11 @@
 package com.android.server.wifi;
 
 import static android.net.util.KeepalivePacketDataUtil.parseTcpKeepalivePacketData;
+import static android.net.wifi.WifiConfiguration.NetworkSelectionStatus.DISABLED_BY_WIFI_MANAGER;
 import static android.net.wifi.WifiConfiguration.NetworkSelectionStatus.DISABLED_NONE;
 import static android.net.wifi.WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET_PERMANENT;
 import static android.net.wifi.WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET_TEMPORARY;
+import static android.net.wifi.WifiConfiguration.NetworkSelectionStatus.DISABLED_TRANSITION_DISABLE_INDICATION;
 import static android.net.wifi.WifiConfiguration.NetworkSelectionStatus.DISABLED_UNWANTED_LOW_RSSI;
 import static android.net.wifi.WifiManager.WIFI_FEATURE_FILS_SHA256;
 import static android.net.wifi.WifiManager.WIFI_FEATURE_FILS_SHA384;
@@ -217,7 +219,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
     private static final int IPCLIENT_SHUTDOWN_TIMEOUT_MS = 60_000; // 60 seconds
     private static final int NETWORK_AGENT_TEARDOWN_DELAY_MS = 5_000; // Max teardown delay.
     private static final int DISASSOC_AP_BUSY_DISABLE_DURATION_MS = 5 * 60 * 1000; // 5 minutes
-    @VisibleForTesting public static final long CONNECTING_WATCHDOG_TIMEOUT_MS = 30_000; // 30 secs.
+    @VisibleForTesting public static final long CONNECTING_WATCHDOG_TIMEOUT_MS = 8_000; // 8 secs.
     public static final int PROVISIONING_TIMEOUT_FILS_CONNECTION_MS = 36_000; // 36 secs.
     @VisibleForTesting
     public static final String ARP_TABLE_PATH = "/proc/net/arp";
@@ -285,6 +287,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
     private final long mId;
 
     private boolean mScreenOn = false;
+    private boolean mIsDeviceIdle = false;
 
     private final String mInterfaceName;
     private final ConcreteClientModeManager mClientModeManager;
@@ -325,6 +328,12 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
 
     private PowerManager.WakeLock mSuspendWakeLock;
 
+    // Log Wifi L2 and L3 connection state transition time stamp
+    private long mL2ConnectingStateTimestamp;
+    private long mL2ConnectedStateTimestamp;
+    private long mL3ProvisioningStateTimestamp;
+    private long mL3ConnectedStateTimestamp;
+
     /**
      * Value to set in wpa_supplicant "bssid" field when we don't want to restrict connection to
      * a specific AP.
@@ -1301,25 +1310,12 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
             updateCurrentConnectionInfo();
         }
 
-        @Override
-        public void onNetworkTemporarilyDisabled(WifiConfiguration config, int disableReason) {
-            if (disableReason == DISABLED_NO_INTERNET_TEMPORARY) return;
-            if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
-                // Disconnect and let autojoin reselect a new network
-                mFrameworkDisconnectReasonOverride = WifiStatsLog.WIFI_DISCONNECT_REPORTED__FAILURE_CODE__DISCONNECT_TEMP_DISABLED;
-                sendMessageAtFrontOfQueue(CMD_DISCONNECT,
-                        StaEvent.DISCONNECT_NETWORK_TEMPORARY_DISABLED);
-            }
-
-        }
-
         @Override
         public void onNetworkPermanentlyDisabled(WifiConfiguration config, int disableReason) {
-            // For DISABLED_NO_INTERNET_PERMANENT we do not need to remove the network
-            // because supplicant won't be trying to reconnect. If this is due to a
-            // preventAutomaticReconnect request from ConnectivityService, that service
-            // will disconnect as appropriate.
-            if (disableReason == DISABLED_NO_INTERNET_PERMANENT) return;
+            if (disableReason != DISABLED_BY_WIFI_MANAGER
+                    && disableReason != DISABLED_TRANSITION_DISABLE_INDICATION) {
+                return;
+            }
             if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                 // Disconnect and let autojoin reselect a new network
                 mFrameworkDisconnectReasonOverride = WifiStatsLog.WIFI_DISCONNECT_REPORTED__FAILURE_CODE__DISCONNECT_PERM_DISABLED;
@@ -1529,6 +1525,17 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
                 mWifiMetrics.setNominatorForNetwork(netId,
                         WifiMetricsProto.ConnectionEvent.NOMINATOR_MANUAL);
             }
+            if (isPrimary()) {
+                WifiConfiguration config = getConnectedWifiConfigurationInternal();
+                if (config != null && getClientRoleForMetrics(config)
+                        == WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__ROLE__ROLE_CLIENT_LOCAL_ONLY) {
+                    // User manually trigger switch from a local-only network to primary.
+                    // Temporarily block re-connection to the local-only network to avoid app
+                    // automatically connecting back to it.
+                    mWifiConfigManager.userTemporarilyDisabledNetwork(config.SSID,
+                            Process.WIFI_UID);
+                }
+            }
             startConnectToNetwork(netId, uid, SUPPLICANT_BSSID_ANY);
         }
     }
@@ -1651,14 +1658,14 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
     }
 
     private boolean isLinkLayerStatsSupported() {
-        return getSupportedFeatures().get(WIFI_FEATURE_LINK_LAYER_STATS);
+        return getSupportedFeaturesBitSet().get(WIFI_FEATURE_LINK_LAYER_STATS);
     }
 
     /**
      * @return true if this device supports WPA3_SAE
      */
     private boolean isWpa3SaeSupported() {
-        return getSupportedFeatures().get(WIFI_FEATURE_WPA3_SAE);
+        return getSupportedFeaturesBitSet().get(WIFI_FEATURE_WPA3_SAE);
     }
 
     /**
@@ -1983,7 +1990,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
     /**
      * Get the supported feature set synchronously
      */
-    public @NonNull BitSet getSupportedFeatures() {
+    public @NonNull BitSet getSupportedFeaturesBitSet() {
         return mWifiNative.getSupportedFeatureSet(mInterfaceName);
     }
 
@@ -2047,7 +2054,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
      *  Check if a TDLS session can be established
      */
     public boolean isTdlsOperationCurrentlyAvailable() {
-        return getSupportedFeatures().get(WIFI_FEATURE_TDLS) && isConnected() && canEnableTdls();
+        return getSupportedFeaturesBitSet().get(WIFI_FEATURE_TDLS) && isConnected() && canEnableTdls();
     }
 
     /**
@@ -2658,6 +2665,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
 
     private void handleScreenStateChanged(boolean screenOn) {
         mScreenOn = screenOn;
+        considerChangingFirmwareRoaming();
         if (mVerboseLoggingEnabled) {
             logd(" handleScreenStateChanged Enter: screenOn=" + screenOn
                     + " mSuspendOptimizationsEnabled="
@@ -3651,7 +3659,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
         // Update link layer stats
         getWifiLinkLayerStats();
 
-        if (mWifiP2pConnection.isConnected() && !mWifiP2pConnection.isP2pInWaitingState()) {
+        if (mWifiP2pConnection.isConnected() && !mWifiP2pConnection.isP2pInDisabledState()) {
             // P2P discovery breaks DHCP, so shut it down in order to get through this.
             // Once P2P service receives this message and processes it accordingly, it is supposed
             // to send arg2 (i.e. CMD_PRE_DHCP_ACTION_COMPLETE) in a new Message.what back to
@@ -3907,6 +3915,15 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
         if (frequency == WifiInfo.UNKNOWN_FREQUENCY && candidate != null) {
             frequency = candidate.frequency;
         }
+
+        long l2ConnectionDuration =
+                (mL2ConnectedStateTimestamp - mL2ConnectingStateTimestamp) > 0
+                ? (mL2ConnectedStateTimestamp - mL2ConnectingStateTimestamp) : 0;
+        long l3ConnectionDuration = (mL3ConnectedStateTimestamp - mL3ProvisioningStateTimestamp) > 0
+                ? (mL3ConnectedStateTimestamp - mL3ProvisioningStateTimestamp) : 0;
+        mWifiMetrics.reportConnectingDuration(mInterfaceName,
+                l2ConnectionDuration, l3ConnectionDuration);
+
         mWifiMetrics.endConnectionEvent(mInterfaceName, level2FailureCode,
                 connectivityFailureCode, level2FailureReason, frequency, statusCode);
         mWifiConnectivityManager.handleConnectionAttemptEnded(
@@ -5794,6 +5811,8 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
                     // We need to get the updated pseudonym from supplicant for EAP-SIM/AKA/AKA'
                     if (config.enterpriseConfig != null
                             && config.enterpriseConfig.isAuthenticationSimBased()) {
+                        // clear SIM related EapFailurenotification
+                        mEapFailureNotifier.dismissEapFailureNotification(config.SSID);
                         if (mWifiCarrierInfoManager.isOobPseudonymFeatureEnabled(
                                 config.carrierId)) {
                             if (mVerboseLoggingEnabled) {
@@ -6095,6 +6114,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
             // network. In some cases supplicant ignores the connect requests (it might not
             // find the target SSID in its cache), Therefore we end up stuck that state, hence the
             // need for the watchdog.
+            mL2ConnectingStateTimestamp = mClock.getElapsedSinceBootMillis();
             mConnectingWatchdogCount++;
             logd("Start Connecting Watchdog " + mConnectingWatchdogCount);
             sendMessageDelayed(obtainMessage(CMD_CONNECTING_WATCHDOG_TIMER,
@@ -6470,6 +6490,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
 
         @Override
         public void enterImpl() {
+            mL2ConnectedStateTimestamp = mClock.getElapsedSinceBootMillis();
             final WifiConfiguration config = getConnectedWifiConfigurationInternal();
             if (config == null) {
                 logw("Connected to a network that's already been removed " + mLastNetworkId
@@ -7089,6 +7110,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
 
         @Override
         public void enterImpl() {
+            mL3ProvisioningStateTimestamp = mClock.getElapsedSinceBootMillis();
             startL3Provisioning();
             if (mContext.getResources().getBoolean(
                     R.bool.config_wifiRemainConnectedAfterIpProvisionTimeout)) {
@@ -7358,7 +7380,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
             if (mVerboseLoggingEnabled) {
                 log("Enter ConnectedState mScreenOn=" + mScreenOn);
             }
-
+            mL3ConnectedStateTimestamp = mClock.getElapsedSinceBootMillis();
             reportConnectionAttemptEnd(
                     WifiMetrics.ConnectionEvent.FAILURE_NONE,
                     WifiMetricsProto.ConnectionEvent.HLF_NONE,
@@ -7551,11 +7573,6 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
                 }
                 case WifiMonitor.NETWORK_DISCONNECTION_EVENT: {
                     DisconnectEventInfo eventInfo = (DisconnectEventInfo) message.obj;
-                    reportConnectionAttemptEnd(
-                            WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION,
-                            WifiMetricsProto.ConnectionEvent.HLF_NONE,
-                            WifiMetricsProto.ConnectionEvent.FAILURE_REASON_UNKNOWN,
-                            eventInfo.reasonCode);
                     if (unexpectedDisconnectedReason(eventInfo.reasonCode)) {
                         mWifiDiagnostics.triggerBugReportDataCapture(
                                 WifiDiagnostics.REPORT_REASON_UNEXPECTED_DISCONNECT);
@@ -8072,21 +8089,21 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
      * @return true if this device supports FILS-SHA256
      */
     private boolean isFilsSha256Supported() {
-        return getSupportedFeatures().get(WIFI_FEATURE_FILS_SHA256);
+        return getSupportedFeaturesBitSet().get(WIFI_FEATURE_FILS_SHA256);
     }
 
     /**
      * @return true if this device supports FILS-SHA384
      */
     private boolean isFilsSha384Supported() {
-        return getSupportedFeatures().get(WIFI_FEATURE_FILS_SHA384);
+        return getSupportedFeaturesBitSet().get(WIFI_FEATURE_FILS_SHA384);
     }
 
     /**
      * @return true if this device supports Trust On First Use
      */
     private boolean isTrustOnFirstUseSupported() {
-        return getSupportedFeatures().get(WIFI_FEATURE_TRUST_ON_FIRST_USE);
+        return getSupportedFeaturesBitSet().get(WIFI_FEATURE_TRUST_ON_FIRST_USE);
     }
 
     /**
@@ -8483,7 +8500,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
         return status == WifiNative.SET_FIRMWARE_ROAMING_SUCCESS;
     }
 
-    private void considerChangingFirmwareRoaming(boolean isIdle) {
+    private void considerChangingFirmwareRoaming() {
         if (mClientModeManager.getRole() != ROLE_CLIENT_PRIMARY) {
             if (mVerboseLoggingEnabled) {
                 Log.v(TAG, "Idle mode changed: iface " + mInterfaceName + " is not primary.");
@@ -8499,7 +8516,7 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
             }
             return;
         }
-        if (isIdle) {
+        if (mIsDeviceIdle && !mScreenOn) {
             // disable firmware roaming if in idle mode
             if (mVerboseLoggingEnabled) {
                 Log.v(TAG, "Idle mode changed: iface " + mInterfaceName
@@ -8508,9 +8525,9 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
             enableRoaming(false);
             return;
         }
-        // Exiting idle mode so re-enable firmware roaming, but only if the current use-case is
-        // not the local-only use-case. The local-only use-case requires firmware roaming to be
-        // always disabled.
+        // Exiting idle mode or screen is turning on, so re-enable firmware roaming, but only if the
+        // current use-case is not the local-only use-case. The local-only use-case requires
+        // firmware roaming to be always disabled.
         WifiConfiguration config = getConnectedWifiConfigurationInternal();
         if (config == null) {
             config = getConnectingWifiConfigurationInternal();
@@ -8529,7 +8546,8 @@ public class ClientModeImpl extends StateMachine implements ClientMode {
 
     @Override
     public void onIdleModeChanged(boolean isIdle) {
-        considerChangingFirmwareRoaming(isIdle);
+        mIsDeviceIdle = isIdle;
+        considerChangingFirmwareRoaming();
     }
 
     @Override
diff --git a/service/java/com/android/server/wifi/Clock.java b/service/java/com/android/server/wifi/Clock.java
index 63e958b3ca..1a235287cb 100644
--- a/service/java/com/android/server/wifi/Clock.java
+++ b/service/java/com/android/server/wifi/Clock.java
@@ -18,6 +18,8 @@ package com.android.server.wifi;
 
 import android.os.SystemClock;
 
+import java.time.Instant;
+
 import javax.annotation.concurrent.ThreadSafe;
 
 /**
@@ -68,4 +70,8 @@ public class Clock {
     public void sleep(long ms) {
         SystemClock.sleep(ms);
     }
+
+    public Instant getCurrentInstant() {
+        return Instant.now();
+    }
 }
diff --git a/service/java/com/android/server/wifi/ConcreteClientModeManager.java b/service/java/com/android/server/wifi/ConcreteClientModeManager.java
index 36a43a5526..c736c80166 100644
--- a/service/java/com/android/server/wifi/ConcreteClientModeManager.java
+++ b/service/java/com/android/server/wifi/ConcreteClientModeManager.java
@@ -16,9 +16,12 @@
 
 package com.android.server.wifi;
 
+import static android.net.wifi.WifiManager.WIFI_STATE_DISABLING;
 import static android.net.wifi.WifiManager.WIFI_STATE_ENABLED;
 import static android.net.wifi.WifiManager.WIFI_STATE_ENABLING;
 
+import static com.android.server.wifi.util.GeneralUtil.bitsetToLong;
+
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.content.Context;
@@ -60,6 +63,8 @@ import android.telephony.ims.stub.ImsRegistrationImplBase;
 import android.text.TextUtils;
 import android.util.Log;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.util.IState;
 import com.android.internal.util.State;
 import com.android.internal.util.StateMachine;
@@ -199,6 +204,7 @@ public class ConcreteClientModeManager implements ClientModeManager {
      * Sets whether this ClientModeManager is for secondary STA with internet.
      * @param secondaryInternet whether the ClientModeManager is for secondary internet.
      */
+    @Keep
     public void setSecondaryInternet(boolean secondaryInternet) {
         // TODO: b/197670907 : Add client role ROLE_CLIENT_SECONDARY_INTERNET
         if (mRole == ROLE_CLIENT_SECONDARY_LONG_LIVED) {
@@ -210,6 +216,7 @@ public class ConcreteClientModeManager implements ClientModeManager {
      * Sets whether this ClientModeManager is for DBS AP multi internet.
      * @param isDbs whether the ClientModeManager is connecting to to the same SSID as primary.
      */
+    @Keep
     public void setSecondaryInternetDbsAp(boolean isDbs) {
         // TODO: b/197670907 : Add client role ROLE_CLIENT_SECONDARY_INTERNET
         if (mRole == ROLE_CLIENT_SECONDARY_LONG_LIVED) {
@@ -587,6 +594,9 @@ public class ConcreteClientModeManager implements ClientModeManager {
         mTargetRoleChangeInfo = new RoleChangeInfo(role, requestorWs, modeListener);
         if (role == ROLE_CLIENT_SCAN_ONLY) {
             // Switch client mode manager to scan only mode.
+            if (mRole == ROLE_CLIENT_PRIMARY) {
+                mWifiInjector.getActiveModeWarden().setWifiStateForApiCalls(WIFI_STATE_DISABLING);
+            }
             mStateMachine.sendMessage(
                     ClientModeStateMachine.CMD_SWITCH_TO_SCAN_ONLY_MODE);
         } else {
@@ -1481,8 +1491,14 @@ public class ConcreteClientModeManager implements ClientModeManager {
     }
 
     @Override
-    public @NonNull BitSet getSupportedFeatures() {
-        return getClientMode().getSupportedFeatures();
+    public @NonNull BitSet getSupportedFeaturesBitSet() {
+        return getClientMode().getSupportedFeaturesBitSet();
+    }
+
+    @Override
+    @Keep
+    public long getSupportedFeatures() {
+        return bitsetToLong(getSupportedFeaturesBitSet());
     }
 
     @Override
diff --git a/service/java/com/android/server/wifi/DefaultClientModeManager.java b/service/java/com/android/server/wifi/DefaultClientModeManager.java
index b289640342..f5f46ab003 100644
--- a/service/java/com/android/server/wifi/DefaultClientModeManager.java
+++ b/service/java/com/android/server/wifi/DefaultClientModeManager.java
@@ -83,7 +83,7 @@ public class DefaultClientModeManager implements ClientModeManager, ClientModeDe
     }
 
     @Override
-    public @NonNull BitSet getSupportedFeatures() {
+    public @NonNull BitSet getSupportedFeaturesBitSet() {
         return new BitSet();
     }
 
diff --git a/service/java/com/android/server/wifi/DppManager.java b/service/java/com/android/server/wifi/DppManager.java
index c8bf111b9d..553d716a7e 100644
--- a/service/java/com/android/server/wifi/DppManager.java
+++ b/service/java/com/android/server/wifi/DppManager.java
@@ -74,6 +74,7 @@ public class DppManager {
     private static final String DPP_TIMEOUT_TAG = TAG + " Request Timeout";
     private static final int DPP_TIMEOUT_MS = 40_000; // 40 seconds
     private static final int DPP_RESPONDER_TIMEOUT_MS = 300_000; // 5 minutes
+    private static final int DPP_ENROLLEE_CONN_STATUS_RESULT_TX_TIMEOUT_MS = 16_000; // 16 seconds
     public static final int DPP_AUTH_ROLE_INACTIVE = -1;
     public static final int DPP_AUTH_ROLE_INITIATOR = 0;
     public static final int DPP_AUTH_ROLE_RESPONDER = 1;
@@ -740,7 +741,11 @@ public class DppManager {
         if (!mDppRequestInfo.connStatusRequested) {
             cleanupDppResources();
         } else {
-            Log.d(TAG, "Wait for enrollee to send connection status");
+            Log.d(TAG, "Wait " + (DPP_ENROLLEE_CONN_STATUS_RESULT_TX_TIMEOUT_MS / 1000)
+                    + " seconds for enrollee to send connection status");
+            mDppTimeoutMessage.cancel();
+            mDppTimeoutMessage.schedule(mClock.getElapsedSinceBootMillis()
+                    + DPP_ENROLLEE_CONN_STATUS_RESULT_TX_TIMEOUT_MS);
         }
     }
 
diff --git a/service/java/com/android/server/wifi/EapFailureNotifier.java b/service/java/com/android/server/wifi/EapFailureNotifier.java
index 64143eb816..fc0dddb5f6 100644
--- a/service/java/com/android/server/wifi/EapFailureNotifier.java
+++ b/service/java/com/android/server/wifi/EapFailureNotifier.java
@@ -134,6 +134,23 @@ public class EapFailureNotifier {
         return eapFailureConfig;
     }
 
+    /**
+     * Dismiss notification
+     */
+    public void dismissEapFailureNotification(String ssid) {
+        if (TextUtils.isEmpty(mCurrentShownSsid) || TextUtils.isEmpty(ssid)
+                || !TextUtils.equals(ssid, mCurrentShownSsid)) {
+            return;
+        }
+        StatusBarNotification[] activeNotifications = mNotificationManager.getActiveNotifications();
+        for (StatusBarNotification activeNotification : activeNotifications) {
+            if ((activeNotification.getId() == NOTIFICATION_ID)) {
+                mNotificationManager.cancel(NOTIFICATION_ID);
+                return;
+            }
+        }
+    }
+
     /**
      * Display eap error notification which defined by carrier.
      *
diff --git a/service/java/com/android/server/wifi/FrameworkFacade.java b/service/java/com/android/server/wifi/FrameworkFacade.java
index 7b905732c4..086bff6db1 100644
--- a/service/java/com/android/server/wifi/FrameworkFacade.java
+++ b/service/java/com/android/server/wifi/FrameworkFacade.java
@@ -448,8 +448,8 @@ public class FrameworkFacade {
                 return true;
             //If the overlay setting enabled for userdebug builds only
             case VERBOSE_LOGGING_ALWAYS_ON_LEVEL_USERDEBUG:
-                // If it is a userdebug build
-                if (buildProperties.isUserdebugBuild()) return true;
+                // If it is a userdebug or eng build
+                if (buildProperties.isUserdebugBuild() || buildProperties.isEngBuild()) return true;
                 break;
             case VERBOSE_LOGGING_ALWAYS_ON_LEVEL_NONE:
                 // nothing
diff --git a/service/java/com/android/server/wifi/HalDeviceManager.java b/service/java/com/android/server/wifi/HalDeviceManager.java
index a251af8578..9a0bf0ae64 100644
--- a/service/java/com/android/server/wifi/HalDeviceManager.java
+++ b/service/java/com/android/server/wifi/HalDeviceManager.java
@@ -1409,7 +1409,8 @@ public class HalDeviceManager {
      * Returns 'true' if there are no discrepancies - 'false' otherwise.
      *
      * A discrepancy is if any local state contains references to a chip or interface which are not
-     * found on the information read from the chip.
+     * found on the information read from the chip, or if the chip has interfaces that don't match
+     * the local state.
      *
      * Also, fills in the |requestorWs| corresponding to each active iface in |WifiChipInfo|.
      */
@@ -1417,6 +1418,7 @@ public class HalDeviceManager {
         if (VDBG) Log.d(TAG, "validateInterfaceCache");
 
         synchronized (mLock) {
+            // Check that each cache entry has a corresponding WifiIfaceInfo from the chip.
             for (InterfaceCacheEntry entry: mInterfaceInfoCache.values()) {
                 // search for chip
                 WifiChipInfo matchingChipInfo = null;
@@ -1456,6 +1458,35 @@ public class HalDeviceManager {
                     return false;
                 }
             }
+            // Check that each WifiIfaceInfo from the chip has a cache entry corresponding to it.
+            // WifiIfaceInfo#requestorWsHelper should be populated from the cache entry in the loop
+            // above. If it's null here, then that means we didn't find a cache entry for it.
+            List<WifiIfaceInfo> ifaceInfosWithoutWsHelper = new ArrayList<>();
+            for (WifiChipInfo chipInfo : chipInfos) {
+                for (int createType : CREATE_TYPES_BY_PRIORITY) {
+                    WifiIfaceInfo[] ifaceInfoList = chipInfo.ifaces[createType];
+                    if (ifaceInfoList == null) {
+                        // Shouldn't happen.
+                        Log.wtf(TAG, "validateInterfaceCache: no iface info list for type "
+                                + createType);
+                        return false;
+                    }
+                    for (WifiIfaceInfo ifaceInfo : ifaceInfoList) {
+                        if (ifaceInfo.requestorWsHelper == null) {
+                            ifaceInfosWithoutWsHelper.add(ifaceInfo);
+                        }
+                    }
+                }
+            }
+            if (!ifaceInfosWithoutWsHelper.isEmpty()) {
+                Log.wtf(TAG, "validateInterfaceCache: no interface cache entries found"
+                        + " for ifaceInfos: " + ifaceInfosWithoutWsHelper);
+                mWifiInjector.getWifiDiagnostics().takeBugReport(
+                        "Wi-Fi HalDeviceManager bugreport", "No iface cache entries found for iface"
+                                + " infos: " + ifaceInfosWithoutWsHelper
+                                + ". Current mInterfaceInfoCache: " + mInterfaceInfoCache);
+                return false;
+            }
         }
 
         return true;
@@ -1553,7 +1584,7 @@ public class HalDeviceManager {
         @Override
         public void onSubsystemRestart(int status) {
             Log.i(TAG, "onSubsystemRestart");
-            mEventHandler.post(() -> {
+            mEventHandler.postAtFrontOfQueue(() -> {
                 Log.i(TAG, "IWifiEventCallback.onSubsystemRestart. Status: " + status);
                 synchronized (mLock) {
                     Log.i(TAG, "Attempting to invoke mSubsystemRestartListener");
diff --git a/service/java/com/android/server/wifi/HostapdHal.java b/service/java/com/android/server/wifi/HostapdHal.java
index 149973cc5b..1bf664e2aa 100644
--- a/service/java/com/android/server/wifi/HostapdHal.java
+++ b/service/java/com/android/server/wifi/HostapdHal.java
@@ -292,6 +292,23 @@ public class HostapdHal {
         }
     }
 
+    /**
+     * See comments for
+     * {@link IHostapdHal#removeLinkFromMultipleLinkBridgedApIface(String, String)}.
+     */
+    public void removeLinkFromMultipleLinkBridgedApIface(@NonNull String ifaceName,
+            @NonNull String apIfaceInstance) {
+        synchronized (mLock) {
+            String methodStr = "removeLinkFromMultipleLinkBridgedApIface";
+            if (mIHostapd == null) {
+                handleNullIHostapd(methodStr);
+                return;
+            }
+            mIHostapd.removeLinkFromMultipleLinkBridgedApIface(
+                    ifaceName, apIfaceInstance);
+        }
+    }
+
     private boolean handleNullIHostapd(String methodStr) {
         Log.e(TAG, "Cannot call " + methodStr + " because mIHostapd is null.");
         return false;
diff --git a/service/java/com/android/server/wifi/HostapdHalAidlImp.java b/service/java/com/android/server/wifi/HostapdHalAidlImp.java
index 32c637630e..d73880f973 100644
--- a/service/java/com/android/server/wifi/HostapdHalAidlImp.java
+++ b/service/java/com/android/server/wifi/HostapdHalAidlImp.java
@@ -422,7 +422,10 @@ public class HostapdHalAidlImp implements IHostapdHal {
                     callback.onInfoChanged(info.apIfaceInstance, info.freqMhz,
                             mapHalChannelBandwidthToSoftApInfo(info.channelBandwidth),
                             mapHalGenerationToWifiStandard(info.generation),
-                            MacAddress.fromBytes(info.apIfaceInstanceMacAddress), vendorData);
+                            MacAddress.fromBytes(info.apIfaceInstanceMacAddress),
+                            (Flags.mloSap() && info.mldMacAddress != null)
+                                    ? MacAddress.fromBytes(info.mldMacAddress) : null,
+                            vendorData);
                 }
                 mActiveInstances.add(info.apIfaceInstance);
             } catch (IllegalArgumentException iae) {
@@ -1194,9 +1197,33 @@ public class HostapdHalAidlImp implements IHostapdHal {
     /**
      * Dump information about the AIDL implementation.
      *
-     * TODO (b/202302891) Log version information once we freeze the AIDL interface
      */
     public void dump(PrintWriter pw) {
-        pw.println("AIDL interface version: 1 (initial)");
+        pw.println("AIDL interface version: " + mServiceVersion);
+    }
+
+    /**
+     * See comments for
+     * {@link IHostapdHal#removeLinkFromMultipleLinkBridgedApIface(String, String)}.
+     */
+    public void removeLinkFromMultipleLinkBridgedApIface(@NonNull String ifaceName,
+            @NonNull String apIfaceInstance) {
+        if (!isServiceVersionAtLeast(3)) {
+            return;
+        }
+        synchronized (mLock) {
+            final String methodStr = "removeLinkFromMultipleLinkBridgedApIface";
+            if (!checkHostapdAndLogFailure(methodStr)) {
+                return;
+            }
+            Log.i(TAG, "Remove link: " + apIfaceInstance + " from AP iface: " + ifaceName);
+            try {
+                mIHostapd.removeLinkFromMultipleLinkBridgedApIface(ifaceName, apIfaceInstance);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            }
+        }
     }
 }
diff --git a/service/java/com/android/server/wifi/HostapdHalHidlImp.java b/service/java/com/android/server/wifi/HostapdHalHidlImp.java
index 389624e6a7..4e675fdc45 100644
--- a/service/java/com/android/server/wifi/HostapdHalHidlImp.java
+++ b/service/java/com/android/server/wifi/HostapdHalHidlImp.java
@@ -1285,6 +1285,7 @@ public class HostapdHalHidlImp implements IHostapdHal {
                             mapHalBandwidthToSoftApInfo(bandwidth),
                             mapHalGenerationToWifiStandard(generation),
                             MacAddress.fromBytes(apIfaceInstanceMacAddress),
+                            null,
                             Collections.emptyList());
                 }
             } catch (IllegalArgumentException iae) {
diff --git a/service/java/com/android/server/wifi/IHostapdHal.java b/service/java/com/android/server/wifi/IHostapdHal.java
index eafb495334..20879fd3fb 100644
--- a/service/java/com/android/server/wifi/IHostapdHal.java
+++ b/service/java/com/android/server/wifi/IHostapdHal.java
@@ -131,4 +131,15 @@ interface IHostapdHal {
      * Dump information about the specific implementation.
      */
     void dump(PrintWriter pw);
+
+    /**
+     * Removes an existing link from multiple link device which the current AP resides on.
+     * Note: It is being implemented for AIDL interface only.
+     *
+     * @param ifaceName Name of the iface.
+     * @param apIfaceInstance The identity of the link which associated to the multiple link device
+     *                        that the current AP resides on.
+     */
+    default void removeLinkFromMultipleLinkBridgedApIface(@NonNull String ifaceName,
+            @NonNull String apIfaceInstance) {};
 }
diff --git a/service/java/com/android/server/wifi/ISupplicantStaIfaceHal.java b/service/java/com/android/server/wifi/ISupplicantStaIfaceHal.java
index c860322719..fcd4c9d52c 100644
--- a/service/java/com/android/server/wifi/ISupplicantStaIfaceHal.java
+++ b/service/java/com/android/server/wifi/ISupplicantStaIfaceHal.java
@@ -18,11 +18,16 @@ package com.android.server.wifi;
 
 
 import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.net.MacAddress;
 import android.net.wifi.MscsParams;
 import android.net.wifi.QosPolicyParams;
 import android.net.wifi.SecurityParams;
 import android.net.wifi.WifiConfiguration;
+import android.net.wifi.usd.PublishConfig;
+import android.net.wifi.usd.SubscribeConfig;
+
+import com.android.server.wifi.usd.UsdRequestManager;
 
 import java.util.ArrayList;
 import java.util.BitSet;
@@ -860,4 +865,89 @@ interface ISupplicantStaIfaceHal {
     default boolean isRsnOverridingSupported(@NonNull String ifaceName) {
         return false;
     }
+
+    /**
+     * Returns USD capabilities for the interface.
+     *
+     * @param ifaceName Name of the interface.
+     * @return UsdCapabilities if available, otherwise null.
+     */
+    @Nullable
+    default SupplicantStaIfaceHal.UsdCapabilitiesInternal getUsdCapabilities(String ifaceName) {
+        return null;
+    }
+
+    /**
+     * Starts USD publish operation.
+     *
+     * @param interfaceName Name of the interface.
+     * @param cmdId An id for this command.
+     * @param publishConfig Publish configuration.
+     * @return true if succeeds otherwise false.
+     */
+    default boolean startUsdPublish(String interfaceName, int cmdId, PublishConfig publishConfig) {
+        return false;
+    }
+
+    /**
+     * Registers USD event callbacks.
+     *
+     * @param usdEventsCallback event callbacks which need to be registered.
+     */
+    default void registerUsdEventsCallback(
+            UsdRequestManager.UsdNativeEventsCallback usdEventsCallback) {}
+
+    /**
+     * Starts USD subscribe operation.
+     *
+     * @param interfaceName Name of the interface.
+     * @param cmdId An id for this command.
+     * @param subscribeConfig Subscribe configuration.
+     * @return true if succeeds otherwise false.
+     */
+    default boolean startUsdSubscribe(String interfaceName, int cmdId,
+            SubscribeConfig subscribeConfig) {
+        return false;
+    }
+
+    /**
+     * Updates an ongoing USD publish operation.
+     *
+     * @param interfaceName Name of the interface.
+     * @param publishId publish id for this session.
+     * @param ssi Service specific info.
+     */
+    default void updateUsdPublish(String interfaceName, int publishId, byte[] ssi) {}
+
+    /**
+     * Cancels an ongoing USD publish.
+     *
+     * @param interfaceName Name of the interface.
+     * @param publishId publish id for the session.
+     */
+    default void cancelUsdPublish(String interfaceName, int publishId) {}
+
+    /**
+     * Cancels an ongoing USD subscribe.
+     *
+     * @param interfaceName Name of the interface.
+     * @param subscribeId Subscribe id for the session.
+     */
+    default void cancelUsdSubscribe(String interfaceName, int subscribeId) {}
+
+    /**
+     * Sends message on a USD publish/subscribe session.
+     *
+     * @param interfaceName Name of the interface.
+     * @param ownId Id for the session.
+     * @param peerId Id for the peer session.
+     * @param peerMacAddress Mac address of the peer session.
+     * @param message Bytes of data to send.
+     * @return true if succeeds otherwise false.
+     */
+    default boolean sendUsdMessage(String interfaceName, int ownId, int peerId,
+            MacAddress peerMacAddress,
+            byte[] message) {
+        return false;
+    }
 }
diff --git a/service/java/com/android/server/wifi/LastMileLogger.java b/service/java/com/android/server/wifi/LastMileLogger.java
index 0c9c0addcf..49c506ed62 100644
--- a/service/java/com/android/server/wifi/LastMileLogger.java
+++ b/service/java/com/android/server/wifi/LastMileLogger.java
@@ -17,6 +17,7 @@
 package com.android.server.wifi;
 
 
+import android.os.Handler;
 import android.util.ArrayMap;
 
 import com.android.internal.annotations.VisibleForTesting;
@@ -34,7 +35,9 @@ import java.util.Map;
  * Provides a facility for capturing kernel trace events related to Wifi control and data paths.
  */
 public class LastMileLogger {
-    public LastMileLogger(WifiInjector injector) {
+    private final Handler mBackgroundHandler;
+    public LastMileLogger(WifiInjector injector, Handler handler) {
+        mBackgroundHandler = handler;
         File tracefsEnablePath = new File(WIFI_EVENT_ENABLE_PATH);
         if (tracefsEnablePath.exists()) {
             initLastMileLogger(injector, WIFI_EVENT_BUFFER_PATH, WIFI_EVENT_ENABLE_PATH,
@@ -47,7 +50,8 @@ public class LastMileLogger {
 
     @VisibleForTesting
     public LastMileLogger(WifiInjector injector, String bufferPath, String enablePath,
-                          String releasePath) {
+                          String releasePath, Handler handler) {
+        mBackgroundHandler = handler;
         initLastMileLogger(injector, bufferPath, enablePath, releasePath);
     }
 
@@ -62,16 +66,17 @@ public class LastMileLogger {
 
         boolean shouldTracingBeEnabled = anyConnectionInProgress();
 
-        if (!wasTracingEnabled && shouldTracingBeEnabled) {
-            enableTracing();
-        } else if (wasTracingEnabled && !shouldTracingBeEnabled) {
-            disableTracing();
-        }
-
-        if (event == WifiDiagnostics.CONNECTION_EVENT_FAILED
-                || event == WifiDiagnostics.CONNECTION_EVENT_TIMEOUT) {
-            mLastMileLogForLastFailure = readTrace();
-        }
+        mBackgroundHandler.post(() -> {
+            if (!wasTracingEnabled && shouldTracingBeEnabled) {
+                enableTracing();
+            } else if (wasTracingEnabled && !shouldTracingBeEnabled) {
+                disableTracing();
+            }
+            if (event == WifiDiagnostics.CONNECTION_EVENT_FAILED
+                    || event == WifiDiagnostics.CONNECTION_EVENT_TIMEOUT) {
+                mLastMileLogForLastFailure = readTrace();
+            }
+        });
     }
 
     private boolean anyConnectionInProgress() {
diff --git a/service/java/com/android/server/wifi/MboOceController.java b/service/java/com/android/server/wifi/MboOceController.java
index 35b1965959..6301d66233 100644
--- a/service/java/com/android/server/wifi/MboOceController.java
+++ b/service/java/com/android/server/wifi/MboOceController.java
@@ -62,7 +62,7 @@ public class MboOceController {
         if (clientModeManager == null) {
             return;
         }
-        BitSet supportedFeatures = clientModeManager.getSupportedFeatures();
+        BitSet supportedFeatures = clientModeManager.getSupportedFeaturesBitSet();
         mIsMboSupported = supportedFeatures.get(WIFI_FEATURE_MBO);
         mIsOceSupported = supportedFeatures.get(WIFI_FEATURE_OCE);
         mEnabled = true;
diff --git a/service/java/com/android/server/wifi/MultiInternetWifiNetworkFactory.java b/service/java/com/android/server/wifi/MultiInternetWifiNetworkFactory.java
index cb149b7bc5..88aa3c6e29 100644
--- a/service/java/com/android/server/wifi/MultiInternetWifiNetworkFactory.java
+++ b/service/java/com/android/server/wifi/MultiInternetWifiNetworkFactory.java
@@ -182,7 +182,8 @@ public class MultiInternetWifiNetworkFactory extends NetworkFactory {
         NetworkRequestState nrs = new NetworkRequestState(networkRequest,
                 new WifiNetworkSpecifier(
                 wns.ssidPatternMatcher, wns.bssidPatternMatcher, wns.getBand(),
-                wns.wifiConfiguration, wns.getPreferredChannelFrequenciesMhz()),
+                wns.wifiConfiguration, wns.getPreferredChannelFrequenciesMhz(),
+                        wns.isPreferSecondarySta()),
                 isFromSetting,
                 isFromForegroundApp,
                 isFromForegroundAppOrService);
diff --git a/service/java/com/android/server/wifi/NetworkUpdateResult.java b/service/java/com/android/server/wifi/NetworkUpdateResult.java
index 78ee193ecb..0dec54577a 100644
--- a/service/java/com/android/server/wifi/NetworkUpdateResult.java
+++ b/service/java/com/android/server/wifi/NetworkUpdateResult.java
@@ -22,6 +22,8 @@ import static android.net.wifi.WifiManager.AddNetworkResult.STATUS_SUCCESS;
 
 import android.net.wifi.WifiManager;
 
+import androidx.annotation.Keep;
+
 import java.util.Objects;
 
 public class NetworkUpdateResult {
@@ -32,6 +34,7 @@ public class NetworkUpdateResult {
     private final boolean mIsNewNetwork;
     private final @WifiManager.AddNetworkResult.AddNetworkStatusCode int mStatusCode;
 
+    @Keep
     public NetworkUpdateResult(int netId) {
         this(netId, netId != INVALID_NETWORK_ID ? STATUS_SUCCESS : STATUS_ADD_WIFI_CONFIG_FAILURE,
                 false, false, false, false);
@@ -61,6 +64,7 @@ public class NetworkUpdateResult {
         return new NetworkUpdateResult(INVALID_NETWORK_ID);
     }
 
+    @Keep
     public int getNetworkId() {
         return mNetId;
     }
@@ -81,6 +85,7 @@ public class NetworkUpdateResult {
         return mIsNewNetwork;
     }
 
+    @Keep
     public boolean isSuccess() {
         return mStatusCode == STATUS_SUCCESS;
     }
diff --git a/service/java/com/android/server/wifi/SarManager.java b/service/java/com/android/server/wifi/SarManager.java
index a454dfe96c..9d6a992f57 100644
--- a/service/java/com/android/server/wifi/SarManager.java
+++ b/service/java/com/android/server/wifi/SarManager.java
@@ -72,7 +72,7 @@ public class SarManager {
     private static final String TAG = "WifiSarManager";
     private boolean mVerboseLoggingEnabled = true;
 
-    private SarInfo mSarInfo;
+    private final SarInfo mSarInfo;
 
     /* Configuration for SAR support */
     private boolean mSupportSarTxPowerLimit;
@@ -106,6 +106,7 @@ public class SarManager {
         mAudioManager = mContext.getSystemService(AudioManager.class);
         mHandler = new Handler(looper);
         mPhoneStateListener = new WifiPhoneStateListener(looper);
+        mSarInfo = new SarInfo();
         wifiDeviceStateChangeManager.registerStateChangeCallback(
                 new WifiDeviceStateChangeManager.StateChangeCallback() {
                     @Override
@@ -121,9 +122,9 @@ public class SarManager {
     public void handleBootCompleted() {
         readSarConfigs();
         if (mSupportSarTxPowerLimit) {
-            mSarInfo = new SarInfo();
             setSarConfigsInInfo();
             registerListeners();
+            updateSarScenario();
         }
     }
 
@@ -302,11 +303,6 @@ public class SarManager {
      */
     public void setClientWifiState(int state) {
         boolean newIsEnabled;
-        /* No action is taken if SAR is not supported */
-        if (!mSupportSarTxPowerLimit) {
-            return;
-        }
-
         if (state == WifiManager.WIFI_STATE_DISABLED) {
             newIsEnabled = false;
         } else if (state == WifiManager.WIFI_STATE_ENABLED) {
@@ -328,10 +324,6 @@ public class SarManager {
      */
     public void setSapWifiState(int state) {
         boolean newIsEnabled;
-        /* No action is taken if SAR is not supported */
-        if (!mSupportSarTxPowerLimit) {
-            return;
-        }
 
         if (state == WifiManager.WIFI_AP_STATE_DISABLED) {
             newIsEnabled = false;
@@ -354,10 +346,6 @@ public class SarManager {
      */
     public void setScanOnlyWifiState(int state) {
         boolean newIsEnabled;
-        /* No action is taken if SAR is not supported */
-        if (!mSupportSarTxPowerLimit) {
-            return;
-        }
 
         if (state == WifiManager.WIFI_STATE_DISABLED) {
             newIsEnabled = false;
@@ -459,6 +447,10 @@ public class SarManager {
      * Update HAL with the new SAR scenario if needed.
      */
     private void updateSarScenario() {
+        /* No action is taken if SAR is not supported */
+        if (!mSupportSarTxPowerLimit) {
+            return;
+        }
         if (!mSarInfo.shouldReport()) {
             return;
         }
diff --git a/service/java/com/android/server/wifi/ScanDetail.java b/service/java/com/android/server/wifi/ScanDetail.java
index fa5148654c..2858d9a215 100644
--- a/service/java/com/android/server/wifi/ScanDetail.java
+++ b/service/java/com/android/server/wifi/ScanDetail.java
@@ -20,6 +20,7 @@ import android.net.wifi.AnqpInformationElement;
 import android.net.wifi.ScanResult;
 import android.net.wifi.WifiSsid;
 
+import androidx.annotation.Keep;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
@@ -183,6 +184,7 @@ public class ScanDetail {
         }
     }
 
+    @Keep
     public ScanResult getScanResult() {
         return mScanResult;
     }
diff --git a/service/java/com/android/server/wifi/ScanDetailCache.java b/service/java/com/android/server/wifi/ScanDetailCache.java
index 90dd4d060f..dcfb423ab5 100644
--- a/service/java/com/android/server/wifi/ScanDetailCache.java
+++ b/service/java/com/android/server/wifi/ScanDetailCache.java
@@ -20,6 +20,8 @@ import android.annotation.NonNull;
 import android.net.wifi.ScanResult;
 import android.net.wifi.WifiConfiguration;
 
+import androidx.annotation.Keep;
+
 import com.android.server.wifi.hotspot2.NetworkDetail;
 
 import java.util.ArrayList;
@@ -93,6 +95,7 @@ public class ScanDetailCache {
         mMap.remove(bssid);
     }
 
+    @Keep
     int size() {
         return mMap.size();
     }
@@ -105,6 +108,7 @@ public class ScanDetailCache {
         return mMap.keySet();
     }
 
+    @Keep
     Collection<ScanDetail> values() {
         return mMap.values();
     }
diff --git a/service/java/com/android/server/wifi/ScanOnlyModeImpl.java b/service/java/com/android/server/wifi/ScanOnlyModeImpl.java
index 1946652a21..c0b58e7b50 100644
--- a/service/java/com/android/server/wifi/ScanOnlyModeImpl.java
+++ b/service/java/com/android/server/wifi/ScanOnlyModeImpl.java
@@ -42,7 +42,7 @@ public class ScanOnlyModeImpl implements ClientModeDefaults {
     }
 
     @Override
-    public @NonNull BitSet getSupportedFeatures() {
+    public @NonNull BitSet getSupportedFeaturesBitSet() {
         return mWifiNative.getSupportedFeatureSet(mIfaceName);
     }
 
diff --git a/service/java/com/android/server/wifi/ScanRequestProxy.java b/service/java/com/android/server/wifi/ScanRequestProxy.java
index 38cf93767a..72609b08c4 100644
--- a/service/java/com/android/server/wifi/ScanRequestProxy.java
+++ b/service/java/com/android/server/wifi/ScanRequestProxy.java
@@ -41,6 +41,8 @@ import android.util.Log;
 import android.util.LruCache;
 import android.util.Pair;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.modules.utils.build.SdkLevel;
@@ -569,6 +571,7 @@ public class ScanRequestProxy {
      * a list of {@link ScanResult} objects.
      * @return the list of results
      */
+    @Keep
     public List<ScanResult> getScanResults() {
         // return a copy to prevent external modification
         return new ArrayList<>(combineScanResultsCache().values());
diff --git a/service/java/com/android/server/wifi/SoftApManager.java b/service/java/com/android/server/wifi/SoftApManager.java
index 1f8c280582..828b3114ad 100644
--- a/service/java/com/android/server/wifi/SoftApManager.java
+++ b/service/java/com/android/server/wifi/SoftApManager.java
@@ -226,6 +226,9 @@ public class SoftApManager implements ActiveModeManager {
     // Whether this SoftApManager (i.e. this AP interface) is using multiple link operation.
     private boolean mIsUsingMlo = false;
 
+    private int mMaximumNumberOfMLDSupported;
+    private int mCurrentExistingMLD;
+
     /**
      * The specified configuration passed in during initialization or during a configuration update
      * that doesn't require a restart.
@@ -243,6 +246,10 @@ public class SoftApManager implements ActiveModeManager {
      */
     @Nullable
     private SoftApConfiguration mCurrentSoftApConfiguration;
+    /**
+     * Whether the configuration being used is the user's persistent SoftApConfiguration.
+     */
+    private boolean mIsUsingPersistentSoftApConfiguration = false;
 
     @NonNull
     private Map<String, SoftApInfo> mCurrentSoftApInfoMap = new HashMap<>();
@@ -293,6 +300,8 @@ public class SoftApManager implements ActiveModeManager {
 
     private boolean mIsSoftApStartedEventWritten = false;
 
+    private int mMaxConnectedClients = 0;
+
     /**
      * A map stores shutdown timeouts for each Soft Ap instance.
      * There are three timeout messages now.
@@ -328,7 +337,8 @@ public class SoftApManager implements ActiveModeManager {
         public void onInfoChanged(String apIfaceInstance, int frequency,
                 @WifiAnnotations.Bandwidth int bandwidth,
                 @WifiAnnotations.WifiStandard int generation,
-                MacAddress apIfaceInstanceMacAddress,
+                @Nullable MacAddress apIfaceInstanceMacAddress,
+                @Nullable MacAddress mldAddress,
                 @NonNull List<OuiKeyedData> vendorData) {
             SoftApInfo apInfo = new SoftApInfo();
             apInfo.setFrequency(frequency);
@@ -337,6 +347,9 @@ public class SoftApManager implements ActiveModeManager {
             if (apIfaceInstanceMacAddress != null) {
                 apInfo.setBssid(apIfaceInstanceMacAddress);
             }
+            if (mldAddress != null) {
+                apInfo.setMldAddress(mldAddress);
+            }
             apInfo.setApInstanceIdentifier(apIfaceInstance != null
                     ? apIfaceInstance : mApInterfaceName);
             if (SdkLevel.isAtLeastV() && vendorData != null && !vendorData.isEmpty()) {
@@ -481,9 +494,11 @@ public class SoftApManager implements ActiveModeManager {
         mWifiApConfigStore = wifiApConfigStore;
         mCurrentSoftApConfiguration = apConfig.getSoftApConfiguration();
         mCurrentSoftApCapability = apConfig.getCapability();
+
         // null is a valid input and means we use the user-configured tethering settings.
         if (mCurrentSoftApConfiguration == null) {
             mCurrentSoftApConfiguration = mWifiApConfigStore.getApConfiguration();
+            mIsUsingPersistentSoftApConfiguration = true;
             // may still be null if we fail to load the default config
         }
         // Store mode configuration before update the configuration.
@@ -523,6 +538,9 @@ public class SoftApManager implements ActiveModeManager {
         mRole = role;
         // chip support it && overlay configuration is set.
         mIsMLDApSupportMLO = mWifiNative.isMLDApSupportMLO();
+        mMaximumNumberOfMLDSupported = ApConfigUtil.getMaximumSupportedMLD(
+                mContext, mWifiNative.isMultipleMLDSupportedOnSap());
+        mCurrentExistingMLD = mActiveModeWarden.getCurrentMLDAp();
         mIsUsingMlo = useMultilinkMloSoftAp();
         enableVerboseLogging(verboseLoggingEnabled);
         mStateMachine.sendMessage(SoftApStateMachine.CMD_START, requestorWs);
@@ -558,12 +576,10 @@ public class SoftApManager implements ActiveModeManager {
                 && mCurrentSoftApConfiguration.isIeee80211beEnabled()
                 && isBridgedMode() && mIsMLDApSupportMLO) {
 
-            int currentExistingMLD =
-                    mActiveModeWarden.getCurrentMLDAp();
             if (ApConfigUtil.is11beAllowedForThisConfiguration(
                     null /* Wiphy capability can be ignored for MLO case*/,
                     mContext, mCurrentSoftApConfiguration, true /* isBridgedMode */,
-                    currentExistingMLD,
+                    mMaximumNumberOfMLDSupported, mCurrentExistingMLD,
                     true /* isMLDApSupportMLO */)) {
                 return true;
             }
@@ -1275,8 +1291,8 @@ public class SoftApManager implements ActiveModeManager {
                                                 .setBand(newSingleApBand)
                                                 .build();
                             }
-                        } else if (!isCountryCodeChanged
-                                && mRole == ROLE_SOFTAP_TETHERED && isBridgedApAvailable()) {
+                        } else if (!isCountryCodeChanged && isBridgedApAvailable()
+                                && mIsUsingPersistentSoftApConfiguration) {
                             // Try upgrading config to 2 + 5 GHz Dual Band if the available config
                             // bands only include 2 or 5 Ghz. This is to handle cases where the
                             // config was previously set to single band in a CC that didn't support
@@ -1340,11 +1356,9 @@ public class SoftApManager implements ActiveModeManager {
                             DeviceWiphyCapabilities capabilities =
                                     mWifiNative.getDeviceWiphyCapabilities(
                                             mApInterfaceName, isBridgeRequired());
-                            int currentExistingMLD =
-                                    mActiveModeWarden.getCurrentMLDAp();
                             if (!ApConfigUtil.is11beAllowedForThisConfiguration(capabilities,
                                     mContext, mCurrentSoftApConfiguration, isBridgedMode(),
-                                    currentExistingMLD,
+                                    mMaximumNumberOfMLDSupported, mCurrentExistingMLD,
                                     mIsMLDApSupportMLO)) {
                                 Log.d(getTag(), "11BE is not allowed,"
                                         + " removing from configuration");
@@ -1508,7 +1522,7 @@ public class SoftApManager implements ActiveModeManager {
                                     mCurrentSoftApCapability, mContext, mWifiNative, null);
                     updateSafeChannelFrequencyList();
                     int[] oldBands = mCurrentSoftApConfiguration.getBands();
-                    if (mRole == ROLE_SOFTAP_TETHERED && isBridgedApAvailable()) {
+                    if (isBridgedApAvailable() && mIsUsingPersistentSoftApConfiguration) {
                         mCurrentSoftApConfiguration =
                                 ApConfigUtil.upgradeTo2g5gBridgedIfAvailableBandsAreSubset(
                                         mCurrentSoftApConfiguration,
@@ -1630,7 +1644,7 @@ public class SoftApManager implements ActiveModeManager {
                             + mCurrentSoftApInfoMap.get(instanceName).getFrequency()
                             + ") from bridged iface " + mApInterfaceName);
                     mWifiNative.removeIfaceInstanceFromBridgedApIface(mApInterfaceName,
-                            instanceName);
+                            instanceName, mIsUsingMlo);
                     // Remove the info and update it.
                     updateSoftApInfo(mCurrentSoftApInfoMap.get(instanceName), true);
                 }
@@ -1765,6 +1779,8 @@ public class SoftApManager implements ActiveModeManager {
                     boolean isAllow = checkSoftApClient(mCurrentSoftApConfiguration, client);
                     if (isAllow) {
                         clientList.add(client);
+                        mMaxConnectedClients = clientList.size() > mMaxConnectedClients
+                                ? clientList.size() : mMaxConnectedClients;
                     } else {
                         return;
                     }
@@ -1785,6 +1801,8 @@ public class SoftApManager implements ActiveModeManager {
                 if (mSoftApCallback != null) {
                     if (Flags.softapDisconnectReason() && !isConnected) {
                         // Client successfully disconnected, should also notify callback
+                        mWifiMetrics.reportOnClientsDisconnected(client.getDisconnectReason(),
+                                mRequestorWs);
                         mSoftApCallback.onClientsDisconnected(
                                 currentInfoWithClientsChanged,
                                 ImmutableList.of(client));
@@ -2420,7 +2438,7 @@ public class SoftApManager implements ActiveModeManager {
                 durationSeconds,
                 securityType,
                 standard,
-                -1,
+                mMaxConnectedClients,
                 mDefaultShutdownIdleInstanceInBridgedModeTimeoutMillis > 0,
                 -1,
                 -1,
diff --git a/service/java/com/android/server/wifi/SupplicantStaIfaceCallbackAidlImpl.java b/service/java/com/android/server/wifi/SupplicantStaIfaceCallbackAidlImpl.java
index 0d2f958f16..3b499c2173 100644
--- a/service/java/com/android/server/wifi/SupplicantStaIfaceCallbackAidlImpl.java
+++ b/service/java/com/android/server/wifi/SupplicantStaIfaceCallbackAidlImpl.java
@@ -29,6 +29,7 @@ import static com.android.server.wifi.hotspot2.anqp.Constants.ANQPElementType.HS
 import static com.android.server.wifi.hotspot2.anqp.Constants.ANQPElementType.HSWANMetrics;
 
 import android.annotation.NonNull;
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.hardware.wifi.supplicant.AnqpData;
 import android.hardware.wifi.supplicant.AssociationRejectionData;
@@ -58,6 +59,7 @@ import android.hardware.wifi.supplicant.StaIfaceStatusCode;
 import android.hardware.wifi.supplicant.SupplicantStateChangeData;
 import android.hardware.wifi.supplicant.UsdMessageInfo;
 import android.hardware.wifi.supplicant.UsdServiceDiscoveryInfo;
+import android.hardware.wifi.supplicant.UsdTerminateReasonCode;
 import android.hardware.wifi.supplicant.WpsConfigError;
 import android.hardware.wifi.supplicant.WpsErrorIndication;
 import android.net.MacAddress;
@@ -66,6 +68,8 @@ import android.net.wifi.SupplicantState;
 import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiManager;
 import android.net.wifi.WifiSsid;
+import android.net.wifi.usd.SessionCallback;
+import android.os.Handler;
 import android.os.Process;
 import android.util.Log;
 
@@ -77,6 +81,7 @@ import com.android.server.wifi.hotspot2.WnmData;
 import com.android.server.wifi.hotspot2.anqp.ANQPElement;
 import com.android.server.wifi.hotspot2.anqp.ANQPParser;
 import com.android.server.wifi.hotspot2.anqp.Constants;
+import com.android.server.wifi.usd.UsdRequestManager;
 import com.android.server.wifi.util.HalAidlUtil;
 import com.android.server.wifi.util.NativeUtil;
 
@@ -103,17 +108,19 @@ class SupplicantStaIfaceCallbackAidlImpl extends ISupplicantStaIfaceCallback.Stu
     // Current SSID in WifiSsid.toString() format. May be translated to UTF-8 if SSID translation
     // is enabled.
     private String mCurrentSsid = null;
+    private final Handler mEventHandler;
 
     SupplicantStaIfaceCallbackAidlImpl(@NonNull SupplicantStaIfaceHalAidlImpl staIfaceHal,
             @NonNull String ifaceName, @NonNull Object lock,
             @NonNull Context context, @NonNull WifiMonitor wifiMonitor,
-            @NonNull SsidTranslator ssidTranslator) {
+            @NonNull SsidTranslator ssidTranslator, Handler eventHandler) {
         mStaIfaceHal = staIfaceHal;
         mIfaceName = ifaceName;
         mLock = lock;
         mContext = context;
         mWifiMonitor = wifiMonitor;
         mSsidTranslator = ssidTranslator;
+        mEventHandler = eventHandler;
     }
 
     @Override
@@ -672,31 +679,147 @@ class SupplicantStaIfaceCallbackAidlImpl extends ISupplicantStaIfaceCallback.Stu
     }
 
     @Override
-    public void onUsdPublishStarted(int cmdId, int publishId) { }
+    public void onUsdPublishStarted(int cmdId, int publishId) {
+        mEventHandler.post(() -> {
+            if (mStaIfaceHal.getUsdEventsCallback() == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            mStaIfaceHal.getUsdEventsCallback().onUsdPublishStarted(cmdId, publishId);
+        });
+    }
 
     @Override
-    public void onUsdSubscribeStarted(int cmdId, int subscribeId) { }
+    public void onUsdSubscribeStarted(int cmdId, int subscribeId) {
+        mEventHandler.post(() -> {
+            if (mStaIfaceHal.getUsdEventsCallback() == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            mStaIfaceHal.getUsdEventsCallback().onUsdSubscribeStarted(cmdId, subscribeId);
+        });
+    }
 
     @Override
-    public void onUsdPublishConfigFailed(int cmdId) { }
+    public void onUsdPublishConfigFailed(int cmdId, int errorCode) {
+        mEventHandler.post(() -> {
+            if (mStaIfaceHal.getUsdEventsCallback() == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            mStaIfaceHal.getUsdEventsCallback().onUsdPublishConfigFailed(cmdId,
+                    convertHalToFrameworkUsdConfigErrorCode(errorCode));
+        });
+    }
 
     @Override
-    public void onUsdSubscribeConfigFailed(int cmdId) { }
+    public void onUsdSubscribeConfigFailed(int cmdId, int errorCode) {
+        mEventHandler.post(() -> {
+            if (mStaIfaceHal.getUsdEventsCallback() == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            mStaIfaceHal.getUsdEventsCallback().onUsdSubscribeConfigFailed(cmdId,
+                    convertHalToFrameworkUsdConfigErrorCode(errorCode));
+        });
+    }
 
     @Override
-    public void onUsdPublishTerminated(int publishId, int reasonCode) { }
+    public void onUsdPublishTerminated(int publishId, int reasonCode) {
+        mEventHandler.post(() -> {
+            if (mStaIfaceHal.getUsdEventsCallback() == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            mStaIfaceHal.getUsdEventsCallback().onUsdPublishTerminated(publishId,
+                    convertHalToFrameworkTerminateReasonCode(reasonCode));
+        });
+    }
+
+    private int convertHalToFrameworkTerminateReasonCode(int usdHalReasonCode) {
+        switch (usdHalReasonCode) {
+            case UsdTerminateReasonCode.USER_REQUEST:
+                return SessionCallback.TERMINATION_REASON_USER_INITIATED;
+            default:
+                return SessionCallback.TERMINATION_REASON_UNKNOWN;
+        }
+    }
+
+    @SuppressLint("NewApi")
+    private static @SessionCallback.FailureCode int
+            convertHalToFrameworkUsdConfigErrorCode(int errorCode) {
+        switch (errorCode) {
+            case UsdConfigErrorCode.FAILURE_TIMEOUT:
+                return SessionCallback.FAILURE_TIMEOUT;
+            case UsdConfigErrorCode.FAILURE_NOT_AVAILABLE:
+                return SessionCallback.FAILURE_NOT_AVAILABLE;
+            default:
+                return SessionCallback.FAILURE_UNKNOWN;
+        }
+    }
 
     @Override
-    public void onUsdSubscribeTerminated(int subscribeId, int reasonCode) { }
+    public void onUsdSubscribeTerminated(int subscribeId, int reasonCode) {
+        mEventHandler.post(() -> {
+            if (mStaIfaceHal.getUsdEventsCallback() == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            mStaIfaceHal.getUsdEventsCallback().onUsdSubscribeTerminated(subscribeId,
+                    convertHalToFrameworkTerminateReasonCode(reasonCode));
+        });
+    }
 
     @Override
-    public void onUsdPublishReplied(UsdServiceDiscoveryInfo info) { }
+    public void onUsdPublishReplied(UsdServiceDiscoveryInfo info) {
+        mEventHandler.post(() -> {
+            if (mStaIfaceHal.getUsdEventsCallback() == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            UsdRequestManager.UsdHalDiscoveryInfo usdHalDiscoveryInfo =
+                    new UsdRequestManager.UsdHalDiscoveryInfo(info.ownId,
+                            info.peerId,
+                            MacAddress.fromBytes(info.peerMacAddress),
+                            info.serviceSpecificInfo,
+                            info.protoType,
+                            info.isFsd,
+                            info.matchFilter);
+            mStaIfaceHal.getUsdEventsCallback().onUsdPublishReplied(usdHalDiscoveryInfo);
+        });
+    }
 
     @Override
-    public void onUsdServiceDiscovered(UsdServiceDiscoveryInfo info) { }
+    public void onUsdServiceDiscovered(UsdServiceDiscoveryInfo info) {
+        mEventHandler.post(() -> {
+            if (mStaIfaceHal.getUsdEventsCallback() == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            UsdRequestManager.UsdHalDiscoveryInfo usdHalDiscoveryInfo =
+                    new UsdRequestManager.UsdHalDiscoveryInfo(info.ownId,
+                            info.peerId,
+                            MacAddress.fromBytes(info.peerMacAddress),
+                            info.serviceSpecificInfo,
+                            info.protoType,
+                            info.isFsd,
+                            info.matchFilter);
+            mStaIfaceHal.getUsdEventsCallback().onUsdServiceDiscovered(usdHalDiscoveryInfo);
+        });
+    }
 
     @Override
-    public void onUsdMessageReceived(UsdMessageInfo messageInfo) { }
+    public void onUsdMessageReceived(UsdMessageInfo messageInfo) {
+        mEventHandler.post(() -> {
+            if (mStaIfaceHal.getUsdEventsCallback() == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            mStaIfaceHal.getUsdEventsCallback().onUsdMessageReceived(messageInfo.ownId,
+                    messageInfo.peerId, MacAddress.fromBytes(messageInfo.peerMacAddress),
+                    messageInfo.message);
+        });
+    }
 
     private @MboOceConstants.BtmResponseStatus int halToFrameworkBtmResponseStatus(int status) {
         switch (status) {
diff --git a/service/java/com/android/server/wifi/SupplicantStaIfaceHal.java b/service/java/com/android/server/wifi/SupplicantStaIfaceHal.java
index 72b47f1ce2..38b217ab93 100644
--- a/service/java/com/android/server/wifi/SupplicantStaIfaceHal.java
+++ b/service/java/com/android/server/wifi/SupplicantStaIfaceHal.java
@@ -23,11 +23,14 @@ import android.net.wifi.MscsParams;
 import android.net.wifi.QosPolicyParams;
 import android.net.wifi.SecurityParams;
 import android.net.wifi.WifiConfiguration;
+import android.net.wifi.usd.PublishConfig;
+import android.net.wifi.usd.SubscribeConfig;
 import android.os.Handler;
 import android.util.Log;
 import android.util.Range;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.wifi.usd.UsdRequestManager;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -2416,4 +2419,163 @@ public class SupplicantStaIfaceHal {
         Log.e(TAG, "Cannot call " + methodStr + " because HAL object is null.");
         return false;
     }
+
+    public static class UsdCapabilitiesInternal {
+        /** Whether USD Publisher is supported on this device. */
+        public boolean isUsdPublisherSupported;
+        /** Whether USD Subscriber is supported on this device. */
+        public final boolean isUsdSubscriberSupported;
+        /** Maximum allowed length (in bytes) for the Service Specific Info (SSI). */
+        public final int maxLocalSsiLengthBytes;
+        /** Maximum allowed length (in bytes) for the service name. */
+        public final int maxServiceNameLengthBytes;
+        /** Maximum allowed length (in bytes) for a match filter. */
+        public final int maxMatchFilterLengthBytes;
+        /** Maximum number of allowed publish sessions. */
+        public final int maxNumPublishSessions;
+        /** Maximum number of allowed subscribe sessions. */
+        public final int maxNumSubscribeSessions;
+
+        public UsdCapabilitiesInternal(boolean isUsdPublisherSupported,
+                boolean isUsdSubscriberSupported,
+                int maxLocalSsiLengthBytes, int maxServiceNameLengthBytes,
+                int maxMatchFilterLengthBytes,
+                int maxNumPublishSessions, int maxNumSubscribeSessions) {
+            this.isUsdPublisherSupported = isUsdPublisherSupported;
+            this.isUsdSubscriberSupported = isUsdSubscriberSupported;
+            this.maxLocalSsiLengthBytes = maxLocalSsiLengthBytes;
+            this.maxServiceNameLengthBytes = maxServiceNameLengthBytes;
+            this.maxMatchFilterLengthBytes = maxMatchFilterLengthBytes;
+            this.maxNumPublishSessions = maxNumPublishSessions;
+            this.maxNumSubscribeSessions = maxNumSubscribeSessions;
+        }
+
+        public UsdCapabilitiesInternal() {
+            this.isUsdPublisherSupported = false;
+            this.isUsdSubscriberSupported = false;
+            this.maxLocalSsiLengthBytes = 0;
+            this.maxServiceNameLengthBytes = 0;
+            this.maxMatchFilterLengthBytes = 0;
+            this.maxNumPublishSessions = 0;
+            this.maxNumSubscribeSessions = 0;
+        }
+    }
+
+    /**
+     * See comments for {@link ISupplicantStaIfaceHal#getUsdCapabilities(String)}
+     */
+    public UsdCapabilitiesInternal getUsdCapabilities(String ifaceName) {
+        synchronized (mLock) {
+            String methodStr = "getUsdCapabilities";
+            if (mStaIfaceHal == null) {
+                handleNullHal(methodStr);
+                return null;
+            }
+            return mStaIfaceHal.getUsdCapabilities(ifaceName);
+        }
+    }
+
+    /**
+     * See comments for {@link ISupplicantStaIfaceHal#startUsdPublish(String, int, PublishConfig)}
+     */
+    public boolean startUsdPublish(String interfaceName, int cmdId, PublishConfig publishConfig) {
+        synchronized (mLock) {
+            String methodStr = "startUsdPublish";
+            if (mStaIfaceHal == null) {
+                handleNullHal(methodStr);
+                return false;
+            }
+            return mStaIfaceHal.startUsdPublish(interfaceName, cmdId, publishConfig);
+        }
+    }
+
+    /**
+     * See comments for
+     * {@link WifiNative#registerUsdEventsCallback(UsdRequestManager.UsdNativeEventsCallback)}
+     */
+    public void registerUsdEventsCallback(
+            UsdRequestManager.UsdNativeEventsCallback usdNativeEventsCallback) {
+        synchronized (mLock) {
+            String methodStr = "registerUsdEventsCallback";
+            if (mStaIfaceHal == null) {
+                handleNullHal(methodStr);
+                return;
+            }
+            mStaIfaceHal.registerUsdEventsCallback(usdNativeEventsCallback);
+        }
+    }
+
+    /**
+     * See comments for
+     * {@link ISupplicantStaIfaceHal#startUsdSubscribe(String, int, SubscribeConfig)}
+     */
+    public boolean startUsdSubscribe(String interfaceName, int cmdId,
+            SubscribeConfig subscribeConfig) {
+        synchronized (mLock) {
+            String methodStr = "startUsdSubscribe";
+            if (mStaIfaceHal == null) {
+                handleNullHal(methodStr);
+                return false;
+            }
+            return mStaIfaceHal.startUsdSubscribe(interfaceName, cmdId, subscribeConfig);
+        }
+    }
+
+    /**
+     * See comments for {@link ISupplicantStaIfaceHal#updateUsdPublish(String, int, byte[])}
+     */
+    public void updateUsdPublish(String interfaceName, int publishId, byte[] ssi) {
+        synchronized (mLock) {
+            String methodStr = "updateUsdPublish";
+            if (mStaIfaceHal == null) {
+                handleNullHal(methodStr);
+                return;
+            }
+            mStaIfaceHal.updateUsdPublish(interfaceName, publishId, ssi);
+        }
+    }
+
+    /**
+     * See comments for {@link ISupplicantStaIfaceHal#cancelUsdPublish(String, int)}
+     */
+    public void cancelUsdPublish(String interfaceName, int publishId) {
+        synchronized (mLock) {
+            String methodStr = "cancelUsdPublish";
+            if (mStaIfaceHal == null) {
+                handleNullHal(methodStr);
+                return;
+            }
+            mStaIfaceHal.cancelUsdPublish(interfaceName, publishId);
+        }
+    }
+
+    /**
+     * See {@link ISupplicantStaIfaceHal#cancelUsdSubscribe(String, int)}
+     */
+    public void cancelUsdSubscribe(String interfaceName, int subscribeId) {
+        synchronized (mLock) {
+            String methodStr = "cancelUsdSubscribe";
+            if (mStaIfaceHal == null) {
+                handleNullHal(methodStr);
+                return;
+            }
+            mStaIfaceHal.cancelUsdSubscribe(interfaceName, subscribeId);
+        }
+    }
+
+    /**
+     * See {@link ISupplicantStaIfaceHal#sendUsdMessage(String, int, int, MacAddress, byte[])}
+     */
+    public boolean sendUsdMessage(String interfaceName, int ownId, int peerId,
+            MacAddress peerMacAddress, byte[] message) {
+        synchronized (mLock) {
+            String methodStr = "sendMessage";
+            if (mStaIfaceHal == null) {
+                handleNullHal(methodStr);
+                return false;
+            }
+            return mStaIfaceHal.sendUsdMessage(interfaceName, ownId, peerId, peerMacAddress,
+                    message);
+        }
+    }
 }
diff --git a/service/java/com/android/server/wifi/SupplicantStaIfaceHalAidlImpl.java b/service/java/com/android/server/wifi/SupplicantStaIfaceHalAidlImpl.java
index e11368e222..f9e32f0f66 100644
--- a/service/java/com/android/server/wifi/SupplicantStaIfaceHalAidlImpl.java
+++ b/service/java/com/android/server/wifi/SupplicantStaIfaceHalAidlImpl.java
@@ -35,6 +35,7 @@ import static android.net.wifi.WifiManager.WIFI_FEATURE_WPA3_SAE;
 import static android.net.wifi.WifiManager.WIFI_FEATURE_WPA3_SUITE_B;
 
 import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.content.Context;
 import android.hardware.wifi.supplicant.BtCoexistenceMode;
@@ -74,6 +75,13 @@ import android.hardware.wifi.supplicant.QosPolicyStatusCode;
 import android.hardware.wifi.supplicant.RxFilterType;
 import android.hardware.wifi.supplicant.SignalPollResult;
 import android.hardware.wifi.supplicant.SupplicantStatusCode;
+import android.hardware.wifi.supplicant.UsdBaseConfig;
+import android.hardware.wifi.supplicant.UsdCapabilities;
+import android.hardware.wifi.supplicant.UsdMessageInfo;
+import android.hardware.wifi.supplicant.UsdPublishConfig;
+import android.hardware.wifi.supplicant.UsdPublishTransmissionType;
+import android.hardware.wifi.supplicant.UsdServiceProtoType;
+import android.hardware.wifi.supplicant.UsdSubscribeConfig;
 import android.hardware.wifi.supplicant.WifiChannelWidthInMhz;
 import android.hardware.wifi.supplicant.WifiTechnology;
 import android.hardware.wifi.supplicant.WpaDriverCapabilitiesMask;
@@ -91,6 +99,9 @@ import android.net.wifi.WifiKeystore;
 import android.net.wifi.WifiMigration;
 import android.net.wifi.WifiSsid;
 import android.net.wifi.flags.Flags;
+import android.net.wifi.usd.Config;
+import android.net.wifi.usd.PublishConfig;
+import android.net.wifi.usd.SubscribeConfig;
 import android.net.wifi.util.Environment;
 import android.os.Handler;
 import android.os.IBinder;
@@ -106,12 +117,15 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.modules.utils.HandlerExecutor;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.mockwifi.MockWifiServiceUtil;
+import com.android.server.wifi.usd.UsdNativeManager;
+import com.android.server.wifi.usd.UsdRequestManager;
 import com.android.server.wifi.util.HalAidlUtil;
 import com.android.server.wifi.util.NativeUtil;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.BitSet;
 import java.util.HashMap;
 import java.util.List;
@@ -190,6 +204,13 @@ public class SupplicantStaIfaceHalAidlImpl implements ISupplicantStaIfaceHal {
     @VisibleForTesting
     protected KeystoreMigrationStatusConsumer mKeystoreMigrationStatusConsumer;
 
+    /**
+     * Default implementation of USD events.
+     * {@link UsdRequestManager#registerUsdEventsCallback(UsdRequestManager.UsdNativeEventsCallback)} will override
+     * this default implementation.
+     */
+    private UsdNativeManager.UsdEventsCallback mUsdEventsCallback = null;
+
     private class SupplicantDeathRecipient implements DeathRecipient {
         @Override
         public void binderDied() {
@@ -321,7 +342,7 @@ public class SupplicantStaIfaceHalAidlImpl implements ISupplicantStaIfaceHal {
 
             ISupplicantStaIfaceCallback callback = new SupplicantStaIfaceCallbackAidlImpl(
                     SupplicantStaIfaceHalAidlImpl.this, ifaceName,
-                    new Object(), mContext, mWifiMonitor, mSsidTranslator);
+                    new Object(), mContext, mWifiMonitor, mSsidTranslator, mEventHandler);
             if (registerCallback(iface, callback)) {
                 mISupplicantStaIfaces.put(ifaceName, iface);
                 // Keep callback in a store to avoid recycling by garbage collector
@@ -4138,4 +4159,256 @@ public class SupplicantStaIfaceHalAidlImpl implements ISupplicantStaIfaceHal {
             }
         }
     }
+
+    @Override
+    public SupplicantStaIfaceHal.UsdCapabilitiesInternal getUsdCapabilities(String ifaceName) {
+        synchronized (mLock) {
+            if (!isServiceVersionAtLeast(4)) {
+                return null;
+            }
+            String methodStr = "getUsdCapabilities";
+            ISupplicantStaIface iface = checkStaIfaceAndLogFailure(ifaceName, methodStr);
+            if (iface == null) {
+                return null;
+            }
+            try {
+                UsdCapabilities usdCapabilities = iface.getUsdCapabilities();
+                return new SupplicantStaIfaceHal.UsdCapabilitiesInternal(
+                        usdCapabilities.isUsdPublisherSupported,
+                        usdCapabilities.isUsdSubscriberSupported,
+                        usdCapabilities.maxLocalSsiLengthBytes,
+                        usdCapabilities.maxServiceNameLengthBytes,
+                        usdCapabilities.maxMatchFilterLengthBytes,
+                        usdCapabilities.maxNumPublishSessions,
+                        usdCapabilities.maxNumSubscribeSessions);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            }
+            return null;
+        }
+    }
+
+    @Override
+    public boolean startUsdPublish(String interfaceName, int cmdId, PublishConfig publishConfig) {
+        synchronized (mLock) {
+            if (!isServiceVersionAtLeast(4)) {
+                return false;
+            }
+            String methodStr = "startUsdPublish";
+            ISupplicantStaIface iface = checkStaIfaceAndLogFailure(interfaceName, methodStr);
+            if (iface == null) {
+                return false;
+            }
+            try {
+                iface.startUsdPublish(cmdId, frameworkToHalPublishConfig(publishConfig));
+                return true;
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            }
+            return false;
+        }
+    }
+
+    private UsdPublishConfig frameworkToHalPublishConfig(PublishConfig frameworkConfig) {
+        UsdPublishConfig aidlConfig = new UsdPublishConfig();
+        // USD publisher is always solicited and unsolicited.
+        aidlConfig.publishType = UsdPublishConfig.PublishType.SOLICITED_AND_UNSOLICITED;
+        // USD has FSD enabled always.
+        aidlConfig.isFsd = true;
+        aidlConfig.transmissionType = frameworkToHalTransmissionType(
+                frameworkConfig.getSolicitedTransmissionType());
+        aidlConfig.announcementPeriodMillis = frameworkConfig.getAnnouncementPeriodMillis();
+        aidlConfig.usdBaseConfig = new UsdBaseConfig();
+        aidlConfig.usdBaseConfig.ttlSec = frameworkConfig.getTtlSeconds();
+        int[] freqs = frameworkConfig.getOperatingFrequenciesMhz();
+        aidlConfig.usdBaseConfig.defaultFreqMhz = (freqs == null) ? 2437 : freqs[0];
+        aidlConfig.usdBaseConfig.freqsMhz =
+                (freqs == null || freqs.length <= 1) ? new int[0] : Arrays.copyOfRange(freqs, 1,
+                        freqs.length);
+        aidlConfig.usdBaseConfig.serviceName = Arrays.toString(frameworkConfig.getServiceName());
+        aidlConfig.usdBaseConfig.serviceSpecificInfo =
+                frameworkConfig.getServiceSpecificInfo() != null
+                        ? frameworkConfig.getServiceSpecificInfo() : new byte[0];
+        aidlConfig.usdBaseConfig.rxMatchFilter = frameworkConfig.getRxMatchFilterTlv() != null
+                ? frameworkConfig.getRxMatchFilterTlv() : new byte[0];
+        aidlConfig.usdBaseConfig.txMatchFilter = frameworkConfig.getTxMatchFilterTlv() != null
+                ? frameworkConfig.getTxMatchFilterTlv() : new byte[0];
+        aidlConfig.usdBaseConfig.serviceProtoType = frameworkToHalProtoType(
+                frameworkConfig.getServiceProtoType());
+        return aidlConfig;
+    }
+
+    private static int frameworkToHalTransmissionType(
+            @Config.TransmissionType int transmissionType) {
+        if (transmissionType == Config.TRANSMISSION_TYPE_MULTICAST) {
+            return UsdPublishTransmissionType.MULTICAST;
+        } else {
+            return UsdPublishTransmissionType.UNICAST;
+        }
+    }
+
+    private static int frameworkToHalProtoType(int serviceProtoType) {
+        return switch (serviceProtoType) {
+            case Config.SERVICE_PROTO_TYPE_GENERIC -> UsdServiceProtoType.GENERIC;
+            case Config.SERVICE_PROTO_TYPE_CSA_MATTER -> UsdServiceProtoType.CSA_MATTER;
+            default -> UsdServiceProtoType.UNKNOWN;
+        };
+    }
+
+    @Override
+    public boolean startUsdSubscribe(String interfaceName, int cmdId,
+            SubscribeConfig subscribeConfig) {
+        if (!isServiceVersionAtLeast(4)) {
+            return false;
+        }
+        String methodStr = "startUsdSubscribe";
+        ISupplicantStaIface iface = checkStaIfaceAndLogFailure(interfaceName, methodStr);
+        if (iface == null) {
+            return false;
+        }
+        try {
+            iface.startUsdSubscribe(cmdId, frameworkToHalSubscribeConfig(subscribeConfig));
+            return true;
+        } catch (RemoteException e) {
+            handleRemoteException(e, methodStr);
+        } catch (ServiceSpecificException e) {
+            handleServiceSpecificException(e, methodStr);
+        }
+        return false;
+    }
+
+    private UsdSubscribeConfig frameworkToHalSubscribeConfig(SubscribeConfig frameworkConfig) {
+        UsdSubscribeConfig aidlconfig = new UsdSubscribeConfig();
+        aidlconfig.subscribeType = frameworkToHalSubscriberType(frameworkConfig.getSubscribeType());
+        aidlconfig.queryPeriodMillis = frameworkConfig.getQueryPeriodMillis();
+        aidlconfig.usdBaseConfig = new UsdBaseConfig();
+        aidlconfig.usdBaseConfig.ttlSec = frameworkConfig.getTtlSeconds();
+        int[] freqs = frameworkConfig.getOperatingFrequenciesMhz();
+        aidlconfig.usdBaseConfig.defaultFreqMhz = (freqs == null) ? 2437 : freqs[0];
+        aidlconfig.usdBaseConfig.freqsMhz =
+                (freqs == null || freqs.length <= 1) ? new int[0] : Arrays.copyOfRange(freqs, 1,
+                        freqs.length);
+        aidlconfig.usdBaseConfig.serviceName = Arrays.toString(frameworkConfig.getServiceName());
+        aidlconfig.usdBaseConfig.serviceSpecificInfo =
+                frameworkConfig.getServiceSpecificInfo() != null
+                        ? frameworkConfig.getServiceSpecificInfo() : new byte[0];
+        aidlconfig.usdBaseConfig.rxMatchFilter = frameworkConfig.getRxMatchFilterTlv() != null
+                ? frameworkConfig.getRxMatchFilterTlv() : new byte[0];
+        aidlconfig.usdBaseConfig.txMatchFilter = frameworkConfig.getTxMatchFilterTlv() != null
+                ? frameworkConfig.getTxMatchFilterTlv() : new byte[0];
+        aidlconfig.usdBaseConfig.serviceProtoType = frameworkToHalProtoType(
+                frameworkConfig.getServiceProtoType());
+        return aidlconfig;
+    }
+
+    private byte frameworkToHalSubscriberType(int subscribeType) {
+        if (subscribeType == Config.SUBSCRIBE_TYPE_ACTIVE) {
+            return UsdSubscribeConfig.SubscribeType.ACTIVE_MODE;
+        }
+        return UsdSubscribeConfig.SubscribeType.PASSIVE_MODE;
+    }
+
+    @Override
+    public void updateUsdPublish(String interfaceName, int publishId, byte[] ssi) {
+        if (!isServiceVersionAtLeast(4)) {
+            return;
+        }
+        String methodStr = "updateUsdPublish";
+        ISupplicantStaIface iface = checkStaIfaceAndLogFailure(interfaceName, methodStr);
+        if (iface == null) {
+            return;
+        }
+        try {
+            iface.updateUsdPublish(publishId, ssi);
+        } catch (RemoteException e) {
+            handleRemoteException(e, methodStr);
+        } catch (ServiceSpecificException e) {
+            handleServiceSpecificException(e, methodStr);
+        }
+    }
+
+    @Override
+    public void cancelUsdPublish(String interfaceName, int publishId) {
+        if (!isServiceVersionAtLeast(4)) {
+            return;
+        }
+        String methodStr = "updateUsdPublish";
+        ISupplicantStaIface iface = checkStaIfaceAndLogFailure(interfaceName, methodStr);
+        if (iface == null) {
+            return;
+        }
+        try {
+            iface.cancelUsdPublish(publishId);
+        } catch (RemoteException e) {
+            handleRemoteException(e, methodStr);
+        } catch (ServiceSpecificException e) {
+            handleServiceSpecificException(e, methodStr);
+        }
+    }
+
+    @Override
+    public void cancelUsdSubscribe(String interfaceName, int subscribeId) {
+        if (!isServiceVersionAtLeast(4)) {
+            return;
+        }
+        String methodStr = "cancelUsdSubscribe";
+        ISupplicantStaIface iface = checkStaIfaceAndLogFailure(interfaceName, methodStr);
+        if (iface == null) {
+            return;
+        }
+        try {
+            iface.cancelUsdSubscribe(subscribeId);
+        } catch (RemoteException e) {
+            handleRemoteException(e, methodStr);
+        } catch (ServiceSpecificException e) {
+            handleServiceSpecificException(e, methodStr);
+        }
+    }
+
+    @Override
+    public boolean sendUsdMessage(String interfaceName, int ownId, int peerId,
+            MacAddress peerMacAddress, byte[] message) {
+        if (!isServiceVersionAtLeast(4)) {
+            return false;
+        }
+        String methodStr = "sendUsdMessage";
+        ISupplicantStaIface iface = checkStaIfaceAndLogFailure(interfaceName, methodStr);
+        if (iface == null) {
+            return false;
+        }
+        try {
+            UsdMessageInfo usdMessageInfo = new UsdMessageInfo();
+            usdMessageInfo.ownId = ownId;
+            usdMessageInfo.peerId = peerId;
+            usdMessageInfo.peerMacAddress = peerMacAddress.toByteArray();
+            usdMessageInfo.message = message;
+            iface.sendUsdMessage(usdMessageInfo);
+            return true;
+        } catch (RemoteException e) {
+            handleRemoteException(e, methodStr);
+        } catch (ServiceSpecificException e) {
+            handleServiceSpecificException(e, methodStr);
+        }
+        return false;
+    }
+
+    /**
+     * Register a framework callback to receive USD events.
+     */
+    public void registerUsdEventsCallback(
+            UsdRequestManager.UsdNativeEventsCallback usdEventsCallback) {
+        mUsdEventsCallback = usdEventsCallback;
+    }
+
+    /**
+     * Get USD event callback.
+     */
+    @Nullable
+    public UsdNativeManager.UsdEventsCallback getUsdEventsCallback() {
+        return mUsdEventsCallback;
+    }
 }
diff --git a/service/java/com/android/server/wifi/SupplicantStaNetworkHalAidlImpl.java b/service/java/com/android/server/wifi/SupplicantStaNetworkHalAidlImpl.java
index 4797584cdc..654ae94f62 100644
--- a/service/java/com/android/server/wifi/SupplicantStaNetworkHalAidlImpl.java
+++ b/service/java/com/android/server/wifi/SupplicantStaNetworkHalAidlImpl.java
@@ -3598,6 +3598,8 @@ public class SupplicantStaNetworkHalAidlImpl {
         synchronized (mLock) {
             if (!config.isSecurityType(WifiConfiguration.SECURITY_TYPE_PSK)
                     || !config.getSecurityParams(WifiConfiguration.SECURITY_TYPE_PSK).isEnabled()
+                    || (config.preSharedKey.length() == 64
+                    && config.preSharedKey.matches("[0-9A-Fa-f]{64}"))
                     || !mWifiGlobals.isWpa3SaeUpgradeOffloadEnabled()) {
                 return keyManagementFlags;
             }
diff --git a/service/java/com/android/server/wifi/SupplicantStaNetworkHalHidlImpl.java b/service/java/com/android/server/wifi/SupplicantStaNetworkHalHidlImpl.java
index 4a96230367..975fc10af4 100644
--- a/service/java/com/android/server/wifi/SupplicantStaNetworkHalHidlImpl.java
+++ b/service/java/com/android/server/wifi/SupplicantStaNetworkHalHidlImpl.java
@@ -3853,6 +3853,8 @@ public class SupplicantStaNetworkHalHidlImpl {
         synchronized (mLock) {
             if (!config.isSecurityType(WifiConfiguration.SECURITY_TYPE_PSK)
                     || !config.getSecurityParams(WifiConfiguration.SECURITY_TYPE_PSK).isEnabled()
+                    || (config.preSharedKey.length() == 64
+                    && config.preSharedKey.matches("[0-9A-Fa-f]{64}"))
                     || !mWifiGlobals.isWpa3SaeUpgradeOffloadEnabled()) {
                 return keyManagementFlags;
             }
diff --git a/service/java/com/android/server/wifi/ThroughputPredictor.java b/service/java/com/android/server/wifi/ThroughputPredictor.java
index 8a2063e4e2..b3f23589dd 100644
--- a/service/java/com/android/server/wifi/ThroughputPredictor.java
+++ b/service/java/com/android/server/wifi/ThroughputPredictor.java
@@ -150,7 +150,7 @@ public class ThroughputPredictor {
     public int predictTxThroughput(@NonNull WifiNative.ConnectionCapabilities capabilities,
             int rssiDbm, int frequency, int channelUtilization) {
         int channelUtilizationFinal = getValidChannelUtilization(frequency,
-                INVALID, channelUtilization, false);
+                channelUtilization, false);
         return predictThroughputInternal(capabilities.wifiStandard, capabilities.is11bMode,
                 capabilities.channelBandwidth, rssiDbm, capabilities.maxNumberTxSpatialStreams,
                 channelUtilizationFinal, frequency, null);
@@ -163,7 +163,7 @@ public class ThroughputPredictor {
     public int predictRxThroughput(@NonNull WifiNative.ConnectionCapabilities capabilities,
             int rssiDbm, int frequency, int channelUtilization) {
         int channelUtilizationFinal = getValidChannelUtilization(frequency,
-                INVALID, channelUtilization, false);
+                channelUtilization, false);
         return predictThroughputInternal(capabilities.wifiStandard, capabilities.is11bMode,
                 capabilities.channelBandwidth, rssiDbm, capabilities.maxNumberRxSpatialStreams,
                 channelUtilizationFinal, frequency, null);
@@ -277,7 +277,6 @@ public class ThroughputPredictor {
         }
 
         int channelUtilization = getValidChannelUtilization(frequency,
-                channelUtilizationBssLoad,
                 channelUtilizationLinkLayerStats,
                 isBluetoothConnected);
 
@@ -417,7 +416,7 @@ public class ThroughputPredictor {
         int phyRateMbps =  (int) ((numBitPerSym * MICRO_TO_NANO_RATIO)
                 / (symDurationNs * BIT_PER_TONE_SCALE));
 
-        int airTimeFraction = calculateAirTimeFraction(channelUtilization, channelWidthFactor);
+        int airTimeFraction = calculateAirTimeFraction(channelUtilization);
 
         int throughputMbps = (phyRateMbps * airTimeFraction) / MAX_CHANNEL_UTILIZATION;
 
@@ -458,13 +457,11 @@ public class ThroughputPredictor {
         return bitPerTone;
     }
 
-    private int getValidChannelUtilization(int frequency, int channelUtilizationBssLoad,
+    private int getValidChannelUtilization(int frequency,
             int channelUtilizationLinkLayerStats, boolean isBluetoothConnected) {
         int channelUtilization;
         boolean is2G = ScanResult.is24GHz(frequency);
-        if (isValidUtilizationRatio(channelUtilizationBssLoad)) {
-            channelUtilization = channelUtilizationBssLoad;
-        } else if (isValidUtilizationRatio(channelUtilizationLinkLayerStats)) {
+        if (isValidUtilizationRatio(channelUtilizationLinkLayerStats)) {
             channelUtilization = channelUtilizationLinkLayerStats;
         } else {
             channelUtilization = is2G ? CHANNEL_UTILIZATION_DEFAULT_2G :
@@ -477,8 +474,8 @@ public class ThroughputPredictor {
         }
         if (mVerboseLoggingEnabled) {
             StringBuilder sb = new StringBuilder();
-            Log.d(TAG, sb.append(" utilization (BssLoad) ").append(channelUtilizationBssLoad)
-                    .append(" utilization (LLStats) ").append(channelUtilizationLinkLayerStats)
+            Log.d(TAG, sb
+                    .append(" utilization (LLS) ").append(channelUtilizationLinkLayerStats)
                     .append(" isBluetoothConnected: ").append(isBluetoothConnected)
                     .append(" final utilization: ").append(channelUtilization)
                     .toString());
@@ -497,19 +494,7 @@ public class ThroughputPredictor {
     // Calculate the available airtime fraction value which is multiplied by
     // MAX_CHANNEL_UTILIZATION for integer representation. It is calculated as
     // (1 - channelUtilization / MAX_CHANNEL_UTILIZATION) * MAX_CHANNEL_UTILIZATION
-    private int calculateAirTimeFraction(int channelUtilization, int channelWidthFactor) {
-        int airTimeFraction20MHz = MAX_CHANNEL_UTILIZATION - channelUtilization;
-        int airTimeFraction = airTimeFraction20MHz;
-        // For the cases of 40MHz or above, need to take
-        // (1 - channelUtilization / MAX_CHANNEL_UTILIZATION) ^ (2 ^ channelWidthFactor)
-        // because channelUtilization is defined for primary 20MHz channel
-        for (int i = 1; i <= channelWidthFactor; ++i) {
-            airTimeFraction *= airTimeFraction;
-            airTimeFraction /= MAX_CHANNEL_UTILIZATION;
-        }
-        if (mVerboseLoggingEnabled) {
-            Log.d(TAG, " airTime20: " + airTimeFraction20MHz + " airTime: " + airTimeFraction);
-        }
-        return airTimeFraction;
+    private int calculateAirTimeFraction(int channelUtilization) {
+        return MAX_CHANNEL_UTILIZATION - channelUtilization;
     }
 }
diff --git a/service/java/com/android/server/wifi/WifiApConfigStore.java b/service/java/com/android/server/wifi/WifiApConfigStore.java
index d5167ac57a..efe527a016 100644
--- a/service/java/com/android/server/wifi/WifiApConfigStore.java
+++ b/service/java/com/android/server/wifi/WifiApConfigStore.java
@@ -487,11 +487,22 @@ public class WifiApConfigStore {
     /**
      * Generate a temporary WPA2 based configuration for use by the local only hotspot.
      * This config is not persisted and will not be stored by the WifiApConfigStore.
+     *
+     * @param context the context of wifi.
+     * @param customConfig customzied softap configuration.
+     * @param capability current softap capability.
+     * @param isExclusive whether customConfig is exclusive (set by privledged app).
+     * @return configuration of local only hotspot.
      */
     public SoftApConfiguration generateLocalOnlyHotspotConfig(@NonNull WifiContext context,
-            @Nullable SoftApConfiguration customConfig, @NonNull SoftApCapability capability) {
+            @Nullable SoftApConfiguration customConfig, @NonNull SoftApCapability capability,
+            boolean isExclusive) {
         SoftApConfiguration.Builder configBuilder;
-        if (customConfig != null) {
+        boolean wasSsidAssigned = false;
+        if (customConfig != null && isExclusive) {
+            if (!TextUtils.isEmpty(customConfig.getSsid())) {
+                wasSsidAssigned = true;
+            }
             configBuilder = new SoftApConfiguration.Builder(customConfig);
             // Make sure that we use available band on old build.
             if (!SdkLevel.isAtLeastT()
@@ -500,14 +511,25 @@ public class WifiApConfigStore {
             }
         } else {
             configBuilder = new SoftApConfiguration.Builder();
-            // Make sure the default band configuration is supported.
-            configBuilder.setBand(generateDefaultBand(context));
+            if (customConfig != null && SdkLevel.isAtLeastS()) {
+                configBuilder.setChannels(customConfig.getChannels());
+            } else {
+                // Make sure the default band configuration is supported.
+                configBuilder.setBand(generateDefaultBand(context));
+            }
             // Default to disable the auto shutdown
             configBuilder.setAutoShutdownEnabled(false);
             try {
                 if (ApConfigUtil.isWpa3SaeSupported(context)) {
-                    configBuilder.setPassphrase(generatePassword(),
-                            SECURITY_TYPE_WPA3_SAE_TRANSITION);
+                    if (customConfig != null
+                            && customConfig.getBand() == SoftApConfiguration.BAND_6GHZ) {
+                        // Requested band is limited to 6GHz only, use SAE.
+                        configBuilder.setPassphrase(generatePassword(),
+                                SECURITY_TYPE_WPA3_SAE);
+                    } else {
+                        configBuilder.setPassphrase(generatePassword(),
+                                SECURITY_TYPE_WPA3_SAE_TRANSITION);
+                    }
                 } else {
                     configBuilder.setPassphrase(generatePassword(),
                             SECURITY_TYPE_WPA2_PSK);
@@ -543,7 +565,8 @@ public class WifiApConfigStore {
             }
             configBuilder.setBand(desiredBand);
         }
-        if (customConfig == null || customConfig.getSsid() == null) {
+
+        if (!wasSsidAssigned) {
             configBuilder.setSsid(generateLohsSsid(context));
         }
 
@@ -709,6 +732,13 @@ public class WifiApConfigStore {
             }
         }
 
+        // Hostapd requires 11AX to configure 11BE
+        if (SdkLevel.isAtLeastB() && apConfig.isIeee80211beEnabled()
+                && !apConfig.isIeee80211axEnabledInternal()) {
+            Log.d(TAG, "11AX is required when configuring 11BE");
+            return false;
+        }
+
         return true;
     }
 
diff --git a/service/java/com/android/server/wifi/WifiBlocklistMonitor.java b/service/java/com/android/server/wifi/WifiBlocklistMonitor.java
index 4e3a0ce3c8..063b57cc6d 100644
--- a/service/java/com/android/server/wifi/WifiBlocklistMonitor.java
+++ b/service/java/com/android/server/wifi/WifiBlocklistMonitor.java
@@ -34,6 +34,8 @@ import android.util.LocalLog;
 import android.util.Log;
 import android.util.SparseArray;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.wifi.util.StringUtil;
 import com.android.server.wifi.util.WifiPermissionsUtil;
@@ -428,6 +430,14 @@ public class WifiBlocklistMonitor {
         }
     }
 
+    /**
+     * Clear the blocklisted bssid entries with a specific block reason.
+     * @param blockReason block reason from WifiBlocklistMonitor.REASON_*
+     */
+    public void clearBssidBlocklistForReason(@FailureReason int blockReason) {
+        mBssidStatusMap.entrySet().removeIf(entry -> entry.getValue().blockReason == blockReason);
+    }
+
     private String getFailureReasonString(@FailureReason int reasonCode) {
         if (reasonCode == INVALID_REASON) {
             return "INVALID_REASON";
@@ -733,6 +743,7 @@ public class WifiBlocklistMonitor {
      * Clears the blocklist for BSSIDs associated with the input SSID only.
      * @param ssid
      */
+    @Keep
     public void clearBssidBlocklistForSsid(@NonNull String ssid) {
         int prevSize = mBssidStatusMap.size();
         mBssidStatusMap.entrySet().removeIf(e -> {
@@ -1300,13 +1311,20 @@ public class WifiBlocklistMonitor {
                 return false;
             }
 
-            // Do not update SSID blocklist with information if this is the only
-            // SSID be observed. By ignoring it we will cause additional failures
-            // which will trigger Watchdog.
+            networkStatus.incrementDisableReasonCounter(reason);
+            // For network disable reasons, we should only update the status if we cross the
+            // threshold.
+            int disableReasonCounter = networkStatus.getDisableReasonCounter(reason);
+            int disableReasonThreshold = getNetworkSelectionDisableThreshold(reason);
+
+            // If this is the only SSID be observed, allow more failures to allow Watchdog to
+            // trigger easier
             if (reason == NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION
                     || reason == NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE
                     || reason == NetworkSelectionStatus.DISABLED_DHCP_FAILURE) {
-                if (mWifiLastResortWatchdog.shouldIgnoreSsidUpdate()) {
+                if (mWifiLastResortWatchdog.shouldIgnoreSsidUpdate()
+                        && disableReasonCounter
+                        < NUM_CONSECUTIVE_FAILURES_PER_NETWORK_EXP_BACKOFF) {
                     if (mVerboseLoggingEnabled) {
                         Log.v(TAG, "Ignore update network selection status "
                                 + "since Watchdog trigger is activated");
@@ -1315,11 +1333,6 @@ public class WifiBlocklistMonitor {
                 }
             }
 
-            networkStatus.incrementDisableReasonCounter(reason);
-            // For network disable reasons, we should only update the status if we cross the
-            // threshold.
-            int disableReasonCounter = networkStatus.getDisableReasonCounter(reason);
-            int disableReasonThreshold = getNetworkSelectionDisableThreshold(reason);
             if (disableReasonCounter < disableReasonThreshold) {
                 if (mVerboseLoggingEnabled) {
                     Log.v(TAG, "Disable counter for network " + config.getPrintableSsid()
diff --git a/service/java/com/android/server/wifi/WifiCarrierInfoManager.java b/service/java/com/android/server/wifi/WifiCarrierInfoManager.java
index 1e623a6987..1cafbecff1 100644
--- a/service/java/com/android/server/wifi/WifiCarrierInfoManager.java
+++ b/service/java/com/android/server/wifi/WifiCarrierInfoManager.java
@@ -66,6 +66,7 @@ import android.util.Pair;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 
+import androidx.annotation.Keep;
 import androidx.annotation.RequiresApi;
 
 import com.android.internal.annotations.GuardedBy;
@@ -883,6 +884,7 @@ public class WifiCarrierInfoManager {
      * @param subId The subscription ID of SIM card.
      * @return true if the IMSI encryption is required, otherwise false.
      */
+    @Keep
     public boolean requiresImsiEncryption(int subId) {
         PersistableBundle bundle = getCarrierConfigForSubId(subId);
         if (bundle == null) {
@@ -899,6 +901,7 @@ public class WifiCarrierInfoManager {
      * @param subId The subscription ID of SIM card.
      * @return true if the IMSI encryption is available, otherwise false.
      */
+    @Keep
     public boolean isImsiEncryptionInfoAvailable(int subId) {
         return mImsiEncryptionInfoAvailable.get(subId);
     }
@@ -909,6 +912,7 @@ public class WifiCarrierInfoManager {
      * @param config the instance of {@link WifiConfiguration}
      * @return the best match SubscriptionId
      */
+    @Keep
     public int getBestMatchSubscriptionId(@NonNull WifiConfiguration config) {
         if (config == null) {
             Log.wtf(TAG, "getBestMatchSubscriptionId: Config must be NonNull!");
@@ -979,6 +983,7 @@ public class WifiCarrierInfoManager {
      * @param subId subscription ID of SIM card in the device.
      * @return true if the SIM is active and all info are available, otherwise false.
      */
+    @Keep
     public boolean isSimReady(int subId) {
         if (!SubscriptionManager.isValidSubscriptionId(subId)) {
             return false;
diff --git a/service/java/com/android/server/wifi/WifiConfigManager.java b/service/java/com/android/server/wifi/WifiConfigManager.java
index b476fe0294..c996782c11 100644
--- a/service/java/com/android/server/wifi/WifiConfigManager.java
+++ b/service/java/com/android/server/wifi/WifiConfigManager.java
@@ -64,6 +64,8 @@ import android.util.LocalLog;
 import android.util.Log;
 import android.util.Pair;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.net.module.util.MacAddressUtils;
@@ -814,11 +816,37 @@ public class WifiConfigManager {
         return getConfiguredNetworks(false, false, Process.WIFI_UID);
     }
 
+    /**
+     * Retrieves the  configured network corresponding to the provided SSID and security type. The
+     * WifiConfiguration object will have the password in plain text.
+     *
+     * WARNING: Don't use this to pass network configurations to external apps. Should only be
+     * sent to system apps/wifi stack, when there is a need for passwords in plaintext.
+     *
+     * @param ssid SSID of the requested network.
+     * @param securityType  security type of the requested network.
+     * @return WifiConfiguration object if found, null otherwise.
+     */
+    public @Nullable WifiConfiguration getConfiguredNetworkWithPassword(@NonNull WifiSsid ssid,
+            @WifiConfiguration.SecurityType int securityType) {
+        List<WifiConfiguration> wifiConfigurations = getConfiguredNetworks(false, false,
+                Process.WIFI_UID);
+        for (WifiConfiguration wifiConfiguration : wifiConfigurations) {
+            // Match ssid and security type
+            if (ssid.equals(WifiSsid.fromString(wifiConfiguration.SSID))
+                    && wifiConfiguration.isSecurityType(securityType)) {
+                return new WifiConfiguration(wifiConfiguration);
+            }
+        }
+        return null;
+    }
+
     /**
      * Retrieves the list of all configured networks with the passwords masked.
      *
      * @return List of WifiConfiguration objects representing the networks.
      */
+    @Keep
     public List<WifiConfiguration> getSavedNetworks(int targetUid) {
         return getConfiguredNetworks(true, true, targetUid);
     }
@@ -844,6 +872,7 @@ public class WifiConfigManager {
      * @param networkId networkId of the requested network.
      * @return WifiConfiguration object if found, null otherwise.
      */
+    @Keep
     public @Nullable WifiConfiguration getConfiguredNetwork(int networkId) {
         WifiConfiguration config = getInternalConfiguredNetwork(networkId);
         if (config == null) {
@@ -1450,7 +1479,7 @@ public class WifiConfigManager {
         WifiConfiguration newInternalConfig = null;
 
         BitSet supportedFeatures = mWifiInjector.getActiveModeWarden()
-                .getPrimaryClientModeManager().getSupportedFeatures();
+                .getPrimaryClientModeManager().getSupportedFeaturesBitSet();
 
         // First check if we already have a network with the provided network id or configKey.
         WifiConfiguration existingInternalConfig = getInternalConfiguredNetwork(config);
@@ -1787,6 +1816,7 @@ public class WifiConfigManager {
      * @param uid    UID of the app requesting the network addition/modification.
      * @return NetworkUpdateResult object representing status of the update.
      */
+    @Keep
     public NetworkUpdateResult addOrUpdateNetwork(WifiConfiguration config, int uid) {
         return addOrUpdateNetwork(config, uid, null, false);
     }
@@ -2193,6 +2223,7 @@ public class WifiConfigManager {
      * @param reason    reason to update the network.
      * @return true if the input configuration has been updated, false otherwise.
      */
+    @Keep
     public boolean updateNetworkSelectionStatus(int networkId, int reason) {
         WifiConfiguration config = getInternalConfiguredNetwork(networkId);
         if (config == null) {
@@ -2741,6 +2772,7 @@ public class WifiConfigManager {
      *
      * @return network Id corresponding to the last selected network.
      */
+    @Keep
     public int getLastSelectedNetwork() {
         return mLastSelectedNetworkId;
     }
@@ -2767,6 +2799,7 @@ public class WifiConfigManager {
      *
      * @return timestamp in milliseconds from boot when this was set.
      */
+    @Keep
     public long getLastSelectedTimeStamp() {
         return mLastSelectedTimeStamp;
     }
@@ -2778,6 +2811,7 @@ public class WifiConfigManager {
      * @param networkId network ID corresponding to the network.
      * @return existing {@link ScanDetailCache} entry if one exists or null.
      */
+    @Keep
     public ScanDetailCache getScanDetailCacheForNetwork(int networkId) {
         return mScanDetailCaches.get(networkId);
     }
@@ -2854,6 +2888,7 @@ public class WifiConfigManager {
      * @return WifiConfiguration object representing the network corresponding to the scanResult,
      * null if none exists.
      */
+    @Keep
     public WifiConfiguration getSavedNetworkForScanResult(@NonNull ScanResult scanResult) {
         WifiConfiguration config = null;
         try {
@@ -3565,7 +3600,7 @@ public class WifiConfigManager {
             Map<String, String> macAddressMapping) {
 
         BitSet supportedFeatures = mWifiInjector.getActiveModeWarden()
-                .getPrimaryClientModeManager().getSupportedFeatures();
+                .getPrimaryClientModeManager().getSupportedFeaturesBitSet();
 
         for (WifiConfiguration configuration : configurations) {
             if (!WifiConfigurationUtil.validate(
@@ -3604,7 +3639,7 @@ public class WifiConfigManager {
      */
     private void loadInternalDataFromUserStore(List<WifiConfiguration> configurations) {
         BitSet supportedFeatures = mWifiInjector.getActiveModeWarden()
-                .getPrimaryClientModeManager().getSupportedFeatures();
+                .getPrimaryClientModeManager().getSupportedFeaturesBitSet();
 
         for (WifiConfiguration configuration : configurations) {
             if (!WifiConfigurationUtil.validate(
diff --git a/service/java/com/android/server/wifi/WifiConfigurationUtil.java b/service/java/com/android/server/wifi/WifiConfigurationUtil.java
index 313af6fb54..612b7b4e59 100644
--- a/service/java/com/android/server/wifi/WifiConfigurationUtil.java
+++ b/service/java/com/android/server/wifi/WifiConfigurationUtil.java
@@ -22,6 +22,7 @@ import static android.net.wifi.hotspot2.PasspointConfiguration.MAX_NUMBER_OF_OI;
 import static android.net.wifi.hotspot2.PasspointConfiguration.MAX_OI_VALUE;
 import static android.net.wifi.hotspot2.PasspointConfiguration.MAX_URL_BYTES;
 
+import static com.android.server.wifi.util.GeneralUtil.longToBitset;
 import static com.android.server.wifi.util.NativeUtil.addEnclosingQuotes;
 
 import android.annotation.SuppressLint;
@@ -42,6 +43,8 @@ import android.text.TextUtils;
 import android.util.Log;
 import android.util.Pair;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.util.NativeUtil;
@@ -105,6 +108,7 @@ public class WifiConfigurationUtil {
     /**
      * Helper method to check if the provided |config| corresponds to a PSK network or not.
      */
+    @Keep
     public static boolean isConfigForPskNetwork(WifiConfiguration config) {
         return config.isSecurityType(WifiConfiguration.SECURITY_TYPE_PSK);
     }
@@ -126,6 +130,7 @@ public class WifiConfigurationUtil {
     /**
      * Helper method to check if the provided |config| corresponds to an SAE network or not.
      */
+    @Keep
     public static boolean isConfigForSaeNetwork(WifiConfiguration config) {
         return config.isSecurityType(WifiConfiguration.SECURITY_TYPE_SAE);
     }
@@ -133,6 +138,7 @@ public class WifiConfigurationUtil {
     /**
      * Helper method to check if the provided |config| corresponds to an OWE network or not.
      */
+    @Keep
     public static boolean isConfigForOweNetwork(WifiConfiguration config) {
         return config.isSecurityType(WifiConfiguration.SECURITY_TYPE_OWE);
     }
@@ -180,6 +186,7 @@ public class WifiConfigurationUtil {
     /**
      * Helper method to check if the provided |config| corresponds to a WEP network or not.
      */
+    @Keep
     public static boolean isConfigForWepNetwork(WifiConfiguration config) {
         return config.isSecurityType(WifiConfiguration.SECURITY_TYPE_WEP);
     }
@@ -196,6 +203,7 @@ public class WifiConfigurationUtil {
      * Helper method to check if the provided |config| corresponds to an open or enhanced
      * open network, or not.
      */
+    @Keep
     public static boolean isConfigForOpenNetwork(WifiConfiguration config) {
         return (!(isConfigForWepNetwork(config) || isConfigForPskNetwork(config)
                 || isConfigForWapiPskNetwork(config) || isConfigForWapiCertNetwork(config)
@@ -867,6 +875,15 @@ public class WifiConfigurationUtil {
         return true;
     }
 
+    /**
+     * Please check {@link #validate(WifiConfiguration, BitSet, boolean)}
+     */
+    @Keep
+    public static boolean validate(WifiConfiguration config, long supportedFeatureSet,
+            boolean isAdd) {
+        return validate(config, longToBitset(supportedFeatureSet), isAdd);
+    }
+
     private static boolean validateStringField(String field, int maxLength) {
         return field == null || field.length() <= maxLength;
     }
@@ -1225,7 +1242,7 @@ public class WifiConfigurationUtil {
     private static boolean isSecurityParamsSupported(SecurityParams params) {
         final BitSet wifiFeatures = WifiInjector.getInstance()
                 .getActiveModeWarden().getPrimaryClientModeManager()
-                .getSupportedFeatures();
+                .getSupportedFeaturesBitSet();
         switch (params.getSecurityType()) {
             case WifiConfiguration.SECURITY_TYPE_SAE:
                 return wifiFeatures.get(WifiManager.WIFI_FEATURE_WPA3_SAE);
diff --git a/service/java/com/android/server/wifi/WifiConnectivityHelper.java b/service/java/com/android/server/wifi/WifiConnectivityHelper.java
index 65d5306591..8beafc6e33 100644
--- a/service/java/com/android/server/wifi/WifiConnectivityHelper.java
+++ b/service/java/com/android/server/wifi/WifiConnectivityHelper.java
@@ -64,7 +64,7 @@ public class WifiConnectivityHelper {
 
         ClientModeManager primaryManager =
                 mWifiInjector.getActiveModeWarden().getPrimaryClientModeManager();
-        BitSet fwFeatureSet = primaryManager.getSupportedFeatures();
+        BitSet fwFeatureSet = primaryManager.getSupportedFeaturesBitSet();
         Log.d(TAG, "Firmware supported feature set: " + fwFeatureSet);
 
         if (!fwFeatureSet.get(WIFI_FEATURE_CONTROL_ROAMING)) {
diff --git a/service/java/com/android/server/wifi/WifiConnectivityManager.java b/service/java/com/android/server/wifi/WifiConnectivityManager.java
index da0ae94dbf..03e0ac007c 100644
--- a/service/java/com/android/server/wifi/WifiConnectivityManager.java
+++ b/service/java/com/android/server/wifi/WifiConnectivityManager.java
@@ -662,6 +662,14 @@ public class WifiConnectivityManager {
         // If cellular is unavailable, re-enable Wi-Fi networks disabled by pinning to cell.
         mConfigManager.considerStopRestrictingAutoJoinToSubscriptionId();
 
+        if (isFullScan) {
+            if (mVerboseLoggingEnabled) {
+                Log.v(TAG, "Clearing blocklist for REASON_FRAMEWORK_DISCONNECT_FAST_RECONNECT");
+            }
+            mWifiBlocklistMonitor.clearBssidBlocklistForReason(
+                    WifiBlocklistMonitor.REASON_FRAMEWORK_DISCONNECT_FAST_RECONNECT);
+        }
+
         // Check if any blocklisted BSSIDs can be freed.
         List<ScanDetail> enabledDetails =
                 mWifiBlocklistMonitor.tryEnablingBlockedBssids(scanDetails);
diff --git a/service/java/com/android/server/wifi/WifiCountryCode.java b/service/java/com/android/server/wifi/WifiCountryCode.java
index c307c010b8..3b041cd25f 100644
--- a/service/java/com/android/server/wifi/WifiCountryCode.java
+++ b/service/java/com/android/server/wifi/WifiCountryCode.java
@@ -30,6 +30,8 @@ import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.Log;
 
+import androidx.annotation.Keep;
+
 import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.hotspot2.NetworkDetail;
 import com.android.server.wifi.p2p.WifiP2pMetrics;
@@ -514,7 +516,7 @@ public class WifiCountryCode {
     }
 
     private boolean shouldDisconnectWifiToForceUpdate() {
-        if (!hasCalling() || mWifiCarrierInfoManager.isWifiCallingAvailable()) {
+        if (hasCalling() && mWifiCarrierInfoManager.isWifiCallingAvailable()) {
             return false;
         }
 
@@ -564,6 +566,7 @@ public class WifiCountryCode {
      * @return The current Wifi Country Code resolved from various sources. Returns null when there
      * is no Country Code available.
      */
+    @Keep
     @Nullable
     public synchronized String getCountryCode() {
         initializeTelephonyCountryCodeIfNeeded();
@@ -760,7 +763,7 @@ public class WifiCountryCode {
     /**
      * Method to check if current driver Country Code is in the world mode
      */
-    private boolean isDriverCountryCodeWorldMode() {
+    public boolean isDriverCountryCodeWorldMode() {
         if (mDriverCountryCode == null) {
             return true;
         }
diff --git a/service/java/com/android/server/wifi/WifiDataStall.java b/service/java/com/android/server/wifi/WifiDataStall.java
index 45aa5f7fd5..e7f01c83ad 100644
--- a/service/java/com/android/server/wifi/WifiDataStall.java
+++ b/service/java/com/android/server/wifi/WifiDataStall.java
@@ -22,6 +22,8 @@ import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.content.Context;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiAnnotations;
 import android.net.wifi.WifiInfo;
 import android.net.wifi.WifiManager.DeviceMobilityState;
 import android.os.Handler;
@@ -84,6 +86,7 @@ public class WifiDataStall {
     private boolean mPhoneStateListenerEnabled = false;
     private int mTxTputKbps = INVALID_THROUGHPUT;
     private int mRxTputKbps = INVALID_THROUGHPUT;
+    private @WifiAnnotations.ChannelWidth int mChannelBandwidth = ScanResult.UNSPECIFIED;
 
     /** @hide */
     @IntDef(prefix = { "CELLULAR_DATA_" }, value = {
@@ -205,6 +208,7 @@ public class WifiDataStall {
         mIsThroughputSufficient = true;
         mTxTputKbps = INVALID_THROUGHPUT;
         mRxTputKbps = INVALID_THROUGHPUT;
+        mChannelBandwidth = ScanResult.UNSPECIFIED;
     }
 
     private void createTelephonyManagerForDefaultDataSubIfNeeded() {
@@ -482,12 +486,16 @@ public class WifiDataStall {
         mIsThroughputSufficient = isThroughputSufficientInternal(mTxTputKbps, mRxTputKbps,
                 isTxTrafficHigh, isRxTrafficHigh, timeDeltaLastTwoPollsMs, txBytes, rxBytes);
 
+        mChannelBandwidth = connectionCapabilities != null
+                ? mChannelBandwidth = connectionCapabilities.channelBandwidth
+                : ScanResult.UNSPECIFIED;
+
         int maxTimeDeltaMs = mWifiGlobals.getPollRssiIntervalMillis()
                 + MAX_TIME_MARGIN_LAST_TWO_POLLS_MS;
         if (timeDeltaLastTwoPollsMs > 0 && timeDeltaLastTwoPollsMs <= maxTimeDeltaMs) {
             mWifiMetrics.incrementConnectionDuration(ifaceName, timeDeltaLastTwoPollsMs,
                     mIsThroughputSufficient, mIsCellularDataAvailable, wifiInfo.getRssi(),
-                    mTxTputKbps, mRxTputKbps);
+                    mTxTputKbps, mRxTputKbps, txLinkSpeedMbps, rxLinkSpeedMbps, mChannelBandwidth);
         }
 
         boolean possibleDataStallTx = isTxTputLow
diff --git a/service/java/com/android/server/wifi/WifiDeviceStateChangeManager.java b/service/java/com/android/server/wifi/WifiDeviceStateChangeManager.java
index 6efa28fc90..0b6ffc68d1 100644
--- a/service/java/com/android/server/wifi/WifiDeviceStateChangeManager.java
+++ b/service/java/com/android/server/wifi/WifiDeviceStateChangeManager.java
@@ -29,6 +29,7 @@ import android.security.advancedprotection.AdvancedProtectionManager;
 import android.text.TextUtils;
 import android.util.ArraySet;
 
+import com.android.internal.annotations.VisibleForTesting;
 import com.android.modules.utils.HandlerExecutor;
 import com.android.wifi.flags.FeatureFlags;
 
@@ -98,7 +99,8 @@ public class WifiDeviceStateChangeManager {
                 },
                 filter);
         handleScreenStateChanged(mPowerManager.isInteractive());
-        if (Environment.isSdkAtLeastB() && mFeatureFlags.wepDisabledInApm() && Flags.aapmApi()) {
+        if (Environment.isSdkAtLeastB() && mFeatureFlags.wepDisabledInApm()
+                && isAapmApiFlagEnabled()) {
             mAdvancedProtectionManager =
                     mContext.getSystemService(AdvancedProtectionManager.class);
             if (mAdvancedProtectionManager != null) {
@@ -118,6 +120,10 @@ public class WifiDeviceStateChangeManager {
         mIsWifiServiceStarted = true;
     }
 
+    @VisibleForTesting
+    public boolean isAapmApiFlagEnabled() {
+        return Flags.aapmApi();
+    }
     /**
      * Register a state change callback. When the state is changed, caller with receive the callback
      * event
diff --git a/service/java/com/android/server/wifi/WifiGlobals.java b/service/java/com/android/server/wifi/WifiGlobals.java
index bc778dada4..1c4e549cf1 100644
--- a/service/java/com/android/server/wifi/WifiGlobals.java
+++ b/service/java/com/android/server/wifi/WifiGlobals.java
@@ -25,6 +25,8 @@ import android.util.ArraySet;
 import android.util.Log;
 import android.util.SparseArray;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.WifiBlocklistMonitor.CarrierSpecificEapFailureConfig;
@@ -189,6 +191,7 @@ public class WifiGlobals {
     }
 
     /** Get the interval between RSSI polls, in milliseconds. */
+    @Keep
     public int getPollRssiIntervalMillis() {
         return mPollRssiIntervalMillis.get();
     }
@@ -221,6 +224,7 @@ public class WifiGlobals {
     }
 
     /** Sets whether CMD_IP_REACHABILITY_LOST events should trigger disconnects. */
+    @Keep
     public void setIpReachabilityDisconnectEnabled(boolean enabled) {
         mIpReachabilityDisconnectEnabled.set(enabled);
     }
diff --git a/service/java/com/android/server/wifi/WifiInjector.java b/service/java/com/android/server/wifi/WifiInjector.java
index 8df39ac380..7bc2604102 100644
--- a/service/java/com/android/server/wifi/WifiInjector.java
+++ b/service/java/com/android/server/wifi/WifiInjector.java
@@ -51,7 +51,10 @@ import android.telephony.TelephonyManager;
 import android.util.LocalLog;
 import android.util.Log;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.flags.Flags;
 import com.android.modules.utils.BackgroundThread;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.aware.WifiAwareMetrics;
@@ -60,6 +63,7 @@ import com.android.server.wifi.coex.CoexManager;
 import com.android.server.wifi.hotspot2.PasspointManager;
 import com.android.server.wifi.hotspot2.PasspointNetworkNominateHelper;
 import com.android.server.wifi.hotspot2.PasspointObjectFactory;
+import com.android.server.wifi.mainline_supplicant.MainlineSupplicant;
 import com.android.server.wifi.mockwifi.MockWifiServiceUtil;
 import com.android.server.wifi.p2p.SupplicantP2pIfaceHal;
 import com.android.server.wifi.p2p.WifiP2pMetrics;
@@ -169,6 +173,7 @@ public class WifiInjector {
     private final WifiP2pMonitor mWifiP2pMonitor;
     private final SupplicantStaIfaceHal mSupplicantStaIfaceHal;
     private final SupplicantP2pIfaceHal mSupplicantP2pIfaceHal;
+    private final MainlineSupplicant mMainlineSupplicant;
     private final HostapdHal mHostapdHal;
     private final WifiVendorHal mWifiVendorHal;
     private final ScoringParams mScoringParams;
@@ -351,13 +356,14 @@ public class WifiInjector {
         mSupplicantStaIfaceHal = new SupplicantStaIfaceHal(
                 mContext, mWifiMonitor, mFrameworkFacade, mWifiHandler, mClock, mWifiMetrics,
                 mWifiGlobals, mSsidTranslator, this);
+        mMainlineSupplicant = new MainlineSupplicant(mWifiThreadRunner);
         mHostapdHal = new HostapdHal(mContext, mWifiHandler);
         mWifiCondManager = (WifiNl80211Manager) mContext.getSystemService(
                 Context.WIFI_NL80211_SERVICE);
         mWifiNative = new WifiNative(
                 mWifiVendorHal, mSupplicantStaIfaceHal, mHostapdHal, mWifiCondManager,
                 mWifiMonitor, mPropertyService, mWifiMetrics,
-                mWifiHandler, new Random(), mBuildProperties, this);
+                mWifiHandler, new Random(), mBuildProperties, this, mMainlineSupplicant);
         mWifiP2pMonitor = new WifiP2pMonitor();
         mSupplicantP2pIfaceHal = new SupplicantP2pIfaceHal(mWifiP2pMonitor, mWifiGlobals, this);
         mWifiP2pNative = new WifiP2pNative(mWifiCondManager, mWifiNative, mWifiMetrics,
@@ -412,7 +418,8 @@ public class WifiInjector {
                         : maxLinesHighRam);
         mWifiDiagnostics = new WifiDiagnostics(
                 mContext, this, mWifiNative, mBuildProperties,
-                new LastMileLogger(this), mClock, mWifiDiagnosticsHandlerThread.getLooper());
+                new LastMileLogger(this, BackgroundThread.getHandler()), mClock,
+                mWifiDiagnosticsHandlerThread.getLooper());
         mWifiLastResortWatchdog = new WifiLastResortWatchdog(this, mContext, mClock,
                 mWifiMetrics, mWifiDiagnostics, wifiLooper,
                 mDeviceConfigFacade, mWifiThreadRunner, mWifiMonitor);
@@ -601,7 +608,7 @@ public class WifiInjector {
         mSelfRecovery = new SelfRecovery(mContext, mActiveModeWarden, mClock, mWifiNative,
                 mWifiGlobals);
         mWifiMulticastLockManager = new WifiMulticastLockManager(mActiveModeWarden, mBatteryStats,
-                wifiLooper, mContext);
+                wifiLooper, mContext, mClock, mWifiMetrics, mWifiPermissionsUtil);
         mApplicationQosPolicyRequestHandler = new ApplicationQosPolicyRequestHandler(
                 mActiveModeWarden, mWifiNative, mWifiHandlerThread, mDeviceConfigFacade, mContext);
 
@@ -629,7 +636,9 @@ public class WifiInjector {
         mTwtManager = new TwtManager(this, mCmiMonitor, mWifiNative, mWifiHandler, mClock,
                 WifiTwtSession.MAX_TWT_SESSIONS, 1);
         mBackupRestoreController = new BackupRestoreController(mWifiSettingsBackupRestore, mClock);
-        if (mFeatureFlags.voipDetectionBugfix() && SdkLevel.isAtLeastV()) {
+        if (mFeatureFlags.voipDetectionBugfix() && SdkLevel.isAtLeastV()
+                && Flags.passCopiedCallStateList() && mContext.getResources().getBoolean(
+                R.bool.config_wifiVoipDetectionEnabled)) {
             mWifiVoipDetector = new WifiVoipDetector(mContext, mWifiHandler, this,
                     mWifiCarrierInfoManager);
         } else {
@@ -651,6 +660,7 @@ public class WifiInjector {
      * This is the generic method to get an instance of the class. The first instance should be
      * retrieved using the getInstanceWithContext method.
      */
+    @Keep
     public static WifiInjector getInstance() {
         if (sWifiInjector == null) {
             throw new IllegalStateException(
@@ -761,7 +771,7 @@ public class WifiInjector {
     public SarManager getSarManager() {
         return mSarManager;
     }
-
+    @Keep
     public ActiveModeWarden getActiveModeWarden() {
         return mActiveModeWarden;
     }
@@ -793,7 +803,7 @@ public class WifiInjector {
     public WifiMulticastLockManager getWifiMulticastLockManager() {
         return mWifiMulticastLockManager;
     }
-
+    @Keep
     public WifiConfigManager getWifiConfigManager() {
         return mWifiConfigManager;
     }
@@ -825,6 +835,7 @@ public class WifiInjector {
         return mContext.getSystemService(BatteryManager.class);
     }
 
+    @Keep
     public WifiCarrierInfoManager getWifiCarrierInfoManager() {
         return mWifiCarrierInfoManager;
     }
@@ -1027,14 +1038,17 @@ public class WifiInjector {
         return mHalDeviceManager;
     }
 
+    @Keep
     public WifiNative getWifiNative() {
         return mWifiNative;
     }
 
+    @Keep
     public WifiMonitor getWifiMonitor() {
         return mWifiMonitor;
     }
 
+    @Keep
     public WifiP2pNative getWifiP2pNative() {
         return mWifiP2pNative;
     }
@@ -1055,6 +1069,7 @@ public class WifiInjector {
         return mSelfRecovery;
     }
 
+    @Keep
     public ScanRequestProxy getScanRequestProxy() {
         return mScanRequestProxy;
     }
@@ -1090,6 +1105,7 @@ public class WifiInjector {
         return mHostapdHal;
     }
 
+    @Keep
     public WifiThreadRunner getWifiThreadRunner() {
         return mWifiThreadRunner;
     }
@@ -1135,6 +1151,7 @@ public class WifiInjector {
         return mConnectHelper;
     }
 
+    @Keep
     public WifiNetworkFactory getWifiNetworkFactory() {
         return mWifiNetworkFactory;
     }
@@ -1163,6 +1180,7 @@ public class WifiInjector {
         return mWifiP2pConnection;
     }
 
+    @Keep
     public WifiGlobals getWifiGlobals() {
         return mWifiGlobals;
     }
diff --git a/service/java/com/android/server/wifi/WifiLockManager.java b/service/java/com/android/server/wifi/WifiLockManager.java
index 80d4ee379b..040aca88bc 100644
--- a/service/java/com/android/server/wifi/WifiLockManager.java
+++ b/service/java/com/android/server/wifi/WifiLockManager.java
@@ -60,6 +60,8 @@ public class WifiLockManager {
 
     private static final int IGNORE_SCREEN_STATE_MASK = 0x01;
     private static final int IGNORE_WIFI_STATE_MASK   = 0x02;
+    @VisibleForTesting
+    public static final long DELAY_LOCK_RELEASE_MS = 1000;
 
     private int mLatencyModeSupport = LOW_LATENCY_SUPPORT_UNDEFINED;
 
@@ -104,6 +106,7 @@ public class WifiLockManager {
         WIFI_CONNECTION_STATE_CHANGED,
         SCREEN_STATE_CHANGED,
     };
+    private final Object mLock = new Object();
 
     WifiLockManager(
             Context context,
@@ -646,7 +649,7 @@ public class WifiLockManager {
 
         // Recalculate the operating mode
         updateOpMode();
-
+        mHandler.removeCallbacksAndMessages(mLock);
         return true;
     }
 
@@ -675,7 +678,7 @@ public class WifiLockManager {
 
         switch(wifiLock.mMode) {
             case WifiManager.WIFI_MODE_FULL_HIGH_PERF:
-                mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+                mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                         uidsAndTags.first,
                         uidsAndTags.second,
                         mWifiPermissionsUtil.getWifiCallerType(wifiLock.getUid(),
@@ -693,7 +696,7 @@ public class WifiLockManager {
                 }
                 break;
             case WifiManager.WIFI_MODE_FULL_LOW_LATENCY:
-                mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+                mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                         uidsAndTags.first,
                         uidsAndTags.second,
                         mWifiPermissionsUtil.getWifiCallerType(wifiLock.getUid(),
@@ -709,10 +712,8 @@ public class WifiLockManager {
                 // Do nothing
                 break;
         }
-
-        // Recalculate the operating mode
-        updateOpMode();
-
+        // Delay 1s to release the lock to avoid stress the HAL.
+        mHandler.postDelayed(this::updateOpMode, mLock, DELAY_LOCK_RELEASE_MS);
         return true;
     }
 
@@ -731,7 +732,7 @@ public class WifiLockManager {
                     return false;
                 }
                 uidsAndTags = WorkSourceUtil.getUidsAndTagsForWs(mHighPerfBlamedWorkSource);
-                mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+                mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                         uidsAndTags.first,
                         uidsAndTags.second,
                         mClock.getElapsedSinceBootMillis() - mCurrentSessionStartTimeMs,
@@ -747,7 +748,7 @@ public class WifiLockManager {
                     return false;
                 }
                 uidsAndTags = WorkSourceUtil.getUidsAndTagsForWs(mLowLatencyBlamedWorkSource);
-                mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+                mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                         uidsAndTags.first,
                         uidsAndTags.second,
                         mClock.getElapsedSinceBootMillis() - mCurrentSessionStartTimeMs,
@@ -851,7 +852,7 @@ public class WifiLockManager {
         }
 
         BitSet supportedFeatures =
-                mActiveModeWarden.getPrimaryClientModeManager().getSupportedFeatures();
+                mActiveModeWarden.getPrimaryClientModeManager().getSupportedFeaturesBitSet();
         if (supportedFeatures.isEmpty()) {
             return LOW_LATENCY_SUPPORT_UNDEFINED;
         }
diff --git a/service/java/com/android/server/wifi/WifiMetrics.java b/service/java/com/android/server/wifi/WifiMetrics.java
index 1f9d54a927..52eac0d037 100644
--- a/service/java/com/android/server/wifi/WifiMetrics.java
+++ b/service/java/com/android/server/wifi/WifiMetrics.java
@@ -56,8 +56,10 @@ import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.net.ConnectivityManager;
+import android.net.MacAddress;
 import android.net.Network;
 import android.net.NetworkCapabilities;
+import android.net.wifi.DeauthenticationReasonCode;
 import android.net.wifi.EAPConstants;
 import android.net.wifi.IOnWifiUsabilityStatsListener;
 import android.net.wifi.MloLink;
@@ -144,6 +146,7 @@ import com.android.server.wifi.proto.nano.WifiMetricsProto.SoftApConnectedClient
 import com.android.server.wifi.proto.nano.WifiMetricsProto.StaEvent;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.StaEvent.ConfigInfo;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.TargetNetworkInfo;
+import com.android.server.wifi.proto.nano.WifiMetricsProto.TrainingData;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.UserActionEvent;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.UserReactionToApprovalUiEvent;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.UserReactionToApprovalUiEvent.UserReaction;
@@ -156,8 +159,8 @@ import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiNetworkSuggestion
 import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiStatus;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiToWifiSwitchStats;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiToggleStats;
-import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiUsabilityStats;  // This contains a time series of WifiUsabilityStatsEntry along with some metadata, such as the label of the time series or trigger type.
 import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiUsabilityStatsEntry;  // This contains all the stats for a single point in time.
+import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiUsabilityStatsTraining;
 import com.android.server.wifi.rtt.RttMetrics;
 import com.android.server.wifi.scanner.KnownBandsChannelHelper;
 import com.android.server.wifi.util.InformationElementUtil;
@@ -168,7 +171,6 @@ import com.android.server.wifi.util.IntHistogram;
 import com.android.server.wifi.util.MetricsUtils;
 import com.android.server.wifi.util.ObjectCounter;
 import com.android.server.wifi.util.StringUtil;
-import com.android.wifi.flags.Flags;
 import com.android.wifi.resources.R;
 
 import org.json.JSONArray;
@@ -178,6 +180,8 @@ import org.json.JSONObject;
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.time.Duration;
+import java.time.Instant;
+import java.time.temporal.ChronoUnit;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -244,15 +248,7 @@ public class WifiMetrics {
     public static final int MIN_DATA_STALL_WAIT_MS = 120 * 1000; // 2 minutes
     // Max number of WifiUsabilityStatsEntry elements to store in the ringbuffer.
     public static final int MAX_WIFI_USABILITY_STATS_ENTRIES_RING_BUFFER_SIZE = 80;
-    // Max number of WifiUsabilityStats records to store for each type.
-    public static final int MAX_WIFI_USABILITY_STATS_RECORDS_PER_TYPE = 10;
-    // Max number of WifiUsabilityStats per labeled type to upload to server
-    public static final int MAX_WIFI_USABILITY_STATS_RECORDS_PER_TYPE_TO_UPLOAD = 2;
-    // One WifiGood WifiUsabilityStats record will be created each time we see this many
-    // WifiUsabilityStatsEntry time samples.
-    public static final int NUM_WIFI_USABILITY_STATS_ENTRIES_PER_WIFI_GOOD = 100;
-    // At most, one WifiGood WifiUsabilityStats record will be created during this time period.
-    public static final int MIN_WIFI_GOOD_USABILITY_STATS_PERIOD_MS = 1000 * 3600; // 1 hour
+    public static final int MAX_WIFI_USABILITY_STATS_TRAINING_SIZE = 10;
     public static final int PASSPOINT_DEAUTH_IMMINENT_SCOPE_ESS = 0;
     public static final int PASSPOINT_DEAUTH_IMMINENT_SCOPE_BSS = 1;
     public static final int COUNTRY_CODE_CONFLICT_WIFI_SCAN = -1;
@@ -280,6 +276,8 @@ public class WifiMetrics {
     public static final int MIN_DOWNSTREAM_BANDWIDTH_KBPS = 1000;
     public static final int MIN_UPSTREAM_BANDWIDTH_KBPS = 1000;
     public static final int INVALID_SPEED = -1;
+    public static final long MILLIS_IN_A_SECOND = 1000;
+    public static final long MILLIS_IN_AN_HOUR = 3600 * 1000;
 
     private Clock mClock;
     private boolean mScreenOn;
@@ -500,14 +498,12 @@ public class WifiMetrics {
     @VisibleForTesting
     public final LinkedList<WifiUsabilityStatsEntry> mWifiUsabilityStatsEntriesRingBuffer =
             new LinkedList<>();
-    // One WifiUsabilityStats contains a single time series of WifiUsabilityStatsEntry along with
-    // some metadata. These LinkedList's below contain sets of time series that are labeled as
-    // either 'good' or 'bad'.
-    private final LinkedList<WifiUsabilityStats> mWifiUsabilityStatsListBad = new LinkedList<>();
-    private final LinkedList<WifiUsabilityStats> mWifiUsabilityStatsListGood = new LinkedList<>();
-    // Counts the number of WifiUsabilityStatsEntry's that we have seen so that we only create a
-    // WifiUsabilityStats every NUM_WIFI_USABILITY_STATS_ENTRIES_PER_WIFI_GOOD time samples.
-    private int mWifiUsabilityStatsEntryCounter = 0;
+    // Each WifiUsabilityStatsTraining instance contains a list of WifiUsabilityStatsEntry objects,
+    // representing a time series of WiFi usability statistics recorded within a specific data
+    // capture period. It also includes information about the type of data capture and the duration
+    // of the capture period.
+    public final List<WifiUsabilityStatsTraining> mWifiUsabilityStatsTrainingExamples =
+            new ArrayList<>();
     private final Random mRand = new Random();
     private final RemoteCallbackList<IOnWifiUsabilityStatsListener> mOnWifiUsabilityListeners;
 
@@ -1249,6 +1245,8 @@ public class WifiMetrics {
         private int mPhase2Method;
         private int mPasspointRoamingType;
         private int mTofuConnectionState;
+        private long mL2ConnectingDuration;
+        private long mL3ConnectingDuration;
 
         @VisibleForTesting
         ConnectionEvent() {
@@ -2048,6 +2046,8 @@ public class WifiMetrics {
                     mFirstConnectionAfterBoot;
             currentConnectionEvent.mRole = role;
             currentConnectionEvent.mUid = uid;
+            currentConnectionEvent.mL2ConnectingDuration = 0;
+            currentConnectionEvent.mL3ConnectingDuration = 0;
             mFirstConnectionAfterBoot = false;
             mConnectionEventList.add(currentConnectionEvent);
             mScanResultRssiTimestampMillis = -1;
@@ -2265,6 +2265,26 @@ public class WifiMetrics {
         }
     }
 
+    /**
+     * Log L2 and L3 connection transition time
+     *
+     * @param ifaceName interface name for this connection event
+     * @param l2ConnectingDuration Time duration between L2ConnectState to L3ProvisioningState
+     * @param l3ConnectingDuration Time duration between L3ProvisioningState to mL3ConnectedState
+     */
+    public void reportConnectingDuration(
+            String ifaceName,
+            long l2ConnectingDuration,
+            long l3ConnectingDuration) {
+        synchronized (mLock) {
+            ConnectionEvent currentConnectionEvent = mCurrentConnectionEventPerIface.get(ifaceName);
+            if (currentConnectionEvent != null) {
+                currentConnectionEvent.mL2ConnectingDuration = l2ConnectingDuration;
+                currentConnectionEvent.mL3ConnectingDuration = l3ConnectingDuration;
+            }
+        }
+    }
+
     /**
      * End a Connection event record. Call when wifi connection attempt succeeds or fails.
      * If a Connection event has not been started and is active when .end is called, then this
@@ -2336,7 +2356,10 @@ public class WifiMetrics {
                         currentConnectionEvent.mPasspointRoamingType,
                         currentConnectionEvent.mCarrierId,
                         currentConnectionEvent.mTofuConnectionState,
-                        currentConnectionEvent.mUid);
+                        currentConnectionEvent.mUid,
+                        frequency,
+                        currentConnectionEvent.mL2ConnectingDuration,
+                        currentConnectionEvent.mL3ConnectingDuration);
 
                 if (connectionSucceeded) {
                     reportRouterCapabilities(currentConnectionEvent.mRouterFingerPrint);
@@ -4963,8 +4986,8 @@ public class WifiMetrics {
                     eventLine.append(",client_control_is_enabled=" + event.clientControlIsEnabled);
                     pw.println(eventLine.toString());
                 }
-
-                mWifiPowerMetrics.dump(pw);
+                // TODO(b/393985164): Temporary remove this from dump.
+                // mWifiPowerMetrics.dump(pw);
                 mWifiWakeMetrics.dump(pw);
 
                 pw.println("mWifiLogProto.isMacRandomizationOn="
@@ -5001,6 +5024,17 @@ public class WifiMetrics {
                     printWifiUsabilityStatsEntry(pw, stats);
                 }
 
+                pw.println("mWifiUsabilityStatsTrainingExamples:");
+                for (WifiUsabilityStatsTraining statsTraining
+                        : mWifiUsabilityStatsTrainingExamples) {
+                    pw.println("\ndata_capture_type=" + statsTraining.dataCaptureType);
+                    pw.println("\ncapture_start_timestamp_secs="
+                            + statsTraining.captureStartTimestampSecs);
+                    for (WifiUsabilityStatsEntry stats : statsTraining.trainingData.stats) {
+                        printWifiUsabilityStatsEntry(pw, stats);
+                    }
+                }
+
                 pw.println("mMobilityStatePnoStatsMap:");
                 for (int i = 0; i < mMobilityStatePnoStatsMap.size(); i++) {
                     printDeviceMobilityStatePnoScanStats(pw, mMobilityStatePnoStatsMap.valueAt(i));
@@ -5768,6 +5802,13 @@ public class WifiMetrics {
             }
             mWifiLogProto.hardwareRevision = SystemProperties.get("ro.boot.revision", "");
 
+            mWifiLogProto.wifiUsabilityStatsTraining =
+                    new WifiUsabilityStatsTraining[mWifiUsabilityStatsTrainingExamples.size()];
+            for (int i = 0; i < mWifiUsabilityStatsTrainingExamples.size(); i++) {
+                mWifiLogProto.wifiUsabilityStatsTraining[i] =
+                        mWifiUsabilityStatsTrainingExamples.get(i);
+            }
+            mWifiUsabilityStatsTrainingExamples.clear();
             mWifiLogProto.mobilityStatePnoStatsList =
                     new DeviceMobilityStatePnoScanStats[mMobilityStatePnoStatsMap.size()];
             for (int i = 0; i < mMobilityStatePnoStatsMap.size(); i++) {
@@ -6103,13 +6144,9 @@ public class WifiMetrics {
             mWifiIsUnusableList.clear();
             mInstalledPasspointProfileTypeForR1.clear();
             mInstalledPasspointProfileTypeForR2.clear();
-            mWifiUsabilityStatsListGood.clear();
-            mWifiUsabilityStatsListBad.clear();
-            mWifiUsabilityStatsEntriesRingBuffer.clear();
             mMobilityStatePnoStatsMap.clear();
             mWifiP2pMetrics.clear();
             mDppMetrics.clear();
-            mWifiUsabilityStatsEntryCounter = 0;
             mLastBssidPerIfaceMap.clear();
             mLastFrequencyPerIfaceMap.clear();
             mSeqNumInsideFramework = 0;
@@ -7144,10 +7181,6 @@ public class WifiMetrics {
         }
     }
 
-    public boolean isWiFiScorerNewStatsCollected() {
-        return Flags.wifiScorerNewStatsCollection();
-    }
-
     /**
      * If isFullCapture is true, capture everything in ring buffer
      *
@@ -7163,11 +7196,74 @@ public class WifiMetrics {
      */
     public int storeCapturedData(int triggerType, boolean isFullCapture,
             long triggerStartTimeMillis, long triggerStopTimeMillis) {
-        // TODO: Implement how to extract WifiUsabilityStatsEntries from ring buffer whose
-        // timestamps are within [triggerStartTimeMillis, triggerStopTimeMillis]
-        Log.d(TAG, "storeCapturedData: triggerType=" + triggerType
-                + ", isFullCapture=" + isFullCapture);
-        return 0;
+        synchronized (mLock) {
+            Instant bootTime = Instant.now()
+                    .minus(Duration.ofMillis(mClock.getElapsedSinceBootMillis()));
+            Log.d(TAG, "storeCapturedData: triggerType=" + triggerType
+                    + ", isFullCapture=" + isFullCapture
+                    + ", triggerStartTimeMillis=" + triggerStartTimeMillis
+                    + ", triggerStartTime="
+                    + bootTime.plus(Duration.ofMillis(triggerStartTimeMillis))
+                    + ", triggerStopTimeMillis=" + triggerStopTimeMillis
+                    + ", triggerStopTime="
+                    + bootTime.plus(Duration.ofMillis(triggerStopTimeMillis)));
+
+            // Validate triggerStartTimeMillis and triggerStopTimeMillis in non full-capture case
+            if (!isFullCapture && ((triggerStartTimeMillis < 0 || triggerStopTimeMillis < 0
+                    || triggerStopTimeMillis <= triggerStartTimeMillis))) {
+                return 1;
+            }
+
+            Instant now = mClock.getCurrentInstant();
+            Duration durationSinceBoot = Duration.ofMillis(mClock.getElapsedSinceBootMillis());
+
+            WifiUsabilityStatsTraining wifiUsabilityStatsTraining =
+                    new WifiUsabilityStatsTraining();
+            while (mWifiUsabilityStatsTrainingExamples.size()
+                    >= MAX_WIFI_USABILITY_STATS_TRAINING_SIZE) {
+                mWifiUsabilityStatsTrainingExamples.remove(0);
+            }
+            wifiUsabilityStatsTraining.dataCaptureType = triggerType;
+
+            long capturePeriodStartTime = triggerStartTimeMillis;
+            long capturePeriodStopTime = triggerStopTimeMillis;
+
+            if (isFullCapture) {
+                capturePeriodStartTime = mWifiUsabilityStatsEntriesRingBuffer.size() > 0
+                    ? mWifiUsabilityStatsEntriesRingBuffer.get(0).timeStampMs :
+                    0;
+                capturePeriodStopTime = mWifiUsabilityStatsEntriesRingBuffer.size() > 0
+                    ? mWifiUsabilityStatsEntriesRingBuffer.get(
+                        mWifiUsabilityStatsEntriesRingBuffer.size() - 1).timeStampMs :
+                    durationSinceBoot.toMillis();
+            }
+
+            wifiUsabilityStatsTraining.captureStartTimestampSecs =
+                    now.minus(durationSinceBoot)
+                        .plus(Duration.ofMillis(capturePeriodStartTime))
+                        .truncatedTo(ChronoUnit.HOURS)
+                        .getEpochSecond();
+            wifiUsabilityStatsTraining.storeTimeOffsetMs =
+                        durationSinceBoot.toMillis() - capturePeriodStopTime;
+
+            // If isFullCapture is true, store everything in ring buffer
+            // If isFullCapture is false, Store WifiUsabilityStatsEntries within capture period
+            TrainingData trainingData = new TrainingData();
+            List<WifiUsabilityStatsEntry> trainingDataList = new ArrayList<>();
+            for (WifiUsabilityStatsEntry currStats : mWifiUsabilityStatsEntriesRingBuffer) {
+                if (isFullCapture || (currStats.timeStampMs >= triggerStartTimeMillis
+                        && currStats.timeStampMs < triggerStopTimeMillis)) {
+                    WifiUsabilityStatsEntry trainingStats =
+                            createNewWifiUsabilityStatsEntry(currStats, capturePeriodStartTime);
+                    trainingDataList.add(trainingStats);
+                }
+            }
+            trainingData.stats = trainingDataList.toArray(new WifiUsabilityStatsEntry[0]);
+            wifiUsabilityStatsTraining.trainingData = trainingData;
+
+            mWifiUsabilityStatsTrainingExamples.add(wifiUsabilityStatsTraining);
+            return 0;
+        }
     }
 
     /**
@@ -7178,9 +7274,9 @@ public class WifiMetrics {
      */
     public void updateWifiUsabilityStatsEntries(String ifaceName, WifiInfo info,
             WifiLinkLayerStats stats, boolean oneshot, int statusDataStall) {
-        // This is only collected for primary STA currently because RSSI polling is disabled for
-        // non-primary STAs.
         synchronized (mLock) {
+            // This is only collected for primary STA currently because RSSI polling is disabled for
+            // non-primary STAs.
             if (info == null) {
                 return;
             }
@@ -7198,208 +7294,214 @@ public class WifiMetrics {
                     < MAX_WIFI_USABILITY_STATS_ENTRIES_RING_BUFFER_SIZE
                     ? new WifiUsabilityStatsEntry() : mWifiUsabilityStatsEntriesRingBuffer.remove()
                     .clear();
-            if (isWiFiScorerNewStatsCollected()) {
-                SparseArray<MloLink> mloLinks = new SparseArray<>();
-                for (MloLink link: info.getAffiliatedMloLinks()) {
-                    mloLinks.put(link.getLinkId(), link);
-                }
-                if (stats.links != null && stats.links.length > 0) {
-                    int numLinks = stats.links.length;
-                    wifiUsabilityStatsEntry.wifiLinkCount = numLinks;
-                    wifiUsabilityStatsEntry.linkStats = new LinkStats[numLinks];
-                    for (int i = 0; i < numLinks; ++i) {
-                        LinkStats linkStats = new LinkStats();
-                        WifiLinkLayerStats.LinkSpecificStats link = stats.links[i];
-                        linkStats.linkId = link.link_id;
-                        linkStats.state = link.state;
-                        linkStats.radioId = link.radio_id;
-                        linkStats.frequencyMhz = link.frequencyMhz;
-                        linkStats.beaconRx = link.beacon_rx;
-                        linkStats.rssiMgmt = link.rssi_mgmt;
-                        linkStats.timeSliceDutyCycleInPercent = link.timeSliceDutyCycleInPercent;
-                        linkStats.rssi = (mloLinks.size() > 0) ? mloLinks.get(link.link_id,
-                                new MloLink()).getRssi() : info.getRssi();
-                        linkStats.txLinkspeed = (mloLinks.size() > 0) ? mloLinks.get(link.link_id,
-                                new MloLink()).getTxLinkSpeedMbps() : info.getTxLinkSpeedMbps();
-                        linkStats.rxLinkspeed = (mloLinks.size() > 0) ? mloLinks.get(link.link_id,
-                                new MloLink()).getRxLinkSpeedMbps() : info.getRxLinkSpeedMbps();
-                        WifiLinkLayerStats.ChannelStats channlStatsEntryOnFreq =
-                                stats.channelStatsMap.get(link.frequencyMhz);
-                        if (channlStatsEntryOnFreq != null) {
-                            linkStats.channelWidth = channlStatsEntryOnFreq.channelWidth;
-                            linkStats.centerFreqFirstSeg =
-                                channlStatsEntryOnFreq.frequencyFirstSegment;
-                            linkStats.centerFreqSecondSeg =
-                                channlStatsEntryOnFreq.frequencySecondSegment;
-                            linkStats.onTimeInMs = channlStatsEntryOnFreq.radioOnTimeMs;
-                            linkStats.ccaBusyTimeInMs = channlStatsEntryOnFreq.ccaBusyTimeMs;
-                        }
-                        linkStats.contentionTimeStats =
-                                new ContentionTimeStats[NUM_WME_ACCESS_CATEGORIES];
-                        linkStats.packetStats = new PacketStats[NUM_WME_ACCESS_CATEGORIES];
-                        for (int ac = 0; ac < NUM_WME_ACCESS_CATEGORIES; ac++) {
-                            ContentionTimeStats contentionTimeStats = new ContentionTimeStats();
-                            PacketStats packetStats = new PacketStats();
-                            switch (ac) {
-                                case ContentionTimeStats.WME_ACCESS_CATEGORY_BE:
-                                    contentionTimeStats.accessCategory =
-                                            ContentionTimeStats.WME_ACCESS_CATEGORY_BE;
-                                    contentionTimeStats.contentionTimeMinMicros =
-                                            stats.contentionTimeMinBeInUsec;
-                                    contentionTimeStats.contentionTimeMaxMicros =
-                                            stats.contentionTimeMaxBeInUsec;
-                                    contentionTimeStats.contentionTimeAvgMicros =
-                                            stats.contentionTimeAvgBeInUsec;
-                                    contentionTimeStats.contentionNumSamples =
-                                            stats.contentionNumSamplesBe;
-                                    packetStats.accessCategory =
-                                            ContentionTimeStats.WME_ACCESS_CATEGORY_BE;
-                                    packetStats.txSuccess = link.txmpdu_be;
-                                    packetStats.txRetries = link.retries_be;
-                                    packetStats.txBad = link.lostmpdu_be;
-                                    packetStats.rxSuccess = link.rxmpdu_be;
-                                    break;
-                                case ContentionTimeStats.WME_ACCESS_CATEGORY_BK:
-                                    contentionTimeStats.accessCategory =
-                                            ContentionTimeStats.WME_ACCESS_CATEGORY_BK;
-                                    contentionTimeStats.contentionTimeMinMicros =
-                                            stats.contentionTimeMinBkInUsec;
-                                    contentionTimeStats.contentionTimeMaxMicros =
-                                            stats.contentionTimeMaxBkInUsec;
-                                    contentionTimeStats.contentionTimeAvgMicros =
-                                            stats.contentionTimeAvgBkInUsec;
-                                    contentionTimeStats.contentionNumSamples =
-                                            stats.contentionNumSamplesBk;
-                                    packetStats.accessCategory =
-                                            ContentionTimeStats.WME_ACCESS_CATEGORY_BK;
-                                    packetStats.txSuccess = link.txmpdu_bk;
-                                    packetStats.txRetries = link.retries_bk;
-                                    packetStats.txBad = link.lostmpdu_bk;
-                                    packetStats.rxSuccess = link.rxmpdu_bk;
-                                    break;
-                                case ContentionTimeStats.WME_ACCESS_CATEGORY_VI:
-                                    contentionTimeStats.accessCategory =
-                                            ContentionTimeStats.WME_ACCESS_CATEGORY_VI;
-                                    contentionTimeStats.contentionTimeMinMicros =
-                                            stats.contentionTimeMinViInUsec;
-                                    contentionTimeStats.contentionTimeMaxMicros =
-                                            stats.contentionTimeMaxViInUsec;
-                                    contentionTimeStats.contentionTimeAvgMicros =
-                                            stats.contentionTimeAvgViInUsec;
-                                    contentionTimeStats.contentionNumSamples =
-                                            stats.contentionNumSamplesVi;
-                                    packetStats.accessCategory =
-                                            ContentionTimeStats.WME_ACCESS_CATEGORY_VI;
-                                    packetStats.txSuccess = link.txmpdu_vi;
-                                    packetStats.txRetries = link.retries_vi;
-                                    packetStats.txBad = link.lostmpdu_vi;
-                                    packetStats.rxSuccess = link.rxmpdu_vi;
-                                    break;
-                                case ContentionTimeStats.WME_ACCESS_CATEGORY_VO:
-                                    contentionTimeStats.accessCategory =
-                                            ContentionTimeStats.WME_ACCESS_CATEGORY_VO;
-                                    contentionTimeStats.contentionTimeMinMicros =
-                                            stats.contentionTimeMinVoInUsec;
-                                    contentionTimeStats.contentionTimeMaxMicros =
-                                            stats.contentionTimeMaxVoInUsec;
-                                    contentionTimeStats.contentionTimeAvgMicros =
-                                            stats.contentionTimeAvgVoInUsec;
-                                    contentionTimeStats.contentionNumSamples =
-                                            stats.contentionNumSamplesVo;
-                                    packetStats.accessCategory =
-                                            ContentionTimeStats.WME_ACCESS_CATEGORY_VO;
-                                    packetStats.txSuccess = link.txmpdu_vo;
-                                    packetStats.txRetries = link.retries_vo;
-                                    packetStats.txBad = link.lostmpdu_vo;
-                                    packetStats.rxSuccess = link.rxmpdu_vo;
-                                    break;
-                                default:
-                                    Log.e(TAG, "Unknown WME Access Category: " + ac);
-                            }
-                            linkStats.contentionTimeStats[ac] = contentionTimeStats;
-                            linkStats.packetStats[ac] = packetStats;
+            SparseArray<MloLink> mloLinks = new SparseArray<>();
+            for (MloLink link: info.getAffiliatedMloLinks()) {
+                mloLinks.put(link.getLinkId(), link);
+            }
+            if (stats.links != null && stats.links.length > 0) {
+                int numLinks = stats.links.length;
+                wifiUsabilityStatsEntry.wifiLinkCount = numLinks;
+                wifiUsabilityStatsEntry.linkStats = new LinkStats[numLinks];
+                for (int i = 0; i < numLinks; ++i) {
+                    LinkStats linkStats = new LinkStats();
+                    WifiLinkLayerStats.LinkSpecificStats link = stats.links[i];
+                    linkStats.linkId = link.link_id;
+                    linkStats.state = link.state;
+                    linkStats.radioId = link.radio_id;
+                    linkStats.frequencyMhz = link.frequencyMhz;
+                    linkStats.beaconRx = link.beacon_rx;
+                    linkStats.rssiMgmt = link.rssi_mgmt;
+                    linkStats.timeSliceDutyCycleInPercent = link.timeSliceDutyCycleInPercent;
+                    linkStats.rssi = (mloLinks.size() > 0) ? mloLinks.get(link.link_id,
+                            new MloLink()).getRssi() : info.getRssi();
+                    linkStats.txLinkspeed = (mloLinks.size() > 0) ? mloLinks.get(link.link_id,
+                            new MloLink()).getTxLinkSpeedMbps() : info.getTxLinkSpeedMbps();
+                    linkStats.rxLinkspeed = (mloLinks.size() > 0) ? mloLinks.get(link.link_id,
+                            new MloLink()).getRxLinkSpeedMbps() : info.getRxLinkSpeedMbps();
+                    WifiLinkLayerStats.ChannelStats channlStatsEntryOnFreq =
+                            stats.channelStatsMap.get(link.frequencyMhz);
+                    if (channlStatsEntryOnFreq != null) {
+                        linkStats.channelWidth = channlStatsEntryOnFreq.channelWidth;
+                        linkStats.centerFreqFirstSeg =
+                            channlStatsEntryOnFreq.frequencyFirstSegment;
+                        linkStats.centerFreqSecondSeg =
+                            channlStatsEntryOnFreq.frequencySecondSegment;
+                        linkStats.onTimeInMs = channlStatsEntryOnFreq.radioOnTimeMs;
+                        linkStats.ccaBusyTimeInMs = channlStatsEntryOnFreq.ccaBusyTimeMs;
+                    }
+                    linkStats.contentionTimeStats =
+                            new ContentionTimeStats[NUM_WME_ACCESS_CATEGORIES];
+                    linkStats.packetStats = new PacketStats[NUM_WME_ACCESS_CATEGORIES];
+                    for (int ac = 0; ac < NUM_WME_ACCESS_CATEGORIES; ac++) {
+                        ContentionTimeStats contentionTimeStats = new ContentionTimeStats();
+                        PacketStats packetStats = new PacketStats();
+                        switch (ac) {
+                            case ContentionTimeStats.WME_ACCESS_CATEGORY_BE:
+                                contentionTimeStats.accessCategory =
+                                        ContentionTimeStats.WME_ACCESS_CATEGORY_BE;
+                                contentionTimeStats.contentionTimeMinMicros =
+                                        stats.contentionTimeMinBeInUsec;
+                                contentionTimeStats.contentionTimeMaxMicros =
+                                        stats.contentionTimeMaxBeInUsec;
+                                contentionTimeStats.contentionTimeAvgMicros =
+                                        stats.contentionTimeAvgBeInUsec;
+                                contentionTimeStats.contentionNumSamples =
+                                        stats.contentionNumSamplesBe;
+                                packetStats.accessCategory =
+                                        ContentionTimeStats.WME_ACCESS_CATEGORY_BE;
+                                packetStats.txSuccess = link.txmpdu_be;
+                                packetStats.txRetries = link.retries_be;
+                                packetStats.txBad = link.lostmpdu_be;
+                                packetStats.rxSuccess = link.rxmpdu_be;
+                                break;
+                            case ContentionTimeStats.WME_ACCESS_CATEGORY_BK:
+                                contentionTimeStats.accessCategory =
+                                        ContentionTimeStats.WME_ACCESS_CATEGORY_BK;
+                                contentionTimeStats.contentionTimeMinMicros =
+                                        stats.contentionTimeMinBkInUsec;
+                                contentionTimeStats.contentionTimeMaxMicros =
+                                        stats.contentionTimeMaxBkInUsec;
+                                contentionTimeStats.contentionTimeAvgMicros =
+                                        stats.contentionTimeAvgBkInUsec;
+                                contentionTimeStats.contentionNumSamples =
+                                        stats.contentionNumSamplesBk;
+                                packetStats.accessCategory =
+                                        ContentionTimeStats.WME_ACCESS_CATEGORY_BK;
+                                packetStats.txSuccess = link.txmpdu_bk;
+                                packetStats.txRetries = link.retries_bk;
+                                packetStats.txBad = link.lostmpdu_bk;
+                                packetStats.rxSuccess = link.rxmpdu_bk;
+                                break;
+                            case ContentionTimeStats.WME_ACCESS_CATEGORY_VI:
+                                contentionTimeStats.accessCategory =
+                                        ContentionTimeStats.WME_ACCESS_CATEGORY_VI;
+                                contentionTimeStats.contentionTimeMinMicros =
+                                        stats.contentionTimeMinViInUsec;
+                                contentionTimeStats.contentionTimeMaxMicros =
+                                        stats.contentionTimeMaxViInUsec;
+                                contentionTimeStats.contentionTimeAvgMicros =
+                                        stats.contentionTimeAvgViInUsec;
+                                contentionTimeStats.contentionNumSamples =
+                                        stats.contentionNumSamplesVi;
+                                packetStats.accessCategory =
+                                        ContentionTimeStats.WME_ACCESS_CATEGORY_VI;
+                                packetStats.txSuccess = link.txmpdu_vi;
+                                packetStats.txRetries = link.retries_vi;
+                                packetStats.txBad = link.lostmpdu_vi;
+                                packetStats.rxSuccess = link.rxmpdu_vi;
+                                break;
+                            case ContentionTimeStats.WME_ACCESS_CATEGORY_VO:
+                                contentionTimeStats.accessCategory =
+                                        ContentionTimeStats.WME_ACCESS_CATEGORY_VO;
+                                contentionTimeStats.contentionTimeMinMicros =
+                                        stats.contentionTimeMinVoInUsec;
+                                contentionTimeStats.contentionTimeMaxMicros =
+                                        stats.contentionTimeMaxVoInUsec;
+                                contentionTimeStats.contentionTimeAvgMicros =
+                                        stats.contentionTimeAvgVoInUsec;
+                                contentionTimeStats.contentionNumSamples =
+                                        stats.contentionNumSamplesVo;
+                                packetStats.accessCategory =
+                                        ContentionTimeStats.WME_ACCESS_CATEGORY_VO;
+                                packetStats.txSuccess = link.txmpdu_vo;
+                                packetStats.txRetries = link.retries_vo;
+                                packetStats.txBad = link.lostmpdu_vo;
+                                packetStats.rxSuccess = link.rxmpdu_vo;
+                                break;
+                            default:
+                                Log.e(TAG, "Unknown WME Access Category: " + ac);
                         }
-                        if (link.peerInfo != null && link.peerInfo.length > 0) {
-                            int numPeers = link.peerInfo.length;
-                            linkStats.peerInfo = new PeerInfo[numPeers];
-                            for (int peerIndex = 0; peerIndex < numPeers; ++peerIndex) {
-                                PeerInfo peerInfo = new PeerInfo();
-                                WifiLinkLayerStats.PeerInfo curPeer = link.peerInfo[peerIndex];
-                                peerInfo.staCount = curPeer.staCount;
-                                peerInfo.chanUtil = curPeer.chanUtil;
-                                if (curPeer.rateStats != null && curPeer.rateStats.length > 0) {
-                                    int numRates = curPeer.rateStats.length;
-                                    peerInfo.rateStats = new RateStats[numRates];
-                                    for (int rateIndex = 0; rateIndex < numRates; rateIndex++) {
-                                        RateStats rateStats = new RateStats();
-                                        WifiLinkLayerStats.RateStat curRate =
-                                                curPeer.rateStats[rateIndex];
-                                        rateStats.preamble = curRate.preamble;
-                                        rateStats.nss = curRate.nss;
-                                        rateStats.bw = curRate.bw;
-                                        rateStats.rateMcsIdx = curRate.rateMcsIdx;
-                                        rateStats.bitRateInKbps = curRate.bitRateInKbps;
-                                        rateStats.txMpdu = curRate.txMpdu;
-                                        rateStats.rxMpdu = curRate.rxMpdu;
-                                        rateStats.mpduLost = curRate.mpduLost;
-                                        rateStats.retries = curRate.retries;
-                                        peerInfo.rateStats[rateIndex] = rateStats;
-                                    }
+                        linkStats.contentionTimeStats[ac] = contentionTimeStats;
+                        linkStats.packetStats[ac] = packetStats;
+                    }
+                    if (link.peerInfo != null && link.peerInfo.length > 0) {
+                        int numPeers = link.peerInfo.length;
+                        linkStats.peerInfo = new PeerInfo[numPeers];
+                        for (int peerIndex = 0; peerIndex < numPeers; ++peerIndex) {
+                            PeerInfo peerInfo = new PeerInfo();
+                            WifiLinkLayerStats.PeerInfo curPeer = link.peerInfo[peerIndex];
+                            peerInfo.staCount = curPeer.staCount;
+                            peerInfo.chanUtil = curPeer.chanUtil;
+                            if (curPeer.rateStats != null && curPeer.rateStats.length > 0) {
+                                int numRates = curPeer.rateStats.length;
+                                peerInfo.rateStats = new RateStats[numRates];
+                                for (int rateIndex = 0; rateIndex < numRates; rateIndex++) {
+                                    RateStats rateStats = new RateStats();
+                                    WifiLinkLayerStats.RateStat curRate =
+                                            curPeer.rateStats[rateIndex];
+                                    rateStats.preamble = curRate.preamble;
+                                    rateStats.nss = curRate.nss;
+                                    rateStats.bw = curRate.bw;
+                                    rateStats.rateMcsIdx = curRate.rateMcsIdx;
+                                    rateStats.bitRateInKbps = curRate.bitRateInKbps;
+                                    rateStats.txMpdu = curRate.txMpdu;
+                                    rateStats.rxMpdu = curRate.rxMpdu;
+                                    rateStats.mpduLost = curRate.mpduLost;
+                                    rateStats.retries = curRate.retries;
+                                    peerInfo.rateStats[rateIndex] = rateStats;
                                 }
-                                linkStats.peerInfo[peerIndex] = peerInfo;
                             }
+                            linkStats.peerInfo[peerIndex] = peerInfo;
                         }
-                        List<ScanResultWithSameFreq> scanResultsWithSameFreq = new ArrayList<>();
-                        if (link.scan_results_same_freq != null
-                                && link.scan_results_same_freq.size() > 0) {
-                            for (int scanResultsIndex = 0; scanResultsIndex
-                                    < link.scan_results_same_freq.size(); ++scanResultsIndex) {
-                                WifiLinkLayerStats.ScanResultWithSameFreq linkLayerScanResult =
-                                        link.scan_results_same_freq.get(scanResultsIndex);
-                                if (linkLayerScanResult != null) {
-                                    String wifiLinkBssid = (mloLinks.size() > 0)
-                                            ? mloLinks.get(link.link_id, new MloLink())
-                                            .getApMacAddress().toString() : info.getBSSID();
-                                    if (!linkLayerScanResult.bssid.equals(wifiLinkBssid)) {
-                                        ScanResultWithSameFreq scanResultWithSameFreq =
-                                                new ScanResultWithSameFreq();
-                                        scanResultWithSameFreq.scanResultTimestampMicros =
-                                                linkLayerScanResult.scan_result_timestamp_micros;
-                                        scanResultWithSameFreq.rssi = linkLayerScanResult.rssi;
-                                        scanResultWithSameFreq.frequencyMhz =
-                                                linkLayerScanResult.frequencyMhz;
-                                        scanResultsWithSameFreq.add(scanResultWithSameFreq);
+                    }
+                    List<ScanResultWithSameFreq> scanResultsWithSameFreq = new ArrayList<>();
+                    if (link.scan_results_same_freq != null
+                            && link.scan_results_same_freq.size() > 0) {
+                        for (int scanResultsIndex = 0; scanResultsIndex
+                                < link.scan_results_same_freq.size(); ++scanResultsIndex) {
+                            WifiLinkLayerStats.ScanResultWithSameFreq linkLayerScanResult =
+                                    link.scan_results_same_freq.get(scanResultsIndex);
+                            if (linkLayerScanResult != null) {
+                                String wifiLinkBssid = "";
+                                if (mloLinks.size() > 0) {
+                                    MacAddress apMacAddress =
+                                            mloLinks.get(link.link_id, new MloLink())
+                                            .getApMacAddress();
+                                    if (apMacAddress != null) {
+                                        wifiLinkBssid = apMacAddress.toString();
                                     }
+                                } else {
+                                    wifiLinkBssid = info.getBSSID();
+                                }
+                                if (!linkLayerScanResult.bssid.equals(wifiLinkBssid)) {
+                                    ScanResultWithSameFreq scanResultWithSameFreq =
+                                            new ScanResultWithSameFreq();
+                                    scanResultWithSameFreq.scanResultTimestampMicros =
+                                            linkLayerScanResult.scan_result_timestamp_micros;
+                                    scanResultWithSameFreq.rssi = linkLayerScanResult.rssi;
+                                    scanResultWithSameFreq.frequencyMhz =
+                                            linkLayerScanResult.frequencyMhz;
+                                    scanResultsWithSameFreq.add(scanResultWithSameFreq);
                                 }
                             }
                         }
-                        linkStats.scanResultWithSameFreq =
-                            scanResultsWithSameFreq.toArray(new ScanResultWithSameFreq[0]);
-                        wifiUsabilityStatsEntry.linkStats[i] = linkStats;
                     }
+                    linkStats.scanResultWithSameFreq =
+                        scanResultsWithSameFreq.toArray(new ScanResultWithSameFreq[0]);
+                    wifiUsabilityStatsEntry.linkStats[i] = linkStats;
                 }
-                wifiUsabilityStatsEntry.mloMode = stats.wifiMloMode;
-                wifiUsabilityStatsEntry.labelBadEventCount = mAccumulatedLabelBadCount;
-                wifiUsabilityStatsEntry.wifiFrameworkState = mWifiFrameworkState;
-                wifiUsabilityStatsEntry.isNetworkCapabilitiesDownstreamSufficient =
-                        mSpeedSufficientNetworkCapabilities.Downstream;
-                wifiUsabilityStatsEntry.isNetworkCapabilitiesUpstreamSufficient =
-                        mSpeedSufficientNetworkCapabilities.Upstream;
-                wifiUsabilityStatsEntry.isThroughputPredictorDownstreamSufficient =
-                        mSpeedSufficientThroughputPredictor.Downstream;
-                wifiUsabilityStatsEntry.isThroughputPredictorUpstreamSufficient =
-                        mSpeedSufficientThroughputPredictor.Upstream;
-                wifiUsabilityStatsEntry.isBluetoothConnected =
-                        mWifiGlobals.isBluetoothConnected();
-                wifiUsabilityStatsEntry.uwbAdapterState = getLastUwbState();
-                wifiUsabilityStatsEntry.isLowLatencyActivated = getLowLatencyState();
-                wifiUsabilityStatsEntry.maxSupportedTxLinkspeed =
-                        info.getMaxSupportedTxLinkSpeedMbps();
-                wifiUsabilityStatsEntry.maxSupportedRxLinkspeed =
-                        info.getMaxSupportedRxLinkSpeedMbps();
-                wifiUsabilityStatsEntry.voipMode = getVoipMode();
-                wifiUsabilityStatsEntry.threadDeviceRole = getLastThreadDeviceRole();
             }
+            wifiUsabilityStatsEntry.mloMode = stats.wifiMloMode;
+            wifiUsabilityStatsEntry.labelBadEventCount = mAccumulatedLabelBadCount;
+            wifiUsabilityStatsEntry.wifiFrameworkState = mWifiFrameworkState;
+            wifiUsabilityStatsEntry.isNetworkCapabilitiesDownstreamSufficient =
+                    mSpeedSufficientNetworkCapabilities.Downstream;
+            wifiUsabilityStatsEntry.isNetworkCapabilitiesUpstreamSufficient =
+                    mSpeedSufficientNetworkCapabilities.Upstream;
+            wifiUsabilityStatsEntry.isThroughputPredictorDownstreamSufficient =
+                    mSpeedSufficientThroughputPredictor.Downstream;
+            wifiUsabilityStatsEntry.isThroughputPredictorUpstreamSufficient =
+                    mSpeedSufficientThroughputPredictor.Upstream;
+            wifiUsabilityStatsEntry.isBluetoothConnected =
+                    mWifiGlobals.isBluetoothConnected();
+            wifiUsabilityStatsEntry.uwbAdapterState = getLastUwbState();
+            wifiUsabilityStatsEntry.isLowLatencyActivated = getLowLatencyState();
+            wifiUsabilityStatsEntry.maxSupportedTxLinkspeed =
+                    info.getMaxSupportedTxLinkSpeedMbps();
+            wifiUsabilityStatsEntry.maxSupportedRxLinkspeed =
+                    info.getMaxSupportedRxLinkSpeedMbps();
+            wifiUsabilityStatsEntry.voipMode = getVoipMode();
+            wifiUsabilityStatsEntry.threadDeviceRole = getLastThreadDeviceRole();
 
             wifiUsabilityStatsEntry.timeStampMs = stats.timeStampInMs;
             wifiUsabilityStatsEntry.totalTxSuccess = stats.txmpdu_be + stats.txmpdu_bk
@@ -7428,17 +7530,15 @@ public class WifiMetrics {
                     radioStats.totalRoamScanTimeMs = radio.on_time_roam_scan;
                     radioStats.totalPnoScanTimeMs = radio.on_time_pno_scan;
                     radioStats.totalHotspot2ScanTimeMs = radio.on_time_hs20_scan;
-                    if (isWiFiScorerNewStatsCollected()) {
-                        if (radio.tx_time_in_ms_per_level != null
-                                && radio.tx_time_in_ms_per_level.length > 0) {
-                            int txTimePerLevelLength = radio.tx_time_in_ms_per_level.length;
-                            radioStats.txTimeMsPerLevel = new int[txTimePerLevelLength];
-                            for (int txTimePerLevelIndex = 0;
-                                    txTimePerLevelIndex < txTimePerLevelLength;
-                                    ++txTimePerLevelIndex) {
-                                radioStats.txTimeMsPerLevel[txTimePerLevelIndex] =
-                                    radio.tx_time_in_ms_per_level[txTimePerLevelIndex];
-                            }
+                    if (radio.tx_time_in_ms_per_level != null
+                            && radio.tx_time_in_ms_per_level.length > 0) {
+                        int txTimePerLevelLength = radio.tx_time_in_ms_per_level.length;
+                        radioStats.txTimeMsPerLevel = new int[txTimePerLevelLength];
+                        for (int txTimePerLevelIndex = 0;
+                                txTimePerLevelIndex < txTimePerLevelLength;
+                                ++txTimePerLevelIndex) {
+                            radioStats.txTimeMsPerLevel[txTimePerLevelIndex] =
+                                radio.tx_time_in_ms_per_level[txTimePerLevelIndex];
                         }
                     }
                     wifiUsabilityStatsEntry.radioStats[i] = radioStats;
@@ -7567,13 +7667,11 @@ public class WifiMetrics {
                         mWifiDataStall.isThroughputSufficient();
                 wifiUsabilityStatsEntry.isCellularDataAvailable =
                         mWifiDataStall.isCellularDataAvailable();
-                if (isWiFiScorerNewStatsCollected()) {
-                    wifiUsabilityStatsEntry.txTransmittedBytes =
-                        mWifiDataStall.getTxTransmittedBytes();
-                    wifiUsabilityStatsEntry.rxTransmittedBytes =
-                        mWifiDataStall.getRxTransmittedBytes();
-                    wifiUsabilityStatsEntry.statusDataStall = statusDataStall;
-                }
+                wifiUsabilityStatsEntry.txTransmittedBytes =
+                    mWifiDataStall.getTxTransmittedBytes();
+                wifiUsabilityStatsEntry.rxTransmittedBytes =
+                    mWifiDataStall.getRxTransmittedBytes();
+                wifiUsabilityStatsEntry.statusDataStall = statusDataStall;
             }
             if (mWifiSettingsStore != null) {
                 wifiUsabilityStatsEntry.isWifiScoringEnabled =
@@ -7607,8 +7705,6 @@ public class WifiMetrics {
                     ? WifiUsabilityStatsEntry.CAPTURE_EVENT_TYPE_ONESHOT_RSSI_POLL
                     : WifiUsabilityStatsEntry.CAPTURE_EVENT_TYPE_SYNCHRONOUS;
 
-            mWifiUsabilityStatsEntriesRingBuffer.add(wifiUsabilityStatsEntry);
-            mWifiUsabilityStatsEntryCounter++;
             if (mScoreBreachLowTimeMillis != -1) {
                 long elapsedTime =  mClock.getElapsedSinceBootMillis() - mScoreBreachLowTimeMillis;
                 if (elapsedTime >= MIN_SCORE_BREACH_TO_GOOD_STATS_WAIT_TIME_MS) {
@@ -7625,6 +7721,17 @@ public class WifiMetrics {
                                 info));
             }
 
+            // We need the records in the ring buffer to all have the same timebase. The records
+            // created here are timestamped by the WiFi driver and the timestamps have been found to
+            // drift relative to the Android clock. Historically, these records have been forwarded
+            // to external WiFi scorers with the drifting clock. In order to maintain historical
+            // behavior while ensuring that records in the ring buffer have the same timebase, we
+            // will send the record created in this function unmodified to any external WiFi Scorer,
+            // but we will modify the timestamp before storing in the ring buffer. Thus, the
+            // following statement, which also modifies the timestamp, must be executed AFTER the
+            // record is deep copied and sent to the external WiFi Scorer.
+            addToRingBuffer(wifiUsabilityStatsEntry);
+
             mSeqNumInsideFramework++;
             mProbeStatusSinceLastUpdate =
                     android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_NO_PROBE;
@@ -8112,9 +8219,15 @@ public class WifiMetrics {
         }
     }
 
-    private WifiUsabilityStatsEntry createNewWifiUsabilityStatsEntry(WifiUsabilityStatsEntry s) {
+    private WifiUsabilityStatsEntry createNewWifiUsabilityStatsEntry(WifiUsabilityStatsEntry s,
+            long referenceTimestampMs) {
         WifiUsabilityStatsEntry out = new WifiUsabilityStatsEntry();
-        out.timeStampMs = s.timeStampMs;
+        // Order the fields here according to the ID in
+        // packages/modules/Wifi/service/proto/src/metrics.proto
+        // Privacy review suggests not to upload real timestamp
+        out.timeStampMs = 0;
+        out.rssi = s.rssi;
+        out.linkSpeedMbps = s.linkSpeedMbps;
         out.totalTxSuccess = s.totalTxSuccess;
         out.totalTxRetries = s.totalTxRetries;
         out.totalTxBad = s.totalTxBad;
@@ -8128,21 +8241,23 @@ public class WifiMetrics {
         out.totalRoamScanTimeMs = s.totalRoamScanTimeMs;
         out.totalPnoScanTimeMs = s.totalPnoScanTimeMs;
         out.totalHotspot2ScanTimeMs = s.totalHotspot2ScanTimeMs;
-        out.rssi = s.rssi;
-        out.linkSpeedMbps = s.linkSpeedMbps;
-        out.totalCcaBusyFreqTimeMs = s.totalCcaBusyFreqTimeMs;
-        out.totalRadioOnFreqTimeMs = s.totalRadioOnFreqTimeMs;
-        out.totalBeaconRx = s.totalBeaconRx;
         out.wifiScore = s.wifiScore;
         out.wifiUsabilityScore = s.wifiUsabilityScore;
         out.seqNumToFramework = s.seqNumToFramework;
+        out.totalCcaBusyFreqTimeMs = s.totalCcaBusyFreqTimeMs;
+        out.totalRadioOnFreqTimeMs = s.totalRadioOnFreqTimeMs;
+        out.totalBeaconRx = s.totalBeaconRx;
         out.predictionHorizonSec = s.predictionHorizonSec;
         out.probeStatusSinceLastUpdate = s.probeStatusSinceLastUpdate;
         out.probeElapsedTimeSinceLastUpdateMs = s.probeElapsedTimeSinceLastUpdateMs;
         out.probeMcsRateSinceLastUpdate = s.probeMcsRateSinceLastUpdate;
         out.rxLinkSpeedMbps = s.rxLinkSpeedMbps;
-        out.isSameBssidAndFreq = s.isSameBssidAndFreq;
         out.seqNumInsideFramework = s.seqNumInsideFramework;
+        out.isSameBssidAndFreq = s.isSameBssidAndFreq;
+        // WifiUsabilityStatsEntry.cellularDataNetworkType (ID: 30) is not implemented
+        // WifiUsabilityStatsEntry.cellularSignalStrengthDbm (ID: 31) is not implemented
+        // WifiUsabilityStatsEntry.cellularSignalStrengthDb (ID: 32) is not implemented
+        // WifiUsabilityStatsEntry.isSameRegisteredCell (ID: 33) is not implemented
         out.deviceMobilityState = s.deviceMobilityState;
         out.timeSliceDutyCycleInPercent = s.timeSliceDutyCycleInPercent;
         out.contentionTimeStats = s.contentionTimeStats;
@@ -8172,10 +8287,19 @@ public class WifiMetrics {
         out.maxSupportedRxLinkspeed = s.maxSupportedRxLinkspeed;
         out.voipMode = s.voipMode;
         out.threadDeviceRole = s.threadDeviceRole;
+        out.captureEventType = s.captureEventType;
+        out.captureEventTypeSubcode = s.captureEventTypeSubcode;
         out.statusDataStall = s.statusDataStall;
+        out.timestampOffsetMs = s.timeStampMs - referenceTimestampMs;
         return out;
     }
 
+    private void addToRingBuffer(WifiUsabilityStatsEntry wifiUsabilityStatsEntry) {
+        // We override the timestamp here so that all records have the same time base.
+        wifiUsabilityStatsEntry.timeStampMs = mClock.getElapsedSinceBootMillis();
+        mWifiUsabilityStatsEntriesRingBuffer.add(wifiUsabilityStatsEntry);
+    }
+
     /**
      * Used to log an asynchronous event (such as WiFi disconnect) into the ring buffer.
      */
@@ -8183,15 +8307,16 @@ public class WifiMetrics {
         if (!isPrimary(ifaceName)) {
             return;
         }
-        WifiUsabilityStatsEntry wifiUsabilityStatsEntry =
-                mWifiUsabilityStatsEntriesRingBuffer.size()
-                < MAX_WIFI_USABILITY_STATS_ENTRIES_RING_BUFFER_SIZE
-                ? new WifiUsabilityStatsEntry() : mWifiUsabilityStatsEntriesRingBuffer.remove()
-                .clear();
-        wifiUsabilityStatsEntry.timeStampMs = mClock.getElapsedSinceBootMillis();
-        wifiUsabilityStatsEntry.captureEventType = e;
-        wifiUsabilityStatsEntry.captureEventTypeSubcode = c;
-        mWifiUsabilityStatsEntriesRingBuffer.add(wifiUsabilityStatsEntry);
+        synchronized (mLock) {
+            WifiUsabilityStatsEntry wifiUsabilityStatsEntry =
+                    mWifiUsabilityStatsEntriesRingBuffer.size()
+                    < MAX_WIFI_USABILITY_STATS_ENTRIES_RING_BUFFER_SIZE
+                    ? new WifiUsabilityStatsEntry() : mWifiUsabilityStatsEntriesRingBuffer.remove()
+                    .clear();
+            wifiUsabilityStatsEntry.captureEventType = e;
+            wifiUsabilityStatsEntry.captureEventTypeSubcode = c;
+            addToRingBuffer(wifiUsabilityStatsEntry);
+        }
     }
     /**
      * Used to log an asynchronous event (such as WiFi disconnect) into the ring buffer.
@@ -8202,82 +8327,6 @@ public class WifiMetrics {
         logAsynchronousEvent(ifaceName, e, -1);
     }
 
-    private WifiUsabilityStats createWifiUsabilityStatsWithLabel(int label, int triggerType,
-            int firmwareAlertCode) {
-        WifiUsabilityStats wifiUsabilityStats = new WifiUsabilityStats();
-        wifiUsabilityStats.label = label;
-        wifiUsabilityStats.triggerType = triggerType;
-        wifiUsabilityStats.firmwareAlertCode = firmwareAlertCode;
-        wifiUsabilityStats.timeStampMs = mClock.getElapsedSinceBootMillis();
-        wifiUsabilityStats.stats =
-                new WifiUsabilityStatsEntry[mWifiUsabilityStatsEntriesRingBuffer.size()];
-        for (int i = 0; i < mWifiUsabilityStatsEntriesRingBuffer.size(); i++) {
-            wifiUsabilityStats.stats[i] =
-                    createNewWifiUsabilityStatsEntry(mWifiUsabilityStatsEntriesRingBuffer.get(i));
-        }
-        return wifiUsabilityStats;
-    }
-
-    /**
-     * Label the current snapshot of WifiUsabilityStatsEntriesRingBuffer and save the labeled data
-     * inside a WifiUsabilityStats ptoto.
-     *
-     * @param label WifiUsabilityStats.LABEL_GOOD or WifiUsabilityStats.LABEL_BAD
-     * @param triggerType what event triggers WifiUsabilityStats
-     * @param firmwareAlertCode the firmware alert code when the stats was triggered by a
-     *        firmware alert
-     */
-    public void addToWifiUsabilityStatsList(String ifaceName, int label, int triggerType,
-            int firmwareAlertCode) {
-        synchronized (mLock) {
-            if (!isPrimary(ifaceName)) {
-                return;
-            }
-            if (mWifiUsabilityStatsEntriesRingBuffer.isEmpty() || !mScreenOn) {
-                return;
-            }
-            if (label == WifiUsabilityStats.LABEL_GOOD) {
-                // Only add a good event if at least |MIN_WIFI_GOOD_USABILITY_STATS_PERIOD_MS|
-                // has passed.
-                if (mWifiUsabilityStatsListGood.isEmpty()
-                        || mWifiUsabilityStatsListGood.getLast().stats[mWifiUsabilityStatsListGood
-                        .getLast().stats.length - 1].timeStampMs
-                        + MIN_WIFI_GOOD_USABILITY_STATS_PERIOD_MS
-                        < mWifiUsabilityStatsEntriesRingBuffer.getLast().timeStampMs) {
-                    while (mWifiUsabilityStatsListGood.size()
-                            >= MAX_WIFI_USABILITY_STATS_RECORDS_PER_TYPE) {
-                        mWifiUsabilityStatsListGood.remove(
-                                mRand.nextInt(mWifiUsabilityStatsListGood.size()));
-                    }
-                    mWifiUsabilityStatsListGood.add(
-                            createWifiUsabilityStatsWithLabel(label, triggerType,
-                                    firmwareAlertCode));
-                }
-            } else {
-                // Only add a bad event if at least |MIN_DATA_STALL_WAIT_MS|
-                // has passed.
-                mScoreBreachLowTimeMillis = -1;
-                if (mWifiUsabilityStatsListBad.isEmpty()
-                        || (mWifiUsabilityStatsListBad.getLast().stats[mWifiUsabilityStatsListBad
-                        .getLast().stats.length - 1].timeStampMs
-                        + MIN_DATA_STALL_WAIT_MS
-                        < mWifiUsabilityStatsEntriesRingBuffer.getLast().timeStampMs)) {
-                    while (mWifiUsabilityStatsListBad.size()
-                            >= MAX_WIFI_USABILITY_STATS_RECORDS_PER_TYPE) {
-                        mWifiUsabilityStatsListBad.remove(
-                                mRand.nextInt(mWifiUsabilityStatsListBad.size()));
-                    }
-                    mWifiUsabilityStatsListBad.add(
-                            createWifiUsabilityStatsWithLabel(label, triggerType,
-                                    firmwareAlertCode));
-                }
-                mAccumulatedLabelBadCount++;
-            }
-            mWifiUsabilityStatsEntryCounter = 0;
-            mWifiUsabilityStatsEntriesRingBuffer.clear();
-        }
-    }
-
     private DeviceMobilityStatePnoScanStats getOrCreateDeviceMobilityStatePnoScanStats(
             @DeviceMobilityState int deviceMobilityState) {
         DeviceMobilityStatePnoScanStats stats = mMobilityStatePnoStatsMap.get(deviceMobilityState);
@@ -8865,8 +8914,11 @@ public class WifiMetrics {
         }
     }
 
-    /** Add a WifiLock acquisition session */
-    public void addWifiLockAcqSession(int lockType, int[] attrUids, String[] attrTags,
+    /**
+     * Add a WifiLockManager acquisition session. This represents the session during which
+     * a single lock was held.
+     */
+    public void addWifiLockManagerAcqSession(int lockType, int[] attrUids, String[] attrTags,
             int callerType, long duration, boolean isPowersaveDisableAllowed,
             boolean isAppExemptedFromScreenOn, boolean isAppExemptedFromForeground) {
         int lockMode;
@@ -8884,6 +8936,27 @@ public class WifiMetrics {
                 Log.e(TAG, "addWifiLockAcqSession: Invalid lock type: " + lockType);
                 return;
         }
+        writeWifiLockAcqSession(lockMode, attrUids, attrTags, callerType, duration,
+                isPowersaveDisableAllowed, isAppExemptedFromScreenOn, isAppExemptedFromForeground);
+    }
+
+    /**
+     * Add a MulticastLockManager acquisition session. This represents the session during which
+     * a single lock was held.
+     */
+    public void addMulticastLockManagerAcqSession(
+            int uid, String attributionTag, int callerType, long duration) {
+        // Use a default value for the boolean parameters, since these fields
+        // don't apply to multicast locks.
+        writeWifiLockAcqSession(
+                WifiStatsLog.WIFI_LOCK_RELEASED__MODE__WIFI_MODE_MULTICAST_FILTERING_DISABLED,
+                new int[]{uid}, new String[]{attributionTag}, callerType, duration,
+                false, false, false);
+    }
+
+    private void writeWifiLockAcqSession(int lockMode, int[] attrUids, String[] attrTags,
+            int callerType, long duration, boolean isPowersaveDisableAllowed,
+            boolean isAppExemptedFromScreenOn, boolean isAppExemptedFromForeground) {
         WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_RELEASED,
                 attrUids,
                 attrTags,
@@ -8895,8 +8968,11 @@ public class WifiMetrics {
                 isAppExemptedFromForeground);
     }
 
-    /** Add a WifiLock active session */
-    public void addWifiLockActiveSession(int lockType, int[] attrUids, String[] attrTags,
+    /**
+     * Add a WifiLockManager active session. This represents the session during which
+     * low-latency mode was enabled.
+     */
+    public void addWifiLockManagerActiveSession(int lockType, int[] attrUids, String[] attrTags,
             long duration, boolean isPowersaveDisableAllowed,
             boolean isAppExemptedFromScreenOn, boolean isAppExemptedFromForeground) {
         int lockMode;
@@ -8919,6 +8995,25 @@ public class WifiMetrics {
                 Log.e(TAG, "addWifiLockActiveSession: Invalid lock type: " + lockType);
                 return;
         }
+        writeWifiLockActiveSession(lockMode, attrUids, attrTags, duration,
+                isPowersaveDisableAllowed, isAppExemptedFromScreenOn, isAppExemptedFromForeground);
+    }
+
+    /**
+     * Add a MulticastLockManager active session. This represents the session during which
+     * multicast packet filtering was disabled.
+     */
+    public void addMulticastLockManagerActiveSession(long duration) {
+        // Use a default value for the array and boolean parameters,
+        // since these fields don't apply to multicast locks
+        writeWifiLockActiveSession(
+                WifiStatsLog.WIFI_LOCK_DEACTIVATED__MODE__WIFI_MODE_MULTICAST_FILTERING_DISABLED,
+                new int[0], new String[0], duration, false, false, false);
+    }
+
+    private void writeWifiLockActiveSession(int lockMode, int[] attrUids, String[] attrTags,
+            long duration, boolean isPowersaveDisableAllowed,
+            boolean isAppExemptedFromScreenOn, boolean isAppExemptedFromForeground) {
         WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_DEACTIVATED,
                 attrUids,
                 attrTags,
@@ -9174,7 +9269,8 @@ public class WifiMetrics {
      */
     public void incrementConnectionDuration(String ifaceName, int timeDeltaLastTwoPollsMs,
             boolean isThroughputSufficient, boolean isCellularDataAvailable, int rssi, int txKbps,
-            int rxKbps) {
+            int rxKbps, int txLinkSpeedMbps, int rxLinkSpeedMbps,
+            @WifiAnnotations.ChannelWidth int channelBandwidth) {
         synchronized (mLock) {
             if (!isPrimary(ifaceName)) {
                 return;
@@ -9187,7 +9283,8 @@ public class WifiMetrics {
             WifiStatsLog.write(WifiStatsLog.WIFI_HEALTH_STAT_REPORTED, timeDeltaLastTwoPollsMs,
                     isThroughputSufficient || !mWifiWins, isCellularDataAvailable, band, rssi,
                     txKbps, rxKbps, mScorerUid, (wifiUsabilityState == WifiUsabilityState.USABLE),
-                    convertWifiUsabilityState(wifiUsabilityState));
+                    convertWifiUsabilityState(wifiUsabilityState),
+                    txLinkSpeedMbps, rxLinkSpeedMbps, convertChannelWidthToProto(channelBandwidth));
         }
     }
 
@@ -10476,6 +10573,155 @@ public class WifiMetrics {
                 WifiStatsLog.SOFT_AP_STATE_CHANGED__HOTSPOT_ON__STATE_OFF);
     }
 
+    /**
+     * Report that a client has disconnected from a soft ap session.
+     *
+     * @param disconnectReason reason for disconnection.
+     * @param source calling WorkSource that identifies the creator of the SoftAp.
+     */
+    public void reportOnClientsDisconnected(
+            @WifiAnnotations.SoftApDisconnectReason int disconnectReason,
+            WorkSource source) {
+        WifiStatsLog.write(WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED,
+                convertDisconnectReasonToProto(disconnectReason),
+                source.getUid(0)
+        );
+    }
+
+    private static int convertDisconnectReasonToProto(
+            @WifiAnnotations.SoftApDisconnectReason int disconnectReason) {
+        return switch (disconnectReason) {
+            case DeauthenticationReasonCode.REASON_UNKNOWN ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__UNKNOWN;
+            case DeauthenticationReasonCode.REASON_UNSPECIFIED ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__UNSPECIFIED;
+            case DeauthenticationReasonCode.REASON_PREV_AUTH_NOT_VALID ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__PREV_AUTH_NOT_VALID;
+            case DeauthenticationReasonCode.REASON_DEAUTH_LEAVING ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__DEAUTH_LEAVING;
+            case DeauthenticationReasonCode.REASON_DISASSOC_DUE_TO_INACTIVITY ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__DISASSOC_DUE_TO_INACTIVITY;
+            case DeauthenticationReasonCode.REASON_DISASSOC_AP_BUSY ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__DISASSOC_AP_BUSY;
+            case DeauthenticationReasonCode.REASON_CLASS2_FRAME_FROM_NONAUTH_STA ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__CLASS2_FRAME_FROM_NONAUTH_STA;
+            case DeauthenticationReasonCode.REASON_CLASS3_FRAME_FROM_NONASSOC_STA ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__CLASS3_FRAME_FROM_NONASSOC_STA;
+            case DeauthenticationReasonCode.REASON_DISASSOC_STA_HAS_LEFT ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__DISASSOC_STA_HAS_LEFT;
+            case DeauthenticationReasonCode.REASON_STA_REQ_ASSOC_WITHOUT_AUTH ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__STA_REQ_ASSOC_WITHOUT_AUTH;
+            case DeauthenticationReasonCode.REASON_PWR_CAPABILITY_NOT_VALID ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__PWR_CAPABILITY_NOT_VALID;
+            case DeauthenticationReasonCode.REASON_SUPPORTED_CHANNEL_NOT_VALID ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__SUPPORTED_CHANNEL_NOT_VALID;
+            case DeauthenticationReasonCode.REASON_BSS_TRANSITION_DISASSOC ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__BSS_TRANSITION_DISASSOC;
+            case DeauthenticationReasonCode.REASON_INVALID_IE ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__INVALID_IE;
+            case DeauthenticationReasonCode.REASON_MICHAEL_MIC_FAILURE ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MICHAEL_MIC_FAILURE;
+            case DeauthenticationReasonCode.REASON_FOURWAY_HANDSHAKE_TIMEOUT ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__FOURWAY_HANDSHAKE_TIMEOUT;
+            case DeauthenticationReasonCode.REASON_GROUP_KEY_UPDATE_TIMEOUT ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__GROUP_KEY_UPDATE_TIMEOUT;
+            case DeauthenticationReasonCode.REASON_IE_IN_4WAY_DIFFERS ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__IE_IN_4WAY_DIFFERS;
+            case DeauthenticationReasonCode.REASON_GROUP_CIPHER_NOT_VALID ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__GROUP_CIPHER_NOT_VALID;
+            case DeauthenticationReasonCode.REASON_PAIRWISE_CIPHER_NOT_VALID ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__PAIRWISE_CIPHER_NOT_VALID;
+            case DeauthenticationReasonCode.REASON_AKMP_NOT_VALID ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__AKMP_NOT_VALID;
+            case DeauthenticationReasonCode.REASON_UNSUPPORTED_RSN_IE_VERSION ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__UNSUPPORTED_RSN_IE_VERSION;
+            case DeauthenticationReasonCode.REASON_INVALID_RSN_IE_CAPAB ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__INVALID_RSN_IE_CAPAB;
+            case DeauthenticationReasonCode.REASON_IEEE_802_1X_AUTH_FAILED ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__IEEE_802_1X_AUTH_FAILED;
+            case DeauthenticationReasonCode.REASON_CIPHER_SUITE_REJECTED ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__CIPHER_SUITE_REJECTED;
+            case DeauthenticationReasonCode.REASON_TDLS_TEARDOWN_UNREACHABLE ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__TDLS_TEARDOWN_UNREACHABLE;
+            case DeauthenticationReasonCode.REASON_TDLS_TEARDOWN_UNSPECIFIED ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__TDLS_TEARDOWN_UNSPECIFIED;
+            case DeauthenticationReasonCode.REASON_SSP_REQUESTED_DISASSOC ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__SSP_REQUESTED_DISASSOC;
+            case DeauthenticationReasonCode.REASON_NO_SSP_ROAMING_AGREEMENT ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__NO_SSP_ROAMING_AGREEMENT;
+            case DeauthenticationReasonCode.REASON_BAD_CIPHER_OR_AKM ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__BAD_CIPHER_OR_AKM;
+            case DeauthenticationReasonCode.REASON_NOT_AUTHORIZED_THIS_LOCATION ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__NOT_AUTHORIZED_THIS_LOCATION;
+            case DeauthenticationReasonCode.REASON_SERVICE_CHANGE_PRECLUDES_TS ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__SERVICE_CHANGE_PRECLUDES_TS;
+            case DeauthenticationReasonCode.REASON_UNSPECIFIED_QOS_REASON ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__UNSPECIFIED_QOS_REASON;
+            case DeauthenticationReasonCode.REASON_NOT_ENOUGH_BANDWIDTH ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__NOT_ENOUGH_BANDWIDTH;
+            case DeauthenticationReasonCode.REASON_DISASSOC_LOW_ACK ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__DISASSOC_LOW_ACK;
+            case DeauthenticationReasonCode.REASON_EXCEEDED_TXOP ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__EXCEEDED_TXOP;
+            case DeauthenticationReasonCode.REASON_STA_LEAVING ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__STA_LEAVING;
+            case DeauthenticationReasonCode.REASON_END_TS_BA_DLS ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__END_TS_BA_DLS;
+            case DeauthenticationReasonCode.REASON_UNKNOWN_TS_BA ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__UNKNOWN_TS_BA;
+            case DeauthenticationReasonCode.REASON_TIMEOUT ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__TIMEOUT;
+            case DeauthenticationReasonCode.REASON_PEERKEY_MISMATCH ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__PEERKEY_MISMATCH;
+            case DeauthenticationReasonCode.REASON_AUTHORIZED_ACCESS_LIMIT_REACHED ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__AUTHORIZED_ACCESS_LIMIT_REACHED;
+            case DeauthenticationReasonCode.REASON_EXTERNAL_SERVICE_REQUIREMENTS ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__EXTERNAL_SERVICE_REQUIREMENTS;
+            case DeauthenticationReasonCode.REASON_INVALID_FT_ACTION_FRAME_COUNT ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__INVALID_FT_ACTION_FRAME_COUNT;
+            case DeauthenticationReasonCode.REASON_INVALID_PMKID ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__INVALID_PMKID;
+            case DeauthenticationReasonCode.REASON_INVALID_MDE ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__INVALID_MDE;
+            case DeauthenticationReasonCode.REASON_INVALID_FTE ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__INVALID_FTE;
+            case DeauthenticationReasonCode.REASON_MESH_PEERING_CANCELLED ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_PEERING_CANCELLED;
+            case DeauthenticationReasonCode.REASON_MESH_MAX_PEERS ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_MAX_PEERS;
+            case DeauthenticationReasonCode.REASON_MESH_CONFIG_POLICY_VIOLATION ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_CONFIG_POLICY_VIOLATION;
+            case DeauthenticationReasonCode.REASON_MESH_CLOSE_RCVD ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_CLOSE_RCVD;
+            case DeauthenticationReasonCode.REASON_MESH_MAX_RETRIES ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_MAX_RETRIES;
+            case DeauthenticationReasonCode.REASON_MESH_CONFIRM_TIMEOUT ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_CONFIRM_TIMEOUT;
+            case DeauthenticationReasonCode.REASON_MESH_INVALID_GTK ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_INVALID_GTK;
+            case DeauthenticationReasonCode.REASON_MESH_INCONSISTENT_PARAMS ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_INCONSISTENT_PARAMS;
+            case DeauthenticationReasonCode.REASON_MESH_INVALID_SECURITY_CAP ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_INVALID_SECURITY_CAP;
+            case DeauthenticationReasonCode.REASON_MESH_PATH_ERROR_NO_PROXY_INFO ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_PATH_ERROR_NO_PROXY_INFO;
+            case DeauthenticationReasonCode.REASON_MESH_PATH_ERROR_NO_FORWARDING_INFO ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_PATH_ERROR_NO_FORWARDING_INFO;
+            case DeauthenticationReasonCode.REASON_MESH_PATH_ERROR_DEST_UNREACHABLE ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_PATH_ERROR_DEST_UNREACHABLE;
+            case DeauthenticationReasonCode.REASON_MAC_ADDRESS_ALREADY_EXISTS_IN_MBSS ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MAC_ADDRESS_ALREADY_EXISTS_IN_MBSS;
+            case DeauthenticationReasonCode.REASON_MESH_CHANNEL_SWITCH_REGULATORY_REQ ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_CHANNEL_SWITCH_REGULATORY_REQ;
+            case DeauthenticationReasonCode.REASON_MESH_CHANNEL_SWITCH_UNSPECIFIED ->
+                    WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__MESH_CHANNEL_SWITCH_UNSPECIFIED;
+            default -> {
+                Log.e(TAG, "Invalid disconnectReason: " + disconnectReason);
+                yield WifiStatsLog.WIFI_SOFT_AP_CALLBACK_ON_CLIENTS_DISCONNECTED__DISCONNECT_REASON__UNKNOWN;
+            }
+        };
+    }
+
     public int getLastUwbState() {
         return mLastUwbState;
     }
diff --git a/service/java/com/android/server/wifi/WifiMonitor.java b/service/java/com/android/server/wifi/WifiMonitor.java
index 7e2e503fe1..eaee9642c9 100644
--- a/service/java/com/android/server/wifi/WifiMonitor.java
+++ b/service/java/com/android/server/wifi/WifiMonitor.java
@@ -28,6 +28,8 @@ import android.util.ArraySet;
 import android.util.Log;
 import android.util.SparseArray;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.Protocol;
 import com.android.server.wifi.MboOceController.BtmFrameData;
@@ -178,6 +180,7 @@ public class WifiMonitor {
     }
 
     private final Map<String, SparseArray<Set<Handler>>> mHandlerMap = new HashMap<>();
+    @Keep
     public synchronized void registerHandler(String iface, int what, Handler handler) {
         SparseArray<Set<Handler>> ifaceHandlers = mHandlerMap.get(iface);
         if (ifaceHandlers == null) {
@@ -198,6 +201,7 @@ public class WifiMonitor {
      * @param what
      * @param handler
      */
+    @Keep
     public synchronized void deregisterHandler(String iface, int what, Handler handler) {
         SparseArray<Set<Handler>> ifaceHandlers = mHandlerMap.get(iface);
         if (ifaceHandlers == null) {
diff --git a/service/java/com/android/server/wifi/WifiMulticastLockManager.java b/service/java/com/android/server/wifi/WifiMulticastLockManager.java
index fa40fd7d3b..598bf5716d 100644
--- a/service/java/com/android/server/wifi/WifiMulticastLockManager.java
+++ b/service/java/com/android/server/wifi/WifiMulticastLockManager.java
@@ -29,6 +29,7 @@ import android.os.WorkSource;
 import android.util.Log;
 
 import com.android.server.wifi.proto.WifiStatsLog;
+import com.android.server.wifi.util.WifiPermissionsUtil;
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -49,11 +50,16 @@ public class WifiMulticastLockManager {
     private final Map<Integer, Integer> mNumLocksPerInactiveOwner = new HashMap<>();
     private int mMulticastEnabled = 0;
     private int mMulticastDisabled = 0;
+    private boolean mIsFilterDisableSessionActive = false;
+    private long mFilterDisableSessionStartTime;
     private final Handler mHandler;
     private final Object mLock = new Object();
     private boolean mVerboseLoggingEnabled = false;
     private final BatteryStatsManager mBatteryStats;
     private final ActiveModeWarden mActiveModeWarden;
+    private final Clock mClock;
+    private final WifiMetrics mWifiMetrics;
+    private final WifiPermissionsUtil mWifiPermissionsUtil;
 
     /** Delegate for handling state change events for multicast filtering. */
     public interface FilterController {
@@ -68,10 +74,16 @@ public class WifiMulticastLockManager {
             ActiveModeWarden activeModeWarden,
             BatteryStatsManager batteryStats,
             Looper looper,
-            Context context) {
+            Context context,
+            Clock clock,
+            WifiMetrics wifiMetrics,
+            WifiPermissionsUtil wifiPermissionsUtil) {
         mBatteryStats = batteryStats;
         mActiveModeWarden = activeModeWarden;
         mHandler = new Handler(looper);
+        mClock = clock;
+        mWifiMetrics = wifiMetrics;
+        mWifiPermissionsUtil = wifiPermissionsUtil;
 
         mActiveModeWarden.registerPrimaryClientModeManagerChangedCallback(
                 new PrimaryClientModeManagerChangedCallback());
@@ -89,11 +101,18 @@ public class WifiMulticastLockManager {
         String mTag;
         int mUid;
         IBinder mBinder;
+        String mAttributionTag;
+        String mPackageName;
+        long mAcquireTime;
 
-        Multicaster(int uid, IBinder binder, String tag) {
+        Multicaster(int uid, IBinder binder, String tag, String attributionTag,
+                String packageName) {
             mTag = tag;
             mUid = uid;
             mBinder = binder;
+            mAttributionTag = attributionTag;
+            mPackageName = packageName;
+            mAcquireTime = mClock.getElapsedSinceBootMillis();
             try {
                 mBinder.linkToDeath(this, 0);
             } catch (RemoteException e) {
@@ -130,6 +149,18 @@ public class WifiMulticastLockManager {
             return mBinder;
         }
 
+        public String getAttributionTag() {
+            return mAttributionTag;
+        }
+
+        public String getPackageName() {
+            return mPackageName;
+        }
+
+        public long getAcquireTime() {
+            return mAcquireTime;
+        }
+
         public String toString() {
             return "Multicaster{" + mTag + " uid=" + mUid  + "}";
         }
@@ -206,25 +237,44 @@ public class WifiMulticastLockManager {
     public void startFilteringMulticastPackets() {
         synchronized (mLock) {
             if (!isMulticastEnabled()) {
+                if (mIsFilterDisableSessionActive) {
+                    // Log the end of the filtering disabled session,
+                    // since we're about to re-enable multicast packet filtering
+                    mWifiMetrics.addMulticastLockManagerActiveSession(
+                            mClock.getElapsedSinceBootMillis() - mFilterDisableSessionStartTime);
+                }
                 mActiveModeWarden.getPrimaryClientModeManager()
                         .getMcastLockManagerFilterController()
                         .startFilteringMulticastPackets();
+                mIsFilterDisableSessionActive = false;
             }
         }
     }
 
     private void stopFilteringMulticastPackets() {
-        mActiveModeWarden.getPrimaryClientModeManager()
-                .getMcastLockManagerFilterController()
-                .stopFilteringMulticastPackets();
+        synchronized (mLock) {
+            if (!mIsFilterDisableSessionActive) {
+                // Mark the beginning of a filtering disabled session,
+                // since we're about to disable multicast packet filtering
+                mFilterDisableSessionStartTime = mClock.getElapsedSinceBootMillis();
+            }
+            mActiveModeWarden.getPrimaryClientModeManager()
+                    .getMcastLockManagerFilterController()
+                    .stopFilteringMulticastPackets();
+            mIsFilterDisableSessionActive = true;
+        }
     }
 
     /**
      * Acquire a multicast lock.
+     * @param uid uid of the calling application
      * @param binder a binder used to ensure caller is still alive
-     * @param tag string name of the caller.
+     * @param lockTag caller-provided tag to identify this lock
+     * @param attributionTag attribution tag of the calling application
+     * @param packageName package name of the calling application
      */
-    public void acquireLock(int uid, IBinder binder, String tag) {
+    public void acquireLock(int uid, IBinder binder, String lockTag, String attributionTag,
+            String packageName) {
         synchronized (mLock) {
             mMulticastEnabled++;
 
@@ -234,35 +284,33 @@ public class WifiMulticastLockManager {
             }
             int numLocksHeldByUid = mNumLocksPerActiveOwner.getOrDefault(uid, 0);
             mNumLocksPerActiveOwner.put(uid, numLocksHeldByUid + 1);
-            mMulticasters.add(new Multicaster(uid, binder, tag));
+            mMulticasters.add(new Multicaster(uid, binder, lockTag, attributionTag, packageName));
 
             // Note that we could call stopFilteringMulticastPackets only when
             // our new size == 1 (first call), but this function won't
             // be called often and by making the stopPacket call each
             // time we're less fragile and self-healing.
-            mActiveModeWarden.getPrimaryClientModeManager()
-                    .getMcastLockManagerFilterController()
-                    .stopFilteringMulticastPackets();
+            stopFilteringMulticastPackets();
         }
 
         final long ident = Binder.clearCallingIdentity();
         mBatteryStats.reportWifiMulticastEnabled(new WorkSource(uid));
         WifiStatsLog.write_non_chained(
                 WifiStatsLog.WIFI_MULTICAST_LOCK_STATE_CHANGED, uid, null,
-                WifiStatsLog.WIFI_MULTICAST_LOCK_STATE_CHANGED__STATE__ON, tag);
+                WifiStatsLog.WIFI_MULTICAST_LOCK_STATE_CHANGED__STATE__ON, lockTag);
         Binder.restoreCallingIdentity(ident);
     }
 
     /** Releases a multicast lock */
-    public void releaseLock(int uid, IBinder binder, String tag) {
+    public void releaseLock(int uid, IBinder binder, String lockTag) {
         synchronized (mLock) {
             mMulticastDisabled++;
             int size = mMulticasters.size();
             for (int i = size - 1; i >= 0; i--) {
                 Multicaster m = mMulticasters.get(i);
-                if ((m != null) && (m.getUid() == uid) && (m.getTag().equals(tag))
+                if ((m != null) && (m.getUid() == uid) && (m.getTag().equals(lockTag))
                         && (m.getBinder() == binder)) {
-                    removeMulticasterLocked(i, uid, tag);
+                    removeMulticasterLocked(i, uid, lockTag);
                     break;
                 }
             }
@@ -282,6 +330,10 @@ public class WifiMulticastLockManager {
         Multicaster removed = mMulticasters.remove(i);
         if (removed != null) {
             removed.unlinkDeathRecipient();
+            mWifiMetrics.addMulticastLockManagerAcqSession(
+                    uid, removed.getAttributionTag(),
+                    mWifiPermissionsUtil.getWifiCallerType(uid, removed.getPackageName()),
+                    mClock.getElapsedSinceBootMillis() - removed.getAcquireTime());
         }
 
         if (mNumLocksPerActiveOwner.containsKey(uid)) {
@@ -291,9 +343,7 @@ public class WifiMulticastLockManager {
         }
 
         if (!isMulticastEnabled()) {
-            mActiveModeWarden.getPrimaryClientModeManager()
-                    .getMcastLockManagerFilterController()
-                    .startFilteringMulticastPackets();
+            startFilteringMulticastPackets();
         }
 
         final long ident = Binder.clearCallingIdentity();
diff --git a/service/java/com/android/server/wifi/WifiNative.java b/service/java/com/android/server/wifi/WifiNative.java
index 26e1adc141..3694dfd0a1 100644
--- a/service/java/com/android/server/wifi/WifiNative.java
+++ b/service/java/com/android/server/wifi/WifiNative.java
@@ -62,6 +62,8 @@ import android.net.wifi.nl80211.RadioChainInfo;
 import android.net.wifi.nl80211.WifiNl80211Manager;
 import android.net.wifi.twt.TwtRequest;
 import android.net.wifi.twt.TwtSessionCallback;
+import android.net.wifi.usd.PublishConfig;
+import android.net.wifi.usd.SubscribeConfig;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
@@ -74,6 +76,8 @@ import android.util.Log;
 import android.util.SparseArray;
 import android.util.SparseIntArray;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.Immutable;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.HexDump;
@@ -84,8 +88,10 @@ import com.android.server.wifi.hal.WifiChip;
 import com.android.server.wifi.hal.WifiHal;
 import com.android.server.wifi.hal.WifiNanIface;
 import com.android.server.wifi.hotspot2.NetworkDetail;
+import com.android.server.wifi.mainline_supplicant.MainlineSupplicant;
 import com.android.server.wifi.mockwifi.MockWifiServiceUtil;
 import com.android.server.wifi.proto.WifiStatsLog;
+import com.android.server.wifi.usd.UsdRequestManager;
 import com.android.server.wifi.util.FrameParser;
 import com.android.server.wifi.util.InformationElementUtil;
 import com.android.server.wifi.util.NativeUtil;
@@ -156,19 +162,22 @@ public class WifiNative {
     private boolean mIsLocationModeEnabled = false;
     private long mLastLocationModeEnabledTimeMs = 0;
     private Map<String, Bundle> mCachedTwtCapabilities = new ArrayMap<>();
+    private final MainlineSupplicant mMainlineSupplicant;
+
     /**
      * Mapping of unknown AKMs configured in overlay config item
      * config_wifiUnknownAkmToKnownAkmMapping to ScanResult security key management scheme
      * (ScanResult.KEY_MGMT_XX)
      */
     @VisibleForTesting @Nullable SparseIntArray mUnknownAkmMap;
+    private SupplicantStaIfaceHal.UsdCapabilitiesInternal mCachedUsdCapabilities = null;
 
     public WifiNative(WifiVendorHal vendorHal,
                       SupplicantStaIfaceHal staIfaceHal, HostapdHal hostapdHal,
                       WifiNl80211Manager condManager, WifiMonitor wifiMonitor,
                       PropertyService propertyService, WifiMetrics wifiMetrics,
                       Handler handler, Random random, BuildProperties buildProperties,
-                      WifiInjector wifiInjector) {
+                      WifiInjector wifiInjector, MainlineSupplicant mainlineSupplicant) {
         mWifiVendorHal = vendorHal;
         mSupplicantStaIfaceHal = staIfaceHal;
         mHostapdHal = hostapdHal;
@@ -181,6 +190,7 @@ public class WifiNative {
         mBuildProperties = buildProperties;
         mWifiInjector = wifiInjector;
         mContext = wifiInjector.getContext();
+        mMainlineSupplicant = mainlineSupplicant;
         initializeUnknownAkmMapping();
     }
 
@@ -267,6 +277,80 @@ public class WifiNative {
         return mCachedTwtCapabilities.get(interfaceName);
     }
 
+    /**
+     * Whether USD subscriber is supported in USD capability or not.
+     */
+    public boolean isUsdSubscriberSupported() {
+        return mCachedUsdCapabilities != null && mCachedUsdCapabilities.isUsdSubscriberSupported;
+    }
+
+    /**
+     * Whether USD publisher is supported in USD capability or not.
+     */
+    public boolean isUsdPublisherSupported() {
+        return mCachedUsdCapabilities != null && mCachedUsdCapabilities.isUsdPublisherSupported;
+    }
+
+    /**
+     * Gets USD capabilities.
+     */
+    public SupplicantStaIfaceHal.UsdCapabilitiesInternal getUsdCapabilities() {
+        return mCachedUsdCapabilities;
+    }
+
+    /**
+     * Start USD publish.
+     */
+    public boolean startUsdPublish(String interfaceName, int cmdId, PublishConfig publishConfig) {
+        return mSupplicantStaIfaceHal.startUsdPublish(interfaceName, cmdId, publishConfig);
+    }
+
+    /**
+     * Register a framework callback to receive USD events from HAL.
+     */
+    public void registerUsdEventsCallback(
+            UsdRequestManager.UsdNativeEventsCallback usdNativeEventsCallback) {
+        mSupplicantStaIfaceHal.registerUsdEventsCallback(usdNativeEventsCallback);
+    }
+
+    /**
+     * Start USD subscribe.
+     */
+    public boolean startUsdSubscribe(String interfaceName, int cmdId,
+            SubscribeConfig subscribeConfig) {
+        return mSupplicantStaIfaceHal.startUsdSubscribe(interfaceName, cmdId, subscribeConfig);
+    }
+
+    /**
+     * Update USD publish.
+     */
+    public void updateUsdPublish(String interfaceName, int publishId, byte[] ssi) {
+        mSupplicantStaIfaceHal.updateUsdPublish(interfaceName, publishId, ssi);
+    }
+
+    /**
+     * Cancel USD publish.
+     */
+    public void cancelUsdPublish(String interfaceName, int publishId) {
+        mSupplicantStaIfaceHal.cancelUsdPublish(interfaceName, publishId);
+    }
+
+    /**
+     * Cancel USD subscribe.
+     */
+    public void cancelUsdSubscribe(String interfaceName, int subscribeId) {
+        mSupplicantStaIfaceHal.cancelUsdSubscribe(interfaceName, subscribeId);
+    }
+
+    /**
+     * Send USD message to the peer identified by the peerId and the peerMacAddress.
+     */
+    public boolean sendUsdMessage(String interfaceName, int ownId, int peerId,
+            MacAddress peerMacAddress, byte[] message) {
+        return mSupplicantStaIfaceHal.sendUsdMessage(interfaceName, ownId, peerId, peerMacAddress,
+                message);
+    }
+
     /**
      * Callbacks for SoftAp interface.
      */
@@ -290,7 +374,7 @@ public class WifiNative {
         @Override
         public void onSoftApChannelSwitched(int frequency, int bandwidth) {
             mSoftApHalCallback.onInfoChanged(mIfaceName, frequency, bandwidth,
-                    ScanResult.WIFI_STANDARD_UNKNOWN, null, Collections.emptyList());
+                    ScanResult.WIFI_STANDARD_UNKNOWN, null, null, Collections.emptyList());
         }
 
         @Override
@@ -349,11 +433,15 @@ public class WifiNative {
          *                     indication that the SoftAp is not enabled.
          * @param bandwidth The new bandwidth of the SoftAp.
          * @param generation The new generation of the SoftAp.
+         * @param apIfaceInstanceMacAddress MAC Address of the apIfaceInstance.
+         * @param mldMacAddress MAC Address of the multiple link device (MLD) which apIfaceInstance
+         *                      is associated with.
          * @param vendorData List of {@link OuiKeyedData} containing vendor-specific configuration
          *                   data, or empty list if not provided.
          */
         void onInfoChanged(String apIfaceInstance, int frequency, int bandwidth,
-                int generation, MacAddress apIfaceInstanceMacAddress,
+                int generation, @Nullable MacAddress apIfaceInstanceMacAddress,
+                @Nullable MacAddress mldMacAddress,
                 @NonNull List<OuiKeyedData> vendorData);
         /**
          * Invoked when there is a change in the associated station (STA).
@@ -734,6 +822,15 @@ public class WifiNative {
                     Log.e(TAG, "Failed to register supplicant death handler");
                     return false;
                 }
+                if (mMainlineSupplicant.isAvailable()) {
+                    if (mMainlineSupplicant.startService()) {
+                        mMainlineSupplicant.registerFrameworkDeathHandler(
+                                new MainlineSupplicantDeathHandlerInternal());
+                    } else {
+                        // Fail quietly if the mainline supplicant does not start
+                        Log.e(TAG, "Unable to start the mainline supplicant");
+                    }
+                }
             }
             return true;
         }
@@ -756,6 +853,12 @@ public class WifiNative {
                         mWifiInjector.getWifiP2pNative().stopP2pSupplicantIfNecessary();
                     }
                 }
+
+                // Mainline supplicant should be disabled if no STA ifaces are in use
+                if (mMainlineSupplicant.isActive()) {
+                    mMainlineSupplicant.unregisterFrameworkDeathHandler();
+                    mMainlineSupplicant.stopService();
+                }
             }
         }
     }
@@ -835,6 +938,11 @@ public class WifiNative {
             if (!mSupplicantStaIfaceHal.teardownIface(iface.name)) {
                 Log.e(TAG, "Failed to teardown iface in supplicant on " + iface);
             }
+            if (mMainlineSupplicant.isActive()
+                    && !mMainlineSupplicant.removeStaInterface(iface.name)) {
+                Log.e(TAG, "Unable to tear down " + iface.name + " in the mainline supplicant"
+                        + " after client interface destroyed");
+            }
             if (!mWifiCondManager.tearDownClientInterface(iface.name)) {
                 Log.e(TAG, "Failed to teardown iface in wificond on " + iface);
             }
@@ -998,6 +1106,19 @@ public class WifiNative {
         }
     }
 
+    /**
+     * Death handler for the mainline supplicant.
+     */
+    private class MainlineSupplicantDeathHandlerInternal implements SupplicantDeathEventHandler {
+        public void onDeath() {
+            mHandler.post(() -> {
+                // TODO: Add metrics for mainline supplicant crashes
+                Log.i(TAG, "Mainline supplicant died. Cleaning up internal state.");
+                onNativeDaemonDeath();
+            });
+        }
+    }
+
     /** Helper method invoked to handle interface change. */
     private void onInterfaceStateChanged(Iface iface, boolean isUp) {
         synchronized (mLock) {
@@ -1417,11 +1538,16 @@ public class WifiNative {
      *
      * @param ifaceName Name of the iface.
      * @param apIfaceInstance The identity of the ap instance.
+     * @param isMloAp true when current access point is using multiple link operation.
      * @return true if the operation succeeded, false if there is an error in Hal.
      */
     public boolean removeIfaceInstanceFromBridgedApIface(@NonNull String ifaceName,
-            @NonNull String apIfaceInstance) {
+            @NonNull String apIfaceInstance, boolean isMloAp) {
         synchronized (mLock) {
+            if (isMloAp && mHostapdHal != null && Flags.mloSap()) {
+                mHostapdHal.removeLinkFromMultipleLinkBridgedApIface(ifaceName,
+                        apIfaceInstance);
+            }
             if (mWifiVendorHal.isVendorHalSupported()) {
                 return mWifiVendorHal.removeIfaceInstanceFromBridgedApIface(ifaceName,
                         apIfaceInstance);
@@ -1598,6 +1724,17 @@ public class WifiNative {
                 && cachedFeatureSet.get(WifiManager.WIFI_FEATURE_SOFTAP_MLO);
     }
 
+    /**
+     * Return true when the device supports multiple Wi-Fi 7 multi-link devices (MLD) on SoftAp.
+     */
+    public boolean isMultipleMLDSupportedOnSap() {
+        if (!Flags.multipleMldOnSapSupported()) {
+            return false;
+        }
+        BitSet cachedFeatureSet = getCompleteFeatureSetFromConfigStore();
+        return cachedFeatureSet.get(WifiManager.WIFI_FEATURE_MULTIPLE_MLD_ON_SAP);
+    }
+
     /**
      * Setup an interface for Soft AP mode operations.
      *
@@ -1706,15 +1843,26 @@ public class WifiNative {
     public boolean switchClientInterfaceToScanMode(@NonNull String ifaceName,
             @NonNull WorkSource requestorWs) {
         synchronized (mLock) {
-            final Iface iface = mIfaceMgr.getIface(ifaceName);
+            Iface iface = null;
+            Iterator<Integer> ifaceIdIter = mIfaceMgr.getIfaceIdIter();
+            while (ifaceIdIter.hasNext()) {
+                Iface nextIface = mIfaceMgr.getIface(ifaceIdIter.next());
+                if (nextIface.name.equals(ifaceName)) {
+                    if (nextIface.type == Iface.IFACE_TYPE_STA_FOR_CONNECTIVITY) {
+                        iface = nextIface;
+                        break;
+                    } else if (nextIface.type == Iface.IFACE_TYPE_STA_FOR_SCAN) {
+                        Log.e(TAG, "Already in scan mode on iface=" + ifaceName);
+                        return true;
+                    }
+                }
+            }
+
             if (iface == null) {
                 Log.e(TAG, "Trying to switch to scan mode on an invalid iface=" + ifaceName);
                 return false;
             }
-            if (iface.type == Iface.IFACE_TYPE_STA_FOR_SCAN) {
-                Log.e(TAG, "Already in scan mode on iface=" + ifaceName);
-                return true;
-            }
+
             if (mWifiVendorHal.isVendorHalSupported()
                     && !mWifiVendorHal.replaceStaIfaceRequestorWs(iface.name, requestorWs)) {
                 Log.e(TAG, "Failed to replace requestor ws on " + iface);
@@ -1726,6 +1874,11 @@ public class WifiNative {
                 teardownInterface(iface.name);
                 return false;
             }
+            if (mMainlineSupplicant.isActive()
+                    && !mMainlineSupplicant.removeStaInterface(iface.name)) {
+                Log.e(TAG, "Unable to tear down " + iface.name + " in the mainline supplicant"
+                        + " for switch to scan mode");
+            }
             iface.type = Iface.IFACE_TYPE_STA_FOR_SCAN;
             stopSupplicantIfNecessary();
             iface.featureSet = getSupportedFeatureSetInternal(iface.name);
@@ -1749,16 +1902,27 @@ public class WifiNative {
     public boolean switchClientInterfaceToConnectivityMode(@NonNull String ifaceName,
             @NonNull WorkSource requestorWs) {
         synchronized (mLock) {
-            final Iface iface = mIfaceMgr.getIface(ifaceName);
+            Iface iface = null;
+            Iterator<Integer> ifaceIdIter = mIfaceMgr.getIfaceIdIter();
+            while (ifaceIdIter.hasNext()) {
+                Iface nextIface = mIfaceMgr.getIface(ifaceIdIter.next());
+                if (nextIface.name.equals(ifaceName)) {
+                    if (nextIface.type == Iface.IFACE_TYPE_STA_FOR_SCAN) {
+                        iface = nextIface;
+                        break;
+                    } else if (nextIface.type == Iface.IFACE_TYPE_STA_FOR_CONNECTIVITY) {
+                        Log.e(TAG, "Already in connectivity mode on iface=" + ifaceName);
+                        return true;
+                    }
+                }
+            }
+
             if (iface == null) {
                 Log.e(TAG, "Trying to switch to connectivity mode on an invalid iface="
                         + ifaceName);
                 return false;
             }
-            if (iface.type == Iface.IFACE_TYPE_STA_FOR_CONNECTIVITY) {
-                Log.e(TAG, "Already in connectivity mode on iface=" + ifaceName);
-                return true;
-            }
+
             if (mWifiVendorHal.isVendorHalSupported()
                     && !mWifiVendorHal.replaceStaIfaceRequestorWs(iface.name, requestorWs)) {
                 Log.e(TAG, "Failed to replace requestor ws on " + iface);
@@ -1786,6 +1950,10 @@ public class WifiNative {
                     Log.e(TAG, "Failed to enable QoS policy feature for iface " + iface.name);
                 }
             }
+            if (mMainlineSupplicant.isActive()
+                    && !mMainlineSupplicant.addStaInterface(iface.name)) {
+                Log.e(TAG, "Unable to add interface " + iface.name + " to mainline supplicant");
+            }
             iface.type = Iface.IFACE_TYPE_STA_FOR_CONNECTIVITY;
             iface.featureSet = getSupportedFeatureSetInternal(iface.name);
             saveCompleteFeatureSetInConfigStoreIfNecessary(iface.featureSet);
@@ -1941,6 +2109,7 @@ public class WifiNative {
      * @return frequencies vector of valid frequencies (MHz), or null for error.
      * @throws IllegalArgumentException if band is not recognized.
      */
+    @Keep
     public int [] getChannelsForBand(@WifiAnnotations.WifiBandBasic int band) {
         if (!SdkLevel.isAtLeastS() && band == WifiScanner.WIFI_BAND_60_GHZ) {
             // 60 GHz band is new in Android S, return empty array on older SDK versions
@@ -2438,6 +2607,7 @@ public class WifiNative {
      * @param reasonCode One of disconnect reason code which defined in {@link ApConfigUtil}.
      * @return true on success, false otherwise.
      */
+    @Keep
     public boolean forceClientDisconnect(@NonNull String ifaceName,
             @NonNull MacAddress client, int reasonCode) {
         return mHostapdHal.forceClientDisconnect(ifaceName, client, reasonCode);
@@ -3765,12 +3935,13 @@ public class WifiNative {
     @Nullable
     ScanData getCachedScanResults(String ifaceName) {
         ScanData scanData = mWifiVendorHal.getCachedScanData(ifaceName);
-        if (scanData == null || scanData.getResults() == null) {
+        ScanResult[] scanResults = scanData != null ? scanData.getResults() : null;
+        if (scanResults == null) {
             return null;
         }
-        ScanResult[] results = getCachedScanResultsFilteredByLocationModeEnabled(
-                scanData.getResults());
-        return new ScanData(0, 0, 0, scanData.getScannedBands(), results);
+        ScanResult[] filteredResults = getCachedScanResultsFilteredByLocationModeEnabled(
+                scanResults);
+        return new ScanData(0, 0, 0, scanData.getScannedBands(), filteredResults);
     }
 
     /**
@@ -3794,29 +3965,30 @@ public class WifiNative {
      * Gets the latest link layer stats
      * @param ifaceName Name of the interface.
      */
+    @Keep
     public WifiLinkLayerStats getWifiLinkLayerStats(@NonNull String ifaceName) {
         WifiLinkLayerStats stats = mWifiVendorHal.getWifiLinkLayerStats(ifaceName);
         if (stats != null) {
             stats.aggregateLinkLayerStats();
             stats.wifiMloMode = getMloMode();
             ScanData scanData = getCachedScanResults(ifaceName);
-            if (scanData != null && scanData.getResults() != null
-                    && scanData.getResults().length >  0) {
+            ScanResult[] scanResults = scanData != null ? scanData.getResults() : null;
+            if (scanResults != null && scanResults.length > 0) {
                 for (int linkIndex = 0; linkIndex < stats.links.length; ++linkIndex) {
                     List<ScanResultWithSameFreq> ScanResultsSameFreq = new ArrayList<>();
-                    for (int scanResultsIndex = 0; scanResultsIndex < scanData.getResults().length;
+                    for (int scanResultsIndex = 0; scanResultsIndex < scanResults.length;
                             ++scanResultsIndex) {
-                        if (scanData.getResults()[scanResultsIndex].frequency
+                        if (scanResults[scanResultsIndex].frequency
                                 != stats.links[linkIndex].frequencyMhz) {
                             continue;
                         }
                         ScanResultWithSameFreq ScanResultSameFreq = new ScanResultWithSameFreq();
                         ScanResultSameFreq.scan_result_timestamp_micros =
-                            scanData.getResults()[scanResultsIndex].timestamp;
-                        ScanResultSameFreq.rssi = scanData.getResults()[scanResultsIndex].level;
+                            scanResults[scanResultsIndex].timestamp;
+                        ScanResultSameFreq.rssi = scanResults[scanResultsIndex].level;
                         ScanResultSameFreq.frequencyMhz =
-                            scanData.getResults()[scanResultsIndex].frequency;
-                        ScanResultSameFreq.bssid = scanData.getResults()[scanResultsIndex].BSSID;
+                            scanResults[scanResultsIndex].frequency;
+                        ScanResultSameFreq.bssid = scanResults[scanResultsIndex].BSSID;
                         ScanResultsSameFreq.add(ScanResultSameFreq);
                     }
                     stats.links[linkIndex].scan_results_same_freq = ScanResultsSameFreq;
@@ -4056,6 +4228,12 @@ public class WifiNative {
         }
         Bundle twtCapabilities = mWifiVendorHal.getTwtCapabilities(ifaceName);
         if (twtCapabilities != null) mCachedTwtCapabilities.put(ifaceName, twtCapabilities);
+        mCachedUsdCapabilities = mSupplicantStaIfaceHal.getUsdCapabilities(ifaceName);
+        // Override device capability with overlay setting for publisher support
+        if (mCachedUsdCapabilities != null && !mContext.getResources().getBoolean(
+                R.bool.config_wifiUsdPublisherSupported)) {
+            mCachedUsdCapabilities.isUsdPublisherSupported = false;
+        }
         return featureSet;
     }
 
@@ -4070,7 +4248,8 @@ public class WifiNative {
             if (getChannelsForBand(WifiScanner.WIFI_BAND_24_GHZ).length > 0) {
                 bands |= WifiScanner.WIFI_BAND_24_GHZ;
             }
-            if (getChannelsForBand(WifiScanner.WIFI_BAND_5_GHZ).length > 0) {
+            if ((getChannelsForBand(WifiScanner.WIFI_BAND_5_GHZ).length > 0)
+                    || (getChannelsForBand(WifiScanner.WIFI_BAND_5_GHZ_DFS_ONLY).length > 0)) {
                 bands |= WifiScanner.WIFI_BAND_5_GHZ;
             }
             if (getChannelsForBand(WifiScanner.WIFI_BAND_6_GHZ).length > 0) {
@@ -4139,6 +4318,7 @@ public class WifiNative {
      * Returns an array of SignalPollResult objects.
      * Returns null on failure.
      */
+    @Keep
     @Nullable
     public WifiSignalPollResults signalPoll(@NonNull String ifaceName) {
         if (mMockWifiModem != null
@@ -4970,6 +5150,7 @@ public class WifiNative {
      * @param ifaceName name of the interface
      * @return the device capabilities for this interface
      */
+    @Keep
     public DeviceWiphyCapabilities getDeviceWiphyCapabilities(@NonNull String ifaceName) {
         return getDeviceWiphyCapabilities(ifaceName, false);
     }
@@ -5021,6 +5202,7 @@ public class WifiNative {
      * @param ifaceName name of the interface
      * @param capabilities the wiphy capabilities to set for this interface
      */
+    @Keep
     public void setDeviceWiphyCapabilities(@NonNull String ifaceName,
             DeviceWiphyCapabilities capabilities) {
         synchronized (mLock) {
diff --git a/service/java/com/android/server/wifi/WifiNetworkFactory.java b/service/java/com/android/server/wifi/WifiNetworkFactory.java
index bdb3309656..ec4a5ca353 100644
--- a/service/java/com/android/server/wifi/WifiNetworkFactory.java
+++ b/service/java/com/android/server/wifi/WifiNetworkFactory.java
@@ -109,8 +109,6 @@ public class WifiNetworkFactory extends NetworkFactory {
     @VisibleForTesting
     public static final int PERIODIC_SCAN_INTERVAL_MS = 10 * 1000; // 10 seconds
     @VisibleForTesting
-    public static final int NETWORK_CONNECTION_TIMEOUT_MS = 30 * 1000; // 30 seconds
-    @VisibleForTesting
     public static final int USER_SELECTED_NETWORK_CONNECT_RETRY_MAX = 3; // max of 3 retries.
     @VisibleForTesting
     public static final int USER_APPROVED_SCAN_RETRY_MAX = 3; // max of 3 retries.
@@ -206,6 +204,7 @@ public class WifiNetworkFactory extends NetworkFactory {
     private final HashMap<String, RemoteCallbackList<ILocalOnlyConnectionStatusListener>>
             mLocalOnlyStatusListenerPerApp = new HashMap<>();
     private final HashMap<String, String> mFeatureIdPerApp = new HashMap<>();
+    private boolean mShouldTriggerScanImmediately = false;
 
     /**
      * Helper class to store an access point that the user previously approved for a specific app.
@@ -908,7 +907,8 @@ public class WifiNetworkFactory extends NetworkFactory {
             WifiNetworkSpecifier wns = (WifiNetworkSpecifier) ns;
             mActiveSpecificNetworkRequestSpecifier = new WifiNetworkSpecifier(
                     wns.ssidPatternMatcher, wns.bssidPatternMatcher, wns.getBand(),
-                    wns.wifiConfiguration, wns.getPreferredChannelFrequenciesMhz());
+                    wns.wifiConfiguration, wns.getPreferredChannelFrequenciesMhz(),
+                    wns.isPreferSecondarySta());
             mSkipUserDialogue = false;
             mWifiMetrics.incrementNetworkRequestApiNumRequest();
 
@@ -1123,9 +1123,6 @@ public class WifiNetworkFactory extends NetworkFactory {
     // Helper method to trigger a connection request & schedule a timeout alarm to track the
     // connection request.
     private void connectToNetwork(@NonNull WifiConfiguration network) {
-        // Cancel connection timeout alarm for any previous connection attempts.
-        cancelConnectionTimeout();
-
         // First add the network to WifiConfigManager and then use the obtained networkId
         // in the CONNECT_NETWORK request.
         // Note: We don't do any error checks on the networkId because ClientModeImpl will do the
@@ -1149,13 +1146,10 @@ public class WifiNetworkFactory extends NetworkFactory {
                 new ActionListenerWrapper(listener),
                 mActiveSpecificNetworkRequest.getRequestorUid(),
                 mActiveSpecificNetworkRequest.getRequestorPackageName(), null);
-
-        // Post an alarm to handle connection timeout.
-        scheduleConnectionTimeout();
     }
 
     private void handleConnectToNetworkUserSelectionInternal(WifiConfiguration network,
-            boolean didUserSeeUi) {
+            boolean didUserSeeUi, boolean preferSecondarySta) {
         // Copy over the credentials from the app's request and then copy the ssid from user
         // selection.
         WifiConfiguration networkToConnect =
@@ -1201,8 +1195,10 @@ public class WifiNetworkFactory extends NetworkFactory {
         }
         WorkSource ws = new WorkSource(mActiveSpecificNetworkRequest.getRequestorUid(),
                 mActiveSpecificNetworkRequest.getRequestorPackageName());
+        // mPreferSecondarySta
         mActiveModeWarden.requestLocalOnlyClientModeManager(new ClientModeManagerRequestListener(),
-                ws, networkToConnect.SSID, networkToConnect.BSSID, didUserSeeUi);
+                ws, networkToConnect.SSID, networkToConnect.BSSID, didUserSeeUi,
+                preferSecondarySta);
     }
 
     private boolean hasNetworkForInternet(WifiConfiguration network) {
@@ -1221,9 +1217,11 @@ public class WifiNetworkFactory extends NetworkFactory {
         // Cancel the ongoing scans after user selection.
         cancelPeriodicScans();
         mIsPeriodicScanEnabled = false;
+        boolean preferSecondarySta = mActiveSpecificNetworkRequestSpecifier == null
+                ? false : mActiveSpecificNetworkRequestSpecifier.isPreferSecondarySta();
 
         // Trigger connection attempts.
-        handleConnectToNetworkUserSelectionInternal(network, didUserSeeUi);
+        handleConnectToNetworkUserSelectionInternal(network, didUserSeeUi, preferSecondarySta);
 
         // Add the network to the approved access point map for the app.
         addNetworkToUserApprovedAccessPointMap(mUserSelectedNetwork);
@@ -1349,6 +1347,14 @@ public class WifiNetworkFactory extends NetworkFactory {
         // If there is no active request or if the user has already selected a network,
         // ignore screen state changes.
         if (mActiveSpecificNetworkRequest == null || !mIsPeriodicScanEnabled) return;
+        if (mSkipUserDialogue) {
+            // Allow App which bypass the user approval to fulfill the request during screen off.
+            return;
+        }
+        if (screenOn != mIsPeriodicScanPaused) {
+            // already at the expected state
+            return;
+        }
 
         // Pause periodic scans when the screen is off & resume when the screen is on.
         if (screenOn) {
@@ -1383,7 +1389,6 @@ public class WifiNetworkFactory extends NetworkFactory {
         }
         // Cancel periodic scan, connection timeout alarm.
         cancelPeriodicScans();
-        cancelConnectionTimeout();
         // Reset the active network request.
         mActiveSpecificNetworkRequest = null;
         mActiveSpecificNetworkRequestSpecifier = null;
@@ -1465,8 +1470,6 @@ public class WifiNetworkFactory extends NetworkFactory {
             mClientModeManager.updateCapabilities();
             return;
         }
-        // Cancel connection timeout alarm.
-        cancelConnectionTimeout();
 
         mConnectionStartTimeMillis = mClock.getElapsedSinceBootMillis();
         if (mClientModeManagerRole == ROLE_CLIENT_PRIMARY) {
@@ -1606,6 +1609,7 @@ public class WifiNetworkFactory extends NetworkFactory {
                 mScanSettings.channels[index++] = new WifiScanner.ChannelSpec(freq);
             }
             mScanSettings.band = WIFI_BAND_UNSPECIFIED;
+            mShouldTriggerScanImmediately = true;
         }
         mIsPeriodicScanEnabled = true;
         startScan();
@@ -1615,6 +1619,7 @@ public class WifiNetworkFactory extends NetworkFactory {
     }
 
     private void cancelPeriodicScans() {
+        mShouldTriggerScanImmediately = false;
         if (mPeriodicScanTimerSet) {
             mAlarmManager.cancel(mPeriodicScanTimerListener);
             mPeriodicScanTimerSet = false;
@@ -1624,6 +1629,8 @@ public class WifiNetworkFactory extends NetworkFactory {
     }
 
     private void scheduleNextPeriodicScan() {
+        boolean triggerScanImmediately = mShouldTriggerScanImmediately;
+        mShouldTriggerScanImmediately = false;
         if (mIsPeriodicScanPaused) {
             Log.e(TAG, "Scan triggered when periodic scanning paused. Ignoring...");
             return;
@@ -1635,6 +1642,10 @@ public class WifiNetworkFactory extends NetworkFactory {
             cleanupActiveRequest();
             return;
         }
+        if (triggerScanImmediately) {
+            startScan();
+            return;
+        }
         mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                 mClock.getElapsedSinceBootMillis() + PERIODIC_SCAN_INTERVAL_MS,
                 TAG, mPeriodicScanTimerListener, mHandler);
@@ -1721,20 +1732,6 @@ public class WifiNetworkFactory extends NetworkFactory {
         mRegisteredCallbacks.finishBroadcast();
     }
 
-    private void cancelConnectionTimeout() {
-        if (mConnectionTimeoutSet) {
-            mAlarmManager.cancel(mConnectionTimeoutAlarmListener);
-            mConnectionTimeoutSet = false;
-        }
-    }
-
-    private void scheduleConnectionTimeout() {
-        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
-                mClock.getElapsedSinceBootMillis() + NETWORK_CONNECTION_TIMEOUT_MS,
-                TAG, mConnectionTimeoutAlarmListener, mHandler);
-        mConnectionTimeoutSet = true;
-    }
-
     private @NonNull CharSequence getAppName(@NonNull String packageName, int uid) {
         ApplicationInfo applicationInfo = null;
         try {
@@ -1987,7 +1984,8 @@ public class WifiNetworkFactory extends NetworkFactory {
             WifiConfiguration config = mActiveSpecificNetworkRequestSpecifier.wifiConfiguration;
             config.SSID = "\"" + ssid + "\"";
             config.BSSID = bssid.toString();
-            handleConnectToNetworkUserSelectionInternal(config, false);
+            handleConnectToNetworkUserSelectionInternal(config, false,
+                    mActiveSpecificNetworkRequestSpecifier.isPreferSecondarySta());
             mWifiMetrics.incrementNetworkRequestApiNumUserApprovalBypass();
             return true;
         }
diff --git a/service/java/com/android/server/wifi/WifiNetworkSelector.java b/service/java/com/android/server/wifi/WifiNetworkSelector.java
index 4f5a2b8568..f1ba972ddd 100644
--- a/service/java/com/android/server/wifi/WifiNetworkSelector.java
+++ b/service/java/com/android/server/wifi/WifiNetworkSelector.java
@@ -708,7 +708,8 @@ public class WifiNetworkSelector {
         mIsEnhancedOpenSupportedInitialized = true;
         ClientModeManager primaryManager =
                 mWifiInjector.getActiveModeWarden().getPrimaryClientModeManager();
-        mIsEnhancedOpenSupported = primaryManager.getSupportedFeatures().get(WIFI_FEATURE_OWE);
+        mIsEnhancedOpenSupported = primaryManager
+                .getSupportedFeaturesBitSet().get(WIFI_FEATURE_OWE);
         return mIsEnhancedOpenSupported;
     }
 
diff --git a/service/java/com/android/server/wifi/WifiNetworkSuggestionsManager.java b/service/java/com/android/server/wifi/WifiNetworkSuggestionsManager.java
index ee4bb2f176..be384213a3 100644
--- a/service/java/com/android/server/wifi/WifiNetworkSuggestionsManager.java
+++ b/service/java/com/android/server/wifi/WifiNetworkSuggestionsManager.java
@@ -1117,7 +1117,7 @@ public class WifiNetworkSuggestionsManager {
         }
 
         BitSet supportedFeatures = mWifiInjector.getActiveModeWarden()
-                .getPrimaryClientModeManager().getSupportedFeatures();
+                .getPrimaryClientModeManager().getSupportedFeaturesBitSet();
 
         for (WifiNetworkSuggestion wns : networkSuggestions) {
             if (wns.passpointConfiguration == null) {
diff --git a/service/java/com/android/server/wifi/WifiP2pConnection.java b/service/java/com/android/server/wifi/WifiP2pConnection.java
index 907ab0d197..f1c665dd01 100644
--- a/service/java/com/android/server/wifi/WifiP2pConnection.java
+++ b/service/java/com/android/server/wifi/WifiP2pConnection.java
@@ -45,8 +45,8 @@ public class WifiP2pConnection {
     private AsyncChannel mWifiP2pChannel;
     private boolean mTemporarilyDisconnectWifi = false;
 
-    /** Used to check if P2P state machine is in waitingState */
-    private boolean mWaitingState = false;
+    /** Used to check if P2P state machine is in DisabledState */
+    private boolean mDisabledState = false;
 
     public WifiP2pConnection(Context context, Looper looper, ActiveModeWarden activeModeWarden) {
         mContext = context;
@@ -191,12 +191,12 @@ public class WifiP2pConnection {
         return mTemporarilyDisconnectWifi;
     }
 
-    public void setP2pInWaitingState(boolean inWaitingState) {
-        mWaitingState = inWaitingState;
+    public void setP2pInDisabledState(boolean inDisabledState) {
+        mDisabledState = inDisabledState;
     }
 
-    /** whether the P2P state machine is in waitingState for user response to create interface */
-    public boolean isP2pInWaitingState() {
-        return mWaitingState;
+    /** whether the P2P state machine is in disabled state */
+    public boolean isP2pInDisabledState() {
+        return mDisabledState;
     }
 }
diff --git a/service/java/com/android/server/wifi/WifiServiceImpl.java b/service/java/com/android/server/wifi/WifiServiceImpl.java
index 385beb6f28..9055d857be 100644
--- a/service/java/com/android/server/wifi/WifiServiceImpl.java
+++ b/service/java/com/android/server/wifi/WifiServiceImpl.java
@@ -70,6 +70,7 @@ import static com.android.server.wifi.WifiSettingsConfigStore.WIFI_WEP_ALLOWED;
 import android.Manifest;
 import android.annotation.AnyThread;
 import android.annotation.CheckResult;
+import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.AppOpsManager;
@@ -83,6 +84,7 @@ import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.ServiceConnection;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
@@ -225,10 +227,12 @@ import com.android.server.wifi.proto.WifiStatsLog;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.UserActionEvent;
 import com.android.server.wifi.util.ActionListenerWrapper;
 import com.android.server.wifi.util.ApConfigUtil;
+import com.android.server.wifi.util.FeatureBitsetUtils;
 import com.android.server.wifi.util.GeneralUtil.Mutable;
 import com.android.server.wifi.util.LastCallerInfoManager;
 import com.android.server.wifi.util.RssiUtil;
 import com.android.server.wifi.util.WifiPermissionsUtil;
+import com.android.server.wifi.util.WorkSourceHelper;
 import com.android.wifi.flags.FeatureFlags;
 import com.android.wifi.resources.R;
 
@@ -241,6 +245,8 @@ import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.net.Inet4Address;
 import java.net.InetAddress;
 import java.security.GeneralSecurityException;
@@ -282,6 +288,40 @@ public class WifiServiceImpl extends IWifiManager.Stub {
     static final int AUTO_DISABLE_SHOW_KEY_COUNTDOWN_MILLIS = 24 * 60 * 60 * 1000;
     private static final int CHANNEL_USAGE_WEAK_SCAN_RSSI_DBM = -80;
 
+    private static final int SCORER_BINDING_STATE_INVALID = -1;
+    // The system is brining up the scorer service.
+    private static final int SCORER_BINDING_STATE_BRINGING_UP = 0;
+    private static final int SCORER_BINDING_STATE_CONNECTED = 1;
+    private static final int SCORER_BINDING_STATE_DISCONNECTED = 2;
+    private static final int SCORER_BINDING_STATE_BINDING_DIED = 3;
+    // A null binder is received.
+    private static final int SCORER_BINDING_STATE_NULL_BINDING = 4;
+    // The system couldn't find the service to bind to.
+    private static final int SCORER_BINDING_STATE_NO_SERVICE = 5;
+    // The app has cleared the Wi-Fi scorer. So the service is unbound.
+    private static final int SCORER_BINDING_STATE_CLEARED = 6;
+    // The app has set a new Wi-Fi scorer. Rebind to the service.
+    public static final int SCORER_BINDING_STATE_REBINDING = 7;
+
+    @IntDef(prefix = { "SCORER_BINDING_STATE_" }, value = {
+        SCORER_BINDING_STATE_INVALID,
+        SCORER_BINDING_STATE_BRINGING_UP,
+        SCORER_BINDING_STATE_CONNECTED,
+        SCORER_BINDING_STATE_DISCONNECTED,
+        SCORER_BINDING_STATE_BINDING_DIED,
+        SCORER_BINDING_STATE_NULL_BINDING,
+        SCORER_BINDING_STATE_NO_SERVICE,
+        SCORER_BINDING_STATE_CLEARED,
+        SCORER_BINDING_STATE_REBINDING
+
+    })
+    @Retention(RetentionPolicy.SOURCE)
+    private @interface ScorerBindingState {}
+
+    private @ScorerBindingState int mLastScorerBindingState = SCORER_BINDING_STATE_INVALID;
+    @VisibleForTesting
+    ScorerServiceConnection mScorerServiceConnection;
+
     private final ActiveModeWarden mActiveModeWarden;
     private final ScanRequestProxy mScanRequestProxy;
 
@@ -350,6 +390,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
 
     private final WifiSettingsConfigStore mSettingsConfigStore;
     private final WifiResourceCache mResourceCache;
+    private boolean mIsUsdSupported = false;
 
     /**
      * Callback for use with LocalOnlyHotspot to unregister requesting applications upon death.
@@ -388,6 +429,112 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         }
     }
 
+    private class ScorerServiceConnection implements ServiceConnection {
+        @Override
+        public void onServiceConnected(ComponentName name, IBinder binder) {
+            Log.i(TAG, "ScorerServiceConnection.onServiceConnected(" + name + ", " + binder + ")");
+            if (binder == null) {
+                mWifiThreadRunner.post(() -> unbindScorerService(SCORER_BINDING_STATE_NULL_BINDING),
+                        "ScorerServiceConnection#onServiceConnected");
+            } else {
+                mWifiThreadRunner.post(() -> {
+                    mLastScorerBindingState = SCORER_BINDING_STATE_CONNECTED;
+                }, "ScorerServiceConnection#onServiceConnected");
+            }
+        }
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+            Log.w(TAG, "ScorerServiceConnection.onServiceDisconnected(" + name + ")");
+            mWifiThreadRunner.post(() -> unbindScorerService(SCORER_BINDING_STATE_DISCONNECTED),
+                    "ScorerServiceConnection#onServiceDisconnected");
+        }
+
+        @Override
+        public void onBindingDied(ComponentName name) {
+            Log.w(TAG, "ScorerServiceConnection.onBindingDied(" + name + ")");
+            mWifiThreadRunner.post(() -> unbindScorerService(SCORER_BINDING_STATE_BINDING_DIED),
+                    "ScorerServiceConnection#onBindingDied");
+        }
+
+        @Override
+        public void onNullBinding(ComponentName name) {
+            Log.i(TAG, "Wifi scorer service " + name + " - onNullBinding");
+            mWifiThreadRunner.post(() -> unbindScorerService(SCORER_BINDING_STATE_NULL_BINDING),
+                    "ScorerServiceConnection#onNullBinding");
+        }
+    }
+
+    /**
+     * Bind to the scorer service to prevent the process of the external scorer from freezing.
+     */
+    private void bindScorerService(int scorerUid) {
+        if (mScorerServiceConnection != null) {
+            Log.i(TAG, "bindScorerService() service is already bound. Unbind it now.");
+            unbindScorerService(SCORER_BINDING_STATE_REBINDING);
+        }
+
+        mLastScorerBindingState = SCORER_BINDING_STATE_NO_SERVICE;
+        PackageManager pm = mContext.getPackageManager();
+        if (pm == null) {
+            Log.e(TAG, "PackageManager is null!");
+            return;
+        } else {
+            String[] packageNames = pm.getPackagesForUid(scorerUid);
+            for (String packageName : packageNames) {
+                if (!TextUtils.isEmpty(packageName)) {
+                    mScorerServiceConnection = new ScorerServiceConnection();
+                    if (bindScorerServiceAsSystemUser(packageName, mScorerServiceConnection)) {
+                        mLastScorerBindingState = SCORER_BINDING_STATE_BRINGING_UP;
+                        return;
+                    } else {
+                        unbindScorerService(SCORER_BINDING_STATE_NO_SERVICE);
+                    }
+                } else {
+                    Log.d(TAG, "bindScorerService() packageName is empty");
+                }
+            }
+        }
+    }
+
+    private boolean bindScorerServiceAsSystemUser(@NonNull String packageName,
+            @NonNull ServiceConnection serviceConnection) {
+        Intent intent = new Intent("android.wifi.ScorerService");
+        intent.setPackage(packageName);
+        try {
+            if (mContext.bindServiceAsUser(intent, serviceConnection,
+                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE,
+                    UserHandle.SYSTEM)) {
+                Log.i(TAG, "bindScorerServiceAsSystemUser(): Bringing up service: " + packageName);
+                return true;
+            }
+        } catch (SecurityException ex) {
+            Log.e(TAG, "Fail to bindServiceAsSystemUser(): " + ex);
+        } catch (Exception ex) {
+            // Just make sure that it won't crash WiFi process
+            Log.e(TAG, "Fail to bindServiceAsSystemUser(): " + ex);
+        }
+        return false;
+    }
+
+    /**
+     * Unbind scorer service to let the system freeze the process of the external scorer freely.
+     */
+    private void unbindScorerService(@ScorerBindingState int state) {
+        mLastScorerBindingState = state;
+        if (mScorerServiceConnection != null) {
+            Log.i(TAG, "unbindScorerService(" + state + ")");
+            try {
+                mContext.unbindService(mScorerServiceConnection);
+            } catch (Exception e) {
+                Log.e(TAG, "Fail to unbindService! " + e);
+            }
+            mScorerServiceConnection = null;
+        } else {
+            Log.i(TAG, "unbindScorerService(" + state
+                    + ") mScorerServiceConnection is already null.");
+        }
+    }
+
     private final WifiLockManager mWifiLockManager;
     private final WifiMulticastLockManager mWifiMulticastLockManager;
     private final DppManager mDppManager;
@@ -457,6 +604,14 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         void onBlockedClientConnecting(@NonNull WifiClient client,
                 @SapClientBlockedReason int blockedReason) {}
 
+        /**
+         * Checks the AttributionSource of a callback and returns true if the AttributionSource
+         * has the correct permissions. This should be extended by child classes.
+         */
+        boolean checkCallbackPermission(@Nullable Object broadcastCookie) {
+            return true;
+        }
+
         /**
          * Notify register the state of soft AP changed.
          */
@@ -465,6 +620,9 @@ public class WifiServiceImpl extends IWifiManager.Stub {
             int itemCount = callbacks.beginBroadcast();
             for (int i = 0; i < itemCount; i++) {
                 try {
+                    if (!checkCallbackPermission(callbacks.getBroadcastCookie(i))) {
+                        continue;
+                    }
                     callbacks.getBroadcastItem(i).onStateChanged(state);
                 } catch (RemoteException e) {
                     Log.e(TAG, "onStateChanged: remote exception -- " + e);
@@ -484,6 +642,9 @@ public class WifiServiceImpl extends IWifiManager.Stub {
             int itemCount = callbacks.beginBroadcast();
             for (int i = 0; i < itemCount; i++) {
                 try {
+                    if (!checkCallbackPermission(callbacks.getBroadcastCookie(i))) {
+                        continue;
+                    }
                     callbacks.getBroadcastItem(i).onConnectedClientsOrInfoChanged(
                             ApConfigUtil.deepCopyForSoftApInfoMap(infos),
                             ApConfigUtil.deepCopyForWifiClientListMap(
@@ -505,6 +666,9 @@ public class WifiServiceImpl extends IWifiManager.Stub {
             int itemCount = callbacks.beginBroadcast();
             for (int i = 0; i < itemCount; i++) {
                 try {
+                    if (!checkCallbackPermission(callbacks.getBroadcastCookie(i))) {
+                        continue;
+                    }
                     callbacks.getBroadcastItem(i).onCapabilityChanged(capability);
                 } catch (RemoteException e) {
                     Log.e(TAG, "onCapabilityChanged: remote exception -- " + e);
@@ -527,6 +691,9 @@ public class WifiServiceImpl extends IWifiManager.Stub {
             int itemCount = callbacks.beginBroadcast();
             for (int i = 0; i < itemCount; i++) {
                 try {
+                    if (!checkCallbackPermission(callbacks.getBroadcastCookie(i))) {
+                        continue;
+                    }
                     callbacks.getBroadcastItem(i).onBlockedClientConnecting(client, blockedReason);
                 } catch (RemoteException e) {
                     Log.e(TAG, "onBlockedClientConnecting: remote exception -- " + e);
@@ -548,6 +715,9 @@ public class WifiServiceImpl extends IWifiManager.Stub {
             int itemCount = callbacks.beginBroadcast();
             for (int i = 0; i < itemCount; i++) {
                 try {
+                    if (!checkCallbackPermission(callbacks.getBroadcastCookie(i))) {
+                        continue;
+                    }
                     callbacks.getBroadcastItem(i).onClientsDisconnected(new SoftApInfo(info),
                             clients);
                 } catch (RemoteException e) {
@@ -626,6 +796,11 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         mAfcManager = mWifiInjector.getAfcManager();
         mTwtManager = mWifiInjector.getTwtManager();
         mWepNetworkUsageController = mWifiInjector.getWepNetworkUsageController();
+        if (Environment.isSdkAtLeastB()) {
+            mIsUsdSupported = mContext.getResources().getBoolean(
+                    mContext.getResources().getIdentifier("config_deviceSupportsWifiUsd", "bool",
+                            "android"));
+        }
     }
 
     /**
@@ -736,6 +911,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                         public void onReceive(Context context, Intent intent) {
                             Log.d(TAG, "locale changed");
                             resetNotificationManager();
+                            mResourceCache.handleLocaleChange();
                         }
                     },
                     new IntentFilter(Intent.ACTION_LOCALE_CHANGED),
@@ -803,6 +979,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
     }
 
     private void resetCarrierNetworks(@ClientModeImpl.ResetSimReason int resetReason) {
+        mResourceCache.reset();
         Log.d(TAG, "resetting carrier networks since SIM was changed");
         if (resetReason == RESET_SIM_REASON_SIM_INSERTED) {
             // clear all SIM related notifications since some action was taken to address
@@ -1972,7 +2149,9 @@ public class WifiServiceImpl extends IWifiManager.Stub {
 
         mLog.info("startTetheredHotspot uid=%").c(callingUid).flush();
         startTetheredHotspotInternal(new SoftApModeConfiguration(
-                WifiManager.IFACE_IP_MODE_TETHERED, null /* config */,
+                WifiManager.IFACE_IP_MODE_TETHERED,
+                com.android.net.flags.Flags.tetheringWithSoftApConfig()
+                        ? request.getSoftApConfiguration() : null,
                 mTetheredSoftApTracker.getSoftApCapability(),
                 mCountryCode.getCountryCode(), request), callingUid, packageName, callback);
     }
@@ -2159,9 +2338,6 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                         Log.e(TAG, "Country code not consistent! expect " + countryCode + " actual "
                                 + mCountryCode.getCurrentDriverCountryCode());
                     }
-                    // Store Soft AP channels for reference after a reboot before the driver is up.
-                    mSettingsConfigStore.put(WifiSettingsConfigStore.WIFI_SOFT_AP_COUNTRY_CODE,
-                            countryCode);
                     List<Integer> freqs = new ArrayList<>();
                     SparseArray<int[]> channelMap = new SparseArray<>(
                             SoftApConfiguration.BAND_TYPES.length);
@@ -2181,9 +2357,17 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                             channelMap.put(band, channel);
                         }
                     }
-                    mSettingsConfigStore.put(
-                            WifiSettingsConfigStore.WIFI_AVAILABLE_SOFT_AP_FREQS_MHZ,
-                            new JSONArray(freqs).toString());
+                    if (!mCountryCode.isDriverCountryCodeWorldMode()
+                            || TextUtils.isEmpty(mSettingsConfigStore.get(
+                                    WifiSettingsConfigStore.WIFI_SOFT_AP_COUNTRY_CODE))) {
+                        // Store Soft AP channels (non-world mode CC or no save before) for
+                        // reference after a reboot before the driver is up.
+                        mSettingsConfigStore.put(WifiSettingsConfigStore.WIFI_SOFT_AP_COUNTRY_CODE,
+                                countryCode);
+                        mSettingsConfigStore.put(
+                                WifiSettingsConfigStore.WIFI_AVAILABLE_SOFT_AP_FREQS_MHZ,
+                                new JSONArray(freqs).toString());
+                    }
                     mTetheredSoftApTracker.updateAvailChannelListInSoftApCapability(countryCode,
                             channelMap);
                     mLohsSoftApTracker.updateAvailChannelListInSoftApCapability(countryCode,
@@ -2387,8 +2571,8 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                     getSoftApCapability(), countryCode, channelMap));
         }
 
-        public boolean registerSoftApCallback(ISoftApCallback callback) {
-            if (!mRegisteredSoftApCallbacks.register(callback)) {
+        public boolean registerSoftApCallback(ISoftApCallback callback, Object cookie) {
+            if (!mRegisteredSoftApCallbacks.register(callback, cookie)) {
                 return false;
             }
 
@@ -2526,6 +2710,8 @@ public class WifiServiceImpl extends IWifiManager.Stub {
      * Implements LOHS behavior on top of the existing SoftAp API.
      */
     private final class LohsSoftApTracker extends BaseSoftApTracker {
+        private static final int UNSPECIFIED_PID = -1;
+
         @GuardedBy("mLocalOnlyHotspotRequests")
         private final HashMap<Integer, LocalOnlyHotspotRequestInfo>
                 mLocalOnlyHotspotRequests = new HashMap<>();
@@ -2541,12 +2727,31 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         @GuardedBy("mLocalOnlyHotspotRequests")
         private boolean mIsExclusive = false;
 
+        @GuardedBy("mLocalOnlyHotspotRequests")
+        private WorkSource mCurrentWs = null;
+
         @GuardedBy("mLocalOnlyHotspotRequests")
         private String mLohsInterfaceName;
 
         @GuardedBy("mLocalOnlyHotspotRequests")
         private int mLohsInterfaceMode = WifiManager.IFACE_IP_MODE_UNSPECIFIED;
 
+        @GuardedBy("mLocalOnlyHotspotRequests")
+        private int mPidRestartingLohsFor = UNSPECIFIED_PID;
+        @Override
+        public boolean checkCallbackPermission(@Nullable Object broadcastCookie) {
+            if (!SdkLevel.isAtLeastS()) {
+                // AttributionSource requires at least S.
+                return false;
+            }
+            if (!(broadcastCookie instanceof AttributionSource)) {
+                return false;
+            }
+            return mWifiPermissionsUtil.checkNearbyDevicesPermission(
+                    (AttributionSource) broadcastCookie,
+                    false /* checkForLocation */,
+                    TAG + " " + this.getClass().getSimpleName() + "#checkCallbackPermission");
+        }
         public void updateInterfaceIpState(String ifaceName, int mode) {
             // update interface IP state related to local-only hotspot
             synchronized (mLocalOnlyHotspotRequests) {
@@ -2632,6 +2837,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
 
             // Since all callers were notified, now clear the registrations.
             mLocalOnlyHotspotRequests.clear();
+            mPidRestartingLohsFor = UNSPECIFIED_PID;
         }
 
         /**
@@ -2670,14 +2876,35 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                 // Never accept exclusive requests (with custom configuration) at the same time as
                 // shared requests.
                 if (!mLocalOnlyHotspotRequests.isEmpty()) {
-                    boolean requestIsExclusive = request.getCustomConfig() != null;
-                    if (mIsExclusive || requestIsExclusive) {
+                    final boolean requestIsExclusive = request.getCustomConfig() != null;
+                    final int newRequestorWsPriority = mWifiInjector
+                            .makeWsHelper(request.getWorkSource()).getRequestorWsPriority();
+                    final int currentWsPriority = mWifiInjector
+                            .makeWsHelper(mCurrentWs).getRequestorWsPriority();
+                    final boolean isCurrentLohsWorksOnNonDefaultBand = mActiveConfig != null
+                            && mActiveConfig.getSoftApConfiguration().getBand()
+                                    != SoftApConfiguration.BAND_2GHZ;
+                    Log.d(TAG, "Receive multiple LOHS requestors,"
+                                + ", requestIsExclusive: " + requestIsExclusive
+                                + ", mIsExclusive: " + mIsExclusive
+                                + ", currentWsPriority: " + currentWsPriority
+                                + ", newRequestorWsPriority: " + newRequestorWsPriority);
+                    if (requestIsExclusive || mIsExclusive
+                            || (currentWsPriority >= newRequestorWsPriority
+                                    && isCurrentLohsWorksOnNonDefaultBand)) {
                         mLog.trace("Cannot share with existing LOHS request due to custom config")
                                 .flush();
                         return LocalOnlyHotspotCallback.ERROR_GENERIC;
                     }
+                    if (mFeatureFlags.publicBandsForLohs() && isCurrentLohsWorksOnNonDefaultBand) {
+                        // Current LOHS is not using 2.4 band, and new caller priority is higher.
+                        // stop all and logging the new requestor pid.
+                        mLog.trace("Restarting LOHS to default band for new requestor")
+                                .flush();
+                        mLohsSoftApTracker.stopAll();
+                        mPidRestartingLohsFor = pid;
+                    }
                 }
-
                 // At this point, the request is accepted.
                 if (mLocalOnlyHotspotRequests.isEmpty()) {
                     mWifiThreadRunner.post(() -> {
@@ -2694,7 +2921,6 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                         return LocalOnlyHotspotCallback.ERROR_GENERIC;
                     }
                 }
-
                 mLocalOnlyHotspotRequests.put(pid, request);
                 return LocalOnlyHotspotCallback.REQUEST_REGISTERED;
             }
@@ -2702,14 +2928,22 @@ public class WifiServiceImpl extends IWifiManager.Stub {
 
         @GuardedBy("mLocalOnlyHotspotRequests")
         private void startForFirstRequestLocked(LocalOnlyHotspotRequestInfo request) {
+            mCurrentWs = request.getWorkSource();
+            final int currentWsPriority = mWifiInjector.makeWsHelper(mCurrentWs)
+                    .getRequestorWsPriority();
+            if (mFeatureFlags.publicBandsForLohs() && Environment.isSdkAtLeastB()) {
+                mIsExclusive = (request.getCustomConfig() != null)
+                        && currentWsPriority >= WorkSourceHelper.PRIORITY_SYSTEM;
+            } else {
+                mIsExclusive = (request.getCustomConfig() != null);
+            }
             final SoftApCapability lohsCapability = mLohsSoftApTracker.getSoftApCapability();
             SoftApConfiguration softApConfig = mWifiApConfigStore.generateLocalOnlyHotspotConfig(
-                    mContext, request.getCustomConfig(), lohsCapability);
+                    mContext, request.getCustomConfig(), lohsCapability, mIsExclusive);
 
             mActiveConfig = new SoftApModeConfiguration(
                     WifiManager.IFACE_IP_MODE_LOCAL_ONLY,
                     softApConfig, lohsCapability, mCountryCode.getCountryCode(), null);
-            mIsExclusive = (request.getCustomConfig() != null);
             // Report the error if we got failure in startSoftApInternal
             if (!startSoftApInternal(mActiveConfig, request.getWorkSource(), null)) {
                 onStateChanged(new SoftApState(
@@ -2765,7 +2999,9 @@ public class WifiServiceImpl extends IWifiManager.Stub {
             if (mLocalOnlyHotspotRequests.isEmpty()) {
                 mActiveConfig = null;
                 mIsExclusive = false;
+                mCurrentWs = null;
                 mLohsInterfaceName = null;
+                mPidRestartingLohsFor = UNSPECIFIED_PID;
                 mLohsInterfaceMode = WifiManager.IFACE_IP_MODE_UNSPECIFIED;
                 stopSoftApInternal(WifiManager.IFACE_IP_MODE_LOCAL_ONLY);
             }
@@ -2815,6 +3051,8 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                     // also need to clear interface ip state
                     updateInterfaceIpState(mLohsInterfaceName,
                             WifiManager.IFACE_IP_MODE_UNSPECIFIED);
+                    // failed, reset restarting pid info
+                    mPidRestartingLohsFor = UNSPECIFIED_PID;
                 } else if (state == WIFI_AP_STATE_DISABLING || state == WIFI_AP_STATE_DISABLED) {
                     // softap is shutting down or is down...  let requestors know via the
                     // onStopped call
@@ -2825,12 +3063,22 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                         // holding the required lock: send message to requestors and clear the list
                         sendHotspotStoppedMessageToAllLOHSRequestInfoEntriesLocked();
                     } else {
-                        // LOHS not active: report an error (still holding the required lock)
-                        sendHotspotFailedMessageToAllLOHSRequestInfoEntriesLocked(ERROR_GENERIC);
+                        // The LOHS is being restarted since there is a mPidRestartingLohsFor,
+                        // We should expect there will be DISABLING and DISABLED.
+                        // No need to report error.
+                        if (mPidRestartingLohsFor == UNSPECIFIED_PID) {
+                            // LOHS not active: report an error.
+                            sendHotspotFailedMessageToAllLOHSRequestInfoEntriesLocked(
+                                    ERROR_GENERIC);
+                        }
                     }
                     // also clear interface ip state
                     updateInterfaceIpState(mLohsInterfaceName,
                             WifiManager.IFACE_IP_MODE_UNSPECIFIED);
+                } else if (state ==  WIFI_AP_STATE_ENABLING
+                        && mPidRestartingLohsFor != UNSPECIFIED_PID) {
+                    // restarting, reset pid info
+                    mPidRestartingLohsFor = UNSPECIFIED_PID;
                 }
                 // For enabling and enabled, just record the new state
                 setState(softApState);
@@ -2872,7 +3120,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
 
         // post operation to handler thread
         mWifiThreadRunner.post(() -> {
-            if (!mTetheredSoftApTracker.registerSoftApCallback(callback)) {
+            if (!mTetheredSoftApTracker.registerSoftApCallback(callback, null)) {
                 Log.e(TAG, "registerSoftApCallback: Failed to add callback");
                 return;
             }
@@ -2914,8 +3162,8 @@ public class WifiServiceImpl extends IWifiManager.Stub {
      * softap mode changes.
      */
     @VisibleForTesting
-    void registerLOHSForTest(int pid, LocalOnlyHotspotRequestInfo request) {
-        mLohsSoftApTracker.start(pid, request);
+    int registerLOHSForTest(int pid, LocalOnlyHotspotRequestInfo request) {
+        return mLohsSoftApTracker.start(pid, request);
     }
 
     /**
@@ -3054,15 +3302,18 @@ public class WifiServiceImpl extends IWifiManager.Stub {
 
     @Override
     public void registerLocalOnlyHotspotSoftApCallback(ISoftApCallback callback, Bundle extras) {
+        if (!SdkLevel.isAtLeastT()) {
+            throw new UnsupportedOperationException();
+        }
+
         // verify arguments
         if (callback == null) {
             throw new IllegalArgumentException("Callback must not be null");
         }
 
-        int uid = Binder.getCallingUid();
-        int pid = Binder.getCallingPid();
-        mWifiPermissionsUtil.enforceNearbyDevicesPermission(
-                extras.getParcelable(WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE),
+        AttributionSource attributionSource =
+                extras.getParcelable(WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE);
+        mWifiPermissionsUtil.enforceNearbyDevicesPermission(attributionSource,
                 false, TAG + " registerLocalOnlyHotspotSoftApCallback");
 
         if (mVerboseLoggingEnabled) {
@@ -3072,9 +3323,8 @@ public class WifiServiceImpl extends IWifiManager.Stub {
 
         // post operation to handler thread
         mWifiThreadRunner.post(() -> {
-            if (!mLohsSoftApTracker.registerSoftApCallback(callback)) {
+            if (!mLohsSoftApTracker.registerSoftApCallback(callback, attributionSource)) {
                 Log.e(TAG, "registerLocalOnlyHotspotSoftApCallback: Failed to add callback");
-                return;
             }
         }, TAG + "#registerLocalOnlyHotspotSoftApCallback");
     }
@@ -3085,8 +3335,6 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         if (callback == null) {
             throw new IllegalArgumentException("Callback must not be null");
         }
-        int uid = Binder.getCallingUid();
-        int pid = Binder.getCallingPid();
 
         mWifiPermissionsUtil.enforceNearbyDevicesPermission(
                 extras.getParcelable(WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE),
@@ -3404,7 +3652,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         if (needToLogSupportedFeatures(supportedFeatures)) {
             mLog.info("isFeatureSupported uid=% returns %")
                     .c(Binder.getCallingUid())
-                    .c(supportedFeatures.toString())
+                    .c(FeatureBitsetUtils.formatSupportedFeatures(supportedFeatures))
                     .flush();
         }
         return supportedFeatures.get(feature);
@@ -5768,7 +6016,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                         mContext, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0));
                 pw.println("mInIdleMode " + mInIdleMode);
                 pw.println("mScanPending " + mScanPending);
-                pw.println("SupportedFeatures: " + getSupportedFeaturesInternal());
+                pw.println("SupportedFeatures: " + getSupportedFeaturesString());
                 pw.println("SettingsStore:");
                 mSettingsStore.dump(fd, pw, args);
                 mActiveModeWarden.dump(fd, pw, args);
@@ -5846,6 +6094,12 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                     pw.println();
                     mWepNetworkUsageController.dump(fd, pw, args);
                 }
+                if (mScorerServiceConnection != null) {
+                    pw.println("boundToExternalScorer successfully");
+                } else {
+                    pw.println("boundToExternalScorer=failure, lastScorerBindingState="
+                            + mLastScorerBindingState);
+                }
             }
         }, TAG + "#dump");
     }
@@ -5917,19 +6171,20 @@ public class WifiServiceImpl extends IWifiManager.Stub {
     }
 
     @Override
-    public void acquireMulticastLock(IBinder binder, String tag) {
+    public void acquireMulticastLock(IBinder binder, String lockTag, String attributionTag,
+            String packageName) {
         enforceMulticastChangePermission();
         int uid = Binder.getCallingUid();
-        mLog.info("acquireMulticastLock uid=% tag=%").c(uid).c(tag).flush();
-        mWifiMulticastLockManager.acquireLock(uid, binder, tag);
+        mLog.info("acquireMulticastLock uid=% lockTag=%").c(uid).c(lockTag).flush();
+        mWifiMulticastLockManager.acquireLock(uid, binder, lockTag, attributionTag, packageName);
     }
 
     @Override
-    public void releaseMulticastLock(IBinder binder, String tag) {
+    public void releaseMulticastLock(IBinder binder, String lockTag) {
         enforceMulticastChangePermission();
         int uid = Binder.getCallingUid();
-        mLog.info("releaseMulticastLock uid=% tag=%").c(uid).c(tag).flush();
-        mWifiMulticastLockManager.releaseLock(uid, binder, tag);
+        mLog.info("releaseMulticastLock uid=% lockTag=%").c(uid).c(lockTag).flush();
+        mWifiMulticastLockManager.releaseLock(uid, binder, lockTag);
     }
 
     @Override
@@ -6410,6 +6665,10 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                 TAG + "#unregisterTrafficStateCallback");
     }
 
+    protected String getSupportedFeaturesString() {
+        return FeatureBitsetUtils.formatSupportedFeatures(getSupportedFeaturesInternal());
+    }
+
     private BitSet getSupportedFeaturesInternal() {
         return mActiveModeWarden.getSupportedFeatureSet();
     }
@@ -7519,6 +7778,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         if (mVerboseLoggingEnabled) {
             mLog.info("setWifiConnectedNetworkScorer uid=%").c(callingUid).flush();
         }
+        mWifiThreadRunner.post(() -> bindScorerService(callingUid));
         // Post operation to handler thread
         return mWifiThreadRunner.call(
                 () -> mActiveModeWarden.setWifiConnectedNetworkScorer(binder, scorer, callingUid),
@@ -7535,6 +7795,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         if (mVerboseLoggingEnabled) {
             mLog.info("clearWifiConnectedNetworkScorer uid=%").c(Binder.getCallingUid()).flush();
         }
+        mWifiThreadRunner.post(() -> unbindScorerService(SCORER_BINDING_STATE_CLEARED));
         // Post operation to handler thread
         mWifiThreadRunner.post(() -> mActiveModeWarden.clearWifiConnectedNetworkScorer(),
                 TAG + "#clearWifiConnectedNetworkScorer");
@@ -8912,7 +9173,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                                 isDeviceOwner);
                 listener.onResult(roamingPolicies);
             } catch (RemoteException e) {
-                Log.e(TAG, e.getMessage());
+                Log.e(TAG, e.getMessage(), e);
             }
         }, TAG + "#getPerSsidRoamingModes");
     }
@@ -9163,6 +9424,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
                 () -> mActiveModeWarden.getPrimaryClientModeManager().blockNetwork(option),
                 "disallowCurrentSuggestedNetwork");
     }
+
     /**
      * See {@link WifiManager#isUsdSubscriberSupported()}
      */
@@ -9175,8 +9437,10 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        // USDSubscriber is not supported.
-        return false;
+        if (!mIsUsdSupported) {
+            return false;
+        }
+        return mWifiNative.isUsdSubscriberSupported();
     }
 
     /**
@@ -9191,8 +9455,9 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        // USDPublisher is not supported.
-        return false;
+        if (!mIsUsdSupported) {
+            return false;
+        }
+        return mWifiNative.isUsdPublisherSupported();
     }
-
 }
diff --git a/service/java/com/android/server/wifi/WifiSettingsStore.java b/service/java/com/android/server/wifi/WifiSettingsStore.java
index a84346b77f..a8e89158fa 100644
--- a/service/java/com/android/server/wifi/WifiSettingsStore.java
+++ b/service/java/com/android/server/wifi/WifiSettingsStore.java
@@ -27,6 +27,8 @@ import android.net.Uri;
 import android.net.wifi.WifiContext;
 import android.provider.Settings;
 
+import androidx.annotation.Keep;
+
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.messages.nano.SystemMessageProto.SystemMessage;
 import com.android.wifi.resources.R;
@@ -192,6 +194,7 @@ public class WifiSettingsStore {
      * Returns true if airplane mode is currently on.
      * @return {@code true} if airplane mode is on.
      */
+    @Keep
     public synchronized boolean isAirplaneModeOn() {
         return mAirplaneModeOn;
     }
@@ -250,6 +253,7 @@ public class WifiSettingsStore {
         mNotificationManager.notify(SystemMessage.NOTE_WIFI_APM_NOTIFICATION, builder.build());
     }
 
+    @Keep
     public synchronized boolean handleWifiToggled(boolean wifiEnabled) {
         // Can Wi-Fi be toggled in airplane mode ?
         if (mAirplaneModeOn && !isAirplaneToggleable()) {
diff --git a/service/java/com/android/server/wifi/WifiShellCommand.java b/service/java/com/android/server/wifi/WifiShellCommand.java
index fe23f18d12..bd49b590ab 100644
--- a/service/java/com/android/server/wifi/WifiShellCommand.java
+++ b/service/java/com/android/server/wifi/WifiShellCommand.java
@@ -188,6 +188,7 @@ public class WifiShellCommand extends BasicShellCommandHandler {
             "set-mock-wifimodem-methods",
             "force-overlay-config-value",
             "get-softap-supported-features",
+            "get-wifi-supported-features",
             "get-overlay-config-values"
     };
 
@@ -1013,7 +1014,14 @@ public class WifiShellCommand extends BasicShellCommandHandler {
                     if (mWifiService.isFeatureSupported(WifiManager.WIFI_FEATURE_STA_BRIDGED_AP)) {
                         pw.println("wifi_softap_bridged_ap_with_sta_supported");
                     }
+                    if (mWifiNative.isMLDApSupportMLO()) {
+                        pw.println("wifi_softap_mlo_supported");
+                    }
+                    return 0;
+                case "get-wifi-supported-features": {
+                    pw.println(mWifiService.getSupportedFeaturesString());
                     return 0;
+                }
                 case "settings-reset":
                     mWifiNative.stopFakingScanDetails();
                     mWifiNative.resetFakeScanDetails();
@@ -1248,6 +1256,10 @@ public class WifiShellCommand extends BasicShellCommandHandler {
                             new ParceledListSlice<>(Collections.emptyList()), SHELL_PACKAGE_NAME,
                             WifiManager.ACTION_REMOVE_SUGGESTION_DISCONNECT);
                     return 0;
+                case "clear-all-suggestions":
+                    mWifiThreadRunner.post(() -> mWifiNetworkSuggestionsManager.clear(),
+                            "shell#clear-all-suggestions");
+                    return 0;
                 case "list-suggestions": {
                     List<WifiNetworkSuggestion> suggestions =
                             mWifiService.getNetworkSuggestions(SHELL_PACKAGE_NAME).getList();
@@ -2309,6 +2321,10 @@ public class WifiShellCommand extends BasicShellCommandHandler {
 
                     mWifiService.setPerSsidRoamingMode(wifiSsid, mode, SHELL_PACKAGE_NAME);
                     return 0;
+                case "set-scan-throttling-enabled":
+                    mWifiService.setScanThrottleEnabled(
+                            getNextArgRequiredTrueOrFalse("enabled", "disabled"));
+                    return 0;
                 default:
                     return handleDefaultCommands(cmd);
             }
@@ -3122,7 +3138,10 @@ public class WifiShellCommand extends BasicShellCommandHandler {
         pw.println("    and/or 'wifi_softap_wpa3_sae_supported',");
         pw.println("    and/or 'wifi_softap_bridged_ap_supported',");
         pw.println("    and/or 'wifi_softap_bridged_ap_with_sta_supported',");
+        pw.println("    and/or 'wifi_softap_mlo_supported',");
         pw.println("    each on a separate line.");
+        pw.println("  get-wifi-supported-features");
+        pw.println("    Gets the features supported by WifiManager");
     }
 
     private void onHelpPrivileged(PrintWriter pw) {
@@ -3253,6 +3272,8 @@ public class WifiShellCommand extends BasicShellCommandHandler {
         pw.println("    Lists all suggested networks on this device");
         pw.println("  list-suggestions-from-app <package name>");
         pw.println("    Lists the suggested networks from the app");
+        pw.println("  clear-all-suggestions");
+        pw.println("    Clear all suggestions added into this device");
         pw.println("  set-emergency-callback-mode enabled|disabled");
         pw.println("    Sets whether Emergency Callback Mode (ECBM) is enabled.");
         pw.println("    Equivalent to receiving the "
@@ -3405,6 +3426,8 @@ public class WifiShellCommand extends BasicShellCommandHandler {
         pw.println("    Sets the roaming mode for the given SSID.");
         pw.println("    -x - Specifies the SSID as hex digits instead of plain text.");
         pw.println("    Example: set-ssid-roaming-mode test_ssid aggressive");
+        pw.println("  set-scan-throttling-enabled enabled|disabled");
+        pw.println("    Set wifi scan throttling for 3P apps enabled or disabled.");
     }
 
     @Override
@@ -3425,15 +3448,36 @@ public class WifiShellCommand extends BasicShellCommandHandler {
         if (suggestions == null || suggestions.isEmpty()) {
             pw.println("No suggestions on this device");
         } else {
-            pw.println("SSID                         Security type(s)");
-            for (WifiNetworkSuggestion suggestion : suggestions) {
-                pw.println(String.format("%-32s %-4s",
-                        WifiInfo.sanitizeSsid(suggestion.getWifiConfiguration().SSID),
-                        suggestion.getWifiConfiguration().getSecurityParamsList().stream()
-                                .map(p -> WifiConfiguration.getSecurityTypeName(
-                                        p.getSecurityType())
-                                        + (p.isAddedByAutoUpgrade() ? "^" : ""))
-                                .collect(Collectors.joining("/"))));
+            if (SdkLevel.isAtLeastS()) {
+                /*
+                 * Print out SubId on S and above because WifiNetworkSuggestion.getSubscriptionId()
+                 * is supported from Android S and above.
+                 */
+                String format = "%-24s %-24s %-12s %-12s";
+                pw.println(String.format(format, "SSID", "Security type(s)", "CarrierId", "SubId"));
+                for (WifiNetworkSuggestion suggestion : suggestions) {
+                    pw.println(String.format(format,
+                            WifiInfo.sanitizeSsid(suggestion.getWifiConfiguration().SSID),
+                            suggestion.getWifiConfiguration().getSecurityParamsList().stream()
+                                    .map(p -> WifiConfiguration.getSecurityTypeName(
+                                            p.getSecurityType())
+                                            + (p.isAddedByAutoUpgrade() ? "^" : ""))
+                                    .collect(Collectors.joining("/")),
+                            suggestion.getCarrierId(), suggestion.getSubscriptionId()));
+                }
+            } else {
+                String format = "%-24s %-24s %-12s";
+                pw.println(String.format(format, "SSID", "Security type(s)", "CarrierId"));
+                for (WifiNetworkSuggestion suggestion : suggestions) {
+                    pw.println(String.format(format,
+                            WifiInfo.sanitizeSsid(suggestion.getWifiConfiguration().SSID),
+                            suggestion.getWifiConfiguration().getSecurityParamsList().stream()
+                                    .map(p -> WifiConfiguration.getSecurityTypeName(
+                                            p.getSecurityType())
+                                            + (p.isAddedByAutoUpgrade() ? "^" : ""))
+                                    .collect(Collectors.joining("/")),
+                            suggestion.getCarrierId()));
+                }
             }
         }
     }
diff --git a/service/java/com/android/server/wifi/WifiSignalPollResults.java b/service/java/com/android/server/wifi/WifiSignalPollResults.java
index 9e83c001e2..5ab8aebeea 100644
--- a/service/java/com/android/server/wifi/WifiSignalPollResults.java
+++ b/service/java/com/android/server/wifi/WifiSignalPollResults.java
@@ -18,6 +18,8 @@ package com.android.server.wifi;
 
 import android.util.Log;
 
+import androidx.annotation.Keep;
+
 import java.util.HashMap;
 import java.util.Map;
 
@@ -110,6 +112,7 @@ public class WifiSignalPollResults {
      *
      * @return rssi in dBm or {@link WifiSignalPollResults#MIN_RSSI} if no poll results.
      */
+    @Keep
     public int getRssi() {
         return mEntries.getOrDefault(mBestLinkId, mDefault).currentRssiDbm;
     }
@@ -167,6 +170,7 @@ public class WifiSignalPollResults {
      *
      * @return frequency in MHz or 0 if no poll results.
      */
+    @Keep
     public int getFrequency() {
         return mEntries.getOrDefault(mBestLinkId, mDefault).frequencyMHz;
     }
diff --git a/service/java/com/android/server/wifi/WifiThreadRunner.java b/service/java/com/android/server/wifi/WifiThreadRunner.java
index 859d96d078..08ebe3868e 100644
--- a/service/java/com/android/server/wifi/WifiThreadRunner.java
+++ b/service/java/com/android/server/wifi/WifiThreadRunner.java
@@ -61,6 +61,10 @@ public class WifiThreadRunner {
         mHandler = handler;
     }
 
+    public Handler getHandler() {
+        return mHandler;
+    }
+
     /**
      * Synchronously runs code on the main Wifi thread and return a value.
      * <b>Blocks</b> the calling thread until the callable completes execution on the main Wifi
diff --git a/service/java/com/android/server/wifi/aware/WifiAwareStateManager.java b/service/java/com/android/server/wifi/aware/WifiAwareStateManager.java
index 19047477dc..3f4460ed8b 100644
--- a/service/java/com/android/server/wifi/aware/WifiAwareStateManager.java
+++ b/service/java/com/android/server/wifi/aware/WifiAwareStateManager.java
@@ -2661,8 +2661,8 @@ public class WifiAwareStateManager implements WifiAwareShellCommand.DelegatedShe
                     onAwareDownLocal();
                     if (reason != NanStatusCode.SUCCESS) {
                         sendAwareStateChangedBroadcast(false);
+                        releaseAwareInterface();
                     }
-                    releaseAwareInterface();
                     break;
                 }
                 case NOTIFICATION_TYPE_ON_MESSAGE_SEND_SUCCESS: {
diff --git a/service/java/com/android/server/wifi/hal/WifiChipAidlImpl.java b/service/java/com/android/server/wifi/hal/WifiChipAidlImpl.java
index d63d1e1187..1fe36ded44 100644
--- a/service/java/com/android/server/wifi/hal/WifiChipAidlImpl.java
+++ b/service/java/com/android/server/wifi/hal/WifiChipAidlImpl.java
@@ -1638,6 +1638,9 @@ public class WifiChipAidlImpl implements IWifiChip {
         if (bitmapContains(halFeatureSet, FeatureSetMask.MLO_SAP)) {
             features.set(WifiManager.WIFI_FEATURE_SOFTAP_MLO);
         }
+        if (bitmapContains(halFeatureSet, FeatureSetMask.MULTIPLE_MLD_ON_SAP)) {
+            features.set(WifiManager.WIFI_FEATURE_MULTIPLE_MLD_ON_SAP);
+        }
         return features;
     }
 
diff --git a/service/java/com/android/server/wifi/hal/WifiRttController.java b/service/java/com/android/server/wifi/hal/WifiRttController.java
index 5accbdd95a..f8eb6280d4 100644
--- a/service/java/com/android/server/wifi/hal/WifiRttController.java
+++ b/service/java/com/android/server/wifi/hal/WifiRttController.java
@@ -19,7 +19,10 @@ package com.android.server.wifi.hal;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.hardware.wifi.Akm;
+import android.hardware.wifi.CipherSuite;
 import android.net.MacAddress;
+import android.net.wifi.rtt.PasnConfig;
 import android.net.wifi.rtt.RangingRequest;
 import android.net.wifi.rtt.RangingResult;
 import android.util.Log;
@@ -116,6 +119,10 @@ public class WifiRttController {
         public boolean ntbInitiatorSupported;
         // Whether IEEE 802.11az Non-Trigger-based (non-TB) responder mode is supported.
         public boolean ntbResponderSupported;
+         // Bitmap of AKM values indicating the set of supported AKMs.
+        public @PasnConfig.AkmType int akmsSupported;
+         // Bitmap of cipher values indicating the set of supported pairwise cipher suites.
+        public @PasnConfig.Cipher int cipherSuitesSupported;
         // Whether secure HE-LTF (Long Training Field) is supported
         public boolean secureHeLtfSupported;
         // Whether ranging frame protection is supported
@@ -176,9 +183,62 @@ public class WifiRttController {
             rangingFrameProtectionSupported = rttHalCapabilities.rangingFrameProtectionSupported;
             maxSupportedSecureHeLtfProtocolVersion =
                     rttHalCapabilities.maxSupportedSecureHeLtfProtocolVersion;
+            akmsSupported = convertAkmsToFramework(rttHalCapabilities.akmsSupported);
+            cipherSuitesSupported = convertCiphersToFramework(
+                    rttHalCapabilities.cipherSuitesSupported);
         }
     }
 
+    @PasnConfig.Cipher
+    private static int convertCiphersToFramework(long ciphersSupported) {
+        @PasnConfig.Cipher int ciphers = PasnConfig.CIPHER_NONE;
+        if ((ciphersSupported & CipherSuite.GCMP_256) != 0) {
+            ciphers |= PasnConfig.CIPHER_GCMP_256;
+        }
+        if ((ciphersSupported & CipherSuite.GCMP_128) != 0) {
+            ciphers |= PasnConfig.CIPHER_GCMP_128;
+        }
+        if ((ciphersSupported & CipherSuite.CCMP_256) != 0) {
+            ciphers |= PasnConfig.CIPHER_CCMP_256;
+        }
+        if ((ciphersSupported & CipherSuite.CCMP_128) != 0) {
+            ciphers |= PasnConfig.CIPHER_CCMP_128;
+        }
+        return ciphers;
+    }
+
+    @PasnConfig.AkmType
+    private static int convertAkmsToFramework(long akmsSupported) {
+        @PasnConfig.AkmType int akms = PasnConfig.AKM_NONE;
+        if ((akmsSupported & Akm.FT_EAP_SHA384) != 0) {
+            akms |= PasnConfig.AKM_FT_EAP_SHA384;
+        }
+        if ((akmsSupported & Akm.FILS_EAP_SHA384) != 0) {
+            akms |= PasnConfig.AKM_FILS_EAP_SHA384;
+        }
+        if ((akmsSupported & Akm.FILS_EAP_SHA256) != 0) {
+            akms |= PasnConfig.AKM_FILS_EAP_SHA256;
+        }
+        if ((akmsSupported & Akm.FT_EAP_SHA256) != 0) {
+            akms |= PasnConfig.AKM_FT_EAP_SHA256;
+        }
+        if ((akmsSupported & Akm.FT_PSK_SHA384) != 0) {
+            akms |= PasnConfig.AKM_FT_PSK_SHA384;
+        }
+        if ((akmsSupported & Akm.FT_PSK_SHA256) != 0) {
+            akms |= PasnConfig.AKM_FT_PSK_SHA256;
+        }
+        if ((akmsSupported & Akm.SAE) != 0) {
+            akms |= PasnConfig.AKM_SAE;
+        }
+        if ((akmsSupported & Akm.PASN) != 0) {
+            akms |= PasnConfig.AKM_PASN;
+        }
+        return akms;
+    }
+
+
+
     /**
      * Callback to receive ranging results.
      */
@@ -286,4 +346,51 @@ public class WifiRttController {
             mWifiRttController.dump(pw);
         }
     }
+
+    /**
+     * Get optimum burst duration corresponding to a burst size.
+     *
+     * IEEE 802.11 spec, Section 11.21.6.3 Fine timing measurement procedure negotiation, burst
+     * duration is defined as
+     *
+     * Burst duration = (N_FTMPB  * (K + 1))  1) * T_MDFTM + T_FTM + aSIFSTime + T_Ack, where
+     *  - N_FTMPB is the value of the FTMs Per Burst subfield
+     *  - K is the maximum number of Fine Timing Measurement frame retransmissions the
+     *    responding STA might attempt
+     *  - T_MDFTM is the duration indicated by the Min Delta FTM subfield of the Fine Timing
+     *    Measurement Parameters field of the initial Fine Timing Measurement frame (FTM_1)
+     *  - T_FTM is the duration of the initial Fine Timing Measurement frame if the FTMs Per Burst
+     *    subfield of the Fine Timing Measurement Parameters field of FTM_1 is set to 1,
+     *    and the duration of the non-initial Fine Timing Measurement frame otherwise
+     *    T_Ack is the duration of the Ack frame expected as a response
+     *
+     * Since many of the parameters are dependent on the chip and the vendor software, framework is
+     * doing a simple conversion with experimented values. Vendor Software may override the burst
+     * duration with more optimal values.
+     *
+     * Section '9.4.2.167 Fine Timing Measurement Parameters element' defines Burst Duration
+     * subfield encoding as,
+     * +--------------------+
+     * |Value|   Represents |
+     * +--------------------+
+     * | 0-1 |  Reserved    |
+     * |  2  |    250 us    |
+     * |  3  |    500 us    |
+     * |  4  |      1 ms    |
+     * |  5  |      2 ms    |
+     * |  6  |      4 ms    |
+     * |  7  |      8 ms    |
+     * |  8  |     16 ms    |
+     * |  9  |     32 ms    |
+     * | 10  |     64 ms    |
+     * | 11  |    128 ms    |
+     * |12-14|  Reserved    |
+     * | 15  | No Preference|
+     * +-----+--------------+
+     */
+    public static int getOptimumBurstDuration(int burstSize) {
+        if (burstSize <= 8) return 9; // 32 ms
+        if (burstSize <= 24) return 10; // 64 ms
+        return 11; // 128 ms
+    }
 }
diff --git a/service/java/com/android/server/wifi/hal/WifiRttControllerAidlImpl.java b/service/java/com/android/server/wifi/hal/WifiRttControllerAidlImpl.java
index 51346df253..674e1558a3 100644
--- a/service/java/com/android/server/wifi/hal/WifiRttControllerAidlImpl.java
+++ b/service/java/com/android/server/wifi/hal/WifiRttControllerAidlImpl.java
@@ -18,6 +18,7 @@ package com.android.server.wifi.hal;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.hardware.wifi.Akm;
 import android.hardware.wifi.IWifiRttControllerEventCallback;
 import android.hardware.wifi.RttBw;
 import android.hardware.wifi.RttCapabilities;
@@ -25,6 +26,7 @@ import android.hardware.wifi.RttConfig;
 import android.hardware.wifi.RttPeerType;
 import android.hardware.wifi.RttPreamble;
 import android.hardware.wifi.RttResult;
+import android.hardware.wifi.RttSecureConfig;
 import android.hardware.wifi.RttStatus;
 import android.hardware.wifi.RttType;
 import android.hardware.wifi.WifiChannelInfo;
@@ -33,10 +35,12 @@ import android.hardware.wifi.common.OuiKeyedData;
 import android.net.MacAddress;
 import android.net.wifi.ScanResult;
 import android.net.wifi.WifiAnnotations;
+import android.net.wifi.rtt.PasnConfig;
 import android.net.wifi.rtt.RangingRequest;
 import android.net.wifi.rtt.RangingResult;
 import android.net.wifi.rtt.ResponderConfig;
 import android.net.wifi.rtt.ResponderLocation;
+import android.net.wifi.rtt.SecureRangingConfig;
 import android.os.RemoteException;
 import android.os.ServiceSpecificException;
 import android.util.Log;
@@ -45,6 +49,7 @@ import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.util.HalAidlUtil;
 
 import java.io.PrintWriter;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -293,7 +298,8 @@ public class WifiRttControllerAidlImpl implements IWifiRttController {
                     .set80211mcMeasurement(rttResult.type == RttType.TWO_SIDED_11MC)
                     .setMeasurementChannelFrequencyMHz(rttResult.channelFreqMHz)
                     .setMeasurementBandwidth(halToFrameworkChannelBandwidth(rttResult.packetBw))
-                    .set80211azNtbMeasurement(rttResult.type == RttType.TWO_SIDED_11AZ_NTB)
+                    .set80211azNtbMeasurement(rttResult.type == RttType.TWO_SIDED_11AZ_NTB
+                            || rttResult.type == RttType.TWO_SIDED_11AZ_NTB_SECURE)
                     .setMinTimeBetweenNtbMeasurementsMicros(rttResult.ntbMinMeasurementTime
                             * CONVERSION_MICROS_TO_100_MICROS)
                     .setMaxTimeBetweenNtbMeasurementsMicros(rttResult.ntbMaxMeasurementTime
@@ -301,7 +307,17 @@ public class WifiRttControllerAidlImpl implements IWifiRttController {
                     .set80211azInitiatorTxLtfRepetitionsCount(rttResult.i2rTxLtfRepetitionCount)
                     .set80211azResponderTxLtfRepetitionsCount(rttResult.r2iTxLtfRepetitionCount)
                     .set80211azNumberOfTxSpatialStreams(rttResult.numTxSpatialStreams)
-                    .set80211azNumberOfRxSpatialStreams(rttResult.numRxSpatialStreams);
+                    .set80211azNumberOfRxSpatialStreams(rttResult.numRxSpatialStreams)
+                    .setPasnComebackAfterMillis(rttResult.pasnComebackAfterMillis)
+                    .setRangingAuthenticated((rttResult.baseAkm & ~Akm.PASN) != 0)
+                    .setRangingFrameProtected(rttResult.isRangingFrameProtectionEnabled)
+                    .setSecureHeLtfEnabled(rttResult.isSecureLtfEnabled)
+                    .setSecureHeLtfProtocolVersion(rttResult.secureHeLtfProtocolVersion);
+
+            if (rttResult.pasnComebackCookie != null) {
+                resultBuilder.setPasnComebackCookie(rttResult.pasnComebackCookie);
+            }
+
             if (SdkLevel.isAtLeastV() && WifiHalAidlImpl.isServiceVersionAtLeast(2)
                     && rttResult.vendorData != null) {
                 resultBuilder.setVendorData(
@@ -397,53 +413,6 @@ public class WifiRttControllerAidlImpl implements IWifiRttController {
         }
     }
 
-    /**
-     * Get optimum burst duration corresponding to a burst size.
-     *
-     * IEEE 802.11 spec, Section 11.21.6.3 Fine timing measurement procedure negotiation, burst
-     * duration is defined as
-     *
-     * Burst duration = (N_FTMPB  * (K + 1))  1) * T_MDFTM + T_FTM + aSIFSTime + T_Ack, where
-     *  - N_FTMPB is the value of the FTMs Per Burst subfield
-     *  - K is the maximum number of Fine Timing Measurement frame retransmissions the
-     *    responding STA might attempt
-     *  - T_MDFTM is the duration indicated by the Min Delta FTM subfield of the Fine Timing
-     *    Measurement Parameters field of the initial Fine Timing Measurement frame (FTM_1)
-     *  - T_FTM is the duration of the initial Fine Timing Measurement frame if the FTMs Per Burst
-     *    subfield of the Fine Timing Measurement Parameters field of FTM_1 is set to 1,
-     *    and the duration of the non-initial Fine Timing Measurement frame otherwise
-     *    T_Ack is the duration of the Ack frame expected as a response
-     *
-     * Since many of the parameters are dependent on the chip and the vendor software, framework is
-     * doing a simple conversion with experimented values. Vendor Software may override the burst
-     * duration with more optimal values.
-     *
-     * Section '9.4.2.167 Fine Timing Measurement Parameters element' defines Burst Duration
-     * subfield encoding as,
-     * +--------------------+
-     * |Value|   Represents |
-     * +--------------------+
-     * | 0-1 |  Reserved    |
-     * |  2  |    250 us    |
-     * |  3  |    500 us    |
-     * |  4  |      1 ms    |
-     * |  5  |      2 ms    |
-     * |  6  |      4 ms    |
-     * |  7  |      8 ms    |
-     * |  8  |     16 ms    |
-     * |  9  |     32 ms    |
-     * | 10  |     64 ms    |
-     * | 11  |    128 ms    |
-     * |12-14|  Reserved    |
-     * | 15  | No Preference|
-     * +-----+--------------+
-     */
-    private static int getOptimumBurstDuration(int burstSize) {
-        if (burstSize <= 8) return 9; // 32 ms
-        if (burstSize <= 24) return 10; // 64 ms
-        return 11; // 128 ms
-    }
-
     private static RttConfig[] convertRangingRequestToRttConfigs(RangingRequest request,
             WifiRttController.Capabilities cap) {
         ArrayList<RttConfig> rttConfigs = new ArrayList<>();
@@ -510,7 +479,8 @@ public class WifiRttControllerAidlImpl implements IWifiRttController {
                     config.numFramesPerBurst = request.mRttBurstSize;
                     config.numRetriesPerRttFrame = 0; // irrelevant for 2-sided RTT
                     config.numRetriesPerFtmr = 3;
-                    config.burstDuration = getOptimumBurstDuration(request.mRttBurstSize);
+                    config.burstDuration = WifiRttController.getOptimumBurstDuration(
+                            request.mRttBurstSize);
                 } else { // AP + all non-NAN requests
                     config.mustRequestLci = true;
                     config.mustRequestLcr = true;
@@ -519,7 +489,8 @@ public class WifiRttControllerAidlImpl implements IWifiRttController {
                     config.numFramesPerBurst = request.mRttBurstSize;
                     config.numRetriesPerRttFrame = (config.type == RttType.TWO_SIDED ? 0 : 3);
                     config.numRetriesPerFtmr = 3;
-                    config.burstDuration = getOptimumBurstDuration(request.mRttBurstSize);
+                    config.burstDuration = WifiRttController.getOptimumBurstDuration(
+                            request.mRttBurstSize);
 
                     if (cap != null) { // constrain parameters per device capabilities
                         config.mustRequestLci = config.mustRequestLci && cap.lciSupported;
@@ -527,8 +498,12 @@ public class WifiRttControllerAidlImpl implements IWifiRttController {
                         config.bw = halRttChannelBandwidthCapabilityLimiter(config.bw, cap,
                                 config.type);
                         config.preamble = halRttPreambleCapabilityLimiter(config.preamble, cap,
-                                config.type);
+                                config.type, responder.frequency);
                     }
+                    // If the device and the responder is capable, IEEE 802.11 az NTB ranging can
+                    // be upgraded to IEEE 802.11 az NTB secure ranging.
+                    upgradeTo80211AzNtbSecureRanging(config, responder.getSecureRangingConfig(),
+                            cap, request.getSecurityMode());
                 }
             } catch (IllegalArgumentException e) {
                 Log.e(TAG, "Invalid configuration: " + e.getMessage());
@@ -545,6 +520,122 @@ public class WifiRttControllerAidlImpl implements IWifiRttController {
         return configArray;
     }
 
+    /**
+     * Upgrade to IEEE 802.11az NTB secure ranging, if supported.
+     */
+    private static void upgradeTo80211AzNtbSecureRanging(RttConfig halRttConfig,
+            SecureRangingConfig secureConfig, WifiRttController.Capabilities cap,
+            @RangingRequest.SecurityMode int securityMode) {
+        if (halRttConfig == null || secureConfig == null || cap == null) {
+            return;
+        }
+        // IEEE 802.11az NTB ranging capability is necessary for secure ranging.
+        if (!cap.ntbInitiatorSupported) {
+            return;
+        }
+        // Only 11az NTB ranging can be upgraded to secure ranging.
+        if (halRttConfig.type != RttType.TWO_SIDED_11AZ_NTB) {
+            return;
+        }
+        // An open security mode does not require security
+        if (securityMode == RangingRequest.SECURITY_MODE_OPEN) {
+            return;
+        }
+        // Either ranging protection of secure HE-LTF is required to be supported by the device.
+        if (!cap.rangingFrameProtectionSupported && !cap.secureHeLtfSupported) {
+            return;
+        }
+        // Check PASN configuration.
+        PasnConfig pasnConfig = secureConfig.getPasnConfig();
+        @PasnConfig.AkmType int baseAkm = getBestBaseAkm(pasnConfig.getBaseAkms(),
+                cap.akmsSupported);
+        @PasnConfig.Cipher int cipherSuite = getBestCipherSuite(pasnConfig.getCiphers(),
+                cap.cipherSuitesSupported);
+        // Responder and device need to support a valid base AKM and cipher suite.
+        if (baseAkm == PasnConfig.AKM_NONE || cipherSuite == PasnConfig.CIPHER_NONE) {
+            Log.e(TAG, "AKM/CIPHERS not compatible, skip secure ranging");
+            return;
+        }
+        halRttConfig.secureConfig = new RttSecureConfig();
+        halRttConfig.secureConfig.enableSecureHeLtf =
+                secureConfig.isSecureHeLtfEnabled() && cap.secureHeLtfSupported;
+        halRttConfig.secureConfig.enableRangingFrameProtection =
+                secureConfig.isRangingFrameProtectionEnabled()
+                        && cap.rangingFrameProtectionSupported;
+        halRttConfig.secureConfig.pasnConfig = new android.hardware.wifi.PasnConfig();
+        var passphrase = pasnConfig.getPassword();
+        if (passphrase != null) {
+            halRttConfig.secureConfig.pasnConfig.passphrase = passphrase.getBytes(
+                    StandardCharsets.UTF_8);
+        } else if (securityMode == RangingRequest.SECURITY_MODE_OPPORTUNISTIC
+                && baseAkm != PasnConfig.AKM_PASN) {
+            // If password is not present, in case of opportunistic mode, adjust the base AKM to
+            // un-authenticated PASN.
+            baseAkm = PasnConfig.AKM_PASN;
+        }
+        halRttConfig.secureConfig.pasnConfig.baseAkm = baseAkm;
+        halRttConfig.secureConfig.pasnConfig.cipherSuite = cipherSuite;
+        halRttConfig.secureConfig.pasnComebackCookie = pasnConfig.getPasnComebackCookie();
+        // Upgrade to IEEE 802.11az NTB secure ranging.
+        halRttConfig.type = RttType.TWO_SIDED_11AZ_NTB_SECURE;
+    }
+
+    /**
+     * Get the best Cipher based on security.
+     */
+    @PasnConfig.Cipher
+    private static int getBestCipherSuite(@PasnConfig.Cipher int requiredAkms,
+            @PasnConfig.Cipher int supportedAkms) {
+        int possibleAkms = requiredAkms & supportedAkms;
+        if ((possibleAkms & PasnConfig.CIPHER_GCMP_256) != 0) {
+            return PasnConfig.CIPHER_GCMP_256;
+        }
+        if ((possibleAkms & PasnConfig.CIPHER_GCMP_128) != 0) {
+            return PasnConfig.CIPHER_GCMP_128;
+        }
+        if ((possibleAkms & PasnConfig.CIPHER_CCMP_256) != 0) {
+            return PasnConfig.CIPHER_CCMP_256;
+        }
+        if ((possibleAkms & PasnConfig.CIPHER_CCMP_128) != 0) {
+            return PasnConfig.CIPHER_CCMP_128;
+        }
+        return PasnConfig.CIPHER_NONE;
+    }
+
+    /**
+     * Get the best AKM based on security.
+     */
+    @PasnConfig.AkmType
+    private static int getBestBaseAkm(@PasnConfig.AkmType int requiredAkms,
+            @PasnConfig.AkmType int supportedAkms) {
+        int possibleAkms = requiredAkms & supportedAkms;
+        if ((possibleAkms & PasnConfig.AKM_FT_EAP_SHA384) != 0) {
+            return PasnConfig.AKM_FT_EAP_SHA384;
+        }
+        if ((possibleAkms & PasnConfig.AKM_FILS_EAP_SHA384) != 0) {
+            return PasnConfig.AKM_FILS_EAP_SHA384;
+        }
+        if ((possibleAkms & PasnConfig.AKM_FILS_EAP_SHA256) != 0) {
+            return PasnConfig.AKM_FILS_EAP_SHA256;
+        }
+        if ((possibleAkms & PasnConfig.AKM_FT_EAP_SHA256) != 0) {
+            return PasnConfig.AKM_FT_EAP_SHA256;
+        }
+        if ((possibleAkms & PasnConfig.AKM_FT_PSK_SHA384) != 0) {
+            return PasnConfig.AKM_FT_PSK_SHA384;
+        }
+        if ((possibleAkms & PasnConfig.AKM_FT_PSK_SHA256) != 0) {
+            return PasnConfig.AKM_FT_PSK_SHA256;
+        }
+        if ((possibleAkms & PasnConfig.AKM_SAE) != 0) {
+            return PasnConfig.AKM_SAE;
+        }
+        if ((possibleAkms & PasnConfig.AKM_PASN) != 0) {
+            return PasnConfig.AKM_PASN;
+        }
+        return PasnConfig.AKM_NONE;
+    }
+
     private static void validateBwAndPreambleCombination(int bw, int preamble) {
         if (bw <= RttBw.BW_20MHZ) {
             return;
@@ -675,17 +766,33 @@ public class WifiRttControllerAidlImpl implements IWifiRttController {
     }
 
     /**
-     * Check whether the selected RTT preamble is supported by the device.
-     * If supported, return the requested preamble.
-     * If not supported, return the next "lower" preamble which is supported.
-     * If none, throw an IllegalArgumentException.
+     * Check whether the selected RTT preamble is supported by the device and the RTT type.
+     * <ul>
+     * <li>If supported, return the requested preamble.
+     * <li>If not supported, return the next "lower" preamble which is supported.
+     * <li>If none, throw an IllegalArgumentException.
+     * </ul>
+     *
+     * <p>Note: the halRttPreamble is a single bit flag from the HAL RttPreamble type.
      *
-     * Note: the halRttPreamble is a single bit flag from the HAL RttPreamble type.
+     * <p>Note: The IEEE 802.11mc is only compatible with HE and EHT when using the 6 GHz band.
+     * However, the IEEE 802.11az supports HE and EHT across all Wi-Fi bands (2.4GHz, 5 GHz, and
+     * 6 GHz).
      */
     private static int halRttPreambleCapabilityLimiter(int halRttPreamble,
-            WifiRttController.Capabilities cap, @RttType int rttType)
+            WifiRttController.Capabilities cap, @RttType int rttType, int frequency)
             throws IllegalArgumentException {
+        // Note: requestedPreamble is only used for the error logging
         int requestedPreamble = halRttPreamble;
+        // Since RTT type is limited based on device capability, check preamble for any adjustment.
+        // The IEEE 802.11mc is only compatible with HE and EHT when using the 6 GHz band. So
+        // adjust the preamble accordingly.
+        if (rttType <= RttType.TWO_SIDED_11MC && !ScanResult.is6GHz(frequency)) {
+            if (halRttPreamble >= RttPreamble.HE) {
+                halRttPreamble = RttPreamble.VHT;
+            }
+        }
+        // Check device capability whether preamble is supported by the device, otherwise adjust it.
         int preambleSupported = (rttType == RttType.TWO_SIDED_11AZ_NTB) ? cap.azPreambleSupported
                 : cap.preambleSupported;
         while ((halRttPreamble != 0) && ((halRttPreamble & preambleSupported) == 0)) {
diff --git a/service/java/com/android/server/wifi/hal/WifiRttControllerHidlImpl.java b/service/java/com/android/server/wifi/hal/WifiRttControllerHidlImpl.java
index cce8bb1372..4130c2248c 100644
--- a/service/java/com/android/server/wifi/hal/WifiRttControllerHidlImpl.java
+++ b/service/java/com/android/server/wifi/hal/WifiRttControllerHidlImpl.java
@@ -641,7 +641,8 @@ public class WifiRttControllerHidlImpl implements IWifiRttController {
                     config.numFramesPerBurst = request.mRttBurstSize;
                     config.numRetriesPerRttFrame = 0; // irrelevant for 2-sided RTT
                     config.numRetriesPerFtmr = 3;
-                    config.burstDuration = 9;
+                    config.burstDuration = WifiRttController.getOptimumBurstDuration(
+                            request.mRttBurstSize);
                 } else { // AP + all non-NAN requests
                     config.mustRequestLci = true;
                     config.mustRequestLcr = true;
@@ -650,7 +651,8 @@ public class WifiRttControllerHidlImpl implements IWifiRttController {
                     config.numFramesPerBurst = request.mRttBurstSize;
                     config.numRetriesPerRttFrame = (config.type == RttType.TWO_SIDED ? 0 : 3);
                     config.numRetriesPerFtmr = 3;
-                    config.burstDuration = 9;
+                    config.burstDuration = WifiRttController.getOptimumBurstDuration(
+                            request.mRttBurstSize);
 
                     if (cap != null) { // constrain parameters per device capabilities
                         config.mustRequestLci = config.mustRequestLci && cap.lciSupported;
diff --git a/service/java/com/android/server/wifi/mainline_supplicant/MainlineSupplicant.java b/service/java/com/android/server/wifi/mainline_supplicant/MainlineSupplicant.java
index e347122942..1ac2ad8f64 100644
--- a/service/java/com/android/server/wifi/mainline_supplicant/MainlineSupplicant.java
+++ b/service/java/com/android/server/wifi/mainline_supplicant/MainlineSupplicant.java
@@ -18,15 +18,31 @@ package com.android.server.wifi.mainline_supplicant;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.net.MacAddress;
+import android.net.wifi.usd.Config;
+import android.net.wifi.usd.PublishConfig;
+import android.net.wifi.usd.SubscribeConfig;
 import android.net.wifi.util.Environment;
 import android.os.IBinder;
 import android.os.RemoteException;
 import android.os.ServiceSpecificException;
 import android.system.wifi.mainline_supplicant.IMainlineSupplicant;
+import android.system.wifi.mainline_supplicant.IStaInterface;
+import android.system.wifi.mainline_supplicant.IStaInterfaceCallback;
+import android.system.wifi.mainline_supplicant.UsdMessageInfo;
+import android.system.wifi.mainline_supplicant.UsdServiceProtoType;
 import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.wifi.SupplicantStaIfaceHal;
+import com.android.server.wifi.WifiNative;
+import com.android.server.wifi.WifiThreadRunner;
+import com.android.server.wifi.usd.UsdNativeManager;
+import com.android.wifi.flags.Flags;
 
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
@@ -40,14 +56,23 @@ public class MainlineSupplicant {
     private static final String TAG = "MainlineSupplicant";
     private static final String MAINLINE_SUPPLICANT_SERVICE_NAME = "wifi_mainline_supplicant";
     private static final long WAIT_FOR_DEATH_TIMEOUT_MS = 50L;
+    protected static final int DEFAULT_USD_FREQ_MHZ = 2437;
 
     private IMainlineSupplicant mIMainlineSupplicant;
     private final Object mLock = new Object();
-    private SupplicantDeathRecipient mDeathRecipient;
+    private final WifiThreadRunner mWifiThreadRunner;
+    private SupplicantDeathRecipient mServiceDeathRecipient;
+    private WifiNative.SupplicantDeathEventHandler mFrameworkDeathHandler;
     private CountDownLatch mWaitForDeathLatch;
+    private final boolean mIsServiceAvailable;
+    private Map<String, IStaInterface> mActiveStaIfaces = new HashMap<>();
+    private Map<String, IStaInterfaceCallback> mStaIfaceCallbacks = new HashMap<>();
+    private UsdNativeManager.UsdEventsCallback mUsdEventsCallback = null;
 
-    public MainlineSupplicant() {
-        mDeathRecipient = new SupplicantDeathRecipient();
+    public MainlineSupplicant(@NonNull WifiThreadRunner wifiThreadRunner) {
+        mWifiThreadRunner = wifiThreadRunner;
+        mServiceDeathRecipient = new SupplicantDeathRecipient();
+        mIsServiceAvailable = canServiceBeAccessed();
     }
 
     @VisibleForTesting
@@ -84,12 +109,42 @@ public class MainlineSupplicant {
                     // Latch indicates that this event was triggered by stopService
                     mWaitForDeathLatch.countDown();
                 }
-                mIMainlineSupplicant = null;
+                clearState();
+                if (mFrameworkDeathHandler != null) {
+                    mFrameworkDeathHandler.onDeath();
+                }
                 Log.i(TAG, "Service death was handled successfully");
             }
         }
     }
 
+    /**
+     * Check whether the mainline supplicant service can be accessed.
+     */
+    private boolean canServiceBeAccessed() {
+        // Requires an Android B+ Selinux policy and a copy of the binary.
+        return Environment.isSdkAtLeastB() && Flags.mainlineSupplicant()
+                && Environment.isMainlineSupplicantBinaryInWifiApex();
+    }
+
+    /**
+     * Returns true if the mainline supplicant service is available on this device.
+     */
+    public boolean isAvailable() {
+        return mIsServiceAvailable;
+    }
+
+    /**
+     * Reset the internal state for this instance.
+     */
+    private void clearState() {
+        synchronized (mLock) {
+            mIMainlineSupplicant = null;
+            mActiveStaIfaces.clear();
+            mStaIfaceCallbacks.clear();
+        }
+    }
+
     /**
      * Start the mainline supplicant process.
      *
@@ -114,7 +169,8 @@ public class MainlineSupplicant {
 
             try {
                 mWaitForDeathLatch = null;
-                mIMainlineSupplicant.asBinder().linkToDeath(mDeathRecipient, /* flags= */  0);
+                mIMainlineSupplicant.asBinder()
+                        .linkToDeath(mServiceDeathRecipient, /* flags= */  0);
             } catch (RemoteException e) {
                 handleRemoteException(e, "startService");
                 return false;
@@ -128,13 +184,129 @@ public class MainlineSupplicant {
     /**
      * Check whether this instance is active.
      */
-    @VisibleForTesting
-    protected boolean isActive() {
+    public boolean isActive() {
         synchronized (mLock) {
             return mIMainlineSupplicant != null;
         }
     }
 
+    /**
+     * Set up a STA interface with the specified iface name.
+     *
+     * @param ifaceName Name of the interface.
+     * @return true on success, false otherwise.
+     */
+    public boolean addStaInterface(@NonNull String ifaceName) {
+        synchronized (mLock) {
+            final String methodName = "addStaInterface";
+            if (!checkIsActiveAndLogError(methodName)) {
+                return false;
+            }
+            if (ifaceName == null) {
+                return false;
+            }
+            if (mActiveStaIfaces.containsKey(ifaceName)) {
+                Log.i(TAG, "STA interface " + ifaceName + " already exists");
+                return true;
+            }
+
+            try {
+                IStaInterface staIface = mIMainlineSupplicant.addStaInterface(ifaceName);
+                IStaInterfaceCallback callback = new MainlineSupplicantStaIfaceCallback(
+                        this, ifaceName, mWifiThreadRunner);
+                if (!registerStaIfaceCallback(staIface, callback)) {
+                    Log.i(TAG, "Unable to register callback with interface " + ifaceName);
+                    return false;
+                }
+                mActiveStaIfaces.put(ifaceName, staIface);
+                // Keep callback in a store to avoid recycling by the garbage collector
+                mStaIfaceCallbacks.put(ifaceName, callback);
+                Log.i(TAG, "Added STA interface " + ifaceName);
+                return true;
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Tear down the STA interface with the specified iface name.
+     *
+     * @param ifaceName Name of the interface.
+     * @return true on success, false otherwise.
+     */
+    public boolean removeStaInterface(@NonNull String ifaceName) {
+        synchronized (mLock) {
+            final String methodName = "removeStaInterface";
+            if (!checkIsActiveAndLogError(methodName)) {
+                return false;
+            }
+            if (ifaceName == null) {
+                return false;
+            }
+            if (!mActiveStaIfaces.containsKey(ifaceName)) {
+                Log.i(TAG, "STA interface " + ifaceName + " does not exist");
+                return false;
+            }
+
+            try {
+                mIMainlineSupplicant.removeStaInterface(ifaceName);
+                mActiveStaIfaces.remove(ifaceName);
+                mStaIfaceCallbacks.remove(ifaceName);
+                Log.i(TAG, "Removed STA interface " + ifaceName);
+                return true;
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Register a callback with the provided STA interface.
+     *
+     * @return true if the registration was successful, false otherwise.
+     */
+    private boolean registerStaIfaceCallback(@NonNull IStaInterface iface,
+            @NonNull IStaInterfaceCallback callback) {
+        synchronized (mLock) {
+            final String methodName = "registerStaIfaceCallback";
+            if (iface == null || callback == null) {
+                return false;
+            }
+            try {
+                iface.registerCallback(callback);
+                return true;
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Register a framework callback to receive USD events.
+     */
+    public void registerUsdEventsCallback(
+            @NonNull UsdNativeManager.UsdEventsCallback usdEventsCallback) {
+        mUsdEventsCallback = usdEventsCallback;
+    }
+
+    /**
+     * Get the registered USD events callback. Method should only be used
+     * by {@link MainlineSupplicantStaIfaceCallback}.
+     */
+    protected @Nullable UsdNativeManager.UsdEventsCallback getUsdEventsCallback() {
+        return mUsdEventsCallback;
+    }
+
     /**
      * Stop the mainline supplicant process.
      */
@@ -166,14 +338,382 @@ public class MainlineSupplicant {
         }
     }
 
+    /**
+     * Register a WifiNative death handler to receive service death notifications.
+     */
+    public void registerFrameworkDeathHandler(
+            @NonNull WifiNative.SupplicantDeathEventHandler deathHandler) {
+        if (deathHandler == null) {
+            Log.e(TAG, "Attempted to register a null death handler");
+            return;
+        }
+        synchronized (mLock) {
+            if (mFrameworkDeathHandler != null) {
+                Log.i(TAG, "Replacing the existing death handler");
+            }
+            mFrameworkDeathHandler = deathHandler;
+        }
+    }
+
+    /**
+     * Unregister an existing WifiNative death handler, for instance to avoid receiving a
+     * death notification during a solicited terminate.
+     */
+    public void unregisterFrameworkDeathHandler() {
+        synchronized (mLock) {
+            if (mFrameworkDeathHandler == null) {
+                Log.e(TAG, "Framework death handler has already been unregistered");
+                return;
+            }
+            mFrameworkDeathHandler = null;
+        }
+    }
+
+    private static byte frameworkToHalUsdTransmissionType(
+            @Config.TransmissionType int transmissionType) {
+        switch (transmissionType) {
+            case Config.TRANSMISSION_TYPE_MULTICAST:
+                return IStaInterface.UsdPublishTransmissionType.MULTICAST;
+            case Config.TRANSMISSION_TYPE_UNICAST:
+            default:
+                return IStaInterface.UsdPublishTransmissionType.UNICAST;
+        }
+    }
+
+    private static byte frameworkToHalUsdProtoType(
+            @Config.ServiceProtoType int protoType) {
+        switch (protoType) {
+            case Config.SERVICE_PROTO_TYPE_GENERIC:
+                return UsdServiceProtoType.GENERIC;
+            case Config.SERVICE_PROTO_TYPE_CSA_MATTER:
+                return UsdServiceProtoType.CSA_MATTER;
+            default:
+                return UsdServiceProtoType.UNKNOWN;
+        }
+    }
+
+    @VisibleForTesting
+    protected static IStaInterface.UsdPublishConfig frameworkToHalUsdPublishConfig(
+            PublishConfig frameworkConfig) {
+        IStaInterface.UsdPublishConfig aidlConfig = new IStaInterface.UsdPublishConfig();
+        // USD publisher is always solicited and unsolicited
+        aidlConfig.publishType = IStaInterface.UsdPublishType.SOLICITED_AND_UNSOLICITED;
+        // FSD is always enabled for USD
+        aidlConfig.isFsd = true;
+        aidlConfig.transmissionType = frameworkToHalUsdTransmissionType(
+                frameworkConfig.getSolicitedTransmissionType());
+        aidlConfig.announcementPeriodMillis = frameworkConfig.getAnnouncementPeriodMillis();
+        aidlConfig.baseConfig = new IStaInterface.UsdBaseConfig();
+        aidlConfig.baseConfig.ttlSec = frameworkConfig.getTtlSeconds();
+        int[] freqs = frameworkConfig.getOperatingFrequenciesMhz();
+        aidlConfig.baseConfig.defaultFreqMhz = (freqs == null || freqs.length == 0)
+                ? DEFAULT_USD_FREQ_MHZ : freqs[0];
+        aidlConfig.baseConfig.freqsMhz = (freqs == null || freqs.length <= 1)
+                ? new int[0] : Arrays.copyOfRange(freqs, 1, freqs.length);
+        aidlConfig.baseConfig.serviceName = Arrays.toString(frameworkConfig.getServiceName());
+        aidlConfig.baseConfig.serviceSpecificInfo =
+                frameworkConfig.getServiceSpecificInfo() != null
+                        ? frameworkConfig.getServiceSpecificInfo() : new byte[0];
+        aidlConfig.baseConfig.rxMatchFilter = frameworkConfig.getRxMatchFilterTlv() != null
+                ? frameworkConfig.getRxMatchFilterTlv() : new byte[0];
+        aidlConfig.baseConfig.txMatchFilter = frameworkConfig.getTxMatchFilterTlv() != null
+                ? frameworkConfig.getTxMatchFilterTlv() : new byte[0];
+        aidlConfig.baseConfig.serviceProtoType = frameworkToHalUsdProtoType(
+                frameworkConfig.getServiceProtoType());
+        return aidlConfig;
+    }
+
+    /**
+     * Start a USD publish operation.
+     *
+     * @param ifaceName Name of the interface
+     * @param cmdId An id for this command
+     * @param publishConfig Publish configuration
+     * @return true if successful, false otherwise
+     */
+    public boolean startUsdPublish(@NonNull String ifaceName, int cmdId,
+            @NonNull PublishConfig publishConfig) {
+        synchronized (mLock) {
+            final String methodName = "startUsdPublish";
+            if (ifaceName == null || publishConfig == null) {
+                return false;
+            }
+            IStaInterface iface = getStaIfaceOrLogError(ifaceName, methodName);
+            if (iface == null) {
+                return false;
+            }
+            try {
+                iface.startUsdPublish(cmdId, frameworkToHalUsdPublishConfig(publishConfig));
+                return true;
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+            return false;
+        }
+    }
+
+    private static byte frameworkToHalUsdSubscribeType(
+            @Config.SubscribeType int subscribeType) {
+        switch (subscribeType) {
+            case Config.SUBSCRIBE_TYPE_ACTIVE:
+                return IStaInterface.UsdSubscribeType.ACTIVE_MODE;
+            case Config.SUBSCRIBE_TYPE_PASSIVE:
+            default:
+                return IStaInterface.UsdSubscribeType.PASSIVE_MODE;
+        }
+    }
+
+    @VisibleForTesting
+    protected static IStaInterface.UsdSubscribeConfig frameworkToHalUsdSubscribeConfig(
+            SubscribeConfig frameworkConfig) {
+        IStaInterface.UsdSubscribeConfig aidlConfig = new IStaInterface.UsdSubscribeConfig();
+        aidlConfig.subscribeType =
+                frameworkToHalUsdSubscribeType(frameworkConfig.getSubscribeType());
+        aidlConfig.queryPeriodMillis = frameworkConfig.getQueryPeriodMillis();
+        aidlConfig.baseConfig = new IStaInterface.UsdBaseConfig();
+        aidlConfig.baseConfig.ttlSec = frameworkConfig.getTtlSeconds();
+        int[] freqs = frameworkConfig.getOperatingFrequenciesMhz();
+        aidlConfig.baseConfig.defaultFreqMhz = (freqs == null || freqs.length == 0)
+                ? DEFAULT_USD_FREQ_MHZ : freqs[0];
+        aidlConfig.baseConfig.freqsMhz = (freqs == null || freqs.length <= 1)
+                ? new int[0] : Arrays.copyOfRange(freqs, 1, freqs.length);
+        aidlConfig.baseConfig.serviceName = Arrays.toString(frameworkConfig.getServiceName());
+        aidlConfig.baseConfig.serviceSpecificInfo =
+                frameworkConfig.getServiceSpecificInfo() != null
+                        ? frameworkConfig.getServiceSpecificInfo() : new byte[0];
+        aidlConfig.baseConfig.rxMatchFilter = frameworkConfig.getRxMatchFilterTlv() != null
+                ? frameworkConfig.getRxMatchFilterTlv() : new byte[0];
+        aidlConfig.baseConfig.txMatchFilter = frameworkConfig.getTxMatchFilterTlv() != null
+                ? frameworkConfig.getTxMatchFilterTlv() : new byte[0];
+        aidlConfig.baseConfig.serviceProtoType = frameworkToHalUsdProtoType(
+                frameworkConfig.getServiceProtoType());
+        return aidlConfig;
+    }
+
+    /**
+     * Start a USD subscribe operation.
+     *
+     * @param ifaceName Name of the interface
+     * @param cmdId An id for this command
+     * @param subscribeConfig Subscribe configuration
+     * @return true if successful, false otherwise
+     */
+    public boolean startUsdSubscribe(@NonNull String ifaceName, int cmdId,
+            @NonNull SubscribeConfig subscribeConfig) {
+        synchronized (mLock) {
+            final String methodName = "startUsdSubscribe";
+            if (ifaceName == null || subscribeConfig == null) {
+                return false;
+            }
+            IStaInterface iface = getStaIfaceOrLogError(ifaceName, methodName);
+            if (iface == null) {
+                return false;
+            }
+            try {
+                iface.startUsdSubscribe(cmdId, frameworkToHalUsdSubscribeConfig(subscribeConfig));
+                return true;
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Get the USD capabilities for the interface.
+     *
+     * @param ifaceName Name of the interface
+     * @return UsdCapabilities if available, otherwise null
+     */
+    public @Nullable SupplicantStaIfaceHal.UsdCapabilitiesInternal getUsdCapabilities(
+            @NonNull String ifaceName) {
+        synchronized (mLock) {
+            final String methodName = "getUsdCapabilities";
+            if (ifaceName == null) {
+                return null;
+            }
+            IStaInterface iface = getStaIfaceOrLogError(ifaceName, methodName);
+            if (iface == null) {
+                return null;
+            }
+            try {
+                IStaInterface.UsdCapabilities aidlCaps = iface.getUsdCapabilities();
+                if (aidlCaps == null) {
+                    Log.e(TAG, "Received null USD capabilities from the HAL");
+                    return null;
+                }
+                return new SupplicantStaIfaceHal.UsdCapabilitiesInternal(
+                        aidlCaps.isUsdPublisherSupported,
+                        aidlCaps.isUsdSubscriberSupported,
+                        aidlCaps.maxLocalSsiLengthBytes,
+                        aidlCaps.maxServiceNameLengthBytes,
+                        aidlCaps.maxMatchFilterLengthBytes,
+                        aidlCaps.maxNumPublishSessions,
+                        aidlCaps.maxNumSubscribeSessions);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Update an ongoing USD publish operation.
+     *
+     * @param ifaceName Name of the interface
+     * @param publishId Publish id for this session
+     * @param ssi Service specific info
+     */
+    public void updateUsdPublish(@NonNull String ifaceName, int publishId,
+            @NonNull byte[] ssi) {
+        synchronized (mLock) {
+            final String methodName = "updateUsdPublish";
+            if (ifaceName == null || ssi == null) {
+                return;
+            }
+            IStaInterface iface = getStaIfaceOrLogError(ifaceName, methodName);
+            if (iface == null) {
+                return;
+            }
+            try {
+                iface.updateUsdPublish(publishId, ssi);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+        }
+    }
+
+    /**
+     * Cancel an ongoing USD publish session.
+     *
+     * @param ifaceName Name of the interface
+     * @param publishId Publish id for the session
+     */
+    public void cancelUsdPublish(@NonNull String ifaceName, int publishId) {
+        synchronized (mLock) {
+            final String methodName = "cancelUsdPublish";
+            if (ifaceName == null) {
+                return;
+            }
+            IStaInterface iface = getStaIfaceOrLogError(ifaceName, methodName);
+            if (iface == null) {
+                return;
+            }
+            try {
+                iface.cancelUsdPublish(publishId);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+        }
+    }
+
+    /**
+     * Cancel an ongoing USD subscribe session.
+     *
+     * @param ifaceName Name of the interface
+     * @param subscribeId Subscribe id for the session
+     */
+    public void cancelUsdSubscribe(@NonNull String ifaceName, int subscribeId) {
+        synchronized (mLock) {
+            final String methodName = "cancelUsdSubscribe";
+            if (ifaceName == null) {
+                return;
+            }
+            IStaInterface iface = getStaIfaceOrLogError(ifaceName, methodName);
+            if (iface == null) {
+                return;
+            }
+            try {
+                iface.cancelUsdSubscribe(subscribeId);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+        }
+    }
+
+    private static UsdMessageInfo createUsdMessageInfo(int ownId, int peerId,
+            MacAddress peerMacAddress, byte[] message) {
+        UsdMessageInfo messageInfo = new UsdMessageInfo();
+        messageInfo.ownId = ownId;
+        messageInfo.peerId = peerId;
+        messageInfo.message = message;
+        messageInfo.peerMacAddress = peerMacAddress.toByteArray();
+        return messageInfo;
+    }
+
+    /**
+     * Send a message to an ongoing USD publish or subscribe session.
+     *
+     * @param ifaceName Name of the interface
+     * @param ownId Id for the session
+     * @param peerId Id for the peer session
+     * @param peerMacAddress Mac address of the peer session
+     * @param message Data to send
+     * @return true if successful, false otherwise
+     */
+    public boolean sendUsdMessage(@NonNull String ifaceName, int ownId, int peerId,
+            @NonNull MacAddress peerMacAddress, @NonNull byte[] message) {
+        synchronized (mLock) {
+            final String methodName = "sendUsdMessage";
+            if (ifaceName == null || peerMacAddress == null || message == null) {
+                return false;
+            }
+            IStaInterface iface = getStaIfaceOrLogError(ifaceName, methodName);
+            if (iface == null) {
+                return false;
+            }
+            try {
+                iface.sendUsdMessage(
+                        createUsdMessageInfo(ownId, peerId, peerMacAddress, message));
+                return true;
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodName);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodName);
+            }
+            return false;
+        }
+    }
+
     private void handleServiceSpecificException(ServiceSpecificException e, String methodName) {
         Log.e(TAG, methodName + " encountered ServiceSpecificException " + e);
     }
 
+    private boolean checkIsActiveAndLogError(String methodName) {
+        if (!isActive()) {
+            Log.e(TAG, "Unable to call " + methodName + " since the instance is not active");
+            return false;
+        }
+        return true;
+    }
+
+    private @Nullable IStaInterface getStaIfaceOrLogError(String ifaceName, String methodName) {
+        synchronized (mLock) {
+            if (!mActiveStaIfaces.containsKey(ifaceName)) {
+                Log.e(TAG, "Unable to call " + methodName + " since iface "
+                        + ifaceName + " does not exist");
+                return null;
+            }
+            return mActiveStaIfaces.get(ifaceName);
+        }
+    }
+
     private void handleRemoteException(RemoteException e, String methodName) {
         synchronized (mLock) {
             Log.e(TAG, methodName + " encountered RemoteException " + e);
-            mIMainlineSupplicant = null;
+            clearState();
         }
     }
 }
diff --git a/service/java/com/android/server/wifi/mainline_supplicant/MainlineSupplicantStaIfaceCallback.java b/service/java/com/android/server/wifi/mainline_supplicant/MainlineSupplicantStaIfaceCallback.java
new file mode 100644
index 0000000000..4d6207357e
--- /dev/null
+++ b/service/java/com/android/server/wifi/mainline_supplicant/MainlineSupplicantStaIfaceCallback.java
@@ -0,0 +1,315 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi.mainline_supplicant;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.SuppressLint;
+import android.net.MacAddress;
+import android.net.wifi.usd.Config;
+import android.net.wifi.usd.SessionCallback;
+import android.system.wifi.mainline_supplicant.IStaInterfaceCallback;
+import android.system.wifi.mainline_supplicant.UsdMessageInfo;
+import android.system.wifi.mainline_supplicant.UsdServiceProtoType;
+import android.util.Log;
+
+import com.android.server.wifi.WifiThreadRunner;
+import com.android.server.wifi.usd.UsdNativeManager;
+import com.android.server.wifi.usd.UsdRequestManager;
+
+/**
+ * Implementation of the mainline supplicant {@link IStaInterfaceCallback}.
+ */
+public class MainlineSupplicantStaIfaceCallback extends IStaInterfaceCallback.Stub {
+    private static final String TAG = "MainlineSupplicantStaIfaceCallback";
+
+    private final MainlineSupplicant mMainlineSupplicant;
+    private final String mIfaceName;
+    private final WifiThreadRunner mWifiThreadRunner;
+
+    MainlineSupplicantStaIfaceCallback(@NonNull MainlineSupplicant mainlineSupplicant,
+            @NonNull String ifaceName, @NonNull WifiThreadRunner wifiThreadRunner) {
+        mMainlineSupplicant = mainlineSupplicant;
+        mIfaceName = ifaceName;
+        mWifiThreadRunner = wifiThreadRunner;
+    }
+
+    /**
+     * Called in response to startUsdPublish to indicate that the publish session
+     * was started successfully.
+     *
+     * @param cmdId Identifier for the original request.
+     * @param publishId Identifier for the publish session.
+     */
+    @Override
+    public void onUsdPublishStarted(int cmdId, int publishId) {
+        mWifiThreadRunner.post(() -> {
+            UsdNativeManager.UsdEventsCallback usdCallback =
+                    mMainlineSupplicant.getUsdEventsCallback();
+            if (usdCallback == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            usdCallback.onUsdPublishStarted(cmdId, publishId);
+        });
+    }
+
+    /**
+     * Called in response to startUsdSubscribe to indicate that the subscribe session
+     * was started successfully.
+     *
+     * @param cmdId Identifier for the original request.
+     * @param subscribeId Identifier for the subscribe session.
+     */
+    @Override
+    public void onUsdSubscribeStarted(int cmdId, int subscribeId) {
+        mWifiThreadRunner.post(() -> {
+            UsdNativeManager.UsdEventsCallback usdCallback =
+                    mMainlineSupplicant.getUsdEventsCallback();
+            if (usdCallback == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            usdCallback.onUsdSubscribeStarted(cmdId, subscribeId);
+        });
+    }
+
+    @SuppressLint("NewApi")
+    private static @SessionCallback.FailureCode int
+            convertHalToFrameworkUsdConfigErrorCode(int errorCode) {
+        switch (errorCode) {
+            case UsdConfigErrorCode.FAILURE_TIMEOUT:
+                return SessionCallback.FAILURE_TIMEOUT;
+            case UsdConfigErrorCode.FAILURE_NOT_AVAILABLE:
+                return SessionCallback.FAILURE_NOT_AVAILABLE;
+            default:
+                return SessionCallback.FAILURE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Called in response to startUsdPublish to indicate that the publish session
+     * could not be configured.
+     *
+     * @param cmdId Identifier for the original request.
+     * @param errorCode Code indicating the failure reason.
+     */
+    @Override public void onUsdPublishConfigFailed(int cmdId, int errorCode)  {
+        mWifiThreadRunner.post(() -> {
+            UsdNativeManager.UsdEventsCallback usdCallback =
+                    mMainlineSupplicant.getUsdEventsCallback();
+            if (usdCallback == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            usdCallback.onUsdPublishConfigFailed(cmdId,
+                    convertHalToFrameworkUsdConfigErrorCode(errorCode));
+        });
+    }
+
+    /**
+     * Called in response to startUsdSubscribe to indicate that the subscribe session
+     * could not be configured.
+     *
+     * @param cmdId Identifier for the original request.
+     * @param errorCode Code indicating the failure reason.
+     */
+    @Override
+    public void onUsdSubscribeConfigFailed(int cmdId, int errorCode) {
+        mWifiThreadRunner.post(() -> {
+            UsdNativeManager.UsdEventsCallback usdCallback =
+                    mMainlineSupplicant.getUsdEventsCallback();
+            if (usdCallback == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            usdCallback.onUsdSubscribeConfigFailed(cmdId,
+                    convertHalToFrameworkUsdConfigErrorCode(errorCode));
+        });
+    }
+
+    @SuppressLint("NewApi")
+    private static @SessionCallback.TerminationReasonCode int
+            convertHalToFrameworkUsdTerminateReasonCode(int reasonCode) {
+        switch (reasonCode) {
+            case UsdTerminateReasonCode.USER_REQUESTED:
+                return SessionCallback.TERMINATION_REASON_USER_INITIATED;
+            default:
+                return SessionCallback.TERMINATION_REASON_UNKNOWN;
+        }
+    }
+
+    /**
+     * Called in response to cancelUsdPublish to indicate that the session was cancelled
+     * successfully. May also be called unsolicited if the session terminated by supplicant.
+     *
+     * @param publishId Identifier for the publish session.
+     * @param reasonCode Code indicating the reason for the session cancellation.
+     */
+    @Override
+    public void onUsdPublishTerminated(int publishId, int reasonCode) {
+        mWifiThreadRunner.post(() -> {
+            UsdNativeManager.UsdEventsCallback usdCallback =
+                    mMainlineSupplicant.getUsdEventsCallback();
+            if (usdCallback == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            usdCallback.onUsdPublishTerminated(publishId,
+                    convertHalToFrameworkUsdTerminateReasonCode(reasonCode));
+        });
+    }
+
+    /**
+     * Called in response to cancelUsdSubscribe to indicate that the session was cancelled
+     * successfully. May also be called unsolicited if the session terminated by supplicant.
+     *
+     * @param subscribeId Identifier for the subscribe session.
+     * @param reasonCode Code indicating the reason for the session cancellation.
+     */
+    @Override
+    public void onUsdSubscribeTerminated(int subscribeId, int reasonCode) {
+        mWifiThreadRunner.post(() -> {
+            UsdNativeManager.UsdEventsCallback usdCallback =
+                    mMainlineSupplicant.getUsdEventsCallback();
+            if (usdCallback == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            usdCallback.onUsdSubscribeTerminated(subscribeId,
+                    convertHalToFrameworkUsdTerminateReasonCode(reasonCode));
+        });
+    }
+
+    private static @Config.ServiceProtoType int
+            convertHalToFrameworkUsdProtocolType(int protocolType) {
+        switch (protocolType) {
+            case UsdServiceProtoType.CSA_MATTER:
+                return Config.SERVICE_PROTO_TYPE_CSA_MATTER;
+            default:
+                return Config.SERVICE_PROTO_TYPE_GENERIC;
+        }
+    }
+
+    private static @Nullable MacAddress safeConvertMacAddress(byte[] macAddrBytes) {
+        if (macAddrBytes == null) return null;
+        try {
+            return MacAddress.fromBytes(macAddrBytes);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    private static UsdRequestManager.UsdHalDiscoveryInfo
+            convertHalToFrameworkUsdDiscoveryInfo(UsdServiceDiscoveryInfo discoveryInfo) {
+        if (discoveryInfo.peerMacAddress == null
+                || discoveryInfo.serviceSpecificInfo == null
+                || discoveryInfo.matchFilter == null) {
+            Log.e(TAG, "USD discovery info contains a null parameter");
+            return null;
+        }
+        MacAddress peerAddress = safeConvertMacAddress(discoveryInfo.peerMacAddress);
+        if (peerAddress == null) {
+            Log.e(TAG, "USD discovery info contains an invalid peer address");
+            return null;
+        }
+        return new UsdRequestManager.UsdHalDiscoveryInfo(discoveryInfo.ownId,
+                discoveryInfo.peerId,
+                peerAddress,
+                discoveryInfo.serviceSpecificInfo,
+                convertHalToFrameworkUsdProtocolType(discoveryInfo.serviceProtoType),
+                discoveryInfo.isFsd,
+                discoveryInfo.matchFilter);
+    }
+
+    /**
+     * Indicates that the publisher sent a solicited publish message to the subscriber.
+     *
+     * @param info Instance of |UsdServiceDiscoveryInfo| containing information about the reply.
+     */
+    @Override
+    public void onUsdPublishReplied(UsdServiceDiscoveryInfo info) {
+        mWifiThreadRunner.post(() -> {
+            UsdNativeManager.UsdEventsCallback usdCallback =
+                    mMainlineSupplicant.getUsdEventsCallback();
+            if (usdCallback == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            UsdRequestManager.UsdHalDiscoveryInfo convertedInfo =
+                    convertHalToFrameworkUsdDiscoveryInfo(info);
+            if (convertedInfo == null) {
+                return;
+            }
+            usdCallback.onUsdPublishReplied(convertedInfo);
+        });
+    }
+
+    /**
+     * Indicates that a publisher was discovered. Only called if this device is acting as a
+     * subscriber.
+     *
+     * @param info Instance of |UsdServiceDiscoveryInfo| containing information about the service.
+     */
+    @Override
+    public void onUsdServiceDiscovered(UsdServiceDiscoveryInfo info) {
+        mWifiThreadRunner.post(() -> {
+            UsdNativeManager.UsdEventsCallback usdCallback =
+                    mMainlineSupplicant.getUsdEventsCallback();
+            if (usdCallback == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            UsdRequestManager.UsdHalDiscoveryInfo convertedInfo =
+                    convertHalToFrameworkUsdDiscoveryInfo(info);
+            if (convertedInfo == null) {
+                return;
+            }
+            usdCallback.onUsdServiceDiscovered(convertedInfo);
+        });
+    }
+
+    /**
+     * Indicates that a message was received on an active USD link.
+     *
+     * @param messageInfo Information about the message that was received.
+     */
+    @Override
+    public void onUsdMessageReceived(UsdMessageInfo messageInfo) {
+        mWifiThreadRunner.post(() -> {
+            UsdNativeManager.UsdEventsCallback usdCallback =
+                    mMainlineSupplicant.getUsdEventsCallback();
+            if (usdCallback == null) {
+                Log.e(TAG, "UsdEventsCallback callback is null");
+                return;
+            }
+            MacAddress peerAddress = safeConvertMacAddress(messageInfo.peerMacAddress);
+            if (peerAddress == null) {
+                Log.e(TAG, "USD message info contains an invalid peer address");
+                return;
+            }
+            if (messageInfo.message == null) {
+                Log.e(TAG, "USD message info contains a null message");
+                return;
+            }
+            usdCallback.onUsdMessageReceived(messageInfo.ownId,
+                    messageInfo.peerId,
+                    peerAddress,
+                    messageInfo.message);
+        });
+    }
+}
diff --git a/service/java/com/android/server/wifi/p2p/ISupplicantP2pIfaceHal.java b/service/java/com/android/server/wifi/p2p/ISupplicantP2pIfaceHal.java
index ef2d9fd146..9dc9cd1845 100644
--- a/service/java/com/android/server/wifi/p2p/ISupplicantP2pIfaceHal.java
+++ b/service/java/com/android/server/wifi/p2p/ISupplicantP2pIfaceHal.java
@@ -21,12 +21,16 @@ import android.annotation.Nullable;
 import android.net.wifi.CoexUnsafeChannel;
 import android.net.wifi.ScanResult;
 import android.net.wifi.p2p.WifiP2pConfig;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pDiscoveryConfig;
 import android.net.wifi.p2p.WifiP2pExtListenParams;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
 
 import com.android.server.wifi.WifiNative;
 
@@ -266,12 +270,14 @@ interface ISupplicantP2pIfaceHal {
     /**
      * Reinvoke a device from a persistent group.
      *
-     * @param networkId Used to specify the persistent group.
+     * @param networkId Used to specify the persistent group (valid only for P2P V1 group).
      * @param peerAddress MAC address of the device to reinvoke.
+     * @param dikId The identifier of device identity key of the device to reinvoke.
+     *              (valid only for P2P V2 group).
      *
      * @return true, if operation was successful.
      */
-    boolean reinvoke(int networkId, String peerAddress);
+    boolean reinvoke(int networkId, String peerAddress, int dikId);
 
     /**
      * Set up a P2P group owner manually (i.e., without group owner
@@ -280,10 +286,11 @@ interface ISupplicantP2pIfaceHal {
      *
      * @param networkId Used to specify the restart of a persistent group.
      * @param isPersistent Used to request a persistent group to be formed.
+     * @param isP2pV2 Used to start a Group Owner that support P2P2 IE
      *
      * @return true, if operation was successful.
      */
-    boolean groupAdd(int networkId, boolean isPersistent);
+    boolean groupAdd(int networkId, boolean isPersistent, boolean isP2pV2);
 
     /**
      * Set up a P2P group as Group Owner or join a group with a configuration.
@@ -607,6 +614,73 @@ interface ISupplicantP2pIfaceHal {
     boolean configureEapolIpAddressAllocationParams(int ipAddressGo, int ipAddressMask,
             int ipAddressStart, int ipAddressEnd);
 
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param discoveryConfig is the configuration for this service discovery request.
+     * @param timeoutInSeconds is the maximum time to be spent for this service discovery request.
+     */
+    int startUsdBasedServiceDiscovery(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedServiceDiscoveryConfig discoveryConfig, int timeoutInSeconds);
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param sessionId Identifier to cancel the service discovery instance.
+     *        Use zero to cancel all the service discovery instances.
+     */
+    void stopUsdBasedServiceDiscovery(int sessionId);
+
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param advertisementConfig is the configuration for this service advertisement.
+     * @param timeoutInSeconds is the maximum time to be spent for this service advertisement.
+     */
+    int startUsdBasedServiceAdvertisement(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedLocalServiceAdvertisementConfig advertisementConfig,
+            int timeoutInSeconds);
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param sessionId Identifier to cancel the service advertisement.
+     *        Use zero to cancel all the service advertisement instances.
+     */
+    void stopUsdBasedServiceAdvertisement(int sessionId);
+
+    /**
+     * Get the Device Identity Resolution (DIR) Information.
+     * See {@link WifiP2pDirInfo} for details
+     *
+     * @return {@link WifiP2pDirInfo} instance on success, null on failure.
+     */
+    WifiP2pDirInfo getDirInfo();
+
+    /**
+     * Validate the Device Identity Resolution (DIR) Information of a P2P device.
+     * See {@link WifiP2pDirInfo} for details.
+     *
+     * @param dirInfo {@link WifiP2pDirInfo} to validate.
+     * @return The identifier of device identity key on success, -1 on failure.
+     */
+    int validateDirInfo(@NonNull WifiP2pDirInfo dirInfo);
+
+    /**
+     * Used to authorize a connection request to an existing Group Owner
+     * interface, to allow a peer device to connect.
+     *
+     * @param config Configuration to use for connection.
+     * @param groupOwnerInterfaceName Group Owner interface name on which the request to connect
+     *                           needs to be authorized.
+     *
+     * @return boolean value indicating whether operation was successful.
+     */
+    boolean authorizeConnectRequestOnGroupOwner(WifiP2pConfig config,
+            String groupOwnerInterfaceName);
+
     /**
      * Terminate the supplicant daemon & wait for its death.
      * Note: Aidl only since it was added from HIDL 1.1
diff --git a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackAidlImpl.java b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackAidlImpl.java
index 3bc093e2e9..8c812a37e1 100644
--- a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackAidlImpl.java
+++ b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackAidlImpl.java
@@ -21,6 +21,7 @@ import static com.android.wifi.flags.Flags.wifiDirectR2;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.SuppressLint;
 import android.hardware.wifi.supplicant.ISupplicantP2pIfaceCallback;
 import android.hardware.wifi.supplicant.KeyMgmtMask;
 import android.hardware.wifi.supplicant.P2pClientEapolIpAddressInfo;
@@ -28,6 +29,7 @@ import android.hardware.wifi.supplicant.P2pDeviceFoundEventParams;
 import android.hardware.wifi.supplicant.P2pGoNegotiationReqEventParams;
 import android.hardware.wifi.supplicant.P2pGroupStartedEventParams;
 import android.hardware.wifi.supplicant.P2pInvitationEventParams;
+import android.hardware.wifi.supplicant.P2pPairingBootstrappingMethodMask;
 import android.hardware.wifi.supplicant.P2pPeerClientDisconnectedEventParams;
 import android.hardware.wifi.supplicant.P2pPeerClientJoinedEventParams;
 import android.hardware.wifi.supplicant.P2pProvDiscStatusCode;
@@ -42,14 +44,18 @@ import android.net.wifi.ScanResult;
 import android.net.wifi.WpsInfo;
 import android.net.wifi.p2p.WifiP2pConfig;
 import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pGroup;
+import android.net.wifi.p2p.WifiP2pPairingBootstrappingConfig;
 import android.net.wifi.p2p.WifiP2pProvDiscEvent;
 import android.net.wifi.p2p.WifiP2pWfdInfo;
 import android.net.wifi.p2p.nsd.WifiP2pServiceResponse;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceResponse;
 import android.net.wifi.util.Environment;
 import android.text.TextUtils;
 import android.util.Log;
 
+import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.HexDump;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.util.HalAidlUtil;
@@ -116,7 +122,7 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
             byte[] wfdDeviceInfo) {
         handleDeviceFound(srcAddress, p2pDeviceAddress, primaryDeviceType, deviceName,
                 configMethods, deviceCapabilities, groupCapabilities, wfdDeviceInfo,
-                null, null, null);
+                null, null, null, 0, null);
     }
 
     /**
@@ -536,7 +542,8 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
     public void onProvisionDiscoveryCompleted(byte[] p2pDeviceAddress, boolean isRequest,
             byte status, int configMethods, String generatedPin) {
         handleProvisionDiscoveryCompletedEvent(
-                p2pDeviceAddress, isRequest, status, configMethods, generatedPin, null, null);
+                p2pDeviceAddress, isRequest, status, configMethods, generatedPin, null, null,
+                0, null);
     }
 
     /**
@@ -549,10 +556,25 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
     public void onProvisionDiscoveryCompletedEvent(
             P2pProvisionDiscoveryCompletedEventParams provisionDiscoveryCompletedEventParams) {
         List<OuiKeyedData> vendorData = null;
+        int pairingBootstrappingMethod = 0;
+        String pairingPinorPassphrase = null;
         if (mServiceVersion >= 3 && provisionDiscoveryCompletedEventParams.vendorData != null) {
             vendorData = HalAidlUtil.halToFrameworkOuiKeyedDataList(
                     provisionDiscoveryCompletedEventParams.vendorData);
         }
+
+        if (mServiceVersion >= 4 && provisionDiscoveryCompletedEventParams
+                .pairingBootstrappingMethod != 0) {
+            pairingBootstrappingMethod = convertAidlPairingBootstrappingMethodsToFramework(
+                    provisionDiscoveryCompletedEventParams.pairingBootstrappingMethod);
+            if (pairingBootstrappingMethod == 0) {
+                Log.e(TAG, "Unsupported : aidl pairing bootstrapping Method"
+                        + provisionDiscoveryCompletedEventParams.pairingBootstrappingMethod);
+                return;
+            }
+            pairingPinorPassphrase = provisionDiscoveryCompletedEventParams.password;
+        }
+
         handleProvisionDiscoveryCompletedEvent(
                 provisionDiscoveryCompletedEventParams.p2pDeviceAddress,
                 provisionDiscoveryCompletedEventParams.isRequest,
@@ -560,7 +582,9 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
                 provisionDiscoveryCompletedEventParams.configMethods,
                 provisionDiscoveryCompletedEventParams.generatedPin,
                 provisionDiscoveryCompletedEventParams.groupInterfaceName,
-                vendorData);
+                vendorData,
+                pairingBootstrappingMethod,
+                pairingPinorPassphrase);
     }
 
     private void handleProvisionDiscoveryCompletedEvent(
@@ -570,7 +594,9 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
             int configMethods,
             String generatedPin,
             String groupIfName,
-            @Nullable List<OuiKeyedData> vendorData) {
+            @Nullable List<OuiKeyedData> vendorData,
+            int pairingBootstrappingMethod,
+            String pairingPinorPassphrase) {
         logd(
                 "Provision discovery "
                         + (isRequest ? "request" : "response")
@@ -579,26 +605,51 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
                         + " status: "
                         + status
                         + " groupIfName: "
-                        + (TextUtils.isEmpty(groupIfName) ? "null" : groupIfName));
-
-        WifiP2pProvDiscEvent event = new WifiP2pProvDiscEvent();
-        event.device = new WifiP2pDevice();
+                        + (TextUtils.isEmpty(groupIfName) ? "null" : groupIfName)
+                        + " pairingBootstrappingMethod: " + pairingBootstrappingMethod);
 
+        String deviceAddress;
         try {
-            event.device.deviceAddress = NativeUtil.macAddressFromByteArray(p2pDeviceAddress);
+            deviceAddress = NativeUtil.macAddressFromByteArray(p2pDeviceAddress);
         } catch (Exception e) {
             Log.e(TAG, "Could not decode MAC address.", e);
-            event.device.deviceAddress = null;
+            deviceAddress = null;
         }
 
-        if (status != P2pProvDiscStatusCode.SUCCESS) {
+        boolean isWfdR2 = pairingBootstrappingMethod != 0;
+        boolean isComebackMsg = isWfdR2 && status == P2pProvDiscStatusCode.INFO_UNAVAILABLE;
+        if (!isComebackMsg && status != P2pProvDiscStatusCode.SUCCESS) {
             Log.e(TAG, "Provision discovery failed, status code: " + status);
+            WifiP2pProvDiscEvent event = new WifiP2pProvDiscEvent();
+            event.device = new WifiP2pDevice();
+            event.device.deviceAddress = deviceAddress;
             mMonitor.broadcastP2pProvisionDiscoveryFailure(mInterface,
                     convertHalProvDiscStatusToFrameworkStatus(status), event);
             return;
         }
 
-        if (TextUtils.isEmpty(event.device.deviceAddress)) return;
+        if (TextUtils.isEmpty(deviceAddress)) return;
+
+        if (isWfdR2) {
+            handlePairingBootstrappingProvisionDiscoveryCompletedEvent(deviceAddress, isRequest,
+                    pairingBootstrappingMethod, pairingPinorPassphrase, vendorData, isComebackMsg);
+        } else {
+            handleWpsProvisionDiscoveryCompletedEvent(deviceAddress, isRequest, configMethods,
+                    generatedPin, vendorData);
+        }
+
+    }
+
+    private void handleWpsProvisionDiscoveryCompletedEvent(
+            String p2pDeviceAddress,
+            boolean isRequest,
+            int configMethods,
+            String generatedPin,
+            @Nullable List<OuiKeyedData> vendorData) {
+        WifiP2pProvDiscEvent event = new WifiP2pProvDiscEvent();
+        event.device = new WifiP2pDevice();
+
+        event.device.deviceAddress = p2pDeviceAddress;
 
         if (SdkLevel.isAtLeastV() && vendorData != null) {
             event.setVendorData(vendorData);
@@ -606,29 +657,110 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
 
         if ((configMethods & WpsConfigMethods.PUSHBUTTON) != 0) {
             if (isRequest) {
-                event.event = WifiP2pProvDiscEvent.PBC_REQ;
+                event.event = WifiP2pProvDiscEvent.WPS_PBC_REQ;
                 mMonitor.broadcastP2pProvisionDiscoveryPbcRequest(mInterface, event);
             } else {
-                event.event = WifiP2pProvDiscEvent.PBC_RSP;
+                event.event = WifiP2pProvDiscEvent.WPS_PBC_RSP;
                 mMonitor.broadcastP2pProvisionDiscoveryPbcResponse(mInterface, event);
             }
         } else if (!isRequest && (configMethods & WpsConfigMethods.KEYPAD) != 0) {
-            event.event = WifiP2pProvDiscEvent.SHOW_PIN;
-            event.pin = generatedPin;
+            event.event = WifiP2pProvDiscEvent.WPS_SHOW_PIN;
+            event.wpsPin = generatedPin;
             mMonitor.broadcastP2pProvisionDiscoveryShowPin(mInterface, event);
         } else if (!isRequest && (configMethods & WpsConfigMethods.DISPLAY) != 0) {
-            event.event = WifiP2pProvDiscEvent.ENTER_PIN;
-            event.pin = generatedPin;
+            event.event = WifiP2pProvDiscEvent.WPS_ENTER_PIN;
+            event.wpsPin = generatedPin;
             mMonitor.broadcastP2pProvisionDiscoveryEnterPin(mInterface, event);
         } else if (isRequest && (configMethods & WpsConfigMethods.DISPLAY) != 0) {
-            event.event = WifiP2pProvDiscEvent.SHOW_PIN;
-            event.pin = generatedPin;
+            event.event = WifiP2pProvDiscEvent.WPS_SHOW_PIN;
+            event.wpsPin = generatedPin;
             mMonitor.broadcastP2pProvisionDiscoveryShowPin(mInterface, event);
         } else if (isRequest && (configMethods & WpsConfigMethods.KEYPAD) != 0) {
-            event.event = WifiP2pProvDiscEvent.ENTER_PIN;
+            event.event = WifiP2pProvDiscEvent.WPS_ENTER_PIN;
             mMonitor.broadcastP2pProvisionDiscoveryEnterPin(mInterface, event);
         } else {
-            Log.e(TAG, "Unsupported config methods: " + configMethods);
+            Log.e(TAG, "Unsupported WPS config methods: " + configMethods);
+        }
+    }
+
+    private void handlePairingBootstrappingProvisionDiscoveryCompletedEvent(
+            String p2pDeviceAddress,
+            boolean isRequest,
+            int pairingBootstrappingMethod,
+            String pairingPasswordOrPin,
+            @Nullable List<OuiKeyedData> vendorData,
+            boolean isComebackMsg) {
+        WifiP2pProvDiscEvent event = new WifiP2pProvDiscEvent();
+        event.device = new WifiP2pDevice();
+
+        event.device.deviceAddress = p2pDeviceAddress;
+        event.isComeback = isComebackMsg;
+
+        if (SdkLevel.isAtLeastV() && vendorData != null) {
+            event.setVendorData(vendorData);
+        }
+
+        if (pairingBootstrappingMethod
+                == WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC) {
+            if (isRequest) {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ;
+                mMonitor.broadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticRequest(
+                        mInterface, event);
+            } else {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP;
+                mMonitor.broadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticResponse(
+                        mInterface, event);
+            }
+        } else if (pairingBootstrappingMethod
+                == WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE) {
+            if (isRequest) {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PIN;
+                mMonitor.broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(
+                        mInterface, event);
+            } else {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN;
+                mMonitor.broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(
+                        mInterface, event);
+            }
+        } else if (pairingBootstrappingMethod
+                == WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE) {
+            if (isRequest) {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE;
+                mMonitor.broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(
+                        mInterface, event);
+            } else {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE;
+                mMonitor.broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(
+                        mInterface, event);
+            }
+        } else if (pairingBootstrappingMethod
+                == WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE) {
+            if (isRequest) {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN;
+                mMonitor.broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(
+                        mInterface, event);
+            } else {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PIN;
+                mMonitor.broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(
+                        mInterface, event);
+            }
+        }  else if (pairingBootstrappingMethod
+                == WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE) {
+            if (isRequest) {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE;
+                mMonitor.broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(
+                        mInterface, event);
+            } else {
+                event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE;
+                mMonitor.broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(
+                        mInterface, event);
+            }
+        } else {
+            Log.e(TAG, "Unsupported bootstrapping method: " + pairingBootstrappingMethod);
         }
     }
 
@@ -662,10 +794,26 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
      *
      * @param params Parameters associated with the USD based service discovery result.
      */
+    @SuppressLint("NewApi")
     @Override
     public void onUsdBasedServiceDiscoveryResult(P2pUsdBasedServiceDiscoveryResultParams params) {
         logd("Usd based service discovery result received on " + mInterface);
-        // TODO implementation
+        if (Environment.isSdkAtLeastB() && wifiDirectR2()) {
+            WifiP2pUsdBasedServiceResponse usdBasedServiceResponse =
+                    new WifiP2pUsdBasedServiceResponse(params.serviceProtocolType,
+                            params.serviceSpecificInfo);
+            WifiP2pDevice dev = new WifiP2pDevice();
+            try {
+                dev.deviceAddress = NativeUtil.macAddressFromByteArray(params.peerMacAddress);
+            } catch (Exception e) {
+                Log.e(TAG, "Could not decode device address.", e);
+                return;
+            }
+            List<WifiP2pServiceResponse> respList = new ArrayList<>();
+            respList.add(
+                    new WifiP2pServiceResponse(dev, usdBasedServiceResponse, params.sessionId));
+            mMonitor.broadcastP2pServiceDiscoveryResponse(mInterface, respList);
+        }
     }
 
     /**
@@ -677,7 +825,7 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
     @Override
     public void onUsdBasedServiceDiscoveryTerminated(int sessionId, int reasonCode) {
         logd("Usd based service discovery terminated on " + mInterface);
-        // TODO implementation
+        mMonitor.broadcastUsdBasedServiceDiscoveryTerminated(mInterface, sessionId, reasonCode);
     }
 
     /**
@@ -689,7 +837,8 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
     @Override
     public void onUsdBasedServiceAdvertisementTerminated(int sessionId, int reasonCode) {
         logd("Usd based service advertisement terminated on " + mInterface);
-        // TODO implementation
+        mMonitor.broadcastUsdBasedServiceAdvertisementTerminated(mInterface, sessionId,
+                reasonCode);
     }
 
     private WifiP2pDevice createStaEventDevice(byte[] interfaceAddress, byte[] p2pDeviceAddress,
@@ -922,7 +1071,7 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
             byte[] wfdR2DeviceInfo, byte[] vendorElemBytes) {
         handleDeviceFound(srcAddress, p2pDeviceAddress, primaryDeviceType, deviceName,
                 configMethods, deviceCapabilities, groupCapabilities, wfdDeviceInfo,
-                wfdR2DeviceInfo, vendorElemBytes, null);
+                wfdR2DeviceInfo, vendorElemBytes, null, 0, null);
     }
 
     /**
@@ -930,13 +1079,34 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
      *
      * @param deviceFoundEventParams Parameters associated with the device found event.
      */
+    @SuppressLint("NewApi")
     @Override
     public void onDeviceFoundWithParams(P2pDeviceFoundEventParams deviceFoundEventParams) {
         List<OuiKeyedData> vendorData = null;
+        int pairingBootstrappingMethods = 0;
+        WifiP2pDirInfo dirInfo = null;
+
         if (mServiceVersion >= 3 && deviceFoundEventParams.vendorData != null) {
             vendorData = HalAidlUtil.halToFrameworkOuiKeyedDataList(
                     deviceFoundEventParams.vendorData);
         }
+
+        if (mServiceVersion >= 4 && Environment.isSdkAtLeastB() && wifiDirectR2()) {
+            pairingBootstrappingMethods = convertAidlPairingBootstrappingMethodsToFramework(
+                    deviceFoundEventParams.pairingBootstrappingMethods);
+            if (deviceFoundEventParams.dirInfo != null) {
+                try {
+                    dirInfo = new WifiP2pDirInfo(MacAddress.fromBytes(
+                            deviceFoundEventParams.dirInfo.deviceInterfaceMacAddress),
+                            deviceFoundEventParams.dirInfo.nonce,
+                            deviceFoundEventParams.dirInfo.dirTag);
+                } catch (IllegalArgumentException e) {
+                    Log.e(TAG, "Could not decode MAC Address from DirInfo ", e);
+                    dirInfo = null;
+                }
+            }
+        }
+
         handleDeviceFound(
                 deviceFoundEventParams.srcAddress,
                 deviceFoundEventParams.p2pDeviceAddress,
@@ -948,14 +1118,39 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
                 deviceFoundEventParams.wfdDeviceInfo,
                 deviceFoundEventParams.wfdR2DeviceInfo,
                 deviceFoundEventParams.vendorElemBytes,
-                vendorData);
+                vendorData, pairingBootstrappingMethods, dirInfo);
     }
 
+    /*
+     * Prepare broadcast message that a P2P device has been found.
+     *
+     * @param srcAddress MAC address of the device found. This must either
+     *        be the P2P device address or the P2P interface address.
+     * @param p2pDeviceAddress P2P device address.
+     * @param primaryDeviceType Type of device. Refer to section B.1 of Wifi P2P
+     *        Technical specification v1.2.
+     * @param deviceName Name of the device.
+     * @param configMethods Mask of WPS configuration methods supported by the
+     *        device.
+     * @param deviceCapabilities Refer to section 4.1.4 of Wifi P2P Technical
+     *        specification v1.2.
+     * @param groupCapabilities Refer to section 4.1.4 of Wifi P2P Technical
+     *        specification v1.2.
+     * @param wfdDeviceInfo WFD device info as described in section 5.1.2 of WFD
+     *        technical specification v1.0.0.
+     * @param wfdR2DeviceInfo WFD R2 device info as described in section 5.1.12 of WFD
+     *        technical specification v2.1.
+     * @param vendorElemBytes vendor-specific information elements.
+     * @param vendorData vendor-specific data.
+     * @param pairingBootstrappingMethods Supported pairing bootstrapping methods.
+     * @param dirInfo Pairing DIR information.
+     */
     private void handleDeviceFound(byte[] srcAddress, byte[] p2pDeviceAddress,
             byte[] primaryDeviceType, String deviceName, int configMethods,
             byte deviceCapabilities, int groupCapabilities, byte[] wfdDeviceInfo,
             @Nullable byte[] wfdR2DeviceInfo, @Nullable byte[] vendorElemBytes,
-            @Nullable List<OuiKeyedData> vendorData) {
+            @Nullable List<OuiKeyedData> vendorData,
+            int pairingBootstrappingMethods, @Nullable WifiP2pDirInfo dirInfo) {
         WifiP2pDevice device = new WifiP2pDevice();
         device.deviceName = deviceName;
         if (deviceName == null) {
@@ -970,11 +1165,17 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
             return;
         }
 
-        try {
-            device.primaryDeviceType = NativeUtil.wpsDevTypeStringFromByteArray(primaryDeviceType);
-        } catch (Exception e) {
-            Log.e(TAG, "Could not encode device primary type.", e);
-            return;
+        // Device Type is present only in WFD R1 device discovery. So in case of USD based
+        // discovery where pairing bootstrapping method is advertised, skip checking the
+        // Device type.
+        if (pairingBootstrappingMethods == 0) {
+            try {
+                device.primaryDeviceType = NativeUtil.wpsDevTypeStringFromByteArray(
+                        primaryDeviceType);
+            } catch (Exception e) {
+                Log.e(TAG, "Could not encode device primary type.", e);
+                return;
+            }
         }
 
         device.deviceCapability = deviceCapabilities;
@@ -1020,6 +1221,12 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
             device.setVendorData(vendorData);
         }
 
+
+        if (Environment.isSdkAtLeastB()) {
+            device.setPairingBootStrappingMethods(pairingBootstrappingMethods);
+            device.dirInfo = dirInfo;
+        }
+
         logd("Device discovered on " + mInterface + ": " + device);
         mMonitor.broadcastP2pDeviceFound(mInterface, device);
     }
@@ -1080,6 +1287,41 @@ public class SupplicantP2pIfaceCallbackAidlImpl extends ISupplicantP2pIfaceCallb
         return result;
     }
 
+    @VisibleForTesting
+    private static int convertAidlPairingBootstrappingMethodsToFramework(
+            int aidlPairingBootstrappingMethods) {
+        int pairingBootstrappingMethods = 0;
+
+        if ((aidlPairingBootstrappingMethods
+                & P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OPPORTUNISTIC) != 0) {
+            pairingBootstrappingMethods |= WifiP2pPairingBootstrappingConfig
+                    .PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC;
+        }
+        if ((aidlPairingBootstrappingMethods
+                & P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PINCODE) != 0) {
+            pairingBootstrappingMethods |= WifiP2pPairingBootstrappingConfig
+                    .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE;
+        }
+        if ((aidlPairingBootstrappingMethods
+                & P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PASSPHRASE) != 0) {
+            pairingBootstrappingMethods |= WifiP2pPairingBootstrappingConfig
+                    .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE;
+        }
+        if ((aidlPairingBootstrappingMethods
+                & P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PINCODE) != 0) {
+            pairingBootstrappingMethods |= WifiP2pPairingBootstrappingConfig
+                    .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE;
+        }
+        if ((aidlPairingBootstrappingMethods
+                & P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PASSPHRASE) != 0) {
+            pairingBootstrappingMethods |= WifiP2pPairingBootstrappingConfig
+                    .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE;
+        }
+
+        return pairingBootstrappingMethods;
+
+    }
+
     @Override
     public String getInterfaceHash() {
         return ISupplicantP2pIfaceCallback.HASH;
diff --git a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackHidlImpl.java b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackHidlImpl.java
index 0cb0cd2354..3deee61d61 100644
--- a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackHidlImpl.java
+++ b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackHidlImpl.java
@@ -438,26 +438,26 @@ public class SupplicantP2pIfaceCallbackHidlImpl extends ISupplicantP2pIfaceCallb
 
         if ((configMethods & WpsConfigMethods.PUSHBUTTON) != 0) {
             if (isRequest) {
-                event.event = WifiP2pProvDiscEvent.PBC_REQ;
+                event.event = WifiP2pProvDiscEvent.WPS_PBC_REQ;
                 mMonitor.broadcastP2pProvisionDiscoveryPbcRequest(mInterface, event);
             } else {
-                event.event = WifiP2pProvDiscEvent.PBC_RSP;
+                event.event = WifiP2pProvDiscEvent.WPS_PBC_RSP;
                 mMonitor.broadcastP2pProvisionDiscoveryPbcResponse(mInterface, event);
             }
         } else if (!isRequest && (configMethods & WpsConfigMethods.KEYPAD) != 0) {
-            event.event = WifiP2pProvDiscEvent.SHOW_PIN;
-            event.pin = generatedPin;
+            event.event = WifiP2pProvDiscEvent.WPS_SHOW_PIN;
+            event.wpsPin = generatedPin;
             mMonitor.broadcastP2pProvisionDiscoveryShowPin(mInterface, event);
         } else if (!isRequest && (configMethods & WpsConfigMethods.DISPLAY) != 0) {
-            event.event = WifiP2pProvDiscEvent.ENTER_PIN;
-            event.pin = generatedPin;
+            event.event = WifiP2pProvDiscEvent.WPS_ENTER_PIN;
+            event.wpsPin = generatedPin;
             mMonitor.broadcastP2pProvisionDiscoveryEnterPin(mInterface, event);
         } else if (isRequest && (configMethods & WpsConfigMethods.DISPLAY) != 0) {
-            event.event = WifiP2pProvDiscEvent.SHOW_PIN;
-            event.pin = generatedPin;
+            event.event = WifiP2pProvDiscEvent.WPS_SHOW_PIN;
+            event.wpsPin = generatedPin;
             mMonitor.broadcastP2pProvisionDiscoveryShowPin(mInterface, event);
         } else if (isRequest && (configMethods & WpsConfigMethods.KEYPAD) != 0) {
-            event.event = WifiP2pProvDiscEvent.ENTER_PIN;
+            event.event = WifiP2pProvDiscEvent.WPS_ENTER_PIN;
             mMonitor.broadcastP2pProvisionDiscoveryEnterPin(mInterface, event);
         } else {
             Log.e(TAG, "Unsupported config methods: " + configMethods);
diff --git a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHal.java b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHal.java
index 149a0ecb4f..5cc2ecbf8f 100644
--- a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHal.java
+++ b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHal.java
@@ -21,12 +21,16 @@ import android.annotation.Nullable;
 import android.net.wifi.CoexUnsafeChannel;
 import android.net.wifi.ScanResult;
 import android.net.wifi.p2p.WifiP2pConfig;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pDiscoveryConfig;
 import android.net.wifi.p2p.WifiP2pExtListenParams;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
 import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
@@ -503,18 +507,20 @@ public class SupplicantP2pIfaceHal {
     /**
      * Reinvoke a device from a persistent group.
      *
-     * @param networkId Used to specify the persistent group.
+     * @param networkId Used to specify the persistent group (valid only for P2P V1 group).
      * @param peerAddress MAC address of the device to reinvoke.
+     * @param dikId The identifier of device identity key of the device to reinvoke.
+     *              (valid only for P2P V2 group).
      *
      * @return true, if operation was successful.
      */
-    public boolean reinvoke(int networkId, String peerAddress) {
+    public boolean reinvoke(int networkId, String peerAddress, int dikId) {
         synchronized (mLock) {
             String methodStr = "reinvoke";
             if (mP2pIfaceHal == null) {
                 return handleNullHal(methodStr);
             }
-            return mP2pIfaceHal.reinvoke(networkId, peerAddress);
+            return mP2pIfaceHal.reinvoke(networkId, peerAddress, dikId);
         }
     }
 
@@ -525,16 +531,17 @@ public class SupplicantP2pIfaceHal {
      *
      * @param networkId Used to specify the restart of a persistent group.
      * @param isPersistent Used to request a persistent group to be formed.
+     * @param isP2pV2 Used to start a Group Owner that support P2P2 IE.
      *
      * @return true, if operation was successful.
      */
-    public boolean groupAdd(int networkId, boolean isPersistent) {
+    public boolean groupAdd(int networkId, boolean isPersistent, boolean isP2pV2) {
         synchronized (mLock) {
             String methodStr = "groupAdd";
             if (mP2pIfaceHal == null) {
                 return handleNullHal(methodStr);
             }
-            return mP2pIfaceHal.groupAdd(networkId, isPersistent);
+            return mP2pIfaceHal.groupAdd(networkId, isPersistent, isP2pV2);
         }
     }
 
@@ -543,13 +550,14 @@ public class SupplicantP2pIfaceHal {
      * This is a helper method that invokes groupAdd(networkId, isPersistent) internally.
      *
      * @param isPersistent Used to request a persistent group to be formed.
+     * @param isP2pV2 Used to start a Group Owner that support P2P2 IE.
      *
      * @return true, if operation was successful.
      */
-    public boolean groupAdd(boolean isPersistent) {
+    public boolean groupAdd(boolean isPersistent, boolean isP2pV2) {
         synchronized (mLock) {
             // Supplicant expects networkId to be -1 if not supplied.
-            return groupAdd(-1, isPersistent);
+            return groupAdd(-1, isPersistent, isP2pV2);
         }
     }
 
@@ -1161,6 +1169,139 @@ public class SupplicantP2pIfaceHal {
         }
     }
 
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param discoveryConfig is the configuration for this service discovery request.
+     * @param timeoutInSeconds is the maximum time to be spent for this service discovery request.
+     */
+    public int startUsdBasedServiceDiscovery(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedServiceDiscoveryConfig discoveryConfig, int timeoutInSeconds) {
+        synchronized (mLock) {
+            String methodStr = "startUsdBasedServiceDiscovery";
+            if (mP2pIfaceHal == null) {
+                handleNullHal(methodStr);
+                return -1;
+            }
+            return mP2pIfaceHal.startUsdBasedServiceDiscovery(usdServiceConfig, discoveryConfig,
+                    timeoutInSeconds);
+        }
+    }
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param sessionId Identifier to cancel the service discovery instance.
+     *        Use zero to cancel all the service discovery instances.
+     */
+    public void stopUsdBasedServiceDiscovery(int sessionId) {
+        synchronized (mLock) {
+            String methodStr = "stopUsdBasedServiceDiscovery";
+            if (mP2pIfaceHal == null) {
+                handleNullHal(methodStr);
+                return;
+            }
+            mP2pIfaceHal.stopUsdBasedServiceDiscovery(sessionId);
+        }
+    }
+
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param advertisementConfig is the configuration for this service advertisement.
+     * @param timeoutInSeconds is the maximum time to be spent for this service advertisement.
+     */
+    public int startUsdBasedServiceAdvertisement(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedLocalServiceAdvertisementConfig advertisementConfig,
+            int timeoutInSeconds) {
+        synchronized (mLock) {
+            String methodStr = "startUsdBasedServiceAdvertisement";
+            if (mP2pIfaceHal == null) {
+                handleNullHal(methodStr);
+                return -1;
+            }
+            return mP2pIfaceHal.startUsdBasedServiceAdvertisement(usdServiceConfig,
+                    advertisementConfig, timeoutInSeconds);
+        }
+    }
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param sessionId Identifier to cancel the service advertisement.
+     *        Use zero to cancel all the service advertisement instances.
+     */
+    public void stopUsdBasedServiceAdvertisement(int sessionId) {
+        synchronized (mLock) {
+            String methodStr = "stopUsdBasedServiceAdvertisement";
+            if (mP2pIfaceHal == null) {
+                handleNullHal(methodStr);
+                return;
+            }
+            mP2pIfaceHal.stopUsdBasedServiceAdvertisement(sessionId);
+        }
+    }
+
+    /**
+     * Get the Device Identity Resolution (DIR) Information.
+     * See {@link WifiP2pDirInfo} for details
+     *
+     * @return {@link WifiP2pDirInfo} instance on success, null on failure.
+     */
+    public WifiP2pDirInfo getDirInfo() {
+        synchronized (mLock) {
+            String methodStr = "getDirInfo";
+            if (mP2pIfaceHal == null) {
+                handleNullHal(methodStr);
+                return null;
+            }
+            return mP2pIfaceHal.getDirInfo();
+        }
+    }
+
+    /**
+     * Validate the Device Identity Resolution (DIR) Information of a P2P device.
+     * See {@link WifiP2pDirInfo} for details.
+     *
+     * @param dirInfo {@link WifiP2pDirInfo} to validate.
+     * @return The identifier of device identity key on success, -1 on failure.
+     */
+    public int validateDirInfo(@NonNull WifiP2pDirInfo dirInfo) {
+        synchronized (mLock) {
+            String methodStr = "validateDirInfo";
+            if (mP2pIfaceHal == null) {
+                handleNullHal(methodStr);
+                return -1;
+            }
+            return mP2pIfaceHal.validateDirInfo(dirInfo);
+        }
+    }
+
+    /**
+     * Used to authorize a connection request to an existing Group Owner
+     * interface, to allow a peer device to connect.
+     *
+     * @param config Configuration to use for connection.
+     * @param groupOwnerInterfaceName Group Owner interface name on which the request to connect
+     *                           needs to be authorized.
+     *
+     * @return boolean value indicating whether operation was successful.
+     */
+    public boolean authorizeConnectRequestOnGroupOwner(
+            WifiP2pConfig config, String groupOwnerInterfaceName) {
+        synchronized (mLock) {
+            String methodStr = "connect";
+            if (mP2pIfaceHal == null) {
+                handleNullHal(methodStr);
+                return false;
+            }
+            return mP2pIfaceHal.authorizeConnectRequestOnGroupOwner(config,
+                    groupOwnerInterfaceName);
+        }
+    }
+
     /**
      * Terminate the supplicant daemon & wait for its death.
      */
diff --git a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHalAidlImpl.java b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHalAidlImpl.java
index 565893ed66..5e2135a699 100644
--- a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHalAidlImpl.java
+++ b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHalAidlImpl.java
@@ -21,6 +21,8 @@ import static android.net.wifi.p2p.WifiP2pManager.FEATURE_WIFI_DIRECT_R2;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.SuppressLint;
+import android.hardware.wifi.supplicant.BandMask;
 import android.hardware.wifi.supplicant.DebugLevel;
 import android.hardware.wifi.supplicant.FreqRange;
 import android.hardware.wifi.supplicant.ISupplicant;
@@ -33,23 +35,38 @@ import android.hardware.wifi.supplicant.KeyMgmtMask;
 import android.hardware.wifi.supplicant.MiracastMode;
 import android.hardware.wifi.supplicant.P2pAddGroupConfigurationParams;
 import android.hardware.wifi.supplicant.P2pConnectInfo;
+import android.hardware.wifi.supplicant.P2pCreateGroupOwnerInfo;
+import android.hardware.wifi.supplicant.P2pDirInfo;
 import android.hardware.wifi.supplicant.P2pDiscoveryInfo;
 import android.hardware.wifi.supplicant.P2pExtListenInfo;
 import android.hardware.wifi.supplicant.P2pFrameTypeMask;
+import android.hardware.wifi.supplicant.P2pPairingBootstrappingMethodMask;
+import android.hardware.wifi.supplicant.P2pProvisionDiscoveryParams;
+import android.hardware.wifi.supplicant.P2pReinvokePersistentGroupParams;
 import android.hardware.wifi.supplicant.P2pScanType;
+import android.hardware.wifi.supplicant.P2pUsdBasedServiceAdvertisementConfig;
+import android.hardware.wifi.supplicant.P2pUsdBasedServiceDiscoveryConfig;
 import android.hardware.wifi.supplicant.WpsConfigMethods;
 import android.hardware.wifi.supplicant.WpsProvisionMethod;
+import android.net.MacAddress;
 import android.net.wifi.CoexUnsafeChannel;
+import android.net.wifi.OuiKeyedData;
 import android.net.wifi.ScanResult;
 import android.net.wifi.WpsInfo;
 import android.net.wifi.p2p.WifiP2pConfig;
 import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pDiscoveryConfig;
 import android.net.wifi.p2p.WifiP2pExtListenParams;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pPairingBootstrappingConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
+import android.net.wifi.util.Environment;
 import android.os.IBinder;
 import android.os.IBinder.DeathRecipient;
 import android.os.RemoteException;
@@ -66,6 +83,7 @@ import com.android.server.wifi.WifiSettingsConfigStore;
 import com.android.server.wifi.util.ArrayUtils;
 import com.android.server.wifi.util.HalAidlUtil;
 import com.android.server.wifi.util.NativeUtil;
+import com.android.wifi.flags.Flags;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -811,23 +829,58 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
         }
     }
 
-    /**
-     * Start P2P group formation with a discovered P2P peer. This includes
-     * optional group owner negotiation, group interface setup, provisioning,
-     * and establishing data connection.
-     *
-     * @param config Configuration to use to connect to remote device.
-     * @param joinExistingGroup Indicates that this is a command to join an
-     *        existing group as a client. It skips the group owner negotiation
-     *        part. This must send a Provision Discovery Request message to the
-     *        target group owner before associating for WPS provisioning.
-     *
-     * @return String containing generated pin, if selected provision method
-     *        uses PIN.
-     */
-    public String connect(WifiP2pConfig config, boolean joinExistingGroup) {
+    private String connectWithParams(boolean joinExistingGroup, byte[] peerAddress,
+            int provisionMethod, String preSelectedPin, boolean persistent, int groupOwnerIntent,
+            @NonNull List<OuiKeyedData> vendorData, int pairingBootstrappingMethod,
+            String pairingPassword, int frequencyMHz, boolean authorize,
+            String groupInterfaceName) {
+        synchronized (mLock) {
+            String methodStr = "connectWithParams";
+
+            // Parameters should be pre-validated.
+            P2pConnectInfo info = new P2pConnectInfo();
+            info.joinExistingGroup = joinExistingGroup;
+            info.peerAddress = peerAddress;
+            info.provisionMethod = provisionMethod;
+            info.preSelectedPin = preSelectedPin;
+            info.persistent = persistent;
+            info.goIntent = groupOwnerIntent;
+
+            if (!vendorData.isEmpty()) {
+                info.vendorData = HalAidlUtil.frameworkToHalOuiKeyedDataList(vendorData);
+            }
+            if (getCachedServiceVersion() >= 4 && pairingBootstrappingMethod != 0) {
+                info.pairingBootstrappingMethod = pairingBootstrappingMethod;
+                info.password = pairingPassword;
+                info.frequencyMHz = frequencyMHz;
+                info.authorizeConnectionFromPeer = authorize;
+                info.groupInterfaceName = groupInterfaceName;
+            }
+
+
+            try {
+                return mISupplicantP2pIface.connectWithParams(info);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            }
+            return null;
+        }
+    }
+
+    @SuppressLint("NewApi")
+    private String connectInternal(WifiP2pConfig config, boolean joinExistingGroup,
+            String groupInterfaceName) {
         synchronized (mLock) {
-            String methodStr = "connect";
+            String methodStr = "connectInternal";
+            int provisionMethod = WpsProvisionMethod.NONE;
+            String preSelectedPin = "";
+            int pairingBootstrappingMethod = 0;
+            String pairingPassword = "";
+            int frequencyMHz = 0;
+            boolean authorize = false;
+            List<OuiKeyedData> vendorData = new ArrayList<>();
 
             if (!checkP2pIfaceAndLogFailure(methodStr)) {
                 return null;
@@ -840,9 +893,54 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
                 Log.e(TAG, "Could not parse null mac address.");
                 return null;
             }
-            if (config.wps.setup == WpsInfo.PBC && !TextUtils.isEmpty(config.wps.pin)) {
-                Log.e(TAG, "Expected empty pin for PBC.");
-                return null;
+
+            if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()
+                    && config.getPairingBootstrappingConfig() != null) {
+                pairingBootstrappingMethod = convertPairingBootstrappingMethodToAidl(
+                        config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+                if (pairingBootstrappingMethod == RESULT_NOT_VALID) {
+                    Log.e(TAG, "Unrecognized pairing bootstrapping method: "
+                            + config.getPairingBootstrappingConfig()
+                            .getPairingBootstrappingMethod());
+                    return null;
+                }
+                pairingPassword = config.getPairingBootstrappingConfig()
+                        .getPairingBootstrappingPassword();
+                // All other pairing bootstrapping methods other than opportunistic method requires
+                // a pairing pin/password.
+                if (pairingBootstrappingMethod == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC) {
+                    if (!TextUtils.isEmpty(
+                            pairingPassword)) {
+                        Log.e(TAG, "Expected empty Pin/Password for opportunistic"
+                                + "bootstrapping");
+                        return null;
+                    }
+                } else { // Non-opportunistic methods
+                    if (TextUtils.isEmpty(pairingPassword)) {
+                        Log.e(TAG, "Pin/Password is not set for AIDL bootstrapping method: "
+                                + pairingBootstrappingMethod);
+                        return null;
+                    }
+                }
+                // WifiP2pConfig Builder treat it as frequency.
+                if (config.groupOwnerBand != 0 && config.groupOwnerBand != 2
+                        && config.groupOwnerBand != 5 && config.groupOwnerBand != 6) {
+                    frequencyMHz = config.groupOwnerBand;
+                }
+                authorize = config.isAuthorizeConnectionFromPeerEnabled();
+            } else {
+                if (config.wps.setup == WpsInfo.PBC && !TextUtils.isEmpty(config.wps.pin)) {
+                    Log.e(TAG, "Expected empty pin for PBC.");
+                    return null;
+                }
+                provisionMethod = wpsInfoToConfigMethod(config.wps.setup);
+                if (provisionMethod == RESULT_NOT_VALID) {
+                    Log.e(TAG, "Invalid WPS config method: " + config.wps.setup);
+                    return null;
+                }
+                // NOTE: preSelectedPin cannot be null, otherwise hal would crash.
+                preSelectedPin = TextUtils.isEmpty(config.wps.pin) ? "" : config.wps.pin;
             }
 
             byte[] peerAddress = null;
@@ -853,13 +951,6 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
                 return null;
             }
 
-            int provisionMethod = wpsInfoToConfigMethod(config.wps.setup);
-            if (provisionMethod == RESULT_NOT_VALID) {
-                Log.e(TAG, "Invalid WPS config method: " + config.wps.setup);
-                return null;
-            }
-            // NOTE: preSelectedPin cannot be null, otherwise hal would crash.
-            String preSelectedPin = TextUtils.isEmpty(config.wps.pin) ? "" : config.wps.pin;
             boolean persistent = (config.netId == WifiP2pGroup.NETWORK_ID_PERSISTENT);
 
             if (config.groupOwnerIntent < 0 || config.groupOwnerIntent > 15) {
@@ -868,8 +959,14 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
             }
 
             if (getCachedServiceVersion() >= 3) {
+                if (SdkLevel.isAtLeastV() && config.getVendorData() != null
+                        && !config.getVendorData().isEmpty()) {
+                    vendorData = config.getVendorData();
+                }
                 return connectWithParams(joinExistingGroup, peerAddress, provisionMethod,
-                        preSelectedPin, persistent, config.groupOwnerIntent, config);
+                        preSelectedPin, persistent, config.groupOwnerIntent, vendorData,
+                        pairingBootstrappingMethod, pairingPassword, frequencyMHz, authorize,
+                        groupInterfaceName);
             }
 
             try {
@@ -885,6 +982,43 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
         }
     }
 
+    /**
+     * Used to authorize a connection request to an existing Group Owner
+     * interface, to allow a peer device to connect.
+     *
+     * @param config Configuration to use for connection.
+     * @param groupOwnerInterfaceName Group Owner interface name on which the request to connect
+     *                           needs to be authorized.
+     *
+     * @return boolean value indicating whether operation was successful.
+     */
+    public boolean authorizeConnectRequestOnGroupOwner(
+            WifiP2pConfig config, String groupOwnerInterfaceName) {
+        if (TextUtils.isEmpty(groupOwnerInterfaceName)) {
+            Log.e(TAG, "authorizeConnectRequestOnGroupOwner: group owner interface is null");
+            return false;
+        }
+        return connectInternal(config, false, groupOwnerInterfaceName) != null;
+    }
+
+    /**
+     * Start P2P group formation with a discovered P2P peer. This includes
+     * optional group owner negotiation, group interface setup, provisioning,
+     * and establishing data connection.
+     *
+     * @param config Configuration to use to connect to remote device.
+     * @param joinExistingGroup Indicates that this is a command to join an
+     *        existing group as a client. It skips the group owner negotiation
+     *        part. This must send a Provision Discovery Request message to the
+     *        target group owner before associating for WPS provisioning.
+     *
+     * @return String containing generated pin, if selected provision method
+     *        uses PIN.
+     */
+    public String connect(WifiP2pConfig config, boolean joinExistingGroup) {
+        return connectInternal(config, joinExistingGroup, null);
+    }
+
     /**
      * Cancel an ongoing P2P group formation and joining-a-group related
      * operation. This operation unauthorizes the specific peer device (if any
@@ -923,9 +1057,12 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
      *
      * @return boolean value indicating whether operation was successful.
      */
+    @SuppressLint("NewApi")
     public boolean provisionDiscovery(WifiP2pConfig config) {
         synchronized (mLock) {
             String methodStr = "provisionDiscovery";
+            int pairingBootstrappingMethod = 0;
+            int targetWpsMethod = 0;
             if (!checkP2pIfaceAndLogFailure("provisionDiscovery")) {
                 return false;
             }
@@ -933,17 +1070,36 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
                 return false;
             }
 
-            int targetMethod = wpsInfoToConfigMethod(config.wps.setup);
-            if (targetMethod == RESULT_NOT_VALID) {
-                Log.e(TAG, "Unrecognized WPS configuration method: " + config.wps.setup);
-                return false;
-            }
-            if (targetMethod == WpsProvisionMethod.DISPLAY) {
-                // We are doing display, so provision discovery is keypad.
-                targetMethod = WpsProvisionMethod.KEYPAD;
-            } else if (targetMethod == WpsProvisionMethod.KEYPAD) {
-                // We are doing keypad, so provision discovery is display.
-                targetMethod = WpsProvisionMethod.DISPLAY;
+            if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()
+                    && config.getPairingBootstrappingConfig() != null) {
+                pairingBootstrappingMethod = convertPairingBootstrappingMethodToAidl(
+                        config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+                if (pairingBootstrappingMethod == RESULT_NOT_VALID) {
+                    Log.e(TAG, "Unrecognized pairing bootstrapping method: "
+                            + config.getPairingBootstrappingConfig()
+                            .getPairingBootstrappingMethod());
+                    return false;
+                }
+                if (pairingBootstrappingMethod
+                        == P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OUT_OF_BAND) {
+                    Log.e(TAG, "Provisioning phase is not required for Bootstrapping method"
+                            + " out of band! Fail");
+                    return false;
+                }
+                targetWpsMethod = WpsProvisionMethod.NONE;
+            } else {
+                targetWpsMethod = wpsInfoToConfigMethod(config.wps.setup);
+                if (targetWpsMethod == RESULT_NOT_VALID) {
+                    Log.e(TAG, "Unrecognized WPS configuration method: " + config.wps.setup);
+                    return false;
+                }
+                if (targetWpsMethod == WpsProvisionMethod.DISPLAY) {
+                    // We are doing display, so provision discovery is keypad.
+                    targetWpsMethod = WpsProvisionMethod.KEYPAD;
+                } else if (targetWpsMethod == WpsProvisionMethod.KEYPAD) {
+                    // We are doing keypad, so provision discovery is display.
+                    targetWpsMethod = WpsProvisionMethod.DISPLAY;
+                }
             }
 
             if (config.deviceAddress == null) {
@@ -958,8 +1114,13 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
                 return false;
             }
 
+            if (getCachedServiceVersion() >= 4) {
+                return provisionDiscoveryWithParams(macAddress, targetWpsMethod,
+                        pairingBootstrappingMethod);
+            }
+
             try {
-                mISupplicantP2pIface.provisionDiscovery(macAddress, targetMethod);
+                mISupplicantP2pIface.provisionDiscovery(macAddress, targetWpsMethod);
                 return true;
             } catch (RemoteException e) {
                 handleRemoteException(e, methodStr);
@@ -970,6 +1131,48 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
         }
     }
 
+    private boolean provisionDiscoveryWithParams(byte[] macAddress, int targetMethod,
+            int pairingBootstrappingMethod) {
+        String methodStr = "provisionDiscoveryWithParams";
+
+        // Expect that these parameters are already validated.
+        P2pProvisionDiscoveryParams params = new P2pProvisionDiscoveryParams();
+        params.peerMacAddress = macAddress;
+        params.provisionMethod = targetMethod;
+        params.pairingBootstrappingMethod = pairingBootstrappingMethod;
+        try {
+            mISupplicantP2pIface.provisionDiscoveryWithParams(params);
+            return true;
+        } catch (RemoteException e) {
+            handleRemoteException(e, methodStr);
+        } catch (ServiceSpecificException e) {
+            handleServiceSpecificException(e, methodStr);
+        }
+        return false;
+    }
+
+    @VisibleForTesting
+    protected static int convertPairingBootstrappingMethodToAidl(int pairingBootstrappingMethod) {
+        switch (pairingBootstrappingMethod) {
+            case WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC:
+                return P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OPPORTUNISTIC;
+            case WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE:
+                return P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PINCODE;
+            case WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE:
+                return P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PASSPHRASE;
+            case WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE:
+                return P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PINCODE;
+            case WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE:
+                return P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PASSPHRASE;
+            case WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_OUT_OF_BAND:
+                return P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OUT_OF_BAND;
+            default:
+                Log.e(TAG, "Unsupported pairingBootstrappingMethod: "
+                        + pairingBootstrappingMethod);
+                return RESULT_NOT_VALID;
+        }
+    }
+
     /**
      * Invite a device to a persistent group.
      * If the peer device is the group owner of the persistent group, the peer
@@ -1146,21 +1349,41 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
         }
     }
 
+    private boolean reinvokePersistentGroupWithParams(byte[] macAddress, int networkId,
+            int dikId) {
+        String methodStr = "reinvokePersistentGroupWithParams";
+        P2pReinvokePersistentGroupParams params = new P2pReinvokePersistentGroupParams();
+        params.peerMacAddress = macAddress;
+        params.persistentNetworkId = networkId;
+        params.deviceIdentityEntryId = dikId;
+        try {
+            mISupplicantP2pIface.reinvokePersistentGroup(params);
+            return true;
+        } catch (RemoteException e) {
+            handleRemoteException(e, methodStr);
+        } catch (ServiceSpecificException e) {
+            handleServiceSpecificException(e, methodStr);
+        }
+        return false;
+    }
+
     /**
      * Reinvoke a device from a persistent group.
      *
-     * @param networkId Used to specify the persistent group.
+     * @param networkId Used to specify the persistent group (valid only for P2P V1 group).
      * @param peerAddress MAC address of the device to reinvoke.
+     * @param dikId The identifier of device identity key of the device to reinvoke.
+     *              (valid only for P2P V2 group).
      *
      * @return true, if operation was successful.
      */
-    public boolean reinvoke(int networkId, String peerAddress) {
+    public boolean reinvoke(int networkId, String peerAddress, int dikId) {
         synchronized (mLock) {
             String methodStr = "reinvoke";
             if (!checkP2pIfaceAndLogFailure(methodStr)) {
                 return false;
             }
-            if (TextUtils.isEmpty(peerAddress) || networkId < 0) {
+            if (TextUtils.isEmpty(peerAddress) || (networkId < 0 && dikId < 0)) {
                 return false;
             }
             byte[] macAddress = null;
@@ -1171,6 +1394,11 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
                 return false;
             }
 
+            /* Call only for P2P V2 group now. TODO extend for V1 group in the future. */
+            if (getCachedServiceVersion() >= 4 && dikId >= 0) {
+                return reinvokePersistentGroupWithParams(macAddress, networkId, dikId);
+            }
+
             try {
                 mISupplicantP2pIface.reinvoke(networkId, macAddress);
                 return true;
@@ -1190,15 +1418,19 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
      *
      * @param networkId Used to specify the restart of a persistent group.
      * @param isPersistent Used to request a persistent group to be formed.
+     * @param isP2pV2 Used to start a Group Owner that support P2P2 IE
      *
      * @return true, if operation was successful.
      */
-    public boolean groupAdd(int networkId, boolean isPersistent) {
+    public boolean groupAdd(int networkId, boolean isPersistent, boolean isP2pV2) {
         synchronized (mLock) {
             String methodStr = "groupAdd";
             if (!checkP2pIfaceAndLogFailure(methodStr)) {
                 return false;
             }
+            if (getCachedServiceVersion() >= 4) {
+                return createGroupOwner(networkId, isPersistent, isP2pV2);
+            }
             try {
                 mISupplicantP2pIface.addGroup(isPersistent, networkId);
                 return true;
@@ -1211,6 +1443,26 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
         }
     }
 
+    private boolean createGroupOwner(int networkId, boolean isPersistent, boolean isP2pV2) {
+        String methodStr = "createGroupOwner";
+
+        // Expect that these parameters are already validated.
+        P2pCreateGroupOwnerInfo groupOwnerInfo =
+                new P2pCreateGroupOwnerInfo();
+        groupOwnerInfo.persistent = isPersistent;
+        groupOwnerInfo.persistentNetworkId = networkId;
+        groupOwnerInfo.isP2pV2 = isP2pV2;
+        try {
+            mISupplicantP2pIface.createGroupOwner(groupOwnerInfo);
+            return true;
+        } catch (RemoteException e) {
+            handleRemoteException(e, methodStr);
+        } catch (ServiceSpecificException e) {
+            handleServiceSpecificException(e, methodStr);
+        }
+        return false;
+    }
+
     /**
      * Set up a P2P group as Group Owner or join a group with a configuration.
      *
@@ -2719,6 +2971,229 @@ public class SupplicantP2pIfaceHalAidlImpl implements ISupplicantP2pIfaceHal {
         }
     }
 
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param discoveryConfig is the configuration for this service discovery request.
+     * @param timeoutInSeconds is the maximum time to be spent for this service discovery request.
+     */
+    @SuppressLint("NewApi")
+    public int startUsdBasedServiceDiscovery(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedServiceDiscoveryConfig discoveryConfig, int timeoutInSeconds) {
+        synchronized (mLock) {
+            String methodStr = "startUsdBasedServiceDiscovery";
+            if (!checkP2pIfaceAndLogFailure(methodStr)) {
+                return -1;
+            }
+            if (getCachedServiceVersion() < 4) {
+                return -1;
+            }
+            if (usdServiceConfig == null || discoveryConfig == null) {
+                return -1;
+            }
+            try {
+                P2pUsdBasedServiceDiscoveryConfig aidlUsdBasedServiceDiscoveryConfig =
+                        new P2pUsdBasedServiceDiscoveryConfig();
+                aidlUsdBasedServiceDiscoveryConfig.serviceName = usdServiceConfig.getServiceName();
+                aidlUsdBasedServiceDiscoveryConfig.serviceProtocolType = usdServiceConfig
+                        .getServiceProtocolType();
+                aidlUsdBasedServiceDiscoveryConfig.serviceSpecificInfo = usdServiceConfig
+                        .getServiceSpecificInfo();
+                if (discoveryConfig.getBand() != ScanResult.UNSPECIFIED) {
+                    aidlUsdBasedServiceDiscoveryConfig.bandMask =
+                            scanResultBandMaskToSupplicantHalWifiBandMask(
+                                    discoveryConfig.getBand());
+                } else {
+                    aidlUsdBasedServiceDiscoveryConfig.bandMask = 0;
+                }
+                aidlUsdBasedServiceDiscoveryConfig.frequencyListMhz = discoveryConfig
+                        .getFrequenciesMhz();
+                aidlUsdBasedServiceDiscoveryConfig.timeoutInSeconds = timeoutInSeconds;
+                return mISupplicantP2pIface.startUsdBasedServiceDiscovery(
+                        aidlUsdBasedServiceDiscoveryConfig);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            }
+            return -1;
+        }
+    }
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param sessionId Identifier to cancel the service discovery instance.
+     *        Use zero to cancel all the service discovery instances.
+     */
+    public void stopUsdBasedServiceDiscovery(int sessionId) {
+        synchronized (mLock) {
+            String methodStr = "stopUsdBasedServiceDiscovery";
+            if (!checkP2pIfaceAndLogFailure(methodStr)) {
+                return;
+            }
+            if (getCachedServiceVersion() < 4) {
+                return;
+            }
+            try {
+                mISupplicantP2pIface.stopUsdBasedServiceDiscovery(sessionId);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            }
+        }
+    }
+
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param advertisementConfig is the configuration for this service advertisement.
+     * @param timeoutInSeconds is the maximum time to be spent for this service advertisement.
+     */
+    @SuppressLint("NewApi")
+    public int startUsdBasedServiceAdvertisement(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedLocalServiceAdvertisementConfig advertisementConfig,
+            int timeoutInSeconds) {
+        synchronized (mLock) {
+            String methodStr = "startUsdBasedServiceAdvertisement";
+            if (!checkP2pIfaceAndLogFailure(methodStr)) {
+                return -1;
+            }
+            if (getCachedServiceVersion() < 4) {
+                return -1;
+            }
+            if (usdServiceConfig == null || advertisementConfig == null) {
+                return -1;
+            }
+            try {
+                P2pUsdBasedServiceAdvertisementConfig aidlServiceAdvertisementConfig =
+                        new P2pUsdBasedServiceAdvertisementConfig();
+                aidlServiceAdvertisementConfig.serviceName = usdServiceConfig.getServiceName();
+                aidlServiceAdvertisementConfig.serviceProtocolType = usdServiceConfig
+                        .getServiceProtocolType();
+                aidlServiceAdvertisementConfig.serviceSpecificInfo = usdServiceConfig
+                        .getServiceSpecificInfo();
+                aidlServiceAdvertisementConfig.frequencyMHz = advertisementConfig.getFrequencyMhz();
+                aidlServiceAdvertisementConfig.timeoutInSeconds = timeoutInSeconds;
+                return mISupplicantP2pIface.startUsdBasedServiceAdvertisement(
+                        aidlServiceAdvertisementConfig);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            }
+            return -1;
+        }
+    }
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param sessionId Identifier to cancel the service advertisement.
+     *        Use zero to cancel all the service advertisement instances.
+     */
+    public void stopUsdBasedServiceAdvertisement(int sessionId) {
+        synchronized (mLock) {
+            String methodStr = "stopUsdBasedServiceAdvertisement";
+            if (!checkP2pIfaceAndLogFailure(methodStr)) {
+                return;
+            }
+            if (getCachedServiceVersion() < 4) {
+                return;
+            }
+            try {
+                mISupplicantP2pIface.stopUsdBasedServiceAdvertisement(sessionId);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            }
+        }
+    }
+
+    private static int scanResultBandMaskToSupplicantHalWifiBandMask(int bandMask) {
+        int halBandMask = 0;
+        if ((bandMask & ScanResult.WIFI_BAND_24_GHZ) != 0) {
+            halBandMask |= BandMask.BAND_2_GHZ;
+        }
+        if ((bandMask & ScanResult.WIFI_BAND_5_GHZ) != 0) {
+            halBandMask |= BandMask.BAND_5_GHZ;
+        }
+        if ((bandMask & ScanResult.WIFI_BAND_6_GHZ) != 0) {
+            halBandMask |= BandMask.BAND_6_GHZ;
+        }
+        return halBandMask;
+    }
+
+    /**
+     * Get the Device Identity Resolution (DIR) Information.
+     * See {@link WifiP2pDirInfo} for details
+     *
+     * @return {@link WifiP2pDirInfo} instance on success, null on failure.
+     */
+    @SuppressLint("NewApi")
+    public WifiP2pDirInfo getDirInfo() {
+        synchronized (mLock) {
+            String methodStr = "getDirInfo";
+            if (!checkP2pIfaceAndLogFailure(methodStr)) {
+                return null;
+            }
+            if (getCachedServiceVersion() < 4) {
+                return null;
+            }
+            try {
+                P2pDirInfo aidlDirInfo = mISupplicantP2pIface.getDirInfo();
+                WifiP2pDirInfo dirInfo = new WifiP2pDirInfo(MacAddress.fromBytes(
+                        aidlDirInfo.deviceInterfaceMacAddress),
+                        aidlDirInfo.nonce, aidlDirInfo.dirTag);
+                return dirInfo;
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            } catch (IllegalArgumentException e) {
+                Log.e(TAG, "Could not decode MAC Address.", e);
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Validate the Device Identity Resolution (DIR) Information of a P2P device.
+     * See {@link WifiP2pDirInfo} for details.
+     *
+     * @param dirInfo {@link WifiP2pDirInfo} to validate.
+     * @return The identifier of device identity key on success, -1 on failure.
+     */
+    @SuppressLint("NewApi")
+    public int validateDirInfo(@NonNull WifiP2pDirInfo dirInfo) {
+        synchronized (mLock) {
+            String methodStr = "validateDirInfo";
+            if (!checkP2pIfaceAndLogFailure(methodStr)) {
+                return -1;
+            }
+            if (getCachedServiceVersion() < 4) {
+                return -1;
+            }
+            try {
+                P2pDirInfo aidlDirInfo = new P2pDirInfo();
+                aidlDirInfo.cipherVersion = P2pDirInfo.CipherVersion.DIRA_CIPHER_VERSION_128_BIT;
+                aidlDirInfo.deviceInterfaceMacAddress = dirInfo.getMacAddress().toByteArray();
+                aidlDirInfo.nonce = dirInfo.getNonce();
+                aidlDirInfo.dirTag = dirInfo.getDirTag();
+                return mISupplicantP2pIface.validateDirInfo(aidlDirInfo);
+            } catch (RemoteException e) {
+                handleRemoteException(e, methodStr);
+            } catch (ServiceSpecificException e) {
+                handleServiceSpecificException(e, methodStr);
+            }
+            return -1;
+        }
+    }
+
     private byte[] convertInformationElementSetToBytes(
             Set<ScanResult.InformationElement> ies) {
         try {
diff --git a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHalHidlImpl.java b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHalHidlImpl.java
index 2644bfbf15..55de17628b 100644
--- a/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHalHidlImpl.java
+++ b/service/java/com/android/server/wifi/p2p/SupplicantP2pIfaceHalHidlImpl.java
@@ -35,11 +35,15 @@ import android.net.wifi.ScanResult;
 import android.net.wifi.WpsInfo;
 import android.net.wifi.p2p.WifiP2pConfig;
 import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pExtListenParams;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
 import android.os.IHwBinder.DeathRecipient;
 import android.os.RemoteException;
 import android.text.TextUtils;
@@ -1296,13 +1300,19 @@ public class SupplicantP2pIfaceHalHidlImpl implements ISupplicantP2pIfaceHal {
     /**
      * Reinvoke a device from a persistent group.
      *
-     * @param networkId Used to specify the persistent group.
+     * @param networkId Used to specify the persistent group (valid only for P2P V1 group).
      * @param peerAddress MAC address of the device to reinvoke.
+     * @param dikId The identifier of device identity key of the device to reinvoke.
+     *              (valid only for P2P V2 group).
      *
      * @return true, if operation was successful.
      */
-    public boolean reinvoke(int networkId, String peerAddress) {
+    public boolean reinvoke(int networkId, String peerAddress, int dikId) {
         if (TextUtils.isEmpty(peerAddress) || networkId < 0) return false;
+        if (dikId >= 0) {
+            Log.e(TAG, "Reinvoke with dikId is not supported.");
+            return false;
+        }
         synchronized (mLock) {
             if (!checkSupplicantP2pIfaceAndLogFailure("reinvoke")) return false;
             if (peerAddress == null) {
@@ -1337,10 +1347,11 @@ public class SupplicantP2pIfaceHalHidlImpl implements ISupplicantP2pIfaceHal {
      *
      * @param networkId Used to specify the restart of a persistent group.
      * @param isPersistent Used to request a persistent group to be formed.
+     * @param isP2pV2 Used to start a Group Owner that support P2P2 IE
      *
      * @return true, if operation was successful.
      */
-    public boolean groupAdd(int networkId, boolean isPersistent) {
+    public boolean groupAdd(int networkId, boolean isPersistent, boolean isP2pV2) {
         synchronized (mLock) {
             if (!checkSupplicantP2pIfaceAndLogFailure("groupAdd")) return false;
             SupplicantResult<Void> result =
@@ -2645,6 +2656,92 @@ public class SupplicantP2pIfaceHalHidlImpl implements ISupplicantP2pIfaceHal {
         return false;
     }
 
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param discoveryConfig is the configuration for this service discovery request.
+     * @param timeoutInSeconds is the maximum time to be spent for this service discovery request.
+     */
+    public int startUsdBasedServiceDiscovery(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedServiceDiscoveryConfig discoveryConfig, int timeoutInSeconds) {
+        Log.d(TAG, "startUsdBasedServiceDiscovery() is not supported.");
+        return -1;
+    }
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param sessionId Identifier to cancel the service discovery instance.
+     *        Use zero to cancel all the service discovery instances.
+     */
+    public void stopUsdBasedServiceDiscovery(int sessionId) {
+        Log.d(TAG, "stopUsdBasedServiceDiscovery() is not supported.");
+    }
+
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param advertisementConfig is the configuration for this service advertisement.
+     * @param timeoutInSeconds is the maximum time to be spent for this service advertisement.
+     */
+    public int startUsdBasedServiceAdvertisement(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedLocalServiceAdvertisementConfig advertisementConfig,
+            int timeoutInSeconds) {
+        Log.d(TAG, "startUsdBasedServiceAdvertisement() is not supported.");
+        return -1;
+    }
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param sessionId Identifier to cancel the service advertisement.
+     *        Use zero to cancel all the service advertisement instances.
+     */
+    public void stopUsdBasedServiceAdvertisement(int sessionId) {
+        Log.d(TAG, "stopUsdBasedServiceAdvertisement() is not supported.");
+    }
+
+    /**
+     * Get the Device Identity Resolution (DIR) Information.
+     * See {@link WifiP2pDirInfo} for details
+     *
+     * @return {@link WifiP2pDirInfo} instance on success, null on failure.
+     */
+    public WifiP2pDirInfo getDirInfo() {
+        Log.d(TAG, "getDirInfo() is not supported.");
+        return null;
+    }
+
+    /**
+     * Validate the Device Identity Resolution (DIR) Information of a P2P device.
+     * See {@link WifiP2pDirInfo} for details.
+     *
+     * @param dirInfo {@link WifiP2pDirInfo} to validate.
+     * @return The identifier of device identity key on success, -1 on failure.
+     */
+    public int validateDirInfo(@NonNull WifiP2pDirInfo dirInfo) {
+        Log.d(TAG, "validateDirInfo() is not supported.");
+        return -1;
+    }
+
+    /**
+     * Used to authorize a connection request to an existing Group Owner
+     * interface, to allow a peer device to connect.
+     *
+     * @param config Configuration to use for connection.
+     * @param groupOwnerInterfaceName Group Owner interface name on which the request to connect
+     *                           needs to be authorized.
+     *
+     * @return boolean value indicating whether operation was successful.
+     */
+    public boolean authorizeConnectRequestOnGroupOwner(WifiP2pConfig config,
+            String groupOwnerInterfaceName) {
+        Log.d(TAG, "authorizeConnectRequestOnGroupOwner() is not supported.");
+        return false;
+    }
+
     /**
      * Converts the Wps config method string to the equivalent enum value.
      */
diff --git a/service/java/com/android/server/wifi/p2p/WifiP2pMonitor.java b/service/java/com/android/server/wifi/p2p/WifiP2pMonitor.java
index 0d1efd7791..d91ef121cd 100644
--- a/service/java/com/android/server/wifi/p2p/WifiP2pMonitor.java
+++ b/service/java/com/android/server/wifi/p2p/WifiP2pMonitor.java
@@ -80,6 +80,18 @@ public class WifiP2pMonitor {
     public static final int AP_STA_DISCONNECTED_EVENT            = BASE + 41;
     public static final int AP_STA_CONNECTED_EVENT               = BASE + 42;
 
+    /* USD service discovery events */
+    public static final int USD_BASED_SERVICE_DISCOVERY_TERMINATED_EVENT = BASE + 43;
+    public static final int USD_BASED_SERVICE_ADVERTISEMENT_TERMINATED_EVENT = BASE + 44;
+
+    /* Provision Discovery event with Pairing bootstrapping method */
+    public static final int P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT = BASE + 45;
+    public static final int P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT = BASE + 46;
+    public static final int P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT =
+            BASE + 47;
+    public static final int P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT =
+            BASE + 48;
+
     public static final int PROV_DISC_STATUS_SUCCESS             = 0;
     public static final int PROV_DISC_STATUS_TIMEOUT             = 1;
     public static final int PROV_DISC_STATUS_REJECTED            = 2;
@@ -438,6 +450,67 @@ public class WifiP2pMonitor {
         }
     }
 
+    /**
+     * Broadcast provision discovery request event with requested method opportunistic
+     * bootstrapping to all handlers registered for this event.
+     *
+     * @param iface Name of iface on which this occurred.
+     * @param event Provision discovery request event.
+     */
+    public void broadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticRequest(
+            String iface, WifiP2pProvDiscEvent event) {
+        if (event != null) {
+            sendMessage(iface, P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT,
+                    event);
+        }
+    }
+
+    /**
+     * Broadcast provision discovery response event with requested method opportunistic
+     * bootstrapping to all handlers registered for this event.
+     *
+     * @param iface Name of iface on which this occurred.
+     * @param event Provision discovery response event.
+     */
+    public void broadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticResponse(
+            String iface, WifiP2pProvDiscEvent event) {
+        if (event != null) {
+            sendMessage(iface, P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT,
+                    event);
+        }
+    }
+
+    /**
+     * Broadcast provision discovery event to enter pairing bootstrapping PIN (Keypad pin-code only
+     * method) or Pairing Passphrase (Keypad passphrase method) to all handlers registered for
+     * this event.
+     *
+     * @param iface Name of iface on which this occurred.
+     * @param event Provision discovery request event.
+     */
+    public void broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(String iface,
+            WifiP2pProvDiscEvent event) {
+        if (event != null) {
+            sendMessage(iface, P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                    event);
+        }
+    }
+
+    /**
+     * Broadcast provision discovery event to show pairing bootstrapping PIN (Display pin-code only
+     * method) or Passphrase (Display passphrase method) to all handlers registered for this event.
+     *
+     * @param iface Name of iface on which this occurred.
+     * @param event Provision discovery response event.
+     */
+    public void broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(String iface,
+            WifiP2pProvDiscEvent event) {
+        if (event != null) {
+            sendMessage(iface, P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                    event);
+        }
+    }
+
     /**
      * Broadcast P2P discovery failure event to all handlers registered for this event.
      *
@@ -488,4 +561,28 @@ public class WifiP2pMonitor {
     public void broadcastP2pFrequencyChanged(String iface,  int frequency) {
         sendMessage(iface, P2P_FREQUENCY_CHANGED_EVENT, frequency);
     }
+
+    /**
+     * Broadcast the termination of USD based service discovery.
+     *
+     * @param iface Name of iface on which this occurred.
+     * @param sessionId Identifier to identify the instance of a service discovery.
+     * @param reasonCode The reason for termination of service discovery.
+     */
+    public void broadcastUsdBasedServiceDiscoveryTerminated(@NonNull String iface,
+            int sessionId, int reasonCode) {
+        sendMessage(iface, USD_BASED_SERVICE_DISCOVERY_TERMINATED_EVENT, sessionId, reasonCode);
+    }
+
+    /**
+     * Broadcast the termination of USD based service advertisement.
+     *
+     * @param iface Name of iface on which this occurred.
+     * @param sessionId Identifier to identify the instance of a service advertisement.
+     * @param reasonCode The reason for termination of service advertisement.
+     */
+    public void broadcastUsdBasedServiceAdvertisementTerminated(@NonNull String iface,
+            int sessionId, int reasonCode) {
+        sendMessage(iface, USD_BASED_SERVICE_ADVERTISEMENT_TERMINATED_EVENT, sessionId, reasonCode);
+    }
 }
diff --git a/service/java/com/android/server/wifi/p2p/WifiP2pNative.java b/service/java/com/android/server/wifi/p2p/WifiP2pNative.java
index f6f7392fee..1ed17de9c5 100644
--- a/service/java/com/android/server/wifi/p2p/WifiP2pNative.java
+++ b/service/java/com/android/server/wifi/p2p/WifiP2pNative.java
@@ -26,18 +26,23 @@ import android.net.wifi.CoexUnsafeChannel;
 import android.net.wifi.ScanResult;
 import android.net.wifi.nl80211.WifiNl80211Manager;
 import android.net.wifi.p2p.WifiP2pConfig;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pDiscoveryConfig;
 import android.net.wifi.p2p.WifiP2pExtListenParams;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
 import android.net.wifi.util.Environment;
 import android.os.Handler;
 import android.os.WorkSource;
 import android.text.TextUtils;
 import android.util.Log;
-import android.util.SparseArray;
+
+import androidx.annotation.Keep;
 
 import com.android.server.wifi.HalDeviceManager;
 import com.android.server.wifi.PropertyService;
@@ -490,6 +495,7 @@ public class WifiP2pNative {
      *
      * @return boolean value indicating whether operation was successful.
      */
+    @Keep
     public boolean setP2pPowerSave(String iface, boolean enabled) {
         return mSupplicantP2pIfaceHal.setPowerSave(iface, enabled);
     }
@@ -696,11 +702,12 @@ public class WifiP2pNative {
      * This is a helper method that invokes groupAdd(networkId, isPersistent) internally.
      *
      * @param persistent Used to request a persistent group to be formed.
+     * @param isP2pV2 Used to start a Group Owner that support P2P2 IE.
      *
      * @return true, if operation was successful.
      */
-    public boolean p2pGroupAdd(boolean persistent) {
-        return mSupplicantP2pIfaceHal.groupAdd(persistent);
+    public boolean p2pGroupAdd(boolean persistent, boolean isP2pV2) {
+        return mSupplicantP2pIfaceHal.groupAdd(persistent, isP2pV2);
     }
 
     /**
@@ -709,11 +716,12 @@ public class WifiP2pNative {
      * group owner.
      *
      * @param netId Used to specify the restart of a persistent group.
+     * @param isP2pV2 Used to start a Group Owner that support P2P2 IE.
      *
      * @return true, if operation was successful.
      */
-    public boolean p2pGroupAdd(int netId) {
-        return mSupplicantP2pIfaceHal.groupAdd(netId, true);
+    public boolean p2pGroupAdd(int netId, boolean isP2pV2) {
+        return mSupplicantP2pIfaceHal.groupAdd(netId, true, isP2pV2);
     }
 
     /**
@@ -857,13 +865,15 @@ public class WifiP2pNative {
     /**
      * Reinvoke a device from a persistent group.
      *
-     * @param netId Used to specify the persistent group.
+     * @param netId Used to specify the persistent group (valid only for P2P V1 group).
      * @param deviceAddress MAC address of the device to reinvoke.
+     * @param dikId The identifier of device identity key of the device to reinvoke.
+     *              (valid only for P2P V2 group).
      *
      * @return true, if operation was successful.
      */
-    public boolean p2pReinvoke(int netId, String deviceAddress) {
-        return mSupplicantP2pIfaceHal.reinvoke(netId, deviceAddress);
+    public boolean p2pReinvoke(int netId, String deviceAddress, int dikId) {
+        return mSupplicantP2pIfaceHal.reinvoke(netId, deviceAddress, dikId);
     }
 
     /**
@@ -1092,18 +1102,6 @@ public class WifiP2pNative {
         }
     }
 
-    /**
-     * Returns whether P2P + P2P concurrency is supported or not.
-     */
-    public boolean isP2pP2pConcurrencySupported() {
-        synchronized (mLock) {
-            return mWifiVendorHal.canDeviceSupportCreateTypeCombo(
-                    new SparseArray<Integer>() {{
-                        put(HDM_CREATE_IFACE_P2P, 2);
-                    }});
-        }
-    }
-
     /**
      * Configure the IP addresses in supplicant for P2P GO to provide the IP address to
      * client in EAPOL handshake. Refer Wi-Fi P2P Technical Specification v1.7 - Section  4.2.8
@@ -1122,4 +1120,89 @@ public class WifiP2pNative {
         return mSupplicantP2pIfaceHal.configureEapolIpAddressAllocationParams(ipAddressGo,
                 ipAddressMask, ipAddressStart, ipAddressEnd);
     }
+
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param discoveryConfig is the configuration for this service discovery request.
+     * @param timeoutInSeconds is the maximum time to be spent for this service discovery request.
+     */
+    public int startUsdBasedServiceDiscovery(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedServiceDiscoveryConfig discoveryConfig, int timeoutInSeconds) {
+        return mSupplicantP2pIfaceHal.startUsdBasedServiceDiscovery(usdServiceConfig,
+                discoveryConfig, timeoutInSeconds);
+    }
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service discovery.
+     *
+     * @param sessionId Identifier to cancel the service discovery instance.
+     *        Use zero to cancel all the service discovery instances.
+     */
+    public void stopUsdBasedServiceDiscovery(int sessionId) {
+        mSupplicantP2pIfaceHal.stopUsdBasedServiceDiscovery(sessionId);
+    }
+
+    /**
+     * Start an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param usdServiceConfig is the USD based service configuration.
+     * @param advertisementConfig is the configuration for this service advertisement.
+     * @param timeoutInSeconds is the maximum time to be spent for this service advertisement.
+     */
+    public int startUsdBasedServiceAdvertisement(WifiP2pUsdBasedServiceConfig usdServiceConfig,
+            WifiP2pUsdBasedLocalServiceAdvertisementConfig advertisementConfig,
+            int timeoutInSeconds) {
+        return mSupplicantP2pIfaceHal.startUsdBasedServiceAdvertisement(usdServiceConfig,
+                advertisementConfig, timeoutInSeconds);
+    }
+
+    /**
+     * Stop an Un-synchronized Service Discovery (USD) based P2P service advertisement.
+     *
+     * @param sessionId Identifier to cancel the service advertisement.
+     *        Use zero to cancel all the service advertisement instances.
+     */
+    public void stopUsdBasedServiceAdvertisement(int sessionId) {
+        mSupplicantP2pIfaceHal.stopUsdBasedServiceAdvertisement(sessionId);
+    }
+
+    /**
+     * Get the Device Identity Resolution (DIR) Information.
+     * See {@link WifiP2pDirInfo} for details
+     *
+     * @return {@link WifiP2pDirInfo} instance on success, null on failure.
+     */
+    public WifiP2pDirInfo getDirInfo() {
+        return mSupplicantP2pIfaceHal.getDirInfo();
+    }
+
+    /**
+     * Validate the Device Identity Resolution (DIR) Information of a P2P device.
+     * See {@link WifiP2pDirInfo} for details.
+     *
+     * @param dirInfo {@link WifiP2pDirInfo} to validate.
+     * @return The identifier of device identity key on success, -1 on failure.
+     */
+    public int validateDirInfo(@NonNull WifiP2pDirInfo dirInfo) {
+        return mSupplicantP2pIfaceHal.validateDirInfo(dirInfo);
+    }
+
+    /**
+     * Used to authorize a connection request to an existing Group Owner
+     * interface, to allow a peer device to connect.
+     *
+     * @param config Configuration to use for connection.
+     * @param groupOwnerInterfaceName Group Owner interface name on which the request to connect
+     *                           needs to be authorized.
+     *
+     * @return boolean value indicating whether operation was successful.
+     */
+    public boolean authorizeConnectRequestOnGroupOwner(
+            WifiP2pConfig config, String groupOwnerInterfaceName) {
+        return mSupplicantP2pIfaceHal.authorizeConnectRequestOnGroupOwner(config,
+                groupOwnerInterfaceName);
+    }
+
 }
diff --git a/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java b/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java
index 19456d644d..05a21be4a3 100644
--- a/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java
+++ b/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java
@@ -71,6 +71,7 @@ import android.net.wifi.p2p.IWifiP2pManager;
 import android.net.wifi.p2p.WifiP2pConfig;
 import android.net.wifi.p2p.WifiP2pDevice;
 import android.net.wifi.p2p.WifiP2pDeviceList;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pDiscoveryConfig;
 import android.net.wifi.p2p.WifiP2pExtListenParams;
 import android.net.wifi.p2p.WifiP2pGroup;
@@ -79,11 +80,15 @@ import android.net.wifi.p2p.WifiP2pGroupList.GroupDeleteListener;
 import android.net.wifi.p2p.WifiP2pInfo;
 import android.net.wifi.p2p.WifiP2pManager;
 import android.net.wifi.p2p.WifiP2pManager.ExternalApproverRequestListener;
+import android.net.wifi.p2p.WifiP2pPairingBootstrappingConfig;
 import android.net.wifi.p2p.WifiP2pProvDiscEvent;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.WifiP2pWfdInfo;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
 import android.net.wifi.p2p.nsd.WifiP2pServiceRequest;
 import android.net.wifi.p2p.nsd.WifiP2pServiceResponse;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
 import android.net.wifi.util.Environment;
 import android.os.Binder;
 import android.os.Build;
@@ -165,6 +170,7 @@ import java.nio.charset.Charset;
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CodingErrorAction;
 import java.nio.charset.StandardCharsets;
+import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -172,13 +178,13 @@ import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.stream.Collectors;
 
 /**
@@ -292,6 +298,9 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
     // Set a two minute discover timeout to avoid STA scans from being blocked
     private static final int DISCOVER_TIMEOUT_S = 120;
 
+    // Set a 30 seconds timeout for USD service discovery and advertisement.
+    @VisibleForTesting static final int USD_BASED_SERVICE_ADVERTISEMENT_DISCOVERY_TIMEOUT_S = 30;
+
     // Idle time after a peer is gone when the group is torn down
     private static final int GROUP_IDLE_TIME_S = 10;
 
@@ -346,8 +355,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
     // Messages for interaction with IpClient.
     private static final int IPC_PRE_DHCP_ACTION            =   BASE + 30;
     private static final int IPC_POST_DHCP_ACTION           =   BASE + 31;
-    @VisibleForTesting
-    static final int IPC_DHCP_RESULTS                       =   BASE + 32;
+    private static final int IPC_DHCP_RESULTS               =   BASE + 32;
     private static final int IPC_PROVISIONING_SUCCESS       =   BASE + 33;
     private static final int IPC_PROVISIONING_FAILURE       =   BASE + 34;
     @VisibleForTesting
@@ -414,10 +422,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
     // The transaction Id of service discovery request
     private int mServiceTransactionId = 0;
 
-    // Service discovery request ID of wpa_supplicant.
-    // null means it's not set yet.
-    private String mServiceDiscReqId;
-
     // clients(application) information list
     private final HashMap<Messenger, ClientInfo> mClientInfoList = new HashMap<>();
 
@@ -434,18 +438,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
     private final Map<String, HashSet<ScanResult.InformationElement>> mVendorElements =
             new HashMap<>();
 
-    // client(application) P2P group info list, key = package name
-    private final Map<String, WifiP2pGroupInfo> mOwnershipMap = new HashMap<>();
-    private WifiP2pGroup mGroup;
-    private final WifiP2pInfo mWifiP2pInfo = new WifiP2pInfo();
-
-    // Max number of P2P groups supported
-    private static final int MAX_NUM_GROUP = 1;
-    // Package name used to represent all shared connections
-    private static final String SHARED_PKG_NAME = "__SHARED_PACKAGE_NAME";
-    // Ongoing connection request package name with the default value set for shared connection
-    private String mConnectionPkgName = SHARED_PKG_NAME;
-
     // peer authorizing timestamp which is indexed by the peer MAC address.
     private final Map<String, Long> mPeerAuthorizingTimestamp = new HashMap<>();
 
@@ -478,10 +470,10 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
     @VisibleForTesting
     static final String GO_EAPOL_IP_RANGE_DEFAULT_END_ADDRESS = "192.168.49.254";
 
+    private static final int PAIRING_PIN_OR_PASSWORD_LENGTH = 8;
+
     private final RemoteCallbackList<IWifiP2pListener> mWifiP2pListeners =
             new RemoteCallbackList<>();
-    // clients(application) P2P listener map, key = package name
-    private final Map<String, IWifiP2pListener> mP2pListenerMap = new HashMap<>();
 
     /**
      * Error code definition.
@@ -599,17 +591,52 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
         mP2pStateMachine.sendMessage(ENABLE_P2P);
     }
 
-    /**
-     * Stores P2P group information
-     */
-    private static class WifiP2pGroupInfo {
-        public WifiP2pGroup p2pGroup;
-        public WifiP2pInfo p2pInfo;
-        public IIpClient ipClient;
-        WifiP2pGroupInfo(WifiP2pGroup group, WifiP2pInfo info, IIpClient client) {
-            p2pGroup = group;
-            p2pInfo = info;
-            ipClient = client;
+    // Tracks the ongoing Service discovery request to wpa_supplicant.
+    private final WifiP2pOngoingServiceDiscoveryRequestInfo mServiceDiscoveryInfo =
+            new WifiP2pOngoingServiceDiscoveryRequestInfo();
+    private static class WifiP2pOngoingServiceDiscoveryRequestInfo {
+        public static final int WIFI_P2P_GAS_FRAME_BASED_SERVICE_DISCOVERY = 1;
+        public static final int WIFI_P2P_USD_FRAME_BASED_SERVICE_DISCOVERY = 2;
+        private String mSessionId = "";
+        private int mServiceDiscoveryType = 0;
+        WifiP2pOngoingServiceDiscoveryRequestInfo() {
+        }
+
+        public String getSessionId() {
+            return mSessionId;
+        }
+
+        public int getServiceDiscoveryType() {
+            return mServiceDiscoveryType;
+        }
+
+        public void update(int serviceDiscoveryType, String sessionId) {
+            mServiceDiscoveryType = serviceDiscoveryType;
+            mSessionId = sessionId;
+        }
+
+        public int getSessionIdInt() {
+            return Integer.parseInt(mSessionId);
+        }
+
+        public void update(int serviceDiscoveryType, int sessionId) {
+            mServiceDiscoveryType = serviceDiscoveryType;
+            mSessionId = Integer.toString(sessionId);
+        }
+
+        public void invalidate() {
+            mServiceDiscoveryType = 0;
+            mSessionId = "";
+        }
+
+        public boolean isValid() {
+            return mServiceDiscoveryType != 0 && !TextUtils.isEmpty(mSessionId);
+        }
+        public String toString() {
+            StringBuilder sbuf = new StringBuilder("WifiP2pOngoingServiceDiscoveryRequestInfo:");
+            sbuf.append("\n serviceDiscoveryType: ").append(mServiceDiscoveryType);
+            sbuf.append("\n sessionId: ").append(mSessionId);
+            return sbuf.toString();
         }
     }
 
@@ -824,7 +851,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
     }
 
     private void stopIpClient() {
-        // TODO: Modify logic for Dual P2P in next CL
         // Invalidate all previous start requests
         mIpClientStartIndex++;
         if (mIpClient != null) {
@@ -896,8 +922,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     return;
                 }
                 mIpClient = ipClient;
-                mOwnershipMap.put(
-                        mConnectionPkgName, new WifiP2pGroupInfo(mGroup, mWifiP2pInfo, mIpClient));
 
                 ProvisioningConfiguration config = null;
                 switch (mGroupClientIpProvisioningMode) {
@@ -1090,8 +1114,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 AttributionSource source = mClientAttributionSource.remove(binder);
                 if (null != source) {
                     mVendorElements.remove(source.getPackageName());
-                    mOwnershipMap.remove(source.getPackageName());
-                    mP2pListenerMap.remove(source.getPackageName());
                 }
             }
 
@@ -1110,34 +1132,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
         }
     }
 
-    /**
-     * Get WifiP2pGroupInfo owned by the provided package name
-     */
-    private WifiP2pGroupInfo getP2pGroupInfo(String packageName) {
-        if (mOwnershipMap.containsKey(packageName)) {
-            return mOwnershipMap.get(packageName);
-        } else if (mOwnershipMap.containsKey(SHARED_PKG_NAME)) {
-            return mOwnershipMap.get(SHARED_PKG_NAME);
-        }
-        return null;
-    }
-
-    private boolean checkIfPackageIsGroupOwner(String packageName) {
-        return !mFeatureFlags.p2pOwnership()
-                || mOwnershipMap.containsKey(packageName)
-                || mOwnershipMap.containsKey(SHARED_PKG_NAME);
-    }
-
-    private String getGroupOwnerPackageName(WifiP2pGroup group) {
-        for (Map.Entry<String, WifiP2pGroupInfo> entry : mOwnershipMap.entrySet()) {
-            if (entry.getValue().p2pGroup.getInterface().equals(group.getInterface())) {
-                return entry.getKey();
-            }
-        }
-        Log.wtf(TAG, "group missing from ownership map " + group.getInterface());
-        return SHARED_PKG_NAME;
-    }
-
     /** This is used to provide information to drivers to optimize performance depending
      * on the current mode of operation.
      * 0 - disabled
@@ -1188,7 +1182,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 TAG + " registerWifiP2pListener");
         Log.i(TAG, "registerWifiP2pListener uid=" + Binder.getCallingUid());
         mWifiP2pListeners.register(listener);
-        mP2pListenerMap.put(packageName, listener);
     }
 
     /**
@@ -1202,15 +1195,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
         }
         Log.i(TAG, "unregisterWifiP2pListener uid=" + Binder.getCallingUid());
         mWifiP2pListeners.unregister(listener);
-        Iterator<Map.Entry<String, IWifiP2pListener>> iterator =
-                mP2pListenerMap.entrySet().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<String, IWifiP2pListener> entry = iterator.next();
-            if (entry.getValue() == listener) {
-                iterator.remove();
-                break;
-            }
-        }
     }
 
     private void onP2pStateChanged(@WifiP2pManager.WifiP2pState int state) {
@@ -1321,57 +1305,53 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
         mWifiP2pListeners.finishBroadcast();
     }
 
-    private void onGroupCreated(WifiP2pInfo p2pInfo, WifiP2pGroup p2pGroup,
-            RemoteCallbackList<IWifiP2pListener> callbackList) {
-        int numCallbacks = callbackList.beginBroadcast();
+    private void onGroupCreated(WifiP2pInfo p2pInfo, WifiP2pGroup p2pGroup) {
+        int numCallbacks = mWifiP2pListeners.beginBroadcast();
         for (int i = 0; i < numCallbacks; i++) {
             try {
-                callbackList.getBroadcastItem(i).onGroupCreated(p2pInfo, p2pGroup);
+                mWifiP2pListeners.getBroadcastItem(i).onGroupCreated(p2pInfo, p2pGroup);
             } catch (RemoteException e) {
                 Log.e(TAG, "Failure calling onGroupCreated" + e);
             }
         }
-        callbackList.finishBroadcast();
+        mWifiP2pListeners.finishBroadcast();
     }
 
-    private void onPeerClientJoined(WifiP2pInfo p2pInfo, WifiP2pGroup p2pGroup,
-            RemoteCallbackList<IWifiP2pListener> callbackList) {
-        int numCallbacks = callbackList.beginBroadcast();
+    private void onPeerClientJoined(WifiP2pInfo p2pInfo, WifiP2pGroup p2pGroup) {
+        int numCallbacks = mWifiP2pListeners.beginBroadcast();
         for (int i = 0; i < numCallbacks; i++) {
             try {
-                callbackList.getBroadcastItem(i).onPeerClientJoined(p2pInfo, p2pGroup);
+                mWifiP2pListeners.getBroadcastItem(i).onPeerClientJoined(p2pInfo, p2pGroup);
             } catch (RemoteException e) {
                 Log.e(TAG, "Failure calling onPeerClientJoined" + e);
             }
         }
-        callbackList.finishBroadcast();
+        mWifiP2pListeners.finishBroadcast();
     }
 
-    private void onPeerClientDisconnected(WifiP2pInfo p2pInfo, WifiP2pGroup p2pGroup,
-            RemoteCallbackList<IWifiP2pListener> callbackList) {
-        int numCallbacks = callbackList.beginBroadcast();
+    private void onPeerClientDisconnected(WifiP2pInfo p2pInfo, WifiP2pGroup p2pGroup) {
+        int numCallbacks = mWifiP2pListeners.beginBroadcast();
         for (int i = 0; i < numCallbacks; i++) {
             try {
-                callbackList.getBroadcastItem(i).onPeerClientDisconnected(p2pInfo,
+                mWifiP2pListeners.getBroadcastItem(i).onPeerClientDisconnected(p2pInfo,
                         p2pGroup);
             } catch (RemoteException e) {
                 Log.e(TAG, "Failure calling onPeerClientDisconnected" + e);
             }
         }
-        callbackList.finishBroadcast();
+        mWifiP2pListeners.finishBroadcast();
     }
 
-    private void onFrequencyChanged(WifiP2pInfo p2pInfo, WifiP2pGroup p2pGroup,
-            RemoteCallbackList<IWifiP2pListener> callbackList) {
-        int numCallbacks = callbackList.beginBroadcast();
+    private void onFrequencyChanged(WifiP2pInfo p2pInfo, WifiP2pGroup p2pGroup) {
+        int numCallbacks = mWifiP2pListeners.beginBroadcast();
         for (int i = 0; i < numCallbacks; i++) {
             try {
-                callbackList.getBroadcastItem(i).onFrequencyChanged(p2pInfo, p2pGroup);
+                mWifiP2pListeners.getBroadcastItem(i).onFrequencyChanged(p2pInfo, p2pGroup);
             } catch (RemoteException e) {
                 Log.e(TAG, "Failure calling onFrequencyChanged" + e);
             }
         }
-        callbackList.finishBroadcast();
+        mWifiP2pListeners.finishBroadcast();
     }
 
     private void onGroupRemoved() {
@@ -1393,12 +1373,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 != PackageManager.PERMISSION_DENIED;
     }
 
-    private boolean isDualP2pSupported() {
-        return mFeatureFlags.p2pDual()
-                && mFeatureFlags.p2pOwnership()
-                && mWifiNative.isP2pP2pConcurrencySupported();
-    }
-
     @Override
     protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
@@ -1416,21 +1390,17 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
         pw.println("mListenStarted " + mListenStarted);
         pw.println("mDetailedState " + mDetailedState);
         pw.println("mTemporarilyDisconnectedWifi " + mTemporarilyDisconnectedWifi);
-        pw.println("mServiceDiscReqId " + mServiceDiscReqId);
+        pw.println("ServiceDiscoveryInfo " + mServiceDiscoveryInfo);
         pw.println("mDeathDataByBinder " + mDeathDataByBinder);
         pw.println("mClientInfoList " + mClientInfoList.size());
         pw.println("mActiveClients " + mActiveClients);
         pw.println("mPeerAuthorizingTimestamp" + mPeerAuthorizingTimestamp);
-        pw.println("isOwnershipSupported " + mFeatureFlags.p2pOwnership());
-        pw.println("isDualP2pSupported " + isDualP2pSupported());
         pw.println();
 
-        for (WifiP2pGroupInfo info : mOwnershipMap.values()) {
-            IIpClient ipClient = info.ipClient;
-            if (ipClient != null) {
-                pw.println("mIpClient:");
-                IpClientUtil.dumpIpClient(ipClient, fd, pw, args);
-            }
+        final IIpClient ipClient = mIpClient;
+        if (ipClient != null) {
+            pw.println("mIpClient:");
+            IpClientUtil.dumpIpClient(ipClient, fd, pw, args);
         }
     }
 
@@ -1468,10 +1438,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 new P2pEnabledState(mThreshold, mThreadLocalLog);
         // Inactive is when p2p is enabled with no connectivity
         private final InactiveState mInactiveState = new InactiveState(mThreshold, mThreadLocalLog);
-        // Idle is when p2p is enabled and there's no ongoing connection attempt
-        private final IdleState mIdleState = new IdleState(mThreshold, mThreadLocalLog);
-        private final L3ConnectingState mL3ConnectingState =
-                new L3ConnectingState(mThreshold, mThreadLocalLog);
         private final GroupCreatingState mGroupCreatingState =
                 new GroupCreatingState(mThreshold, mThreadLocalLog);
         private final UserAuthorizingInviteRequestState mUserAuthorizingInviteRequestState =
@@ -1541,6 +1507,8 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         sendP2pPersistentGroupsChangedBroadcast();
                     }
                 });
+        private final WifiP2pInfo mWifiP2pInfo = new WifiP2pInfo();
+        private WifiP2pGroup mGroup;
         // Is wifi on or off.
         private boolean mIsWifiEnabled = false;
 
@@ -1563,7 +1531,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     addState(mWaitingState, mP2pDisabledContainerState);
                 addState(mP2pEnabledState, mDefaultState);
                     addState(mInactiveState, mP2pEnabledState);
-                    addState(mIdleState, mP2pEnabledState);
                     addState(mGroupCreatingState, mP2pEnabledState);
                         addState(mUserAuthorizingInviteRequestState, mGroupCreatingState);
                         addState(mUserAuthorizingNegotiationRequestState, mGroupCreatingState);
@@ -1571,7 +1538,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         addState(mGroupNegotiationState, mGroupCreatingState);
                         addState(mFrequencyConflictState, mGroupCreatingState);
                         addState(mP2pRejectWaitState, mGroupCreatingState);
-                        addState(mL3ConnectingState, mGroupCreatingState);
                     addState(mGroupCreatedState, mP2pEnabledState);
                         addState(mUserAuthorizingJoinState, mGroupCreatedState);
                         addState(mOngoingGroupRemovalState, mGroupCreatedState);
@@ -1691,22 +1657,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             }
         }
 
-        private RemoteCallbackList<IWifiP2pListener> generateCallbackList(WifiP2pGroup group) {
-            // TODO: Modify logic for Dual P2P in next CL
-            if (!mFeatureFlags.p2pOwnership() || mOwnershipMap.containsKey(SHARED_PKG_NAME)) {
-                return mWifiP2pListeners;
-            }
-
-            String pkgName = getGroupOwnerPackageName(group);
-            IWifiP2pListener p2pListener = mP2pListenerMap.get(pkgName);
-            RemoteCallbackList<IWifiP2pListener> listener = new RemoteCallbackList<>();
-            if (p2pListener != null) {
-                listener.register(p2pListener);
-                logd("WifiP2pListener callback generated for " + pkgName);
-            }
-            return listener;
-        }
-
         @Override
         protected String getLogRecString(Message msg) {
             StringBuilder sb = new StringBuilder();
@@ -1911,6 +1861,24 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     return "WifiP2pMonitor.SUP_DISCONNECTION_EVENT";
                 case WifiP2pMonitor.P2P_FREQUENCY_CHANGED_EVENT:
                     return "WifiP2pMonitor.P2P_FREQUENCY_CHANGED_EVENT";
+                case WifiP2pMonitor.USD_BASED_SERVICE_DISCOVERY_TERMINATED_EVENT:
+                    return "WifiP2pMonitor.USD_BASED_SERVICE_DISCOVERY_TERMINATED_EVENT";
+                case WifiP2pMonitor.USD_BASED_SERVICE_ADVERTISEMENT_TERMINATED_EVENT:
+                    return "WifiP2pMonitor.USD_BASED_SERVICE_ADVERTISEMENT_TERMINATED_EVENT";
+                case WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT:
+                    return "WifiP2pMonitor"
+                            + ".P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT";
+                case WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT:
+                    return "WifiP2pMonitor"
+                            + ".P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT";
+                case WifiP2pMonitor
+                        .P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT:
+                    return "WifiP2pMonitor"
+                            + ".P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT";
+                case WifiP2pMonitor
+                        .P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT:
+                    return "WifiP2pMonitor"
+                            + ".P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT";
                 case WpsInfo.DISPLAY:
                     return "WpsInfo.DISPLAY";
                 case WpsInfo.KEYPAD:
@@ -2104,6 +2072,26 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     WifiP2pMonitor.SUP_DISCONNECTION_EVENT, getHandler());
             mWifiMonitor.registerHandler(mInterfaceName,
                     WifiP2pMonitor.P2P_FREQUENCY_CHANGED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(mInterfaceName,
+                    WifiP2pMonitor.USD_BASED_SERVICE_DISCOVERY_TERMINATED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(mInterfaceName,
+                    WifiP2pMonitor.USD_BASED_SERVICE_ADVERTISEMENT_TERMINATED_EVENT, getHandler());
+            mWifiMonitor.registerHandler(mInterfaceName,
+                    WifiP2pMonitor
+                            .P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT,
+                    getHandler());
+            mWifiMonitor.registerHandler(mInterfaceName,
+                    WifiP2pMonitor
+                            .P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT,
+                    getHandler());
+            mWifiMonitor.registerHandler(mInterfaceName,
+                    WifiP2pMonitor
+                            .P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                    getHandler());
+            mWifiMonitor.registerHandler(mInterfaceName,
+                    WifiP2pMonitor
+                            .P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                    getHandler());
 
             mWifiMonitor.startMonitoring(mInterfaceName);
         }
@@ -2336,22 +2324,8 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                         message.obj));
                         break;
                     case WifiP2pManager.REQUEST_CONNECTION_INFO:
-                        if (mFeatureFlags.p2pOwnership()) {
-                            String packageName = getCallingPkgName(
-                                    message.sendingUid, message.replyTo);
-                            WifiP2pGroupInfo groupInfo = getP2pGroupInfo(packageName);
-                            if (groupInfo != null) {
-                                replyToMessage(message, WifiP2pManager.RESPONSE_CONNECTION_INFO,
-                                        new WifiP2pInfo(groupInfo.p2pInfo));
-                            } else {
-                                logd("No group owned by caller - returning empty info");
-                                replyToMessage(message, WifiP2pManager.RESPONSE_CONNECTION_INFO,
-                                        new WifiP2pInfo());
-                            }
-                        } else {
-                            replyToMessage(message, WifiP2pManager.RESPONSE_CONNECTION_INFO,
-                                    new WifiP2pInfo(mWifiP2pInfo));
-                        }
+                        replyToMessage(message, WifiP2pManager.RESPONSE_CONNECTION_INFO,
+                                new WifiP2pInfo(mWifiP2pInfo));
                         break;
                     case WifiP2pManager.REQUEST_GROUP_INFO: {
                         String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
@@ -2377,19 +2351,8 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             // remain at this state.
                             break;
                         }
-                        if (mFeatureFlags.p2pOwnership()) {
-                            WifiP2pGroupInfo groupInfo = getP2pGroupInfo(packageName);
-                            if (groupInfo != null) {
-                                replyToMessage(message, WifiP2pManager.RESPONSE_GROUP_INFO,
-                                        maybeEraseOwnDeviceAddress(groupInfo.p2pGroup, uid));
-                            } else  {
-                                logd("No group owned by caller - returning null group");
-                                replyToMessage(message, WifiP2pManager.RESPONSE_GROUP_INFO, null);
-                            }
-                        } else {
-                            replyToMessage(message, WifiP2pManager.RESPONSE_GROUP_INFO,
-                                    maybeEraseOwnDeviceAddress(mGroup, message.sendingUid));
-                        }
+                        replyToMessage(message, WifiP2pManager.RESPONSE_GROUP_INFO,
+                                maybeEraseOwnDeviceAddress(mGroup, message.sendingUid));
                         break;
                     }
                     case WifiP2pManager.REQUEST_PERSISTENT_GROUP_INFO: {
@@ -2495,6 +2458,9 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     case WifiP2pMonitor.P2P_DEVICE_LOST_EVENT:
                     case WifiP2pMonitor.P2P_FIND_STOPPED_EVENT:
                     case WifiP2pMonitor.P2P_SERV_DISC_RESP_EVENT:
+                    case WifiP2pMonitor.P2P_PROV_DISC_FAILURE_EVENT:
+                    case WifiP2pMonitor.USD_BASED_SERVICE_DISCOVERY_TERMINATED_EVENT:
+                    case WifiP2pMonitor.USD_BASED_SERVICE_ADVERTISEMENT_TERMINATED_EVENT:
                     case PEER_CONNECTION_USER_ACCEPT:
                     case PEER_CONNECTION_USER_REJECT:
                     case DISCONNECT_WIFI_RESPONSE:
@@ -2510,7 +2476,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     case TETHER_INTERFACE_STATE_CHANGED:
                     case TETHER_INTERFACE_CLIENTS_CHANGED:
                     case UPDATE_P2P_DISALLOWED_CHANNELS:
-                    case WifiP2pMonitor.P2P_PROV_DISC_FAILURE_EVENT:
                     case SET_MIRACAST_MODE:
                         break;
                     case WifiP2pManager.START_LISTEN:
@@ -2980,7 +2945,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 }
                 resetWifiP2pInfo();
                 mGroup = null;
-                mOwnershipMap.clear();
             }
 
             @Override
@@ -3062,12 +3026,12 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
 
             @Override
             public void enterImpl() {
-
+                mWifiInjector.getWifiP2pConnection().setP2pInDisabledState(true);
             }
 
             @Override
             public void exitImpl() {
-
+                mWifiInjector.getWifiP2pConnection().setP2pInDisabledState(false);
             }
 
             @Override
@@ -3091,25 +3055,19 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             Log.i(TAG, "No valid package name, ignore ENABLE_P2P");
                             break;
                         }
-                        mWifiInjector.getWifiP2pConnection().setP2pInWaitingState(true);
                         int proceedWithOperation =
                                 mInterfaceConflictManager.manageInterfaceConflictForStateMachine(
                                         TAG, message, mP2pStateMachine, mWaitingState,
                                         mP2pDisabledState, HalDeviceManager.HDM_CREATE_IFACE_P2P,
                                         createRequestorWs(message.sendingUid, packageName),
                                         false /* bypassDialog */);
-                        mWifiInjector.getWifiP2pConnection().setP2pInWaitingState(false);
                         if (proceedWithOperation == InterfaceConflictManager.ICM_ABORT_COMMAND) {
                             Log.e(TAG, "User refused to set up P2P");
                             updateThisDevice(WifiP2pDevice.UNAVAILABLE);
                         } else if (proceedWithOperation
                                 == InterfaceConflictManager.ICM_EXECUTE_COMMAND) {
                             if (setupInterface()) {
-                                if (mFeatureFlags.p2pOwnership()) {
-                                    smTransition(this, mIdleState);
-                                } else {
-                                    smTransition(this, mInactiveState);
-                                }
+                                smTransition(this, mInactiveState);
                             }
                         } // else InterfaceConflictManager.ICM_SKIP_COMMAND_WAIT_FOR_USER: nop
                         break;
@@ -3171,14 +3129,12 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             Log.i(TAG, "No valid package name, do not set up the P2P interface");
                             return NOT_HANDLED;
                         }
-                        mWifiInjector.getWifiP2pConnection().setP2pInWaitingState(true);
                         int proceedWithOperation =
                                 mInterfaceConflictManager.manageInterfaceConflictForStateMachine(
                                         TAG, message, mP2pStateMachine, mWaitingState,
                                         mP2pDisabledState, HalDeviceManager.HDM_CREATE_IFACE_P2P,
                                         createRequestorWs(message.sendingUid, packageName),
                                         false /* bypassDialog */);
-                        mWifiInjector.getWifiP2pConnection().setP2pInWaitingState(false);
                         if (proceedWithOperation == InterfaceConflictManager.ICM_ABORT_COMMAND) {
                             Log.e(TAG, "User refused to set up P2P");
                             updateThisDevice(WifiP2pDevice.UNAVAILABLE);
@@ -3187,11 +3143,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                 == InterfaceConflictManager.ICM_EXECUTE_COMMAND) {
                             if (!setupInterface()) return NOT_HANDLED;
                             deferMessage(message);
-                            if (mFeatureFlags.p2pOwnership()) {
-                                smTransition(this, mIdleState);
-                            } else {
-                                smTransition(this, mInactiveState);
-                            }
+                            smTransition(this, mInactiveState);
                         }  // else InterfaceConflictManager.ICM_SKIP_COMMAND_WAIT_FOR_USER: nop
                         break;
                     }
@@ -3362,7 +3314,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         mLastCallerInfoManager.put(apiType, Process.myTid(), uid, 0, packageName,
                                 true);
                         // do not send service discovery request while normal find operation.
-                        clearSupplicantServiceRequest();
+                        clearGasFrameBasedServiceDiscoveryRequests();
                         if (p2pFind(scanType, freq, DISCOVER_TIMEOUT_S, discoveryConfig)) {
                             mWifiP2pMetrics.incrementPeerScans();
                             replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_SUCCEEDED);
@@ -3388,6 +3340,48 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                     WifiP2pManager.ERROR);
                         }
                         break;
+                    case WifiP2pMonitor.USD_BASED_SERVICE_ADVERTISEMENT_TERMINATED_EVENT: {
+                        int sessionId = message.arg1;
+                        for (ClientInfo c : mClientInfoList.values()) {
+                            for (WifiP2pServiceInfo serviceInfo : c.mUsdServiceAdvertiseList) {
+                                if (serviceInfo.getUsdSessionId() == sessionId) {
+                                    serviceInfo.setUsdSessionId(0);
+                                    break;
+                                }
+                            }
+                        }
+                        // TODO check the reason code and set to false only for timeout
+                        sendP2pListenChangedBroadcast(false);
+                        break;
+                    }
+                    case WifiP2pMonitor.USD_BASED_SERVICE_DISCOVERY_TERMINATED_EVENT: {
+                        int sessionId = message.arg1;
+                        if (mServiceDiscoveryInfo.isValid()) {
+                            if (sessionId == mServiceDiscoveryInfo.getSessionIdInt()) {
+                                mServiceDiscoveryInfo.invalidate();
+                                sendP2pDiscoveryChangedBroadcast(false);
+                            } else {
+                                Log.e(TAG, "USD terminate event received from non-active"
+                                        + " session ID: " + sessionId + " . Active session ID: "
+                                        + mServiceDiscoveryInfo.getSessionIdInt());
+                            }
+                        } else {
+                            Log.e(TAG, "USD terminate event received from non-active session"
+                                    + " ID: " + sessionId + " when there is no active session"
+                                    + " running");
+                        }
+
+                        for (ClientInfo c : mClientInfoList.values()) {
+                            for (WifiP2pServiceRequest serviceRequest : c.mUsdServiceDiscoverList) {
+                                if (serviceRequest.getUsdSessionId() == sessionId) {
+                                    Log.d(TAG, "Clear service request session ID: " +  sessionId);
+                                    serviceRequest.setUsdSessionId(0);
+                                    break;
+                                }
+                            }
+                        }
+                        break;
+                    }
                     case WifiP2pManager.DISCOVER_SERVICES: {
                         String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
                         if (packageName == null) {
@@ -3423,30 +3417,9 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         logd(getName() + " discover services - Type: " + serviceDiscoveryType);
                         if (serviceDiscoveryType
                                 == WifiP2pManager.WIFI_P2P_USD_BASED_SERVICE_DISCOVERY) {
-                            if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()
-                                     && isFeatureSupported(
-                                             WifiP2pManager.FEATURE_WIFI_DIRECT_R2)) {
-                                // TODO implementation
-                                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
-                                        WifiP2pManager.ERROR);
-                            } else {
-                                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
-                                        WifiP2pManager.ERROR);
-                            }
-                            break;
-                        }
-                        if (!updateSupplicantServiceRequest()) {
-                            replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
-                                    WifiP2pManager.NO_SERVICE_REQUESTS);
-                            break;
-                        }
-                        if (p2pFind(DISCOVER_TIMEOUT_S)) {
-                            sendP2pDiscoveryChangedBroadcast(true);
-                            mWifiP2pMetrics.incrementServiceScans();
-                            replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_SUCCEEDED);
+                            processUsdFrameBasedServiceDiscoveryRequestMessage(message);
                         } else {
-                            replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
-                                    WifiP2pManager.ERROR);
+                            processGasFrameBasedServiceDiscoveryRequestMessage(message);
                         }
                         break;
                     }
@@ -3517,8 +3490,10 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         break;
                     case WifiP2pManager.ADD_SERVICE_REQUEST:
                         if (mVerboseLoggingEnabled) logd(getName() + " add service request");
-                        if (!addServiceRequest(message)) {
-                            replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED);
+                        AtomicInteger errorCode = new AtomicInteger(0);
+                        if (!addServiceRequest(message, errorCode)) {
+                            replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED,
+                                    errorCode.get());
                             break;
                         }
                         replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_SUCCEEDED);
@@ -3683,32 +3658,63 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     case WifiP2pManager.GET_DIR_INFO: {
                         String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
                         if (packageName == null) {
-                            replyToMessage(message, WifiP2pManager.GET_DIR_INFO_FAILED);
+                            replyToMessage(message, WifiP2pManager.GET_DIR_INFO_FAILED,
+                                    WifiP2pManager.ERROR);
+                            break;
+                        }
+                        if (!isWifiDirect2Enabled()) {
+                            replyToMessage(message, WifiP2pManager.GET_DIR_INFO_FAILED,
+                                    WifiP2pManager.ERROR);
                             break;
                         }
-                        if (!Environment.isSdkAtLeastB()
-                                || !checkNearbyDevicesPermission(message, "GET_DIR_INFO")) {
-                            replyToMessage(message, WifiP2pManager.GET_DIR_INFO_FAILED);
+                        if (!checkNearbyDevicesPermission(message, "GET_DIR_INFO")) {
+                            replyToMessage(message, WifiP2pManager.GET_DIR_INFO_FAILED,
+                                    WifiP2pManager.NO_PERMISSION);
                             break;
                         }
-                        // TODO implementation
-                        replyToMessage(message, WifiP2pManager.RESPONSE_GET_DIR_INFO, null);
+
+                        WifiP2pDirInfo dirInfo = mWifiNative.getDirInfo();
+                        if (mVerboseLoggingEnabled) {
+                            Log.d(TAG, " DIR info received: " + dirInfo);
+                        }
+                        replyToMessage(message, WifiP2pManager.RESPONSE_GET_DIR_INFO, dirInfo);
                         break;
                     }
                     case WifiP2pManager.VALIDATE_DIR_INFO: {
                         String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
                         if (packageName == null) {
-                            replyToMessage(message, WifiP2pManager.VALIDATE_DIR_INFO_FAILED);
+                            replyToMessage(message, WifiP2pManager.VALIDATE_DIR_INFO_FAILED,
+                                    WifiP2pManager.ERROR);
+                            break;
+                        }
+                        if (!isWifiDirect2Enabled()) {
+                            replyToMessage(message, WifiP2pManager.GET_DIR_INFO_FAILED,
+                                    WifiP2pManager.ERROR);
+                            break;
+                        }
+                        if (!checkNearbyDevicesPermission(message, "VALIDATE_DIR_INFO")) {
+                            replyToMessage(message, WifiP2pManager.VALIDATE_DIR_INFO_FAILED,
+                                    WifiP2pManager.NO_PERMISSION);
                             break;
                         }
-                        if (!Environment.isSdkAtLeastB()
-                                || !checkNearbyDevicesPermission(message,
-                                "VALIDATE_DIR_INFO")) {
-                            replyToMessage(message, WifiP2pManager.VALIDATE_DIR_INFO_FAILED);
+                        Bundle extras = message.getData()
+                                .getBundle(WifiP2pManager.EXTRA_PARAM_KEY_BUNDLE);
+                        WifiP2pDirInfo dirInfo = extras.getParcelable(
+                                WifiP2pManager.EXTRA_PARAM_KEY_DIR_INFO);
+                        if (dirInfo == null) {
+                            replyToMessage(message, WifiP2pManager.VALIDATE_DIR_INFO_FAILED,
+                                    WifiP2pManager.ERROR);
                             break;
                         }
-                        // TODO implementation
-                        replyToMessage(message, WifiP2pManager.RESPONSE_VALIDATE_DIR_INFO, 0);
+                        boolean isValid = false;
+                        if (mWifiNative.validateDirInfo(dirInfo) >= 0) {
+                            isValid = true;
+                        }
+                        if (mVerboseLoggingEnabled) {
+                            Log.d(TAG, " DIR info validated. isValid: " + isValid);
+                        }
+                        replyToMessage(message, WifiP2pManager.RESPONSE_VALIDATE_DIR_INFO,
+                                isValid ? 1 : 0);
                         break;
                     }
                     default:
@@ -3763,6 +3769,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 cancelIdleShutdown();
             }
 
+            @SuppressLint("NewApi")
             @Override
             public boolean processMessageImpl(Message message) {
                 logSmMessage(getName(), message);
@@ -3823,6 +3830,25 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                 isConnectFailed = true;
                                 replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
                             }
+                        } else if (isConfigForV2Connection(config)) {
+                            if (isWifiDirect2Enabled()) {
+                                mAutonomousGroup = false;
+                                mWifiNative.p2pStopFind();
+                                if (reinvokePersistentV2Group(config)) {
+                                    smTransition(this, mGroupNegotiationState);
+                                } else if (isConfigForBootstrappingMethodOutOfBand(config)) {
+                                    if (mWifiNative.p2pConnect(config, FORM_GROUP) != null) {
+                                        smTransition(this, mGroupNegotiationState);
+                                    } else {
+                                        isConnectFailed = true;
+                                    }
+                                } else {
+                                    smTransition(this, mProvisionDiscoveryState);
+                                }
+                            } else {
+                                isConnectFailed = true;
+                                replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
+                            }
                         } else {
                             if (isConfigInvalid(config)) {
                                 loge("Dropping connect request " + config);
@@ -3862,7 +3888,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             // When discovery stops in inactive state, flush to clear
                             // state peer data
                             mWifiNative.p2pFlush();
-                            mServiceDiscReqId = null;
+                            mServiceDiscoveryInfo.invalidate();
                             replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
                         } else {
                             replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
@@ -3944,7 +3970,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         // Handling provision discovery and issuing a p2p_connect before
                         // group negotiation comes through causes issues
                         break;
-                    case WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    case WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT: {
                         if (message.obj == null) {
                             Log.e(TAG, "Illegal argument(s)");
                             break;
@@ -3958,16 +3984,42 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         mSavedPeerConfig = new WifiP2pConfig();
                         mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
                         mSavedPeerConfig.deviceAddress = device.deviceAddress;
-                        mSavedPeerConfig.wps.pin = provDisc.pin;
+                        mSavedPeerConfig.wps.pin = provDisc.wpsPin;
                         if (SdkLevel.isAtLeastV() && provDisc.getVendorData() != null) {
                             mSavedPeerConfig.setVendorData(provDisc.getVendorData());
                         }
 
-                        notifyP2pProvDiscShowPinRequest(provDisc.pin, device.deviceAddress);
+                        notifyP2pProvDiscShowPinRequest(provDisc.wpsPin, device.deviceAddress);
                         mPeers.updateStatus(device.deviceAddress, WifiP2pDevice.INVITED);
                         sendPeersChangedBroadcast();
                         smTransition(this, mUserAuthorizingNegotiationRequestState);
                         break;
+                    }
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT:
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT: {
+                        if (processProvisionDiscoveryRequestForV2ConnectionOnP2pDevice(
+                                (WifiP2pProvDiscEvent) message.obj)) {
+                            smTransition(this, mUserAuthorizingNegotiationRequestState);
+                        }
+                        break;
+                    }
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT: {
+                        // TODO Change this logic:
+                        // Move to UserAuthorizingNegotiationRequestState, display the PIN or
+                        // passphrase and request user to accept/reject.
+                        if (processProvisionDiscoveryRequestForV2ConnectionOnP2pDevice(
+                                (WifiP2pProvDiscEvent) message.obj)) {
+                            notifyP2pProvDiscShowPinRequest(getPinOrPassphraseFromSavedPeerConfig(),
+                                    mSavedPeerConfig.deviceAddress);
+                            p2pConnectWithPinDisplay(mSavedPeerConfig,
+                                    P2P_CONNECT_TRIGGER_GROUP_NEG_REQ);
+                            smTransition(this, mGroupNegotiationState);
+                        }
+                        break;
+                    }
                     case WifiP2pManager.CREATE_GROUP: {
                         String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
                         if (packageName == null) {
@@ -4003,16 +4055,21 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                         : WifiManager.API_P2P_CREATE_GROUP_P2P_CONFIG,
                                 Process.myTid(), uid, 0, packageName, true);
                         boolean ret = false;
-                        if (config != null) {
-                            if (isConfigValidAsGroup(config)) {
-                                if (mVerboseLoggingEnabled) {
-                                    logd("FAST_CONNECTION GO band freq: "
-                                            + getGroupOwnerBandToString(config.groupOwnerBand));
-                                }
-                                reportConnectionEventTakeBugReportIfOverlapped(
-                                        P2pConnectionEvent.CONNECTION_FAST,
-                                        config, GroupEvent.GROUP_OWNER, uid, attributionTag);
-                                ret = mWifiNative.p2pGroupAdd(config, false);
+                        if (isConfigValidAsGroup(config)) {
+                            if (mVerboseLoggingEnabled) {
+                                logd("FAST_CONNECTION GO band freq: "
+                                        + getGroupOwnerBandToString(config.groupOwnerBand));
+                            }
+                            reportConnectionEventTakeBugReportIfOverlapped(
+                                    P2pConnectionEvent.CONNECTION_FAST,
+                                    config, GroupEvent.GROUP_OWNER, uid, attributionTag);
+                            ret = mWifiNative.p2pGroupAdd(config, false);
+                        } else if (isConfigForGroupOwnerV2(config)) {
+                            logd("Requested to create Group Owner - V2");
+                            // TODO check if the configuration is to start persistent connection.
+                            // TODO check if the persistent group is present
+                            if (isWifiDirect2Enabled()) {
+                                ret = mWifiNative.p2pGroupAdd(false, true);
                             }
                         } else if (netId == WifiP2pGroup.NETWORK_ID_PERSISTENT) {
                             // check if the go persistent group is present.
@@ -4021,18 +4078,18 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                 mWifiP2pMetrics.startConnectionEvent(
                                         P2pConnectionEvent.CONNECTION_REINVOKE,
                                         null, GroupEvent.GROUP_OWNER, uid, attributionTag);
-                                ret = mWifiNative.p2pGroupAdd(netId);
+                                ret = mWifiNative.p2pGroupAdd(netId, false);
                             } else {
                                 mWifiP2pMetrics.startConnectionEvent(
                                         P2pConnectionEvent.CONNECTION_LOCAL,
                                         null, GroupEvent.GROUP_OWNER, uid, attributionTag);
-                                ret = mWifiNative.p2pGroupAdd(true);
+                                ret = mWifiNative.p2pGroupAdd(true, false);
                             }
                         } else {
                             mWifiP2pMetrics.startConnectionEvent(
                                     P2pConnectionEvent.CONNECTION_LOCAL,
                                     null, GroupEvent.GROUP_OWNER, uid, attributionTag);
-                            ret = mWifiNative.p2pGroupAdd(false);
+                            ret = mWifiNative.p2pGroupAdd(false, false);
                         }
 
                         if (ret) {
@@ -4213,14 +4270,76 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             }
         }
 
-        class IdleState extends RunnerState {
+        class P2pRejectWaitState extends RunnerState {
+
+            /**
+             * The Runner state Constructor
+             *
+             * @param threshold the running time threshold in milliseconds
+             */
+            P2pRejectWaitState(int threshold, @NonNull LocalLog localLog) {
+                super(threshold, localLog);
+            }
+
+            @Override
+            public void enterImpl() {
+                if (mVerboseLoggingEnabled) logd(getName());
+            }
+
+            @Override
+            public void exitImpl() {
+
+            }
+
+            @Override
+            public boolean processMessageImpl(Message message) {
+                boolean ret = HANDLED;
+                switch (message.what) {
+                    case P2P_REJECTION_RESUME_AFTER_DELAY:
+                        if (sP2pRejectionResumeAfterDelayIndex == message.arg1) {
+                            logd(
+                                    "P2p rejection resume after delay - originated from "
+                                            + getWhatToString(message.what));
+                            if (message.arg2 == WifiP2pManager.CANCEL_CONNECT) {
+                                handleGroupCreationFailure(WifiP2pManager
+                                        .GROUP_CREATION_FAILURE_REASON_CONNECTION_CANCELLED);
+                                if (message.obj != null) {
+                                    replyToMessage(
+                                            (Message) message.obj,
+                                            WifiP2pManager.CANCEL_CONNECT_SUCCEEDED);
+                                }
+                            }
+                            transitionTo(mInactiveState);
+                        } else {
+                            loge(
+                                    "Stale P2p rejection resume after delay - cached index: "
+                                            + sP2pRejectionResumeAfterDelayIndex
+                                            + " index from msg: "
+                                            + message.arg1);
+                        }
+                        break;
+                    default:
+                        ret = NOT_HANDLED;
+                }
+                return ret;
+            }
+
+            @Override
+            public String getMessageLogRec(int what) {
+                return P2pStateMachine.class.getSimpleName() + "."
+                        + this.getClass().getSimpleName()
+                        + "." + getWhatToString(what);
+            }
+        }
+
+        class GroupCreatingState extends RunnerState {
 
             /**
              * The Runner state Constructor
              *
              * @param threshold the running time threshold in milliseconds
              */
-            IdleState(int threshold, @NonNull LocalLog localLog) {
+            GroupCreatingState(int threshold, @NonNull LocalLog localLog) {
                 super(threshold, localLog);
             }
 
@@ -4228,590 +4347,39 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             public void enterImpl() {
                 logSmStateName(this.getName(),
                         getCurrentState() != null ? getCurrentState().getName() : "");
-                mPeerAuthorizingTimestamp.clear();
-                mSavedPeerConfig.invalidate();
-                mDetailedState = NetworkInfo.DetailedState.IDLE;
-                mConnectionPkgName = SHARED_PKG_NAME;
-                scheduleIdleShutdown();
+                onGroupCreating();
+                if (SdkLevel.isAtLeastT()) {
+                    mDetailedState = NetworkInfo.DetailedState.CONNECTING;
+                    sendP2pConnectionChangedBroadcast();
+                }
+                sendMessageDelayed(obtainMessage(GROUP_CREATING_TIMED_OUT,
+                        ++sGroupCreatingTimeoutIndex, 0), GROUP_CREATING_WAIT_TIME_MS);
             }
 
             @Override
             public void exitImpl() {
-                cancelIdleShutdown();
+
             }
 
             @Override
             public boolean processMessageImpl(Message message) {
                 logSmMessage(getName(), message);
-                // Re-schedule the shutdown timer since we got the new operation.
-                // only handle commands from clients.
-                if (message.what > Protocol.BASE_WIFI_P2P_MANAGER
-                        && message.what < Protocol.BASE_WIFI_P2P_SERVICE) {
-                    scheduleIdleShutdown();
-                }
+                boolean ret = HANDLED;
                 switch (message.what) {
-                    case WifiP2pManager.CONNECT: {
-                        String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
-                        if (packageName == null) {
-                            replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
-                            break;
-                        }
-                        int uid = message.sendingUid;
-                        String attributionTag = getCallingFeatureId(uid, message.replyTo);
-                        Bundle extras = message.getData()
-                                .getBundle(WifiP2pManager.EXTRA_PARAM_KEY_BUNDLE);
-                        boolean hasPermission = false;
-                        if (isPlatformOrTargetSdkLessThanT(packageName, uid)) {
-                            hasPermission = mWifiPermissionsUtil.checkCanAccessWifiDirect(
-                                    packageName,
-                                    attributionTag,
-                                    uid, false);
-                        } else {
-                            hasPermission = checkNearbyDevicesPermission(uid, packageName,
-                                    extras, "CONNECT", message.obj);
-                        }
-                        if (!hasPermission) {
-                            replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
-                            // remain at this state.
-                            break;
-                        }
-                        mLastCallerInfoManager.put(WifiManager.API_P2P_CONNECT,
-                                Process.myTid(), uid, 0, packageName, true);
-                        if (mVerboseLoggingEnabled) logd(getName() + " sending connect");
-                        WifiP2pConfig config = (WifiP2pConfig)
-                                extras.getParcelable(WifiP2pManager.EXTRA_PARAM_KEY_CONFIG);
-
-                        boolean isConnectFailed = false;
-                        if (isConfigValidAsGroup(config)) {
-                            mAutonomousGroup = false;
-                            mWifiNative.p2pStopFind();
-                            if (mVerboseLoggingEnabled) {
-                                logd("FAST_CONNECTION GC band freq: " + getGroupOwnerBandToString(
-                                        config.groupOwnerBand));
-                            }
-                            if (mWifiNative.p2pGroupAdd(config, true)) {
-                                reportConnectionEventTakeBugReportIfOverlapped(
-                                        P2pConnectionEvent.CONNECTION_FAST,
-                                        config, WifiMetricsProto.GroupEvent.GROUP_CLIENT, uid,
-                                        attributionTag);
-                                mConnectionPkgName = packageName;
-                                smTransition(this, mGroupNegotiationState);
-                            } else {
-                                loge("Cannot join a group with config.");
-                                isConnectFailed = true;
-                                replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
-                            }
-                        } else {
-                            if (isConfigInvalid(config)) {
-                                loge("Dropping connect request " + config);
-                                isConnectFailed = true;
-                                replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
-                            } else {
-                                mAutonomousGroup = false;
-                                mWifiNative.p2pStopFind();
-                                if (reinvokePersistentGroup(config, false)) {
-                                    mWifiP2pMetrics.startConnectionEvent(
-                                            P2pConnectionEvent.CONNECTION_REINVOKE,
-                                            config, GroupEvent.GROUP_UNKNOWN, uid, attributionTag);
-                                    smTransition(this, mGroupNegotiationState);
-                                } else {
-                                    mWifiP2pMetrics.startConnectionEvent(
-                                            P2pConnectionEvent.CONNECTION_FRESH,
-                                            config, GroupEvent.GROUP_UNKNOWN, uid, attributionTag);
-                                    smTransition(this, mProvisionDiscoveryState);
-                                }
-                            }
-                        }
-
-                        if (!isConnectFailed) {
-                            mSavedPeerConfig = config;
-                            mPeers.updateStatus(mSavedPeerConfig.deviceAddress,
-                                    WifiP2pDevice.INVITED);
-                            sendPeersChangedBroadcast();
-                            replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
-                        }
-                        break;
-                    }
-                    case WifiP2pManager.STOP_DISCOVERY:
-                        mLastCallerInfoManager.put(WifiManager.API_P2P_STOP_PEER_DISCOVERY,
-                                Process.myTid(), message.sendingUid, 0,
-                                getCallingPkgName(message.sendingUid, message.replyTo), true);
-                        if (mWifiNative.p2pStopFind()) {
-                            // When discovery stops in inactive state, flush to clear
-                            // state peer data
-                            mWifiNative.p2pFlush();
-                            mServiceDiscReqId = null;
-                            replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
-                        } else {
-                            replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED,
-                                    WifiP2pManager.ERROR);
-                        }
-                        break;
-                    case CMD_P2P_IDLE_SHUTDOWN:
-                        Log.d(TAG, "IdleShutDown message received");
-                        sendMessage(DISABLE_P2P);
-                        break;
-                    case WifiP2pMonitor.P2P_GO_NEGOTIATION_REQUEST_EVENT:
-                        WifiP2pConfig config = (WifiP2pConfig) message.obj;
-                        if (isConfigInvalid(config)) {
-                            loge("Dropping GO neg request " + config);
-                            break;
-                        }
-                        mSavedPeerConfig = config;
-                        mAutonomousGroup = false;
-                        mJoinExistingGroup = false;
-                        mWifiP2pMetrics.startConnectionEvent(
-                                P2pConnectionEvent.CONNECTION_FRESH,
-                                config, GroupEvent.GROUP_UNKNOWN, Process.SYSTEM_UID, null);
-                        smTransition(this, mUserAuthorizingNegotiationRequestState);
-                        break;
-                    case WifiP2pMonitor.P2P_INVITATION_RECEIVED_EVENT:
-                        if (message.obj == null) {
-                            Log.e(TAG, "Invalid argument(s)");
-                            break;
-                        }
-                        WifiP2pGroup group = (WifiP2pGroup) message.obj;
-                        WifiP2pDevice owner = group.getOwner();
-                        if (owner == null) {
-                            int id = group.getNetworkId();
-                            if (id < 0) {
-                                loge("Ignored invitation from null owner");
-                                break;
-                            }
-
-                            String addr = mGroups.getOwnerAddr(id);
-                            if (addr != null) {
-                                group.setOwner(new WifiP2pDevice(addr));
-                                owner = group.getOwner();
-                            } else {
-                                loge("Ignored invitation from null owner");
-                                break;
-                            }
-                        }
-                        config = new WifiP2pConfig();
-                        config.deviceAddress = group.getOwner().deviceAddress;
-                        if (isConfigInvalid(config)) {
-                            loge("Dropping invitation request " + config);
-                            break;
-                        }
-                        mSavedPeerConfig = config;
-
-                        // Check if we have the owner in peer list and use appropriate
-                        // wps method. Default is to use PBC.
-                        if (owner != null && ((owner = mPeers.get(owner.deviceAddress)) != null)) {
-                            if (owner.wpsPbcSupported()) {
-                                mSavedPeerConfig.wps.setup = WpsInfo.PBC;
-                            } else if (owner.wpsKeypadSupported()) {
-                                mSavedPeerConfig.wps.setup = WpsInfo.KEYPAD;
-                            } else if (owner.wpsDisplaySupported()) {
-                                mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
-                            }
-                        }
-
-                        mAutonomousGroup = false;
-                        mJoinExistingGroup = true;
-                        mWifiP2pMetrics.startConnectionEvent(
-                                P2pConnectionEvent.CONNECTION_FRESH,
-                                config, GroupEvent.GROUP_UNKNOWN, Process.SYSTEM_UID, null);
-                        smTransition(this, mUserAuthorizingInviteRequestState);
-                        break;
-                    case WifiP2pMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
-                    case WifiP2pMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
-                        // We let the supplicant handle the provision discovery response
-                        // and wait instead for the GO_NEGOTIATION_REQUEST_EVENT.
-                        // Handling provision discovery and issuing a p2p_connect before
-                        // group negotiation comes through causes issues
-                        break;
-                    case WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
-                        if (message.obj == null) {
-                            Log.e(TAG, "Illegal argument(s)");
-                            break;
-                        }
-                        WifiP2pProvDiscEvent provDisc = (WifiP2pProvDiscEvent) message.obj;
-                        WifiP2pDevice device = provDisc.device;
-                        if (device == null) {
-                            loge("Device entry is null");
-                            break;
-                        }
-                        mSavedPeerConfig = new WifiP2pConfig();
-                        mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
-                        mSavedPeerConfig.deviceAddress = device.deviceAddress;
-                        mSavedPeerConfig.wps.pin = provDisc.pin;
-                        if (SdkLevel.isAtLeastV() && provDisc.getVendorData() != null) {
-                            mSavedPeerConfig.setVendorData(provDisc.getVendorData());
-                        }
-
-                        notifyP2pProvDiscShowPinRequest(provDisc.pin, device.deviceAddress);
-                        mPeers.updateStatus(device.deviceAddress, WifiP2pDevice.INVITED);
-                        sendPeersChangedBroadcast();
-                        smTransition(this, mUserAuthorizingNegotiationRequestState);
-                        break;
-                    case WifiP2pManager.CREATE_GROUP: {
-                        String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
-                        if (packageName == null) {
-                            replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED,
-                                    WifiP2pManager.ERROR);
-                            break;
-                        }
-                        int uid = message.sendingUid;
-                        String attributionTag = getCallingFeatureId(uid, message.replyTo);
-                        Bundle extras = message.getData()
-                                .getBundle(WifiP2pManager.EXTRA_PARAM_KEY_BUNDLE);
-                        boolean hasPermission;
-                        if (isPlatformOrTargetSdkLessThanT(packageName, uid)) {
-                            hasPermission = mWifiPermissionsUtil.checkCanAccessWifiDirect(
-                                    packageName,
-                                    attributionTag,
-                                    uid, false);
-                        } else {
-                            hasPermission = checkNearbyDevicesPermission(uid, packageName,
-                                    extras, "CREATE_GROUP", message.obj);
-                        }
-                        if (!hasPermission) {
-                            replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED,
-                                    WifiP2pManager.ERROR);
-                            // remain at this state.
-                            break;
-                        }
-                        mAutonomousGroup = true;
-                        int netId = message.arg1;
-                        config = extras.getParcelable(WifiP2pManager.EXTRA_PARAM_KEY_CONFIG);
-                        mLastCallerInfoManager.put(config == null
-                                        ? WifiManager.API_P2P_CREATE_GROUP
-                                        : WifiManager.API_P2P_CREATE_GROUP_P2P_CONFIG,
-                                Process.myTid(), uid, 0, packageName, true);
-                        boolean ret = false;
-                        if (config != null && isConfigValidAsGroup(config)) {
-                                mConnectionPkgName = packageName;
-                                if (mVerboseLoggingEnabled) {
-                                    logd("FAST_CONNECTION GO band freq: "
-                                            + getGroupOwnerBandToString(config.groupOwnerBand));
-                                }
-                                reportConnectionEventTakeBugReportIfOverlapped(
-                                        P2pConnectionEvent.CONNECTION_FAST,
-                                        config, GroupEvent.GROUP_OWNER, uid, attributionTag);
-                                ret = mWifiNative.p2pGroupAdd(config, false);
-                        } else if (isConfigForGroupOwnerV2(config)) {
-                            logd("Requested to create Group Owner - V2");
-                            // TODO implementation
-                        } else if (netId == WifiP2pGroup.NETWORK_ID_PERSISTENT) {
-                            // check if the go persistent group is present.
-                            netId = mGroups.getNetworkId(mThisDevice.deviceAddress);
-                            if (netId != -1) {
-                                mWifiP2pMetrics.startConnectionEvent(
-                                        P2pConnectionEvent.CONNECTION_REINVOKE,
-                                        null, GroupEvent.GROUP_OWNER, uid, attributionTag);
-                                ret = mWifiNative.p2pGroupAdd(netId);
-                            } else {
-                                mWifiP2pMetrics.startConnectionEvent(
-                                        P2pConnectionEvent.CONNECTION_LOCAL,
-                                        null, GroupEvent.GROUP_OWNER, uid, attributionTag);
-                                ret = mWifiNative.p2pGroupAdd(true);
-                            }
-                        } else {
-                            mWifiP2pMetrics.startConnectionEvent(
-                                    P2pConnectionEvent.CONNECTION_LOCAL,
-                                    null, GroupEvent.GROUP_OWNER, uid, attributionTag);
-                            ret = mWifiNative.p2pGroupAdd(false);
-                        }
-
-                        if (ret) {
-                            replyToMessage(message, WifiP2pManager.CREATE_GROUP_SUCCEEDED);
-                            smTransition(this, mGroupNegotiationState);
-                        } else {
-                            mConnectionPkgName = SHARED_PKG_NAME;
-                            replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED,
-                                    WifiP2pManager.ERROR);
-                            // remain at this state.
-                            String errorMsg = "P2P group creating failed";
-                            if (mVerboseLoggingEnabled) logd(getName() + errorMsg);
-                            if (mWifiP2pMetrics.isP2pFastConnectionType()) {
-                                takeBugReportP2pFailureIfNeeded("Wi-Fi BugReport (P2P "
-                                        + mWifiP2pMetrics.getP2pGroupRoleString()
-                                        + " creation failure)", errorMsg);
-                            }
-                            mWifiP2pMetrics.endConnectionEvent(
-                                    P2pConnectionEvent.CLF_CREATE_GROUP_FAILED);
-                        }
-                        break;
-                    }
-                    case WifiP2pMonitor.P2P_GROUP_STARTED_EVENT:
-                        if (message.obj == null) {
-                            Log.e(TAG, "Invalid argument(s)");
-                            break;
-                        }
-                        mGroup = (WifiP2pGroup) message.obj;
-                        if (mVerboseLoggingEnabled) logd(getName() + " group started");
-                        if (mGroup.isGroupOwner()
-                                && EMPTY_DEVICE_ADDRESS.equals(mGroup.getOwner().deviceAddress)) {
-                            // wpa_supplicant doesn't set own device address to go_dev_addr.
-                            mGroup.getOwner().deviceAddress = mThisDevice.deviceAddress;
-                        }
-                        // We hit this scenario when a persistent group is reinvoked
-                        if (mGroup.getNetworkId() == WifiP2pGroup.NETWORK_ID_PERSISTENT) {
-                            mAutonomousGroup = false;
-                            deferMessage(message);
-                            smTransition(this, mGroupNegotiationState);
-                        } else {
-                            loge("Unexpected group creation, remove " + mGroup);
-                            mWifiNative.p2pGroupRemove(mGroup.getInterface());
-                            mGroup = null;
-                        }
-                        break;
-                    case WifiP2pManager.START_LISTEN:
-                        String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
-                        if (packageName == null) {
-                            replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
-                            break;
-                        }
-                        int uid = message.sendingUid;
-                        int listenType = message.arg1;
-                        if (listenType == WifiP2pManager.WIFI_P2P_EXT_LISTEN_WITH_PARAMS
-                                && !SdkLevel.isAtLeastV()) {
-                            replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
-                            break;
-                        }
-                        Bundle extras = message.getData()
-                                .getBundle(WifiP2pManager.EXTRA_PARAM_KEY_BUNDLE);
-                        WifiP2pExtListenParams extListenParams = SdkLevel.isAtLeastV()
-                                && (listenType == WifiP2pManager.WIFI_P2P_EXT_LISTEN_WITH_PARAMS)
-                                ? extras.getParcelable(
-                                WifiP2pManager.EXTRA_PARAM_KEY_EXT_LISTEN_PARAMS,
-                                WifiP2pExtListenParams.class)
-                                : null;
-                        boolean hasPermission;
-                        if (isPlatformOrTargetSdkLessThanT(packageName, uid)) {
-                            hasPermission = mWifiPermissionsUtil.checkCanAccessWifiDirect(
-                                    packageName,
-                                    getCallingFeatureId(message.sendingUid, message.replyTo),
-                                    uid, true);
-                        } else {
-                            hasPermission = checkNearbyDevicesPermission(uid, packageName,
-                                    extras, "START_LISTEN", message.obj);
-                        }
-                        if (!hasPermission) {
-                            replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
-                            break;
-                        }
-                        mLastCallerInfoManager.put(WifiManager.API_P2P_START_LISTENING,
-                                Process.myTid(), uid, 0, packageName, true);
-                        if (mVerboseLoggingEnabled) logd(getName() + " start listen mode");
-                        mWifiNative.p2pStopFind();
-                        if (mWifiNative.p2pExtListen(true,
-                                mContext.getResources().getInteger(
-                                        R.integer.config_wifiP2pExtListenPeriodMs),
-                                mContext.getResources().getInteger(
-                                        R.integer.config_wifiP2pExtListenIntervalMs),
-                                extListenParams)) {
-                            replyToMessage(message, WifiP2pManager.START_LISTEN_SUCCEEDED);
-                            sendP2pListenChangedBroadcast(true);
-                        } else {
-                            replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
-                        }
-                        break;
-                    case WifiP2pManager.STOP_LISTEN:
-                        mLastCallerInfoManager.put(WifiManager.API_P2P_STOP_LISTENING,
-                                Process.myTid(), message.sendingUid, 0,
-                                getCallingPkgName(message.sendingUid, message.replyTo), true);
-                        if (mVerboseLoggingEnabled) logd(getName() + " stop listen mode");
-                        if (mWifiNative.p2pExtListen(false, 0, 0, null)) {
-                            replyToMessage(message, WifiP2pManager.STOP_LISTEN_SUCCEEDED);
-                            sendP2pListenChangedBroadcast(false);
-                        } else {
-                            replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED);
-                        }
-                        mWifiNative.p2pStopFind();
-                        break;
-                    case WifiP2pManager.SET_CHANNEL:
-                        if (!checkNetworkSettingsOrNetworkStackOrOverrideWifiConfigPermission(
-                                message.sendingUid)) {
-                            loge("Permission violation - none of NETWORK_SETTING, NETWORK_STACK,"
-                                    + " or OVERRIDE_WIFI_CONFIG permission, uid = "
-                                    + message.sendingUid);
-                            replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED,
-                                    WifiP2pManager.ERROR);
-                            break;
-                        }
-                        if (message.obj == null) {
-                            Log.e(TAG, "Illegal arguments(s)");
-                            break;
-                        }
-                        mLastCallerInfoManager.put(WifiManager.API_P2P_SET_CHANNELS,
-                                Process.myTid(), message.sendingUid, 0,
-                                getCallingPkgName(message.sendingUid, message.replyTo), true);
-                        Bundle p2pChannels = (Bundle) message.obj;
-                        mUserListenChannel = p2pChannels.getInt("lc", 0);
-                        mUserOperatingChannel = p2pChannels.getInt("oc", 0);
-                        if (updateP2pChannels()) {
-                            replyToMessage(message, WifiP2pManager.SET_CHANNEL_SUCCEEDED);
-                        } else {
-                            replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED);
-                        }
-                        break;
-                    case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:
-                        String handoverSelect = null;
-
-                        if (message.obj != null) {
-                            handoverSelect = ((Bundle) message.obj)
-                                    .getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
-                        }
-
-                        if (handoverSelect != null
-                                && mWifiNative.initiatorReportNfcHandover(handoverSelect)) {
-                            replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
-                            smTransition(this, mGroupCreatingState);
-                        } else {
-                            replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
-                        }
-                        break;
-                    case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:
-                        String handoverRequest = null;
-
-                        if (message.obj != null) {
-                            handoverRequest = ((Bundle) message.obj)
-                                    .getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
-                        }
-
-                        if (handoverRequest != null
-                                && mWifiNative.responderReportNfcHandover(handoverRequest)) {
-                            replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
-                            smTransition(this, mGroupCreatingState);
-                        } else {
-                            replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
-                        }
-                        break;
-                    default:
-                        return NOT_HANDLED;
-                }
-                return HANDLED;
-            }
-
-            @Override
-            public String getMessageLogRec(int what) {
-                return P2pStateMachine.class.getSimpleName() + "."
-                        + this.getClass().getSimpleName()
-                        + "." + getWhatToString(what);
-            }
-        }
-
-        class P2pRejectWaitState extends RunnerState {
-
-            /**
-             * The Runner state Constructor
-             *
-             * @param threshold the running time threshold in milliseconds
-             */
-            P2pRejectWaitState(int threshold, @NonNull LocalLog localLog) {
-                super(threshold, localLog);
-            }
-
-            @Override
-            public void enterImpl() {
-                if (mVerboseLoggingEnabled) logd(getName());
-            }
-
-            @Override
-            public void exitImpl() {
-
-            }
-
-            @Override
-            public boolean processMessageImpl(Message message) {
-                boolean ret = HANDLED;
-                switch (message.what) {
-                    case P2P_REJECTION_RESUME_AFTER_DELAY:
-                        if (sP2pRejectionResumeAfterDelayIndex == message.arg1) {
-                            logd(
-                                    "P2p rejection resume after delay - originated from "
-                                            + getWhatToString(message.what));
-                            if (message.arg2 == WifiP2pManager.CANCEL_CONNECT) {
-                                handleGroupCreationFailure(WifiP2pManager
-                                        .GROUP_CREATION_FAILURE_REASON_CONNECTION_CANCELLED);
-                                if (message.obj != null) {
-                                    replyToMessage(
-                                            (Message) message.obj,
-                                            WifiP2pManager.CANCEL_CONNECT_SUCCEEDED);
-                                }
-                            }
-                            if (mFeatureFlags.p2pOwnership()) {
-                                smTransition(this, mIdleState);
-                            } else {
-                                smTransition(this, mInactiveState);
-                            }
-                        } else {
-                            loge(
-                                    "Stale P2p rejection resume after delay - cached index: "
-                                            + sP2pRejectionResumeAfterDelayIndex
-                                            + " index from msg: "
-                                            + message.arg1);
-                        }
-                        break;
-                    default:
-                        ret = NOT_HANDLED;
-                }
-                return ret;
-            }
-
-            @Override
-            public String getMessageLogRec(int what) {
-                return P2pStateMachine.class.getSimpleName() + "."
-                        + this.getClass().getSimpleName()
-                        + "." + getWhatToString(what);
-            }
-        }
-
-        class GroupCreatingState extends RunnerState {
-
-            /**
-             * The Runner state Constructor
-             *
-             * @param threshold the running time threshold in milliseconds
-             */
-            GroupCreatingState(int threshold, @NonNull LocalLog localLog) {
-                super(threshold, localLog);
-            }
-
-            @Override
-            public void enterImpl() {
-                logSmStateName(this.getName(),
-                        getCurrentState() != null ? getCurrentState().getName() : "");
-                onGroupCreating();
-                if (SdkLevel.isAtLeastT()) {
-                    mDetailedState = NetworkInfo.DetailedState.CONNECTING;
-                    sendP2pConnectionChangedBroadcast();
-                }
-                sendMessageDelayed(obtainMessage(GROUP_CREATING_TIMED_OUT,
-                        ++sGroupCreatingTimeoutIndex, 0), GROUP_CREATING_WAIT_TIME_MS);
-            }
-
-            @Override
-            public void exitImpl() {
-
-            }
-
-            @Override
-            public boolean processMessageImpl(Message message) {
-                logSmMessage(getName(), message);
-                boolean ret = HANDLED;
-                switch (message.what) {
-                    case GROUP_CREATING_TIMED_OUT:
-                        if (sGroupCreatingTimeoutIndex == message.arg1) {
-                            String errorMsg = "P2P group negotiation timed out";
-                            if (mVerboseLoggingEnabled) logd(getName() + errorMsg);
-                            if (mWifiP2pMetrics.isP2pFastConnectionType()) {
-                                takeBugReportP2pFailureIfNeeded("Wi-Fi BugReport (P2P "
-                                        + mWifiP2pMetrics.getP2pGroupRoleString()
-                                        + " creation failure)", errorMsg);
-                            }
-                            mWifiP2pMetrics.endConnectionEvent(
-                                    P2pConnectionEvent.CLF_TIMEOUT);
-                            handleGroupCreationFailure(
-                                    WifiP2pManager.GROUP_CREATION_FAILURE_REASON_TIMED_OUT);
-                            if (mFeatureFlags.p2pOwnership()) {
-                                smTransition(this, mIdleState);
-                            } else {
-                                smTransition(this, mInactiveState);
-                            }
+                    case GROUP_CREATING_TIMED_OUT:
+                        if (sGroupCreatingTimeoutIndex == message.arg1) {
+                            String errorMsg = "P2P group negotiation timed out";
+                            if (mVerboseLoggingEnabled) logd(getName() + errorMsg);
+                            if (mWifiP2pMetrics.isP2pFastConnectionType()) {
+                                takeBugReportP2pFailureIfNeeded("Wi-Fi BugReport (P2P "
+                                        + mWifiP2pMetrics.getP2pGroupRoleString()
+                                        + " creation failure)", errorMsg);
+                            }
+                            mWifiP2pMetrics.endConnectionEvent(
+                                    P2pConnectionEvent.CLF_TIMEOUT);
+                            handleGroupCreationFailure(
+                                    WifiP2pManager.GROUP_CREATION_FAILURE_REASON_TIMED_OUT);
+                            smTransition(this, mInactiveState);
                         }
                         break;
                     case WifiP2pMonitor.P2P_DEVICE_LOST_EVENT:
@@ -4863,16 +4431,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         // discovery or for a pending user action, but at the framework
                         // level, we always treat cancel as succeeded and enter
                         // an inactive state
-                        String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
-                        if (mFeatureFlags.p2pOwnership()
-                                && mConnectionPkgName != packageName
-                                && mConnectionPkgName != SHARED_PKG_NAME) {
-                            replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED,
-                                    WifiP2pManager.BUSY);
-                            logd("Cancel connect requested by " + packageName
-                                    + " when connection is initiated by " + mConnectionPkgName);
-                            break;
-                        }
                         mLastCallerInfoManager.put(WifiManager.API_P2P_CANCEL_CONNECT,
                                 Process.myTid(), message.sendingUid, 0,
                                 getCallingPkgName(message.sendingUid, message.replyTo), true);
@@ -4930,7 +4488,9 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 logSmStateName(this.getName(),
                         getCurrentState() != null ? getCurrentState().getName() : "");
                 if (mSavedPeerConfig.wps.setup == WpsInfo.PBC
-                            || TextUtils.isEmpty(mSavedPeerConfig.wps.pin)) {
+                        || (mSavedPeerConfig.wps.setup != WpsInfo.INVALID
+                        && TextUtils.isEmpty(mSavedPeerConfig.wps.pin))
+                        || isConfigForV2Connection(mSavedPeerConfig)) {
                     notifyInvitationReceived(
                             WifiP2pManager.ExternalApproverRequestListener
                                     .REQUEST_TYPE_NEGOTIATION);
@@ -4983,15 +4543,13 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             mWifiNative.p2pCancelConnect();
                             handleGroupCreationFailure(
                                     WifiP2pManager.GROUP_CREATION_FAILURE_REASON_USER_REJECTED);
-                            if (mFeatureFlags.p2pOwnership()) {
-                                smTransition(this, mIdleState);
-                            } else {
-                                smTransition(this, mInactiveState);
-                            }
+                            smTransition(this, mInactiveState);
                         }
                         break;
                     case PEER_CONNECTION_USER_CONFIRM:
-                        mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
+                        if (!isConfigForV2Connection(mSavedPeerConfig)) {
+                            mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
+                        }
                         mSavedPeerConfig.groupOwnerIntent =
                                 selectGroupOwnerIntentIfNecessary(mSavedPeerConfig);
                         mWifiNative.p2pConnect(mSavedPeerConfig, FORM_GROUP);
@@ -5001,11 +4559,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         loge("provision discovery failed status: " + message.arg1);
                         handleGroupCreationFailure(WifiP2pManager
                                 .GROUP_CREATION_FAILURE_REASON_PROVISION_DISCOVERY_FAILED);
-                        if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mIdleState);
-                        } else {
-                            smTransition(this, mInactiveState);
-                        }
+                        smTransition(this, mInactiveState);
                         break;
                     case WifiP2pManager.SET_CONNECTION_REQUEST_RESULT: {
                         if (!handleSetConnectionResult(message,
@@ -5085,21 +4639,13 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         if (mVerboseLoggingEnabled) {
                             logd("User rejected invitation " + mSavedPeerConfig);
                         }
-                        if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mIdleState);
-                        } else {
-                            smTransition(this, mInactiveState);
-                        }
+                        smTransition(this, mInactiveState);
                         break;
                     case WifiP2pMonitor.P2P_PROV_DISC_FAILURE_EVENT:
                         loge("provision discovery failed status: " + message.arg1);
                         handleGroupCreationFailure(WifiP2pManager
                                 .GROUP_CREATION_FAILURE_REASON_PROVISION_DISCOVERY_FAILED);
-                        if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mIdleState);
-                        } else {
-                            smTransition(this, mInactiveState);
-                        }
+                        smTransition(this, mInactiveState);
                         break;
                     case WifiP2pManager.SET_CONNECTION_REQUEST_RESULT:
                         if (!handleSetConnectionResult(message,
@@ -5205,12 +4751,12 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             if (TextUtils.isEmpty(mSavedPeerConfig.wps.pin)) {
                                 // Some implementations get the PIN OOB and deliver it from
                                 // Supplicant. This is to avoid connecting with the dialog box
-                                mSavedPeerConfig.wps.pin = provDisc.pin;
+                                mSavedPeerConfig.wps.pin = provDisc.wpsPin;
                             }
                             // we already have the pin
                             if (!TextUtils.isEmpty(mSavedPeerConfig.wps.pin)) {
                                 p2pConnectWithPinDisplay(mSavedPeerConfig,
-                                                         P2P_CONNECT_TRIGGER_OTHER);
+                                        P2P_CONNECT_TRIGGER_OTHER);
                                 smTransition(this, mGroupNegotiationState);
                             } else {
                                 mJoinExistingGroup = false;
@@ -5236,12 +4782,91 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             if (mVerboseLoggingEnabled) {
                                 logd("Found a match " + mSavedPeerConfig);
                             }
-                            mSavedPeerConfig.wps.pin = provDisc.pin;
+                            mSavedPeerConfig.wps.pin = provDisc.wpsPin;
                             p2pConnectWithPinDisplay(mSavedPeerConfig, P2P_CONNECT_TRIGGER_OTHER);
-                            notifyInvitationSent(provDisc.pin, device.deviceAddress);
+                            notifyInvitationSent(provDisc.wpsPin, device.deviceAddress);
                             smTransition(this, mGroupNegotiationState);
                         }
                         break;
+                    case WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT:
+                        if (message.obj == null) {
+                            Log.e(TAG, "Invalid argument(s)");
+                            break;
+                        }
+                        provDisc = (WifiP2pProvDiscEvent) message.obj;
+                        device = provDisc.device;
+                        if (device != null
+                                && !device.deviceAddress.equals(mSavedPeerConfig.deviceAddress)) {
+                            break;
+                        }
+                        if (isConfigForBootstrappingMethodOpportunistic(mSavedPeerConfig)) {
+                            if (!provDisc.isComeback) {
+                                logd("Peer accepted the bootstrapping request " + mSavedPeerConfig
+                                        + " Initiate the pairing protocol");
+                                p2pConnectWithPinDisplay(mSavedPeerConfig,
+                                        P2P_CONNECT_TRIGGER_OTHER);
+                                smTransition(this, mGroupNegotiationState);
+                            }
+                        } else {
+                            loge("Error in mapping pairingBootstrappingMethod");
+                        }
+                        break;
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT:
+                        if (message.obj == null) {
+                            Log.e(TAG, "Illegal argument(s)");
+                            break;
+                        }
+                        provDisc = (WifiP2pProvDiscEvent) message.obj;
+                        device = provDisc.device;
+                        if (device != null
+                                && !device.deviceAddress.equals(mSavedPeerConfig.deviceAddress)) {
+                            break;
+                        }
+                        if (isConfigForBootstrappingMethodKeypadPinOrPassphrase(mSavedPeerConfig)) {
+                            if (mVerboseLoggingEnabled) {
+                                logd("Found a match " + mSavedPeerConfig);
+                            }
+                            mJoinExistingGroup = false;
+                            smTransition(this, mUserAuthorizingNegotiationRequestState);
+                        } else {
+                            loge("Error in mapping pairingBootstrappingMethod");
+                        }
+                        break;
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT: {
+                        if (message.obj == null) {
+                            Log.e(TAG, "Illegal argument(s)");
+                            break;
+                        }
+                        provDisc = (WifiP2pProvDiscEvent) message.obj;
+                        device = provDisc.device;
+                        if (device == null) {
+                            Log.e(TAG, "Invalid device");
+                            break;
+                        }
+                        if (!device.deviceAddress.equals(mSavedPeerConfig.deviceAddress)) {
+                            break;
+                        }
+                        if (isConfigForBootstrappingMethodDisplayPinOrPassphrase(
+                                mSavedPeerConfig)) {
+                            setDisplayPinOrPassphraseInSavedPeerConfigIfNeeded();
+                            if (!provDisc.isComeback) {
+                                logd("Peer accepted the bootstrapping request " + mSavedPeerConfig
+                                        + " Initiate the pairing protocol");
+                                p2pConnectWithPinDisplay(mSavedPeerConfig,
+                                        P2P_CONNECT_TRIGGER_OTHER);
+                                smTransition(this, mGroupNegotiationState);
+                            } else {
+                                logd("Display Pin/Passphrase " + mSavedPeerConfig);
+                                notifyInvitationSent(getPinOrPassphraseFromSavedPeerConfig(),
+                                        device.deviceAddress);
+                            }
+                        } else {
+                            loge("Error in mapping pairingBootstrappingMethod");
+                        }
+                        break;
+                    }
                     case WifiP2pMonitor.P2P_PROV_DISC_FAILURE_EVENT:
                         loge("provision discovery failed status: " + message.arg1);
 
@@ -5256,11 +4881,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                 P2pConnectionEvent.CLF_PROV_DISC_FAIL);
                         handleGroupCreationFailure(WifiP2pManager
                                 .GROUP_CREATION_FAILURE_REASON_PROVISION_DISCOVERY_FAILED);
-                        if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mIdleState);
-                        } else {
-                            smTransition(this, mInactiveState);
-                        }
+                        smTransition(this, mInactiveState);
                         break;
                     default:
                         return NOT_HANDLED;
@@ -5331,6 +4952,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             mGroup.setNetworkId(mGroups.getNetworkId(devAddr,
                                     mGroup.getNetworkName()));
                         }
+
                         if (mGroup.isGroupOwner()) {
                             // Setting an idle time out on GO causes issues with certain scenarios
                             // on clients where it can be off-channel for longer and with the power
@@ -5360,13 +4982,13 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             }
                             break;
                         }
-                        if (mOwnershipMap.size() >= MAX_NUM_GROUP) {
-                            Log.wtf(TAG, "group size= " + mOwnershipMap.size()
-                                    + " exceeds max number of p2p group supported");
-                        }
-                        mOwnershipMap.put(mConnectionPkgName,
-                                new WifiP2pGroupInfo(mGroup, mWifiP2pInfo, mIpClient));
+
                         mWifiNative.setP2pGroupIdle(mGroup.getInterface(), GROUP_IDLE_TIME_S);
+                        Log.d(TAG, "start Ip client with provisioning mode: "
+                                + mSavedPeerConfig.getGroupClientIpProvisioningMode());
+                        startIpClient(mGroup.getInterface(), getHandler(),
+                                mSavedPeerConfig.getGroupClientIpProvisioningMode(),
+                                mGroup.p2pClientEapolIpInfo);
                         WifiP2pDevice groupOwner = mGroup.getOwner();
                         if (!EMPTY_DEVICE_ADDRESS.equals(groupOwner.deviceAddress)) {
                             WifiP2pDevice peer = mPeers.get(groupOwner.deviceAddress);
@@ -5383,20 +5005,10 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         } else {
                             // A supplicant bug can lead to reporting an invalid
                             // group owner address (all zeroes) at times. Avoid a
-                            // crash, but continue group creation since it is not
-                            // essential.
-                            logw("Unknown group owner " + groupOwner);
-                        }
-                        // TODO: enable state transition when GroupCreatedState merged to IdleState
-                        /* if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mL3ConnectingState);
-                            break;
-                        }*/
-                        Log.d(TAG, "start Ip client with provisioning mode: "
-                                + mSavedPeerConfig.getGroupClientIpProvisioningMode());
-                        startIpClient(mGroup.getInterface(), getHandler(),
-                                mSavedPeerConfig.getGroupClientIpProvisioningMode(),
-                                mGroup.p2pClientEapolIpInfo);
+                            // crash, but continue group creation since it is not
+                            // essential.
+                            logw("Unknown group owner " + groupOwner);
+                        }
                         smTransition(this, mGroupCreatedState);
                         break;
                     case TETHER_INTERFACE_STATE_CHANGED:
@@ -5409,12 +5021,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         if (!interfaces.contains(mGroup.getInterface())) break;
 
                         Log.d(TAG, "tether " + mGroup.getInterface() + " ready");
-                        if (mOwnershipMap.size() > MAX_NUM_GROUP) {
-                            Log.wtf(TAG, "group size= " + mOwnershipMap.size()
-                                    + " exceeds max number of p2p group supported");
-                        }
-                        mOwnershipMap.put(mConnectionPkgName,
-                                new WifiP2pGroupInfo(mGroup, mWifiP2pInfo, mIpClient));
                         smTransition(this, mGroupCreatedState);
                         break;
                     case WifiP2pMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT:
@@ -5436,11 +5042,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                 P2pConnectionEvent.CLF_GROUP_REMOVED);
                         handleGroupCreationFailure(
                                 WifiP2pManager.GROUP_CREATION_FAILURE_REASON_GROUP_REMOVED);
-                        if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mIdleState);
-                        } else {
-                            smTransition(this, mInactiveState);
-                        }
+                        smTransition(this, mInactiveState);
                         break;
                     case WifiP2pMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
                         // A group formation failure is always followed by
@@ -5512,11 +5114,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                     P2pConnectionEvent.CLF_INVITATION_FAIL);
                             handleGroupCreationFailure(
                                     WifiP2pManager.GROUP_CREATION_FAILURE_REASON_INVITATION_FAILED);
-                            if (mFeatureFlags.p2pOwnership()) {
-                                smTransition(this, mIdleState);
-                            } else {
-                                smTransition(this, mInactiveState);
-                            }
+                            smTransition(this, mInactiveState);
                         }
                         break;
                     case WifiP2pMonitor.P2P_PROV_DISC_FAILURE_EVENT:
@@ -5525,11 +5123,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                 P2pConnectionEvent.CLF_GROUP_REMOVED);
                         handleGroupCreationFailure(WifiP2pManager
                                 .GROUP_CREATION_FAILURE_REASON_PROVISION_DISCOVERY_FAILED);
-                        if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mIdleState);
-                        } else {
-                            smTransition(this, mInactiveState);
-                        }
+                        smTransition(this, mInactiveState);
                         break;
                     case WifiP2pMonitor.AP_STA_CONNECTED_EVENT:
                     case WifiP2pMonitor.AP_STA_DISCONNECTED_EVENT:
@@ -5568,149 +5162,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             }
         }
 
-        class L3ConnectingState extends RunnerState {
-
-            /**
-             * The Runner state Constructor
-             *
-             * @param threshold the running time threshold in milliseconds
-             */
-            L3ConnectingState(int threshold, @NonNull LocalLog localLog) {
-                super(threshold, localLog);
-            }
-
-            @Override
-            public void enterImpl() {
-                logSmStateName(this.getName(),
-                        getCurrentState() != null ? getCurrentState().getName() : "");
-                Log.d(TAG, "start Ip client with provisioning mode: "
-                        + mSavedPeerConfig.getGroupClientIpProvisioningMode());
-                startIpClient(mGroup.getInterface(), getHandler(),
-                        mSavedPeerConfig.getGroupClientIpProvisioningMode(),
-                        mGroup.p2pClientEapolIpInfo);
-            }
-
-            @Override
-            public boolean processMessageImpl(Message message) {
-                logSmMessage(getName(), message);
-                switch (message.what) {
-                    case IPC_PRE_DHCP_ACTION:
-                        mWifiNative.setP2pPowerSave(mGroup.getInterface(), false);
-                        try {
-                            mIpClient.completedPreDhcpAction();
-                        } catch (RemoteException e) {
-                            e.rethrowFromSystemServer();
-                        }
-                        break;
-                    case IPC_POST_DHCP_ACTION:
-                        mWifiNative.setP2pPowerSave(mGroup.getInterface(), true);
-                        break;
-                    case IPC_DHCP_RESULTS:
-                        mDhcpResultsParcelable = (DhcpResultsParcelable) message.obj;
-                        if (mDhcpResultsParcelable == null) {
-                            break;
-                        }
-
-                        if (mVerboseLoggingEnabled) {
-                            logd("mDhcpResultsParcelable: " + mDhcpResultsParcelable);
-                        }
-                        if (mDhcpResultsParcelable.serverAddress != null) {
-                            setWifiP2pInfoOnGroupFormation(mDhcpResultsParcelable.serverAddress);
-                        } else {
-                            // In case of static IP (IP address received via EAPOL-Key exchange),
-                            // the DHCP server address is null. So look for the gateway address.
-                            InetAddress addr =
-                                    mDhcpResultsParcelable.baseConfiguration.getGateway();
-                            if (addr != null) {
-                                setWifiP2pInfoOnGroupFormation(addr.getHostAddress());
-                            }
-                        }
-                        try {
-                            final String ifname = mGroup.getInterface();
-                            if (mDhcpResultsParcelable != null) {
-                                mNetdWrapper.addInterfaceToLocalNetwork(
-                                        ifname,
-                                        mDhcpResultsParcelable.baseConfiguration.getRoutes(ifname));
-                            }
-                        } catch (Exception e) {
-                            loge("Failed to add iface to local network " + e);
-                        }
-                        onGroupCreated(new WifiP2pInfo(mWifiP2pInfo),
-                                eraseOwnDeviceAddress(mGroup),
-                                generateCallbackList(mGroup));
-                        sendP2pConnectionChangedBroadcast();
-                        break;
-                    case IPC_PROVISIONING_SUCCESS:
-                        if (mSavedPeerConfig.getGroupClientIpProvisioningMode()
-                                != GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL) {
-                            smTransition(this, mIdleState);
-                            break;
-                        }
-
-                        LinkProperties linkProperties = (LinkProperties) message.obj;
-                        if (mVerboseLoggingEnabled) {
-                            logd("IP provisioning result " + linkProperties);
-                        }
-                        try {
-                            mNetdWrapper.addInterfaceToLocalNetwork(
-                                    mGroup.getInterface(),
-                                    linkProperties.getRoutes());
-                        } catch (Exception e) {
-                            loge("Failed to add iface to local network " + e);
-                            mWifiNative.p2pGroupRemove(mGroup.getInterface());
-                        }
-
-                        byte[] goInterfaceMacAddress = mGroup.interfaceAddress;
-                        if (goInterfaceMacAddress == null) {
-                            setWifiP2pInfoOnGroupFormationWithInetAddress(null);
-                            onGroupCreated(new WifiP2pInfo(mWifiP2pInfo),
-                                    eraseOwnDeviceAddress(mGroup),
-                                    generateCallbackList(mGroup));
-                            sendP2pConnectionChangedBroadcast();
-                            smTransition(this, mIdleState);
-                            break;
-                        }
-
-                        byte[] goIpv6Address = MacAddress.fromBytes(goInterfaceMacAddress)
-                                .getLinkLocalIpv6FromEui48Mac().getAddress();
-                        try {
-                            InetAddress goIp = Inet6Address.getByAddress(null, goIpv6Address,
-                                    NetworkInterface.getByName(mGroup.getInterface()));
-                            setWifiP2pInfoOnGroupFormationWithInetAddress(goIp);
-                            onGroupCreated(new WifiP2pInfo(mWifiP2pInfo),
-                                    eraseOwnDeviceAddress(mGroup),
-                                    generateCallbackList(mGroup));
-                            sendP2pConnectionChangedBroadcast();
-                        } catch (UnknownHostException | SocketException e) {
-                            loge("Unable to retrieve link-local IPv6 address of group owner "
-                                    + e);
-                            mWifiNative.p2pGroupRemove(mGroup.getInterface());
-                        }
-                        smTransition(this, mIdleState);
-                        break;
-                    case IPC_PROVISIONING_FAILURE:
-                        loge("IP provisioning failed");
-                        mWifiNative.p2pGroupRemove(mGroup.getInterface());
-                        smTransition(this, mIdleState);
-                        break;
-                    default:
-                        return NOT_HANDLED;
-                }
-                return HANDLED;
-            }
-
-            public void exitImpl() {
-
-            }
-
-            @Override
-            public String getMessageLogRec(int what) {
-                return P2pStateMachine.class.getSimpleName() + "."
-                        + this.getClass().getSimpleName()
-                        + "." + getWhatToString(what);
-            }
-        }
-
         class FrequencyConflictState extends RunnerState {
             private WifiDialogManager.DialogHandle mFrequencyConflictDialog;
             private AlertDialog mFrequencyConflictDialogPreT;
@@ -5823,11 +5274,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                 P2pConnectionEvent.CLF_USER_REJECT);
                         handleGroupCreationFailure(
                                 WifiP2pManager.GROUP_CREATION_FAILURE_REASON_USER_REJECTED);
-                        if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mIdleState);
-                        } else {
-                            smTransition(this, mInactiveState);
-                        }
+                        smTransition(this, mInactiveState);
                         break;
                     case DROP_WIFI_USER_ACCEPT:
                         mFrequencyConflictDialog = null;
@@ -5840,11 +5287,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         if (mVerboseLoggingEnabled) {
                             logd(getName() + "Wifi disconnected, retry p2p");
                         }
-                        if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mIdleState);
-                        } else {
-                            smTransition(this, mInactiveState);
-                        }
+                        smTransition(this, mInactiveState);
                         p2pReconnect();
                         break;
                     default:
@@ -5906,8 +5349,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 // In case of a negotiation group, connection changed is sent
                 // after a client joins. For autonomous, send now
                 if (mAutonomousGroup) {
-                    onGroupCreated(new WifiP2pInfo(mWifiP2pInfo), eraseOwnDeviceAddress(mGroup),
-                            generateCallbackList(mGroup));
+                    onGroupCreated(new WifiP2pInfo(mWifiP2pInfo), eraseOwnDeviceAddress(mGroup));
                     sendP2pConnectionChangedBroadcast();
                 }
 
@@ -5954,12 +5396,10 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         }
                         if (!mAutonomousGroup && mGroup.getClientList().size() == 1) {
                             onGroupCreated(new WifiP2pInfo(mWifiP2pInfo),
-                                    eraseOwnDeviceAddress(mGroup),
-                                    generateCallbackList(mGroup));
+                                    eraseOwnDeviceAddress(mGroup));
                         }
                         onPeerClientJoined(new WifiP2pInfo(mWifiP2pInfo),
-                                eraseOwnDeviceAddress(mGroup),
-                                generateCallbackList(mGroup));
+                                eraseOwnDeviceAddress(mGroup));
                         sendP2pConnectionChangedBroadcast();
                         break;
                     }
@@ -5983,8 +5423,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                     // when this happens at exit()
                                 } else {
                                     onPeerClientDisconnected(new WifiP2pInfo(mWifiP2pInfo),
-                                            eraseOwnDeviceAddress(mGroup),
-                                            generateCallbackList(mGroup));
+                                            eraseOwnDeviceAddress(mGroup));
                                     // Notify when a client disconnects from group
                                     sendP2pConnectionChangedBroadcast();
                                 }
@@ -6075,8 +5514,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             loge("Failed to add iface to local network " + e);
                         }
                         onGroupCreated(new WifiP2pInfo(mWifiP2pInfo),
-                                eraseOwnDeviceAddress(mGroup),
-                                generateCallbackList(mGroup));
+                                eraseOwnDeviceAddress(mGroup));
                         sendP2pConnectionChangedBroadcast();
                         break;
                     case IPC_PROVISIONING_SUCCESS:
@@ -6102,8 +5540,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         if (goInterfaceMacAddress == null) {
                             setWifiP2pInfoOnGroupFormationWithInetAddress(null);
                             onGroupCreated(new WifiP2pInfo(mWifiP2pInfo),
-                                    eraseOwnDeviceAddress(mGroup),
-                                    generateCallbackList(mGroup));
+                                    eraseOwnDeviceAddress(mGroup));
                             sendP2pConnectionChangedBroadcast();
                             break;
                         }
@@ -6115,8 +5552,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                                     NetworkInterface.getByName(mGroup.getInterface()));
                             setWifiP2pInfoOnGroupFormationWithInetAddress(goIp);
                             onGroupCreated(new WifiP2pInfo(mWifiP2pInfo),
-                                    eraseOwnDeviceAddress(mGroup),
-                                    generateCallbackList(mGroup));
+                                    eraseOwnDeviceAddress(mGroup));
                             sendP2pConnectionChangedBroadcast();
                         } catch (UnknownHostException | SocketException e) {
                             loge("Unable to retrieve link-local IPv6 address of group owner "
@@ -6128,33 +5564,21 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         loge("IP provisioning failed");
                         mWifiNative.p2pGroupRemove(mGroup.getInterface());
                         break;
-                    case WifiP2pManager.REMOVE_GROUP: {
-                        String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
-                        if (!checkIfPackageIsGroupOwner(packageName)
-                                && message.sendingUid != Process.SYSTEM_UID) {
-                            replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED,
-                                    WifiP2pManager.BUSY);
-                            logd("Remove group requested by non-group owner " + packageName);
-                            break;
-                        }
+                    case WifiP2pManager.REMOVE_GROUP:
                         mLastCallerInfoManager.put(WifiManager.API_P2P_REMOVE_GROUP,
-                                Process.myTid(), message.sendingUid, 0, packageName, true);
+                                Process.myTid(), message.sendingUid, 0,
+                                getCallingPkgName(message.sendingUid, message.replyTo), true);
                         if (mVerboseLoggingEnabled) logd(getName() + " remove group");
                         if (mWifiNative.p2pGroupRemove(mGroup.getInterface())) {
                             smTransition(this, mOngoingGroupRemovalState);
                             replyToMessage(message, WifiP2pManager.REMOVE_GROUP_SUCCEEDED);
                         } else {
-                            handleGroupRemoved(packageName);
-                            if (mFeatureFlags.p2pOwnership()) {
-                                smTransition(this, mIdleState);
-                            } else {
-                                smTransition(this, mInactiveState);
-                            }
+                            handleGroupRemoved();
+                            smTransition(this, mInactiveState);
                             replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED,
                                     WifiP2pManager.ERROR);
                         }
                         break;
-                    }
                     case WifiP2pMonitor.P2P_GROUP_REMOVED_EVENT:
                         // We do not listen to NETWORK_DISCONNECTION_EVENT for group removal
                         // handling since supplicant actually tries to reconnect after a temporary
@@ -6167,19 +5591,8 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         // Treating network disconnection as group removal causes race conditions
                         // since supplicant would still maintain the group at that stage.
                         if (mVerboseLoggingEnabled) logd(getName() + " group removed");
-
-                        if (message.obj == null) {
-                            Log.e(TAG, "Illegal arguments");
-                            break;
-                        }
-                        WifiP2pGroup group = (WifiP2pGroup) message.obj;
-                        String pkgName = getGroupOwnerPackageName(group);
-                        handleGroupRemoved(pkgName);
-                        if (mFeatureFlags.p2pOwnership()) {
-                            smTransition(this, mIdleState);
-                        } else {
-                            smTransition(this, mInactiveState);
-                        }
+                        handleGroupRemoved();
+                        smTransition(this, mInactiveState);
                         break;
                     case WifiP2pMonitor.P2P_DEVICE_LOST_EVENT:
                         if (message.obj == null) {
@@ -6253,12 +5666,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             // remain at this state.
                             break;
                         }
-                        if (!checkIfPackageIsGroupOwner(packageName)) {
-                            replyToMessage(message, WifiP2pManager.CONNECT_FAILED,
-                                    WifiP2pManager.BUSY);
-                            logd("Cannot perform invitation connection due to lack of ownership");
-                            break;
-                        }
                         mLastCallerInfoManager.put(WifiManager.API_P2P_CONNECT,
                                 Process.myTid(), uid, 0, packageName, true);
                         WifiP2pConfig config = (WifiP2pConfig)
@@ -6274,9 +5681,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             mPeers.updateStatus(config.deviceAddress, WifiP2pDevice.INVITED);
                             sendPeersChangedBroadcast();
                             replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
-                            if (mOwnershipMap.containsKey(packageName)) {
-                                mConnectionPkgName = packageName;
-                            }
                         } else {
                             replyToMessage(message, WifiP2pManager.CONNECT_FAILED,
                                     WifiP2pManager.ERROR);
@@ -6308,7 +5712,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         break;
                     case WifiP2pMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
                     case WifiP2pMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
-                    case WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    case WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT: {
                         WifiP2pProvDiscEvent provDisc = (WifiP2pProvDiscEvent) message.obj;
                         WifiP2pConfig newPeerConfig = new WifiP2pConfig();
                         if (provDisc != null && provDisc.device != null) {
@@ -6325,7 +5729,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             newPeerConfig.wps.setup = WpsInfo.KEYPAD;
                         } else if (message.what == WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT) {
                             newPeerConfig.wps.setup = WpsInfo.DISPLAY;
-                            newPeerConfig.wps.pin = provDisc.pin;
+                            newPeerConfig.wps.pin = provDisc.wpsPin;
                         } else {
                             newPeerConfig.wps.setup = WpsInfo.PBC;
                         }
@@ -6349,20 +5753,47 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                             }
                         }
                         break;
+                    }
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT:
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT: {
+                        if (mGroup.isGroupOwner()) {
+                            if (processProvisionDiscoveryRequestForV2ConnectionOnGroupOwner(
+                                    (WifiP2pProvDiscEvent) message.obj)) {
+                                smTransition(this, mUserAuthorizingJoinState);
+                            }
+                        } else {
+                            if (mVerboseLoggingEnabled) {
+                                logd("Ignore provision discovery for GC");
+                            }
+                        }
+                        break;
+                    }
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT: {
+                        // According to section 3.2.3 in SPEC, only GO can handle group join.
+                        // Multiple groups is not supported, ignore this discovery for GC.
+                        if (mGroup.isGroupOwner()) {
+                            if (processProvisionDiscoveryRequestForV2ConnectionOnGroupOwner(
+                                    (WifiP2pProvDiscEvent) message.obj)) {
+                                notifyP2pProvDiscShowPinRequest(
+                                        getPinOrPassphraseFromSavedPeerConfig(),
+                                        mSavedPeerConfig.deviceAddress);
+                                mWifiNative.authorizeConnectRequestOnGroupOwner(mSavedPeerConfig,
+                                        mGroup.getInterface());
+                            }
+                        } else {
+                            if (mVerboseLoggingEnabled) {
+                                logd("Ignore provision discovery for GC");
+                            }
+                        }
+                        break;
+                    }
                     case WifiP2pMonitor.P2P_GROUP_STARTED_EVENT:
                         loge("Duplicate group creation event notice, ignore");
                         break;
-                    case WifiP2pManager.CANCEL_CONNECT: {
-                        String packageName = getCallingPkgName(message.sendingUid, message.replyTo);
-                        if (mFeatureFlags.p2pOwnership()
-                                && mConnectionPkgName != packageName
-                                && mConnectionPkgName != SHARED_PKG_NAME) {
-                            replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED,
-                                    WifiP2pManager.BUSY);
-                            logd("Cancel invitation connect requested by " + packageName
-                                    + " when connection is initiated by " + mConnectionPkgName);
-                            break;
-                        }
+                    case WifiP2pManager.CANCEL_CONNECT:
                         mLastCallerInfoManager.put(WifiManager.API_P2P_CANCEL_CONNECT,
                                 Process.myTid(), message.sendingUid, 0,
                                 getCallingPkgName(message.sendingUid, message.replyTo), true);
@@ -6382,13 +5813,11 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
 
                         replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_SUCCEEDED);
                         break;
-                    }
                     case WifiP2pMonitor.P2P_FREQUENCY_CHANGED_EVENT:
                         if (mGroup != null) {
                             mGroup.setFrequency(message.arg1);
                             onFrequencyChanged(new WifiP2pInfo(mWifiP2pInfo),
-                                    eraseOwnDeviceAddress(mGroup),
-                                    generateCallbackList(mGroup));
+                                    eraseOwnDeviceAddress(mGroup));
                             sendP2pConnectionChangedBroadcast();
                         }
                         break;
@@ -6481,6 +5910,11 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     case WifiP2pMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
                     case WifiP2pMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
                     case WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
+                    case WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT:
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT:
+                    case WifiP2pMonitor
+                            .P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT:
                         // Ignore more client requests
                         break;
                     case WifiP2pMonitor.P2P_PROV_DISC_FAILURE_EVENT:
@@ -6496,16 +5930,22 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                         if (mDiscoveryStarted) {
                             mWifiNative.p2pStopFind();
                         }
-                        if (mSavedPeerConfig.wps.setup == WpsInfo.PBC) {
-                            mWifiNative.startWpsPbc(mGroup.getInterface(), null);
+                        if (isConfigForV2Connection(mSavedPeerConfig)) {
+                            mWifiNative.authorizeConnectRequestOnGroupOwner(mSavedPeerConfig,
+                                    mGroup.getInterface());
                         } else {
-                            mWifiNative.startWpsPinKeypad(mGroup.getInterface(),
-                                    mSavedPeerConfig.wps.pin);
+                            if (mSavedPeerConfig.wps.setup == WpsInfo.PBC) {
+                                mWifiNative.startWpsPbc(mGroup.getInterface(), null);
+                            } else {
+                                mWifiNative.startWpsPinKeypad(mGroup.getInterface(),
+                                        mSavedPeerConfig.wps.pin);
+                            }
                         }
                         smTransition(this, mGroupCreatedState);
                         break;
                     case PEER_CONNECTION_USER_REJECT:
                         if (mVerboseLoggingEnabled) logd("User rejected incoming request");
+                        mSavedPeerConfig.invalidate();
                         smTransition(this, mGroupCreatedState);
                         break;
                     case WifiP2pManager.SET_CONNECTION_REQUEST_RESULT:
@@ -6662,60 +6102,23 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             final Intent intent = new Intent(WifiP2pManager.ACTION_WIFI_P2P_LISTEN_STATE_CHANGED);
             intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
             intent.putExtra(WifiP2pManager.EXTRA_LISTEN_STATE, started
-                    ? WifiP2pManager.WIFI_P2P_LISTEN_STARTED :
-                    WifiP2pManager.WIFI_P2P_LISTEN_STOPPED);
-            sendBroadcastWithExcludedPermissions(intent, null);
-        }
-
-        // TODO(b/193460475): Remove when tooling supports SystemApi to public API.
-        /**
-         * Use the function to send broadcast to apps that hold included permissions and don't
-         * hold excluded permissions.
-         * @param intent The Intent to broadcast
-         * @param excludedPermissions A list of Strings of permissions the receiver must not have.
-         * SdkLevel < T:  Does not support excludedPermissions and sets the value always null.
-         * SdkLevel >= T: Combines all excludedPermissions
-         */
-        @SuppressLint("NewApi")
-        private void sendBroadcastWithExcludedPermissions(Intent intent,
-                @Nullable String[] excludedPermissions) {
-            Context context = mContext.createContextAsUser(UserHandle.ALL, 0);
-            boolean isLocationModeEnabled = mWifiPermissionsUtil.isLocationModeEnabled();
-            String[] permissions = isLocationModeEnabled ? RECEIVER_PERMISSIONS_FOR_BROADCAST
-                    : RECEIVER_PERMISSIONS_FOR_BROADCAST_LOCATION_OFF;
-            if (SdkLevel.isAtLeastU()) {
-                BroadcastOptions broadcastOptions = mWifiInjector.makeBroadcastOptions();
-                broadcastOptions.setRequireAllOfPermissions(permissions);
-                broadcastOptions.setRequireNoneOfPermissions(excludedPermissions);
-                context.sendBroadcast(intent, null, broadcastOptions.toBundle());
-            } else {
-                context.sendBroadcastWithMultiplePermissions(intent, permissions);
-            }
-            if (SdkLevel.isAtLeastT()) {
-                // on Android T or later, also send broadcasts to apps that have NEARBY_WIFI_DEVICES
-                String[] requiredPermissions = new String[]{
-                        android.Manifest.permission.NEARBY_WIFI_DEVICES,
-                        android.Manifest.permission.ACCESS_WIFI_STATE
-                };
-                BroadcastOptions broadcastOptions = mWifiInjector.makeBroadcastOptions();
-                broadcastOptions.setRequireAllOfPermissions(requiredPermissions);
-                ArrayList<String> excludedPermissionsList = new ArrayList<>();
-                if (isLocationModeEnabled) {
-                    excludedPermissionsList.add(android.Manifest.permission.ACCESS_FINE_LOCATION);
-                }
-                if (excludedPermissions != null) {
-                    Collections.addAll(excludedPermissionsList, excludedPermissions);
-                }
-                if (excludedPermissionsList.size() > 0) {
-                    broadcastOptions.setRequireNoneOfPermissions(excludedPermissionsList.toArray(
-                            new String[0]));
-                }
-                context.sendBroadcast(intent, null, broadcastOptions.toBundle());
-            }
+                    ? WifiP2pManager.WIFI_P2P_LISTEN_STARTED :
+                    WifiP2pManager.WIFI_P2P_LISTEN_STOPPED);
+            sendBroadcastWithExcludedPermissions(intent, null);
         }
 
-        private void sendMultipleP2pConnectionChangedBroadcast(Intent intent,
-                @Nullable String[] excludedPermissions, Set<String> pkgNames) {
+        // TODO(b/193460475): Remove when tooling supports SystemApi to public API.
+        /**
+         * Use the function to send broadcast to apps that hold included permissions and don't
+         * hold excluded permissions.
+         * @param intent The Intent to broadcast
+         * @param excludedPermissions A list of Strings of permissions the receiver must not have.
+         * SdkLevel < T:  Does not support excludedPermissions and sets the value always null.
+         * SdkLevel >= T: Combines all excludedPermissions
+         */
+        @SuppressLint("NewApi")
+        private void sendBroadcastWithExcludedPermissions(Intent intent,
+                @Nullable String[] excludedPermissions) {
             Context context = mContext.createContextAsUser(UserHandle.ALL, 0);
             boolean isLocationModeEnabled = mWifiPermissionsUtil.isLocationModeEnabled();
             String[] permissions = isLocationModeEnabled ? RECEIVER_PERMISSIONS_FOR_BROADCAST
@@ -6724,23 +6127,9 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 BroadcastOptions broadcastOptions = mWifiInjector.makeBroadcastOptions();
                 broadcastOptions.setRequireAllOfPermissions(permissions);
                 broadcastOptions.setRequireNoneOfPermissions(excludedPermissions);
-                if (pkgNames.size() > 0) {
-                    for (String pkg : pkgNames) {
-                        intent.setPackage(pkg);
-                        context.sendBroadcast(intent, null, broadcastOptions.toBundle());
-                    }
-                } else {
-                    context.sendBroadcast(intent, null, broadcastOptions.toBundle());
-                }
+                context.sendBroadcast(intent, null, broadcastOptions.toBundle());
             } else {
-                if (pkgNames.size() > 0) {
-                    for (String pkg : pkgNames) {
-                        intent.setPackage(pkg);
-                        context.sendBroadcastWithMultiplePermissions(intent, permissions);
-                    }
-                } else {
-                    context.sendBroadcastWithMultiplePermissions(intent, permissions);
-                }
+                context.sendBroadcastWithMultiplePermissions(intent, permissions);
             }
             if (SdkLevel.isAtLeastT()) {
                 // on Android T or later, also send broadcasts to apps that have NEARBY_WIFI_DEVICES
@@ -6761,10 +6150,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     broadcastOptions.setRequireNoneOfPermissions(excludedPermissionsList.toArray(
                             new String[0]));
                 }
-                // remove package name from intent for ownership
-                if (mFeatureFlags.p2pOwnership()) {
-                    intent = getP2pConnectionChangedIntent();
-                }
                 context.sendBroadcast(intent, null, broadcastOptions.toBundle());
             }
         }
@@ -6798,71 +6183,19 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             return intent;
         }
 
-        private Set<String> getGroupOwnershipPackageList() {
-            Set<String> pkgNames = new HashSet<>();
-
-            if (mOwnershipMap.isEmpty()) {
-                logd("No ownership mapping available");
-                return pkgNames;
-            }
-
-            boolean hasSharedPkg = mOwnershipMap.containsKey(SHARED_PKG_NAME);
-
-            if (mOwnershipMap.size() == 1) {
-                if (hasSharedPkg) {
-                    logd("Sending P2P connection changed broadcast to everyone");
-                    return pkgNames;
-                }
-                String pkg = mOwnershipMap.keySet().iterator().next();
-                pkgNames.add(pkg);
-                logd("Sending P2P connection changed broadcast to only " + pkg);
-                return pkgNames;
-            }
-
-            if (hasSharedPkg) {
-                for (ClientInfo client : mClientInfoList.values()) {
-                    if (!mOwnershipMap.containsKey(client.mPackageName)) {
-                        pkgNames.add(client.mPackageName);
-                    }
-                }
-            } else {
-                if (mGroup == null) {
-                    loge("P2P current group information is not available");
-                    return pkgNames;
-                }
-                for (Map.Entry<String, WifiP2pGroupInfo> entry : mOwnershipMap.entrySet()) {
-                    if (entry.getValue().p2pGroup.getInterface().equals(mGroup.getInterface())) {
-                        pkgNames.add(entry.getKey());
-                    }
-                }
-            }
-
-            return pkgNames;
-        }
-
         private void sendP2pConnectionChangedBroadcast() {
             if (mVerboseLoggingEnabled) logd("sending p2p connection changed broadcast");
             Intent intent = getP2pConnectionChangedIntent();
-            Set<String> pkgNames = getGroupOwnershipPackageList();
             if (SdkLevel.isAtLeastU()) {
                 // First send direct foreground broadcast to Tethering package and system service
                 // with same android.permission.MAINLINE_NETWORK_STACK
                 sendBroadcastWithMainlineNetworkStackPermissionPostU();
                 // Then send the same broadcast to remaining apps without
                 // android.permission.MAINLINE_NETWORK_STACK
-                if (mFeatureFlags.p2pOwnership()) {
-                    sendMultipleP2pConnectionChangedBroadcast(intent,
-                            RECEIVER_PERMISSIONS_MAINLINE_NETWORK_STACK, pkgNames);
-                } else {
-                    sendBroadcastWithExcludedPermissions(intent,
-                            RECEIVER_PERMISSIONS_MAINLINE_NETWORK_STACK);
-                }
+                sendBroadcastWithExcludedPermissions(intent,
+                        RECEIVER_PERMISSIONS_MAINLINE_NETWORK_STACK);
             } else {
-                if (mFeatureFlags.p2pOwnership()) {
-                    sendMultipleP2pConnectionChangedBroadcast(intent, null, pkgNames);
-                } else {
-                    sendBroadcastWithExcludedPermissions(intent, null);
-                }
+                sendBroadcastWithExcludedPermissions(intent, null);
             }
             if (mWifiChannel != null) {
                 mWifiChannel.sendMessage(WifiP2pServiceImpl.P2P_CONNECTION_CHANGED,
@@ -7233,6 +6566,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             mLegacyInvitationDialog.show();
         }
 
+        @SuppressLint("NewApi")
         private void showInvitationReceivedDialog() {
             String deviceName = getDeviceName(mSavedPeerConfig.deviceAddress);
             boolean isPinRequested = false;
@@ -7255,12 +6589,36 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                     break;
             }
 
+            if (isConfigForV2Connection(mSavedPeerConfig)) {
+                int pairingBootstrappingMethod = mSavedPeerConfig.getPairingBootstrappingConfig()
+                        .getPairingBootstrappingMethod();
+                if (pairingBootstrappingMethod
+                        == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE || pairingBootstrappingMethod
+                        == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE) {
+                    isPinRequested = true;
+                } else if (pairingBootstrappingMethod
+                        == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE || pairingBootstrappingMethod
+                        == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE) {
+                    displayPin = mSavedPeerConfig.getPairingBootstrappingConfig()
+                            .getPairingBootstrappingPassword();
+                }
+            }
+
             WifiDialogManager.P2pInvitationReceivedDialogCallback callback =
                     new WifiDialogManager.P2pInvitationReceivedDialogCallback() {
                         @Override
                         public void onAccepted(@Nullable String optionalPin) {
                             if (optionalPin != null) {
-                                mSavedPeerConfig.wps.pin = optionalPin;
+                                if (isConfigForV2Connection(mSavedPeerConfig)) {
+                                    mSavedPeerConfig.getPairingBootstrappingConfig()
+                                            .setPairingBootstrappingPassword(optionalPin);
+                                } else {
+                                    mSavedPeerConfig.wps.pin = optionalPin;
+                                }
                             }
                             if (mVerboseLoggingEnabled) {
                                 logd(getName() + " accept invitation " + mSavedPeerConfig);
@@ -7316,93 +6674,401 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             if (!SdkLevel.isAtLeastT()) {
                 showInvitationReceivedDialogPreT();
             } else {
-                showInvitationReceivedDialog();
+                showInvitationReceivedDialog();
+            }
+        }
+
+        /**
+         * This method unifies the persisent group list, cleans up unused
+         * networks and if required, updates corresponding broadcast receivers
+         * @param reload if true, reload the group list from scratch
+         *                and send broadcast message with fresh list
+         */
+        private void updatePersistentNetworks(boolean reload) {
+            if (reload) mGroups.clear();
+
+            // Save in all cases, including when reload was requested, but
+            // no network has been found.
+            if (mWifiNative.p2pListNetworks(mGroups) || reload) {
+                for (WifiP2pGroup group : mGroups.getGroupList()) {
+                    if (group.getOwner() == null) {
+                        Log.d(TAG, "group.getOwner() null");
+                        continue;
+                    }
+                    if (Objects.equals(mThisDevice.deviceAddress, group.getOwner().deviceAddress)) {
+                        group.setOwner(mThisDevice);
+                    }
+                }
+                mWifiNative.saveConfig();
+                mWifiP2pMetrics.updatePersistentGroup(mGroups);
+                sendP2pPersistentGroupsChangedBroadcast();
+            }
+        }
+
+        /**
+         * A config is valid if it has a peer address that has already been
+         * discovered
+         * @param WifiP2pConfig config to be validated
+         * @return true if it is invalid, false otherwise
+         */
+        private boolean isConfigInvalid(WifiP2pConfig config) {
+            if (config == null) return true;
+            if (TextUtils.isEmpty(config.deviceAddress)) return true;
+            return mPeers.get(config.deviceAddress) == null;
+        }
+
+        /**
+         * Check the network name complies standard SSID naming rules.
+         *
+         * The network name of a group is also the broadcasting SSID,
+         * as a result, the network name must complies standard SSID naming
+         * rules.
+         */
+        private boolean isValidNetworkName(String networkName) {
+            if (TextUtils.isEmpty(networkName)) return false;
+
+            byte[] ssidBytes = networkName.getBytes(StandardCharsets.UTF_8);
+            if (ssidBytes.length < MIN_NETWORK_NAME_BYTES) return false;
+            return ssidBytes.length <= MAX_NETWORK_NAME_BYTES;
+        }
+
+        /**
+         * A config is valid as a group if it has network name and passphrase.
+         * Supplicant can construct a group on the fly for creating a group with specified config
+         * or join a group without negotiation and WPS.
+         * @param WifiP2pConfig config to be validated
+         * @return true if it is valid, false otherwise
+         */
+        private boolean isConfigValidAsGroup(WifiP2pConfig config) {
+            if (config == null) return false;
+            if (TextUtils.isEmpty(config.deviceAddress)) return false;
+            return isValidNetworkName(config.networkName)
+                    && !TextUtils.isEmpty(config.passphrase);
+        }
+
+        /**
+         * Check if the Wi-Fi Direct R2 feature is enabled or not
+         *
+         * @return true if Wi-Fi Direct R2 feature is enabled, false otherwise.
+         */
+        private boolean isWifiDirect2Enabled() {
+            if (Environment.isSdkAtLeastB()
+                    && isFeatureSupported(WifiP2pManager.FEATURE_WIFI_DIRECT_R2)
+                    && Flags.wifiDirectR2()) {
+                return true;
+            }
+            return false;
+        }
+
+        /**
+         * Check the config is for starting P2P version 2 group owner.
+         *
+         * @param config config to be checked for P2P group owner version.
+         * @return true if it is version 2, false otherwise.
+         */
+        @SuppressLint("NewApi")
+        private boolean isConfigForGroupOwnerV2(WifiP2pConfig config) {
+            if (config != null && Environment.isSdkAtLeastB()
+                    && config.getGroupOwnerVersion() == P2P_VERSION_2) {
+                return true;
+            }
+            return false;
+        }
+
+        /**
+         * Check the configuration is for forming or joining a P2P version 2 group.
+         *
+         * @param config config to be checked for version 2.
+         * @return true if it is version 2, false otherwise.
+         */
+        @SuppressLint("NewApi")
+        private boolean isConfigForV2Connection(WifiP2pConfig config) {
+            if (config != null && Environment.isSdkAtLeastB()
+                    && config.getPairingBootstrappingConfig() != null) {
+                return true;
+            }
+            return false;
+        }
+
+        /**
+         * Convert the WifiP2pProvDiscEvent to
+         * |WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_*|.
+         *
+         * @param event The event ID carried in WifiP2pProvDiscEvent.
+         * @return The |WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_*|.
+         * if not found, return -1.
+         */
+        @SuppressLint("NewApi")
+        private @WifiP2pPairingBootstrappingConfig.PairingBootstrappingMethod int
+        convertWifiP2pProvDiscEventToPairingBootstrappingMethod(int event) {
+            switch (event) {
+                case WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ:
+                case WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP:
+                    return WifiP2pPairingBootstrappingConfig
+                            .PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC;
+                case WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE:
+                    return WifiP2pPairingBootstrappingConfig
+                            .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE;
+                case WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN:
+                    return WifiP2pPairingBootstrappingConfig
+                            .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE;
+                case WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PIN:
+                    return WifiP2pPairingBootstrappingConfig
+                            .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE;
+                case WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE:
+                    return WifiP2pPairingBootstrappingConfig
+                            .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE;
+                default:
+                    return 0;
+            }
+        }
+
+        /**
+         * Check the configuration is for forming or joining a P2P version 2 group with pairing
+         * bootstrapping method: opportunistic
+         *
+         * @param config config to be checked for version 2.
+         * {@link WifiP2pPairingBootstrappingConfig#PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC},
+         * false otherwise.
+         */
+        @SuppressLint("NewApi")
+        private boolean isConfigForBootstrappingMethodOpportunistic(WifiP2pConfig config) {
+            if (config != null && Environment.isSdkAtLeastB()
+                    && config.getPairingBootstrappingConfig() != null
+                    && (config.getPairingBootstrappingConfig().getPairingBootstrappingMethod()
+                    == WifiP2pPairingBootstrappingConfig
+                    .PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC)) {
+                return true;
+            }
+            return false;
+        }
+
+        /**
+         * Check the configuration is for forming or joining a P2P version 2 group with pairing
+         * bootstrapping method: Display pin-code or Display passphrase.
+         *
+         * @param config config to be checked for version 2.
+         * {@link WifiP2pPairingBootstrappingConfig#PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE} or
+         * {@link WifiP2pPairingBootstrappingConfig#PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE}
+         * , false otherwise.
+         */
+        @SuppressLint("NewApi")
+        private boolean isConfigForBootstrappingMethodDisplayPinOrPassphrase(WifiP2pConfig config) {
+            if (config != null && Environment.isSdkAtLeastB()
+                    && config.getPairingBootstrappingConfig() != null) {
+                int pairingBootstrappingMethod =
+                        config.getPairingBootstrappingConfig().getPairingBootstrappingMethod();
+                if (pairingBootstrappingMethod == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE || pairingBootstrappingMethod
+                        == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        /**
+         * Check the configuration is for forming or joining a P2P version 2 group with pairing
+         * bootstrapping method: Keypad pin-code or Keypad passphrase.
+         *
+         * @param config config to be checked for bootstrapping method.
+         * @return true if the pairing bootstrapping method is
+         * {@link WifiP2pPairingBootstrappingConfig#PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE} or
+         * {@link WifiP2pPairingBootstrappingConfig#PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE},
+         * false otherwise.
+         */
+        @SuppressLint("NewApi")
+        private boolean isConfigForBootstrappingMethodKeypadPinOrPassphrase(WifiP2pConfig config) {
+            if (config != null && Environment.isSdkAtLeastB()
+                    && config.getPairingBootstrappingConfig() != null) {
+                int pairingBootstrappingMethod =
+                        config.getPairingBootstrappingConfig().getPairingBootstrappingMethod();
+                if (pairingBootstrappingMethod == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE || pairingBootstrappingMethod
+                        == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        /**
+         * Check the configuration is for forming or joining a P2P version 2 group with pairing
+         * bootstrapping method done out of band.
+         *
+         * @param config config to be checked for bootstrapping method.
+         * @return true if the pairing bootstrapping method is
+         * {@link WifiP2pPairingBootstrappingConfig#PAIRING_BOOTSTRAPPING_METHOD_OUT_OF_BAND},
+         * false otherwise.
+         */
+        @SuppressLint("NewApi")
+        private boolean isConfigForBootstrappingMethodOutOfBand(WifiP2pConfig config) {
+            if (config != null && Environment.isSdkAtLeastB()
+                    && config.getPairingBootstrappingConfig() != null) {
+                if (config.getPairingBootstrappingConfig().getPairingBootstrappingMethod()
+                        == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_OUT_OF_BAND) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        private static String generatePairingPin() {
+            SecureRandom random = new SecureRandom();
+            StringBuilder sb = new StringBuilder(PAIRING_PIN_OR_PASSWORD_LENGTH);
+            for (int i = 0; i < PAIRING_PIN_OR_PASSWORD_LENGTH; i++) {
+                sb.append(random.nextInt(10));
+            }
+            return sb.toString();
+        }
+
+        private static String generatePairingPassphrase() {
+            final String allowed = "23456789abcdefghjkmnpqrstuvwxyz";
+            StringBuilder sb = new StringBuilder(PAIRING_PIN_OR_PASSWORD_LENGTH);
+            SecureRandom random = new SecureRandom();
+            for (int i = 0; i < PAIRING_PIN_OR_PASSWORD_LENGTH; i++) {
+                sb.append(allowed.charAt(random.nextInt(allowed.length())));
+            }
+            return sb.toString();
+        }
+
+        @SuppressLint("NewApi")
+        private boolean createPeerConfigForV2ConnectionRequest(
+                WifiP2pProvDiscEvent provDisc) {
+            int pairingBootstrappingMethod =
+                    convertWifiP2pProvDiscEventToPairingBootstrappingMethod(
+                            provDisc.event);
+            if (pairingBootstrappingMethod != 0) {
+                String pairingPinOrPassphrase = "";
+                if (pairingBootstrappingMethod == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE) {
+                    pairingPinOrPassphrase = generatePairingPin();
+                } else if (pairingBootstrappingMethod == WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE) {
+                    pairingPinOrPassphrase = generatePairingPassphrase();
+                }
+                WifiP2pPairingBootstrappingConfig pairingBootstrappingConfig =
+                        new WifiP2pPairingBootstrappingConfig(
+                                pairingBootstrappingMethod,
+                                pairingPinOrPassphrase);
+                mSavedPeerConfig = new WifiP2pConfig.Builder()
+                        .setDeviceAddress(MacAddress.fromString(
+                                provDisc.device.deviceAddress))
+                        .setPairingBootstrappingConfig(pairingBootstrappingConfig)
+                        .setGroupClientIpProvisioningMode(
+                                GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL)
+                        .setAuthorizeConnectionFromPeerEnabled(true)
+                        .build();
+                if (provDisc.getVendorData() != null) {
+                    mSavedPeerConfig.setVendorData(provDisc.getVendorData());
+                }
+                return true;
+            } else {
+                loge("Error in mapping provDisc event: " + provDisc.event
+                        + " to pairingBootstrappingMethod");
+                return false;
+            }
+        }
+
+        @SuppressLint("NewApi")
+        private boolean processProvisionDiscoveryRequestForV2ConnectionOnP2pDevice(
+                WifiP2pProvDiscEvent provDisc) {
+            if (!isWifiDirect2Enabled()) {
+                return false;
+            }
+            if (provDisc == null) {
+                Log.e(TAG, "provDisc is null");
+                return false;
+            }
+            WifiP2pDevice device = provDisc.device;
+            if (device == null) {
+                loge("Device entry is null");
+                return false;
+            }
+            if (TextUtils.isEmpty(device.deviceAddress)) {
+                loge("Device address is empty");
+                return false;
+            }
+            if (createPeerConfigForV2ConnectionRequest(provDisc)) {
+                mPeers.updateStatus(provDisc.device.deviceAddress, WifiP2pDevice.INVITED);
+                sendPeersChangedBroadcast();
+                mAutonomousGroup = false;
+                mJoinExistingGroup = false;
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        @SuppressLint("NewApi")
+        private boolean processProvisionDiscoveryRequestForV2ConnectionOnGroupOwner(
+                WifiP2pProvDiscEvent provDisc) {
+            if (!isWifiDirect2Enabled()) {
+                return false;
+            }
+            if (provDisc == null) {
+                Log.e(TAG, "provDisc is null");
+                return false;
+            }
+            WifiP2pDevice device = provDisc.device;
+            if (device == null) {
+                loge("Device entry is null");
+                return false;
+            }
+            if (TextUtils.isEmpty(device.deviceAddress)) {
+                loge("Device address is empty");
+                return false;
+            }
+
+            if (isPeerAuthorizing(device.deviceAddress)) {
+                Log.i(TAG, "Ignore duplicate provision discovery request from "
+                        + device.deviceAddress);
+                return false;
+            }
+            if (createPeerConfigForV2ConnectionRequest(provDisc)) {
+                mPeerAuthorizingTimestamp.put(mSavedPeerConfig.deviceAddress,
+                        mClock.getElapsedSinceBootMillis());
+                return true;
+            } else {
+                return false;
             }
         }
 
-        /**
-         * This method unifies the persisent group list, cleans up unused
-         * networks and if required, updates corresponding broadcast receivers
-         * @param reload if true, reload the group list from scratch
-         *                and send broadcast message with fresh list
-         */
-        private void updatePersistentNetworks(boolean reload) {
-            if (reload) mGroups.clear();
-
-            // Save in all cases, including when reload was requested, but
-            // no network has been found.
-            if (mWifiNative.p2pListNetworks(mGroups) || reload) {
-                for (WifiP2pGroup group : mGroups.getGroupList()) {
-                    if (group.getOwner() == null) {
-                        Log.d(TAG, "group.getOwner() null");
-                        continue;
-                    }
-                    if (Objects.equals(mThisDevice.deviceAddress, group.getOwner().deviceAddress)) {
-                        group.setOwner(mThisDevice);
+        @SuppressLint("NewApi")
+        private void setDisplayPinOrPassphraseInSavedPeerConfigIfNeeded() {
+            WifiP2pPairingBootstrappingConfig pairingConfig =
+                    mSavedPeerConfig.getPairingBootstrappingConfig();
+            if (pairingConfig != null) {
+                String pairingPinOrPassphrase = pairingConfig.getPairingBootstrappingPassword();
+                if (TextUtils.isEmpty(pairingPinOrPassphrase)) {
+                    int pairingBootstrappingMethod = pairingConfig.getPairingBootstrappingMethod();
+                    if (pairingBootstrappingMethod == WifiP2pPairingBootstrappingConfig
+                            .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE) {
+                        pairingPinOrPassphrase = generatePairingPassphrase();
+                    } else if (pairingBootstrappingMethod == WifiP2pPairingBootstrappingConfig
+                            .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE) {
+                        pairingPinOrPassphrase = generatePairingPin();
+                    } else {
+                        loge("setDisplayPinOrPassphraseInSavedPeerConfigIfNeeded() called for"
+                                + " a non-display method: " + pairingBootstrappingMethod);
+                        return;
                     }
+                    pairingConfig.setPairingBootstrappingPassword(pairingPinOrPassphrase);
                 }
-                mWifiNative.saveConfig();
-                mWifiP2pMetrics.updatePersistentGroup(mGroups);
-                sendP2pPersistentGroupsChangedBroadcast();
             }
         }
 
-        /**
-         * A config is valid if it has a peer address that has already been
-         * discovered
-         * @param WifiP2pConfig config to be validated
-         * @return true if it is invalid, false otherwise
-         */
-        private boolean isConfigInvalid(WifiP2pConfig config) {
-            if (config == null) return true;
-            if (TextUtils.isEmpty(config.deviceAddress)) return true;
-            return mPeers.get(config.deviceAddress) == null;
-        }
-
-        /**
-         * Check the network name complies standard SSID naming rules.
-         *
-         * The network name of a group is also the broadcasting SSID,
-         * as a result, the network name must complies standard SSID naming
-         * rules.
-         */
-        private boolean isValidNetworkName(String networkName) {
-            if (TextUtils.isEmpty(networkName)) return false;
-
-            byte[] ssidBytes = networkName.getBytes(StandardCharsets.UTF_8);
-            if (ssidBytes.length < MIN_NETWORK_NAME_BYTES) return false;
-            return ssidBytes.length <= MAX_NETWORK_NAME_BYTES;
-        }
-
-        /**
-         * A config is valid as a group if it has network name and passphrase.
-         * Supplicant can construct a group on the fly for creating a group with specified config
-         * or join a group without negotiation and WPS.
-         * @param WifiP2pConfig config to be validated
-         * @return true if it is valid, false otherwise
-         */
-        private boolean isConfigValidAsGroup(WifiP2pConfig config) {
-            if (config == null) return false;
-            if (TextUtils.isEmpty(config.deviceAddress)) return false;
-            return isValidNetworkName(config.networkName)
-                    && !TextUtils.isEmpty(config.passphrase);
-        }
-
-        /**
-         * Check the config for group owner version 2.
-         *
-         * @param config config to be checked for P2P group owner version.
-         * @return true if it is version 2, false otherwise.
-         */
         @SuppressLint("NewApi")
-        private boolean isConfigForGroupOwnerV2(WifiP2pConfig config) {
-            if (config != null && Environment.isSdkAtLeastB()
-                    && isFeatureSupported(WifiP2pManager.FEATURE_WIFI_DIRECT_R2)
-                    && Flags.wifiDirectR2()
-                    && config.getGroupOwnerVersion() == P2P_VERSION_2) {
-                return true;
+        private String getPinOrPassphraseFromSavedPeerConfig() {
+            WifiP2pPairingBootstrappingConfig pairingConfig =
+                    mSavedPeerConfig.getPairingBootstrappingConfig();
+            if (pairingConfig != null) {
+                return pairingConfig.getPairingBootstrappingPassword();
             }
-            return false;
+            return null;
         }
 
         private WifiP2pDevice fetchCurrentDeviceDetails(WifiP2pConfig config) {
@@ -7564,14 +7230,74 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
 
             String pin = mWifiNative.p2pConnect(config, action);
             try {
-                Integer.parseInt(pin);
-                mSavedPeerConfig.wps.pin = pin;
-                notifyInvitationSent(pin, config.deviceAddress);
+                // TODO check this logic in detail
+                if (mSavedPeerConfig.wps.setup == WpsInfo.DISPLAY) {
+                    Integer.parseInt(pin);
+                    mSavedPeerConfig.wps.pin = pin;
+                    notifyInvitationSent(pin, config.deviceAddress);
+                }
             } catch (NumberFormatException ignore) {
                 // do nothing if p2pConnect did not return a pin
             }
         }
 
+        /**
+         * Reinvoke a P2P version 2 persistent group.
+         *
+         * @param config for the peer
+         * @return true on success, false on failure
+         */
+        private boolean reinvokePersistentV2Group(WifiP2pConfig config) {
+            if (config == null) {
+                Log.e(TAG, "config is null for p2pReinvoke() of V2 group");
+                return false;
+            }
+
+            if (!isConfigForV2Connection(config)) {
+                Log.e(TAG, "config is not for p2pReinvoke() of V2 group");
+                return false;
+            }
+            WifiP2pDevice peerDevice = fetchCurrentDeviceDetails(config);
+            if (peerDevice == null) {
+                Log.e(TAG, "Invalid device for p2pReinvoke() of V2 group");
+                return false;
+            }
+            if (!peerDevice.isInvitationCapable()) {
+                Log.e(TAG, "Device is not invitation capable for p2pReinvoke() of V2 group");
+                return false;
+            }
+            boolean shouldJoin = peerDevice.isGroupOwner() || config.isJoinExistingGroup();
+            if (shouldJoin && peerDevice.isGroupLimit()) {
+                if (mVerboseLoggingEnabled) logd("target V2 supported device reaches group limit");
+                // if the target group has reached the limit,
+                // try group formation.
+                shouldJoin = false;
+            }
+            if (!shouldJoin && peerDevice.isDeviceLimit()) {
+                loge("target V2 supported device reaches the device limit");
+                return false;
+            }
+
+            WifiP2pDirInfo dirInfo = peerDevice.dirInfo;
+            if (dirInfo == null) {
+                return false;
+            }
+            int dikIdx = mWifiNative.validateDirInfo(dirInfo);
+            if (dikIdx < 0) {
+                if (mVerboseLoggingEnabled) {
+                    logd("target V2 supported device is not paired before");
+                }
+                return false;
+            }
+
+            if (mWifiNative.p2pReinvoke(-1, peerDevice.deviceAddress, dikIdx)) {
+                return true;
+            }
+
+            loge("p2pReinvoke() of V2 group failed");
+            return false;
+        }
+
         /**
          * Reinvoke a persistent group.
          *
@@ -7583,6 +7309,10 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 Log.e(TAG, "Illegal argument(s)");
                 return false;
             }
+            if (isConfigForV2Connection(config)) {
+                Log.e(TAG, "config is for V2 group. Should call reinvokePersistentV2Group()");
+                return false;
+            }
             WifiP2pDevice dev = fetchCurrentDeviceDetails(config);
             if (dev == null) {
                 Log.e(TAG, "Invalid device");
@@ -7606,7 +7336,8 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 int netId = mGroups.getNetworkId(dev.deviceAddress, ssid);
                 if (netId >= 0) {
                     // Skip WPS and start 4way handshake immediately.
-                    return mWifiNative.p2pGroupAdd(netId);
+                    // TODO Add support P2P2
+                    return mWifiNative.p2pGroupAdd(netId, false);
                 } else {
                     loge("The Network: " + ssid + " is not found in the persistent group list");
                 }
@@ -7634,7 +7365,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 }
                 if (netId >= 0) {
                     // Invoke the persistent group.
-                    if (mWifiNative.p2pReinvoke(netId, dev.deviceAddress)) {
+                    if (mWifiNative.p2pReinvoke(netId, dev.deviceAddress, -1)) {
                         // Save network id. It'll be used when an invitation
                         // result event is received.
                         config.netId = netId;
@@ -7768,8 +7499,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             mWifiP2pInfo.groupFormed = true;
             mWifiP2pInfo.isGroupOwner = mGroup.isGroupOwner();
             mWifiP2pInfo.groupOwnerAddress = serverAddress;
-            mOwnershipMap.put(
-                    mConnectionPkgName, new WifiP2pGroupInfo(mGroup, mWifiP2pInfo, mIpClient));
         }
 
         private void resetWifiP2pInfo() {
@@ -7980,7 +7709,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             mWifiNative.p2pFlush();
             mWifiNative.p2pServiceFlush();
             mServiceTransactionId = 0;
-            mServiceDiscReqId = null;
+            mServiceDiscoveryInfo.invalidate();
 
             if (null != mThisDevice.wfdInfo) {
                 setWfdInfo(mThisDevice.wfdInfo);
@@ -8051,7 +7780,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             }
 
             mPeersLostDuringConnection.clear();
-            mServiceDiscReqId = null;
+            mServiceDiscoveryInfo.invalidate();
 
             Bundle extras = new Bundle();
             extras.putBoolean(WifiP2pManager.EXTRA_PARAM_KEY_INTERNAL_MESSAGE, true);
@@ -8064,8 +7793,7 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             sendDisconnectWifiRequest(false);
         }
 
-        private void handleGroupRemoved(String packageName) {
-            // TODO: Modify logic for Dual P2P in next CL
+        private void handleGroupRemoved() {
             if (mGroup.isGroupOwner()) {
                 // {@link com.android.server.connectivity.Tethering} listens to
                 // {@link WifiP2pManager#WIFI_P2P_CONNECTION_CHANGED_ACTION}
@@ -8103,15 +7831,9 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 sendPeersChangedBroadcast();
             }
 
-            if (mOwnershipMap.containsKey(packageName)) {
-                mOwnershipMap.remove(packageName);
-            } else {
-                mOwnershipMap.remove(SHARED_PKG_NAME);
-            }
-
             mGroup = null;
             mPeersLostDuringConnection.clear();
-            mServiceDiscReqId = null;
+            mServiceDiscoveryInfo.invalidate();
 
             sendDisconnectWifiRequest(false);
         }
@@ -8181,11 +7903,97 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
         }
 
         /**
-         * Update service discovery request to wpa_supplicant.
+         * Process USD based service discovery request message.
+         */
+        private void processGasFrameBasedServiceDiscoveryRequestMessage(@NonNull Message message) {
+            if (!updateSupplicantGasFrameBasedServiceRequest()) {
+                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                        WifiP2pManager.NO_SERVICE_REQUESTS);
+                return;
+            }
+            if (p2pFind(DISCOVER_TIMEOUT_S)) {
+                sendP2pDiscoveryChangedBroadcast(true);
+                mWifiP2pMetrics.incrementServiceScans();
+                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_SUCCEEDED);
+            } else {
+                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                        WifiP2pManager.ERROR);
+            }
+        }
+        /**
+         * Process USD based service discovery request message.
+         */
+        @SuppressLint("NewApi")
+        private void processUsdFrameBasedServiceDiscoveryRequestMessage(@NonNull Message message) {
+            if (!isWifiDirect2Enabled()) {
+                Log.e(TAG, "Wi-Fi Direct R2 is not supported");
+                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                        WifiP2pManager.ERROR);
+                return;
+            }
+            Messenger m = message.replyTo;
+            Bundle extras = message.getData()
+                    .getBundle(WifiP2pManager.EXTRA_PARAM_KEY_BUNDLE);
+            if (m == null || extras == null) {
+                Log.e(TAG, "Illegal argument(s)");
+                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                        WifiP2pManager.ERROR);
+                return;
+            }
+            WifiP2pUsdBasedServiceDiscoveryConfig serviceDiscoveryConfig =
+                    extras.getParcelable(WifiP2pManager
+                            .EXTRA_PARAM_KEY_USD_BASED_SERVICE_DISCOVERY_CONFIG);
+            if (serviceDiscoveryConfig == null) {
+                Log.e(TAG, "Service discovery config null!");
+                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                        WifiP2pManager.ERROR);
+                return;
+            }
+
+            ClientInfo clientInfo = getClientInfo(m, false);
+            if (clientInfo == null) {
+                Log.e(TAG, "Client doesn't exist");
+                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                        WifiP2pManager.NO_SERVICE_REQUESTS);
+                return;
+            }
+
+            if (mServiceDiscoveryInfo.isValid() && mServiceDiscoveryInfo.getServiceDiscoveryType()
+                    == WifiP2pOngoingServiceDiscoveryRequestInfo
+                    .WIFI_P2P_USD_FRAME_BASED_SERVICE_DISCOVERY) {
+                mWifiNative.stopUsdBasedServiceDiscovery(mServiceDiscoveryInfo.getSessionIdInt());
+            }
+
+            // TODO This loop runs only once as add service request allow to add only one service
+            // per client. Keeping this loop to expand in the future to service multiple services.
+            for (WifiP2pServiceRequest serviceRequest: clientInfo.mUsdServiceDiscoverList) {
+                int sessionId = mWifiNative.startUsdBasedServiceDiscovery(
+                        serviceRequest.getWifiP2pUsdBasedServiceConfig(), serviceDiscoveryConfig,
+                        USD_BASED_SERVICE_ADVERTISEMENT_DISCOVERY_TIMEOUT_S);
+                if (sessionId > 0) {
+                    serviceRequest.setUsdSessionId(sessionId);
+                    mServiceDiscoveryInfo.update(WifiP2pOngoingServiceDiscoveryRequestInfo
+                                    .WIFI_P2P_USD_FRAME_BASED_SERVICE_DISCOVERY, sessionId);
+                    sendP2pDiscoveryChangedBroadcast(true);
+                    replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_SUCCEEDED);
+                } else {
+                    replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                            WifiP2pManager.ERROR);
+                }
+                return;
+            }
+
+            Log.e(TAG, "No service requests added");
+            replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED,
+                    WifiP2pManager.NO_SERVICE_REQUESTS);
+        }
+
+        /**
+         * Update GAS frame based service discovery request to wpa_supplicant.
          */
-        private boolean updateSupplicantServiceRequest() {
-            clearSupplicantServiceRequest();
-            StringBuffer sb = new StringBuffer();
+        private boolean updateSupplicantGasFrameBasedServiceRequest() {
+            clearGasFrameBasedServiceDiscoveryRequests();
+            StringBuilder sb = new StringBuilder();
             for (ClientInfo c: mClientInfoList.values()) {
                 WifiP2pServiceRequest req;
                 for (int i = 0; i < c.mReqList.size(); i++) {
@@ -8199,62 +8007,92 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 return false;
             }
 
-            mServiceDiscReqId = mWifiNative.p2pServDiscReq("00:00:00:00:00:00", sb.toString());
-            return mServiceDiscReqId != null;
+            String serviceDiscReqId = mWifiNative.p2pServDiscReq("00:00:00:00:00:00",
+                    sb.toString());
+            if (!TextUtils.isEmpty(serviceDiscReqId)) {
+                mServiceDiscoveryInfo.update(WifiP2pOngoingServiceDiscoveryRequestInfo
+                        .WIFI_P2P_GAS_FRAME_BASED_SERVICE_DISCOVERY, serviceDiscReqId);
+                return true;
+            } else {
+                return false;
+            }
         }
 
         /**
-         * Clear service discovery request in wpa_supplicant
+         * Clear GAS frame based service discovery requests in wpa_supplicant
          */
-        private void clearSupplicantServiceRequest() {
-            if (mServiceDiscReqId == null) return;
-
-            mWifiNative.p2pServDiscCancelReq(mServiceDiscReqId);
-            mServiceDiscReqId = null;
+        private void clearGasFrameBasedServiceDiscoveryRequests() {
+            if (!mServiceDiscoveryInfo.isValid()) {
+                return;
+            }
+            if (mServiceDiscoveryInfo.getServiceDiscoveryType()
+                    != WifiP2pOngoingServiceDiscoveryRequestInfo
+                    .WIFI_P2P_GAS_FRAME_BASED_SERVICE_DISCOVERY) {
+                return;
+            }
+            mWifiNative.p2pServDiscCancelReq(mServiceDiscoveryInfo.getSessionId());
+            mServiceDiscoveryInfo.invalidate();
         }
 
         @SuppressLint("NewApi")
-        private boolean addServiceRequest(@NonNull Message message) {
+        private boolean addServiceRequest(@NonNull Message message, AtomicInteger errorCode) {
             Messenger m = message.replyTo;
             WifiP2pServiceRequest req = (WifiP2pServiceRequest) message.obj;
             if (m == null || req == null) {
                 Log.e(TAG, "Illegal argument(s)");
+                errorCode.set(WifiP2pManager.ERROR);
+                return false;
+            }
+            clearClientDeadChannels();
+
+            ClientInfo clientInfo = getClientInfo(m, false);
+            if (clientInfo == null) {
                 return false;
             }
-            if (Environment.isSdkAtLeastB() && Flags.wifiDirectR2()
-                    && isFeatureSupported(WifiP2pManager.FEATURE_WIFI_DIRECT_R2)) {
-                if (req.getWifiP2pUsdBasedServiceConfig() != null) {
+
+            if (Environment.isSdkAtLeastB() && req.getWifiP2pUsdBasedServiceConfig() != null) {
+                if (isWifiDirect2Enabled()) {
                     if (mVerboseLoggingEnabled) {
-                        logd(getName() + " USD service config: "
+                        logd(getName() + " Add USD service config: "
                                 + req.getWifiP2pUsdBasedServiceConfig().toString());
                     }
-                    // TODO implementation
+                    if (clientInfo.mUsdServiceDiscoverList.isEmpty()) {
+                        clientInfo.mUsdServiceDiscoverList.add(req);
+                        return true;
+                    } else {
+                        loge(getName() + "This application already has a service added");
+                        errorCode.set(WifiP2pManager.BUSY);
+                        return false;
+                    }
+                } else {
+                    loge(getName() + "Device doesn't support Wi-Fi Direct R2");
+                    errorCode.set(WifiP2pManager.ERROR);
                     return false;
                 }
             }
-            // TODO: We could track individual service adds separately and avoid
-            // having to do update all service requests on every new request
-            clearClientDeadChannels();
 
-            ClientInfo clientInfo = getClientInfo(m, false);
-            if (clientInfo == null) {
-                return false;
-            }
+            // Add GAS frame based service discovery request.
 
+            // TODO: We could track individual service adds separately and avoid
+            // having to do update all service requests on every new request
             ++mServiceTransactionId;
             // The Wi-Fi p2p spec says transaction id should be 1 byte and non-zero.
             if (mServiceTransactionId == 256) mServiceTransactionId = 1;
             req.setTransactionId((mServiceTransactionId));
             clientInfo.mReqList.put(mServiceTransactionId, req);
-            if (mServiceDiscReqId == null) {
+            if (!mServiceDiscoveryInfo.isValid() || mServiceDiscoveryInfo
+                    .getServiceDiscoveryType() == WifiP2pOngoingServiceDiscoveryRequestInfo
+                    .WIFI_P2P_USD_FRAME_BASED_SERVICE_DISCOVERY) {
                 return true;
             }
-            return updateSupplicantServiceRequest();
+            return updateSupplicantGasFrameBasedServiceRequest();
         }
 
+        @SuppressLint("NewApi")
         private void removeServiceRequest(Messenger m, WifiP2pServiceRequest req) {
             if (m == null || req == null) {
                 Log.e(TAG, "Illegal argument(s)");
+                return;
             }
 
             ClientInfo clientInfo = getClientInfo(m, false);
@@ -8265,21 +8103,37 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
             // Application does not have transaction id information
             // go through stored requests to remove
             boolean removed = false;
-            for (int i = 0; i < clientInfo.mReqList.size(); i++) {
-                if (req.equals(clientInfo.mReqList.valueAt(i))) {
-                    removed = true;
-                    clientInfo.mReqList.removeAt(i);
-                    break;
+            if (Environment.isSdkAtLeastB() && req.getWifiP2pUsdBasedServiceConfig() != null) {
+                for (WifiP2pServiceRequest usdServRequest : clientInfo.mUsdServiceDiscoverList) {
+                    if (req.equals(usdServRequest)) {
+                        int sessionId = usdServRequest.getUsdSessionId();
+                        if (sessionId > 0) {
+                            mWifiNative.stopUsdBasedServiceDiscovery(sessionId);
+                        }
+                        clientInfo.mUsdServiceDiscoverList.remove(usdServRequest);
+                        removed = true;
+                        break;
+                    }
+                }
+            } else {
+                for (int i = 0; i < clientInfo.mReqList.size(); i++) {
+                    if (req.equals(clientInfo.mReqList.valueAt(i))) {
+                        removed = true;
+                        clientInfo.mReqList.removeAt(i);
+                        break;
+                    }
                 }
             }
 
             if (!removed) return;
 
-            if (mServiceDiscReqId == null) {
+            if (!mServiceDiscoveryInfo.isValid() || mServiceDiscoveryInfo
+                    .getServiceDiscoveryType() == WifiP2pOngoingServiceDiscoveryRequestInfo
+                    .WIFI_P2P_USD_FRAME_BASED_SERVICE_DISCOVERY) {
                 return;
             }
 
-            updateSupplicantServiceRequest();
+            updateSupplicantGasFrameBasedServiceRequest();
         }
 
         private void clearServiceRequests(Messenger m) {
@@ -8293,19 +8147,31 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 return;
             }
 
-            if (clientInfo.mReqList.size() == 0) {
+            if (clientInfo.mReqList.size() == 0
+                    && clientInfo.mUsdServiceDiscoverList.size() == 0) {
                 return;
             }
 
             clientInfo.mReqList.clear();
 
-            if (mServiceDiscReqId == null) {
+            for (WifiP2pServiceRequest usdServRequest : clientInfo.mUsdServiceDiscoverList) {
+                int sessionId = usdServRequest.getUsdSessionId();
+                if (sessionId > 0) {
+                    mWifiNative.stopUsdBasedServiceDiscovery(sessionId);
+                }
+            }
+            clientInfo.mUsdServiceDiscoverList.clear();
+
+            if (!mServiceDiscoveryInfo.isValid() || mServiceDiscoveryInfo
+                    .getServiceDiscoveryType() == WifiP2pOngoingServiceDiscoveryRequestInfo
+                    .WIFI_P2P_USD_FRAME_BASED_SERVICE_DISCOVERY) {
                 return;
             }
 
-            updateSupplicantServiceRequest();
+            updateSupplicantGasFrameBasedServiceRequest();
         }
 
+        @SuppressLint("NewApi")
         private boolean addLocalService(@NonNull Message message) {
             Messenger m = message.replyTo;
             Bundle extras = message.getData()
@@ -8316,12 +8182,6 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 Log.e(TAG, "Illegal arguments");
                 return false;
             }
-            int addLocalServiceType = message.arg1;
-            if (addLocalServiceType
-                    == WifiP2pManager.WIFI_P2P_USD_BASED_ADD_LOCAL_SERVICE) {
-                // TODO implementation
-                return false;
-            }
 
             clearClientDeadChannels();
 
@@ -8331,18 +8191,46 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 return false;
             }
 
-            if (!clientInfo.mServList.add(servInfo)) {
-                return false;
-            }
+            int addLocalServiceType = message.arg1;
+            if (addLocalServiceType
+                    == WifiP2pManager.WIFI_P2P_USD_BASED_ADD_LOCAL_SERVICE) {
+                if (!isWifiDirect2Enabled()) {
+                    return false;
+                }
+                int sessionId = 0;
+                if (Environment.isSdkAtLeastB()
+                        && servInfo.getWifiP2pUsdBasedServiceConfig() != null) {
+                    WifiP2pUsdBasedServiceConfig usdServiceConfig =
+                            servInfo.getWifiP2pUsdBasedServiceConfig();
+                    WifiP2pUsdBasedLocalServiceAdvertisementConfig advertisementConfig =
+                            extras.getParcelable(WifiP2pManager
+                                    .EXTRA_PARAM_KEY_USD_BASED_LOCAL_SERVICE_ADVERTISEMENT_CONFIG);
+                    sessionId = mWifiNative.startUsdBasedServiceAdvertisement(usdServiceConfig,
+                            advertisementConfig,
+                            USD_BASED_SERVICE_ADVERTISEMENT_DISCOVERY_TIMEOUT_S);
 
-            if (!mWifiNative.p2pServiceAdd(servInfo)) {
-                clientInfo.mServList.remove(servInfo);
-                return false;
+                }
+                if (sessionId > 0) {
+                    servInfo.setUsdSessionId(sessionId);
+                    clientInfo.mUsdServiceAdvertiseList.add(servInfo);
+                    sendP2pListenChangedBroadcast(true);
+                } else {
+                    return false;
+                }
+            } else {
+                if (!clientInfo.mServList.add(servInfo)) {
+                    return false;
+                }
+                if (!mWifiNative.p2pServiceAdd(servInfo)) {
+                    clientInfo.mServList.remove(servInfo);
+                    return false;
+                }
             }
 
             return true;
         }
 
+        @SuppressLint("NewApi")
         private void removeLocalService(Messenger m, WifiP2pServiceInfo servInfo) {
             if (m == null || servInfo == null) {
                 Log.e(TAG, "Illegal arguments");
@@ -8354,8 +8242,21 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 return;
             }
 
-            mWifiNative.p2pServiceDel(servInfo);
-            clientInfo.mServList.remove(servInfo);
+            if (Environment.isSdkAtLeastB() && servInfo.getWifiP2pUsdBasedServiceConfig() != null) {
+                for (WifiP2pServiceInfo savedServInfo: clientInfo.mUsdServiceAdvertiseList) {
+                    if (servInfo.equals(savedServInfo)) {
+                        int sessionId = savedServInfo.getUsdSessionId();
+                        if (sessionId > 0) {
+                            mWifiNative.stopUsdBasedServiceAdvertisement(sessionId);
+                        }
+                        clientInfo.mUsdServiceAdvertiseList.remove(servInfo);
+                        break;
+                    }
+                }
+            } else {
+                mWifiNative.p2pServiceDel(servInfo);
+                clientInfo.mServList.remove(servInfo);
+            }
         }
 
         private void clearLocalServices(Messenger m) {
@@ -8369,6 +8270,15 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
                 return;
             }
 
+            for (WifiP2pServiceInfo savedServInfo: clientInfo.mUsdServiceAdvertiseList) {
+                int sessionId = savedServInfo.getUsdSessionId();
+                if (sessionId > 0) {
+                    mWifiNative.stopUsdBasedServiceAdvertisement(sessionId);
+                }
+            }
+
+            clientInfo.mUsdServiceAdvertiseList.clear();
+
             for (WifiP2pServiceInfo servInfo: clientInfo.mServList) {
                 mWifiNative.p2pServiceDel(servInfo);
             }
@@ -8389,33 +8299,52 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
 
         /**
          * Send the service response to the WifiP2pManager.Channel.
-         * @param WifiP2pServiceResponse response to service discovery
+         * @param resp {@link WifiP2pServiceResponse} response to service discovery
          */
         private void sendServiceResponse(WifiP2pServiceResponse resp) {
+            WifiP2pServiceRequest req = null;
+            ClientInfo client = null;
             if (resp == null) {
                 Log.e(TAG, "sendServiceResponse with null response");
                 return;
             }
             for (ClientInfo c : mClientInfoList.values()) {
-                WifiP2pServiceRequest req = c.mReqList.get(resp.getTransactionId());
-                if (req != null) {
-                    Message msg = Message.obtain();
-                    msg.what = WifiP2pManager.RESPONSE_SERVICE;
-                    msg.arg1 = 0;
-                    msg.arg2 = 0;
-                    msg.obj = resp;
-                    if (c.mMessenger == null) {
-                        continue;
+                if (Environment.isSdkAtLeastB()
+                        && resp.getWifiP2pUsdBasedServiceResponse() != null) {
+                    for (WifiP2pServiceRequest serviceRequest : c.mUsdServiceDiscoverList) {
+                        if (serviceRequest.getUsdSessionId() == resp.getUsdSessionId()) {
+                            client = c;
+                            req = serviceRequest;
+                            break;
+                        }
+
                     }
-                    try {
-                        c.mMessenger.send(msg);
-                    } catch (RemoteException e) {
-                        if (mVerboseLoggingEnabled) logd("detect dead channel");
-                        clearClientInfo(c.mMessenger);
-                        return;
+                } else {
+                    WifiP2pServiceRequest serviceRequest = c.mReqList.get(resp.getTransactionId());
+                    if (serviceRequest != null) {
+                        client = c;
+                        req = serviceRequest;
+                        break;
                     }
                 }
             }
+
+            if (req != null) {
+                Message msg = Message.obtain();
+                msg.what = WifiP2pManager.RESPONSE_SERVICE;
+                msg.arg1 = 0;
+                msg.arg2 = 0;
+                msg.obj = resp;
+                if (client.mMessenger == null) {
+                    return;
+                }
+                try {
+                    client.mMessenger.send(msg);
+                } catch (RemoteException e) {
+                    if (mVerboseLoggingEnabled) logd("detect dead channel");
+                    clearClientInfo(client.mMessenger);
+                }
+            }
         }
 
         /**
@@ -8925,12 +8854,18 @@ public class WifiP2pServiceImpl extends IWifiP2pManager.Stub {
         private String mPackageName;
         @Nullable private String mFeatureId;
 
-        // A service discovery request list.
+        // A service discovery request list using GAS frames.
         private final SparseArray<WifiP2pServiceRequest> mReqList = new SparseArray<>();
 
         // A local service information list.
         private final List<WifiP2pServiceInfo> mServList = new ArrayList<>();
 
+        // A service discovery request list using USD frames.
+        private final List<WifiP2pServiceRequest> mUsdServiceDiscoverList = new ArrayList<>();
+
+        // A service advertise list using USD frames.
+        private final List<WifiP2pServiceInfo> mUsdServiceAdvertiseList = new ArrayList<>();
+
         private ClientInfo(Messenger m) {
             mMessenger = m;
             mPackageName = null;
diff --git a/service/java/com/android/server/wifi/rtt/RttService.java b/service/java/com/android/server/wifi/rtt/RttService.java
index aa13c0b6c0..9242992a08 100644
--- a/service/java/com/android/server/wifi/rtt/RttService.java
+++ b/service/java/com/android/server/wifi/rtt/RttService.java
@@ -62,7 +62,8 @@ public class RttService extends SystemService {
 
             mImpl.start(handlerThread.getLooper(), wifiInjector.getClock(), awareManager,
                     rttMetrics, wifiPermissionsUtil, wifiInjector.getSettingsConfigStore(),
-                    wifiInjector.getHalDeviceManager());
+                    wifiInjector.getHalDeviceManager(), wifiInjector.getWifiConfigManager(),
+                    wifiInjector.getSsidTranslator());
         } else if (phase == SystemService.PHASE_BOOT_COMPLETED) {
             mImpl.handleBootCompleted();
         }
diff --git a/service/java/com/android/server/wifi/rtt/RttServiceImpl.java b/service/java/com/android/server/wifi/rtt/RttServiceImpl.java
index 930368e1b0..10cbe18e11 100644
--- a/service/java/com/android/server/wifi/rtt/RttServiceImpl.java
+++ b/service/java/com/android/server/wifi/rtt/RttServiceImpl.java
@@ -38,17 +38,21 @@ import android.content.IntentFilter;
 import android.content.pm.PackageManager;
 import android.location.LocationManager;
 import android.net.MacAddress;
+import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiManager;
+import android.net.wifi.WifiSsid;
 import android.net.wifi.aware.IWifiAwareMacAddressProvider;
 import android.net.wifi.aware.MacAddrMapping;
 import android.net.wifi.aware.WifiAwareManager;
 import android.net.wifi.rtt.IRttCallback;
 import android.net.wifi.rtt.IWifiRttManager;
+import android.net.wifi.rtt.PasnConfig;
 import android.net.wifi.rtt.RangingRequest;
 import android.net.wifi.rtt.RangingResult;
 import android.net.wifi.rtt.RangingResultCallback;
 import android.net.wifi.rtt.ResponderConfig;
 import android.net.wifi.rtt.ResponderLocation;
+import android.net.wifi.rtt.SecureRangingConfig;
 import android.net.wifi.rtt.WifiRttManager;
 import android.os.Binder;
 import android.os.Bundle;
@@ -73,7 +77,9 @@ import com.android.server.wifi.BuildProperties;
 import com.android.server.wifi.Clock;
 import com.android.server.wifi.FrameworkFacade;
 import com.android.server.wifi.HalDeviceManager;
+import com.android.server.wifi.SsidTranslator;
 import com.android.server.wifi.SystemBuildProperties;
+import com.android.server.wifi.WifiConfigManager;
 import com.android.server.wifi.WifiSettingsConfigStore;
 import com.android.server.wifi.hal.WifiRttController;
 import com.android.server.wifi.proto.nano.WifiMetricsProto;
@@ -116,8 +122,8 @@ public class RttServiceImpl extends IWifiRttManager.Stub {
     private final BuildProperties mBuildProperties;
     private FrameworkFacade mFrameworkFacade;
     private WifiRttController.Capabilities mCapabilities;
-
     private RttServiceSynchronized mRttServiceSynchronized;
+    private SsidTranslator mWifiSsidTranslator;
 
     /* package */ static final String HAL_RANGING_TIMEOUT_TAG = TAG + " HAL Ranging Timeout";
 
@@ -128,6 +134,7 @@ public class RttServiceImpl extends IWifiRttManager.Stub {
 
     // arbitrary, larger than anything reasonable
     /* package */ static final int MAX_QUEUED_PER_UID = 20;
+    private WifiConfigManager mWifiConfigManager;
 
     private final WifiRttController.RttControllerRangingResultsCallback mRangingResultsCallback =
             new WifiRttController.RttControllerRangingResultsCallback() {
@@ -311,10 +318,14 @@ public class RttServiceImpl extends IWifiRttManager.Stub {
      * @param wifiPermissionsUtil Utility for permission checks.
      * @param settingsConfigStore Used for retrieving verbose logging level.
      * @param halDeviceManager The HAL device manager object.
+     * @param wifiConfigManager The Wi-Fi configuration manager used to retrieve credentials for
+     *                          secure ranging
+     * @param ssidTranslator SSID translator
      */
     public void start(Looper looper, Clock clock, WifiAwareManager awareManager,
             RttMetrics rttMetrics, WifiPermissionsUtil wifiPermissionsUtil,
-            WifiSettingsConfigStore settingsConfigStore, HalDeviceManager halDeviceManager) {
+            WifiSettingsConfigStore settingsConfigStore, HalDeviceManager halDeviceManager,
+            WifiConfigManager wifiConfigManager, SsidTranslator ssidTranslator) {
         mClock = clock;
         mAwareManager = awareManager;
         mHalDeviceManager = halDeviceManager;
@@ -323,6 +334,8 @@ public class RttServiceImpl extends IWifiRttManager.Stub {
         mRttServiceSynchronized = new RttServiceSynchronized(looper);
         mActivityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
         mPowerManager = mContext.getSystemService(PowerManager.class);
+        mWifiConfigManager = wifiConfigManager;
+        mWifiSsidTranslator = ssidTranslator;
 
         mRttServiceSynchronized.mHandler.post(() -> {
             IntentFilter intentFilter = new IntentFilter();
@@ -516,6 +529,63 @@ public class RttServiceImpl extends IWifiRttManager.Stub {
         }
     }
 
+    private @WifiConfiguration.SecurityType int getSecurityTypeFromPasnAkms(
+            @PasnConfig.AkmType int akms) {
+        @WifiConfiguration.SecurityType int securityType;
+        // IEEE 802.11az supports PASN authentication with FT, PASN authentication with SAE and
+        // PASN authentication with FILS shared key. On FT PSK and SAE needs pre-shared key or
+        // password.
+        if (akms == PasnConfig.AKM_PASN) {
+            securityType = WifiConfiguration.SECURITY_TYPE_OPEN;
+        } else if ((akms & PasnConfig.AKM_SAE) != 0) {
+            securityType = WifiConfiguration.SECURITY_TYPE_SAE;
+        } else if ((akms & PasnConfig.AKM_FT_PSK_SHA256) != 0
+                || (akms & PasnConfig.AKM_FT_PSK_SHA384) != 0) {
+            // Note: WifiConfiguration is created as PSK. The fast transition (FT) flag is added
+            // before saving to wpa_supplicant. So check for SECURITY_TYPE_PSK.
+            securityType = WifiConfiguration.SECURITY_TYPE_PSK;
+        } else {
+            securityType = WifiConfiguration.SECURITY_TYPE_EAP;
+        }
+        return securityType;
+    }
+
+    /**
+     * Update the PASN password from WifiConfiguration.
+     */
+    private void updatePasswordIfRequired(@NonNull PasnConfig pasnConfig) {
+        if (pasnConfig.getPassword() != null || pasnConfig.getWifiSsid() == null) {
+            return;
+        }
+        int securityType = getSecurityTypeFromPasnAkms(pasnConfig.getBaseAkms());
+        if (securityType == WifiConfiguration.SECURITY_TYPE_SAE
+                || securityType == WifiConfiguration.SECURITY_TYPE_PSK) {
+            // The SSID within PasnConfig is supplied by an 11az secure ranging application,
+            // which doesn't guarantee UTF-8 encoding. Therefore, a UTF-8 conversion step is
+            // necessary before the SSID can be reliably used by service code.
+            WifiSsid translatedSsid = mWifiSsidTranslator.getTranslatedSsid(
+                    pasnConfig.getWifiSsid());
+            WifiConfiguration wifiConfiguration =
+                    mWifiConfigManager.getConfiguredNetworkWithPassword(translatedSsid,
+                            securityType);
+            if (wifiConfiguration != null) {
+                pasnConfig.setPassword(wifiConfiguration.preSharedKey);
+            }
+        }
+    }
+
+    /**
+     * Update the secure ranging parameters if required.
+     */
+    private void updateSecureRangingParams(RangingRequest request) {
+        for (ResponderConfig rttPeer : request.mRttPeers) {
+            SecureRangingConfig secureRangingConfig = rttPeer.getSecureRangingConfig();
+            if (secureRangingConfig != null) {
+                updatePasswordIfRequired(secureRangingConfig.getPasnConfig());
+            }
+        }
+    }
+
     /**
      * Binder interface API to start a ranging operation. Called on binder thread, operations needs
      * to be posted to handler thread.
@@ -620,6 +690,7 @@ public class RttServiceImpl extends IWifiRttManager.Stub {
         }
 
         override11azOverlays(request);
+        updateSecureRangingParams(request);
 
         mRttServiceSynchronized.mHandler.post(() -> {
             WorkSource sourceToUse = ws;
@@ -1381,6 +1452,17 @@ public class RttServiceImpl extends IWifiRttManager.Stub {
                             && !resultForRequest.getVendorData().isEmpty()) {
                         builder.setVendorData(resultForRequest.getVendorData());
                     }
+                    // set secure ranging fields
+                    builder.setRangingFrameProtected(resultForRequest.isRangingFrameProtected())
+                            .setRangingAuthenticated(resultForRequest.isRangingAuthenticated())
+                            .setSecureHeLtfEnabled(resultForRequest.isSecureHeLtfEnabled())
+                            .setSecureHeLtfProtocolVersion(
+                                    resultForRequest.getSecureHeLtfProtocolVersion());
+                    if (resultForRequest.getPasnComebackCookie() != null) {
+                        builder.setPasnComebackCookie(resultForRequest.getPasnComebackCookie());
+                        builder.setPasnComebackAfterMillis(
+                                resultForRequest.getPasnComebackAfterMillis());
+                    }
                     finalResults.add(builder.build());
                 }
             }
diff --git a/service/java/com/android/server/wifi/scanner/WifiScannerInternal.java b/service/java/com/android/server/wifi/scanner/WifiScannerInternal.java
index 713edd792e..7dac6f1264 100644
--- a/service/java/com/android/server/wifi/scanner/WifiScannerInternal.java
+++ b/service/java/com/android/server/wifi/scanner/WifiScannerInternal.java
@@ -26,6 +26,7 @@ import android.os.WorkSource;
 import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.modules.utils.ParceledListSlice;
 import com.android.server.wifi.WifiThreadRunner;
 
 import java.util.Collections;
@@ -93,9 +94,9 @@ public abstract class WifiScannerInternal {
         }
 
         @Override
-        public void onFullResults(List<ScanResult> fullScanResult) {
-            mWifiThreadRunner.post(() -> fullScanResult.forEach(mScanListener::onFullResult),
-                    TAG + "#onFullResults");
+        public void onFullResults(ParceledListSlice<ScanResult> fullScanResult) {
+            mWifiThreadRunner.post(() -> fullScanResult.getList()
+                            .forEach(mScanListener::onFullResult), TAG + "#onFullResults");
         }
 
         @Override
diff --git a/service/java/com/android/server/wifi/scanner/WifiScanningServiceImpl.java b/service/java/com/android/server/wifi/scanner/WifiScanningServiceImpl.java
index 4dead3e34b..e8c37cf1b3 100644
--- a/service/java/com/android/server/wifi/scanner/WifiScanningServiceImpl.java
+++ b/service/java/com/android/server/wifi/scanner/WifiScanningServiceImpl.java
@@ -61,6 +61,7 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.Protocol;
 import com.android.internal.util.State;
 import com.android.internal.util.StateMachine;
+import com.android.modules.utils.ParceledListSlice;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.ClientModeImpl;
 import com.android.server.wifi.Clock;
@@ -267,13 +268,13 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
             notifyFailure(listener, WifiScanner.REASON_NOT_AUTHORIZED, "Not authorized");
             return;
         }
-        ExternalClientInfo client = (ExternalClientInfo) mClients.get(listener);
-        if (client == null) {
-            logw("no client registered: " + uid + ", listener=" + listener
-                    + " AttributionTag " + featureId);
-            return;
-        }
         mWifiThreadRunner.post(() -> {
+            ExternalClientInfo client = (ExternalClientInfo) mClients.get(listener);
+            if (client == null) {
+                logw("no client registered: " + uid + ", listener=" + listener
+                        + " AttributionTag " + featureId);
+                return;
+            }
             logScanRequest("deregisterScanListener", client, null, null, null);
             mSingleScanListeners.removeRequest(client);
             client.cleanup();
@@ -1740,9 +1741,10 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
                 }
                 entry.clientInfo.reportEvent((listener) -> {
                     try {
-                        listener.onFullResults(new ArrayList<>(matchedScanResults));
+                        listener.onFullResults(
+                                new ParceledListSlice<>(new ArrayList<>(matchedScanResults)));
                     } catch (RemoteException e) {
-                        loge("Failed to call onFullResult: " + entry.clientInfo);
+                        loge("Failed to call onFullResults: " + entry.clientInfo);
                     }
                 });
                 matchedScanResults.clear();
@@ -1751,9 +1753,9 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
             for (RequestInfo<Void> entry : mSingleScanListeners) {
                 entry.clientInfo.reportEvent((listener) -> {
                     try {
-                        listener.onFullResults(results);
+                        listener.onFullResults(new ParceledListSlice<>(results));
                     } catch (RemoteException e) {
-                        loge("Failed to call onFullResult: " + entry.clientInfo);
+                        loge("Failed to call onFullResults: " + entry.clientInfo);
                     }
                 });
             }
@@ -1779,7 +1781,7 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
                         // make sure the handler is removed
                         listener.onSingleScanCompleted();
                     } catch (RemoteException e) {
-                        loge("Failed to call onResult: " + entry.clientInfo);
+                        loge("Failed to call onResults: " + entry.clientInfo);
                     }
                 });
             }
@@ -1791,7 +1793,7 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
                     try {
                         listener.onResults(allResults);
                     } catch (RemoteException e) {
-                        loge("Failed to call onResult: " + entry.clientInfo);
+                        loge("Failed to call onResults: " + entry.clientInfo);
                     }
                 });
             }
@@ -2314,9 +2316,10 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
                     }
                     entry.clientInfo.reportEvent((listener) -> {
                         try {
-                            listener.onFullResults(new ArrayList<>(matchedResults));
+                            listener.onFullResults(
+                                    new ParceledListSlice<>(new ArrayList<>(matchedResults)));
                         } catch (RemoteException e) {
-                            loge("Failed to call onFullResult: " + ci);
+                            loge("Failed to call onFullResults: " + ci);
                         }
                     });
                 }
@@ -2350,7 +2353,7 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
                         try {
                             listener.onResults(resultsToDeliver);
                         } catch (RemoteException e) {
-                            loge("Failed to call onFullResult: " + ci);
+                            loge("Failed to call onResults: " + ci);
                         }
                     });
                 }
@@ -2364,7 +2367,7 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
                     try {
                         listener.onFailure(reason, description);
                     } catch (RemoteException e) {
-                        loge("Failed to call onFullResult: " + ci);
+                        loge("Failed to call onFailure: " + ci);
                     }
                 });
             }
@@ -3229,7 +3232,7 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
                     try {
                         listener.onPnoNetworkFound(results);
                     } catch (RemoteException e) {
-                        loge("Failed to call onFullResult: " + ci);
+                        loge("Failed to call onPnoNetworkFound: " + ci);
                     }
                 });
             }
@@ -3242,7 +3245,7 @@ public class WifiScanningServiceImpl extends IWifiScanner.Stub {
                     try {
                         listener.onFailure(reason, description);
                     } catch (RemoteException e) {
-                        loge("Failed to call onFullResult: " + ci);
+                        loge("Failed to call onFailure: " + ci);
                     }
                 });
             }
diff --git a/service/java/com/android/server/wifi/usd/UsdNativeManager.java b/service/java/com/android/server/wifi/usd/UsdNativeManager.java
new file mode 100644
index 0000000000..5c0e3dc0b6
--- /dev/null
+++ b/service/java/com/android/server/wifi/usd/UsdNativeManager.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi.usd;
+
+import android.net.MacAddress;
+import android.net.wifi.usd.PublishConfig;
+import android.net.wifi.usd.PublishSessionCallback;
+import android.net.wifi.usd.SessionCallback;
+import android.net.wifi.usd.SubscribeConfig;
+import android.net.wifi.usd.SubscribeSessionCallback;
+
+import com.android.server.wifi.SupplicantStaIfaceHal;
+import com.android.server.wifi.WifiNative;
+
+import java.util.concurrent.Executor;
+
+/**
+ * Manages the interface to the HAL.
+ */
+public class UsdNativeManager {
+    private final WifiNative mWifiNative;
+
+    /**
+     * USD Events from HAL.
+     */
+    public interface UsdEventsCallback {
+        /**
+         * Called when publisher is started.
+         */
+        void onUsdPublishStarted(int cmdId, int publishId);
+
+        /**
+         * Called when subscribe is started.
+         */
+        void onUsdSubscribeStarted(int cmdId, int subscribeId);
+
+        /**
+         * Called when publisher is failed to start.
+         */
+        void onUsdPublishConfigFailed(int cmdId, @SessionCallback.FailureCode int errorCode);
+
+        /**
+         * Called when subscriber is failed to start.
+         */
+        void onUsdSubscribeConfigFailed(int cmdId, @SessionCallback.FailureCode int errorCode);
+
+        /**
+         * Called when publish session is terminated.
+         */
+        void onUsdPublishTerminated(int publishId,
+                @SessionCallback.TerminationReasonCode int reasonCode);
+
+        /**
+         *  Called when subscribe session is terminated.
+         */
+        void onUsdSubscribeTerminated(int subscribeId,
+                @SessionCallback.TerminationReasonCode int reasonCode);
+
+        /**
+         * Called for each Publish replied event.
+         */
+        void onUsdPublishReplied(
+                UsdRequestManager.UsdHalDiscoveryInfo usdHalDiscoveryInfo);
+
+        /**
+         * Called when the subscriber discovers publisher.
+         */
+        void onUsdServiceDiscovered(
+                UsdRequestManager.UsdHalDiscoveryInfo usdHalDiscoveryInfo);
+
+        /**
+         * Called when a message is received.
+         */
+        void onUsdMessageReceived(int ownId, int peerId, MacAddress peerMacAddress,
+                byte[] message);
+    }
+
+    /**
+     * Constructor
+     */
+    public UsdNativeManager(WifiNative wifiNative) {
+        mWifiNative = wifiNative;
+    }
+
+    /**
+     * Register USD events.
+     */
+    public void registerUsdEventsCallback(
+            UsdRequestManager.UsdNativeEventsCallback usdNativeEventsCallback) {
+        mWifiNative.registerUsdEventsCallback(usdNativeEventsCallback);
+    }
+
+    /**
+     * Gets USD capabilities.
+     */
+    public SupplicantStaIfaceHal.UsdCapabilitiesInternal getUsdCapabilities() {
+        return mWifiNative.getUsdCapabilities();
+    }
+
+    /**
+     * See {@link android.net.wifi.usd.UsdManager#publish(PublishConfig, Executor,
+     * PublishSessionCallback)}
+     */
+    public boolean publish(String interfaceName, int cmdId, PublishConfig publishConfig) {
+        return mWifiNative.startUsdPublish(interfaceName, cmdId, publishConfig);
+    }
+
+    /**
+     * See {@link android.net.wifi.usd.UsdManager#subscribe(SubscribeConfig, Executor,
+     * SubscribeSessionCallback)}
+     */
+    public boolean subscribe(String interfaceName, int cmdId, SubscribeConfig subscribeConfig) {
+        return mWifiNative.startUsdSubscribe(interfaceName, cmdId, subscribeConfig);
+    }
+
+    /**
+     * Update publish.
+     */
+    public void updatePublish(String interfaceName, int publishId, byte[] ssi) {
+        mWifiNative.updateUsdPublish(interfaceName, publishId, ssi);
+    }
+
+    /**
+     * Cancels publish session identified by publishId.
+     */
+    public void cancelPublish(String interfaceName, int publishId) {
+        mWifiNative.cancelUsdPublish(interfaceName, publishId);
+    }
+
+    /**
+     * Cancels subscribe identified by subscribeId
+     */
+    public void cancelSubscribe(String interfaceName, int subscribeId) {
+        mWifiNative.cancelUsdSubscribe(interfaceName, subscribeId);
+    }
+
+    /**
+     * Send a message to the peer identified by the peerId and the peerMacAddress.
+     */
+    public boolean sendMessage(String interfaceName, int ownId, int peerId,
+            MacAddress peerMacAddress, byte[] message) {
+        return mWifiNative.sendUsdMessage(interfaceName, ownId, peerId, peerMacAddress, message);
+    }
+}
diff --git a/service/java/com/android/server/wifi/usd/UsdRequestManager.java b/service/java/com/android/server/wifi/usd/UsdRequestManager.java
new file mode 100644
index 0000000000..1ea9891913
--- /dev/null
+++ b/service/java/com/android/server/wifi/usd/UsdRequestManager.java
@@ -0,0 +1,929 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi.usd;
+
+import android.annotation.NonNull;
+import android.annotation.SuppressLint;
+import android.app.AlarmManager;
+import android.net.MacAddress;
+import android.net.wifi.IBooleanListener;
+import android.net.wifi.usd.Characteristics;
+import android.net.wifi.usd.Config;
+import android.net.wifi.usd.IPublishSessionCallback;
+import android.net.wifi.usd.ISubscribeSessionCallback;
+import android.net.wifi.usd.PublishConfig;
+import android.net.wifi.usd.PublishSession;
+import android.net.wifi.usd.PublishSessionCallback;
+import android.net.wifi.usd.SessionCallback;
+import android.net.wifi.usd.SubscribeConfig;
+import android.net.wifi.usd.SubscribeSession;
+import android.net.wifi.usd.SubscribeSessionCallback;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.RemoteCallbackList;
+import android.os.RemoteException;
+import android.util.Log;
+import android.util.SparseArray;
+
+import com.android.server.wifi.ActiveModeWarden;
+import com.android.server.wifi.Clock;
+import com.android.server.wifi.SupplicantStaIfaceHal;
+import com.android.server.wifi.WifiThreadRunner;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.Executor;
+import java.util.function.Consumer;
+
+import javax.annotation.concurrent.NotThreadSafe;
+
+/**
+ * This class UsdRequestManager acts as central point for handling various USD requests from
+ * applications such as publish, subscribe, send message, etc. It sends the command to HAL to
+ * carry out these actions and expect for callbacks from HAL on various events such as susbcribe/
+ * publish started, service discovered, received a message from the peer, etc.
+ *
+ * <p>Here is how it works,
+ * <ul>
+ * <li>Role: The UsdRequestManager can act as either a publisher or subscriber
+ * <li>Request handling: It manages incoming requests and ensures the new commands are not accepted
+ * while a previous subscribe or publish is still awaiting for the response from HAL.
+ * <li>Session Management: USD session are organized and tracked using unique session IDs. Each
+ * session maintains a collection of USD discovery results which are indexed by the USD peer.
+ * <li>USD Peer: A peer is created for discover and also created a unique id (hash) which maps to
+ * local session id, remote session id and remote mac address. Applications are given this unique
+ * id (hash) on various indications.
+ *
+ * <p>Essentially, this class streamlines USD communication by managing requests, organizing
+ * sessions, and maintaining information about discovered peers. It also enforces a sequential
+ * processing of requests to prevent conflicts and ensure reliable communication with HAL.
+ * </ul>
+ */
+@NotThreadSafe
+@SuppressLint("NewApi")
+public class UsdRequestManager {
+    public static final String TAG = "UsdRequestManager";
+    private static final int DEFAULT_COMMAND_ID = 100;
+    private static final int USD_TEMP_SESSION_ID = 255;
+    private static final int INVALID_ID = -1;
+    private static final String USD_REQUEST_MANAGER_ALARM_TAG = "UsdRequestManagerAlarmTag";
+
+    /**
+     * A unique peer hash (a unique peer id) generator. Application will get the peer hash as the
+     * identifier of the peer. Also peer hash is globally mapped to a peer (defined by ownId,
+     * peerId and peer mac address).
+     */
+    private static int sNextPeerHash = 100;
+    private final UsdNativeManager mUsdNativeManager;
+    private final ActiveModeWarden mActiveModeWarden;
+    private SupplicantStaIfaceHal.UsdCapabilitiesInternal mUsdCapabilities;
+    private final WifiThreadRunner mWifiThreadRunner;
+    private final Clock mClock;
+    private enum Role {
+        NONE, PUBLISHER, SUBSCRIBER
+    }
+    private Role mRequesterRole;
+    private final AlarmManager mAlarmManager;
+    private final AlarmManager.OnAlarmListener mTimeoutListener = () -> {
+        startCleaningUpExpiredSessions();
+    };
+    private static final int TEMP_SESSION_TIMEOUT_MILLIS = 1000;
+    private static final int TTL_GAP_MILLIS = 1000;
+
+    private final RemoteCallbackList<IBooleanListener> mPublisherListenerList =
+            new RemoteCallbackList<IBooleanListener>();
+    private final RemoteCallbackList<IBooleanListener> mSubscriberListenerList =
+            new RemoteCallbackList<IBooleanListener>();
+
+    private void startCleaningUpExpiredSessions() {
+        long current = mClock.getElapsedSinceBootMillis();
+        long nextSchedule = Long.MAX_VALUE;
+        long age;
+        List<Integer> sessionsToDelete = new ArrayList<>();
+
+        // Cleanup sessions which crossed the TTL.
+        for (int i = 0; i < mUsdSessions.size(); i++) {
+            UsdSession usdSession = mUsdSessions.valueAt(i);
+            int sessionId = mUsdSessions.keyAt(i);
+            int ttlMillis = TEMP_SESSION_TIMEOUT_MILLIS;
+            if (sessionId != USD_TEMP_SESSION_ID) {
+                ttlMillis = ((usdSession.getRole() == Role.PUBLISHER)
+                        ? usdSession.mPublishConfig.getTtlSeconds()
+                        : usdSession.mSubscribeConfig.getTtlSeconds()) * 1000 + TTL_GAP_MILLIS;
+            }
+            age = current - usdSession.mCreationTimeMillis;
+            if (age >= ttlMillis) {
+                sessionsToDelete.add(sessionId);
+            } else {
+                nextSchedule = Math.min(ttlMillis - age, nextSchedule);
+            }
+        }
+
+        for (int sessionId : sessionsToDelete) {
+            mUsdSessions.get(sessionId).sessionCleanup();
+            mUsdSessions.remove(sessionId);
+        }
+
+        // Reschedule if necessary.
+        if (mUsdSessions.size() > 0 && nextSchedule < Long.MAX_VALUE) {
+            mAlarmManager.set(AlarmManager.ELAPSED_REALTIME,
+                    mClock.getElapsedSinceBootMillis() + nextSchedule,
+                    USD_REQUEST_MANAGER_ALARM_TAG, mTimeoutListener,
+                    mWifiThreadRunner.getHandler());
+        }
+    }
+
+    private void stopCleaningUpExpiredSessions() {
+        mAlarmManager.cancel(mTimeoutListener);
+    }
+
+    /**
+     * A class to represent USD peer. A combination of ownId, peerId and peerMacAddress define a
+     * unique peer.
+     */
+    public static final class UsdPeer {
+        public final int ownId;
+        public final int peerId;
+        public final MacAddress peerMacAddress;
+
+        public UsdPeer(int ownId, int peerId, MacAddress peerMacAddress) {
+            this.ownId = ownId;
+            this.peerId = peerId;
+            this.peerMacAddress = peerMacAddress;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof UsdPeer peer)) return false;
+            return ownId == peer.ownId && peerId == peer.peerId && peerMacAddress.equals(
+                    peer.peerMacAddress);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(ownId, peerId, peerMacAddress);
+        }
+    }
+
+    /**
+     * A class representing USD session.
+     */
+    private final class UsdSession implements IBinder.DeathRecipient {
+        private int mId = INVALID_ID;
+        private Role mSessionRole = Role.NONE;
+        private PublishConfig mPublishConfig;
+        private IPublishSessionCallback mIPublishSessionCallback;
+        private SubscribeConfig mSubscribeConfig;
+        private ISubscribeSessionCallback mISubscribeSessionCallback;
+        private final long mCreationTimeMillis;
+        /**
+         * Maps peer to peer hash (a unique identifier to the peer).
+         */
+        private final HashMap<UsdPeer, Integer> mSessionPeers = new HashMap<>();
+
+        /**
+         * Get Role of the session. See {@link Role} for different roles.
+         */
+        public Role getRole() {
+            return mSessionRole;
+        }
+
+        /**
+         * Set session id for this session.
+         */
+        public void setSessionId(int sessionId) {
+            mId = sessionId;
+        }
+
+        /**
+         * Adds a peer to the session if not already there. It creates a unique id (key) and add the
+         * peer to a map.
+         */
+        public void addPeerOnce(UsdPeer peer) {
+            if (mSessionPeers.containsKey(peer)) return;
+            int peerHash = sNextPeerHash++;
+            mSessionPeers.put(peer, peerHash);
+            addPeerToGlobalMap(peerHash, peer);
+        }
+
+        /**
+         * Get unique hash (a unique id) for a peer.
+         */
+        public int getPeerHash(UsdPeer peer) {
+            return mSessionPeers.getOrDefault(peer, INVALID_ID);
+        }
+
+        /**
+         * Clear all peers for this session.
+         */
+        public void releasePeers() {
+            // Release all peers associated to this session from global map.
+            for (int peerHash : mSessionPeers.values()) {
+                removePeerFromGlobalMap(peerHash);
+            }
+            mSessionPeers.clear();
+        }
+
+        /**
+         * A constructor for publisher session.
+         */
+        UsdSession(PublishConfig publishConfig, IPublishSessionCallback callback) {
+            mSessionRole = Role.PUBLISHER;
+            mPublishConfig = publishConfig;
+            mIPublishSessionCallback = callback;
+            // Register the recipient for a notification if this binder goes away.
+            try {
+                callback.asBinder().linkToDeath(this, 0);
+            } catch (RemoteException e) {
+                Log.e(TAG, "UsdSession linkToDeath " + e);
+            }
+            mCreationTimeMillis = mClock.getElapsedSinceBootMillis();
+        }
+
+        /**
+         * A constructor for subscriber session.
+         */
+        UsdSession(SubscribeConfig subscribeConfig, ISubscribeSessionCallback callback) {
+            mSessionRole = Role.SUBSCRIBER;
+            mSubscribeConfig = subscribeConfig;
+            mISubscribeSessionCallback = callback;
+            // Register the recipient for a notification if this binder goes away.
+            try {
+                callback.asBinder().linkToDeath(this, 0);
+            } catch (RemoteException e) {
+                Log.e(TAG, "UsdSession linkToDeath " + e);
+            }
+            mCreationTimeMillis = mClock.getElapsedSinceBootMillis();
+        }
+
+        @Override
+        public void binderDied() {
+            mWifiThreadRunner.post(() -> sessionCleanup());
+        }
+
+        /**
+         * A sessionCleanup function for the USD session.
+         */
+        public void sessionCleanup() {
+            releasePeers();
+            if (mSessionRole == Role.PUBLISHER) {
+                mIPublishSessionCallback.asBinder().unlinkToDeath(this, 0);
+            } else {
+                mISubscribeSessionCallback.asBinder().unlinkToDeath(this, 0);
+            }
+            if (isSingleSession()) {
+                mRequesterRole = Role.NONE;
+                stopCleaningUpExpiredSessions();
+                // Once last session is cleaned up, broadcast subscriber/publisher status.
+                if (mSessionRole == Role.PUBLISHER) {
+                    broadcastSubscriberStatus();
+                } else {
+                    broadcastPublisherStatus();
+                }
+            }
+            mUsdSessions.remove(mId);
+            mSessionRole = Role.NONE;
+        }
+    }
+
+    /**
+     * A class for USD discovery info from HAL.
+     */
+    public static final class UsdHalDiscoveryInfo {
+        public final int ownId;
+        public final int peerId;
+        public MacAddress peerMacAddress;
+        public final byte[] serviceSpecificInfo;
+        @Config.ServiceProtoType
+        public final int serviceProtoType;
+        public final boolean isFsdEnabled;
+        public final byte[] matchFilter;
+
+        public UsdHalDiscoveryInfo(int ownId, int peerId, MacAddress peerMacAddress,
+                byte[] serviceSpecificInfo, int serviceProtoType, boolean isFsdEnabled,
+                byte[] matchFilter) {
+            this.ownId = ownId;
+            this.peerId = peerId;
+            this.peerMacAddress = peerMacAddress;
+            this.serviceSpecificInfo = serviceSpecificInfo;
+            this.serviceProtoType = serviceProtoType;
+            this.isFsdEnabled = isFsdEnabled;
+            this.matchFilter = matchFilter;
+        }
+    }
+
+    private final SparseArray<UsdSession> mUsdSessions = new SparseArray<>();
+    private final SparseArray<UsdPeer> mGlobalPeerMap = new SparseArray<>();
+
+    private boolean isSingleSession() {
+        return mUsdSessions.size() == 1;
+    }
+
+    /**
+     * Add peer to the global peer map.
+     */
+    private void addPeerToGlobalMap(int peerHash, UsdPeer peer) {
+        mGlobalPeerMap.put(peerHash, peer);
+    }
+
+    /**
+     * Checks whether peer existing in the global peer map.
+     */
+    private boolean doesPeerExistInGlobalMap(int peerHash) {
+        return mGlobalPeerMap.contains(peerHash);
+    }
+
+    /**
+     * Gets peer from the global peer map. Returns null if peer does not exist.
+     */
+    private UsdPeer getPeerFromGlobalMap(int peerHash) {
+        return mGlobalPeerMap.get(peerHash);
+    }
+
+    /**
+     * Removes peer from global peer map.
+     */
+    private void removePeerFromGlobalMap(int peerHash) {
+        mGlobalPeerMap.remove(peerHash);
+    }
+
+    /**
+     * Constructor.
+     */
+    public UsdRequestManager(UsdNativeManager usdNativeManager, WifiThreadRunner wifiThreadRunner,
+            ActiveModeWarden activeModeWarden, Clock clock, AlarmManager alarmManager) {
+        mUsdNativeManager = usdNativeManager;
+        mActiveModeWarden = activeModeWarden;
+        mWifiThreadRunner = wifiThreadRunner;
+        registerUsdEventsCallback(new UsdNativeEventsCallback());
+        mClock = clock;
+        mAlarmManager = alarmManager;
+        mRequesterRole = Role.NONE;
+    }
+
+    private boolean isUsdPublisherSupported() {
+        return mUsdCapabilities != null && mUsdCapabilities.isUsdPublisherSupported;
+    }
+
+    private boolean isUsdSubscriberSupported() {
+        return mUsdCapabilities != null && mUsdCapabilities.isUsdSubscriberSupported;
+    }
+
+    /**
+     * Get USD characteristics.
+     */
+    public Characteristics getCharacteristics() {
+        Bundle bundle = new Bundle();
+        if (mUsdCapabilities == null) {
+            mUsdCapabilities = mUsdNativeManager.getUsdCapabilities();
+        }
+        if (mUsdCapabilities != null) {
+            bundle.putInt(Characteristics.KEY_MAX_NUM_SUBSCRIBE_SESSIONS,
+                    mUsdCapabilities.maxNumSubscribeSessions);
+            bundle.putInt(Characteristics.KEY_MAX_NUM_PUBLISH_SESSIONS,
+                    mUsdCapabilities.maxNumPublishSessions);
+            bundle.putInt(Characteristics.KEY_MAX_SERVICE_SPECIFIC_INFO_LENGTH,
+                    mUsdCapabilities.maxLocalSsiLengthBytes);
+            bundle.putInt(Characteristics.KEY_MAX_MATCH_FILTER_LENGTH,
+                    mUsdCapabilities.maxMatchFilterLengthBytes);
+            bundle.putInt(Characteristics.KEY_MAX_SERVICE_NAME_LENGTH,
+                    mUsdCapabilities.maxServiceNameLengthBytes);
+        }
+        return new Characteristics(bundle);
+    }
+
+    /**
+     * Whether subscriber is available.
+     */
+    public boolean isSubscriberAvailable() {
+        return mUsdSessions.size() == 0 || mUsdSessions.valueAt(0).mSessionRole == Role.SUBSCRIBER;
+    }
+
+    /**
+     * Whether publisher is available.
+     */
+    public boolean isPublisherAvailable() {
+        return mUsdSessions.size() == 0 || mUsdSessions.valueAt(0).mSessionRole == Role.PUBLISHER;
+    }
+
+    private void notifyStatus(IBooleanListener listener, String errMsg, boolean isSuccess) {
+        if (!isSuccess) {
+            Log.e(TAG, "notifyStatus: " + errMsg);
+        }
+        try {
+            listener.onResult(isSuccess);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.toString());
+        }
+    }
+
+    private String getUsdInterfaceName() {
+        return mActiveModeWarden.getPrimaryClientModeManager().getInterfaceName();
+    }
+
+    /**
+     * See {@link SubscribeSession#sendMessage(int, byte[], Executor, Consumer)} and
+     * {@link PublishSession#sendMessage(int, byte[], Executor, Consumer)}
+     */
+    public void sendMessage(int sessionId, int peerHash, @NonNull byte[] message,
+            @NonNull IBooleanListener listener) {
+        if (!isUsdAvailable()) {
+            notifyStatus(listener, "USD is not available", false);
+            return;
+        }
+        if (getUsdInterfaceName() == null) {
+            notifyStatus(listener, "USD interface name is null", false);
+            return;
+        }
+        if (!mUsdSessions.contains(sessionId)) {
+            notifyStatus(listener, "Session does not exist. Session id = " + sessionId, false);
+            return;
+        }
+        if (message.length > mUsdCapabilities.maxLocalSsiLengthBytes) {
+            notifyStatus(listener, "longer message than supported. Max len supported = "
+                    + mUsdCapabilities.maxLocalSsiLengthBytes + " len = " + message.length, false);
+            return;
+        }
+        if (!doesPeerExistInGlobalMap(peerHash)) {
+            notifyStatus(listener, "Invalid peer hash = " + peerHash, false);
+            return;
+        }
+        UsdPeer peer = getPeerFromGlobalMap(peerHash);
+        if (mUsdNativeManager.sendMessage(getUsdInterfaceName(), sessionId, peer.peerId,
+                peer.peerMacAddress, message)) {
+            notifyStatus(listener, "", true);
+        } else {
+            notifyStatus(listener, "sendMessage failed", false);
+        }
+    }
+
+    private boolean isUsdAvailable() {
+        if (mRequesterRole == Role.PUBLISHER) {
+            return isPublisherAvailable();
+        } else if (mRequesterRole == Role.SUBSCRIBER) {
+            return isSubscriberAvailable();
+        }
+        return false;
+    }
+
+    /**
+     * See {@link SubscribeSession#cancel()}
+     */
+    public void cancelSubscribe(int sessionId) {
+        if (getUsdInterfaceName() == null) {
+            Log.e(TAG, "cancelSubscribe: USD interface name is null");
+            return;
+        }
+        if (mRequesterRole == Role.SUBSCRIBER && mUsdSessions.contains(sessionId)) {
+            mUsdNativeManager.cancelSubscribe(getUsdInterfaceName(), sessionId);
+        }
+    }
+
+    /**
+     * See {@link PublishSession#cancel()}
+     */
+    public void cancelPublish(int sessionId) {
+        if (getUsdInterfaceName() == null) {
+            Log.e(TAG, "cancelPublish: USD interface name is null");
+            return;
+        }
+        if (mRequesterRole == Role.PUBLISHER && mUsdSessions.contains(sessionId)) {
+            mUsdNativeManager.cancelPublish(getUsdInterfaceName(), sessionId);
+        }
+    }
+
+    /**
+     * See {@link PublishSession#updatePublish(byte[])}
+     */
+    public void updatePublish(int sessionId, byte[] ssi) {
+        if (getUsdInterfaceName() == null) {
+            Log.e(TAG, "updatePublish: USD interface name is null");
+            return;
+        }
+        if (mRequesterRole == Role.PUBLISHER && mUsdSessions.contains(sessionId)
+                && isPublisherAvailable()) {
+            mUsdNativeManager.updatePublish(getUsdInterfaceName(), sessionId, ssi);
+        }
+    }
+
+    private void notifyPublishFailure(IPublishSessionCallback callback, int reasonCode,
+            String reason) {
+        try {
+            Log.w(TAG, reason);
+            callback.onPublishFailed(reasonCode);
+        } catch (RemoteException e) {
+            Log.e(TAG, "publish: " + e);
+        }
+    }
+
+    /**
+     * See {@link android.net.wifi.usd.UsdManager#publish(PublishConfig, Executor,
+     * PublishSessionCallback)}
+     */
+    public void publish(PublishConfig publishConfig, IPublishSessionCallback callback) {
+        if (!isUsdPublisherSupported() || !isPublisherAvailable()) {
+            notifyPublishFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE, "Not available");
+            return;
+        }
+        if (getUsdInterfaceName() == null) {
+            notifyPublishFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE,
+                    "USD interface name is null");
+            return;
+        }
+        // Check if the Role is already taken.
+        if (mRequesterRole == Role.SUBSCRIBER) {
+            notifyPublishFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE,
+                    "Subscriber is running");
+            return;
+        }
+        if (sessionCreationInProgress()) {
+            notifyPublishFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE,
+                    "Publish session creation in progress");
+            return;
+        }
+        // Check if maximum sessions reached
+        if (mUsdSessions.size() >= mUsdCapabilities.maxNumPublishSessions) {
+            notifyPublishFailure(callback, SessionCallback.FAILURE_MAX_SESSIONS_REACHED,
+                    "Maximum number of publish sessions reached, num of sessions = "
+                            + mUsdSessions.size());
+            return;
+        }
+        // publish
+        if (mUsdNativeManager.publish(getUsdInterfaceName(), DEFAULT_COMMAND_ID, publishConfig)) {
+            createPublishSession(publishConfig, callback);
+            // Next: onUsdPublishStarted or  onUsdPublishConfigFailed
+        } else {
+            notifyPublishFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE, "Failed");
+        }
+    }
+
+    private boolean sessionCreationInProgress() {
+        return mUsdSessions.contains(USD_TEMP_SESSION_ID);
+    }
+
+    private void notifySubscribeFailure(ISubscribeSessionCallback callback, int reasonCode,
+            String reason) {
+        try {
+            Log.w(TAG, reason);
+            callback.onSubscribeFailed(reasonCode);
+        } catch (RemoteException e) {
+            Log.e(TAG, "subscribe: " + e);
+        }
+    }
+
+    private void createPublishSession(PublishConfig config, IPublishSessionCallback callback) {
+        UsdSession usdSession = new UsdSession(config, callback);
+        // Use a temp session id. Will get updated in onPublisherStarted.
+        usdSession.setSessionId(USD_TEMP_SESSION_ID);
+        mUsdSessions.put(USD_TEMP_SESSION_ID, usdSession);
+        if (isSingleSession()) {
+            mRequesterRole = Role.PUBLISHER;
+            startCleaningUpExpiredSessions();
+            // After first publisher session is created, notify subscriber status as not available.
+            broadcastSubscriberStatus();
+        }
+    }
+
+    private void createSubscribeSession(SubscribeConfig config,
+            ISubscribeSessionCallback callback) {
+        UsdSession usdSession = new UsdSession(config, callback);
+        // Use a temp session id. Will get updated in onSubscriberStarted.
+        usdSession.setSessionId(USD_TEMP_SESSION_ID);
+        mUsdSessions.put(USD_TEMP_SESSION_ID, usdSession);
+        if (isSingleSession()) {
+            mRequesterRole = Role.SUBSCRIBER;
+            startCleaningUpExpiredSessions();
+            // After first subscriber session is created, notify publisher status as not available.
+            broadcastPublisherStatus();
+        }
+    }
+
+    /**
+     * See {@link android.net.wifi.usd.UsdManager#subscribe(SubscribeConfig, Executor,
+     * SubscribeSessionCallback)}
+     */
+    public void subscribe(SubscribeConfig subscribeConfig, ISubscribeSessionCallback callback) {
+        if (!isUsdSubscriberSupported() || !isSubscriberAvailable()) {
+            notifySubscribeFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE,
+                    "Not available");
+            return;
+        }
+        if (getUsdInterfaceName() == null) {
+            notifySubscribeFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE,
+                    "USD interface name is null");
+            return;
+        }
+        // Check if the Role is already taken.
+        if (mRequesterRole == Role.PUBLISHER) {
+            notifySubscribeFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE,
+                    "Publisher is running");
+            return;
+        }
+        if (sessionCreationInProgress()) {
+            notifySubscribeFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE,
+                    "Subscribe session creation in progress");
+            return;
+        }
+        // Check if maximum sessions reached
+        if (mUsdSessions.size() >= mUsdCapabilities.maxNumSubscribeSessions) {
+            notifySubscribeFailure(callback, SessionCallback.FAILURE_MAX_SESSIONS_REACHED,
+                    "Maximum number of subscribe sessions reached");
+            return;
+        }
+        // subscribe
+        if (mUsdNativeManager.subscribe(getUsdInterfaceName(), DEFAULT_COMMAND_ID,
+                subscribeConfig)) {
+            createSubscribeSession(subscribeConfig, callback);
+            // Next: onUsdSubscribeStarted or onUsdSubscribeConfigFailed
+        } else {
+            notifySubscribeFailure(callback, SessionCallback.FAILURE_NOT_AVAILABLE, "Failed");
+        }
+    }
+
+    /**
+     * Register USD events from HAL.
+     */
+    public void  registerUsdEventsCallback(UsdNativeEventsCallback usdNativeEventsCallback) {
+        mUsdNativeManager.registerUsdEventsCallback(usdNativeEventsCallback);
+    }
+
+    /**
+     * Validate the session.
+     */
+    private static boolean isValidSession(UsdSession session, int sessionId, Role role) {
+        if (session == null) {
+            Log.e(TAG, "isValidSession: session does not exist (id = " + sessionId + ")");
+            return false;
+        }
+        if (session.mSessionRole != role) {
+            Log.e(TAG, "isValidSession: Invalid session role (id = " + sessionId + ")");
+            return false;
+        }
+        if (session.mId != sessionId) {
+            Log.e(TAG, "isValidSession: Invalid session id (id = " + sessionId + ")");
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Implementation of USD callbacks. All callbacks are posted to Wi-Fi thread from
+     * SupplicantStaIfaceCallbackAidlImpl.
+     */
+    public class UsdNativeEventsCallback implements UsdNativeManager.UsdEventsCallback {
+        @Override
+        public void onUsdPublishStarted(int cmdId, int publishId) {
+            if (cmdId != DEFAULT_COMMAND_ID) {
+                Log.e(TAG, "onUsdPublishStarted: Invalid command id = " + cmdId);
+                return;
+            }
+            UsdSession usdSession = mUsdSessions.get(USD_TEMP_SESSION_ID);
+            if (!isValidSession(usdSession, USD_TEMP_SESSION_ID, Role.PUBLISHER)) return;
+            mUsdSessions.put(publishId, usdSession);
+            usdSession.setSessionId(publishId);
+            mUsdSessions.remove(USD_TEMP_SESSION_ID);
+            try {
+                usdSession.mIPublishSessionCallback.onPublishStarted(publishId);
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUsdPublishStarted " + e);
+            }
+            // Next: onUsdPublishReplied or onUsdPublishTerminated
+        }
+
+        @Override
+        public void onUsdSubscribeStarted(int cmdId, int subscribeId) {
+            if (cmdId != DEFAULT_COMMAND_ID) {
+                Log.e(TAG, "onUsdSubscribeStarted: Invalid command id = " + cmdId);
+                return;
+            }
+            UsdSession usdSession = mUsdSessions.get(USD_TEMP_SESSION_ID);
+            if (!isValidSession(usdSession, USD_TEMP_SESSION_ID, Role.SUBSCRIBER)) return;
+            mUsdSessions.put(subscribeId, usdSession);
+            usdSession.setSessionId(subscribeId);
+            mUsdSessions.remove(USD_TEMP_SESSION_ID);
+            try {
+                usdSession.mISubscribeSessionCallback.onSubscribeStarted(subscribeId);
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUsdSubscribeStarted " + e);
+            }
+            // Next: onUsdServiceDiscovered or onUsdSubscribeTerminated
+        }
+
+        @Override
+        public void onUsdPublishConfigFailed(int cmdId,
+                @SessionCallback.FailureCode int errorCode) {
+            if (cmdId != DEFAULT_COMMAND_ID) {
+                Log.e(TAG, "onUsdPublishConfigFailed: Invalid command id = " + cmdId);
+                return;
+            }
+            UsdSession usdSession = mUsdSessions.get(USD_TEMP_SESSION_ID);
+            if (isValidSession(usdSession, USD_TEMP_SESSION_ID, Role.PUBLISHER)) return;
+            usdSession.sessionCleanup();
+            try {
+                usdSession.mIPublishSessionCallback.onPublishFailed(errorCode);
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUsdPublishConfigFailed " + e);
+            }
+        }
+
+        @Override
+        public void onUsdSubscribeConfigFailed(int cmdId,
+                @SessionCallback.FailureCode int errorCode) {
+            if (cmdId != DEFAULT_COMMAND_ID) {
+                Log.e(TAG, "onUsdSubscribeConfigFailed: Invalid command id = " + cmdId);
+                return;
+            }
+            UsdSession usdSession = mUsdSessions.get(USD_TEMP_SESSION_ID);
+            if (!isValidSession(usdSession, USD_TEMP_SESSION_ID, Role.SUBSCRIBER)) return;
+            usdSession.sessionCleanup();
+            try {
+                usdSession.mISubscribeSessionCallback.onSubscribeFailed(errorCode);
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUsdSubscribeConfigFailed " + e);
+            }
+        }
+
+        @Override
+        public void onUsdPublishTerminated(int publishId, int reasonCode) {
+            if (!mUsdSessions.contains(publishId)) {
+                return;
+            }
+            UsdSession usdSession = mUsdSessions.get(publishId);
+            if (!isValidSession(usdSession, publishId, Role.PUBLISHER)) return;
+            try {
+                usdSession.mIPublishSessionCallback.onPublishSessionTerminated(reasonCode);
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUsdPublishTerminated " + e);
+            }
+            usdSession.sessionCleanup();
+        }
+
+        @Override
+        public void onUsdSubscribeTerminated(int subscribeId, int reasonCode) {
+            if (!mUsdSessions.contains(subscribeId)) {
+                return;
+            }
+            UsdSession usdSession = mUsdSessions.get(subscribeId);
+            if (!isValidSession(usdSession, subscribeId, Role.SUBSCRIBER)) return;
+            try {
+                usdSession.mISubscribeSessionCallback.onSubscribeSessionTerminated(reasonCode);
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUsdSubscribeTerminated " + e);
+            }
+            usdSession.sessionCleanup();
+        }
+
+        @Override
+        public void onUsdPublishReplied(UsdHalDiscoveryInfo info) {
+            // Check whether session matches.
+            if (!mUsdSessions.contains(info.ownId)) {
+                return;
+            }
+            // Check whether events are enabled for the publisher.
+            UsdSession usdSession = mUsdSessions.get(info.ownId);
+            if (isValidSession(usdSession, info.ownId, Role.PUBLISHER)) return;
+            if (!usdSession.mPublishConfig.isEventsEnabled()) return;
+            // Add the peer to the session if not already present.
+            UsdPeer peer = new UsdPeer(info.ownId, info.peerId, info.peerMacAddress);
+            usdSession.addPeerOnce(peer);
+            try {
+                // Pass unique peer hash to the application. When the application gives back the
+                // peer hash, it'll be used to retrieve the peer.
+                usdSession.mIPublishSessionCallback.onPublishReplied(usdSession.getPeerHash(peer),
+                        info.serviceSpecificInfo, info.serviceProtoType, info.isFsdEnabled);
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUsdPublishReplied " + e);
+            }
+        }
+
+        @Override
+        public void onUsdServiceDiscovered(UsdHalDiscoveryInfo info) {
+            // Check whether session matches.
+            if (!mUsdSessions.contains(info.ownId)) {
+                return;
+            }
+            // Add the peer to the session if not already present.
+            UsdPeer peer = new UsdPeer(info.ownId, info.peerId, info.peerMacAddress);
+            UsdSession usdSession = mUsdSessions.get(info.ownId);
+            if (isValidSession(usdSession, info.ownId, Role.SUBSCRIBER)) return;
+            usdSession.addPeerOnce(peer);
+            try {
+                // Pass unique peer hash to the application. When the application gives back the
+                // peer hash, it'll be used to retrieve the peer.
+                usdSession.mISubscribeSessionCallback.onSubscribeDiscovered(
+                        usdSession.getPeerHash(peer), info.serviceSpecificInfo,
+                        info.serviceProtoType, info.isFsdEnabled);
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUsdServiceDiscovered " + e);
+            }
+        }
+
+        @Override
+        public void onUsdMessageReceived(int ownId, int peerId, MacAddress peerMacAddress,
+                byte[] message) {
+            // Check whether session matches.
+            if (!mUsdSessions.contains(ownId)) {
+                return;
+            }
+            // Add the peer to the session if not already present.
+            UsdPeer peer = new UsdPeer(ownId, peerId, peerMacAddress);
+            UsdSession usdSession = mUsdSessions.get(ownId);
+            if (isValidSession(usdSession, ownId, mRequesterRole)) return;
+            usdSession.addPeerOnce(peer);
+            try {
+                // Pass unique peer hash to the application. When the application gives back the
+                // peer hash, it'll be used to retrieve the peer.
+                if (mRequesterRole == Role.SUBSCRIBER) {
+                    usdSession.mISubscribeSessionCallback.onMessageReceived(
+                            usdSession.getPeerHash(peer), message);
+                } else {
+                    usdSession.mIPublishSessionCallback.onMessageReceived(
+                            usdSession.getPeerHash(peer), message);
+                }
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUsdMessageReceived " + e);
+            }
+        }
+    }
+
+    private void broadcastPublisherStatus() {
+        int numListeners = mPublisherListenerList.beginBroadcast();
+        for (int i = 0; i < numListeners; i++) {
+            IBooleanListener listener = mPublisherListenerList.getBroadcastItem(i);
+            try {
+                listener.onResult(isPublisherAvailable());
+            } catch (RemoteException e) {
+                Log.e(TAG, "broadcastPublisherStatus: " + e);
+            }
+        }
+        mPublisherListenerList.finishBroadcast();
+    }
+
+    private void broadcastSubscriberStatus() {
+        int numListeners = mSubscriberListenerList.beginBroadcast();
+        for (int i = 0; i < numListeners; i++) {
+            IBooleanListener listener = mSubscriberListenerList.getBroadcastItem(i);
+            try {
+                listener.onResult(isSubscriberAvailable());
+            } catch (RemoteException e) {
+                Log.e(TAG, "broadcastSubscriberStatus: " + e);
+            }
+        }
+        mSubscriberListenerList.finishBroadcast();
+    }
+
+    /**
+     * Register for publisher status listener and notify the application on current status.
+     */
+    public void registerPublisherStatusListener(IBooleanListener listener) {
+        mPublisherListenerList.register(listener);
+        try {
+            listener.onResult(isPublisherAvailable());
+        } catch (RemoteException e) {
+            Log.e(TAG, "registerPublisherStatusListener: " + e);
+        }
+    }
+
+    /**
+     * Unregister previously registered publisher status listener.
+     */
+    public void unregisterPublisherStatusListener(IBooleanListener listener) {
+        mPublisherListenerList.unregister(listener);
+    }
+
+    /**
+     * Register for subscriber status listener and notify the application on current status.
+     */
+    public void registerSubscriberStatusListener(IBooleanListener listener) {
+        mSubscriberListenerList.register(listener);
+        try {
+            listener.onResult(isSubscriberAvailable());
+        } catch (RemoteException e) {
+            Log.e(TAG, "registerSubscriberStatusListener: " + e);
+        }
+    }
+
+    /**
+     * Unregister previously registered subscriber status listener.
+     */
+    public void unregisterSubscriberStatusListener(IBooleanListener listener) {
+        mSubscriberListenerList.unregister(listener);
+    }
+}
diff --git a/service/java/com/android/server/wifi/usd/UsdServiceImpl.java b/service/java/com/android/server/wifi/usd/UsdServiceImpl.java
index f1528c9032..4473adc15e 100644
--- a/service/java/com/android/server/wifi/usd/UsdServiceImpl.java
+++ b/service/java/com/android/server/wifi/usd/UsdServiceImpl.java
@@ -20,7 +20,6 @@ import android.annotation.NonNull;
 import android.content.Context;
 import android.net.wifi.IBooleanListener;
 import android.net.wifi.usd.Characteristics;
-import android.net.wifi.usd.IAvailabilityCallback;
 import android.net.wifi.usd.IPublishSessionCallback;
 import android.net.wifi.usd.ISubscribeSessionCallback;
 import android.net.wifi.usd.IUsdManager;
@@ -32,11 +31,10 @@ import android.net.wifi.usd.SubscribeSession;
 import android.net.wifi.usd.SubscribeSessionCallback;
 import android.net.wifi.usd.UsdManager;
 import android.os.Binder;
-import android.os.Bundle;
 import android.util.Log;
 
-import com.android.server.wifi.RunnerHandler;
 import com.android.server.wifi.WifiInjector;
+import com.android.server.wifi.WifiThreadRunner;
 import com.android.server.wifi.util.WifiPermissionsUtil;
 
 import java.util.Objects;
@@ -49,10 +47,11 @@ import java.util.function.Consumer;
 public class UsdServiceImpl extends IUsdManager.Stub {
     private static final String TAG = UsdServiceImpl.class.getName();
     private final Context mContext;
-    private RunnerHandler mHandler;
+    private WifiThreadRunner mWifiThreadRunner;
     private WifiInjector mWifiInjector;
-    WifiPermissionsUtil mWifiPermissionsUtil;
-
+    private WifiPermissionsUtil mWifiPermissionsUtil;
+    private UsdRequestManager mUsdRequestManager;
+    private UsdNativeManager mUsdNativeManager;
 
     /**
      * Constructor
@@ -67,6 +66,12 @@ public class UsdServiceImpl extends IUsdManager.Stub {
     public void start(@NonNull WifiInjector wifiInjector) {
         mWifiInjector = wifiInjector;
         mWifiPermissionsUtil = mWifiInjector.getWifiPermissionsUtil();
+        mUsdNativeManager = new UsdNativeManager(mWifiInjector.getWifiNative());
+        mUsdRequestManager = new UsdRequestManager(mUsdNativeManager,
+                mWifiInjector.getWifiThreadRunner(),
+                mWifiInjector.getActiveModeWarden(),
+                mWifiInjector.getClock(), mWifiInjector.getAlarmManager());
+        mWifiThreadRunner = mWifiInjector.getWifiThreadRunner();
         Log.i(TAG, "start");
     }
 
@@ -75,6 +80,8 @@ public class UsdServiceImpl extends IUsdManager.Stub {
      */
     public void startLate() {
         Log.i(TAG, "startLate");
+        // Get USD capabilities to update the cache in UsdRequestManager
+        mUsdRequestManager.getCharacteristics();
     }
 
     /**
@@ -86,147 +93,146 @@ public class UsdServiceImpl extends IUsdManager.Stub {
     }
 
     /**
-     * See {@link UsdManager#isSubscriberAvailable()}
+     * See {@link UsdManager#getCharacteristics()}
      */
     @Override
-    public boolean isSubscriberAvailable() {
+    public Characteristics getCharacteristics() {
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        Log.i(TAG, "Subscriber is not available");
-        return false;
+        return mUsdRequestManager.getCharacteristics();
     }
 
     /**
-     * See {@link UsdManager#isPublisherAvailable()}
+     * See {@link SubscribeSession#sendMessage(int, byte[], Executor, Consumer)}
      */
-    @Override
-    public boolean isPublisherAvailable() {
+    public void sendMessage(int sessionId, int peerId, @NonNull byte[] message,
+            @NonNull IBooleanListener listener) {
+        Objects.requireNonNull(message, "message must not be null");
+        Objects.requireNonNull(listener, "listener must not be null");
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        Log.i(TAG, "Publisher is not available");
-        return false;
+        Log.i(TAG, "sendMessage ( peerId = " + peerId + " , message length = " + message.length
+                + " )");
+        mWifiThreadRunner.post(() -> mUsdRequestManager.sendMessage(sessionId, peerId, message,
+                listener));
     }
 
     /**
-     * See
-     * {@link UsdManager#registerAvailabilityCallback(Executor, UsdManager.AvailabilityCallback)}
+     * See {@link SubscribeSession#cancel()}
      */
-    @Override
-    public void registerAvailabilityCallback(IAvailabilityCallback callback) {
+    public void cancelSubscribe(int sessionId) {
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
+        Log.i(TAG, "cancelSubscribe: ( sessionId = " + sessionId + " )");
+        mWifiThreadRunner.post(() -> mUsdRequestManager.cancelSubscribe(sessionId));
     }
 
     /**
-     * See {@link UsdManager#unregisterAvailabilityCallback(UsdManager.AvailabilityCallback)}
+     * See {@link PublishSession#cancel()}
      */
-    @Override
-    public void unregisterAvailabilityCallback(IAvailabilityCallback callback) {
+    public void cancelPublish(int sessionId) {
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
+        Log.i(TAG, "cancelPublish: ( sessionId = " + sessionId + " )");
+        mWifiThreadRunner.post(() -> mUsdRequestManager.cancelPublish(sessionId));
     }
 
     /**
-     * See {@link UsdManager#getCharacteristics()}
+     * See {@link PublishSession#updatePublish(byte[])}
      */
-    @Override
-    public Characteristics getCharacteristics() {
+    public void updatePublish(int sessionId, @NonNull byte[] ssi) {
+        Objects.requireNonNull(ssi, "Service specific info must not be null");
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-
-        Bundle bundle = new Bundle();
-        bundle.putInt(Characteristics.KEY_MAX_NUM_SUBSCRIBE_SESSIONS, 0);
-        bundle.putInt(Characteristics.KEY_MAX_NUM_SUBSCRIBE_SESSIONS, 0);
-        bundle.putInt(Characteristics.KEY_MAX_SERVICE_SPECIFIC_INFO_LENGTH, 0);
-        bundle.putInt(Characteristics.KEY_MAX_MATCH_FILTER_LENGTH, 0);
-        bundle.putInt(Characteristics.KEY_MAX_SERVICE_NAME_LENGTH, 0);
-        return new Characteristics(bundle);
+        Log.i(TAG, "updatePublish: ( sessionId = " + sessionId + " )");
+        mWifiThreadRunner.post(() -> mUsdRequestManager.updatePublish(sessionId, ssi));
     }
 
     /**
-     * See {@link SubscribeSession#sendMessage(int, byte[], Executor, Consumer)}
+     * See {@link UsdManager#publish(PublishConfig, Executor, PublishSessionCallback)}
      */
-    public void sendMessage(int peerId, @NonNull byte[] message,
-            @NonNull IBooleanListener listener) {
-        Objects.requireNonNull(message, "message must not be null");
-        Objects.requireNonNull(listener, "listener must not be null");
+    @Override
+    public void publish(PublishConfig publishConfig, IPublishSessionCallback callback) {
+        Objects.requireNonNull(publishConfig, "publishConfig must not be null");
+        Objects.requireNonNull(callback, "callback must not be null");
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        Log.i(TAG, "sendMessage ( peerId = " + peerId + " , message length = " + message.length
-                + " )");
+        // TODO: validate config
+        Log.i(TAG, "publish " + publishConfig);
+        mWifiThreadRunner.post(() -> mUsdRequestManager.publish(publishConfig, callback));
     }
 
     /**
-     * See {@link SubscribeSession#cancel()}
+     * See {@link UsdManager#subscribe(SubscribeConfig, Executor, SubscribeSessionCallback)}
      */
-    public void cancelSubscribe(int sessionId) {
+    @Override
+    public void subscribe(SubscribeConfig subscribeConfig, ISubscribeSessionCallback callback) {
+        Objects.requireNonNull(subscribeConfig, "subscribeConfig must not be null");
+        Objects.requireNonNull(callback, "callback must not be null");
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        Log.i(TAG, "cancelSubscribe: ( sessionId = " + sessionId + " )");
+        // TODO: validate config
+        Log.i(TAG, "subscribe " + subscribeConfig);
+        mWifiThreadRunner.post(() -> mUsdRequestManager.subscribe(subscribeConfig, callback));
     }
 
     /**
-     * See {@link PublishSession#cancel()}
+     * See {@link UsdManager#registerPublisherStatusListener(Executor, Consumer)}
      */
-    public void cancelPublish(int sessionId) {
+    public void registerPublisherStatusListener(@NonNull IBooleanListener listener) {
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        Log.i(TAG, "cancelPublish: ( sessionId = " + sessionId + " )");
+        mWifiThreadRunner.post(() -> mUsdRequestManager.registerPublisherStatusListener(listener));
     }
 
     /**
-     * See {@link PublishSession#updatePublish(byte[])}
+     * See {@link UsdManager#unregisterPublisherStatusListener(Consumer)}
      */
-    public void updatePublish(int sessionId, @NonNull byte[] ssi) {
-        Objects.requireNonNull(ssi, "Service specific info must not be null");
+    public void unregisterPublisherStatusListener(@NonNull IBooleanListener listener) {
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        Log.i(TAG, "updatePublish: ( sessionId = " + sessionId + " )");
+        mWifiThreadRunner.post(
+                () -> mUsdRequestManager.unregisterPublisherStatusListener(listener));
     }
 
     /**
-     * See {@link UsdManager#publish(PublishConfig, Executor, PublishSessionCallback)}
+     * See {@link UsdManager#registerSubscriberStatusListener(Executor, Consumer)}
      */
-    @Override
-    public void publish(PublishConfig publishConfig, IPublishSessionCallback callback) {
-        Objects.requireNonNull(publishConfig, "publishConfig must not be null");
-        Objects.requireNonNull(callback, "callback must not be null");
+    public void registerSubscriberStatusListener(@NonNull IBooleanListener listener) {
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        Log.i(TAG, "publish " + publishConfig);
+        mWifiThreadRunner.post(() -> mUsdRequestManager.registerSubscriberStatusListener(listener));
     }
 
     /**
-     * See {@link UsdManager#subscribe(SubscribeConfig, Executor, SubscribeSessionCallback)}
+     * See {@link UsdManager#unregisterSubscriberStatusListener(Consumer)}
      */
-    @Override
-    public void subscribe(SubscribeConfig subscribeConfig, ISubscribeSessionCallback callback) {
-        Objects.requireNonNull(subscribeConfig, "subscribeConfig must not be null");
-        Objects.requireNonNull(callback, "callback must not be null");
+    public void unregisterSubscriberStatusListener(@NonNull IBooleanListener listener) {
         int uid = getMockableCallingUid();
         if (!mWifiPermissionsUtil.checkManageWifiNetworkSelectionPermission(uid)) {
             throw new SecurityException("App not allowed to use USD (uid = " + uid + ")");
         }
-        Log.i(TAG, "subscribe " + subscribeConfig);
+        mWifiThreadRunner.post(
+                () -> mUsdRequestManager.unregisterSubscriberStatusListener(listener));
     }
 }
diff --git a/service/java/com/android/server/wifi/util/ApConfigUtil.java b/service/java/com/android/server/wifi/util/ApConfigUtil.java
index b2bb51007e..c60a9f4f35 100644
--- a/service/java/com/android/server/wifi/util/ApConfigUtil.java
+++ b/service/java/com/android/server/wifi/util/ApConfigUtil.java
@@ -904,6 +904,7 @@ public class ApConfigUtil {
      *                IEEE80211BE & single link MLO in bridged mode from the resource file.
      * @param config The current {@link SoftApConfiguration}.
      * @param isBridgedMode true if bridged mode is enabled, false otherwise.
+     * @param maximumSupportedMLD maximum number of supported MLD on SoftAp.
      * @param currentExistingMLD number of existing 11BE SoftApManager.
      * @param isMLDApSupportMLO true if the chip reports the support multiple links
      *                                    on a single MLD AP.
@@ -913,7 +914,7 @@ public class ApConfigUtil {
     public static boolean is11beAllowedForThisConfiguration(DeviceWiphyCapabilities capabilities,
             @NonNull WifiContext context,
             SoftApConfiguration config,
-            boolean isBridgedMode, int currentExistingMLD,
+            boolean isBridgedMode, int maximumSupportedMLD, int currentExistingMLD,
             boolean isMLDApSupportMLO) {
         if (!ApConfigUtil.isIeee80211beSupported(context)) {
             return false;
@@ -926,7 +927,7 @@ public class ApConfigUtil {
             }
         }
         if (Flags.mloSap()) {
-            if (!hasAvailableMLD(context, isBridgedMode,
+            if (!hasAvailableMLD(context, isBridgedMode, maximumSupportedMLD,
                     currentExistingMLD, isMLDApSupportMLO)) {
                 Log.i(TAG, "No available MLD, hence downgrading from 11be. currentExistingMLD = "
                         + currentExistingMLD + ", isMLDApSupportMLO = " + isMLDApSupportMLO);
@@ -946,10 +947,10 @@ public class ApConfigUtil {
     }
 
     private static boolean hasAvailableMLD(@NonNull WifiContext context,
-            boolean isBridgedMode, int currentExistingMLD,
+            boolean isBridgedMode, int maximumSupportedMLD, int currentExistingMLD,
             boolean isMLDApSupportMLO) {
         int numberOfMLDStillAllowed =
-                maximumNumberOfMLDForMLOAp(context) - currentExistingMLD;
+                maximumSupportedMLD - currentExistingMLD;
         if (numberOfMLDStillAllowed < 1) {
             return false;
         }
@@ -960,10 +961,21 @@ public class ApConfigUtil {
         return true;
     }
 
-    private static int maximumNumberOfMLDForMLOAp(@NonNull WifiContext context) {
+    /**
+     * Returns maximum number of supported MLD on SoftAp.
+     *
+     * @param context The caller context used to get the OEM configuration from resource file.
+     * @param chipSupportsMultipleMld whether Chip supports multiple mld on SoftAp.
+     */
+    public static int getMaximumSupportedMLD(@NonNull WifiContext context,
+            boolean chipSupportsMultipleMld) {
         int numberOfMLDSupported = context.getResourceCache()
                 .getInteger(R.integer.config_wifiSoftApMaxNumberMLDSupported);
-        if (numberOfMLDSupported != 0) {
+        if (numberOfMLDSupported > 0) {
+            if (Flags.multipleMldOnSapSupported() && !chipSupportsMultipleMld) {
+                // Chip doesn't support multiple mld on SoftAp
+                return 1;
+            }
             return numberOfMLDSupported;
         }
         if (context.getResourceCache().getBoolean(
diff --git a/service/java/com/android/server/wifi/util/FeatureBitsetUtils.java b/service/java/com/android/server/wifi/util/FeatureBitsetUtils.java
new file mode 100644
index 0000000000..73ad5c867a
--- /dev/null
+++ b/service/java/com/android/server/wifi/util/FeatureBitsetUtils.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi.util;
+
+import android.net.wifi.WifiManager;
+import android.util.SparseArray;
+
+import java.util.BitSet;
+
+/**
+ * Utilities for formatting the WifiManager.FEATURE_ BitSet as a String.
+ */
+public class FeatureBitsetUtils {
+    // All WifiManager.WIFI_FEATURE_ values should be added to the ALL_FEATURES map below
+    // to keep the feature logging up to date.
+    protected static final SparseArray ALL_FEATURES = new SparseArray() {
+        {
+            append(WifiManager.WIFI_FEATURE_INFRA, "WIFI_FEATURE_INFRA");
+            append(WifiManager.WIFI_FEATURE_PASSPOINT, "WIFI_FEATURE_PASSPOINT");
+            append(WifiManager.WIFI_FEATURE_P2P, "WIFI_FEATURE_P2P");
+            append(WifiManager.WIFI_FEATURE_MOBILE_HOTSPOT, "WIFI_FEATURE_MOBILE_HOTSPOT");
+            append(WifiManager.WIFI_FEATURE_SCANNER, "WIFI_FEATURE_SCANNER");
+            append(WifiManager.WIFI_FEATURE_AWARE, "WIFI_FEATURE_AWARE");
+            append(WifiManager.WIFI_FEATURE_D2D_RTT, "WIFI_FEATURE_D2D_RTT");
+            append(WifiManager.WIFI_FEATURE_D2AP_RTT, "WIFI_FEATURE_D2AP_RTT");
+            append(WifiManager.WIFI_FEATURE_PNO, "WIFI_FEATURE_PNO");
+            append(WifiManager.WIFI_FEATURE_TDLS, "WIFI_FEATURE_TDLS");
+            append(WifiManager.WIFI_FEATURE_TDLS_OFFCHANNEL, "WIFI_FEATURE_TDLS_OFFCHANNEL");
+            append(WifiManager.WIFI_FEATURE_AP_STA, "WIFI_FEATURE_AP_STA");
+            append(WifiManager.WIFI_FEATURE_LINK_LAYER_STATS, "WIFI_FEATURE_LINK_LAYER_STATS");
+            append(WifiManager.WIFI_FEATURE_LOGGER, "WIFI_FEATURE_LOGGER");
+            append(WifiManager.WIFI_FEATURE_RSSI_MONITOR, "WIFI_FEATURE_RSSI_MONITOR");
+            append(WifiManager.WIFI_FEATURE_MKEEP_ALIVE, "WIFI_FEATURE_MKEEP_ALIVE");
+            append(WifiManager.WIFI_FEATURE_CONFIG_NDO, "WIFI_FEATURE_CONFIG_NDO");
+            append(WifiManager.WIFI_FEATURE_CONTROL_ROAMING, "WIFI_FEATURE_CONTROL_ROAMING");
+            append(WifiManager.WIFI_FEATURE_IE_WHITELIST, "WIFI_FEATURE_IE_WHITELIST");
+            append(WifiManager.WIFI_FEATURE_SCAN_RAND, "WIFI_FEATURE_SCAN_RAND");
+            append(WifiManager.WIFI_FEATURE_TX_POWER_LIMIT, "WIFI_FEATURE_TX_POWER_LIMIT");
+            append(WifiManager.WIFI_FEATURE_WPA3_SAE, "WIFI_FEATURE_WPA3_SAE");
+            append(WifiManager.WIFI_FEATURE_WPA3_SUITE_B, "WIFI_FEATURE_WPA3_SUITE_B");
+            append(WifiManager.WIFI_FEATURE_OWE, "WIFI_FEATURE_OWE");
+            append(WifiManager.WIFI_FEATURE_LOW_LATENCY, "WIFI_FEATURE_LOW_LATENCY");
+            append(WifiManager.WIFI_FEATURE_DPP, "WIFI_FEATURE_DPP");
+            append(WifiManager.WIFI_FEATURE_P2P_RAND_MAC, "WIFI_FEATURE_P2P_RAND_MAC");
+            append(WifiManager.WIFI_FEATURE_CONNECTED_RAND_MAC, "WIFI_FEATURE_CONNECTED_RAND_MAC");
+            append(WifiManager.WIFI_FEATURE_AP_RAND_MAC, "WIFI_FEATURE_AP_RAND_MAC");
+            append(WifiManager.WIFI_FEATURE_MBO, "WIFI_FEATURE_MBO");
+            append(WifiManager.WIFI_FEATURE_OCE, "WIFI_FEATURE_OCE");
+            append(WifiManager.WIFI_FEATURE_WAPI, "WIFI_FEATURE_WAPI");
+            append(WifiManager.WIFI_FEATURE_FILS_SHA256, "WIFI_FEATURE_FILS_SHA256");
+            append(WifiManager.WIFI_FEATURE_FILS_SHA384, "WIFI_FEATURE_FILS_SHA384");
+            append(WifiManager.WIFI_FEATURE_SAE_PK, "WIFI_FEATURE_SAE_PK");
+            append(WifiManager.WIFI_FEATURE_STA_BRIDGED_AP, "WIFI_FEATURE_STA_BRIDGED_AP");
+            append(WifiManager.WIFI_FEATURE_BRIDGED_AP, "WIFI_FEATURE_BRIDGED_AP");
+            append(WifiManager.WIFI_FEATURE_INFRA_60G, "WIFI_FEATURE_INFRA_60G");
+            append(WifiManager.WIFI_FEATURE_ADDITIONAL_STA_LOCAL_ONLY,
+                    "WIFI_FEATURE_ADDITIONAL_STA_LOCAL_ONLY");
+            append(WifiManager.WIFI_FEATURE_ADDITIONAL_STA_MBB, "WIFI_FEATURE_ADDITIONAL_STA_MBB");
+            append(WifiManager.WIFI_FEATURE_ADDITIONAL_STA_RESTRICTED,
+                    "WIFI_FEATURE_ADDITIONAL_STA_RESTRICTED");
+            append(WifiManager.WIFI_FEATURE_DPP_ENROLLEE_RESPONDER,
+                    "WIFI_FEATURE_DPP_ENROLLEE_RESPONDER");
+            append(WifiManager.WIFI_FEATURE_PASSPOINT_TERMS_AND_CONDITIONS,
+                    "WIFI_FEATURE_PASSPOINT_TERMS_AND_CONDITIONS");
+            append(WifiManager.WIFI_FEATURE_SAE_H2E, "WIFI_FEATURE_SAE_H2E");
+            append(WifiManager.WIFI_FEATURE_WFD_R2, "WIFI_FEATURE_WFD_R2");
+            append(WifiManager.WIFI_FEATURE_DECORATED_IDENTITY, "WIFI_FEATURE_DECORATED_IDENTITY");
+            append(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE, "WIFI_FEATURE_TRUST_ON_FIRST_USE");
+            append(WifiManager.WIFI_FEATURE_ADDITIONAL_STA_MULTI_INTERNET,
+                    "WIFI_FEATURE_ADDITIONAL_STA_MULTI_INTERNET");
+            append(WifiManager.WIFI_FEATURE_DPP_AKM, "WIFI_FEATURE_DPP_AKM");
+            append(WifiManager.WIFI_FEATURE_SET_TLS_MINIMUM_VERSION,
+                    "WIFI_FEATURE_SET_TLS_MINIMUM_VERSION");
+            append(WifiManager.WIFI_FEATURE_TLS_V1_3, "WIFI_FEATURE_TLS_V1_3");
+            append(WifiManager.WIFI_FEATURE_DUAL_BAND_SIMULTANEOUS,
+                    "WIFI_FEATURE_DUAL_BAND_SIMULTANEOUS");
+            append(WifiManager.WIFI_FEATURE_T2LM_NEGOTIATION, "WIFI_FEATURE_T2LM_NEGOTIATION");
+            append(WifiManager.WIFI_FEATURE_WEP, "WIFI_FEATURE_WEP");
+            append(WifiManager.WIFI_FEATURE_WPA_PERSONAL, "WIFI_FEATURE_WPA_PERSONAL");
+            append(WifiManager.WIFI_FEATURE_AGGRESSIVE_ROAMING_MODE_SUPPORT,
+                    "WIFI_FEATURE_AGGRESSIVE_ROAMING_MODE_SUPPORT");
+            append(WifiManager.WIFI_FEATURE_D2D_WHEN_INFRA_STA_DISABLED,
+                    "WIFI_FEATURE_D2D_WHEN_INFRA_STA_DISABLED");
+            append(WifiManager.WIFI_FEATURE_SOFTAP_MLO, "WIFI_FEATURE_SOFTAP_MLO");
+            append(WifiManager.WIFI_FEATURE_MULTIPLE_MLD_ON_SAP,
+                    "WIFI_FEATURE_MULTIPLE_MLD_ON_SAP");
+        }
+    };
+
+    // Index of the newest available feature. This will be calculated automatically
+    // in the static block below.
+    protected static final int NEWEST_FEATURE_INDEX;
+    static {
+        int newestFeatureIndex = 0;
+        for (int i = 0; i < ALL_FEATURES.size(); i++) {
+            newestFeatureIndex = Math.max(ALL_FEATURES.keyAt(i), newestFeatureIndex);
+        }
+        NEWEST_FEATURE_INDEX = newestFeatureIndex;
+    }
+
+    /**
+     * Format a BitSet of WifiManager.WIFI_FEATURE_ features as a String.
+     */
+    public static String formatSupportedFeatures(BitSet supportedFeatures) {
+        if (supportedFeatures == null || supportedFeatures.isEmpty()) return "[]";
+        StringBuilder formatted = new StringBuilder("[");
+        for (int i = 0; i < ALL_FEATURES.size(); i++) {
+            int capabilityIndex = ALL_FEATURES.keyAt(i);
+            if (supportedFeatures.get(capabilityIndex)) {
+                String capabilityName = (String) ALL_FEATURES.valueAt(i);
+                formatted.append(capabilityName);
+                formatted.append(", ");
+            }
+        }
+
+        // Include a warning if an unrecognized feature is supported. It may have been added
+        // to WifiManager without updating this file.
+        if (supportedFeatures.length() > NEWEST_FEATURE_INDEX + 1) {
+            formatted.append("+ UNRECOGNIZED FEATURE(S)");
+        } else {
+            // Otherwise, trim the last 2 characters (", ") from the string
+            formatted.setLength(formatted.length() - 2);
+        }
+        formatted.append("]");
+        return formatted.toString();
+    }
+}
diff --git a/service/java/com/android/server/wifi/util/InformationElementUtil.java b/service/java/com/android/server/wifi/util/InformationElementUtil.java
index 37a07a5ca8..9ac19d6283 100644
--- a/service/java/com/android/server/wifi/util/InformationElementUtil.java
+++ b/service/java/com/android/server/wifi/util/InformationElementUtil.java
@@ -1895,6 +1895,7 @@ public class InformationElementUtil {
         private static final int RSN_CIPHER_CCMP = 0x04ac0f00;
         private static final int RSN_CIPHER_NO_GROUP_ADDRESSED = 0x07ac0f00;
         private static final int RSN_CIPHER_GCMP_256 = 0x09ac0f00;
+        private static final int RSN_CIPHER_CCMP_256 = 0x0aac0f00;
         private static final int RSN_CIPHER_GCMP_128 = 0x08ac0f00;
         private static final int RSN_CIPHER_BIP_GMAC_128 = 0x0bac0f00;
         private static final int RSN_CIPHER_BIP_GMAC_256 = 0x0cac0f00;
@@ -2129,6 +2130,8 @@ public class InformationElementUtil {
                     return ScanResult.CIPHER_TKIP;
                 case RSN_CIPHER_CCMP:
                     return ScanResult.CIPHER_CCMP;
+                case RSN_CIPHER_CCMP_256:
+                    return ScanResult.CIPHER_CCMP_256;
                 case RSN_CIPHER_GCMP_256:
                     return ScanResult.CIPHER_GCMP_256;
                 case RSN_CIPHER_NO_GROUP_ADDRESSED:
@@ -2489,7 +2492,11 @@ public class InformationElementUtil {
                 case ScanResult.CIPHER_NONE:
                     return "None";
                 case ScanResult.CIPHER_CCMP:
-                    return "CCMP";
+                    return "CCMP-128";
+                case ScanResult.CIPHER_CCMP_256:
+                    return "CCMP-256";
+                case ScanResult.CIPHER_GCMP_128:
+                    return "GCMP-128";
                 case ScanResult.CIPHER_GCMP_256:
                     return "GCMP-256";
                 case ScanResult.CIPHER_TKIP:
diff --git a/service/proto/src/metrics.proto b/service/proto/src/metrics.proto
index 4a53854d81..225cad81fb 100644
--- a/service/proto/src/metrics.proto
+++ b/service/proto/src/metrics.proto
@@ -2535,6 +2535,8 @@ message WifiLinkLayerUsageStats {
   repeated RadioStats radio_stats = 11;
 }
 
+// WifiUsabilityStatsEntry will only be uploaded when its timestamp is within the data capture
+// period
 message WifiUsabilityStatsEntry {
   // Status codes for link probe status
   enum LinkProbeStatus {
@@ -2815,6 +2817,14 @@ message WifiUsabilityStatsEntry {
   optional int32 capture_event_type_subcode = 64;
 
   optional int32 status_data_stall = 65;
+
+  // If the full data capture is being stored (field isFullCapture is true in the function call
+  // WifiManager.storeCapturedData), this field will represent the time offset between this sample
+  // and the first sample in the capture buffer. i.e. this field will have the value 0 for the
+  // first sample in the capture buffer.
+  // If isFullCapture is false, then this field will be the time offset between the capture start
+  // time and the timestamp of this sample.
+  optional int64 timestamp_offset_ms = 66;
 }
 
 message ContentionTimeStats {
@@ -3104,7 +3114,7 @@ message ScanResultWithSameFreq {
   optional int32 rssi = 2;
 
   // The center frequency of the primary 20 MHz frequency (in MHz) of the channel
-  optional int32 frequencyMhz = 3;
+  optional int32 frequency_mhz = 3;
 }
 
 message WifiUsabilityStats {
@@ -3169,6 +3179,13 @@ message WifiUsabilityStatsTraining {
   optional int64 capture_start_timestamp_secs = 2;
 
   optional TrainingData training_data = 3;
+
+  // If isFullCapture is true in the WifiManager.storeCaptureData call, this represents the time
+  // offset between the last sample in the capture buffer and the time the capture buffer was
+  // stored. If ring buffer is empty (no last sample), we set store_time_offset_ms to 0.
+  // If isFullCapture is false, this represents the time between 'capture period stop time' and the
+  // time the capture buffer was stored.
+  optional int64 store_time_offset_ms = 4;
 }
 
 message DeviceMobilityStatePnoScanStats {
diff --git a/service/tests/wifitests/Android.bp b/service/tests/wifitests/Android.bp
index 98974c26c7..f0f9102a76 100644
--- a/service/tests/wifitests/Android.bp
+++ b/service/tests/wifitests/Android.bp
@@ -503,6 +503,9 @@ android_test {
             "com.android.server.wifi.WakeupOnboarding",
             "com.android.server.wifi.WakeupOnboarding$*",
             "com.android.server.wifi.WakeupOnboarding.**",
+            "com.android.server.wifi.WepNetworkUsageController",
+            "com.android.server.wifi.WepNetworkUsageController$*",
+            "com.android.server.wifi.WepNetworkUsageController.**",
             "com.android.server.wifi.WifiApConfigStore",
             "com.android.server.wifi.WifiApConfigStore$*",
             "com.android.server.wifi.WifiApConfigStore.**",
@@ -1085,6 +1088,12 @@ android_test {
             "com.android.server.wifi.hotspot2.soap.command.SppCommand",
             "com.android.server.wifi.hotspot2.soap.command.SppCommand$*",
             "com.android.server.wifi.hotspot2.soap.command.SppCommand.**",
+            "com.android.server.wifi.mainline_supplicant.MainlineSupplicant",
+            "com.android.server.wifi.mainline_supplicant.MainlineSupplicant$*",
+            "com.android.server.wifi.mainline_supplicant.MainlineSupplicant.**",
+            "com.android.server.wifi.mainline_supplicant.ServiceManagerWrapper",
+            "com.android.server.wifi.mainline_supplicant.ServiceManagerWrapper$*",
+            "com.android.server.wifi.mainline_supplicant.ServiceManagerWrapper.**",
             "com.android.server.wifi.mockwifi.MockSupplicantManager",
             "com.android.server.wifi.mockwifi.MockSupplicantManager$*",
             "com.android.server.wifi.mockwifi.MockSupplicantManager.**",
@@ -1094,6 +1103,18 @@ android_test {
             "com.android.server.wifi.mockwifi.MockWifiServiceUtil",
             "com.android.server.wifi.mockwifi.MockWifiServiceUtil$*",
             "com.android.server.wifi.mockwifi.MockWifiServiceUtil.**",
+            "com.android.server.wifi.nl80211.GenericNetlinkMsg",
+            "com.android.server.wifi.nl80211.GenericNetlinkMsg$*",
+            "com.android.server.wifi.nl80211.GenericNetlinkMsg.**",
+            "com.android.server.wifi.nl80211.NetlinkConstants",
+            "com.android.server.wifi.nl80211.NetlinkConstants$*",
+            "com.android.server.wifi.nl80211.NetlinkConstants.**",
+            "com.android.server.wifi.nl80211.Nl80211Proxy",
+            "com.android.server.wifi.nl80211.Nl80211Proxy$*",
+            "com.android.server.wifi.nl80211.Nl80211Proxy.**",
+            "com.android.server.wifi.nl80211.StructGenNlMsgHdr",
+            "com.android.server.wifi.nl80211.StructGenNlMsgHdr$*",
+            "com.android.server.wifi.nl80211.StructGenNlMsgHdr.**",
             "com.android.server.wifi.p2p.ExternalApproverManager",
             "com.android.server.wifi.p2p.ExternalApproverManager$*",
             "com.android.server.wifi.p2p.ExternalApproverManager.**",
@@ -1181,6 +1202,18 @@ android_test {
             "com.android.server.wifi.scanner.WificondScannerImpl",
             "com.android.server.wifi.scanner.WificondScannerImpl$*",
             "com.android.server.wifi.scanner.WificondScannerImpl.**",
+            "com.android.server.wifi.usd.UsdNativeManager",
+            "com.android.server.wifi.usd.UsdNativeManager$*",
+            "com.android.server.wifi.usd.UsdNativeManager.**",
+            "com.android.server.wifi.usd.UsdRequestManager",
+            "com.android.server.wifi.usd.UsdRequestManager$*",
+            "com.android.server.wifi.usd.UsdRequestManager.**",
+            "com.android.server.wifi.usd.UsdService",
+            "com.android.server.wifi.usd.UsdService$*",
+            "com.android.server.wifi.usd.UsdService.**",
+            "com.android.server.wifi.usd.UsdServiceImpl",
+            "com.android.server.wifi.usd.UsdServiceImpl$*",
+            "com.android.server.wifi.usd.UsdServiceImpl.**",
             "com.android.server.wifi.util.ActionListenerWrapper",
             "com.android.server.wifi.util.ActionListenerWrapper$*",
             "com.android.server.wifi.util.ActionListenerWrapper.**",
@@ -1202,6 +1235,9 @@ android_test {
             "com.android.server.wifi.util.EncryptedData",
             "com.android.server.wifi.util.EncryptedData$*",
             "com.android.server.wifi.util.EncryptedData.**",
+            "com.android.server.wifi.util.FeatureBitsetUtils",
+            "com.android.server.wifi.util.FeatureBitsetUtils$*",
+            "com.android.server.wifi.util.FeatureBitsetUtils.**",
             "com.android.server.wifi.util.FileUtils",
             "com.android.server.wifi.util.FileUtils$*",
             "com.android.server.wifi.util.FileUtils.**",
diff --git a/service/tests/wifitests/src/com/android/server/wifi/ActiveModeWardenTest.java b/service/tests/wifitests/src/com/android/server/wifi/ActiveModeWardenTest.java
index b859e2a457..eab4ac329f 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/ActiveModeWardenTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/ActiveModeWardenTest.java
@@ -64,7 +64,6 @@ import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 import android.annotation.Nullable;
@@ -113,6 +112,7 @@ import com.android.server.wifi.ActiveModeWarden.ExternalClientModeManagerRequest
 import com.android.server.wifi.util.GeneralUtil.Mutable;
 import com.android.server.wifi.util.LastCallerInfoManager;
 import com.android.server.wifi.util.WifiPermissionsUtil;
+import com.android.wifi.flags.FeatureFlags;
 import com.android.wifi.resources.R;
 
 import org.junit.After;
@@ -203,6 +203,9 @@ public class ActiveModeWardenTest extends WifiBaseTest {
     @Mock WifiGlobals mWifiGlobals;
     @Mock WifiConnectivityManager mWifiConnectivityManager;
     @Mock WifiConfigManager mWifiConfigManager;
+    @Mock WakeupController mWakeupController;
+    @Mock DeviceConfigFacade mDeviceConfigFacade;
+    @Mock FeatureFlags mFeatureFlags;
 
     Listener<ConcreteClientModeManager> mClientListener;
     Listener<SoftApManager> mSoftApListener;
@@ -242,10 +245,13 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         when(mWifiInjector.getWifiHandlerLocalLog()).thenReturn(mLocalLog);
         when(mWifiInjector.getWifiConnectivityManager()).thenReturn(mWifiConnectivityManager);
         when(mWifiInjector.getWifiConfigManager()).thenReturn(mWifiConfigManager);
+        when(mWifiInjector.getWakeupController()).thenReturn(mWakeupController);
         when(mClientModeManager.getRole()).thenReturn(ROLE_CLIENT_PRIMARY);
         when(mClientModeManager.getInterfaceName()).thenReturn(WIFI_IFACE_NAME);
         when(mContext.getResourceCache()).thenReturn(mWifiResourceCache);
         when(mSoftApManager.getRole()).thenReturn(ROLE_SOFTAP_TETHERED);
+        when(mWifiInjector.getDeviceConfigFacade()).thenReturn(mDeviceConfigFacade);
+        when(mDeviceConfigFacade.getFeatureFlags()).thenReturn(mFeatureFlags);
 
         when(mWifiResourceCache.getString(R.string.wifi_localhotspot_configure_ssid_default))
                 .thenReturn("AndroidShare");
@@ -300,6 +306,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         mLooper.dispatchAll();
 
         verify(mWifiMetrics).noteWifiEnabledDuringBoot(false);
+        verify(mWifiMetrics, never()).reportWifiStateChanged(eq(true), anyBoolean(), eq(false));
         verify(mWifiGlobals).setD2dStaConcurrencySupported(false);
         verify(mWifiNative).registerStatusListener(mStatusListenerCaptor.capture());
         verify(mWifiNative).initialize();
@@ -610,6 +617,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         // take snapshot of ActiveModeManagers
         Collection<ActiveModeManager> activeModeManagers =
                 mActiveModeWarden.getActiveModeManagers();
+        ClientModeManager primaryCmm = mActiveModeWarden.getPrimaryClientModeManagerNullable();
 
         List<Integer> expectedStopInvocationCounts = activeModeManagers
                 .stream()
@@ -617,6 +625,9 @@ public class ActiveModeWardenTest extends WifiBaseTest {
                 .collect(Collectors.toList());
 
         r.run();
+        if (times > 0 && primaryCmm != null) {
+            assertEquals(WIFI_STATE_DISABLING, mActiveModeWarden.getWifiState());
+        }
 
         List<Integer> actualStopInvocationCounts = activeModeManagers
                 .stream()
@@ -1227,7 +1238,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         verify(mWifiNative).isStaStaConcurrencySupported();
         verify(mWifiNative).isP2pStaConcurrencySupported();
         verify(mWifiNative).isNanStaConcurrencySupported();
-        verifyZeroInteractions(mWifiNative);
+        verifyNoMoreInteractions(mWifiNative);
     }
 
     /**
@@ -1376,7 +1387,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
                 new SoftApModeConfiguration(WifiManager.IFACE_IP_MODE_TETHERED, null,
                 mSoftApCapability, TEST_COUNTRYCODE, null);
         SoftApConfiguration lohsConfigWC = mWifiApConfigStore.generateLocalOnlyHotspotConfig(
-                mContext, null, mSoftApCapability);
+                mContext, null, mSoftApCapability, false);
         SoftApModeConfiguration lohsConfig =
                 new SoftApModeConfiguration(WifiManager.IFACE_IP_MODE_LOCAL_ONLY, lohsConfigWC,
                 mSoftApCapability, TEST_COUNTRYCODE, null);
@@ -1519,6 +1530,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         mLooper.dispatchAll();
 
         verify(mWifiMetrics).noteWifiEnabledDuringBoot(true);
+        verify(mWifiMetrics).reportWifiStateChanged(eq(true), anyBoolean(), eq(false));
 
         assertInEnabledState();
 
@@ -1591,6 +1603,21 @@ public class ActiveModeWardenTest extends WifiBaseTest {
      */
     @Test
     public void testWifiStateUnaffectedByAirplaneMode() throws Exception {
+        when(mFeatureFlags.monitorIntentForAllUsers()).thenReturn(false);
+        verifyWifiStateUnaffectedByAirplaneMode(false);
+    }
+
+    /**
+     * Same as #testWifiStateUnaffectedByAirplaneMode but monitoring intent by RegisterForAllUsers.
+     */
+    @Test
+    public void testWifiStateUnaffectedByAirplaneModeWithRegisterForAllUsers() throws Exception {
+        when(mFeatureFlags.monitorIntentForAllUsers()).thenReturn(true);
+        verifyWifiStateUnaffectedByAirplaneMode(true);
+    }
+
+    private void verifyWifiStateUnaffectedByAirplaneMode(boolean isMonitorIntentForAllUsersEnabled)
+            throws Exception {
         assumeTrue(SdkLevel.isAtLeastT());
         when(mUserManager.hasUserRestrictionForUser(eq(UserManager.DISALLOW_CHANGE_WIFI_STATE),
                 any())).thenReturn(true);
@@ -1604,9 +1631,16 @@ public class ActiveModeWardenTest extends WifiBaseTest {
 
         ArgumentCaptor<BroadcastReceiver> bcastRxCaptor =
                 ArgumentCaptor.forClass(BroadcastReceiver.class);
-        verify(mContext).registerReceiver(
-                bcastRxCaptor.capture(),
-                argThat(filter -> filter.hasAction(Intent.ACTION_AIRPLANE_MODE_CHANGED)));
+        if (isMonitorIntentForAllUsersEnabled) {
+            verify(mContext).registerReceiverForAllUsers(
+                    bcastRxCaptor.capture(),
+                    argThat(filter -> filter.hasAction(Intent.ACTION_AIRPLANE_MODE_CHANGED)),
+                    eq(null), any(Handler.class));
+        } else {
+            verify(mContext).registerReceiver(
+                    bcastRxCaptor.capture(),
+                    argThat(filter -> filter.hasAction(Intent.ACTION_AIRPLANE_MODE_CHANGED)));
+        }
         BroadcastReceiver broadcastReceiver = bcastRxCaptor.getValue();
 
         Intent intent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
@@ -1653,7 +1687,14 @@ public class ActiveModeWardenTest extends WifiBaseTest {
                 anyInt(), eq("android_apm"), eq(false));
     }
 
-    /** Wi-Fi state is restored properly when SoftAp is enabled during airplane mode. */
+    /**
+     * Test sequence
+     * - APM on
+     * - STA stop
+     * - SoftAp on
+     * - APM off
+     * Wifi STA should get turned on at the end.
+     **/
     @Test
     public void testWifiStateRestoredWhenSoftApEnabledDuringApm() throws Exception {
         enableWifi();
@@ -1674,6 +1715,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
                         anyInt(),
                         eq("android_apm"),
                         eq(false));
+        mActiveModeWarden.setWifiStateForApiCalls(WIFI_STATE_DISABLED);
         mClientListener.onStopped(mClientModeManager);
         mLooper.dispatchAll();
 
@@ -1702,6 +1744,134 @@ public class ActiveModeWardenTest extends WifiBaseTest {
                         eq(true));
     }
 
+    /**
+     * Test sequence
+     * - APM on
+     * - SoftAp on
+     * - STA stop
+     * - APM off
+     * Wifi STA should get turned on at the end.
+     **/
+    @Test
+    public void testWifiStateRestoredWhenSoftApEnabledDuringApm2() throws Exception {
+        enableWifi();
+        assertInEnabledState();
+
+        // enabling airplane mode shuts down wifi
+        assertWifiShutDown(
+                () -> {
+                    when(mSettingsStore.isAirplaneModeOn()).thenReturn(true);
+                    mActiveModeWarden.airplaneModeToggled();
+                    mLooper.dispatchAll();
+                });
+        verify(mLastCallerInfoManager)
+                .put(
+                        eq(WifiManager.API_WIFI_ENABLED),
+                        anyInt(),
+                        anyInt(),
+                        anyInt(),
+                        eq("android_apm"),
+                        eq(false));
+
+        // start SoftAp
+        mActiveModeWarden.startSoftAp(
+                new SoftApModeConfiguration(
+                        WifiManager.IFACE_IP_MODE_LOCAL_ONLY,
+                        null,
+                        mSoftApCapability,
+                        TEST_COUNTRYCODE,
+                        null),
+                TEST_WORKSOURCE);
+        mLooper.dispatchAll();
+
+        mActiveModeWarden.setWifiStateForApiCalls(WIFI_STATE_DISABLED);
+        mClientListener.onStopped(mClientModeManager);
+        mLooper.dispatchAll();
+
+        // disabling airplane mode enables wifi
+        when(mSettingsStore.isAirplaneModeOn()).thenReturn(false);
+        mActiveModeWarden.airplaneModeToggled();
+        mLooper.dispatchAll();
+        verify(mLastCallerInfoManager)
+                .put(
+                        eq(WifiManager.API_WIFI_ENABLED),
+                        anyInt(),
+                        anyInt(),
+                        anyInt(),
+                        eq("android_apm"),
+                        eq(true));
+    }
+
+    /**
+     * Test sequence
+     * - APM on
+     * - SoftAp on
+     * - APM off
+     * - STA stop
+     * Wifi STA should get turned on at the end.
+     **/
+    @Test
+    public void testWifiStateRestoredWhenSoftApEnabledDuringApm3() throws Exception {
+        enableWifi();
+        assertInEnabledState();
+
+        // enabling airplane mode shuts down wifi
+        assertWifiShutDown(
+                () -> {
+                    when(mSettingsStore.isAirplaneModeOn()).thenReturn(true);
+                    mActiveModeWarden.airplaneModeToggled();
+                    mLooper.dispatchAll();
+                });
+        verify(mLastCallerInfoManager)
+                .put(
+                        eq(WifiManager.API_WIFI_ENABLED),
+                        anyInt(),
+                        anyInt(),
+                        anyInt(),
+                        eq("android_apm"),
+                        eq(false));
+        assertEquals(WIFI_STATE_DISABLING, mActiveModeWarden.getWifiState());
+
+        // start SoftAp
+        mActiveModeWarden.startSoftAp(
+                new SoftApModeConfiguration(
+                        WifiManager.IFACE_IP_MODE_LOCAL_ONLY,
+                        null,
+                        mSoftApCapability,
+                        TEST_COUNTRYCODE,
+                        null),
+                TEST_WORKSOURCE);
+        mLooper.dispatchAll();
+
+        // disabling airplane mode does not enables wifi yet, since wifi haven't stopped properly
+        when(mSettingsStore.isAirplaneModeOn()).thenReturn(false);
+        mActiveModeWarden.airplaneModeToggled();
+        mLooper.dispatchAll();
+        verify(mLastCallerInfoManager, never())
+                .put(
+                        eq(WifiManager.API_WIFI_ENABLED),
+                        anyInt(),
+                        anyInt(),
+                        anyInt(),
+                        eq("android_apm"),
+                        eq(true));
+        assertInEnabledState();
+
+        // Wifi STA stopped, it should now trigger APM handling to re-enable STA
+        mActiveModeWarden.setWifiStateForApiCalls(WIFI_STATE_DISABLED);
+        mClientListener.onStopped(mClientModeManager);
+        mLooper.dispatchAll();
+
+        verify(mLastCallerInfoManager)
+                .put(
+                        eq(WifiManager.API_WIFI_ENABLED),
+                        anyInt(),
+                        anyInt(),
+                        anyInt(),
+                        eq("android_apm"),
+                        eq(true));
+    }
+
     /**
      * Disabling location mode when in scan mode will disable wifi
      */
@@ -1740,6 +1910,37 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         assertInDisabledState();
     }
 
+    /**
+     * When in Client mode, make sure ECM triggers wifi shutdown.
+     */
+    @Test
+    public void testEcmReceiverFromClientModeWithRegisterForAllUsers()
+            throws Exception {
+        when(mFeatureFlags.monitorIntentForAllUsers()).thenReturn(true);
+        ArgumentCaptor<BroadcastReceiver> bcastRxCaptor =
+                ArgumentCaptor.forClass(BroadcastReceiver.class);
+        mActiveModeWarden = createActiveModeWarden();
+        mActiveModeWarden.start();
+        mLooper.dispatchAll();
+        verify(mContext).registerReceiverForAllUsers(
+                bcastRxCaptor.capture(),
+                argThat(filter ->
+                        filter.hasAction(TelephonyManager.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)),
+                        eq(null), any(Handler.class));
+        mEmergencyCallbackModeChangedBr = bcastRxCaptor.getValue();
+        when(mSettingsStore.isScanAlwaysAvailable()).thenReturn(false);
+        enableWifi();
+
+        // Test with WifiDisableInECBM turned on:
+        when(mFacade.getConfigWiFiDisableInECBM(mContext)).thenReturn(true);
+
+        assertWifiShutDown(() -> {
+            // test ecm changed
+            emergencyCallbackModeChanged(true);
+            mLooper.dispatchAll();
+        });
+    }
+
     /**
      * When in Client mode, make sure ECM triggers wifi shutdown.
      */
@@ -1969,6 +2170,45 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         });
     }
 
+    /**
+     * Updates about call state change also trigger entry of ECM mode.
+     */
+    @Test
+    public void testEnterEcmOnEmergencyCallStateChangeWithRegisterForAllUsers()
+            throws Exception {
+        when(mFeatureFlags.monitorIntentForAllUsers()).thenReturn(true);
+        ArgumentCaptor<BroadcastReceiver> bcastRxCaptor =
+                ArgumentCaptor.forClass(BroadcastReceiver.class);
+        mActiveModeWarden = createActiveModeWarden();
+        mActiveModeWarden.start();
+        mLooper.dispatchAll();
+        verify(mContext).registerReceiverForAllUsers(
+                bcastRxCaptor.capture(),
+                argThat(filter ->
+                        filter.hasAction(TelephonyManager.ACTION_EMERGENCY_CALL_STATE_CHANGED)),
+                        eq(null), any(Handler.class));
+        mEmergencyCallStateChangedBr = bcastRxCaptor.getValue();
+        assertInDisabledState();
+
+        enableWifi();
+        assertInEnabledState();
+
+        // Test with WifiDisableInECBM turned on:
+        when(mFacade.getConfigWiFiDisableInECBM(mContext)).thenReturn(true);
+
+        assertEnteredEcmMode(() -> {
+            // test call state changed
+            emergencyCallStateChanged(true);
+            mLooper.dispatchAll();
+            mClientListener.onStopped(mClientModeManager);
+            mLooper.dispatchAll();
+        });
+
+        emergencyCallStateChanged(false);
+        mLooper.dispatchAll();
+
+        assertInEnabledState();
+    }
 
     /**
      * Updates about call state change also trigger entry of ECM mode.
@@ -3184,7 +3424,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         // request for ssid2/bssid2
         if (additionaClientModeManagerRole == ROLE_CLIENT_LOCAL_ONLY) {
             mActiveModeWarden.requestLocalOnlyClientModeManager(
-                    externalRequestListener, TEST_WORKSOURCE, ssid, bssid, false);
+                    externalRequestListener, TEST_WORKSOURCE, ssid, bssid, false, false);
         } else if (additionaClientModeManagerRole == ROLE_CLIENT_SECONDARY_LONG_LIVED) {
             mActiveModeWarden.requestSecondaryLongLivedClientModeManager(
                     externalRequestListener, TEST_WORKSOURCE, ssid, bssid);
@@ -3299,7 +3539,8 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         // request for ssid2/bssid2
         if (role == ROLE_CLIENT_LOCAL_ONLY) {
             mActiveModeWarden.requestLocalOnlyClientModeManager(
-                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false);
+                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false,
+                    false);
         } else if (role == ROLE_CLIENT_SECONDARY_LONG_LIVED) {
             mActiveModeWarden.requestSecondaryLongLivedClientModeManager(
                     externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2);
@@ -3330,7 +3571,8 @@ public class ActiveModeWardenTest extends WifiBaseTest {
                 ExternalClientModeManagerRequestListener.class);
         if (role == ROLE_CLIENT_LOCAL_ONLY) {
             mActiveModeWarden.requestLocalOnlyClientModeManager(
-                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_1, TEST_BSSID_1, false);
+                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_1, TEST_BSSID_1, false,
+                    false);
         } else if (role == ROLE_CLIENT_SECONDARY_LONG_LIVED) {
             mActiveModeWarden.requestSecondaryLongLivedClientModeManager(
                     externalRequestListener, TEST_WORKSOURCE, TEST_SSID_1, TEST_BSSID_1);
@@ -3362,7 +3604,8 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         // request for one more CMM (returns the existing one).
         if (role == ROLE_CLIENT_LOCAL_ONLY) {
             mActiveModeWarden.requestLocalOnlyClientModeManager(
-                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_3, TEST_BSSID_3, false);
+                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_3, TEST_BSSID_3, false,
+                    false);
         } else if (role == ROLE_CLIENT_SECONDARY_LONG_LIVED) {
             mActiveModeWarden.requestSecondaryLongLivedClientModeManager(
                     externalRequestListener, TEST_WORKSOURCE, TEST_SSID_3, TEST_BSSID_3);
@@ -3405,7 +3648,8 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         // request for the same SSID/BSSID and expect the existing CMM to get returned twice.
         if (role == ROLE_CLIENT_LOCAL_ONLY) {
             mActiveModeWarden.requestLocalOnlyClientModeManager(
-                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false);
+                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false,
+                    false);
         } else if (role == ROLE_CLIENT_SECONDARY_LONG_LIVED) {
             mActiveModeWarden.requestSecondaryLongLivedClientModeManager(
                     externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2);
@@ -3452,7 +3696,8 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         // request for same ssid1/bssid1
         if (role == ROLE_CLIENT_LOCAL_ONLY) {
             mActiveModeWarden.requestLocalOnlyClientModeManager(
-                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_1, TEST_BSSID_1, false);
+                    externalRequestListener, TEST_WORKSOURCE, TEST_SSID_1, TEST_BSSID_1, false,
+                    false);
         } else if (role == ROLE_CLIENT_SECONDARY_LONG_LIVED) {
             mActiveModeWarden.requestSecondaryLongLivedClientModeManager(
                     externalRequestListener, TEST_WORKSOURCE, TEST_SSID_1, TEST_BSSID_1);
@@ -3518,7 +3763,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         ExternalClientModeManagerRequestListener externalRequestListener = mock(
                 ExternalClientModeManagerRequestListener.class);
         mActiveModeWarden.requestLocalOnlyClientModeManager(
-                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_1, TEST_BSSID_1, false);
+                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_1, TEST_BSSID_1, false, false);
         mLooper.dispatchAll();
 
         verify(externalRequestListener).onAnswer(null);
@@ -3893,7 +4138,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
                 ExternalClientModeManagerRequestListener.class);
         // request for ssid2/bssid2
         mActiveModeWarden.requestLocalOnlyClientModeManager(
-                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false);
+                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false, false);
         mLooper.dispatchAll();
         verify(mWifiInjector).makeClientModeManager(
                 any(), eq(TEST_WORKSOURCE), eq(ROLE_CLIENT_LOCAL_ONLY), anyBoolean());
@@ -3978,7 +4223,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
                 ExternalClientModeManagerRequestListener.class);
         // request for ssid2/bssid2
         mActiveModeWarden.requestLocalOnlyClientModeManager(
-                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false);
+                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false, false);
         mLooper.dispatchAll();
         verify(mWifiInjector).makeClientModeManager(
                 any(), eq(TEST_WORKSOURCE), eq(ROLE_CLIENT_LOCAL_ONLY), anyBoolean());
@@ -4116,7 +4361,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
 
         // mock requesting local only secondary
         mActiveModeWarden.requestLocalOnlyClientModeManager(
-                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false);
+                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false, false);
         mLooper.dispatchAll();
         // Verify the primary is given to the externalRequestListener
         verify(externalRequestListener).onAnswer(requestedClientModeManager.capture());
@@ -4124,20 +4369,18 @@ public class ActiveModeWardenTest extends WifiBaseTest {
                 any(), any(), eq(ROLE_CLIENT_LOCAL_ONLY), anyBoolean());
         assertEquals(ROLE_CLIENT_PRIMARY, requestedClientModeManager.getValue().getRole());
 
-        // Request for non local-only STA and verify the secondary STA is provided instead.
-        when(additionalClientModeManager.getRole()).thenReturn(ROLE_CLIENT_SECONDARY_LONG_LIVED);
-        mActiveModeWarden.requestSecondaryLongLivedClientModeManager(
-                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2);
+        // mock requesting local only secondary, but with preference for secondary STA.
+        // This should bypass the enterCarMode permission check and still give secondary STA.
+        mActiveModeWarden.requestLocalOnlyClientModeManager(
+                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false, true);
         mLooper.dispatchAll();
-        verify(mWifiInjector).makeClientModeManager(any(), any(),
-                eq(ROLE_CLIENT_SECONDARY_LONG_LIVED), anyBoolean());
-
         additionalClientListener.value.onStarted(additionalClientModeManager);
         mLooper.dispatchAll();
-        verify(externalRequestListener, times(2)).onAnswer(
-                requestedClientModeManager.capture());
-        assertEquals(ROLE_CLIENT_SECONDARY_LONG_LIVED,
-                requestedClientModeManager.getValue().getRole());
+        // Verify secondary is given to the externalRequestListener
+        verify(externalRequestListener, times(2)).onAnswer(requestedClientModeManager.capture());
+        verify(mWifiInjector).makeClientModeManager(
+                any(), any(), eq(ROLE_CLIENT_LOCAL_ONLY), anyBoolean());
+        assertEquals(ROLE_CLIENT_LOCAL_ONLY, requestedClientModeManager.getValue().getRole());
     }
 
     @Test
@@ -4174,10 +4417,10 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         when(additionalClientModeManager.getInterfaceName()).thenReturn(WIFI_IFACE_NAME_1);
         when(additionalClientModeManager.getRole()).thenReturn(ROLE_CLIENT_LOCAL_ONLY);
 
-        // Request will shell uid for local-only STA and verify the secondary is provided instead.
+        // Request with shell uid for local-only STA and verify the secondary is provided instead.
         WorkSource shellWs = new WorkSource(0, "shell");
         mActiveModeWarden.requestLocalOnlyClientModeManager(
-                externalRequestListener, shellWs, TEST_SSID_2, TEST_BSSID_2, false);
+                externalRequestListener, shellWs, TEST_SSID_2, TEST_BSSID_2, false, false);
         mLooper.dispatchAll();
         verify(mWifiInjector).makeClientModeManager(any(), any(),
                 eq(ROLE_CLIENT_LOCAL_ONLY), anyBoolean());
@@ -4559,7 +4802,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
 
         mActiveModeWarden.requestLocalOnlyClientModeManager(
                 mock(ExternalClientModeManagerRequestListener.class),
-                TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false);
+                TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, false, false);
         mLooper.dispatchAll();
 
         // No role set, should be ignored.
@@ -4890,7 +5133,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
 
         // mock requesting local only secondary
         mActiveModeWarden.requestLocalOnlyClientModeManager(
-                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, true);
+                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, true, false);
         mLooper.dispatchAll();
         // Verify the primary is given to the externalRequestListener
         verify(externalRequestListener).onAnswer(requestedClientModeManager.capture());
@@ -4948,7 +5191,7 @@ public class ActiveModeWardenTest extends WifiBaseTest {
 
         // mock requesting local only secondary
         mActiveModeWarden.requestLocalOnlyClientModeManager(
-                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, true);
+                externalRequestListener, TEST_WORKSOURCE, TEST_SSID_2, TEST_BSSID_2, true, false);
         mLooper.dispatchAll();
         WorkSource ws = new WorkSource(TEST_WORKSOURCE);
         ws.add(SETTINGS_WORKSOURCE);
@@ -5568,22 +5811,24 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         IWifiStateChangedListener remoteCallback2 = mock(IWifiStateChangedListener.class);
         when(remoteCallback2.asBinder()).thenReturn(mock(IBinder.class));
         mActiveModeWarden.addWifiStateChangedListener(remoteCallback1);
+        verify(remoteCallback1, times(1)).onWifiStateChanged();
         mActiveModeWarden.addWifiStateChangedListener(remoteCallback2);
+        verify(remoteCallback2, times(1)).onWifiStateChanged();
 
         // Change the state to DISABLED and verify the listeners were called.
         final int newState = WIFI_STATE_DISABLED;
         mActiveModeWarden.setWifiStateForApiCalls(newState);
 
-        verify(remoteCallback1, times(1)).onWifiStateChanged();
-        verify(remoteCallback2, times(1)).onWifiStateChanged();
+        verify(remoteCallback1, times(2)).onWifiStateChanged();
+        verify(remoteCallback2, times(2)).onWifiStateChanged();
 
         // Duplicate wifi state should not notify the callbacks again.
         mActiveModeWarden.setWifiStateForApiCalls(newState);
         mActiveModeWarden.setWifiStateForApiCalls(newState);
         mActiveModeWarden.setWifiStateForApiCalls(newState);
 
-        verify(remoteCallback1, times(1)).onWifiStateChanged();
-        verify(remoteCallback2, times(1)).onWifiStateChanged();
+        verify(remoteCallback1, times(2)).onWifiStateChanged();
+        verify(remoteCallback2, times(2)).onWifiStateChanged();
     }
 
     /**
@@ -5598,14 +5843,16 @@ public class ActiveModeWardenTest extends WifiBaseTest {
         IWifiStateChangedListener remoteCallback2 = mock(IWifiStateChangedListener.class);
         when(remoteCallback2.asBinder()).thenReturn(mock(IBinder.class));
         mActiveModeWarden.addWifiStateChangedListener(remoteCallback1);
+        verify(remoteCallback1, times(1)).onWifiStateChanged();
         mActiveModeWarden.addWifiStateChangedListener(remoteCallback2);
+        verify(remoteCallback2, times(1)).onWifiStateChanged();
         mActiveModeWarden.removeWifiStateChangedListener(remoteCallback1);
         mActiveModeWarden.removeWifiStateChangedListener(remoteCallback2);
 
         final int newState = WIFI_STATE_ENABLED;
         mActiveModeWarden.setWifiStateForApiCalls(newState);
 
-        verify(remoteCallback1, never()).onWifiStateChanged();
-        verify(remoteCallback2, never()).onWifiStateChanged();
+        verify(remoteCallback1, times(1)).onWifiStateChanged();
+        verify(remoteCallback2, times(1)).onWifiStateChanged();
     }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/ClientModeImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/ClientModeImplTest.java
index 8b705f0991..37ae9aa13e 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/ClientModeImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/ClientModeImplTest.java
@@ -64,7 +64,6 @@ import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyByte;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.anyLong;
-import static org.mockito.Mockito.anyObject;
 import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.argThat;
 import static org.mockito.Mockito.atLeast;
@@ -634,7 +633,7 @@ public class ClientModeImplTest extends WifiBaseTest {
         cap.wifiStandard = ScanResult.WIFI_STANDARD_11AC;
         when(mWifiNative.getConnectionCapabilities(WIFI_IFACE_NAME))
                 .thenReturn(mConnectionCapabilities);
-        when(mWifiNative.setStaMacAddress(eq(WIFI_IFACE_NAME), anyObject()))
+        when(mWifiNative.setStaMacAddress(eq(WIFI_IFACE_NAME), any()))
                 .then(new AnswerWithArguments() {
                     public boolean answer(String iface, MacAddress mac) {
                         when(mWifiNative.getMacAddress(iface)).thenReturn(mac.toString());
@@ -736,7 +735,7 @@ public class ClientModeImplTest extends WifiBaseTest {
 
         when(mWifiInjector.getActiveModeWarden()).thenReturn(mActiveModeWarden);
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mPrimaryClientModeManager);
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(
                         WifiManager.WIFI_FEATURE_WPA3_SAE, WifiManager.WIFI_FEATURE_OWE));
         when(mWifiInjector.getWifiGlobals()).thenReturn(mWifiGlobals);
@@ -1577,6 +1576,7 @@ public class ClientModeImplTest extends WifiBaseTest {
         mCmi.sendMessage(WifiMonitor.NETWORK_CONNECTION_EVENT,
                 new NetworkConnectionEventInfo(0, wifiSsid, TEST_BSSID_STR, false, null));
         mLooper.dispatchAll();
+        verify(mEapFailureNotifier).dismissEapFailureNotification(mConnectedNetwork.SSID);
         assertEquals("L3ProvisioningState", getCurrentState().getName());
     }
 
@@ -2343,10 +2343,16 @@ public class ClientModeImplTest extends WifiBaseTest {
         mCmi.onIdleModeChanged(true);
         verify(mWifiNative, never()).enableFirmwareRoaming(anyString(), anyInt());
 
-        // Enable both, then verify firmware roaming is disabled when idle mode is entered
+        // Enable both, then verify firmware roaming is not yet disabled when idle mode is entered
+        // because screen is still on
         when(mWifiGlobals.isDisableFirmwareRoamingInIdleMode()).thenReturn(true);
         when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true);
         mCmi.onIdleModeChanged(true);
+        verify(mWifiNative, never()).enableFirmwareRoaming(anyString(), anyInt());
+
+        // Verify firmware roaming is now disabled after screen turns off
+        setScreenState(false);
+        mLooper.dispatchAll();
         verify(mWifiNative).enableFirmwareRoaming(anyString(),
                 eq(WifiNative.DISABLE_FIRMWARE_ROAMING));
 
@@ -2368,6 +2374,8 @@ public class ClientModeImplTest extends WifiBaseTest {
         when(mWifiGlobals.isDisableFirmwareRoamingInIdleMode()).thenReturn(true);
         when(mWifiConnectivityHelper.isFirmwareRoamingSupported()).thenReturn(true);
         mCmi.onIdleModeChanged(true);
+        setScreenState(false);
+        mLooper.dispatchAll();
         verify(mWifiNative).enableFirmwareRoaming(anyString(),
                 eq(WifiNative.DISABLE_FIRMWARE_ROAMING));
 
@@ -5362,6 +5370,19 @@ public class ClientModeImplTest extends WifiBaseTest {
         // BSSID different, record this connection.
         verify(mWifiMetrics).incrementNumBssidDifferentSelectionBetweenFrameworkAndFirmware();
         verifyConnectionEventTimeoutDoesNotOccur();
+
+        // Disconnect now should not trigger handleConnectionAttemptEnded
+        DisconnectEventInfo disconnectEventInfo =
+                new DisconnectEventInfo(TEST_SSID, TEST_BSSID_STR, 0, false);
+        mCmi.sendMessage(WifiMonitor.NETWORK_DISCONNECTION_EVENT, disconnectEventInfo);
+        mLooper.dispatchAll();
+
+        verify(mWifiMetrics, never()).endConnectionEvent(
+                any(), eq(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION),
+                anyInt(), anyInt(), anyInt(), anyInt());
+        verify(mWifiConnectivityManager, never()).handleConnectionAttemptEnded(
+                any(), eq(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION),
+                anyInt(), any(), any());
     }
 
     /**
@@ -6443,7 +6464,7 @@ public class ClientModeImplTest extends WifiBaseTest {
     @Test
     public void testRandomizeMacAddressFailedRetryOnInterfaceUp() throws Exception {
         // mock setting the MAC address to fail
-        when(mWifiNative.setStaMacAddress(eq(WIFI_IFACE_NAME), anyObject())).thenReturn(false);
+        when(mWifiNative.setStaMacAddress(eq(WIFI_IFACE_NAME), any())).thenReturn(false);
         initializeCmi();
 
         ArgumentCaptor<MacAddress> macAddressCaptor = ArgumentCaptor.forClass(MacAddress.class);
@@ -6451,7 +6472,7 @@ public class ClientModeImplTest extends WifiBaseTest {
         MacAddress currentMac = macAddressCaptor.getValue();
 
         // mock setting the MAC address to succeed
-        when(mWifiNative.setStaMacAddress(eq(WIFI_IFACE_NAME), anyObject()))
+        when(mWifiNative.setStaMacAddress(eq(WIFI_IFACE_NAME), any()))
                 .then(new AnswerWithArguments() {
                     public boolean answer(String iface, MacAddress mac) {
                         when(mWifiNative.getMacAddress(iface)).thenReturn(mac.toString());
@@ -6566,6 +6587,26 @@ public class ClientModeImplTest extends WifiBaseTest {
         assumeTrue(mWifiInfo.isRestricted());
         assertEquals(OP_PACKAGE_NAME,
                 mWifiInfo.getRequestingPackageName());
+
+        verify(mWifiConfigManager, never()).userTemporarilyDisabledNetwork(
+                eq(mConnectedNetwork.SSID), anyInt());
+        // Setup new manual connection to another network
+        WifiConfiguration config = WifiConfigurationTestUtil.createPskSaeNetwork();
+        config.networkId = TEST_NETWORK_ID;
+        when(mWifiConfigManager.getConfiguredNetwork(TEST_NETWORK_ID)).thenReturn(config);
+
+        IActionListener connectActionListener = mock(IActionListener.class);
+        mCmi.connectNetwork(
+                new NetworkUpdateResult(TEST_NETWORK_ID),
+                new ActionListenerWrapper(connectActionListener),
+                Process.SYSTEM_UID, OP_PACKAGE_NAME, null);
+        mLooper.dispatchAll();
+        verify(connectActionListener).onSuccess();
+
+        // verify new manual connection will add the wifi network specifier network to temporary
+        // blocklist
+        verify(mWifiConfigManager).userTemporarilyDisabledNetwork(eq(mConnectedNetwork.SSID),
+                anyInt());
     }
 
     /**
@@ -6732,6 +6773,8 @@ public class ClientModeImplTest extends WifiBaseTest {
     public void testOnNetworkPermanentlyDisabled() throws Exception {
         connect();
 
+        // Verify connection failure related disable reason should not trigger disconnect because
+        // this could be from another STA
         WifiConfiguration disabledNetwork = new WifiConfiguration();
         disabledNetwork.networkId = FRAMEWORK_NETWORK_ID;
         for (WifiConfigManager.OnNetworkUpdateListener listener : mConfigUpdateListenerCaptor
@@ -6740,7 +6783,15 @@ public class ClientModeImplTest extends WifiBaseTest {
                 WifiConfiguration.NetworkSelectionStatus.DISABLED_BY_WRONG_PASSWORD);
         }
         mLooper.dispatchAll();
+        verify(mWifiNative, never()).disconnect(WIFI_IFACE_NAME);
 
+        // Verify that the network is disconnect if the profile is disabled by wifi API call
+        for (WifiConfigManager.OnNetworkUpdateListener listener : mConfigUpdateListenerCaptor
+                .getAllValues()) {
+            listener.onNetworkPermanentlyDisabled(disabledNetwork,
+                    WifiConfiguration.NetworkSelectionStatus.DISABLED_BY_WIFI_MANAGER);
+        }
+        mLooper.dispatchAll();
         verify(mWifiNative).disconnect(WIFI_IFACE_NAME);
     }
 
@@ -11075,8 +11126,8 @@ public class ClientModeImplTest extends WifiBaseTest {
     }
 
     /**
-     * Verify that during DHCP process, 1. If P2P is in waiting state, clientModeImpl doesn't send a
-     * message to block P2P discovery. 2. If P2P is not in waiting state, clientModeImpl sends a
+     * Verify that during DHCP process, 1. If P2P is in disabled state, clientModeImpl doesn't send
+     * a message to block P2P discovery. 2. If P2P is not in disabled state, clientModeImpl sends a
      * message to block P2P discovery. 3. On DHCP completion, clientModeImpl sends a message to
      * unblock P2P discovery.
      */
@@ -11111,7 +11162,7 @@ public class ClientModeImplTest extends WifiBaseTest {
         assertEquals("L3ProvisioningState", getCurrentState().getName());
 
         when(mWifiP2pConnection.isConnected()).thenReturn(true);
-        when(mWifiP2pConnection.isP2pInWaitingState()).thenReturn(true);
+        when(mWifiP2pConnection.isP2pInDisabledState()).thenReturn(true);
 
         mIpClientCallback.onPreDhcpAction();
         mLooper.dispatchAll();
@@ -11119,7 +11170,7 @@ public class ClientModeImplTest extends WifiBaseTest {
         verify(mIpClient).completedPreDhcpAction();
 
         when(mWifiP2pConnection.isConnected()).thenReturn(true);
-        when(mWifiP2pConnection.isP2pInWaitingState()).thenReturn(false);
+        when(mWifiP2pConnection.isP2pInDisabledState()).thenReturn(false);
 
         mIpClientCallback.onPreDhcpAction();
         mLooper.dispatchAll();
diff --git a/service/tests/wifitests/src/com/android/server/wifi/ConcreteClientModeManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/ConcreteClientModeManagerTest.java
index 0f6ebe895c..cfa03ff236 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/ConcreteClientModeManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/ConcreteClientModeManagerTest.java
@@ -500,6 +500,7 @@ public class ConcreteClientModeManagerTest extends WifiBaseTest {
                 .thenReturn(false);
         InOrder inOrder = inOrder(mContext);
         mClientModeManager.setRole(ROLE_CLIENT_SCAN_ONLY, TEST_WORKSOURCE);
+        verify(mActiveModeWarden).setWifiStateForApiCalls(WIFI_STATE_DISABLING);
         mLooper.dispatchAll();
 
         // Verify callback received for failed transition
diff --git a/service/tests/wifitests/src/com/android/server/wifi/ConfigurationMapTest.java b/service/tests/wifitests/src/com/android/server/wifi/ConfigurationMapTest.java
index b282fd1b14..5225d518db 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/ConfigurationMapTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/ConfigurationMapTest.java
@@ -111,7 +111,7 @@ public class ConfigurationMapTest extends WifiBaseTest {
         when(mWifiInjector.getActiveModeWarden()).thenReturn(mActiveModeWarden);
         when(mWifiInjector.getWifiGlobals()).thenReturn(mWifiGlobals);
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mPrimaryClientModeManager);
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(
                         WifiManager.WIFI_FEATURE_WPA3_SAE, WifiManager.WIFI_FEATURE_OWE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/DppManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/DppManagerTest.java
index 1870690353..bda9d6e362 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/DppManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/DppManagerTest.java
@@ -59,6 +59,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
+import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.anyString;
@@ -623,7 +624,7 @@ public class DppManagerTest extends WifiBaseTest {
         verify(mDppMetrics).updateDppEnrolleeSuccess();
         verify(mDppMetrics).updateDppOperationTime(anyInt());
         verifyNoMoreInteractions(mDppMetrics);
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR);
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR, 1);
         assertFalse(mDppManager.isSessionInProgress());
     }
 
@@ -674,7 +675,7 @@ public class DppManagerTest extends WifiBaseTest {
                 .EASY_CONNECT_EVENT_FAILURE_AUTHENTICATION));
         verify(mDppMetrics).updateDppOperationTime(anyInt());
         verifyNoMoreInteractions(mDppMetrics);
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR);
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR, 1);
         assertFalse(mDppManager.isSessionInProgress());
     }
 
@@ -724,7 +725,7 @@ public class DppManagerTest extends WifiBaseTest {
                 .EASY_CONNECT_EVENT_FAILURE_AUTHENTICATION));
         verify(mDppMetrics).updateDppOperationTime(anyInt());
         verifyNoMoreInteractions(mDppMetrics);
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR);
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR, 1);
         assertFalse(mDppManager.isSessionInProgress());
     }
 
@@ -807,15 +808,15 @@ public class DppManagerTest extends WifiBaseTest {
         // Check that WifiNative is called to stop the DPP session
         mDppManager.stopDppSession(10);
         verify(mWifiNative).stopDppInitiator(eq(TEST_INTERFACE_NAME));
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR);
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR, 1);
         assertFalse(mDppManager.isSessionInProgress());
     }
 
-    private void verifyCleanUpResources(int authRole) {
+    private void verifyCleanUpResources(int authRole, int expectedNumOfCancelTimeOuts) {
         if (authRole == DppManager.DPP_AUTH_ROLE_INITIATOR) {
             verify(mWifiNative).removeDppUri(eq(TEST_INTERFACE_NAME), anyInt());
         }
-        verify(mWakeupMessage).cancel();
+        verify(mWakeupMessage, times(expectedNumOfCancelTimeOuts)).cancel();
     }
 
     @Test
@@ -1061,7 +1062,7 @@ public class DppManagerTest extends WifiBaseTest {
             verify(mDppMetrics, times(1)).updateDppR2EnrolleeResponderIncompatibleConfiguration();
         }
         verifyNoMoreInteractions(mDppMetrics);
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR);
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR, 1);
         assertFalse(mDppManager.isSessionInProgress());
     }
 
@@ -1203,7 +1204,7 @@ public class DppManagerTest extends WifiBaseTest {
         verify(mDppMetrics).updateDppEnrolleeResponderSuccess();
         verify(mDppMetrics).updateDppOperationTime(anyInt());
         verifyNoMoreInteractions(mDppMetrics);
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_RESPONDER);
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_RESPONDER, 1);
         assertFalse(mDppManager.isSessionInProgress());
     }
 
@@ -1244,7 +1245,7 @@ public class DppManagerTest extends WifiBaseTest {
                 .EASY_CONNECT_EVENT_FAILURE_AUTHENTICATION));
         verify(mDppMetrics).updateDppOperationTime(anyInt());
         verifyNoMoreInteractions(mDppMetrics);
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_RESPONDER);
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_RESPONDER, 1);
         assertFalse(mDppManager.isSessionInProgress());
     }
 
@@ -1273,7 +1274,7 @@ public class DppManagerTest extends WifiBaseTest {
         verify(mWifiNative).stopDppResponder(eq(TEST_INTERFACE_NAME), eq(TEST_BOOTSTRAP_ID));
         verify(mDppMetrics).updateDppEnrolleeResponderRequests();
         verifyNoMoreInteractions(mDppMetrics);
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_RESPONDER);
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_RESPONDER, 1);
         assertFalse(mDppManager.isSessionInProgress());
     }
 
@@ -1315,7 +1316,8 @@ public class DppManagerTest extends WifiBaseTest {
         // and check that DPP session is cleaned up & session is not in progress anymore.
         dppEventCallback.onConnectionStatusResultSent(0);
         mLooper.dispatchAll();
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_RESPONDER);
+        verify(mWakeupMessage, times(2)).schedule(anyLong());
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_RESPONDER, 2);
         assertFalse(mDppManager.isSessionInProgress());
     }
 
@@ -1356,7 +1358,8 @@ public class DppManagerTest extends WifiBaseTest {
         // and check that DPP session is cleaned up & session is not in progress anymore.
         dppEventCallback.onConnectionStatusResultSent(0);
         mLooper.dispatchAll();
-        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR);
+        verify(mWakeupMessage, times(2)).schedule(anyLong());
+        verifyCleanUpResources(DppManager.DPP_AUTH_ROLE_INITIATOR, 2);
         assertFalse(mDppManager.isSessionInProgress());
     }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/EapFailureNotifierTest.java b/service/tests/wifitests/src/com/android/server/wifi/EapFailureNotifierTest.java
index e257c2d1bb..cb0706e4b0 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/EapFailureNotifierTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/EapFailureNotifierTest.java
@@ -20,6 +20,7 @@ import static com.android.server.wifi.EapFailureNotifier.CONFIG_EAP_FAILURE_DISA
 import static com.android.server.wifi.EapFailureNotifier.CONFIG_EAP_FAILURE_DISABLE_THRESHOLD;
 import static com.android.server.wifi.EapFailureNotifier.ERROR_MESSAGE_OVERLAY_PREFIX;
 import static com.android.server.wifi.EapFailureNotifier.ERROR_MESSAGE_OVERLAY_UNKNOWN_ERROR_CODE;
+import static com.android.server.wifi.EapFailureNotifier.NOTIFICATION_ID;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
@@ -274,6 +275,10 @@ public class EapFailureNotifierTest extends WifiBaseTest {
         verify(mFrameworkFacade, never()).makeNotificationBuilder(any(),
                 eq(WifiService.NOTIFICATION_NETWORK_ALERTS));
         assertEquals(mExpectedEapFailureConfig, failureConfig);
+
+        // verify cancel notification works
+        mEapFailureNotifier.dismissEapFailureNotification(SSID_1);
+        verify(mWifiNotificationManager).cancel(NOTIFICATION_ID);
     }
 
     /**
diff --git a/service/tests/wifitests/src/com/android/server/wifi/HalDeviceManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/HalDeviceManagerTest.java
index 40fd2597c6..3bb9e85c61 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/HalDeviceManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/HalDeviceManagerTest.java
@@ -39,10 +39,10 @@ import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.anyList;
 import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.clearInvocations;
 import static org.mockito.Mockito.doAnswer;
@@ -347,13 +347,13 @@ public class HalDeviceManagerTest extends WifiBaseTest {
 
     /**
      * Validates that when (for some reason) the cache is out-of-sync with the actual chip status
-     * then Wi-Fi is shut-down.
+     * (cache returns more ifaces than the chip reports) then Wi-Fi is shut-down.
      *
      * Uses TestChipV1 - but nothing specific to its configuration. The test validates internal
      * HDM behavior.
      */
     @Test
-    public void testCacheMismatchError() throws Exception {
+    public void testCacheHasMoreInterfacesThanChipMismatchError() throws Exception {
         TestChipV1 chipMock = new TestChipV1();
         chipMock.initialize();
         mInOrder = inOrder(mWifiMock, chipMock.chip, mManagerStatusListenerMock);
@@ -411,6 +411,38 @@ public class HalDeviceManagerTest extends WifiBaseTest {
                 nanDestroyedListener);
     }
 
+    /**
+     * Validates that when (for some reason) the cache is out-of-sync with the actual chip status
+     * (chip returns more ifaces than we have in the cache) then Wi-Fi is shut-down.
+     *
+     * Uses TestChipV1 - but nothing specific to its configuration. The test validates internal
+     * HDM behavior.
+     */
+    @Test
+    public void testChipHasMoreInterfacesThanCacheMismatchError() throws Exception {
+        TestChipV1 chipMock = new TestChipV1();
+        chipMock.initialize();
+        mInOrder = inOrder(mWifiMock, chipMock.chip, mManagerStatusListenerMock);
+        executeAndValidateStartupSequence();
+
+        InterfaceDestroyedListener nanDestroyedListener = mock(
+                InterfaceDestroyedListener.class);
+
+        // fiddle with the "chip" by adding a STA that we haven't added to our cache.
+        chipMock.interfaceNames.get(WifiChip.IFACE_TYPE_STA).add("wlan0");
+
+        // Now try to request a NAN.
+        WifiNanIface nanIface =
+                mDut.createNanIface(nanDestroyedListener, mHandler, TEST_WORKSOURCE_0);
+        collector.checkThat("NAN can't be created", nanIface, IsNull.nullValue());
+        mTestLooper.dispatchAll();
+
+        // verify that Wi-Fi is shut-down.
+        verify(mWifiMock).stop();
+        verify(mManagerStatusListenerMock, times(2)).onStatusChanged();
+    }
+
+
     /**
      * Validate that when no chip info is found an empty list is returned.
      */
diff --git a/service/tests/wifitests/src/com/android/server/wifi/HostapdHalAidlImpTest.java b/service/tests/wifitests/src/com/android/server/wifi/HostapdHalAidlImpTest.java
index 0055781812..59cf1f6f7e 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/HostapdHalAidlImpTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/HostapdHalAidlImpTest.java
@@ -23,9 +23,9 @@ import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyList;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doAnswer;
@@ -107,6 +107,7 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
     private static final String TEST_CLIENT_MAC = "11:22:33:44:55:66";
     private static final String TEST_AP_INSTANCE = "instance-wlan0";
     private static final String TEST_AP_INSTANCE_2 = "instance-wlan1";
+    private static final String TEST_MLD_MAC = "aa:bb:cc:dd:ee:ff";
     private static final int TEST_FREQ_24G = 2412;
     private static final int TEST_FREQ_5G = 5745;
     private static final int TEST_BANDWIDTH = ChannelBandwidth.BANDWIDTH_20;
@@ -167,7 +168,7 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
 
     private void mockApInfoChangedAndVerify(String ifaceName, int numOfApInfo,
             IHostapdCallback mockHostapdCallback,
-            WifiNative.SoftApHalCallback mockSoftApHalCallback) throws Exception {
+            WifiNative.SoftApHalCallback mockSoftApHalCallback, boolean isMLD) throws Exception {
         // Trigger on info changed.
         ApInfo apInfo = new ApInfo();
         apInfo.ifaceName = ifaceName;
@@ -176,12 +177,16 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
         apInfo.channelBandwidth = TEST_BANDWIDTH;
         apInfo.generation = TEST_GENERATION;
         apInfo.apIfaceInstanceMacAddress = MacAddress.fromString(TEST_CLIENT_MAC).toByteArray();
+        if (isMLD) {
+            apInfo.mldMacAddress = MacAddress.fromString(TEST_MLD_MAC).toByteArray();
+        }
         if (numOfApInfo == 1) {
             mockHostapdCallback.onApInstanceInfoChanged(apInfo);
             verify(mockSoftApHalCallback).onInfoChanged(eq(TEST_AP_INSTANCE), eq(TEST_FREQ_24G),
                     eq(mHostapdHal.mapHalChannelBandwidthToSoftApInfo(TEST_BANDWIDTH)),
                     eq(mHostapdHal.mapHalGenerationToWifiStandard(TEST_GENERATION)),
-                    eq(MacAddress.fromString(TEST_CLIENT_MAC)), anyList());
+                    eq(MacAddress.fromString(TEST_CLIENT_MAC)),
+                    isMLD ? eq(MacAddress.fromString(TEST_MLD_MAC)) : eq(null), anyList());
         } else if (numOfApInfo == 2) {
             apInfo.apIfaceInstance = TEST_AP_INSTANCE_2;
             apInfo.freqMhz = TEST_FREQ_5G;
@@ -189,7 +194,8 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
             verify(mockSoftApHalCallback).onInfoChanged(eq(TEST_AP_INSTANCE_2), eq(TEST_FREQ_5G),
                     eq(mHostapdHal.mapHalChannelBandwidthToSoftApInfo(TEST_BANDWIDTH)),
                     eq(mHostapdHal.mapHalGenerationToWifiStandard(TEST_GENERATION)),
-                    eq(MacAddress.fromString(TEST_CLIENT_MAC)), anyList());
+                    eq(MacAddress.fromString(TEST_CLIENT_MAC)),
+                    isMLD ? eq(MacAddress.fromString(TEST_MLD_MAC)) : eq(null), anyList());
         }
     }
 
@@ -208,7 +214,7 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
         mResources.setString(R.string.config_wifiSoftap2gChannelList, "");
         mResources.setString(R.string.config_wifiSoftap5gChannelList, "");
         mResources.setString(R.string.config_wifiSoftap6gChannelList, "");
-
+        when(Flags.mloSap()).thenReturn(true);
         when(mContext.getResources()).thenReturn(mResources);
         when(mContext.getResourceCache()).thenReturn(new WifiResourceCache(mContext));
         doNothing().when(mIHostapdMock).addAccessPoint(
@@ -923,9 +929,9 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
         verify(mSoftApHalCallback1, never()).onFailure();
 
         // Trigger on info changed and verify.
-        mockApInfoChangedAndVerify(IFACE_NAME, 1, mIHostapdCallback, mSoftApHalCallback);
+        mockApInfoChangedAndVerify(IFACE_NAME, 1, mIHostapdCallback, mSoftApHalCallback, false);
         verify(mSoftApHalCallback1, never()).onInfoChanged(anyString(), anyInt(), anyInt(),
-                anyInt(), any(), anyList());
+                anyInt(), any(), any(), anyList());
 
         // Trigger on client connected.
         ClientInfo clientInfo = new ClientInfo();
@@ -1223,7 +1229,7 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
      * Verifies the onFailure event in bridged mode.
      */
     @Test
-    public void testHostapdCallbackOnFailureEventInBridgedMode() throws Exception {
+    public void testHostapdCallbackOnFailureEventInMldBridgedMode() throws Exception {
         assumeTrue(SdkLevel.isAtLeastT());
         executeAndValidateInitializationSequence(true);
         Builder configurationBuilder = new SoftApConfiguration.Builder();
@@ -1241,8 +1247,8 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
         mHostapdHal.registerApCallback(IFACE_NAME, mSoftApHalCallback);
 
         // Trigger on info changed and verify.
-        mockApInfoChangedAndVerify(IFACE_NAME, 1, mIHostapdCallback, mSoftApHalCallback);
-        mockApInfoChangedAndVerify(IFACE_NAME, 2, mIHostapdCallback, mSoftApHalCallback);
+        mockApInfoChangedAndVerify(IFACE_NAME, 1, mIHostapdCallback, mSoftApHalCallback, true);
+        mockApInfoChangedAndVerify(IFACE_NAME, 2, mIHostapdCallback, mSoftApHalCallback, true);
 
         // Trigger on instance failure from first instance.
         mIHostapdCallback.onFailure(IFACE_NAME, TEST_AP_INSTANCE);
@@ -1275,7 +1281,7 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
         mHostapdHal.registerApCallback(IFACE_NAME, mSoftApHalCallback);
 
         // Trigger on info changed and verify.
-        mockApInfoChangedAndVerify(IFACE_NAME, 1, mIHostapdCallback, mSoftApHalCallback);
+        mockApInfoChangedAndVerify(IFACE_NAME, 1, mIHostapdCallback, mSoftApHalCallback, false);
 
         // Trigger on failure from first instance.
         mIHostapdCallback.onFailure(IFACE_NAME, TEST_AP_INSTANCE);
@@ -1370,7 +1376,6 @@ public class HostapdHalAidlImpTest extends WifiBaseTest {
             throws Exception {
         assumeTrue(Environment.isSdkAtLeastB());
         mResources.setBoolean(R.bool.config_wifi_softap_acs_supported, true);
-        when(Flags.mloSap()).thenReturn(true);
         when(Flags.apIsolate()).thenReturn(true);
         when(mIHostapdMock.getInterfaceVersion()).thenReturn(3);
         mHostapdHal = new HostapdHalSpy();
diff --git a/service/tests/wifitests/src/com/android/server/wifi/HostapdHalHidlImpTest.java b/service/tests/wifitests/src/com/android/server/wifi/HostapdHalHidlImpTest.java
index 0a2c12b7fa..8c7c31b232 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/HostapdHalHidlImpTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/HostapdHalHidlImpTest.java
@@ -21,10 +21,10 @@ import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.anyList;
@@ -1340,9 +1340,9 @@ public class HostapdHalHidlImpTest extends WifiBaseTest {
         verify(mSoftApHalCallback).onInfoChanged(eq(TEST_AP_INSTANCE), eq(testFreq),
                 eq(mHostapdHal.mapHalBandwidthToSoftApInfo(testBandwidth)),
                 eq(mHostapdHal.mapHalGenerationToWifiStandard(testGeneration)),
-                eq(MacAddress.fromString(TEST_CLIENT_MAC)), anyList());
+                eq(MacAddress.fromString(TEST_CLIENT_MAC)), eq(null),  anyList());
         verify(mSoftApHalCallback1, never()).onInfoChanged(anyString(), anyInt(), anyInt(),
-                anyInt(), any(), anyList());
+                anyInt(), any(), any(), anyList());
 
         // Trigger on client connected.
         mIHostapdCallback13.onConnectedClientsChanged(IFACE_NAME, TEST_AP_INSTANCE,
diff --git a/service/tests/wifitests/src/com/android/server/wifi/InterfaceConflictManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/InterfaceConflictManagerTest.java
index e707d5e2b3..3e303b4a10 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/InterfaceConflictManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/InterfaceConflictManagerTest.java
@@ -25,8 +25,8 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
diff --git a/service/tests/wifitests/src/com/android/server/wifi/LastMileLoggerTest.java b/service/tests/wifitests/src/com/android/server/wifi/LastMileLoggerTest.java
index e165dea0e2..ab181f693a 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/LastMileLoggerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/LastMileLoggerTest.java
@@ -18,12 +18,15 @@ package com.android.server.wifi;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.contains;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.contains;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
+import android.os.Handler;
+import android.os.test.TestLooper;
+
 import androidx.test.filters.SmallTest;
 
 import com.android.server.wifi.util.FileUtils;
@@ -52,6 +55,8 @@ public class LastMileLoggerTest extends WifiBaseTest {
 
     @Mock WifiInjector mWifiInjector;
     @Spy FakeWifiLog mLog;
+    private TestLooper mLooper;
+
 
     @Before
     public void setUp() throws Exception {
@@ -64,8 +69,10 @@ public class LastMileLoggerTest extends WifiBaseTest {
         mTraceEnableFile.deleteOnExit();
         mTraceReleaseFile.deleteOnExit();
         FileUtils.stringToFile(mTraceEnableFile.getPath(), "0");
+        mLooper = new TestLooper();
+        Handler backgroundHandler = new Handler(mLooper.getLooper());
         mLastMileLogger = new LastMileLogger(mWifiInjector, mTraceDataFile.getPath(),
-                mTraceEnableFile.getPath(),  mTraceReleaseFile.getPath());
+                mTraceEnableFile.getPath(),  mTraceReleaseFile.getPath(), backgroundHandler);
     }
 
     private static String readFileAsString(File file) throws IOException {
@@ -75,13 +82,15 @@ public class LastMileLoggerTest extends WifiBaseTest {
     @Test
     public void ctorDoesNotCrash() throws Exception {
         new LastMileLogger(mWifiInjector, mTraceDataFile.getPath(), mTraceEnableFile.getPath(),
-                mTraceReleaseFile.getPath());
-        verifyZeroInteractions(mLog);
+                mTraceReleaseFile.getPath(), new Handler(mLooper.getLooper()));
+        mLooper.dispatchAll();
+        verifyNoMoreInteractions(mLog);
     }
 
     @Test
     public void connectionEventStartedEnablesTracing() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         assertEquals("1", readFileAsString(mTraceEnableFile));
     }
 
@@ -89,6 +98,7 @@ public class LastMileLoggerTest extends WifiBaseTest {
     public void connectionEventStartedDoesNotCrashIfReleaseFileIsMissing() throws Exception {
         mTraceReleaseFile.delete();
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         verify(mLog).warn(contains("Failed to open free_buffer"));
     }
 
@@ -97,13 +107,14 @@ public class LastMileLoggerTest extends WifiBaseTest {
             throws Exception {
         mTraceReleaseFile.delete();
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         assertEquals("0", readFileAsString(mTraceEnableFile));
     }
 
     @Test
     public void connectionEventStartedDoesNotAttemptToReopenReleaseFile() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
-
+        mLooper.dispatchAll();
         // This is a rather round-about way of verifying that we don't attempt to re-open
         // the file. Namely: if we delete the |release| file, and CONNECTION_EVENT_STARTED
         // _did_ re-open the file, then we'd log an error message. Since the test is deleting the
@@ -114,43 +125,50 @@ public class LastMileLoggerTest extends WifiBaseTest {
         // FileInputStream.
         mTraceReleaseFile.delete();
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
-        verifyZeroInteractions(mLog);
+        mLooper.dispatchAll();
+        verifyNoMoreInteractions(mLog);
     }
 
     @Test
     public void connectionEventStartedDoesNotCrashIfEnableFileIsMissing() throws Exception {
         mTraceEnableFile.delete();
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
     }
 
     @Test
     public void connectionEventStartedDoesNotCrashOnRepeatedCalls() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
     }
 
     @Test
     public void connectionEventSucceededDisablesTracing() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_SUCCEEDED);
         assertEquals("0", readFileAsString(mTraceEnableFile));
+        mLooper.dispatchAll();
     }
 
     @Test
     public void connectionEventSucceededDoesNotCrashIfEnableFileIsMissing() throws Exception {
         mTraceEnableFile.delete();
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_SUCCEEDED);
+        mLooper.dispatchAll();
     }
 
     @Test
     public void connectionEventSucceededDoesNotCrashOnRepeatedCalls() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_SUCCEEDED);
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_SUCCEEDED);
+        mLooper.dispatchAll();
     }
 
     @Test
     public void connectionEventFailedDisablesTracingWhenPendingFails() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_FAILED);
+        mLooper.dispatchAll();
         assertEquals("0", readFileAsString(mTraceEnableFile));
     }
 
@@ -158,25 +176,30 @@ public class LastMileLoggerTest extends WifiBaseTest {
     public void connectionEventTimeoutDisablesTracing() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_TIMEOUT);
+        mLooper.dispatchAll();
         assertEquals("0", readFileAsString(mTraceEnableFile));
     }
 
     @Test
     public void multipleIfaces() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         assertEquals("1", readFileAsString(mTraceEnableFile));
 
         mLastMileLogger.reportConnectionEvent(WLAN1, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         assertEquals("1", readFileAsString(mTraceEnableFile));
 
         FileUtils.stringToFile(mTraceDataFile.getPath(), "rdev_connect");
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_TIMEOUT);
+        mLooper.dispatchAll();
         assertEquals("1", readFileAsString(mTraceEnableFile));
         String dumpString = getDumpString();
         assertTrue(dumpString.contains("--- Last failed"));
         assertTrue(dumpString.contains("rdev_connect"));
 
         mLastMileLogger.reportConnectionEvent(WLAN1, WifiDiagnostics.CONNECTION_EVENT_SUCCEEDED);
+        mLooper.dispatchAll();
         assertEquals("0", readFileAsString(mTraceEnableFile));
     }
 
@@ -184,25 +207,30 @@ public class LastMileLoggerTest extends WifiBaseTest {
     public void connectionEventFailedDoesNotCrashIfEnableFileIsMissing() throws Exception {
         mTraceEnableFile.delete();
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_FAILED);
+        mLooper.dispatchAll();
     }
 
     @Test
     public void connectionEventFailedDoesNotCrashIfDataFileIsMissing() throws Exception {
         mTraceDataFile.delete();
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_FAILED);
+        mLooper.dispatchAll();
     }
 
     @Test
     public void connectionEventFailedDoesNotCrashOnRepeatedCalls() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_FAILED);
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_FAILED);
+        mLooper.dispatchAll();
     }
 
     @Test
     public void dumpShowsFailureTrace() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         FileUtils.stringToFile(mTraceDataFile.getPath(), "rdev_connect");
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_FAILED);
+        mLooper.dispatchAll();
         assertTrue(getDumpString().contains("--- Last failed"));
         assertTrue(getDumpString().contains("rdev_connect"));
     }
@@ -211,6 +239,7 @@ public class LastMileLoggerTest extends WifiBaseTest {
     @Test
     public void dumpShowsPendingConnectionTrace() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         FileUtils.stringToFile(mTraceDataFile.getPath(), "rdev_connect");
         assertTrue(getDumpString().contains("No last mile log for \"Last failed"));
         assertTrue(getDumpString().contains("--- Latest"));
@@ -220,9 +249,11 @@ public class LastMileLoggerTest extends WifiBaseTest {
     @Test
     public void dumpShowsLastFailureTraceAndPendingConnectionTrace() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         FileUtils.stringToFile(mTraceDataFile.getPath(), "rdev_connect try #1");
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_FAILED);
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         FileUtils.stringToFile(mTraceDataFile.getPath(), "rdev_connect try #2");
 
         String dumpString = getDumpString();
@@ -233,11 +264,14 @@ public class LastMileLoggerTest extends WifiBaseTest {
     @Test
     public void dumpShowsLastFailureTraceAndCurrentConnectionTrace() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         FileUtils.stringToFile(mTraceDataFile.getPath(), "rdev_connect try #1");
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_FAILED);
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         FileUtils.stringToFile(mTraceDataFile.getPath(), "rdev_connect try #2");
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_SUCCEEDED);
+        mLooper.dispatchAll();
 
         String dumpString = getDumpString();
         assertTrue(dumpString.contains("rdev_connect try #1"));
@@ -247,8 +281,10 @@ public class LastMileLoggerTest extends WifiBaseTest {
     @Test
     public void dumpDoesNotClearLastFailureData() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         FileUtils.stringToFile(mTraceDataFile.getPath(), "rdev_connect");
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_FAILED);
+        mLooper.dispatchAll();
 
         getDumpString();
         String dumpString = getDumpString();
@@ -258,6 +294,7 @@ public class LastMileLoggerTest extends WifiBaseTest {
     @Test
     public void dumpDoesNotClearPendingConnectionTrace() throws Exception {
         mLastMileLogger.reportConnectionEvent(WLAN0, WifiDiagnostics.CONNECTION_EVENT_STARTED);
+        mLooper.dispatchAll();
         FileUtils.stringToFile(mTraceDataFile.getPath(), "rdev_connect");
 
         getDumpString();
diff --git a/service/tests/wifitests/src/com/android/server/wifi/MboOceControllerTest.java b/service/tests/wifitests/src/com/android/server/wifi/MboOceControllerTest.java
index 96c6cb1af7..dba2ba6ff7 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/MboOceControllerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/MboOceControllerTest.java
@@ -85,7 +85,7 @@ public class MboOceControllerTest extends WifiBaseTest {
         if (isOceEnabled) {
             featureSet.set(WifiManager.WIFI_FEATURE_OCE);
         }
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(featureSet);
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(featureSet);
 
         mMboOceController.enable();
 
diff --git a/service/tests/wifitests/src/com/android/server/wifi/MultiInternetWifiNetworkFactoryTest.java b/service/tests/wifitests/src/com/android/server/wifi/MultiInternetWifiNetworkFactoryTest.java
index fa1dc98e00..602ee8934e 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/MultiInternetWifiNetworkFactoryTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/MultiInternetWifiNetworkFactoryTest.java
@@ -20,7 +20,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.Mockito.anyInt;
-import static org.mockito.Mockito.anyObject;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.times;
@@ -243,7 +243,7 @@ public class MultiInternetWifiNetworkFactoryTest extends WifiBaseTest {
         mMultiInternetWifiNetworkFactory.needNetworkFor(mNetworkRequest2G);
         mMultiInternetWifiNetworkFactory.needNetworkFor(mNetworkRequest5G);
         verify(mMultiInternetManager, never()).setMultiInternetConnectionWorksource(anyInt(),
-                anyObject(), anyObject());
+                any(), any());
         verifyNoMoreInteractions(mWifiConnectivityManager);
     }
 
diff --git a/service/tests/wifitests/src/com/android/server/wifi/PmkCacheManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/PmkCacheManagerTest.java
index 15dfb795d9..f8a60af8f7 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/PmkCacheManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/PmkCacheManagerTest.java
@@ -18,8 +18,8 @@ package com.android.server.wifi;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
diff --git a/service/tests/wifitests/src/com/android/server/wifi/SarManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/SarManagerTest.java
index 867396da1d..fe582e3521 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/SarManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/SarManagerTest.java
@@ -133,7 +133,6 @@ public class SarManagerTest extends WifiBaseTest {
                         mWifiDeviceStateChangeManager);
 
         mSarMgr.handleBootCompleted();
-
         if (isSarEnabled) {
             /* Capture the PhoneStateListener */
             ArgumentCaptor<PhoneStateListener> phoneStateListenerCaptor =
@@ -573,4 +572,44 @@ public class SarManagerTest extends WifiBaseTest {
         assertTrue(mSarInfo.isWifiScanOnlyEnabled);
         assertFalse(mSarInfo.isWifiClientEnabled);
     }
+
+    /**
+     * Test that for devices that support setting/resetting Tx Power limits, device sets wifi enable
+     * first then finish the boot up. Verify device will change the power scenario.
+     */
+    @Test
+    public void testSarMgr_enabledTxPowerScenario_wifiOn_before_boot_completed_offHook() {
+        mResources.setBoolean(
+                R.bool.config_wifi_framework_enable_sar_tx_power_limit, true);
+        mResources.setBoolean(
+                R.bool.config_wifi_framework_enable_soft_ap_sar_tx_power_limit,
+                false);
+
+        mSarMgr = new SarManager(mContext, mTelephonyManager, mLooper.getLooper(), mWifiNative,
+                mWifiDeviceStateChangeManager);
+        /* Enable logs from SarManager */
+        enableDebugLogs();
+
+        InOrder inOrder = inOrder(mWifiNative);
+        // Enable wifi first, should be no change to the WifiNative
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any());
+
+        mSarMgr.handleBootCompleted();
+        ArgumentCaptor<PhoneStateListener> phoneStateListenerCaptor =
+                ArgumentCaptor.forClass(PhoneStateListener.class);
+        verify(mTelephonyManager).listen(phoneStateListenerCaptor.capture(),
+                eq(PhoneStateListener.LISTEN_CALL_STATE));
+        mPhoneStateListener = phoneStateListenerCaptor.getValue();
+        assertNotNull(mPhoneStateListener);
+        captureSarInfo(mWifiNative);
+        assertFalse(mSarInfo.isVoiceCall);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+
+        /* Set phone state to OFFHOOK */
+        mPhoneStateListener.onCallStateChanged(CALL_STATE_OFFHOOK, "");
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertTrue(mSarInfo.isVoiceCall);
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/SavedNetworkNominatorTest.java b/service/tests/wifitests/src/com/android/server/wifi/SavedNetworkNominatorTest.java
index 9cc7f5b438..f1b4f2de26 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/SavedNetworkNominatorTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/SavedNetworkNominatorTest.java
@@ -68,7 +68,7 @@ public class SavedNetworkNominatorTest extends WifiBaseTest {
         when(mWifiInjector.getActiveModeWarden()).thenReturn(mActiveModeWarden);
         when(mWifiInjector.getWifiGlobals()).thenReturn(mWifiGlobals);
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mPrimaryClientModeManager);
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(
                         WifiManager.WIFI_FEATURE_WPA3_SAE, WifiManager.WIFI_FEATURE_OWE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/ScanResultMatchInfoTest.java b/service/tests/wifitests/src/com/android/server/wifi/ScanResultMatchInfoTest.java
index 77c9351aa5..6b1fa2ea52 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/ScanResultMatchInfoTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/ScanResultMatchInfoTest.java
@@ -74,7 +74,7 @@ public class ScanResultMatchInfoTest extends WifiBaseTest {
         when(mWifiInjector.getWifiGlobals()).thenReturn(mWifiGlobals);
         when(mWifiInjector.getActiveModeWarden()).thenReturn(mActiveModeWarden);
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mClientModeManager);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WIFI_FEATURE_OWE, WIFI_FEATURE_WPA3_SAE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
         when(mWifiGlobals.isOweUpgradeEnabled()).thenReturn(true);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/SoftApManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/SoftApManagerTest.java
index aa11715c1c..86a4a48c1c 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/SoftApManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/SoftApManagerTest.java
@@ -171,6 +171,9 @@ public class SoftApManagerTest extends WifiBaseTest {
     private static final WifiClient TEST_DISCONNECTED_CLIENT =
             new WifiClient(TEST_CLIENT_MAC_ADDRESS, TEST_INTERFACE_NAME,
                     TEST_DISCONNECT_REASON);
+    private static final WifiClient TEST_DISCONNECTED_CLIENT_ON_FIRST_IFACE =
+            new WifiClient(TEST_CLIENT_MAC_ADDRESS, TEST_FIRST_INSTANCE_NAME,
+                    TEST_DISCONNECT_REASON);
     private static final WifiClient TEST_DISCONNECTED_CLIENT_2_ON_FIRST_IFACE =
             new WifiClient(TEST_CLIENT_MAC_ADDRESS_2, TEST_FIRST_INSTANCE_NAME,
                     TEST_DISCONNECT_REASON);
@@ -183,7 +186,7 @@ public class SoftApManagerTest extends WifiBaseTest {
     private static final int[] ALLOWED_6G_FREQS = {5945, 5965};
     private static final int[] ALLOWED_60G_FREQS = {58320, 60480}; // ch# 1, 2
     private static final WorkSource TEST_WORKSOURCE = new WorkSource();
-    private SoftApConfiguration mDefaultApConfig = createDefaultApConfig();
+    private SoftApConfiguration mPersistentApConfig;
 
     private static final TetheringManager.TetheringRequest TEST_TETHERING_REQUEST =
             new TetheringManager.TetheringRequest.Builder(TetheringManager.TETHERING_WIFI).build();
@@ -262,7 +265,7 @@ public class SoftApManagerTest extends WifiBaseTest {
     /** Old callback event from wificond */
     private void mockChannelSwitchEvent(int frequency, int bandwidth) {
         mSoftApHalCallbackCaptor.getValue().onInfoChanged(
-                TEST_INTERFACE_NAME, frequency, bandwidth, 0, null, Collections.emptyList());
+                TEST_INTERFACE_NAME, frequency, bandwidth, 0, null, null, Collections.emptyList());
     }
 
     /** New callback event from hostapd */
@@ -271,7 +274,8 @@ public class SoftApManagerTest extends WifiBaseTest {
                 ? apInfo.getVendorData() : Collections.emptyList();
         mSoftApHalCallbackCaptor.getValue().onInfoChanged(
                 apInfo.getApInstanceIdentifier(), apInfo.getFrequency(), apInfo.getBandwidth(),
-                apInfo.getWifiStandardInternal(), apInfo.getBssidInternal(), vendorData);
+                apInfo.getWifiStandardInternal(), apInfo.getBssidInternal(),
+                apInfo.getMldAddress(), vendorData);
         mTestSoftApInfoMap.put(apInfo.getApInstanceIdentifier(), apInfo);
         mTestWifiClientsMap.put(apInfo.getApInstanceIdentifier(), new ArrayList<WifiClient>());
     }
@@ -474,7 +478,8 @@ public class SoftApManagerTest extends WifiBaseTest {
         mTestSoftApCapability.setSupportedChannelList(
                 SoftApConfiguration.BAND_5GHZ, TEST_SUPPORTED_5G_CHANNELS);
         mTestSoftApCapability.setCountryCode(TEST_COUNTRY_CODE);
-        when(mWifiApConfigStore.getApConfiguration()).thenReturn(mDefaultApConfig);
+        mPersistentApConfig = createDefaultApConfig();
+        when(mWifiApConfigStore.getApConfiguration()).thenReturn(mPersistentApConfig);
         when(mWifiNative.isHalStarted()).thenReturn(true);
 
         mTestSoftApInfoMap.clear();
@@ -1038,7 +1043,7 @@ public class SoftApManagerTest extends WifiBaseTest {
                         SoftApManager.START_RESULT_FAILURE_ADD_AP_HOSTAPD);
 
         SoftApModeConfiguration softApModeConfig =
-                new SoftApModeConfiguration(WifiManager.IFACE_IP_MODE_TETHERED, mDefaultApConfig,
+                new SoftApModeConfiguration(WifiManager.IFACE_IP_MODE_TETHERED, mPersistentApConfig,
                 mTestSoftApCapability, TEST_COUNTRY_CODE, TEST_TETHERING_REQUEST);
 
         mSoftApManager = createSoftApManager(
@@ -1336,7 +1341,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance
         verify(mWifiNative).removeIfaceInstanceFromBridgedApIface(eq(TEST_INTERFACE_NAME),
-                eq(TEST_SECOND_INSTANCE_NAME));
+                eq(TEST_SECOND_INSTANCE_NAME), eq(false));
         mLooper.dispatchAll();
         mTestSoftApInfoMap.clear();
         mTestWifiClientsMap.clear();
@@ -1371,7 +1376,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance
         verify(mWifiNative).removeIfaceInstanceFromBridgedApIface(eq(TEST_INTERFACE_NAME),
-                eq(TEST_SECOND_INSTANCE_NAME));
+                eq(TEST_SECOND_INSTANCE_NAME), eq(false));
         mLooper.dispatchAll();
         mTestSoftApInfoMap.clear();
         mTestWifiClientsMap.clear();
@@ -1416,7 +1421,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance but SAP off since it can't get instances.
         verify(mWifiNative).removeIfaceInstanceFromBridgedApIface(eq(TEST_INTERFACE_NAME),
-                eq(TEST_SECOND_INSTANCE_NAME));
+                eq(TEST_SECOND_INSTANCE_NAME), eq(false));
         mLooper.dispatchAll();
         mTestSoftApInfoMap.clear();
         mTestWifiClientsMap.clear();
@@ -1445,7 +1450,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify AP remains up while waiting for the second instance.
         verify(mWifiNative).removeIfaceInstanceFromBridgedApIface(eq(TEST_INTERFACE_NAME),
-                eq(TEST_FIRST_INSTANCE_NAME));
+                eq(TEST_FIRST_INSTANCE_NAME), eq(false));
         verify(mWifiNative, never()).teardownInterface(TEST_INTERFACE_NAME);
     }
 
@@ -1670,6 +1675,8 @@ public class SoftApManagerTest extends WifiBaseTest {
         verify(mCallback).onClientsDisconnected(eq(mTestSoftApInfo),
                 eq(ImmutableList.of(TEST_DISCONNECTED_CLIENT)));
 
+        verify(mWifiMetrics).reportOnClientsDisconnected(
+                eq(TEST_DISCONNECT_REASON), eq(TEST_WORKSOURCE));
         verify(mWifiMetrics)
                 .addSoftApNumAssociatedStationsChangedEvent(0, 0,
                 apConfig.getTargetMode(), mTestSoftApInfo);
@@ -1691,11 +1698,25 @@ public class SoftApManagerTest extends WifiBaseTest {
         verify(mWifiMetrics).addSoftApNumAssociatedStationsChangedEvent(1, 1,
                 apConfig.getTargetMode(), mTestSoftApInfo);
 
+        mockClientConnectedEvent(TEST_CLIENT_MAC_ADDRESS_2, true, TEST_INTERFACE_NAME, true);
+        mLooper.dispatchAll();
+        order.verify(mCallback).onConnectedClientsOrInfoChanged(mTestSoftApInfoMap,
+                  mTestWifiClientsMap, false);
+        verify(mWifiMetrics).addSoftApNumAssociatedStationsChangedEvent(2, 2,
+                apConfig.getTargetMode(), mTestSoftApInfo);
+
         mSoftApManager.stop();
         mLooper.dispatchAll();
 
         verify(mWifiNative).forceClientDisconnect(TEST_INTERFACE_NAME, TEST_CLIENT_MAC_ADDRESS,
                 SAP_CLIENT_DISCONNECT_REASON_CODE_UNSPECIFIED);
+        verify(mWifiNative).forceClientDisconnect(TEST_INTERFACE_NAME, TEST_CLIENT_MAC_ADDRESS_2,
+                SAP_CLIENT_DISCONNECT_REASON_CODE_UNSPECIFIED);
+
+        verify(mWifiMetrics).writeSoftApStoppedEvent(eq(SoftApManager.STOP_EVENT_STOPPED),
+                any(), anyInt(), anyBoolean(), anyBoolean(), anyBoolean(), anyInt(), anyBoolean(),
+                anyInt(), anyInt(), anyInt(), eq(2), anyBoolean(),
+                anyInt(), anyInt(), any());
     }
 
     @Test
@@ -2157,7 +2178,7 @@ public class SoftApManagerTest extends WifiBaseTest {
 
         mockSoftApInfoUpdateAndVerifyAfterSapStarted(false, true);
 
-        SoftApConfiguration newConfig = new SoftApConfiguration.Builder(mDefaultApConfig)
+        SoftApConfiguration newConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setAutoShutdownEnabled(false)
                 .build();
         mSoftApManager.updateConfiguration(newConfig);
@@ -2171,7 +2192,7 @@ public class SoftApManagerTest extends WifiBaseTest {
     @Test
     public void schedulesTimeoutTimerOnTimeoutToggleChangeWhenNoClients() throws Exception {
         // start with timeout toggle disabled
-        mDefaultApConfig = new SoftApConfiguration.Builder(mDefaultApConfig)
+        mPersistentApConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setAutoShutdownEnabled(false)
                 .build();
         SoftApModeConfiguration apConfig =
@@ -2193,7 +2214,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         verify(mAlarmManager.getAlarmManager(), never()).setExact(anyInt(), anyLong(),
                 any(), any(), any());
 
-        SoftApConfiguration newConfig = new SoftApConfiguration.Builder(mDefaultApConfig)
+        SoftApConfiguration newConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setAutoShutdownEnabled(true)
                 .build();
         mSoftApManager.updateConfiguration(newConfig);
@@ -2208,7 +2229,7 @@ public class SoftApManagerTest extends WifiBaseTest {
     @Test
     public void doesNotScheduleTimeoutTimerOnStartWhenTimeoutIsDisabled() throws Exception {
         // start with timeout toggle disabled
-        mDefaultApConfig = new SoftApConfiguration.Builder(mDefaultApConfig)
+        mPersistentApConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setAutoShutdownEnabled(false)
                 .build();
         SoftApModeConfiguration apConfig =
@@ -2231,7 +2252,7 @@ public class SoftApManagerTest extends WifiBaseTest {
     public void doesNotScheduleTimeoutTimerWhenAllClientsDisconnectButTimeoutIsDisabled()
             throws Exception {
         // start with timeout toggle disabled
-        mDefaultApConfig = new SoftApConfiguration.Builder(mDefaultApConfig)
+        mPersistentApConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setAutoShutdownEnabled(false)
                 .build();
         SoftApModeConfiguration apConfig =
@@ -2374,7 +2395,7 @@ public class SoftApManagerTest extends WifiBaseTest {
     @Test
     public void setMacFailureWhenRandomMac() throws Exception {
         SoftApConfiguration.Builder randomizedBssidConfigBuilder =
-                new SoftApConfiguration.Builder(mDefaultApConfig)
+                new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setBssid(TEST_CLIENT_MAC_ADDRESS);
         if (SdkLevel.isAtLeastS()) {
             randomizedBssidConfigBuilder.setMacRandomizationSetting(
@@ -2486,7 +2507,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         int[] dual_bands = {SoftApConfiguration.BAND_2GHZ ,
                 SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ};
         Builder configBuilder = new SoftApConfiguration.Builder(
-                config != null ? config : mDefaultApConfig);
+                config != null ? config : mPersistentApConfig);
         configBuilder.setBands(dual_bands);
         return configBuilder.build();
     }
@@ -2519,12 +2540,12 @@ public class SoftApManagerTest extends WifiBaseTest {
         SoftApConfiguration randomizedBssidConfig = null;
         InOrder order = inOrder(mCallback, mWifiNative);
 
-        SoftApConfiguration config = softApConfig.getSoftApConfiguration();
+        final SoftApConfiguration config = softApConfig.getSoftApConfiguration();
         if (expectedConfig == null) {
             if (config == null) {
                 // Only generate randomized mac for default config since test case doesn't care it.
                 SoftApConfiguration.Builder randomizedBssidConfigBuilder =
-                        new SoftApConfiguration.Builder(mDefaultApConfig)
+                        new SoftApConfiguration.Builder(mPersistentApConfig)
                         .setBssid(TEST_INTERFACE_MAC_ADDRESS);
                 if (SdkLevel.isAtLeastS()) {
                     randomizedBssidConfigBuilder.setMacRandomizationSetting(
@@ -2690,7 +2711,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         // Verify the bands we get from getSoftApModeConfiguration() match the original bands
         // we passed in.
         assertThat(mSoftApManager.getSoftApModeConfiguration().getSoftApConfiguration().getBands())
-                .isEqualTo(config != null ? config.getBands() : mDefaultApConfig.getBands());
+                .isEqualTo(config != null ? config.getBands() : mPersistentApConfig.getBands());
         if (SdkLevel.isAtLeastS()) {
             SparseIntArray actualChannels =
                     mSoftApManager
@@ -2698,7 +2719,7 @@ public class SoftApManagerTest extends WifiBaseTest {
                             .getSoftApConfiguration()
                             .getChannels();
             SparseIntArray expectedChannels =
-                    config != null ? config.getChannels() : mDefaultApConfig.getChannels();
+                    config != null ? config.getChannels() : mPersistentApConfig.getChannels();
             assertThat(actualChannels.size()).isEqualTo(expectedChannels.size());
             for (int band : actualChannels.copyKeys()) {
                 assertThat(actualChannels.get(band)).isEqualTo(actualChannels.get(band));
@@ -2767,7 +2788,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         noClientControlCapability.setMaxSupportedClients(1);
         noClientControlCapability.setCountryCode(TEST_COUNTRY_CODE);
         SoftApConfiguration softApConfig = new SoftApConfiguration.Builder(
-                mDefaultApConfig).setMaxNumberOfClients(1).build();
+                mPersistentApConfig).setMaxNumberOfClients(1).build();
 
         SoftApModeConfiguration apConfig =
                 new SoftApModeConfiguration(WifiManager.IFACE_IP_MODE_TETHERED, softApConfig,
@@ -2796,7 +2817,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         SoftApCapability noSaeCapability = new SoftApCapability(testSoftApFeature);
         noSaeCapability.setCountryCode(TEST_COUNTRY_CODE);
         SoftApConfiguration softApConfig = new SoftApConfiguration.Builder(
-                mDefaultApConfig).setPassphrase(TEST_PASSWORD,
+                mPersistentApConfig).setPassphrase(TEST_PASSWORD,
                 SoftApConfiguration.SECURITY_TYPE_WPA3_SAE).build();
 
         SoftApModeConfiguration apConfig =
@@ -2869,7 +2890,7 @@ public class SoftApManagerTest extends WifiBaseTest {
                 SoftApConfiguration.BAND_2GHZ, TEST_SUPPORTED_24G_CHANNELS);
         testCapability.setSupportedChannelList(
                 SoftApConfiguration.BAND_5GHZ, TEST_SUPPORTED_5G_CHANNELS);
-        SoftApConfiguration softApConfig = new SoftApConfiguration.Builder(mDefaultApConfig)
+        SoftApConfiguration softApConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setChannels(dual_channels)
                 .build();
         SoftApModeConfiguration apConfig = new SoftApModeConfiguration(
@@ -3055,7 +3076,7 @@ public class SoftApManagerTest extends WifiBaseTest {
     public void testBssidUpdatedWhenSoftApInfoUpdate() throws Exception {
         MacAddress testBssid = MacAddress.fromString("aa:bb:cc:11:22:33");
         SoftApConfiguration.Builder customizedBssidConfigBuilder = new SoftApConfiguration
-                .Builder(mDefaultApConfig).setBssid(testBssid);
+                .Builder(mPersistentApConfig).setBssid(testBssid);
         if (SdkLevel.isAtLeastS()) {
             customizedBssidConfigBuilder.setMacRandomizationSetting(
                     SoftApConfiguration.RANDOMIZATION_NONE);
@@ -3257,7 +3278,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance
         verify(mWifiNative).removeIfaceInstanceFromBridgedApIface(eq(TEST_INTERFACE_NAME),
-                eq(TEST_SECOND_INSTANCE_NAME));
+                eq(TEST_SECOND_INSTANCE_NAME), eq(false));
         mLooper.dispatchAll();
         mTestSoftApInfoMap.clear();
         mTestWifiClientsMap.clear();
@@ -3351,7 +3372,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance
         verify(mWifiNative).removeIfaceInstanceFromBridgedApIface(eq(TEST_INTERFACE_NAME),
-                eq(TEST_SECOND_INSTANCE_NAME));
+                eq(TEST_SECOND_INSTANCE_NAME), eq(false));
 
         mTestSoftApInfoMap.clear();
         mTestWifiClientsMap.clear();
@@ -3372,6 +3393,8 @@ public class SoftApManagerTest extends WifiBaseTest {
         reset(mAlarmManager.getAlarmManager());
         mockClientConnectedEvent(TEST_CLIENT_MAC_ADDRESS, false, TEST_FIRST_INSTANCE_NAME, true);
         mLooper.dispatchAll();
+        verify(mCallback).onClientsDisconnected(eq(mTestSoftApInfoOnFirstInstance),
+                eq(ImmutableList.of(TEST_DISCONNECTED_CLIENT_ON_FIRST_IFACE)));
         // Verify timer is scheduled
         verify(mAlarmManager.getAlarmManager()).setExact(anyInt(), anyLong(),
                 eq(mSoftApManager.SOFT_AP_SEND_MESSAGE_TIMEOUT_TAG + TEST_INTERFACE_NAME),
@@ -3380,6 +3403,8 @@ public class SoftApManagerTest extends WifiBaseTest {
         verify(mAlarmManager.getAlarmManager(), never()).setExact(anyInt(), anyLong(),
                 eq(mSoftApManager.SOFT_AP_SEND_MESSAGE_TIMEOUT_TAG + TEST_FIRST_INSTANCE_NAME),
                 any(), any());
+        verify(mWifiMetrics, times(3)).reportOnClientsDisconnected(
+                eq(TEST_DISCONNECT_REASON), eq(TEST_WORKSOURCE));
     }
 
     @Test
@@ -3648,7 +3673,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance
         verify(mWifiNative, never()).removeIfaceInstanceFromBridgedApIface(any(),
-                any());
+                any(), anyBoolean());
     }
 
 
@@ -3682,7 +3707,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance
         verify(mWifiNative).removeIfaceInstanceFromBridgedApIface(eq(TEST_INTERFACE_NAME),
-                eq(TEST_SECOND_INSTANCE_NAME));
+                eq(TEST_SECOND_INSTANCE_NAME), eq(false));
         mLooper.dispatchAll();
         mTestSoftApInfoMap.clear();
         mTestWifiClientsMap.clear();
@@ -3721,7 +3746,8 @@ public class SoftApManagerTest extends WifiBaseTest {
         mCoexListenerCaptor.getValue().onCoexUnsafeChannelsChanged();
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance
-        verify(mWifiNative, never()).removeIfaceInstanceFromBridgedApIface(any(), any());
+        verify(mWifiNative, never()).removeIfaceInstanceFromBridgedApIface(any(), any(),
+                anyBoolean());
     }
 
     @Test
@@ -3745,7 +3771,8 @@ public class SoftApManagerTest extends WifiBaseTest {
         mCmiListenerCaptor.getValue().onL2Connected(mConcreteClientModeManager);
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance
-        verify(mWifiNative, never()).removeIfaceInstanceFromBridgedApIface(any(), any());
+        verify(mWifiNative, never()).removeIfaceInstanceFromBridgedApIface(any(), any(),
+                anyBoolean());
     }
 
     @Test
@@ -3774,7 +3801,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify the remove correct iface and instance
         verify(mWifiNative).removeIfaceInstanceFromBridgedApIface(eq(TEST_INTERFACE_NAME),
-                eq(TEST_SECOND_INSTANCE_NAME));
+                eq(TEST_SECOND_INSTANCE_NAME), eq(false));
         mLooper.dispatchAll();
         mTestSoftApInfoMap.clear();
         mTestWifiClientsMap.clear();
@@ -3814,7 +3841,7 @@ public class SoftApManagerTest extends WifiBaseTest {
         mLooper.dispatchAll();
         // Verify instance not removed
         verify(mWifiNative, never()).removeIfaceInstanceFromBridgedApIface(eq(TEST_INTERFACE_NAME),
-                eq(TEST_SECOND_INSTANCE_NAME));
+                eq(TEST_SECOND_INSTANCE_NAME), eq(false));
     }
 
     @Test
@@ -4376,23 +4403,45 @@ public class SoftApManagerTest extends WifiBaseTest {
         int[] dual_bands = {SoftApConfiguration.BAND_2GHZ,
                 SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ};
 
-        SoftApConfiguration config = new SoftApConfiguration.Builder().setSsid(TEST_SSID)
-                .setSsid(TEST_SSID)
+        mPersistentApConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setBand(SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ
                         | SoftApConfiguration.BAND_6GHZ)
                 .build();
-        SoftApConfiguration dualBandConfig = new SoftApConfiguration.Builder(config)
+        when(mWifiApConfigStore.getApConfiguration()).thenReturn(mPersistentApConfig);
+        SoftApConfiguration dualBandConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setBands(dual_bands)
                 .build();
 
         SoftApCapability no6GhzCapability = new SoftApCapability(mTestSoftApCapability);
         no6GhzCapability.setSupportedChannelList(WifiScanner.WIFI_BAND_6_GHZ, new int[0]);
         SoftApModeConfiguration apConfig = new SoftApModeConfiguration(
-                WifiManager.IFACE_IP_MODE_TETHERED, config,
+                WifiManager.IFACE_IP_MODE_TETHERED, null,
                 no6GhzCapability, TEST_COUNTRY_CODE, TEST_TETHERING_REQUEST);
         startSoftApAndVerifyEnabled(apConfig, dualBandConfig, false);
     }
 
+    @Test
+    public void testStartSoftApDoesNotAutoUpgradeTo2g5gDbsWhenConfigIsSpecified() throws Exception {
+        assumeTrue(SdkLevel.isAtLeastS());
+        when(mResourceCache.getBoolean(
+                R.bool.config_wifiSoftapUpgradeTetheredTo2g5gBridgedIfBandsAreSubset))
+                .thenReturn(true);
+        SoftApConfiguration config = new SoftApConfiguration.Builder(mPersistentApConfig)
+                .setBand(SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ
+                        | SoftApConfiguration.BAND_6GHZ)
+                .build();
+        SoftApConfiguration expected = new SoftApConfiguration.Builder(config)
+                .setBand(SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ)
+                .build();
+
+        SoftApCapability no6GhzCapability = new SoftApCapability(mTestSoftApCapability);
+        no6GhzCapability.setSupportedChannelList(WifiScanner.WIFI_BAND_6_GHZ, new int[0]);
+        SoftApModeConfiguration apConfig = new SoftApModeConfiguration(
+                WifiManager.IFACE_IP_MODE_TETHERED, config,
+                no6GhzCapability, TEST_COUNTRY_CODE, TEST_TETHERING_REQUEST);
+        startSoftApAndVerifyEnabled(apConfig, expected, false);
+    }
+
     @Test
     public void testStartSoftApDoesNotAutoUpgradeTo2g5gDbsWhen6GhzAvailable() throws Exception {
         assumeTrue(SdkLevel.isAtLeastS());
@@ -4401,21 +4450,20 @@ public class SoftApManagerTest extends WifiBaseTest {
         when(mResourceCache.getBoolean(
                 R.bool.config_wifiSoftapUpgradeTetheredTo2g5gBridgedIfBandsAreSubset))
                 .thenReturn(true);
-
-        SoftApConfiguration config = new SoftApConfiguration.Builder().setSsid(TEST_SSID)
-                .setSsid(TEST_SSID)
-                .setPassphrase("somepassword", SoftApConfiguration.SECURITY_TYPE_WPA3_SAE)
+        mPersistentApConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setBand(SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ
                         | SoftApConfiguration.BAND_6GHZ)
+                .setPassphrase("somepassword", SoftApConfiguration.SECURITY_TYPE_WPA3_SAE)
                 .build();
+        when(mWifiApConfigStore.getApConfiguration()).thenReturn(mPersistentApConfig);
 
         SoftApCapability with6GhzCapability = new SoftApCapability(mTestSoftApCapability);
         with6GhzCapability.setSupportedChannelList(
                 SoftApConfiguration.BAND_6GHZ, new int[]{5, 21});
         SoftApModeConfiguration apConfig = new SoftApModeConfiguration(
-                WifiManager.IFACE_IP_MODE_TETHERED, config,
+                WifiManager.IFACE_IP_MODE_TETHERED, null,
                 with6GhzCapability, TEST_COUNTRY_CODE, TEST_TETHERING_REQUEST);
-        startSoftApAndVerifyEnabled(apConfig, config, false);
+        startSoftApAndVerifyEnabled(apConfig, mPersistentApConfig, false);
     }
 
     @Test
@@ -4430,19 +4478,19 @@ public class SoftApManagerTest extends WifiBaseTest {
         int[] dual_bands = {SoftApConfiguration.BAND_2GHZ,
                 SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ};
 
-        SoftApConfiguration config = new SoftApConfiguration.Builder().setSsid(TEST_SSID)
-                .setSsid(TEST_SSID)
+        mPersistentApConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setBand(SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ
                         | SoftApConfiguration.BAND_6GHZ)
                 .build();
-        SoftApConfiguration dualBandConfig = new SoftApConfiguration.Builder(config)
+        when(mWifiApConfigStore.getApConfiguration()).thenReturn(mPersistentApConfig);
+        SoftApConfiguration dualBandConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setBands(dual_bands)
                 .build();
 
         when(mWifiNative.getChannelsForBand(WifiScanner.WIFI_BAND_6_GHZ))
                 .thenReturn(new int[0]);
         SoftApModeConfiguration apConfig = new SoftApModeConfiguration(
-                WifiManager.IFACE_IP_MODE_TETHERED, config,
+                WifiManager.IFACE_IP_MODE_TETHERED, null,
                 mTestSoftApCapability, "Not " + TEST_COUNTRY_CODE, TEST_TETHERING_REQUEST);
         startSoftApAndVerifyEnabled(apConfig, dualBandConfig, false);
     }
@@ -4460,18 +4508,18 @@ public class SoftApManagerTest extends WifiBaseTest {
                 R.bool.config_wifiSoftapUpgradeTetheredTo2g5gBridgedIfBandsAreSubset))
                 .thenReturn(true);
 
-        SoftApConfiguration config = new SoftApConfiguration.Builder().setSsid(TEST_SSID)
-                .setSsid(TEST_SSID)
-                .setPassphrase("somepassword", SoftApConfiguration.SECURITY_TYPE_WPA3_SAE)
+        mPersistentApConfig = new SoftApConfiguration.Builder(mPersistentApConfig)
                 .setBand(SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ
                         | SoftApConfiguration.BAND_6GHZ)
+                .setPassphrase("somepassword", SoftApConfiguration.SECURITY_TYPE_WPA3_SAE)
                 .build();
+        when(mWifiApConfigStore.getApConfiguration()).thenReturn(mPersistentApConfig);
 
         when(mWifiNative.getChannelsForBand(WifiScanner.WIFI_BAND_6_GHZ))
                 .thenReturn(ALLOWED_6G_FREQS);
         SoftApModeConfiguration apConfig = new SoftApModeConfiguration(
-                WifiManager.IFACE_IP_MODE_TETHERED, config,
+                WifiManager.IFACE_IP_MODE_TETHERED, null,
                 mTestSoftApCapability, "Not " + TEST_COUNTRY_CODE, TEST_TETHERING_REQUEST);
-        startSoftApAndVerifyEnabled(apConfig, config, false);
+        startSoftApAndVerifyEnabled(apConfig);
     }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalAidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalAidlImplTest.java
index 9df178a37e..28f4ea7939 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalAidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalAidlImplTest.java
@@ -39,12 +39,12 @@ import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.doReturn;
diff --git a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalHidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalHidlImplTest.java
index 0bde06bf5e..0c3ed7592b 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalHidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalHidlImplTest.java
@@ -34,13 +34,13 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.anyShort;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyShort;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.inOrder;
diff --git a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalTest.java b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalTest.java
index e93932b6f8..2749d94038 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaIfaceHalTest.java
@@ -27,7 +27,7 @@ import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Matchers.anyString;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
diff --git a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkCallbackAidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkCallbackAidlImplTest.java
index 2c52db920c..7571cf465b 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkCallbackAidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkCallbackAidlImplTest.java
@@ -17,7 +17,7 @@ package com.android.server.wifi;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.doThrow;
diff --git a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkHalAidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkHalAidlImplTest.java
index 4d399f1142..9f4953a53e 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkHalAidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkHalAidlImplTest.java
@@ -24,7 +24,7 @@ import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.anyString;
@@ -779,6 +779,23 @@ public class SupplicantStaNetworkHalAidlImplTest extends WifiBaseTest {
         WifiConfigurationTestUtil.assertConfigurationEqualForSupplicant(config, loadConfig);
     }
 
+    /**
+     * Tests the addition of multiple AKM when the 64 byte Hexadecimal PSK is used as preSharedKey.
+     */
+    @Test
+    public void testAddPskSaeAkmWhenRawPskIsUsedAsPreSharedKey() throws Exception {
+        WifiConfiguration config = WifiConfigurationTestUtil.createPskNetwork();
+        config.preSharedKey = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
+        config.getNetworkSelectionStatus().setCandidateSecurityParams(
+                config.getDefaultSecurityParams());
+        assertTrue(mSupplicantNetwork.saveWifiConfiguration(config));
+
+        assertEquals(KeyMgmtMask.WPA_PSK, (mSupplicantVariables.keyMgmtMask & KeyMgmtMask.WPA_PSK));
+        // Verify that the SAE AKM is not added.
+        assertEquals(0, (mSupplicantVariables.keyMgmtMask & KeyMgmtMask.SAE));
+        assertFalse(mSupplicantVariables.requirePmf);
+    }
+
     /**
      * Tests ciphers are merged when the device supports auto upgrade offload feature
      * and when candidate security type is PSK.
diff --git a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkHalHidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkHalHidlImplTest.java
index d1e32ebcd7..1e86d872bb 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkHalHidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/SupplicantStaNetworkHalHidlImplTest.java
@@ -26,7 +26,7 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyByte;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.doAnswer;
@@ -1004,6 +1004,27 @@ public class SupplicantStaNetworkHalHidlImplTest extends WifiBaseTest {
         WifiConfigurationTestUtil.assertConfigurationEqualForSupplicant(config, loadConfig);
     }
 
+    /**
+     * Tests the addition of multiple AKM when the 64 byte Hexadecimal PSK is used as preSharedKey.
+     */
+    @Test
+    public void testAddPskSaeAkmWhenRawPskIsUsedAsPreSharedKey() throws Exception {
+        createSupplicantStaNetwork(SupplicantStaNetworkVersion.V1_2);
+        WifiConfiguration config = WifiConfigurationTestUtil.createPskNetwork();
+        config.preSharedKey = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
+        config.getNetworkSelectionStatus().setCandidateSecurityParams(
+                config.getDefaultSecurityParams());
+        assertTrue(mSupplicantNetwork.saveWifiConfiguration(config));
+
+        assertEquals(ISupplicantStaNetwork.KeyMgmtMask.WPA_PSK,
+                (mSupplicantVariables.keyMgmtMask & ISupplicantStaNetwork.KeyMgmtMask.WPA_PSK));
+        // Verify that the SAE AKM is not added.
+        assertEquals(0,
+                (mSupplicantVariables.keyMgmtMask & android.hardware.wifi.supplicant.V1_2
+                        .ISupplicantStaNetwork.KeyMgmtMask.SAE));
+        assertFalse(mSupplicantVariables.requirePmf);
+    }
+
     /**
      * Tests the PMF is disabled when the device supports multiple AKMs.
      */
diff --git a/service/tests/wifitests/src/com/android/server/wifi/ThroughputPredictorTest.java b/service/tests/wifitests/src/com/android/server/wifi/ThroughputPredictorTest.java
index 556f7d5073..04ba2a541b 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/ThroughputPredictorTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/ThroughputPredictorTest.java
@@ -144,10 +144,10 @@ public class ThroughputPredictorTest extends WifiBaseTest {
     @Test
     public void verifyMaxChannelUtilizationBssLoad() {
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
-                ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_20MHZ, 0, 2412, 1,
+                ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_80MHZ, 0, 5210, 1,
                 MAX_CHANNEL_UTILIZATION, 0, false, null);
 
-        assertEquals(0, predictedThroughputMbps);
+        assertEquals(433, predictedThroughputMbps);
     }
 
     @Test
@@ -163,7 +163,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
     public void verifyHighRssiMinChannelUtilizationAc5g80Mhz2ss() {
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_80MHZ, 0, 5180, 2,
-                MIN_CHANNEL_UTILIZATION, 50, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
 
         assertEquals(866, predictedThroughputMbps);
     }
@@ -178,7 +178,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
                 .thenReturn(1);
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_80MHZ, 0, 5180, 2,
-                MIN_CHANNEL_UTILIZATION, 50, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
 
         assertEquals(433, predictedThroughputMbps);
     }
@@ -194,7 +194,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
 
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11BE, ScanResult.CHANNEL_WIDTH_320MHZ, 0, 6180, 4,
-                MIN_CHANNEL_UTILIZATION, INVALID, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
 
         assertEquals(11529, predictedThroughputMbps);
     }
@@ -213,7 +213,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
 
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11AX, ScanResult.CHANNEL_WIDTH_160MHZ, 0, 5180, 4,
-                MIN_CHANNEL_UTILIZATION, INVALID, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
 
         assertEquals(2401, predictedThroughputMbps);
     }
@@ -223,7 +223,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
     public void verifyMidRssiMinChannelUtilizationAc5g80Mhz2ss() {
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_80MHZ, -50, 5180, 2,
-                MIN_CHANNEL_UTILIZATION, INVALID, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
 
         assertEquals(866, predictedThroughputMbps);
     }
@@ -232,7 +232,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
     public void verifyLowRssiMinChannelUtilizationAc5g80Mhz2ss() {
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_80MHZ, -80, 5180, 2,
-                MIN_CHANNEL_UTILIZATION, INVALID, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
 
         assertEquals(41, predictedThroughputMbps);
     }
@@ -243,14 +243,14 @@ public class ThroughputPredictorTest extends WifiBaseTest {
                 ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_80MHZ, -80, 5180, 2,
                 INVALID, INVALID, false, null);
 
-        assertEquals(31, predictedThroughputMbps);
+        assertEquals(38, predictedThroughputMbps);
     }
 
     @Test
     public void verifyHighRssiMinChannelUtilizationAc2g20Mhz2ss() {
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_20MHZ, -20, 2437, 2,
-                MIN_CHANNEL_UTILIZATION, INVALID, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
 
         assertEquals(192, predictedThroughputMbps);
     }
@@ -259,7 +259,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
     public void verifyHighRssiMinChannelUtilizationAc2g20Mhz2ssBluetoothConnected() {
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_20MHZ, -20, 2437, 2,
-                MIN_CHANNEL_UTILIZATION, INVALID, true, null);
+                0, MIN_CHANNEL_UTILIZATION, true, null);
 
         assertEquals(144, predictedThroughputMbps);
     }
@@ -268,7 +268,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
     public void verifyHighRssiMinChannelUtilizationLegacy5g20Mhz() {
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_LEGACY, ScanResult.CHANNEL_WIDTH_20MHZ, -50, 5180,
-                1, MIN_CHANNEL_UTILIZATION, INVALID, false, null);
+                1, 0, MIN_CHANNEL_UTILIZATION, false, null);
 
         assertEquals(54, predictedThroughputMbps);
     }
@@ -286,7 +286,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
     public void verifyHighRssiMinChannelUtilizationHt2g20Mhz2ss() {
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11N, ScanResult.CHANNEL_WIDTH_20MHZ, -50, 2437, 2,
-                MIN_CHANNEL_UTILIZATION, INVALID, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
 
         assertEquals(144, predictedThroughputMbps);
     }
@@ -297,7 +297,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
         when(mDeviceCapabilities.getMaxNumberRxSpatialStreams()).thenReturn(0);
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11N, ScanResult.CHANNEL_WIDTH_20MHZ, -50, 2437, 2,
-                MIN_CHANNEL_UTILIZATION, INVALID, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
         // Expect to 1SS peak rate because maxNumberSpatialStream is overridden to 1.
         assertEquals(72, predictedThroughputMbps);
     }
@@ -335,7 +335,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
                 ScanResult.WIFI_STANDARD_11AC, ScanResult.CHANNEL_WIDTH_40MHZ, -66, 5180, 2,
                 INVALID, 80, false, null);
 
-        assertEquals(103, predictedThroughputMbps);
+        assertEquals(150, predictedThroughputMbps);
     }
 
     @Test
@@ -437,7 +437,7 @@ public class ThroughputPredictorTest extends WifiBaseTest {
         mConnectionCap.channelBandwidth = ScanResult.CHANNEL_WIDTH_160MHZ;
         mConnectionCap.maxNumberRxSpatialStreams = 4;
         //mConnectionCap.maxNumberTxSpatialStreams = 4;
-        assertEquals(2881, mThroughputPredictor.predictRxThroughput(mConnectionCap,
+        assertEquals(4520, mThroughputPredictor.predictRxThroughput(mConnectionCap,
                 -10, 5180, INVALID));
     }
 
@@ -451,12 +451,12 @@ public class ThroughputPredictorTest extends WifiBaseTest {
         when(mDeviceCapabilities.getMaxNumberRxSpatialStreams()).thenReturn(4);
         int predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11BE, ScanResult.CHANNEL_WIDTH_160MHZ, 0, 5240, 4,
-                MIN_CHANNEL_UTILIZATION, 50, false, null);
+                0, MIN_CHANNEL_UTILIZATION, false, null);
         assertEquals(5764, predictedThroughputMbps);
 
         predictedThroughputMbps = mThroughputPredictor.predictThroughput(mDeviceCapabilities,
                 ScanResult.WIFI_STANDARD_11BE, ScanResult.CHANNEL_WIDTH_160MHZ, 0, 5240, 4,
-                MIN_CHANNEL_UTILIZATION, 50, false, new byte[]{(byte) 0x3, (byte) 0x0});
+                0, MIN_CHANNEL_UTILIZATION, false, new byte[]{(byte) 0x3, (byte) 0x0});
         assertEquals(4388, predictedThroughputMbps);
     }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WakeupControllerTest.java b/service/tests/wifitests/src/com/android/server/wifi/WakeupControllerTest.java
index 8674ed38ec..a0cd6c653f 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WakeupControllerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WakeupControllerTest.java
@@ -128,7 +128,7 @@ public class WakeupControllerTest extends WifiBaseTest {
         when(mWifiInjector.getWifiSettingsStore()).thenReturn(mWifiSettingsStore);
         when(mWifiInjector.getActiveModeWarden()).thenReturn(mActiveModeWarden);
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mPrimaryClientModeManager);
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(
                         WifiManager.WIFI_FEATURE_WPA3_SAE, WifiManager.WIFI_FEATURE_OWE));
         when(mWifiInjector.getWifiNative()).thenReturn(mWifiNative);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WakeupEvaluatorTest.java b/service/tests/wifitests/src/com/android/server/wifi/WakeupEvaluatorTest.java
index 064283e044..3952f3cda3 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WakeupEvaluatorTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WakeupEvaluatorTest.java
@@ -106,7 +106,7 @@ public class WakeupEvaluatorTest extends WifiBaseTest {
         when(WifiInjector.getInstance()).thenReturn(mWifiInjector);
         when(mWifiInjector.getActiveModeWarden()).thenReturn(mActiveModeWarden);
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mPrimaryClientModeManager);
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(
                         WifiManager.WIFI_FEATURE_WPA3_SAE, WifiManager.WIFI_FEATURE_OWE));
         when(mWifiInjector.getWifiGlobals()).thenReturn(mWifiGlobals);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiApConfigStoreTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiApConfigStoreTest.java
index 77274c17ec..b7b86871d0 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiApConfigStoreTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiApConfigStoreTest.java
@@ -568,7 +568,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
     public void generateLocalOnlyHotspotConfigIsValid() throws Exception {
         WifiApConfigStore store = createWifiApConfigStore();
         SoftApConfiguration config = store
-                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability);
+                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false);
         verifyDefaultLocalOnlyApConfig(config, TEST_DEFAULT_HOTSPOT_SSID,
                 SoftApConfiguration.BAND_2GHZ);
 
@@ -589,7 +589,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         mResources.setBoolean(R.bool.config_wifi_local_only_hotspot_5ghz, true);
         WifiApConfigStore store = createWifiApConfigStore();
         SoftApConfiguration config = store
-                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability);
+                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false);
         verifyDefaultLocalOnlyApConfig(config, TEST_DEFAULT_HOTSPOT_SSID,
                 SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ);
 
@@ -609,7 +609,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         mResources.setBoolean(R.bool.config_wifi_local_only_hotspot_5ghz, true);
         WifiApConfigStore store = createWifiApConfigStore();
         SoftApConfiguration config = store
-                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability);
+                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false);
         verifyDefaultLocalOnlyApConfig(config, TEST_DEFAULT_HOTSPOT_SSID,
                 SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ);
 
@@ -627,7 +627,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         mResources.setBoolean(R.bool.config_wifiLocalOnlyHotspot6ghz, true);
         WifiApConfigStore store = createWifiApConfigStore();
         SoftApConfiguration config = store
-                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability);
+                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false);
         verifyDefaultLocalOnlyApConfig(config, TEST_DEFAULT_HOTSPOT_SSID,
                 SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_6GHZ);
 
@@ -651,7 +651,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         mResources.setBoolean(R.bool.config_wifi_local_only_hotspot_5ghz, true);
         WifiApConfigStore store = createWifiApConfigStore();
         SoftApConfiguration config = store
-                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability);
+                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false);
         verifyDefaultLocalOnlyApConfig(config, TEST_DEFAULT_HOTSPOT_SSID,
                 SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ
                         | SoftApConfiguration.BAND_6GHZ);
@@ -671,13 +671,13 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         SoftApConfiguration.Builder customConfigBuilder = new SoftApConfiguration.Builder()
                 .setBand(SoftApConfiguration.BAND_5GHZ);
         SoftApConfiguration softApConfig = store.generateLocalOnlyHotspotConfig(
-                mContext, customConfigBuilder.build(), mSoftApCapability);
+                mContext, customConfigBuilder.build(), mSoftApCapability, true);
         assertThat(softApConfig.getBand()).isEqualTo(SoftApConfiguration.BAND_5GHZ);
 
         // Test 6G band
         customConfigBuilder.setBand(SoftApConfiguration.BAND_6GHZ);
         softApConfig = store.generateLocalOnlyHotspotConfig(
-                mContext, customConfigBuilder.build(), mSoftApCapability);
+                mContext, customConfigBuilder.build(), mSoftApCapability, true);
         assertThat(softApConfig.getBand()).isEqualTo(SoftApConfiguration.BAND_6GHZ);
     }
 
@@ -692,7 +692,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         }
         SoftApConfiguration customConfig = customConfigBuilder.build();
         SoftApConfiguration softApConfig = store.generateLocalOnlyHotspotConfig(
-                mContext, customConfig, mSoftApCapability);
+                mContext, customConfig, mSoftApCapability, true);
         assertThat(softApConfig.getBssid().toString()).isNotEmpty();
         assertThat(softApConfig.getBssid()).isEqualTo(TEST_SAP_BSSID_MAC);
     }
@@ -946,6 +946,16 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
                 configBuilder.build(), true, mContext, mWifiNative));
     }
 
+    @Test
+    public void test11BERequires11AXConfigInValidateApWifiConfigurationCheck() {
+        assumeTrue(SdkLevel.isAtLeastB());
+        assertFalse(WifiApConfigStore.validateApWifiConfiguration(
+                new SoftApConfiguration.Builder()
+                .setSsid(TEST_DEFAULT_HOTSPOT_SSID)
+                .setIeee80211axEnabled(false)
+                .setIeee80211beEnabled(true)
+                .buildWithoutCheck(), true, mContext, mWifiNative));
+    }
 
     /**
      * Verify the default configuration security when SAE support.
@@ -967,7 +977,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         mResources.setBoolean(R.bool.config_wifi_softap_sae_supported, true);
         WifiApConfigStore store = createWifiApConfigStore();
         SoftApConfiguration config = store
-                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability);
+                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false);
         verifyDefaultLocalOnlyApConfig(config, TEST_DEFAULT_HOTSPOT_SSID,
                 SoftApConfiguration.BAND_2GHZ, true);
 
@@ -986,7 +996,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         mResources.setBoolean(R.bool.config_wifi_ap_mac_randomization_supported, true);
         WifiApConfigStore store = createWifiApConfigStore();
         SoftApConfiguration config = store
-                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability);
+                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false);
         verifyDefaultLocalOnlyApConfig(config, TEST_DEFAULT_HOTSPOT_SSID,
                 SoftApConfiguration.BAND_2GHZ, true, true);
 
@@ -1006,7 +1016,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         mResources.setBoolean(R.bool.config_wifi_ap_mac_randomization_supported, false);
         WifiApConfigStore store = createWifiApConfigStore();
         SoftApConfiguration config = store
-                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability);
+                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false);
         verifyDefaultLocalOnlyApConfig(config, TEST_DEFAULT_HOTSPOT_SSID,
                 SoftApConfiguration.BAND_2GHZ, true, false);
 
@@ -1031,7 +1041,7 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
                 .setMacRandomizationSetting(SoftApConfiguration.RANDOMIZATION_NONE).build();
         storeMacRandomizationSupported.setApConfiguration(disableMacRandomizationConfig);
         SoftApConfiguration config = storeMacRandomizationSupported
-                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability);
+                .generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false);
         verifyDefaultLocalOnlyApConfig(config, TEST_DEFAULT_HOTSPOT_SSID,
                 SoftApConfiguration.BAND_2GHZ, true, false);
 
@@ -1452,11 +1462,11 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         assertEquals(TEST_RANDOMIZED_MAC, store.getApConfiguration()
                 .getPersistentRandomizedMacAddress());
         assertEquals(TEST_RANDOMIZED_MAC,
-                store.generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability)
+                store.generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false)
                 .getPersistentRandomizedMacAddress());
         assertEquals(TEST_RANDOMIZED_MAC,
                 store.generateLocalOnlyHotspotConfig(mContext, store.getApConfiguration(),
-                mSoftApCapability).getPersistentRandomizedMacAddress());
+                mSoftApCapability, true).getPersistentRandomizedMacAddress());
     }
 
     @Test
@@ -1465,11 +1475,11 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         WifiApConfigStore store = createWifiApConfigStore();
         assertNotNull(store.getApConfiguration().getPersistentRandomizedMacAddress());
         assertNotNull(
-                store.generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability)
+                store.generateLocalOnlyHotspotConfig(mContext, null, mSoftApCapability, false)
                 .getPersistentRandomizedMacAddress());
         assertNotNull(
                 store.generateLocalOnlyHotspotConfig(mContext, store.getApConfiguration(),
-                mSoftApCapability).getPersistentRandomizedMacAddress());
+                mSoftApCapability, true).getPersistentRandomizedMacAddress());
     }
 
     @Test
@@ -1531,4 +1541,32 @@ public class WifiApConfigStoreTest extends WifiBaseTest {
         // Verify it changes to default band.
         verifyDefaultApConfig(store.getApConfiguration(), TEST_DEFAULT_AP_SSID, false, true, false);
     }
+
+    @Test
+    public void testGenerateLocalOnlyHotspotFromNonExclusiveConfig() throws Exception {
+        assumeTrue(SdkLevel.isAtLeastS());
+        WifiApConfigStore store = createWifiApConfigStore();
+        String testSsid = "ShouldNotApplied";
+        SoftApConfiguration.Builder customConfigBuilder = new SoftApConfiguration.Builder()
+                .setSsid(testSsid)
+                .setBand(SoftApConfiguration.BAND_5GHZ);
+        SoftApConfiguration softApConfig = store.generateLocalOnlyHotspotConfig(
+                mContext, customConfigBuilder.build(), mSoftApCapability, false);
+        assertThat(softApConfig.getBand()).isEqualTo(SoftApConfiguration.BAND_5GHZ);
+        // Make sure SSID was not applied.
+        verifyDefaultLocalOnlyApConfig(softApConfig, TEST_DEFAULT_HOTSPOT_SSID,
+                SoftApConfiguration.BAND_5GHZ);
+
+        // verify that the config passes the validateApWifiConfiguration check
+        assertTrue(WifiApConfigStore.validateApWifiConfiguration(softApConfig, true, mContext,
+                mWifiNative));
+        // Test 6G band with non-isPrivileged use case
+        mResources.setBoolean(R.bool.config_wifi_softap_sae_supported, true);
+        customConfigBuilder.setBand(SoftApConfiguration.BAND_6GHZ);
+        softApConfig = store.generateLocalOnlyHotspotConfig(
+                mContext, customConfigBuilder.build(), mSoftApCapability, false);
+        assertThat(softApConfig.getBand()).isEqualTo(SoftApConfiguration.BAND_6GHZ);
+        assertTrue(WifiApConfigStore.validateApWifiConfiguration(
+                softApConfig, false, mContext, mWifiNative));
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiBlocklistMonitorTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiBlocklistMonitorTest.java
index ce5a929101..8b243e6dd8 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiBlocklistMonitorTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiBlocklistMonitorTest.java
@@ -1419,11 +1419,22 @@ public class WifiBlocklistMonitorTest extends WifiBaseTest {
         int assocRejectReason = NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION;
         int assocRejectThreshold =
                 mWifiBlocklistMonitor.getNetworkSelectionDisableThreshold(assocRejectReason);
-        for (int i = 1; i <= assocRejectThreshold; i++) {
+        for (int i = 0; i < assocRejectThreshold; i++) {
             assertFalse(mWifiBlocklistMonitor.updateNetworkSelectionStatus(
                     openNetwork, assocRejectReason));
         }
         assertFalse(openNetwork.getNetworkSelectionStatus().isNetworkTemporaryDisabled());
+
+        // verify that after the consecutive failure threshold is reached, the network is blocked
+        int remainingTriggers = WifiBlocklistMonitor
+                .NUM_CONSECUTIVE_FAILURES_PER_NETWORK_EXP_BACKOFF - assocRejectThreshold;
+        for (int i = 0; i < remainingTriggers - 1; i++) {
+            assertFalse(mWifiBlocklistMonitor.updateNetworkSelectionStatus(
+                    openNetwork, assocRejectReason));
+        }
+        assertTrue(mWifiBlocklistMonitor.updateNetworkSelectionStatus(
+                openNetwork, assocRejectReason));
+        assertTrue(openNetwork.getNetworkSelectionStatus().isNetworkTemporaryDisabled());
     }
 
     /**
@@ -1788,4 +1799,34 @@ public class WifiBlocklistMonitorTest extends WifiBaseTest {
 
         assertEquals(maxAllowlistSize, ssidAllowlistCaptor.getValue().size());
     }
+
+    /**
+     * Verifies the bssid block list can be cleared for a specific reason code.
+     */
+    @Test
+    public void testClearBlocklistBssidForReason() {
+        WifiConfiguration config = WifiConfigurationTestUtil.createPskNetwork(TEST_SSID_1);
+        long testDuration = 5500L;
+        // Add bssid's in the block list with different reason codes and validate.
+        // - TEST_BSSID_1 and TEST_BSSID_2 with REASON_FRAMEWORK_DISCONNECT_FAST_RECONNECT
+        // - TEST_BSSID_3 with REASON_ASSOCIATION_REJECTION
+        mWifiBlocklistMonitor.blockBssidForDurationMs(TEST_BSSID_1, config, testDuration,
+                WifiBlocklistMonitor.REASON_FRAMEWORK_DISCONNECT_FAST_RECONNECT, -TEST_GOOD_RSSI);
+        mWifiBlocklistMonitor.blockBssidForDurationMs(TEST_BSSID_2, config, testDuration,
+                WifiBlocklistMonitor.REASON_FRAMEWORK_DISCONNECT_FAST_RECONNECT, -TEST_GOOD_RSSI);
+        mWifiBlocklistMonitor.blockBssidForDurationMs(TEST_BSSID_3, config, testDuration,
+                WifiBlocklistMonitor.REASON_ASSOCIATION_REJECTION, -TEST_GOOD_RSSI);
+        assertEquals(Set.of(TEST_BSSID_1, TEST_BSSID_2, TEST_BSSID_3),
+                mWifiBlocklistMonitor.updateAndGetBssidBlocklist());
+        assertEquals(Set.of(WifiBlocklistMonitor.REASON_ASSOCIATION_REJECTION,
+                        WifiBlocklistMonitor.REASON_FRAMEWORK_DISCONNECT_FAST_RECONNECT),
+                mWifiBlocklistMonitor.getFailureReasonsForSsid(TEST_SSID_1));
+        // Remove entries with reason REASON_FRAMEWORK_DISCONNECT_FAST_RECONNECT, and
+        // block list should have only TEST_BSSID_3 with reason REASON_ASSOCIATION_REJECTION
+        mWifiBlocklistMonitor.clearBssidBlocklistForReason(
+                WifiBlocklistMonitor.REASON_FRAMEWORK_DISCONNECT_FAST_RECONNECT);
+        assertEquals(Set.of(TEST_BSSID_3), mWifiBlocklistMonitor.updateAndGetBssidBlocklist());
+        assertEquals(Set.of(WifiBlocklistMonitor.REASON_ASSOCIATION_REJECTION),
+                mWifiBlocklistMonitor.getFailureReasonsForSsid(TEST_SSID_1));
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiCandidatesTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiCandidatesTest.java
index 40f94fe9ff..9d095242b1 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiCandidatesTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiCandidatesTest.java
@@ -98,7 +98,7 @@ public class WifiCandidatesTest extends WifiBaseTest {
         when(mWifiInjector.getWifiGlobals()).thenReturn(mWifiGlobals);
         when(mWifiInjector.getActiveModeWarden()).thenReturn(mActiveModeWarden);
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mClientModeManager);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WIFI_FEATURE_OWE, WIFI_FEATURE_WPA3_SAE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
         when(mWifiGlobals.isOweUpgradeEnabled()).thenReturn(true);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiConfigManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiConfigManagerTest.java
index 75f044f76c..3d25fdada6 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiConfigManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiConfigManagerTest.java
@@ -17,6 +17,7 @@
 package com.android.server.wifi;
 
 import static android.net.wifi.WifiConfiguration.SECURITY_TYPE_PSK;
+import static android.net.wifi.WifiConfiguration.SECURITY_TYPE_SAE;
 import static android.net.wifi.WifiManager.AddNetworkResult.STATUS_INVALID_CONFIGURATION_ENTERPRISE;
 
 import static com.android.server.wifi.TestUtil.createCapabilityBitset;
@@ -31,7 +32,7 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeTrue;
-import static org.mockito.ArgumentMatchers.anyObject;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyInt;
@@ -367,7 +368,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
         when(mWifiInjector.getWifiGlobals()).thenReturn(mWifiGlobals);
         when(mWifiInjector.getSsidTranslator()).thenReturn(mSsidTranslator);
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mPrimaryClientModeManager);
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(
                         WifiManager.WIFI_FEATURE_WPA3_SAE, WifiManager.WIFI_FEATURE_OWE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
@@ -2035,7 +2036,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
      */
     @Test
     public void testEnterpriseConfigTofuStateMerge() {
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE));
 
         // If the configuration has never connected, the merged TOFU connection state
@@ -8009,7 +8010,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
         if (isTofuSupported) {
             featureSet.set(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE);
         }
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(featureSet);
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(featureSet);
 
         WifiConfiguration config = prepareTofuEapConfig(
                 WifiEnterpriseConfig.Eap.PEAP, WifiEnterpriseConfig.Phase2.NONE);
@@ -8117,7 +8118,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
         verifyAddNetworkToWifiConfigManager(openNetwork);
         NetworkUpdateResult result =
                 mWifiConfigManager.addOrUpdateNetwork(openNetwork, TEST_CREATOR_UID);
-        verify(mListener, never()).onNetworkAdded(anyObject());
+        verify(mListener, never()).onNetworkAdded(any());
     }
 
     private int verifyAddNetwork(WifiConfiguration config, boolean expectNew) {
@@ -8129,7 +8130,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
 
     @Test
     public void testUpdateCaCertificateSuccess() throws Exception {
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE));
 
         int eapPeapNetId = verifyAddNetwork(prepareTofuEapConfig(
@@ -8144,7 +8145,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
 
     @Test
     public void testUpdateCaCertificatePathSuccess() throws Exception {
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE));
 
         int eapPeapNetId = verifyAddNetwork(prepareTofuEapConfig(
@@ -8162,7 +8163,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
 
     @Test
     public void testUpdateCaCertificateWithoutAltSubjectNames() throws Exception {
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE));
 
         verifyAddNetwork(WifiConfigurationTestUtil.createOpenNetwork(), true);
@@ -8188,7 +8189,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
 
     @Test
     public void testUpdateCaCertificateWithAltSubjectNames() throws Exception {
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE));
 
         verifyAddNetwork(WifiConfigurationTestUtil.createOpenNetwork(), true);
@@ -8228,7 +8229,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
 
     @Test
     public void testUpdateCaCertificateFaiulreInvalidArgument() throws Exception {
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE));
 
         int openNetId = verifyAddNetwork(WifiConfigurationTestUtil.createOpenNetwork(), true);
@@ -8264,7 +8265,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
 
     @Test
     public void testUpdateCaCertificateSuccessWithSelfSignedCertificate() throws Exception {
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE));
         int eapPeapNetId = verifyAddNetwork(prepareTofuEapConfig(
                 WifiEnterpriseConfig.Eap.PEAP, WifiEnterpriseConfig.Phase2.NONE), true);
@@ -8280,7 +8281,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
 
     @Test
     public void testUpdateServerCertificateHashSuccess() throws Exception {
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE));
         int eapPeapNetId = verifyAddNetwork(prepareTofuEapConfig(
                 WifiEnterpriseConfig.Eap.PEAP, WifiEnterpriseConfig.Phase2.NONE), true);
@@ -8295,7 +8296,7 @@ public class WifiConfigManagerTest extends WifiBaseTest {
     @Test
     public void testUpdateCaCertificateFailureWithSelfSignedCertificateAndTofuNotEnabled()
             throws Exception {
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WifiManager.WIFI_FEATURE_TRUST_ON_FIRST_USE));
         int eapPeapNetId = verifyAddNetwork(WifiConfigurationTestUtil.createEapNetwork(
                 WifiEnterpriseConfig.Eap.PEAP, WifiEnterpriseConfig.Phase2.NONE), true);
@@ -8502,4 +8503,33 @@ public class WifiConfigManagerTest extends WifiBaseTest {
         result = updateNetworkToWifiConfigManager(config);
         assertFalse(result.isSuccess());
     }
+
+    /**
+     * Verify that the configured network with password is correctly retrieved using SSID and Key
+     * management.
+     */
+    @Test
+    public void testConfiguredNetworkWithPassword() {
+
+        NetworkSelectionStatus.Builder builder = new NetworkSelectionStatus.Builder();
+        NetworkSelectionStatus networkSelectionStatus = builder.build();
+        SecurityParams params = SecurityParams.createSecurityParamsBySecurityType(
+                SECURITY_TYPE_SAE);
+        networkSelectionStatus.setCandidateSecurityParams(params);
+        WifiConfiguration saeNetwork = WifiConfigurationTestUtil.createSaeNetwork(TEST_SSID);
+        saeNetwork.setNetworkSelectionStatus(networkSelectionStatus);
+        NetworkUpdateResult result  = verifyAddNetworkToWifiConfigManager(saeNetwork);
+
+        // Get the configured network with password
+        WifiConfiguration wifiConfig = mWifiConfigManager.getConfiguredNetworkWithPassword(
+                WifiSsid.fromString(TEST_SSID), SECURITY_TYPE_SAE);
+        // Test the retrieved network is the same network that was added for TEST_SSID and SAE
+        assertNotNull(wifiConfig);
+        assertEquals(saeNetwork.networkId, result.getNetworkId());
+        assertEquals(WifiConfigurationTestUtil.TEST_PSK, wifiConfig.preSharedKey);
+        wifiConfig = mWifiConfigManager.getConfiguredNetworkWithPassword(
+                WifiSsid.fromString(TEST_SSID), SECURITY_TYPE_PSK);
+        // Test there is no network with TEST_SSID and FT_PSK
+        assertNull(wifiConfig);
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiConfigurationUtilTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiConfigurationUtilTest.java
index 5aa28c451b..0ff24270f1 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiConfigurationUtilTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiConfigurationUtilTest.java
@@ -773,7 +773,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher(TEST_SSID, PatternMatcher.PATTERN_LITERAL),
                 Pair.create(WifiManager.ALL_ZEROS_MAC_ADDRESS, WifiManager.ALL_ZEROS_MAC_ADDRESS),
                 ScanResult.UNSPECIFIED,
-                WifiConfigurationTestUtil.createOpenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenNetwork(), new int[0], false);
         assertTrue(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
@@ -787,7 +787,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher(".*", PatternMatcher.PATTERN_SIMPLE_GLOB),
                 Pair.create(MacAddress.fromString(TEST_BSSID), MacAddress.BROADCAST_ADDRESS),
                 ScanResult.UNSPECIFIED,
-                WifiConfigurationTestUtil.createOpenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenNetwork(), new int[0], false);
         assertTrue(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
@@ -801,7 +801,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher(TEST_SSID, PatternMatcher.PATTERN_LITERAL),
                 Pair.create(MacAddress.fromString(TEST_BSSID), MacAddress.BROADCAST_ADDRESS),
                 ScanResult.UNSPECIFIED,
-                WifiConfigurationTestUtil.createOpenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenNetwork(), new int[0], false);
         assertTrue(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
@@ -816,7 +816,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher(TEST_SSID, PatternMatcher.PATTERN_LITERAL),
                 Pair.create(MacAddress.fromString(TEST_BSSID), MacAddress.BROADCAST_ADDRESS),
                 ScanResult.WIFI_BAND_5_GHZ,
-                WifiConfigurationTestUtil.createOpenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenNetwork(), new int[0], false);
         assertTrue(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
@@ -831,7 +831,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher(".*", PatternMatcher.PATTERN_SIMPLE_GLOB),
                 Pair.create(WifiManager.ALL_ZEROS_MAC_ADDRESS, WifiManager.ALL_ZEROS_MAC_ADDRESS),
                 ScanResult.UNSPECIFIED,
-                WifiConfigurationTestUtil.createOpenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenNetwork(), new int[0], false);
         assertFalse(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
@@ -845,7 +845,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher("", PatternMatcher.PATTERN_LITERAL),
                 Pair.create(WifiManager.ALL_ZEROS_MAC_ADDRESS, WifiManager.ALL_ZEROS_MAC_ADDRESS),
                 ScanResult.UNSPECIFIED,
-                WifiConfigurationTestUtil.createOpenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenNetwork(), new int[0], false);
         assertFalse(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
@@ -859,7 +859,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher(TEST_SSID, PatternMatcher.PATTERN_LITERAL),
                 Pair.create(MacAddress.BROADCAST_ADDRESS, MacAddress.BROADCAST_ADDRESS),
                 ScanResult.UNSPECIFIED,
-                WifiConfigurationTestUtil.createOpenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenNetwork(), new int[0], false);
         assertFalse(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
@@ -873,7 +873,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher(TEST_SSID, PatternMatcher.PATTERN_LITERAL),
                 Pair.create(MacAddress.fromString(TEST_BSSID), WifiManager.ALL_ZEROS_MAC_ADDRESS),
                 ScanResult.UNSPECIFIED,
-                WifiConfigurationTestUtil.createOpenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenNetwork(), new int[0], false);
         assertFalse(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
@@ -887,7 +887,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher(TEST_SSID, PatternMatcher.PATTERN_PREFIX),
                 Pair.create(WifiManager.ALL_ZEROS_MAC_ADDRESS, WifiManager.ALL_ZEROS_MAC_ADDRESS),
                 ScanResult.UNSPECIFIED,
-                WifiConfigurationTestUtil.createOpenHiddenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenHiddenNetwork(), new int[0], false);
         assertFalse(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
@@ -900,7 +900,7 @@ public class WifiConfigurationUtilTest extends WifiBaseTest {
                 new PatternMatcher(TEST_SSID, PatternMatcher.PATTERN_LITERAL),
                 Pair.create(MacAddress.fromString(TEST_BSSID), MacAddress.BROADCAST_ADDRESS),
                 42,  // invalid
-                WifiConfigurationTestUtil.createOpenNetwork(), new int[0]);
+                WifiConfigurationTestUtil.createOpenNetwork(), new int[0], false);
         assertFalse(WifiConfigurationUtil.validateNetworkSpecifier(specifier, 5));
     }
 
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiConnectivityHelperTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiConnectivityHelperTest.java
index f78f6ec4c9..24ab6baff0 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiConnectivityHelperTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiConnectivityHelperTest.java
@@ -71,7 +71,7 @@ public class WifiConnectivityHelperTest extends WifiBaseTest {
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mClientModeManager);
 
         // Return firmware roaming feature as supported by default.
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WIFI_FEATURE_CONTROL_ROAMING));
 
         WifiNative.RoamingCapabilities roamCap = new WifiNative.RoamingCapabilities();
@@ -125,7 +125,7 @@ public class WifiConnectivityHelperTest extends WifiBaseTest {
     public void returnFirmwareRoamingNotSupported() {
         BitSet supportedFeatures = new BitSet();
         supportedFeatures.set(WIFI_FEATURE_CONTROL_ROAMING, false);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(supportedFeatures);
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(supportedFeatures);
         assertTrue(mWifiConnectivityHelper.getFirmwareRoamingInfo());
         assertFalse(mWifiConnectivityHelper.isFirmwareRoamingSupported());
     }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiConnectivityManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiConnectivityManagerTest.java
index 05464fd237..996c2be2b3 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiConnectivityManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiConnectivityManagerTest.java
@@ -36,7 +36,6 @@ import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.anyList;
 import static org.mockito.Mockito.anyLong;
-import static org.mockito.Mockito.anyObject;
 import static org.mockito.Mockito.anySet;
 import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.argThat;
@@ -505,7 +504,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                 }
                 mAllSingleScanListenerCaptor.getValue().getWifiScannerListener().onResults(
                         scanDatas);
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
 
         // This unfortunately needs to be a somewhat valid scan result, otherwise
         // |ScanDetailUtil.toScanDetail| raises exceptions.
@@ -534,7 +533,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                         (WifiScanner.PnoScanListener) listener.getWifiScannerListener();
                 l.onPnoNetworkFound(scanResults);
             }}).when(mWifiScanner).startPnoScan(
-                    anyObject(), anyObject(), anyObject());
+                    any(), any(), any());
 
     }
 
@@ -3155,7 +3154,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
             int[] intervalSchedule, int[] scheduleScanType) {
         // Verify the scans actually happened for expected times, one scan for state change and
         // each for scan timer triggered.
-        verify(mWifiScanner, times(scanTimes)).startScan(anyObject(), anyObject());
+        verify(mWifiScanner, times(scanTimes)).startScan(any(), any());
 
         // Verify scans are happening using the expected scan type.
         Map<Integer, Integer> scanTypeToTimesMap = new HashMap<>();
@@ -3762,7 +3761,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         mWifiConnectivityManager.handleConnectionStateChanged(
                 mPrimaryClientModeManager,
                 WifiConnectivityManager.WIFI_STATE_DISCONNECTED);
-        verify(mWifiScanner, times(1)).startScan(anyObject(), anyObject());
+        verify(mWifiScanner, times(1)).startScan(any(), any());
 
         // Set up time stamp for when entering CONNECTED state
         currentTimeStamp += 2000;
@@ -3804,7 +3803,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                 mPrimaryClientModeManager,
                 WifiConnectivityManager.WIFI_STATE_DISCONNECTED);
 
-        verify(mWifiScanner, never()).startScan(anyObject(), anyObject());
+        verify(mWifiScanner, never()).startScan(any(), any());
     }
 
     /**
@@ -3833,7 +3832,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         // Set WiFi to connected state to trigger the periodic scan
         setWifiStateConnected();
 
-        verify(mWifiScanner, times(1)).startScan(anyObject(), anyObject());
+        verify(mWifiScanner, times(1)).startScan(any(), any());
 
         // Set up the time stamp for when entering DISCONNECTED state
         currentTimeStamp += 2000;
@@ -3939,7 +3938,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                     assertEquals(WifiScanner.WIFI_BAND_ALL, settings.band);
                 }
                 assertNull(settings.channels);
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
 
         when(mClock.getElapsedSinceBootMillis()).thenReturn(0L);
         // Set screen to ON
@@ -3950,7 +3949,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                 mPrimaryClientModeManager,
                 WifiConnectivityManager.WIFI_STATE_CONNECTED);
         mLooper.dispatchAll();
-        verify(mWifiScanner).startScan(anyObject(), anyObject());
+        verify(mWifiScanner).startScan(any(), any());
 
         // Verify case 2
         when(mWifiNS.isNetworkSufficient(eq(mWifiInfo))).thenReturn(true);
@@ -3963,7 +3962,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         mWifiConnectivityManager.handleConnectionStateChanged(
                 mPrimaryClientModeManager,
                 WifiConnectivityManager.WIFI_STATE_CONNECTED);
-        verify(mWifiScanner, times(2)).startScan(anyObject(), anyObject());
+        verify(mWifiScanner, times(2)).startScan(any(), any());
 
         // Verify case 3
         when(mWifiNS.isNetworkSufficient(eq(mWifiInfo))).thenReturn(false);
@@ -3976,7 +3975,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         mWifiConnectivityManager.handleConnectionStateChanged(
                 mPrimaryClientModeManager,
                 WifiConnectivityManager.WIFI_STATE_CONNECTED);
-        verify(mWifiScanner, times(2)).startScan(anyObject(), anyObject());
+        verify(mWifiScanner, times(2)).startScan(any(), any());
     }
 
     /**
@@ -4023,7 +4022,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                     assertTrue(channelList.contains(settings.channels[chanIdx].frequency));
                 }
                 mLooper.dispatchAll();
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
 
         // Set screen to ON
         setScreenState(true);
@@ -4033,7 +4032,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                 mPrimaryClientModeManager,
                 WifiConnectivityManager.WIFI_STATE_CONNECTED);
 
-        verify(mWifiScanner).startScan(anyObject(), anyObject());
+        verify(mWifiScanner).startScan(any(), any());
     }
 
     /**
@@ -4074,7 +4073,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                     assertTrue(channelList.contains(settings.channels[chanIdx].frequency));
                 }
                 mLooper.dispatchAll();
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
 
         // Set screen to ON
         setScreenState(true);
@@ -4084,7 +4083,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                 mPrimaryClientModeManager,
                 WifiConnectivityManager.WIFI_STATE_CONNECTED);
 
-        verify(mWifiScanner).startScan(anyObject(), anyObject());
+        verify(mWifiScanner).startScan(any(), any());
     }
 
 
@@ -4126,7 +4125,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                     assertEquals(WifiScanner.WIFI_BAND_ALL, settings.band);
                 }
                 mLooper.dispatchAll();
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
 
         // Set screen to ON
         setScreenState(true);
@@ -4136,7 +4135,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                 mPrimaryClientModeManager,
                 WifiConnectivityManager.WIFI_STATE_CONNECTED);
 
-        verify(mWifiScanner).startScan(anyObject(), anyObject());
+        verify(mWifiScanner).startScan(any(), any());
     }
 
     /**
@@ -4156,7 +4155,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                     throws Exception {
                 listener.onFailure(-1, "ScanFailure");
                 mLooper.dispatchAll();
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
 
         // Set WiFi to disconnected state to trigger the single scan based periodic scan
         mWifiConnectivityManager.handleConnectionStateChanged(
@@ -4174,7 +4173,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         // The very first scan is the initial one, and the other MAX_SCAN_RESTART_ALLOWED
         // are the retrial ones.
         verify(mWifiScanner, times(WifiConnectivityManager.MAX_SCAN_RESTART_ALLOWED + 1)).startScan(
-                anyObject(), anyObject());
+                any(), any());
     }
 
     @Test
@@ -4187,7 +4186,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                     throws Exception {
                 listener.onFailure(-1, "ScanFailure");
                 mLooper.dispatchAll();
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
 
         // Set WiFi to disconnected state to trigger the single scan based periodic scan
         mWifiConnectivityManager.handleConnectionStateChanged(
@@ -4206,7 +4205,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         // Verify that the connectivity scan has happened 2 times. Note, the first scan is due
         // to the initial request, and the second scan is the first retry after failure.
         // There are no more retries afterwards because the screen is off.
-        verify(mWifiScanner, times(2)).startScan(anyObject(), anyObject());
+        verify(mWifiScanner, times(2)).startScan(any(), any());
     }
 
     /**
@@ -4228,7 +4227,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                     throws Exception {
                 listener.onFailure(-1, "ScanFailure");
                 mLooper.dispatchAll();
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
 
         mWifiConnectivityManager.forceConnectivityScan(null);
         // make the retry succeed
@@ -4237,14 +4236,14 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                     throws Exception {
                 listener.onResults(null);
                 mLooper.dispatchAll();
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
         mAlarmManager.dispatch(WifiConnectivityManager.RESTART_SINGLE_SCAN_TIMER_TAG);
         mLooper.dispatchAll();
 
         // Verify that startScan is called once for the original scan, plus once for the retry.
         // The successful retry should have now cleared the restart count
         verify(mWifiScanner, times(2)).startScan(
-                anyObject(), anyObject());
+                any(), any());
 
         // Now force a new scan and verify we retry MAX_SCAN_RESTART_ALLOWED times
         doAnswer(new AnswerWithArguments() {
@@ -4252,7 +4251,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                     throws Exception {
                 listener.onFailure(-1, "ScanFailure");
                 mLooper.dispatchAll();
-            }}).when(mWifiScanner).startScan(anyObject(), anyObject());
+            }}).when(mWifiScanner).startScan(any(), any());
         mWifiConnectivityManager.forceConnectivityScan(null);
         // Fire the alarm timer 2x timers
         for (int i = 0; i < (WifiConnectivityManager.MAX_SCAN_RESTART_ALLOWED * 2); i++) {
@@ -4265,7 +4264,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         // and additionally MAX_SCAN_RESTART_ALLOWED + 1 times from forceConnectivityScan and
         // subsequent retries.
         verify(mWifiScanner, times(WifiConnectivityManager.MAX_SCAN_RESTART_ALLOWED + 3)).startScan(
-                anyObject(), anyObject());
+                any(), any());
     }
 
     /**
@@ -4769,6 +4768,8 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                 .updateAndGetBssidBlocklistForSsids(anySet());
         mWifiConnectivityManager.forceConnectivityScan(WIFI_WORK_SOURCE);
         mLooper.dispatchAll();
+        inOrder.verify(mWifiBlocklistMonitor).clearBssidBlocklistForReason(
+                eq(WifiBlocklistMonitor.REASON_FRAMEWORK_DISCONNECT_FAST_RECONNECT));
         inOrder.verify(mWifiBlocklistMonitor).tryEnablingBlockedBssids(any());
         inOrder.verify(mWifiConfigManager).updateNetworkSelectionStatus(disabledConfig.networkId,
                 WifiConfiguration.NetworkSelectionStatus.DISABLED_NONE);
@@ -5081,7 +5082,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
                 mCandidateBssidCaptor.capture());
         assertEquals(mCandidateBssidCaptor.getValue(), CANDIDATE_BSSID);
         verify(mPrimaryClientModeManager, never()).startConnectToNetwork(
-                anyInt(), anyInt(), anyObject());
+                anyInt(), anyInt(), any());
     }
 
     /**
@@ -5103,9 +5104,9 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         // Set screen to on
         setScreenState(true);
         mLooper.dispatchAll();
-        verify(mPrimaryClientModeManager, never()).startRoamToNetwork(anyInt(), anyObject());
+        verify(mPrimaryClientModeManager, never()).startRoamToNetwork(anyInt(), any());
         verify(mPrimaryClientModeManager, never()).startConnectToNetwork(
-                anyInt(), anyInt(), anyObject());
+                anyInt(), anyInt(), any());
     }
 
     /*
@@ -5175,7 +5176,7 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         // Set screen to on
         setScreenState(true);
 
-        verify(mPrimaryClientModeManager, times(0)).startRoamToNetwork(anyInt(), anyObject());
+        verify(mPrimaryClientModeManager, times(0)).startRoamToNetwork(anyInt(), any());
     }
 
     @Test
@@ -6289,8 +6290,8 @@ public class WifiConnectivityManagerTest extends WifiBaseTest {
         assertEquals(1, mTestHandler.getIntervals().size());
         final long delta = Math.abs(NETWORK_CHANGE_TRIGGER_PNO_THROTTLE_MS
                 - mTestHandler.getIntervals().get(0));
-        assertTrue("Interval " + " (" + delta + ") not in 1ms error margin",
-                delta < 2);
+        assertTrue("Interval " + " (" + delta + ") not in 5ms error margin",
+                delta < 6);
         when(mClock.getElapsedSinceBootMillis()).thenReturn(mTestHandler.getIntervals().get(0));
         // Now advance the test handler and fire the periodic scan timer
         mTestHandler.timeAdvance();
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiCountryCodeTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiCountryCodeTest.java
index 5941feeafd..6aa996e7c5 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiCountryCodeTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiCountryCodeTest.java
@@ -338,19 +338,20 @@ public class WifiCountryCodeTest extends WifiBaseTest {
         // Wifi get L2 connected.
         mClientModeImplListenerCaptor.getValue().onConnectionStart(mClientModeManager);
 
-        // Wifi Calling is available
-        when(mWifiCarrierInfoManager.isWifiCallingAvailable()).thenReturn(true);
-        // Telephony country code arrives.
-        mWifiCountryCode.setTelephonyCountryCodeAndUpdate(mTelephonyCountryCode);
-        // Telephony country code won't be applied at this time.
-        assertEquals("00", mWifiCountryCode.getCurrentDriverCountryCode());
-        verify(mWifiP2pMetrics).setIsCountryCodeWorldMode(true);
-        // Wifi is not forced to disconnect
-        verify(mClientModeManager, times(0)).disconnect();
+        if (mCallingSupported) {
+            // Wifi Calling is available
+            when(mWifiCarrierInfoManager.isWifiCallingAvailable()).thenReturn(true);
+            // Telephony country code arrives.
+            mWifiCountryCode.setTelephonyCountryCodeAndUpdate(mTelephonyCountryCode);
+            // Telephony country code won't be applied at this time.
+            assertEquals("00", mWifiCountryCode.getCurrentDriverCountryCode());
+            verify(mWifiP2pMetrics).setIsCountryCodeWorldMode(true);
+            verify(mClientModeManager, never()).disconnect();
+        }
 
+        // Test wifi traffic is high.
         // Wifi Calling is not available
         when(mWifiCarrierInfoManager.isWifiCallingAvailable()).thenReturn(false);
-        // Wifi traffic is high
         when(mWifiInfo.getSuccessfulTxPacketsPerSecond()).thenReturn(20.0);
         // Telephony country code arrives.
         mWifiCountryCode.setTelephonyCountryCodeAndUpdate(mTelephonyCountryCode);
@@ -358,9 +359,9 @@ public class WifiCountryCodeTest extends WifiBaseTest {
         assertEquals("00", mWifiCountryCode.getCurrentDriverCountryCode());
         verify(mWifiP2pMetrics).setIsCountryCodeWorldMode(true);
         // Wifi is not forced to disconnect
-        verify(mClientModeManager, times(0)).disconnect();
+        verify(mClientModeManager, never()).disconnect();
 
-        // Wifi traffic is low
+        // Wifi traffic is low (And no wifi calling)
         when(mWifiInfo.getSuccessfulTxPacketsPerSecond()).thenReturn(10.0);
         // Telephony country code arrives for multiple times
         for (int i = 0; i < 3; i++) {
@@ -368,10 +369,8 @@ public class WifiCountryCodeTest extends WifiBaseTest {
         }
         // Telephony country code still won't be applied.
         assertEquals("00", mWifiCountryCode.getCurrentDriverCountryCode());
-        if (mCallingSupported) {
-            // Wifi is forced to disconnect
-            verify(mClientModeManager, times(1)).disconnect();
-        }
+        // Wifi is forced to disconnect
+        verify(mClientModeManager, times(1)).disconnect();
 
         mClientModeImplListenerCaptor.getValue().onConnectionEnd(mClientModeManager);
         // Telephony country is applied after supplicant is ready.
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiDataStallTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiDataStallTest.java
index 592b16c420..cdce00ed6c 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiDataStallTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiDataStallTest.java
@@ -33,6 +33,7 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.content.Context;
+import android.net.wifi.ScanResult;
 import android.net.wifi.WifiInfo;
 import android.os.Handler;
 import android.os.test.TestLooper;
@@ -655,16 +656,17 @@ public class WifiDataStallTest extends WifiBaseTest {
         mNewLlStats.timeStampInMs = mOldLlStats.timeStampInMs + 1000;
         // Expect 1st throughput sufficiency check to return true
         // because it hits mLastTxBytes == 0 || mLastRxBytes == 0
+        mCapabilities.channelBandwidth = ScanResult.CHANNEL_WIDTH_80MHZ;
         mWifiDataStall.checkDataStallAndThroughputSufficiency(TEST_IFACE_NAME,
                 mCapabilities, mOldLlStats, mNewLlStats, mWifiInfo, mTxBytes, mRxBytes);
         verify(mWifiMetrics, times(1)).incrementConnectionDuration(TEST_IFACE_NAME,
-                1000, true, true, TEST_RSSI, 960, 9609);
+                1000, true, true, TEST_RSSI, 960, 9609, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
 
         // Expect 2nd throughput sufficiency check to return false
         mWifiDataStall.checkDataStallAndThroughputSufficiency(TEST_IFACE_NAME,
                 mCapabilities, mOldLlStats, mNewLlStats, mWifiInfo, mTxBytes, mRxBytes);
         verify(mWifiMetrics, times(1)).incrementConnectionDuration(TEST_IFACE_NAME,
-                1000, false, true, TEST_RSSI, 960, 9609);
+                1000, false, true, TEST_RSSI, 960, 9609, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
 
         mNewLlStats.timeStampInMs = mOldLlStats.timeStampInMs + 2000;
         phoneStateListener.onDataConnectionStateChanged(
@@ -673,7 +675,7 @@ public class WifiDataStallTest extends WifiBaseTest {
         mWifiDataStall.checkDataStallAndThroughputSufficiency(TEST_IFACE_NAME,
                 mCapabilities, mOldLlStats, mNewLlStats, mWifiInfo, mTxBytes, mRxBytes);
         verify(mWifiMetrics, times(1)).incrementConnectionDuration(TEST_IFACE_NAME,
-                2000, false, false, TEST_RSSI, 960, 9609);
+                2000, false, false, TEST_RSSI, 960, 9609, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
 
         // Expect this update to be ignored by connection duration counters due to its
         // too large poll interval
@@ -681,7 +683,7 @@ public class WifiDataStallTest extends WifiBaseTest {
         mWifiDataStall.checkDataStallAndThroughputSufficiency(TEST_IFACE_NAME,
                 mCapabilities, mOldLlStats, mNewLlStats, mWifiInfo, mTxBytes, mRxBytes);
         verify(mWifiMetrics, never()).incrementConnectionDuration(TEST_IFACE_NAME,
-                10000, false, false, TEST_RSSI, 960, 9609);
+                10000, false, false, TEST_RSSI, 960, 9609, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
         setWifiEnabled(false);
     }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiDeviceStateChangeManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiDeviceStateChangeManagerTest.java
index ec3c259f11..394e4ff334 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiDeviceStateChangeManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiDeviceStateChangeManagerTest.java
@@ -52,7 +52,6 @@ import org.mockito.MockitoAnnotations;
 
 @SmallTest
 public class WifiDeviceStateChangeManagerTest extends WifiBaseTest {
-
     @Mock Context mContext;
     @Mock WifiDeviceStateChangeManager.StateChangeCallback mStateChangeCallback;
     @Mock PowerManager mPowerManager;
@@ -63,7 +62,19 @@ public class WifiDeviceStateChangeManagerTest extends WifiBaseTest {
     @Captor ArgumentCaptor<BroadcastReceiver> mBroadcastReceiverCaptor;
     private TestLooper mLooper;
     private Handler mHandler;
-    private WifiDeviceStateChangeManager mWifiDeviceStateChangeManager;
+    private WifiDeviceStateChangeManagerSpy mWifiDeviceStateChangeManager;
+    private boolean mIsAapmApiFlagEnabled = false;
+
+    class WifiDeviceStateChangeManagerSpy extends WifiDeviceStateChangeManager {
+        WifiDeviceStateChangeManagerSpy() {
+            super(mContext, mHandler, mWifiInjector);
+        }
+
+        @Override
+        public boolean isAapmApiFlagEnabled() {
+            return mIsAapmApiFlagEnabled;
+        }
+    }
 
     @Before
     public void setUp() {
@@ -74,9 +85,7 @@ public class WifiDeviceStateChangeManagerTest extends WifiBaseTest {
         when(mPowerManager.isInteractive()).thenReturn(true);
         mLooper = new TestLooper();
         mHandler = new Handler(mLooper.getLooper());
-        mWifiDeviceStateChangeManager = new WifiDeviceStateChangeManager(mContext, mHandler,
-                mWifiInjector);
-
+        mWifiDeviceStateChangeManager = new WifiDeviceStateChangeManagerSpy();
     }
 
     @Test
@@ -123,7 +132,7 @@ public class WifiDeviceStateChangeManagerTest extends WifiBaseTest {
     @Test
     public void testCallbackWhenAdvancedProtectionModeSupported() {
         assumeTrue(Environment.isSdkAtLeastB());
-        assumeTrue(android.security.Flags.aapmApi());
+        mIsAapmApiFlagEnabled = true;
         ArgumentCaptor<AdvancedProtectionManager.Callback> apmCallbackCaptor =
                 ArgumentCaptor.forClass(AdvancedProtectionManager.Callback.class);
         when(mFeatureFlags.wepDisabledInApm()).thenReturn(true);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiDiagnosticsTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiDiagnosticsTest.java
index 1501289646..56dfd1a0c1 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiDiagnosticsTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiDiagnosticsTest.java
@@ -22,10 +22,10 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.AdditionalMatchers.gt;
 import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.contains;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.contains;
 import static org.mockito.Mockito.anyInt;
-import static org.mockito.Mockito.anyObject;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.eq;
@@ -183,7 +183,7 @@ public class WifiDiagnosticsTest extends WifiBaseTest {
     public void startLoggingRegistersLogEventHandler() throws Exception {
         mWifiDiagnostics.enableVerboseLogging(false, false);
         mWifiDiagnostics.startLogging(STA_IF_NAME);
-        verify(mWifiNative).setLoggingEventHandler(anyObject());
+        verify(mWifiNative).setLoggingEventHandler(any());
     }
 
     /**
@@ -195,32 +195,32 @@ public class WifiDiagnosticsTest extends WifiBaseTest {
             throws Exception {
         final boolean verbosityToggle = false;  // even default mode registers handler
 
-        when(mWifiNative.setLoggingEventHandler(anyObject())).thenReturn(false);
+        when(mWifiNative.setLoggingEventHandler(any())).thenReturn(false);
         mWifiDiagnostics.enableVerboseLogging(verbosityToggle, false);
         mWifiDiagnostics.startLogging(STA_IF_NAME);
-        verify(mWifiNative).setLoggingEventHandler(anyObject());
+        verify(mWifiNative).setLoggingEventHandler(any());
         mWifiDiagnostics.stopLogging(STA_IF_NAME);
         reset(mWifiNative);
 
-        when(mWifiNative.setLoggingEventHandler(anyObject())).thenReturn(true);
+        when(mWifiNative.setLoggingEventHandler(any())).thenReturn(true);
         mWifiDiagnostics.enableVerboseLogging(verbosityToggle, false);
         mWifiDiagnostics.startLogging(STA_IF_NAME);
-        verify(mWifiNative).setLoggingEventHandler(anyObject());
+        verify(mWifiNative).setLoggingEventHandler(any());
     }
 
     /** Verifies that startLogging() does not make redundant calls to setLoggingEventHandler(). */
     @Test
     public void startLoggingDoesNotRegisterLogEventHandlerIfPriorAttemptSucceeded()
             throws Exception {
-        when(mWifiNative.setLoggingEventHandler(anyObject())).thenReturn(true);
+        when(mWifiNative.setLoggingEventHandler(any())).thenReturn(true);
         mWifiDiagnostics.enableVerboseLogging(false, false);
         mWifiDiagnostics.startLogging(STA_IF_NAME);
-        verify(mWifiNative).setLoggingEventHandler(anyObject());
+        verify(mWifiNative).setLoggingEventHandler(any());
         reset(mWifiNative);
 
         mWifiDiagnostics.enableVerboseLogging(false, false);
         mWifiDiagnostics.startLogging(STA_IF_NAME);
-        verify(mWifiNative, never()).setLoggingEventHandler(anyObject());
+        verify(mWifiNative, never()).setLoggingEventHandler(any());
     }
 
     /**
@@ -262,7 +262,7 @@ public class WifiDiagnosticsTest extends WifiBaseTest {
         final boolean verbosityToggle = false;  // even default mode registers handler
 
         mWifiDiagnostics.enableVerboseLogging(verbosityToggle, verbosityToggle);
-        when(mWifiNative.setLoggingEventHandler(anyObject())).thenReturn(true);
+        when(mWifiNative.setLoggingEventHandler(any())).thenReturn(true);
         mWifiDiagnostics.startLogging(STA_IF_NAME);
         reset(mWifiNative);
 
@@ -282,7 +282,7 @@ public class WifiDiagnosticsTest extends WifiBaseTest {
     public void multipleStopLoggingCallsOnlyResetLogHandlerOnce() throws Exception {
         final boolean verbosityToggle = false;  // even default mode registers handler
 
-        when(mWifiNative.setLoggingEventHandler(anyObject())).thenReturn(true);
+        when(mWifiNative.setLoggingEventHandler(any())).thenReturn(true);
         mWifiDiagnostics.enableVerboseLogging(verbosityToggle, verbosityToggle);
         mWifiDiagnostics.startLogging(STA_IF_NAME);
         reset(mWifiNative);
@@ -917,7 +917,7 @@ public class WifiDiagnosticsTest extends WifiBaseTest {
     public void dumpRequestsLastMileLoggerDump() {
         mWifiDiagnostics.dump(
                 new FileDescriptor(), new PrintWriter(new StringWriter()), new String[]{});
-        verify(mLastMileLogger).dump(anyObject());
+        verify(mLastMileLogger).dump(any());
     }
 
     @Test
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiHealthMonitorTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiHealthMonitorTest.java
index 4f55297cbd..381ae62126 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiHealthMonitorTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiHealthMonitorTest.java
@@ -270,7 +270,7 @@ public class WifiHealthMonitorTest extends WifiBaseTest {
             public void answer(OnNetworkUpdateListener listener) throws Exception {
                 mOnNetworkUpdateListener = listener;
             }
-        }).when(wifiConfigManager).addOnNetworkUpdateListener(anyObject());
+        }).when(wifiConfigManager).addOnNetworkUpdateListener(any());
 
         doAnswer(new AnswerWithArguments() {
             public boolean answer(int networkId, int uid, String packageName) throws Exception {
@@ -331,7 +331,7 @@ public class WifiHealthMonitorTest extends WifiBaseTest {
                 }
                 listener.onResults(scanDatas);
             }
-        }).when(scanner).startScan(anyObject(), anyObject());
+        }).when(scanner).startScan(any(), any());
         WifiLocalServices.removeServiceForTest(WifiScannerInternal.class);
         WifiLocalServices.addService(WifiScannerInternal.class, scanner);
         return scanner;
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiLockManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiLockManagerTest.java
index 47065937db..cbdf1e80e0 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiLockManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiLockManagerTest.java
@@ -20,6 +20,7 @@ import static com.android.server.wifi.ActiveModeManager.ROLE_CLIENT_LOCAL_ONLY;
 import static com.android.server.wifi.ActiveModeManager.ROLE_CLIENT_PRIMARY;
 import static com.android.server.wifi.ActiveModeManager.ROLE_CLIENT_SECONDARY_TRANSIENT;
 import static com.android.server.wifi.TestUtil.createCapabilityBitset;
+import static com.android.server.wifi.WifiLockManager.DELAY_LOCK_RELEASE_MS;
 
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertEquals;
@@ -135,7 +136,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mContext.getSystemService(PowerManager.class)).thenReturn(mPowerManager);
 
         when(mClientModeManager.getRole()).thenReturn(ROLE_CLIENT_PRIMARY);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(new BitSet());
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(new BitSet());
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mClientModeManager);
 
         when(mClientModeManager2.getRole()).thenReturn(ROLE_CLIENT_SECONDARY_TRANSIENT);
@@ -302,7 +303,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
 
         acquireWifiLockSuccessful(WifiManager.WIFI_MODE_FULL_HIGH_PERF, "", mBinder, mWorkSource);
         releaseWifiLockSuccessful(mBinder);
-        verify(mWifiMetrics).addWifiLockAcqSession(
+        verify(mWifiMetrics).addWifiLockManagerAcqSession(
                 eq(mDeviceConfigFacade.isHighPerfLockDeprecated() && SdkLevel.isAtLeastU()
                         ? WifiManager.WIFI_MODE_FULL_LOW_LATENCY
                         : WifiManager.WIFI_MODE_FULL_HIGH_PERF), eq(new int[]{DEFAULT_TEST_UID_1}),
@@ -531,7 +532,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
             setScreenState(true);
             when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                     ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-            when(mClientModeManager.getSupportedFeatures())
+            when(mClientModeManager.getSupportedFeaturesBitSet())
                     .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
             when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
         }
@@ -562,7 +563,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
             setScreenState(true);
             when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                     ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-            when(mClientModeManager.getSupportedFeatures())
+            when(mClientModeManager.getSupportedFeaturesBitSet())
                     .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
             when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
             expectedMode = WifiManager.WIFI_MODE_FULL_LOW_LATENCY;
@@ -575,11 +576,28 @@ public class WifiLockManagerTest extends WifiBaseTest {
                 false);
 
         releaseWifiLockSuccessful(mBinder);
-        assertEquals(WifiManager.WIFI_MODE_NO_LOCKS_HELD,
-                mWifiLockManager.getStrongestLockMode());
+        assertEquals(WifiManager.WIFI_MODE_NO_LOCKS_HELD, mWifiLockManager.getStrongestLockMode());
+
+        mLooper.moveTimeForward(DELAY_LOCK_RELEASE_MS / 2 + 1);
+
+        acquireWifiLockSuccessful(WifiManager.WIFI_MODE_FULL_HIGH_PERF, "",
+                mBinder, mWorkSource);
+        assertEquals(expectedMode, mWifiLockManager.getStrongestLockMode());
+        releaseWifiLockSuccessful(mBinder);
+
+        mLooper.moveTimeForward(DELAY_LOCK_RELEASE_MS / 2 + 1);
+        assertEquals(WifiManager.WIFI_MODE_NO_LOCKS_HELD, mWifiLockManager.getStrongestLockMode());
+        mLooper.dispatchAll();
+        // Verify the first release is not triggered
+        inOrder.verify(mClientModeManager, never()).setPowerSave(
+                eq(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK), anyBoolean());
+
+        // Verify the last release is triggered
+        mLooper.moveTimeForward(DELAY_LOCK_RELEASE_MS + 1);
+        mLooper.dispatchAll();
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(expectedMode),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(eq(expectedMode),
                 eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
     }
@@ -614,7 +632,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
 
         // Release the first lock
         releaseWifiLockSuccessful(mBinder);
-        verify(mWifiMetrics).addWifiLockAcqSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
+        verify(mWifiMetrics).addWifiLockManagerAcqSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
                 eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyInt(), anyLong(),
                 anyBoolean(), anyBoolean(),
                 anyBoolean());
@@ -626,15 +644,19 @@ public class WifiLockManagerTest extends WifiBaseTest {
 
         // Release the second lock
         releaseWifiLockSuccessful(mBinder2);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
-                eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
+        mLooper.moveTimeForward(DELAY_LOCK_RELEASE_MS + 1);
+        mLooper.dispatchAll();
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF), eq(new int[]{DEFAULT_TEST_UID_1}),
+                eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
         assertEquals(WifiManager.WIFI_MODE_NO_LOCKS_HELD,
                 mWifiLockManager.getStrongestLockMode());
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
-                eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF), eq(new int[]{DEFAULT_TEST_UID_1}),
+                eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
     }
 
@@ -704,7 +726,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
             setScreenState(true);
             when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                     ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-            when(mClientModeManager.getSupportedFeatures())
+            when(mClientModeManager.getSupportedFeaturesBitSet())
                     .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
             when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
             expectedMode = WifiManager.WIFI_MODE_FULL_LOW_LATENCY;
@@ -749,7 +771,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
             setScreenState(true);
             when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                     ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-            when(mClientModeManager.getSupportedFeatures())
+            when(mClientModeManager.getSupportedFeaturesBitSet())
                     .thenReturn(createCapabilityBitset(WifiManager.WIFI_MODE_FULL_LOW_LATENCY));
             when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
             expectedMode = WifiManager.WIFI_MODE_FULL_LOW_LATENCY;
@@ -762,14 +784,16 @@ public class WifiLockManagerTest extends WifiBaseTest {
                 false);
 
         releaseWifiLockSuccessful(mBinder);
-        verify(mWifiMetrics).addWifiLockAcqSession(eq(expectedMode),
+        verify(mWifiMetrics).addWifiLockManagerAcqSession(eq(expectedMode),
                 eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyInt(), anyLong(),
                 anyBoolean(), anyBoolean(), anyBoolean());
         assertEquals(WifiManager.WIFI_MODE_NO_LOCKS_HELD,
                 mWifiLockManager.getStrongestLockMode());
+        mLooper.moveTimeForward(DELAY_LOCK_RELEASE_MS + 1);
+        mLooper.dispatchAll();
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics, never()).addWifiLockActiveSession(
+        verify(mWifiMetrics, never()).addWifiLockManagerActiveSession(
                 eq(expectedMode), eq(new int[]{DEFAULT_TEST_UID_1}),
                 eq(new String[]{null}), anyLong(), anyBoolean(), anyBoolean(), anyBoolean());
 
@@ -782,7 +806,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
                 mWifiLockManager.getStrongestLockMode());
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(expectedMode),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(eq(expectedMode),
                 eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
     }
@@ -811,9 +835,9 @@ public class WifiLockManagerTest extends WifiBaseTest {
                 mWifiLockManager.getStrongestLockMode());
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
-                eq(new int[0]), eq(new String[0]), anyLong(), anyBoolean(),
-                anyBoolean(), anyBoolean());
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF), eq(new int[0]), eq(new String[0]),
+                anyLong(), anyBoolean(), anyBoolean(), anyBoolean());
     }
 
     /**
@@ -841,7 +865,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
                 eq(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK), anyBoolean());
 
         releaseWifiLockSuccessful(mBinder);
-        verify(mWifiMetrics).addWifiLockAcqSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
+        verify(mWifiMetrics).addWifiLockManagerAcqSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
                 eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyInt(), anyLong(),
                 anyBoolean(), anyBoolean(), anyBoolean());
         assertEquals(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
@@ -854,8 +878,9 @@ public class WifiLockManagerTest extends WifiBaseTest {
                 mWifiLockManager.getStrongestLockMode());
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
-                eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF), eq(new int[]{DEFAULT_TEST_UID_1}),
+                eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
     }
 
@@ -1011,7 +1036,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         acquireWifiLockSuccessful(WifiManager.WIFI_MODE_FULL_LOW_LATENCY, "",
@@ -1031,7 +1056,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         setScreenState(true);
         when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_TX_POWER_LIMIT));
 
         acquireWifiLockSuccessful(WifiManager.WIFI_MODE_FULL_LOW_LATENCY, "",
@@ -1051,7 +1076,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         setScreenState(true);
         when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         // Make sure setLowLatencyMode() is successful
@@ -1070,11 +1095,18 @@ public class WifiLockManagerTest extends WifiBaseTest {
         releaseLowLatencyWifiLockSuccessful(mBinder);
         assertEquals(WifiManager.WIFI_MODE_NO_LOCKS_HELD,
                 mWifiLockManager.getStrongestLockMode());
+        mLooper.dispatchAll();
+        verify(mClientModeManager, never()).setLowLatencyMode(false);
+        verify(mClientModeManager, never()).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
+                true);
+        mLooper.moveTimeForward(DELAY_LOCK_RELEASE_MS + 1);
+        mLooper.dispatchAll();
         inOrder.verify(mClientModeManager).setLowLatencyMode(false);
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
-                eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY), eq(new int[]{DEFAULT_TEST_UID_1}),
+                eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
     }
 
@@ -1090,7 +1122,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         setScreenState(true);
         when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         // Fail the call to ClientModeManager
@@ -1120,7 +1152,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         setScreenState(true);
         when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         // Succeed to setLowLatencyMode()
@@ -1149,7 +1181,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         setScreenState(true);
         when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         // Make sure setLowLatencyMode() is successful
@@ -1173,8 +1205,9 @@ public class WifiLockManagerTest extends WifiBaseTest {
         inOrder.verify(mClientModeManager).setLowLatencyMode(false);
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
-                eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY), eq(new int[]{DEFAULT_TEST_UID_1}),
+                eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
     }
 
@@ -1188,7 +1221,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         setScreenState(true);
         when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         // Make sure setLowLatencyMode() is successful
@@ -1217,8 +1250,9 @@ public class WifiLockManagerTest extends WifiBaseTest {
         inOrder.verify(mClientModeManager).setLowLatencyMode(false);
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
-                eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY), eq(new int[]{DEFAULT_TEST_UID_1}),
+                eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
     }
 
@@ -1231,7 +1265,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         // Initially, set screen on, and app background
         setScreenState(true);
         when(mFrameworkFacade.isAppForeground(any(), anyInt())).thenReturn(false);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         // Make sure setLowLatencyMode() is successful
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
@@ -1274,7 +1308,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         // Initially, set screen on, and app background
         setScreenState(true);
         when(mFrameworkFacade.isAppForeground(any(), anyInt())).thenReturn(false);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
 
@@ -1307,8 +1341,9 @@ public class WifiLockManagerTest extends WifiBaseTest {
 
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
-                eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF), eq(new int[]{DEFAULT_TEST_UID_1}),
+                eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
         inOrder.verify(mClientModeManager).setLowLatencyMode(true);
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
@@ -1326,7 +1361,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
         when(mClientModeManager.setPowerSave(eq(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK),
                 anyBoolean())).thenReturn(true);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         InOrder inOrder = inOrder(mClientModeManager);
@@ -1347,9 +1382,9 @@ public class WifiLockManagerTest extends WifiBaseTest {
         inOrder.verify(mClientModeManager).setLowLatencyMode(false);
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
-                eq(new int[0]), eq(new String[0]), anyLong(), anyBoolean(),
-                anyBoolean(), anyBoolean());
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY), eq(new int[0]), eq(new String[0]),
+                anyLong(), anyBoolean(), anyBoolean(), anyBoolean());
     }
 
     /**
@@ -1361,7 +1396,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClientModeManager.setPowerSave(eq(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK),
                 anyBoolean())).thenReturn(true);
         setScreenState(false);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
 
@@ -1402,7 +1437,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         setScreenState(true);
         when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         InOrder inOrder = inOrder(mClientModeManager);
@@ -1435,8 +1470,9 @@ public class WifiLockManagerTest extends WifiBaseTest {
         inOrder.verify(mClientModeManager).setLowLatencyMode(false);
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
-                eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyLong(), anyBoolean(),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY), eq(new int[]{DEFAULT_TEST_UID_1}),
+                eq(new String[]{null}), anyLong(), anyBoolean(),
                 anyBoolean(), anyBoolean());
     }
 
@@ -1448,7 +1484,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
         when(mClientModeManager.setPowerSave(eq(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK),
                 anyBoolean())).thenReturn(true);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
 
@@ -1477,7 +1513,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
         when(mClientModeManager.setPowerSave(eq(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK),
                 anyBoolean())).thenReturn(true);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
         InOrder inOrder = inOrder(mClientModeManager);
@@ -1494,9 +1530,9 @@ public class WifiLockManagerTest extends WifiBaseTest {
 
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF),
-                eq(new int[0]), eq(new String[0]), anyLong(), anyBoolean(), anyBoolean(),
-                anyBoolean());
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_HIGH_PERF), eq(new int[0]), eq(new String[0]),
+                anyLong(), anyBoolean(), anyBoolean(), anyBoolean());
         inOrder.verify(mClientModeManager).setLowLatencyMode(true);
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 false);
@@ -1510,7 +1546,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
         when(mClientModeManager.setPowerSave(eq(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK),
                 anyBoolean())).thenReturn(true);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
 
@@ -1529,9 +1565,9 @@ public class WifiLockManagerTest extends WifiBaseTest {
         inOrder.verify(mClientModeManager).setLowLatencyMode(false);
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 true);
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
-                eq(new int[0]), eq(new String[0]), anyLong(), anyBoolean(), anyBoolean(),
-                anyBoolean());
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY), eq(new int[0]), eq(new String[0]),
+                anyLong(), anyBoolean(), anyBoolean(), anyBoolean());
         inOrder.verify(mClientModeManager).setPowerSave(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK,
                 false);
     }
@@ -1543,7 +1579,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
     public void testForceLowLatencyFailure() throws Exception {
         int expectedMode = WifiManager.WIFI_MODE_FULL_HIGH_PERF;
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(false);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         InOrder inOrder = inOrder(mClientModeManager);
@@ -1701,7 +1737,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
             setScreenState(true);
             when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                     ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-            when(mClientModeManager.getSupportedFeatures())
+            when(mClientModeManager.getSupportedFeaturesBitSet())
                     .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
             when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
             expectedMode = WifiManager.WIFI_MODE_FULL_LOW_LATENCY;
@@ -1720,8 +1756,8 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClock.getElapsedSinceBootMillis()).thenReturn(deactivationTime);
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, false);
 
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(expectedMode),
-                eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(expectedMode), eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}),
                 eq(deactivationTime - activationTime), eq(true), eq(false), eq(false));
 
 
@@ -1729,7 +1765,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClock.getElapsedSinceBootMillis()).thenReturn(releaseTime);
         releaseWifiLockSuccessful_noBatteryStats(mBinder);
 
-        verify(mWifiMetrics).addWifiLockAcqSession(eq(expectedMode),
+        verify(mWifiMetrics).addWifiLockManagerAcqSession(eq(expectedMode),
                 eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyInt(),
                 eq(releaseTime - acquireTime), eq(true), eq(false), eq(false));
     }
@@ -1754,7 +1790,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         setScreenState(true);
         when(mActivityManager.getUidImportance(anyInt())).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         InOrder inOrder = inOrder(mWifiMetrics);
@@ -1772,7 +1808,8 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClock.getElapsedSinceBootMillis()).thenReturn(deactivationTime);
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, false);
 
-        verify(mWifiMetrics).addWifiLockActiveSession(eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
+        verify(mWifiMetrics).addWifiLockManagerActiveSession(
+                eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
                 eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}),
                 eq(deactivationTime - activationTime), eq(true), eq(false), eq(false));
 
@@ -1780,7 +1817,8 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClock.getElapsedSinceBootMillis()).thenReturn(releaseTime);
         releaseWifiLockSuccessful_noBatteryStats(mBinder);
 
-        verify(mWifiMetrics).addWifiLockAcqSession(eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
+        verify(mWifiMetrics).addWifiLockManagerAcqSession(
+                eq(WifiManager.WIFI_MODE_FULL_LOW_LATENCY),
                 eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyInt(),
                 eq(releaseTime - acquireTime), eq(true), eq(false), eq(false));
 
@@ -1823,7 +1861,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         acquireWifiLockSuccessful(WifiManager.WIFI_MODE_FULL_HIGH_PERF, TEST_WIFI_LOCK_TAG,
                 mBinder, mWorkSource);
         releaseWifiLockSuccessful(mBinder);
-        verify(mWifiMetrics).addWifiLockAcqSession(eq(expectedMode),
+        verify(mWifiMetrics).addWifiLockManagerAcqSession(eq(expectedMode),
                 eq(new int[]{DEFAULT_TEST_UID_1}), eq(new String[]{null}), anyInt(), anyLong(),
                 anyBoolean(), anyBoolean(), anyBoolean());
         acquireWifiLockSuccessful(WifiManager.WIFI_MODE_FULL_HIGH_PERF, TEST_WIFI_LOCK_TAG,
@@ -1901,7 +1939,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
         when(mClientModeManager.setPowerSave(eq(ClientMode.POWER_SAVE_CLIENT_WIFI_LOCK),
                 anyBoolean())).thenReturn(false);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
 
         InOrder inOrder = inOrder(mClientModeManager);
@@ -1948,7 +1986,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mActivityManager.getUidImportance(DEFAULT_TEST_UID_1)).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         acquireWifiLockSuccessful(WifiManager.WIFI_MODE_FULL_LOW_LATENCY, "", mBinder, mWorkSource);
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
@@ -2041,7 +2079,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         BitSet supportedFeatures = new BitSet();
         supportedFeatures.set(WifiManager.WIFI_FEATURE_LOW_LATENCY, false);
         supportedFeatures.set(WifiManager.WIFI_FEATURE_DPP, true);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(supportedFeatures);
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(supportedFeatures);
 
         acquireWifiLockSuccessful(WifiManager.WIFI_MODE_FULL_LOW_LATENCY, "", mBinder, mWorkSource);
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
@@ -2066,7 +2104,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mActivityManager.getUidImportance(DEFAULT_TEST_UID_1)).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
 
@@ -2112,7 +2150,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mActivityManager.getUidImportance(DEFAULT_TEST_UID_1)).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
 
@@ -2160,7 +2198,7 @@ public class WifiLockManagerTest extends WifiBaseTest {
         when(mActivityManager.getUidImportance(DEFAULT_TEST_UID_1)).thenReturn(
                 ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND);
         when(mClientModeManager.setLowLatencyMode(anyBoolean())).thenReturn(true);
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WifiManager.WIFI_FEATURE_LOW_LATENCY));
         mWifiLockManager.updateWifiClientConnected(mClientModeManager, true);
 
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiMetricsTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiMetricsTest.java
index e317d31dbe..1e9c381554 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiMetricsTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiMetricsTest.java
@@ -77,6 +77,7 @@ import static org.junit.Assert.fail;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyInt;
+import static org.mockito.Mockito.anyLong;
 import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doThrow;
@@ -86,7 +87,6 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.mockito.Mockito.withSettings;
 
 import static java.lang.StrictMath.toIntExact;
 
@@ -164,11 +164,10 @@ import com.android.server.wifi.proto.nano.WifiMetricsProto.SoftApConnectedClient
 import com.android.server.wifi.proto.nano.WifiMetricsProto.StaEvent;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiIsUnusableEvent;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiRadioUsage;
-import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiUsabilityStats;
 import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiUsabilityStatsEntry;
+import com.android.server.wifi.proto.nano.WifiMetricsProto.WifiUsabilityStatsTraining;
 import com.android.server.wifi.rtt.RttMetrics;
 import com.android.server.wifi.util.InformationElementUtil;
-import com.android.wifi.flags.Flags;
 import com.android.wifi.resources.R;
 
 import org.junit.After;
@@ -186,6 +185,7 @@ import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.time.Duration;
+import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.BitSet;
@@ -219,7 +219,6 @@ public class WifiMetricsTest extends WifiBaseTest {
     private static final int TEST_CHANNEL = 36;
     private static final int POLLING_INTERVAL_DEFAULT = 3000;
     private static final int POLLING_INTERVAL_NOT_DEFAULT = 6000;
-
     private MockitoSession mSession;
     @Mock Context mContext;
     MockResources mResources;
@@ -321,7 +320,6 @@ public class WifiMetricsTest extends WifiBaseTest {
         mSession = ExtendedMockito.mockitoSession()
                 .strictness(Strictness.LENIENT)
                 .mockStatic(WifiStatsLog.class)
-                .mockStatic(Flags.class, withSettings().lenient())
                 .startMocking();
 
         when(mWifiInfo.getLinkSpeed()).thenReturn(10);
@@ -329,7 +327,6 @@ public class WifiMetricsTest extends WifiBaseTest {
         when(mWifiInfo.getFrequency()).thenReturn(5850);
         when(mWifiInfo.getBSSID()).thenReturn("5G_WiFi");
         when(mWifiInfo.getRssi()).thenReturn(-55);
-
     }
 
     @After
@@ -576,6 +573,7 @@ public class WifiMetricsTest extends WifiBaseTest {
     private static final int NUM_RADIO_MODE_CHANGE_TO_DBS = 34;
     private static final int NUM_SOFTAP_USER_BAND_PREFERENCE_UNSATISFIED = 14;
     private static final long NUM_WATCHDOG_SUCCESS_DURATION_MS = 65;
+    private static final long WIFI_CONNECTING_DURATION_MS = 1000;
     private static final long WIFI_POWER_METRICS_LOGGING_DURATION = 280;
     private static final long WIFI_POWER_METRICS_SCAN_TIME = 33;
     private static final boolean LINK_SPEED_COUNTS_LOGGING_SETTING = true;
@@ -2537,6 +2535,8 @@ public class WifiMetricsTest extends WifiBaseTest {
         mWifiMetrics.startConnectionEvent(TEST_IFACE_NAME, createComplexWifiConfig(),
                 "RED", WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE, false,
                 WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__ROLE__ROLE_CLIENT_PRIMARY, TEST_UID);
+        mWifiMetrics.reportConnectingDuration(TEST_IFACE_NAME,
+                WIFI_CONNECTING_DURATION_MS, WIFI_CONNECTING_DURATION_MS + 1);
         mWifiMetrics.endConnectionEvent(TEST_IFACE_NAME,
                 WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE,
                 WifiMetricsProto.ConnectionEvent.HLF_DHCP,
@@ -2555,7 +2555,8 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(true),
                 eq(false),
                 eq(1), eq(TEST_CONNECTION_FAILURE_STATUS_CODE), anyInt(), anyInt(), anyInt(),
-                anyInt(), anyInt(), eq(TEST_UID)));
+                anyInt(), anyInt(), eq(TEST_UID), eq(TEST_CANDIDATE_FREQ),
+                eq(WIFI_CONNECTING_DURATION_MS), eq(WIFI_CONNECTING_DURATION_MS + 1)));
     }
 
     /**
@@ -4236,11 +4237,11 @@ public class WifiMetricsTest extends WifiBaseTest {
     }
 
     private void assertUsabilityStatsAssignment(WifiInfo info, WifiLinkLayerStats stats,
-            WifiUsabilityStatsEntry usabilityStats) {
+            WifiUsabilityStatsEntry usabilityStats, int expectedTimestampMs) {
         assertEquals(info.getRssi(), usabilityStats.rssi);
         assertEquals(info.getLinkSpeed(), usabilityStats.linkSpeedMbps);
         assertEquals(info.getRxLinkSpeedMbps(), usabilityStats.rxLinkSpeedMbps);
-        assertEquals(stats.timeStampInMs, usabilityStats.timeStampMs);
+        assertEquals(expectedTimestampMs, usabilityStats.timeStampMs);
         assertEquals(stats.txmpdu_be + stats.txmpdu_bk + stats.txmpdu_vi + stats.txmpdu_vo,
                 usabilityStats.totalTxSuccess);
         assertEquals(stats.retries_be + stats.retries_bk + stats.retries_vi + stats.retries_vo,
@@ -4327,39 +4328,204 @@ public class WifiMetricsTest extends WifiBaseTest {
         }
     }
 
-    // Simulate adding a LABEL_GOOD WifiUsabilityStats
-    private WifiLinkLayerStats addGoodWifiUsabilityStats(WifiLinkLayerStats start) {
-        WifiInfo info = mock(WifiInfo.class);
-        when(info.getRssi()).thenReturn(nextRandInt());
-        when(info.getLinkSpeed()).thenReturn(nextRandInt());
-        WifiLinkLayerStats stats = start;
-        for (int i = 0; i < WifiMetrics.NUM_WIFI_USABILITY_STATS_ENTRIES_PER_WIFI_GOOD; i++) {
-            mWifiMetrics.updateWifiUsabilityStatsEntries(TEST_IFACE_NAME, info, stats, false, 0);
-            stats = nextRandomStats(stats);
+    /**
+     * When ring buffer is empty, verify that full-capture will capture empty results
+     */
+    @Test
+    public void testStoreCapturedDataEmptyRingbufferFullCapture() throws Exception {
+        Instant testCurrentInstant =
+                Instant.parse("2024-01-01T00:00:00Z").plus(Duration.ofSeconds(258));
+        when(mClock.getCurrentInstant()).thenReturn(testCurrentInstant);
+        when(mClock.getElapsedSinceBootMillis()).thenReturn((long) 10
+                * mWifiMetrics.MILLIS_IN_A_SECOND);
+        assertEquals(0, mWifiMetrics.mWifiUsabilityStatsEntriesRingBuffer.size());
+        mWifiMetrics.storeCapturedData(123, true, 2 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                        8 * mWifiMetrics.MILLIS_IN_A_SECOND);
+        dumpProtoAndDeserialize();
+        assertEquals(1, mDecodedProto.wifiUsabilityStatsTraining.length);
+        assertEquals(123, mDecodedProto.wifiUsabilityStatsTraining[0].dataCaptureType);
+        assertEquals(1704067200,
+                mDecodedProto.wifiUsabilityStatsTraining[0].captureStartTimestampSecs);
+        assertEquals(0, mDecodedProto.wifiUsabilityStatsTraining[0].trainingData.stats.length);
+        assertEquals(0, mDecodedProto.wifiUsabilityStatsTraining[0].storeTimeOffsetMs);
+    }
+
+    /**
+     * When ring buffer is empty, verify that non full-capture will capture empty results
+     */
+    @Test
+    public void testStoreCapturedDataEmptyRingbufferNonFullCapture() throws Exception {
+        Instant testCurrentInstant =
+                Instant.parse("2024-01-01T00:00:00Z").plus(Duration.ofSeconds(258));
+        when(mClock.getCurrentInstant()).thenReturn(testCurrentInstant);
+        when(mClock.getElapsedSinceBootMillis()).thenReturn((long) 258
+                * mWifiMetrics.MILLIS_IN_A_SECOND);
+        assertEquals(0, mWifiMetrics.mWifiUsabilityStatsEntriesRingBuffer.size());
+        mWifiMetrics.storeCapturedData(123, false, 2 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                        8 * mWifiMetrics.MILLIS_IN_A_SECOND);
+        dumpProtoAndDeserialize();
+        assertEquals(1, mDecodedProto.wifiUsabilityStatsTraining.length);
+        assertEquals(123, mDecodedProto.wifiUsabilityStatsTraining[0].dataCaptureType);
+        assertEquals(1704067200,
+                mDecodedProto.wifiUsabilityStatsTraining[0].captureStartTimestampSecs);
+        assertEquals(0, mDecodedProto.wifiUsabilityStatsTraining[0].trainingData.stats.length);
+        // 258 (current time) - 8 (triggerStopTimeMillis) = 250
+        assertEquals(250 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                mDecodedProto.wifiUsabilityStatsTraining[0].storeTimeOffsetMs);
+    }
+
+    private void ringBufferSetupForTestStoreCapturedData() {
+        // Starting from 20s, add a WifiUsabilityStatsEntry into ring buffer every 3s,
+        // the last timestamp is 20 + 3 * (80-1) = 257s
+        for (int i = 0; i < mWifiMetrics.MAX_WIFI_USABILITY_STATS_ENTRIES_RING_BUFFER_SIZE; ++i) {
+            WifiUsabilityStatsEntry entry = new WifiUsabilityStatsEntry();
+            entry.timeStampMs = (20 + i * 3) * mWifiMetrics.MILLIS_IN_A_SECOND;
+            mWifiMetrics.mWifiUsabilityStatsEntriesRingBuffer.add(entry);
+        }
+        assertEquals(80, mWifiMetrics.mWifiUsabilityStatsEntriesRingBuffer.size());
+        assertEquals(0, mWifiMetrics.mWifiUsabilityStatsTrainingExamples.size());
+        // Set current time since boot to 258s
+        when(mClock.getElapsedSinceBootMillis()).thenReturn((long) 258
+                * mWifiMetrics.MILLIS_IN_A_SECOND);
+        // Assume device boot up time is 2024-01-01, 00:00:00 UTC, unix timestamp in seconds
+        // is 1704067200
+        Instant testCurrentInstant =
+                Instant.parse("2024-01-01T00:00:00Z").plus(Duration.ofSeconds(258));
+        when(mClock.getCurrentInstant()).thenReturn(testCurrentInstant);
+    }
+
+    /**
+     * In non full-capture, verify:
+     * triggerStartTimeMillis has to be positive
+     */
+    @Test
+    public void testStoreCapturedDataNonFullCaptureStartTimePositive() throws Exception {
+        ringBufferSetupForTestStoreCapturedData();
+        mWifiMetrics.storeCapturedData(1, false, -1 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                20 * mWifiMetrics.MILLIS_IN_A_SECOND);
+        dumpProtoAndDeserialize();
+        assertEquals(0, mDecodedProto.wifiUsabilityStatsTraining.length);
+    }
+
+    /**
+     * In non full-capture, verify:
+     * triggerStopTimeMillis has to be positive
+     */
+    @Test
+    public void testStoreCapturedDataNonFullCaptureStopTimePositive() throws Exception {
+        ringBufferSetupForTestStoreCapturedData();
+        mWifiMetrics.storeCapturedData(1, false, 30 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                -1 * mWifiMetrics.MILLIS_IN_A_SECOND);
+        dumpProtoAndDeserialize();
+        assertEquals(0, mDecodedProto.wifiUsabilityStatsTraining.length);
+    }
+
+    /**
+     * In non full-capture, verify:
+     * triggerStartTimeMillis must be smaller than triggerStopTimeMillis
+     */
+    @Test
+    public void testStoreCapturedDataNonFullCaptureStartTimeEalierThanStopTime() throws Exception {
+        ringBufferSetupForTestStoreCapturedData();
+        mWifiMetrics.storeCapturedData(1, false, 30 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                20 * mWifiMetrics.MILLIS_IN_A_SECOND);
+        dumpProtoAndDeserialize();
+        assertEquals(0, mDecodedProto.wifiUsabilityStatsTraining.length);
+    }
+
+    /**
+     * In non full-capture, verify results
+     */
+    @Test
+    public void testStoreCapturedDataNonFullCapture() throws Exception {
+        ringBufferSetupForTestStoreCapturedData();
+        // Do a successful capture in [30s, 150s], and verify each field
+        mWifiMetrics.storeCapturedData(1, false, 30 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                150 * mWifiMetrics.MILLIS_IN_A_SECOND);
+        dumpProtoAndDeserialize();
+        assertEquals(1, mDecodedProto.wifiUsabilityStatsTraining.length);
+        WifiUsabilityStatsTraining result = mDecodedProto.wifiUsabilityStatsTraining[0];
+        assertEquals(1, result.dataCaptureType);
+        assertEquals(1704067200, result.captureStartTimestampSecs);
+        // 258 (current time) - 150 (triggerStopTimeMillis) = 108
+        assertEquals(108 * mWifiMetrics.MILLIS_IN_A_SECOND, result.storeTimeOffsetMs);
+        // Capture period is 150 - 30 = 120s, 120 / 3 = 40 WifiUsabilityStatsEntries
+        assertEquals(40, result.trainingData.stats.length);
+        for (int i = 0; i < 40; ++i) {
+            WifiUsabilityStatsEntry resultEntry = result.trainingData.stats[i];
+            assertEquals(0, resultEntry.timeStampMs);
+            // The timestamp of WifiUsabilityStatsEntries who are in captured result are:
+            // 32, 35, ... 149
+            assertEquals((2 + 3 * i) * mWifiMetrics.MILLIS_IN_A_SECOND,
+                    resultEntry.timestampOffsetMs);
         }
-        return stats;
     }
 
-    // Simulate adding a LABEL_BAD WifiUsabilityStats
-    private WifiLinkLayerStats addBadWifiUsabilityStats(WifiLinkLayerStats start) {
-        WifiInfo info = mock(WifiInfo.class);
-        when(info.getRssi()).thenReturn(nextRandInt());
-        when(info.getLinkSpeed()).thenReturn(nextRandInt());
-        WifiLinkLayerStats stats1 = start;
-        WifiLinkLayerStats stats2 = nextRandomStats(stats1);
-        mWifiMetrics.updateWifiUsabilityStatsEntries(TEST_IFACE_NAME, info, stats1, false, 0);
-        mWifiMetrics.updateWifiUsabilityStatsEntries(TEST_IFACE_NAME, info, stats2, false, 0);
-        mWifiMetrics.addToWifiUsabilityStatsList(TEST_IFACE_NAME, WifiUsabilityStats.LABEL_BAD,
-                WifiUsabilityStats.TYPE_DATA_STALL_BAD_TX, -1);
-        return nextRandomStats(stats2);
+    /**
+     * In full-capture, verify results
+     */
+    @Test
+    public void testStoreCapturedDataFullCapture() throws Exception {
+        ringBufferSetupForTestStoreCapturedData();
+        // Do a successful full-capture, and verify each field
+        mWifiMetrics.storeCapturedData(2, true, 30 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                150 * mWifiMetrics.MILLIS_IN_A_SECOND);
+        dumpProtoAndDeserialize();
+        assertEquals(1, mDecodedProto.wifiUsabilityStatsTraining.length);
+        WifiUsabilityStatsTraining result = mDecodedProto.wifiUsabilityStatsTraining[0];
+        assertEquals(2, result.dataCaptureType);
+        assertEquals(1704067200, result.captureStartTimestampSecs);
+        // 258 (current time) - 257 (triggerStopTimeMillis) = 1
+        assertEquals(1 * mWifiMetrics.MILLIS_IN_A_SECOND, result.storeTimeOffsetMs);
+        // Capture period is 257 - 20 = 237s, (237 / 3) + 1 = 80 WifiUsabilityStatsEntries
+        assertEquals(mWifiMetrics.MAX_WIFI_USABILITY_STATS_ENTRIES_RING_BUFFER_SIZE,
+                result.trainingData.stats.length);
+        for (int i = 0; i < mWifiMetrics.MAX_WIFI_USABILITY_STATS_ENTRIES_RING_BUFFER_SIZE; ++i) {
+            WifiUsabilityStatsEntry resultEntry = result.trainingData.stats[i];
+            assertEquals(0, resultEntry.timeStampMs);
+            // The timestamps of WifiUsabilityStatsEntries who are in captured result are:
+            // 20, 23, ... 257, offsets are 0, 3, ... 237
+            assertEquals((3 * i) * mWifiMetrics.MILLIS_IN_A_SECOND,
+                    resultEntry.timestampOffsetMs);
+        }
+    }
+
+    /**
+     * Verify wifiUsabilityStatsTraining size limit
+     */
+    @Test
+    public void testwifiUsabilityStatsTrainingSize() throws Exception {
+        ringBufferSetupForTestStoreCapturedData();
+        // Do MAX_WIFI_USABILITY_STATS_TRAINING_SIZE times successful data capture
+        for (int i = 0; i < WifiMetrics.MAX_WIFI_USABILITY_STATS_TRAINING_SIZE; ++i) {
+            mWifiMetrics.storeCapturedData(2, false, (30 + i * 3) * mWifiMetrics.MILLIS_IN_A_SECOND,
+                    (150 + i * 3) * mWifiMetrics.MILLIS_IN_A_SECOND);
+        }
+        assertEquals(WifiMetrics.MAX_WIFI_USABILITY_STATS_TRAINING_SIZE,
+                mWifiMetrics.mWifiUsabilityStatsTrainingExamples.size());
+        // 1st capture period is [30s, 150s), current time is 258s, storeTimeOffsetMs is 108s
+        assertEquals(108 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                mWifiMetrics.mWifiUsabilityStatsTrainingExamples.get(0).storeTimeOffsetMs);
+
+        // Do another successful data capture, the size should not grow
+        mWifiMetrics.storeCapturedData(2, false,
+                (30 + WifiMetrics.MAX_WIFI_USABILITY_STATS_TRAINING_SIZE)
+                * mWifiMetrics.MILLIS_IN_A_SECOND,
+                (150 + WifiMetrics.MAX_WIFI_USABILITY_STATS_TRAINING_SIZE)
+                * mWifiMetrics.MILLIS_IN_A_SECOND);
+        assertEquals(WifiMetrics.MAX_WIFI_USABILITY_STATS_TRAINING_SIZE,
+                mWifiMetrics.mWifiUsabilityStatsTrainingExamples.size());
+        // 1st capture period is [33s, 153s), current time is 258s, storeTimeOffsetMs is 105s
+        assertEquals(105 * mWifiMetrics.MILLIS_IN_A_SECOND,
+                mWifiMetrics.mWifiUsabilityStatsTrainingExamples.get(0).storeTimeOffsetMs);
+        dumpProtoAndDeserialize();
+        assertEquals(10, mDecodedProto.wifiUsabilityStatsTraining.length);
     }
 
     /**
      * Verify that updateWifiUsabilityStatsEntries correctly converts the inputs into
      * a WifiUsabilityStatsEntry Object and then stores it.
      *
-     * Verify that the converted metrics proto contains pairs of WifiUsabilityStats with
-     * LABEL_GOOD and LABEL_BAD
      * @throws Exception
      */
     @Test
@@ -4381,6 +4547,8 @@ public class WifiMetricsTest extends WifiBaseTest {
         mWifiMetrics.incrementWifiUsabilityScoreCount(TEST_IFACE_NAME, 2, 55, 15);
         mWifiMetrics.logLinkProbeSuccess(
                 TEST_IFACE_NAME, nextRandInt(), nextRandInt(), nextRandInt(), 12);
+        // This is used as the timestamp when the record lands in the ring buffer.
+        when(mClock.getElapsedSinceBootMillis()).thenReturn((long) 618);
         mWifiMetrics.updateWifiUsabilityStatsEntries(TEST_IFACE_NAME, info, stats1, false, 0);
         mWifiMetrics.incrementWifiScoreCount(TEST_IFACE_NAME, 58);
         mWifiMetrics.incrementWifiUsabilityScoreCount(TEST_IFACE_NAME, 3, 56, 15);
@@ -4388,11 +4556,34 @@ public class WifiMetricsTest extends WifiBaseTest {
                 nextRandInt(), nextRandInt());
         mWifiMetrics.enterDeviceMobilityState(DEVICE_MOBILITY_STATE_HIGH_MVMT);
 
+        // This is used as the timestamp when the record lands in the ring buffer.
+        when(mClock.getElapsedSinceBootMillis()).thenReturn((long) 1791);
         mWifiMetrics.updateWifiUsabilityStatsEntries(TEST_IFACE_NAME, info, stats2, false, 0);
         assertEquals(stats2.beacon_rx, mWifiMetrics.getTotalBeaconRxCount());
 
-        dumpProtoAndDeserialize();
-        // TODO (b/377723852) Add more verifications when new data capture is implemented
+        assertEquals(2, mWifiMetrics.mWifiUsabilityStatsEntriesRingBuffer.size());
+        WifiUsabilityStatsEntry result1 = mWifiMetrics.mWifiUsabilityStatsEntriesRingBuffer.get(0);
+        WifiUsabilityStatsEntry result2 = mWifiMetrics.mWifiUsabilityStatsEntriesRingBuffer.get(1);
+
+        assertUsabilityStatsAssignment(info, stats1, result1, 618);
+        assertUsabilityStatsAssignment(info, stats2, result2, 1791);
+        assertEquals(2, result1.seqNumToFramework);
+        assertEquals(3, result2.seqNumToFramework);
+        assertEquals(0, result1.seqNumInsideFramework);
+        assertEquals(1, result2.seqNumInsideFramework);
+        assertEquals(60, result1.wifiScore);
+        assertEquals(58, result2.wifiScore);
+        assertEquals(55, result1.wifiUsabilityScore);
+        assertEquals(56, result2.wifiUsabilityScore);
+        assertEquals(15, result1.predictionHorizonSec);
+        assertEquals(true, result1.isSameBssidAndFreq);
+        assertEquals(android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_SUCCESS,
+                result1.probeStatusSinceLastUpdate);
+        assertEquals(android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_FAILURE,
+                result2.probeStatusSinceLastUpdate);
+        assertEquals(12, result1.probeElapsedTimeSinceLastUpdateMs);
+        assertEquals(true, result1.isCellularDataAvailable);
+        assertEquals(false, result2.isThroughputSufficient);
     }
 
     private WifiLinkLayerStats createNewWifiLinkLayerStats() {
@@ -4429,30 +4620,6 @@ public class WifiMetricsTest extends WifiBaseTest {
         assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
     }
 
-    /**
-     * Verify that we discard a WifiUsabilityStats with LABEL_GOOD if there is no corresponding
-     * LABEL_BAD
-     * @throws Exception
-     */
-    @Test
-    public void testWifiUsabilityStatsIgnoreSingleLabelGood() throws Exception {
-        addGoodWifiUsabilityStats(new WifiLinkLayerStats());
-        dumpProtoAndDeserialize();
-        assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
-    }
-
-    /**
-     * Verify that we discard a WifiUsabilityStats with LABEL_BAD if there is no corresponding
-     * LABEL_GOOD
-     * @throws Exception
-     */
-    @Test
-    public void testWifiUsabilityStatsIgnoreSingleLabelBad() throws Exception {
-        addBadWifiUsabilityStats(new WifiLinkLayerStats());
-        dumpProtoAndDeserialize();
-        assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
-    }
-
     /**
      * Verify that records are properly added to mWifiUsabilityStatsEntriesRingBuffer and that the
      * size does not grow indefinitely.
@@ -4874,28 +5041,6 @@ public class WifiMetricsTest extends WifiBaseTest {
                 anyBoolean(), any());
     }
 
-    /**
-     * Verify that the label and the triggerType of Wifi usability stats are saved correctly
-     * during firmware alert is triggered.
-     * @throws Exception
-     */
-    @Test
-    public void verifyFirmwareAlertUpdatesWifiUsabilityMetrics() throws Exception {
-        WifiInfo info = mock(WifiInfo.class);
-        when(info.getRssi()).thenReturn(nextRandInt());
-        when(info.getLinkSpeed()).thenReturn(nextRandInt());
-        long eventTimeMs = nextRandInt();
-        when(mClock.getElapsedSinceBootMillis()).thenReturn(eventTimeMs);
-        WifiLinkLayerStats stats1 = nextRandomStats(new WifiLinkLayerStats());
-        mWifiMetrics.updateWifiUsabilityStatsEntries(TEST_IFACE_NAME, info, stats1, false, 0);
-
-        // Firmware alert occurs
-        mWifiMetrics.logFirmwareAlert(TEST_IFACE_NAME, 2);
-
-        dumpProtoAndDeserialize();
-        // TODO(b/377723852) Verify asynchronous events are logged correctly
-    }
-
     /**
      * Test the generation of 'WifiConfigStoreIODuration' read histograms.
      */
@@ -5385,7 +5530,7 @@ public class WifiMetricsTest extends WifiBaseTest {
      */
     @Test
     public void testWifiLockActiveSession() throws Exception {
-        mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+        mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 100000, true, false, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_DEACTIVATED, new int[]{TEST_UID},
@@ -5393,7 +5538,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_DEACTIVATED__MODE__WIFI_MODE_FULL_HIGH_PERF, 100000,
                         true, false, false));
 
-        mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+        mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 10000, true, true, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_DEACTIVATED, new int[]{TEST_UID},
@@ -5401,7 +5546,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_DEACTIVATED__MODE__WIFI_MODE_FULL_HIGH_PERF, 10000,
                         true, true, false));
 
-        mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+        mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 10000000, true, true, true);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_DEACTIVATED, new int[]{TEST_UID},
@@ -5409,7 +5554,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_DEACTIVATED__MODE__WIFI_MODE_FULL_HIGH_PERF,
                         10000000, true, true, true));
 
-        mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+        mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 1000, false, false, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_DEACTIVATED, new int[]{TEST_UID},
@@ -5417,7 +5562,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_DEACTIVATED__MODE__WIFI_MODE_FULL_HIGH_PERF, 1000,
                         false, false, false));
 
-        mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+        mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 90000, false, false, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_DEACTIVATED, new int[]{TEST_UID},
@@ -5425,7 +5570,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_DEACTIVATED__MODE__WIFI_MODE_FULL_LOW_LATENCY, 90000,
                         false, false, false));
 
-        mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+        mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 900000, true, false, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_DEACTIVATED, new int[]{TEST_UID},
@@ -5433,7 +5578,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_DEACTIVATED__MODE__WIFI_MODE_FULL_LOW_LATENCY,
                         900000, true, false, false));
 
-        mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+        mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 9000, true, true, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_DEACTIVATED, new int[]{TEST_UID},
@@ -5441,7 +5586,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_DEACTIVATED__MODE__WIFI_MODE_FULL_LOW_LATENCY, 9000,
                         true, true, false));
 
-        mWifiMetrics.addWifiLockActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+        mWifiMetrics.addWifiLockManagerActiveSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 20000000, true, true, true);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_DEACTIVATED, new int[]{TEST_UID},
@@ -5479,8 +5624,8 @@ public class WifiMetricsTest extends WifiBaseTest {
      * Test the WifiLock acquisition session statistics
      */
     @Test
-    public void testWifiLockAcqSession() throws Exception {
-        mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+    public void testWifiLockManagerAcqSession() throws Exception {
+        mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 0, 100000, false, false, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_RELEASED, new int[]{TEST_UID},
@@ -5488,7 +5633,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_RELEASED__MODE__WIFI_MODE_FULL_HIGH_PERF, 100000,
                         false, false, false));
 
-        mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+        mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 0, 10000, true, false, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_RELEASED, new int[]{TEST_UID},
@@ -5496,7 +5641,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_RELEASED__MODE__WIFI_MODE_FULL_HIGH_PERF, 10000,
                         true, false, false));
 
-        mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+        mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 0, 10000000, true, true, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_RELEASED, new int[]{TEST_UID},
@@ -5504,7 +5649,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_RELEASED__MODE__WIFI_MODE_FULL_HIGH_PERF, 10000000,
                         true, true, false));
 
-        mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
+        mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_HIGH_PERF,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 0, 1000, true, true, true);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_RELEASED, new int[]{TEST_UID},
@@ -5513,7 +5658,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         true, true, true));
 
 
-        mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+        mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 0, 90000, false, false, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_RELEASED, new int[]{TEST_UID},
@@ -5521,7 +5666,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_RELEASED__MODE__WIFI_MODE_FULL_LOW_LATENCY, 90000,
                         false, false, false));
 
-        mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+        mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 0, 900000, true, false, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_RELEASED, new int[]{TEST_UID},
@@ -5529,7 +5674,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_RELEASED__MODE__WIFI_MODE_FULL_LOW_LATENCY, 900000,
                         true, false, false));
 
-        mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+        mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 0, 9000, true, true, false);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_RELEASED, new int[]{TEST_UID},
@@ -5537,7 +5682,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                         WifiStatsLog.WIFI_LOCK_RELEASED__MODE__WIFI_MODE_FULL_LOW_LATENCY, 9000,
                         true, true, false));
 
-        mWifiMetrics.addWifiLockAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
+        mWifiMetrics.addWifiLockManagerAcqSession(WifiManager.WIFI_MODE_FULL_LOW_LATENCY,
                 new int[]{TEST_UID}, new String[]{TEST_TAG}, 0, 20000000, true, true, true);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_LOCK_RELEASED, new int[]{TEST_UID},
@@ -5568,96 +5713,6 @@ public class WifiMetricsTest extends WifiBaseTest {
                 mDecodedProto.wifiLockStats.lowLatencyLockAcqDurationSecHistogram);
     }
 
-    /**
-     * Verify that LABEL_GOOD stats are not generated if Wifi score breaches low and the checking
-     * time is less than MIN_SCORE_BREACH_TO_GOOD_STATS_WAIT_TIME_MS millis
-     * @throws Exception
-     */
-    @Test
-    public void testGoodStatsAreNotGeneratedByWifiScoreBreachLow() throws Exception {
-        // The elapsed time is shorter than necessary to add good stats
-        createTestForDataCollectionByScoreBreach(
-                WifiMetrics.MIN_SCORE_BREACH_TO_GOOD_STATS_WAIT_TIME_MS - 1,
-                false, true);
-        dumpProtoAndDeserialize();
-        assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
-    }
-
-    /**
-     * Verify that LABEL_GOOD stats are not generated if Wifi score breaches low and the checking
-     * time is greater than VALIDITY_PERIOD_OF_SCORE_BREACH_LOW_MS
-     * @throws Exception
-     */
-    @Test
-    public void testGoodStatsAreNotGeneratedIfWifiScoreBreachExpires() throws Exception {
-        // The Wifi score breaching expires for adding good stats
-        createTestForDataCollectionByScoreBreach(
-                WifiMetrics.VALIDITY_PERIOD_OF_SCORE_BREACH_LOW_MS + 1,
-                false, true);
-        dumpProtoAndDeserialize();
-        assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
-    }
-
-    /**
-     * Verify that LABEL_GOOD stats are not generated if Wifi score breaches low and there is
-     * WifiIsUnusableEvent occured within MIN_SCORE_BREACH_TO_GOOD_STATS_WAIT_TIME_MS millis
-     * @throws Exception
-     */
-    @Test
-    public void testGoodStatsAreNotGeneratedIfBadEventOccured() throws Exception {
-        // The elapsed time falls into the interval for adding good stats and bad event occurs
-        createTestForDataCollectionByScoreBreach(
-                WifiMetrics.MIN_SCORE_BREACH_TO_GOOD_STATS_WAIT_TIME_MS + 1,
-                true, true);
-        dumpProtoAndDeserialize();
-        assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
-    }
-
-    /**
-     * Verify that LABEL_GOOD stats are not generated if Wifi usability score breaches low and
-     * the checking time is less than MIN_SCORE_BREACH_TO_GOOD_STATS_WAIT_TIME_MS millis
-     * @throws Exception
-     */
-    @Test
-    public void testGoodStatsAreNotGeneratedByWifiUsabilityScoreBreachLow() throws Exception {
-        // The elapsed time is shorter than necessary to add good stats
-        createTestForDataCollectionByScoreBreach(
-                WifiMetrics.MIN_SCORE_BREACH_TO_GOOD_STATS_WAIT_TIME_MS - 1,
-                false, false);
-        dumpProtoAndDeserialize();
-        assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
-    }
-
-    /**
-     * Verify that LABEL_GOOD stats are not generated if Wifi usability score breaches low and
-     * the checking time is greater than VALIDITY_PERIOD_OF_SCORE_BREACH_LOW_MS
-     * @throws Exception
-     */
-    @Test
-    public void testGoodStatsAreNotGeneratedIfWifiUsabilityScoreBreachExpires() throws Exception {
-        // The Wifi usability score breaching expires for adding good stats
-        createTestForDataCollectionByScoreBreach(
-                WifiMetrics.VALIDITY_PERIOD_OF_SCORE_BREACH_LOW_MS + 1,
-                false, false);
-        dumpProtoAndDeserialize();
-        assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
-    }
-
-    /**
-     * Verify that LABEL_GOOD stats are not generated if Wifi usability score breaches low and there
-     * is WifiIsUnusableEvent occured within MIN_SCORE_BREACH_TO_GOOD_STATS_WAIT_TIME_MS millis
-     * @throws Exception
-     */
-    @Test
-    public void testGoodStatsAreNotGeneratedIfBadEventOccuredForUsabilityScore() throws Exception {
-        // The elapsed time falls into the interval for adding good stats and bad event occurs
-        createTestForDataCollectionByScoreBreach(
-                WifiMetrics.MIN_SCORE_BREACH_TO_GOOD_STATS_WAIT_TIME_MS + 1,
-                true, false);
-        dumpProtoAndDeserialize();
-        assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
-    }
-
     /**
      * Verify that incrementNumWifiToggles increments the corrects fields based on input.
      */
@@ -5741,42 +5796,6 @@ public class WifiMetricsTest extends WifiBaseTest {
         assertEquals(0, mDecodedProto.meteredNetworkStatsSuggestion.numOverrideUnmetered);
     }
 
-    /**
-     * Create a test to verify data collection logic triggered by score breaching low
-     * @param elapsedTimeAfterBreach The elapsed time after score breaches low
-     * @param isThereBadEvent Whether there is a bad event happened after score breaches low
-     * @param isWifiScore Whether it is Wifi score or not that breaches the threshold
-     */
-    private void createTestForDataCollectionByScoreBreach(
-            long elapsedTimeAfterBreach, boolean isThereBadEvent, boolean isWifiScore) {
-        WifiInfo info = mock(WifiInfo.class);
-        when(info.getRssi()).thenReturn(nextRandInt());
-        when(info.getLinkSpeed()).thenReturn(nextRandInt());
-        WifiLinkLayerStats stats2 = new WifiLinkLayerStats();
-        mWifiMetrics.setWifiState(TEST_IFACE_NAME, WifiMetricsProto.WifiLog.WIFI_ASSOCIATED);
-
-        addOneBadWifiUsabilityStats(info);
-        if (isWifiScore) {
-            stats2 = wifiScoreBreachesLow(info, stats2);
-        } else {
-            stats2 = wifiUsabilityScoreBreachesLow(info, stats2);
-        }
-        if (isThereBadEvent) {
-            mWifiMetrics.logWifiIsUnusableEvent(TEST_IFACE_NAME,
-                    WifiIsUnusableEvent.TYPE_DATA_STALL_BAD_TX, -1);
-        }
-        when(mClock.getElapsedSinceBootMillis()).thenReturn(elapsedTimeAfterBreach);
-        mWifiMetrics.updateWifiUsabilityStatsEntries(TEST_IFACE_NAME, info, stats2, false, 0);
-    }
-
-    // Simulate adding one LABEL_BAD WifiUsabilityStats
-    private void addOneBadWifiUsabilityStats(WifiInfo info) {
-        WifiLinkLayerStats stats1 = new WifiLinkLayerStats();
-        mWifiMetrics.updateWifiUsabilityStatsEntries(TEST_IFACE_NAME, info, stats1, false, 0);
-        mWifiMetrics.addToWifiUsabilityStatsList(TEST_IFACE_NAME, WifiUsabilityStats.LABEL_BAD,
-                WifiUsabilityStats.TYPE_DATA_STALL_BAD_TX, -1);
-    }
-
     // Simulate that Wifi score breaches low
     private WifiLinkLayerStats wifiScoreBreachesLow(WifiInfo info, WifiLinkLayerStats stats2) {
         int upper = WifiMetrics.LOW_WIFI_SCORE + 7;
@@ -5838,34 +5857,6 @@ public class WifiMetricsTest extends WifiBaseTest {
         }
     }
 
-    /**
-     * Verify that the LABEL_BAD Wifi usability stats are not saved if screen state is off.
-     * @throws Exception
-     */
-    @Test
-    public void verifyLabelBadStatsAreNotSavedIfScreenIsOff() throws Exception {
-        setScreenState(false);
-        WifiInfo info = mock(WifiInfo.class);
-        when(info.getRssi()).thenReturn(nextRandInt());
-        when(info.getLinkSpeed()).thenReturn(nextRandInt());
-        WifiLinkLayerStats stats1 = nextRandomStats(new WifiLinkLayerStats());
-        mWifiMetrics.updateWifiUsabilityStatsEntries(TEST_IFACE_NAME, info, stats1, false, 0);
-
-        // Add 1 LABEL_GOOD
-        WifiLinkLayerStats statsGood = addGoodWifiUsabilityStats(nextRandomStats(stats1));
-        // IP reachability lost occurs
-        mWifiMetrics.addToWifiUsabilityStatsList(TEST_IFACE_NAME, WifiUsabilityStats.LABEL_BAD,
-                WifiUsabilityStats.TYPE_IP_REACHABILITY_LOST, -1);
-        // Wifi data stall occurs
-        mWifiMetrics.addToWifiUsabilityStatsList(TEST_IFACE_NAME, WifiUsabilityStats.LABEL_BAD,
-                WifiIsUnusableEvent.TYPE_DATA_STALL_BAD_TX, -1);
-        // Firmware alert occurs
-        mWifiMetrics.logFirmwareAlert(TEST_IFACE_NAME, 2);
-
-        dumpProtoAndDeserialize();
-        assertEquals(0, mDecodedProto.wifiUsabilityStatsList.length);
-    }
-
     /**
      * Test the logging of connection duration stats
      */
@@ -5874,16 +5865,16 @@ public class WifiMetricsTest extends WifiBaseTest {
         for (int i = 0; i < 2; i++) {
             mWifiMetrics.incrementWifiScoreCount(TEST_IFACE_NAME, 52);
             mWifiMetrics.incrementConnectionDuration(TEST_IFACE_NAME, 5000, false, true, -50, 10000,
-                    10000);
+                    10000, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
             mWifiMetrics.incrementWifiScoreCount(TEST_IFACE_NAME, 40);
             mWifiMetrics.incrementConnectionDuration(TEST_IFACE_NAME, 5000, false, true, -50, 10000,
-                    10000);
+                    10000, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
             mWifiMetrics.incrementConnectionDuration(TEST_IFACE_NAME, 3000, true, true, -50, 10000,
-                    10000);
+                    10000, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
             mWifiMetrics.incrementConnectionDuration(TEST_IFACE_NAME, 1000, false, false, -50,
-                    10000, 10000);
+                    10000, 10000, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
             mWifiMetrics.incrementConnectionDuration(TEST_IFACE_NAME, 500, true, false, -50, 10000,
-                    10000);
+                    10000, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
         }
         dumpProtoAndDeserialize();
 
@@ -6270,7 +6261,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED), anyBoolean(), anyInt(), anyInt(),
                 anyInt(), anyInt(), anyInt(), anyInt(), anyBoolean(), anyInt(), anyBoolean(),
                 anyBoolean(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(),
-                eq(TEST_UID)),
+                eq(TEST_UID), anyInt(), anyLong(), anyLong()),
                 times(0));
     }
 
@@ -6286,22 +6277,26 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED), anyBoolean(), anyInt(), anyInt(),
                 anyInt(), anyInt(), anyInt(), anyInt(), anyBoolean(), anyInt(), anyBoolean(),
                 anyBoolean(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(),
-                eq(TEST_UID)),
+                eq(TEST_UID), eq(TEST_CANDIDATE_FREQ), anyLong(), anyLong()),
                 times(0));
     }
 
     @Test
     public void testWifiConnectionResultAtomEmittedOnlyOnceWithMultipleConnectionEndEvents() {
+        long connectingDuration = WIFI_CONNECTING_DURATION_MS;
         mWifiMetrics.startConnectionEvent(TEST_IFACE_NAME, createComplexWifiConfig(),
                 "RED", WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE, false,
                 WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__ROLE__ROLE_CLIENT_PRIMARY, TEST_UID);
 
         for (int i = 0; i < 5; i++) {
+            mWifiMetrics.reportConnectingDuration(TEST_IFACE_NAME,
+                    connectingDuration, connectingDuration);
             mWifiMetrics.endConnectionEvent(TEST_IFACE_NAME,
                     WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE,
                     WifiMetricsProto.ConnectionEvent.HLF_DHCP,
                     WifiMetricsProto.ConnectionEvent.FAILURE_REASON_UNKNOWN, TEST_CANDIDATE_FREQ,
                     TEST_CONNECTION_FAILURE_STATUS_CODE);
+            connectingDuration++;
         }
 
         ExtendedMockito.verify(() -> WifiStatsLog.write(
@@ -6313,7 +6308,9 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__TRIGGER__AUTOCONNECT_BOOT),
                 eq(true),
                 eq(0), eq(true), eq(false), eq(1), eq(TEST_CONNECTION_FAILURE_STATUS_CODE),
-                anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), eq(TEST_UID)),
+                anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), eq(TEST_UID),
+                eq(TEST_CANDIDATE_FREQ),
+                eq(WIFI_CONNECTING_DURATION_MS), eq(WIFI_CONNECTING_DURATION_MS)),
                 times(1));
     }
 
@@ -6349,7 +6346,8 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__TRIGGER__AUTOCONNECT_BOOT),
                 eq(true),
                 eq(0),  eq(true), eq(true), eq(1), eq(TEST_CONNECTION_FAILURE_STATUS_CODE),
-                anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), eq(TEST_UID)),
+                anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), eq(TEST_UID),
+                eq(TEST_CANDIDATE_FREQ), anyLong(), anyLong()),
                 times(1));
     }
 
@@ -6373,7 +6371,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__TRIGGER__AUTOCONNECT_BOOT),
                 anyBoolean(), anyInt(), anyBoolean(), anyBoolean(), anyInt(),
                 eq(TEST_CONNECTION_FAILURE_STATUS_CODE), anyInt(), anyInt(), anyInt(), anyInt(),
-                anyInt(), eq(TEST_UID)));
+                anyInt(), eq(TEST_UID), eq(TEST_CANDIDATE_FREQ), anyLong(), anyLong()));
 
         mWifiMetrics.startConnectionEvent(TEST_IFACE_NAME, createComplexWifiConfig(),
                 "RED", WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE, false,
@@ -6393,7 +6391,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__TRIGGER__RECONNECT_SAME_NETWORK),
                 anyBoolean(), anyInt(), anyBoolean(), anyBoolean(), anyInt(),
                 eq(TEST_CONNECTION_FAILURE_STATUS_CODE), anyInt(), anyInt(), anyInt(), anyInt(),
-                anyInt(), eq(TEST_UID)));
+                anyInt(), eq(TEST_UID), eq(TEST_CANDIDATE_FREQ), anyLong(), anyLong()));
 
         WifiConfiguration configOtherNetwork = createComplexWifiConfig();
         configOtherNetwork.networkId = 21;
@@ -6419,7 +6417,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__TRIGGER__AUTOCONNECT_CONFIGURED_NETWORK),
                 anyBoolean(), anyInt(), anyBoolean(), anyBoolean(), anyInt(),
                 eq(TEST_CONNECTION_FAILURE_STATUS_CODE), anyInt(), anyInt(), anyInt(), anyInt(),
-                anyInt(), eq(TEST_UID)));
+                anyInt(), eq(TEST_UID), eq(TEST_CANDIDATE_FREQ), anyLong(), anyLong()));
 
         WifiConfiguration config = createComplexWifiConfig();
         config.networkId = 42;
@@ -6442,7 +6440,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__TRIGGER__MANUAL),
                 anyBoolean(), anyInt(), anyBoolean(), anyBoolean(), anyInt(),
                 eq(TEST_CONNECTION_FAILURE_STATUS_CODE), anyInt(), anyInt(), anyInt(), anyInt(),
-                anyInt(), eq(TEST_UID)));
+                anyInt(), eq(TEST_UID), eq(TEST_CANDIDATE_FREQ), anyLong(), anyLong()));
     }
 
     @Test
@@ -6603,7 +6601,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__TRIGGER__AUTOCONNECT_BOOT),
                 anyBoolean(), eq(10), anyBoolean(), anyBoolean(), anyInt(),
                 eq(TEST_CONNECTION_FAILURE_STATUS_CODE), anyInt(), anyInt(), anyInt(), anyInt(),
-                anyInt(), eq(TEST_UID)));
+                anyInt(), eq(TEST_UID), eq(TEST_CANDIDATE_FREQ), anyLong(), anyLong()));
 
         mWifiMetrics.reportNetworkDisconnect(TEST_IFACE_NAME, 0, 0, 0, 0);
 
@@ -6625,7 +6623,7 @@ public class WifiMetricsTest extends WifiBaseTest {
                 eq(WifiStatsLog.WIFI_CONNECTION_RESULT_REPORTED__TRIGGER__RECONNECT_SAME_NETWORK),
                 anyBoolean(), eq(20), anyBoolean(), anyBoolean(), anyInt(),
                 eq(TEST_CONNECTION_FAILURE_STATUS_CODE), anyInt(), anyInt(), anyInt(), anyInt(),
-                anyInt(), eq(TEST_UID)));
+                anyInt(), eq(TEST_UID), eq(TEST_CANDIDATE_FREQ), anyLong(), anyLong()));
 
         mWifiMetrics.reportNetworkDisconnect(TEST_IFACE_NAME, 0, 0, 0, 0);
     }
@@ -6892,13 +6890,15 @@ public class WifiMetricsTest extends WifiBaseTest {
         mWifiMetrics.incrementWifiScoreCount("",  60);
         mWifiMetrics.handlePollResult(TEST_IFACE_NAME, wifiInfo);
         mWifiMetrics.incrementConnectionDuration(TEST_IFACE_NAME, 3000, true, true, -50, 10002,
-                10001);
+                10001, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
         ExtendedMockito.verify(() -> WifiStatsLog.write(
                 WifiStatsLog.WIFI_HEALTH_STAT_REPORTED, 3000, true, true,
                 WifiStatsLog.WIFI_HEALTH_STAT_REPORTED__BAND__BAND_5G_HIGH, -50, 10002, 10001,
                 Process.WIFI_UID,
                 false,
-                WIFI_IS_UNUSABLE_REPORTED__WIFI_PREDICTED_USABILITY_STATE__WIFI_USABILITY_PREDICTED_UNKNOWN));
+                WIFI_IS_UNUSABLE_REPORTED__WIFI_PREDICTED_USABILITY_STATE__WIFI_USABILITY_PREDICTED_UNKNOWN,
+                10, 10,
+                WifiStatsLog.WIFI_AP_CAPABILITIES_REPORTED__CHANNEL_WIDTH_MHZ__CHANNEL_WIDTH_80MHZ));
 
         when(wifiInfo.getFrequency()).thenReturn(2412);
         mWifiMetrics.setIsExternalWifiScorerOn(true, TEST_UID);
@@ -6907,12 +6907,14 @@ public class WifiMetricsTest extends WifiBaseTest {
         mWifiMetrics.incrementWifiScoreCount("",  30);
         mWifiMetrics.handlePollResult(TEST_IFACE_NAME, wifiInfo);
         mWifiMetrics.incrementConnectionDuration(TEST_IFACE_NAME, 2000, false, true, -55, 20002,
-                20001);
+                20001, 10, 10, ScanResult.CHANNEL_WIDTH_80MHZ);
         ExtendedMockito.verify(
                 () -> WifiStatsLog.write(WifiStatsLog.WIFI_HEALTH_STAT_REPORTED, 2000, true, true,
                         WifiStatsLog.WIFI_HEALTH_STAT_REPORTED__BAND__BAND_2G, -55, 20002, 20001,
                         TEST_UID, true,
-                        WIFI_IS_UNUSABLE_REPORTED__WIFI_PREDICTED_USABILITY_STATE__WIFI_USABILITY_PREDICTED_USABLE));
+                        WIFI_IS_UNUSABLE_REPORTED__WIFI_PREDICTED_USABILITY_STATE__WIFI_USABILITY_PREDICTED_USABLE,
+                        10,  10,
+                        WifiStatsLog.WIFI_AP_CAPABILITIES_REPORTED__CHANNEL_WIDTH_MHZ__CHANNEL_WIDTH_80MHZ));
     }
 
     /**
@@ -7647,13 +7649,4 @@ public class WifiMetricsTest extends WifiBaseTest {
         mWifiMetrics.resetWifiUnusableEvent();
         assertEquals(WifiIsUnusableEvent.TYPE_UNKNOWN, mWifiMetrics.mUnusableEventType);
     }
-
-    /** Verifies WiFi Scorer new stats collection flag could be set properly */
-    @Test
-    public void verifyWifiScorerNewStatsCollectionFlagTrue() {
-        when(Flags.wifiScorerNewStatsCollection()).thenReturn(true);
-        assertEquals(mWifiMetrics.isWiFiScorerNewStatsCollected(), true);
-        when(Flags.wifiScorerNewStatsCollection()).thenReturn(false);
-        assertEquals(mWifiMetrics.isWiFiScorerNewStatsCollected(), false);
-    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiMulticastLockManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiMulticastLockManagerTest.java
index f57f8c43b1..8ce4a8d191 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiMulticastLockManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiMulticastLockManagerTest.java
@@ -34,6 +34,7 @@ import androidx.test.filters.SmallTest;
 
 import com.android.server.wifi.ActiveModeWarden.PrimaryClientModeManagerChangedCallback;
 import com.android.server.wifi.WifiMulticastLockManager.FilterController;
+import com.android.server.wifi.util.WifiPermissionsUtil;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -52,6 +53,9 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
     private static final String WL_1_TAG = "Wakelock-1";
     private static final String WL_2_TAG = "Wakelock-2";
     private static final int TEST_UID = 123;
+    private static final String TEST_ATTRIBUTION_TAG = "attribution-tag";
+    private static final String TEST_PACKAGE_NAME = "package-name";
+    private static final long START_TIME = 0;
 
     private TestLooper mLooper;
     @Mock ConcreteClientModeManager mClientModeManager;
@@ -62,6 +66,9 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
     @Mock ActiveModeWarden mActiveModeWarden;
     @Mock Context mContext;
     @Mock ActivityManager mActivityManager;
+    @Mock Clock mClock;
+    @Mock WifiMetrics mWifiMetrics;
+    @Mock WifiPermissionsUtil mWifiPermissionsUtil;
     @Captor ArgumentCaptor<PrimaryClientModeManagerChangedCallback> mPrimaryChangedCallbackCaptor;
     @Captor ArgumentCaptor<ActivityManager.OnUidImportanceListener> mUidImportanceListenerCaptor =
             ArgumentCaptor.forClass(ActivityManager.OnUidImportanceListener.class);
@@ -86,7 +93,7 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mClientModeManager);
         when(mContext.getSystemService(ActivityManager.class)).thenReturn(mActivityManager);
         mManager = new WifiMulticastLockManager(mActiveModeWarden, mBatteryStats,
-                mLooper.getLooper(), mContext);
+                mLooper.getLooper(), mContext, mClock, mWifiMetrics, mWifiPermissionsUtil);
 
         verify(mActiveModeWarden).registerPrimaryClientModeManagerChangedCallback(
                 mPrimaryChangedCallbackCaptor.capture());
@@ -110,7 +117,7 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
     @Test
     public void oneLock() throws RemoteException {
         IBinder binder = mock(IBinder.class);
-        mManager.acquireLock(TEST_UID, binder, WL_1_TAG);
+        mManager.acquireLock(TEST_UID, binder, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
         assertTrue(mManager.isMulticastEnabled());
         verify(mFilterController).stopFilteringMulticastPackets();
         mManager.startFilteringMulticastPackets();
@@ -160,7 +167,7 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
         assertTrue(mFilterController2.isFilteringStarted());
 
         IBinder binder = mock(IBinder.class);
-        mManager.acquireLock(TEST_UID, binder, WL_1_TAG);
+        mManager.acquireLock(TEST_UID, binder, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
         assertTrue(mManager.isMulticastEnabled());
         // CMM1 filtering stopped
         assertFalse(mFilterController.isFilteringStarted());
@@ -195,7 +202,7 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
     @Test
     public void oneLock_wrongName() throws RemoteException {
         IBinder binder = mock(IBinder.class);
-        mManager.acquireLock(TEST_UID, binder, WL_1_TAG);
+        mManager.acquireLock(TEST_UID, binder, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
         assertTrue(mManager.isMulticastEnabled());
         verify(mFilterController).stopFilteringMulticastPackets();
         mManager.startFilteringMulticastPackets();
@@ -218,12 +225,12 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
         InOrder inOrderHandler = inOrder(mFilterController);
         InOrder inOrderBatteryStats = inOrder(mBatteryStats);
 
-        mManager.acquireLock(TEST_UID, binder, WL_1_TAG);
+        mManager.acquireLock(TEST_UID, binder, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
         inOrderHandler.verify(mFilterController).stopFilteringMulticastPackets();
         inOrderBatteryStats.verify(mBatteryStats).reportWifiMulticastEnabled(any());
         assertTrue(mManager.isMulticastEnabled());
 
-        mManager.acquireLock(TEST_UID, binder, WL_2_TAG);
+        mManager.acquireLock(TEST_UID, binder, WL_2_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
         inOrderHandler.verify(mFilterController).stopFilteringMulticastPackets();
         inOrderBatteryStats.verify(mBatteryStats).reportWifiMulticastEnabled(any());
         assertTrue(mManager.isMulticastEnabled());
@@ -252,12 +259,12 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
         InOrder inOrderHandler = inOrder(mFilterController);
         InOrder inOrderBatteryStats = inOrder(mBatteryStats);
 
-        mManager.acquireLock(TEST_UID, binder, WL_1_TAG);
+        mManager.acquireLock(TEST_UID, binder, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
         inOrderHandler.verify(mFilterController).stopFilteringMulticastPackets();
         inOrderBatteryStats.verify(mBatteryStats).reportWifiMulticastEnabled(any());
         assertTrue(mManager.isMulticastEnabled());
 
-        mManager.acquireLock(TEST_UID, binder, WL_2_TAG);
+        mManager.acquireLock(TEST_UID, binder, WL_2_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
         inOrderHandler.verify(mFilterController).stopFilteringMulticastPackets();
         inOrderBatteryStats.verify(mBatteryStats).reportWifiMulticastEnabled(any());
         assertTrue(mManager.isMulticastEnabled());
@@ -288,8 +295,8 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
         IBinder binder2 = mock(IBinder.class);
 
         // Both acquired locks have the same tag
-        mManager.acquireLock(TEST_UID, binder1, WL_1_TAG);
-        mManager.acquireLock(TEST_UID, binder2, WL_1_TAG);
+        mManager.acquireLock(TEST_UID, binder1, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
+        mManager.acquireLock(TEST_UID, binder2, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
         assertTrue(mManager.isMulticastEnabled());
 
         mManager.releaseLock(TEST_UID, binder1, WL_1_TAG);
@@ -308,7 +315,7 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
     @Test
     public void testSingleLockActiveStateChange() {
         IBinder binder = mock(IBinder.class);
-        mManager.acquireLock(TEST_UID, binder, WL_1_TAG);
+        mManager.acquireLock(TEST_UID, binder, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
         assertTrue(mManager.isMulticastEnabled());
         verify(mFilterController).stopFilteringMulticastPackets();
 
@@ -339,11 +346,15 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
     public void testMultipleOwnersActiveStateChange() {
         int uid1 = TEST_UID;
         int uid2 = TEST_UID + 1;
+        String attributionTag1 = "attribution-tag-1";
+        String attributionTag2 = "attribution-tag-2";
+        String packageName1 = "package-name-1";
+        String packageName2 = "package-name-2";
         IBinder binder1 = mock(IBinder.class);
         IBinder binder2 = mock(IBinder.class);
 
-        mManager.acquireLock(uid1, binder1, WL_1_TAG);
-        mManager.acquireLock(uid2, binder2, WL_2_TAG);
+        mManager.acquireLock(uid1, binder1, WL_1_TAG, attributionTag1, packageName1);
+        mManager.acquireLock(uid2, binder2, WL_2_TAG, attributionTag2, packageName2);
         assertTrue(mManager.isMulticastEnabled());
         verify(mFilterController, times(2)).stopFilteringMulticastPackets();
 
@@ -379,4 +390,86 @@ public class WifiMulticastLockManagerTest extends WifiBaseTest {
         assertFalse(mManager.isMulticastEnabled());
         verify(mFilterController, times(2)).startFilteringMulticastPackets();
     }
+
+    /**
+     * Verify that an acquire session is logged in the metrics when a lock is released.
+     */
+    @Test
+    public void testAcquireSessionMetrics() {
+        IBinder binder = mock(IBinder.class);
+        when(mClock.getElapsedSinceBootMillis()).thenReturn(START_TIME);
+        mManager.acquireLock(TEST_UID, binder, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
+
+        // Advance clock by 10 ms and release the lock
+        when(mClock.getElapsedSinceBootMillis()).thenReturn(START_TIME + 10);
+        mManager.releaseLock(TEST_UID, binder, WL_1_TAG);
+        verify(mWifiMetrics).addMulticastLockManagerAcqSession(
+                eq(TEST_UID), eq(TEST_ATTRIBUTION_TAG), anyInt(), eq(10L) /* duration */);
+    }
+
+    /**
+     * Verify that an active session is logged when multicast filtering is re-enabled,
+     * and that an acquire session is logged when a multicast lock is released.
+     */
+    @Test
+    public void testSingleLockActiveSessionMetrics() {
+        IBinder binder = mock(IBinder.class);
+        when(mClock.getElapsedSinceBootMillis()).thenReturn(START_TIME);
+        mManager.acquireLock(TEST_UID, binder, WL_1_TAG, TEST_ATTRIBUTION_TAG, TEST_PACKAGE_NAME);
+
+        // Transition the UID to low importance at t=10
+        // Since this is the only lock, this should re-enable packet filtering
+        when(mClock.getElapsedSinceBootMillis()).thenReturn(START_TIME + 10);
+        mUidImportanceListenerCaptor.getValue().onUidImportance(
+                TEST_UID, ActivityManager.RunningAppProcessInfo.IMPORTANCE_CACHED);
+        mLooper.dispatchAll();
+
+        // Release the lock at t=20
+        when(mClock.getElapsedSinceBootMillis()).thenReturn(START_TIME + 20);
+        mManager.releaseLock(TEST_UID, binder, WL_1_TAG);
+
+        // Verify that the active session was logged during the priority switch (t=10)
+        // and that the lock acquire session was logged during the lock release (t=20)
+        verify(mWifiMetrics).addMulticastLockManagerActiveSession(eq(10L));
+        verify(mWifiMetrics).addMulticastLockManagerAcqSession(
+                eq(TEST_UID), eq(TEST_ATTRIBUTION_TAG), anyInt(), eq(20L));
+    }
+
+    /**
+     * See comment for {@link #testSingleLockActiveSessionMetrics()}.
+     * This case considers a multi-lock scenario.
+     */
+    @Test
+    public void testMultiLockActiveSessionMetrics() {
+        int uid1 = TEST_UID;
+        int uid2 = TEST_UID + 1;
+        String attributionTag1 = "attribution-tag-1";
+        String attributionTag2 = "attribution-tag-2";
+        String packageName1 = "package-name-1";
+        String packageName2 = "package-name-2";
+        IBinder binder1 = mock(IBinder.class);
+        IBinder binder2 = mock(IBinder.class);
+
+        when(mClock.getElapsedSinceBootMillis()).thenReturn(START_TIME);
+        mManager.acquireLock(uid1, binder1, WL_1_TAG, attributionTag1, packageName1);
+        mManager.acquireLock(uid2, binder2, WL_2_TAG, attributionTag2, packageName2);
+
+        // Release lock 1 at t=10. Multicast filtering is still disabled.
+        when(mClock.getElapsedSinceBootMillis()).thenReturn(START_TIME + 10);
+        mManager.releaseLock(uid1, binder1, WL_1_TAG);
+
+        // Release lock 2 at t=20. Multicast filtering should be re-enabled.
+        when(mClock.getElapsedSinceBootMillis()).thenReturn(START_TIME + 20);
+        mManager.releaseLock(uid2, binder2, WL_2_TAG);
+
+        // An acquire session should have been logged when each lock was released
+        verify(mWifiMetrics).addMulticastLockManagerAcqSession(
+                eq(uid1), eq(attributionTag1), anyInt(), eq(10L));
+        verify(mWifiMetrics).addMulticastLockManagerAcqSession(
+                eq(uid2), eq(attributionTag2), anyInt(), eq(20L));
+
+        // A single active session should have been logged when the final lock was released (t=20)
+        verify(mWifiMetrics, times(1)).addMulticastLockManagerActiveSession(anyLong());
+        verify(mWifiMetrics).addMulticastLockManagerActiveSession(eq(20L));
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiNativeInterfaceManagementTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiNativeInterfaceManagementTest.java
index 6b1de984ab..97838f8000 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiNativeInterfaceManagementTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiNativeInterfaceManagementTest.java
@@ -61,6 +61,7 @@ import com.android.server.wifi.HalDeviceManager.InterfaceDestroyedListener;
 import com.android.server.wifi.WifiNative.SupplicantDeathEventHandler;
 import com.android.server.wifi.WifiNative.VendorHalDeathEventHandler;
 import com.android.server.wifi.hal.WifiNanIface;
+import com.android.server.wifi.mainline_supplicant.MainlineSupplicant;
 import com.android.server.wifi.p2p.WifiP2pNative;
 import com.android.server.wifi.util.NetdWrapper;
 import com.android.server.wifi.util.NetdWrapper.NetdEventObserver;
@@ -75,6 +76,8 @@ import org.mockito.InOrder;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 
 import java.util.ArrayList;
 import java.util.BitSet;
@@ -109,6 +112,7 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
     @Mock private WifiVendorHal mWifiVendorHal;
     @Mock private WifiNl80211Manager mWificondControl;
     @Mock private SupplicantStaIfaceHal mSupplicantStaIfaceHal;
+    @Mock private MainlineSupplicant mMainlineSupplicant;
     @Mock private HostapdHal mHostapdHal;
     @Mock private WifiMonitor mWifiMonitor;
     @Mock private NetdWrapper mNetdWrapper;
@@ -148,6 +152,8 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
             ArgumentCaptor.forClass(WifiNative.VendorHalRadioModeChangeEventHandler.class);
     private ArgumentCaptor<SupplicantDeathEventHandler> mSupplicantDeathHandlerCaptor =
             ArgumentCaptor.forClass(SupplicantDeathEventHandler.class);
+    private ArgumentCaptor<SupplicantDeathEventHandler> mMainlineSupplicantDeathHandlerCaptor =
+            ArgumentCaptor.forClass(SupplicantDeathEventHandler.class);
     private ArgumentCaptor<WifiNative.HostapdDeathEventHandler> mHostapdDeathHandlerCaptor =
             ArgumentCaptor.forClass(WifiNative.HostapdDeathEventHandler.class);
     private ArgumentCaptor<NetdEventObserver> mNetworkObserverCaptor0 =
@@ -226,6 +232,32 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         when(mHostapdHal.removeAccessPoint(any())).thenReturn(true);
         when(mHostapdHal.registerApCallback(any(), any())).thenReturn(true);
 
+        when(mMainlineSupplicant.addStaInterface(anyString())).thenReturn(true);
+        when(mMainlineSupplicant.isAvailable()).thenReturn(true);
+        when(mMainlineSupplicant.removeStaInterface(anyString())).thenReturn(true);
+        when(mMainlineSupplicant.startService()).thenReturn(true);
+
+        /**
+         * Ensure that {@link MainlineSupplicant#isActive()} only returns true if the service has
+         * been started. Otherwise, if the service has been stopped or was never started,
+         * the service is not considered active.
+         */
+        when(mMainlineSupplicant.isActive()).thenReturn(false);
+        doAnswer(new Answer<Boolean>() {
+            @Override
+            public Boolean answer(InvocationOnMock invocation) {
+                when(mMainlineSupplicant.isActive()).thenReturn(true);
+                return true;
+            }
+        }).when(mMainlineSupplicant).startService();
+        doAnswer(new Answer<Void>() {
+            @Override
+            public Void answer(InvocationOnMock invocation) {
+                when(mMainlineSupplicant.isActive()).thenReturn(false);
+                return null; // void method returns null
+            }
+        }).when(mMainlineSupplicant).stopService();
+
         when(mWifiGlobals.isWifiInterfaceAddedSelfRecoveryEnabled()).thenReturn(false);
 
         when(mWifiInjector.makeNetdWrapper()).thenReturn(mNetdWrapper);
@@ -258,12 +290,13 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
 
         mInOrder = inOrder(mWifiVendorHal, mWificondControl, mSupplicantStaIfaceHal, mHostapdHal,
                 mWifiMonitor, mNetdWrapper, mIfaceCallback0, mIfaceCallback1, mIfaceEventCallback0,
-                mWifiMetrics, mWifiP2pNative);
+                mWifiMetrics, mWifiP2pNative, mMainlineSupplicant);
 
         mWifiNative = new WifiNative(
                 mWifiVendorHal, mSupplicantStaIfaceHal, mHostapdHal, mWificondControl,
                 mWifiMonitor, mPropertyService, mWifiMetrics,
-                new Handler(mLooper.getLooper()), null, mBuildProperties, mWifiInjector);
+                new Handler(mLooper.getLooper()), null, mBuildProperties, mWifiInjector,
+                mMainlineSupplicant);
         mWifiNative.initialize();
         mWifiNative.registerStatusListener(mStatusListener);
 
@@ -283,7 +316,7 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         }
         verifyNoMoreInteractions(mWifiVendorHal, mWificondControl, mSupplicantStaIfaceHal,
                 mHostapdHal, mWifiMonitor, mNetdWrapper, mIfaceCallback0, mIfaceCallback1,
-                mIfaceEventCallback0, mWifiMetrics);
+                mIfaceEventCallback0, mWifiMetrics, mMainlineSupplicant);
     }
 
     private MockResources getMockResources() {
@@ -536,6 +569,10 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         verify(mSupplicantStaIfaceHal, atLeastOnce()).isInitializationStarted();
         verify(mSupplicantStaIfaceHal).deregisterDeathHandler();
         verify(mSupplicantStaIfaceHal).terminate();
+        verify(mMainlineSupplicant, atLeastOnce()).isActive();
+        verify(mMainlineSupplicant).removeStaInterface(IFACE_NAME_1);
+        verify(mMainlineSupplicant).unregisterFrameworkDeathHandler();
+        verify(mMainlineSupplicant).stopService();
         verify(mIfaceCallback1).onDestroyed(IFACE_NAME_1);
 
         // Verify AP removal
@@ -598,14 +635,20 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         mInOrder.verify(mWifiVendorHal).isVendorHalSupported();
         mInOrder.verify(mWifiVendorHal).replaceStaIfaceRequestorWs(ifaceName, workSource);
         mInOrder.verify(mSupplicantStaIfaceHal).teardownIface(ifaceName);
+        mInOrder.verify(mMainlineSupplicant).isActive();
+        mInOrder.verify(mMainlineSupplicant).removeStaInterface(ifaceName);
         mInOrder.verify(mSupplicantStaIfaceHal).isInitializationStarted();
         mInOrder.verify(mSupplicantStaIfaceHal).deregisterDeathHandler();
         mInOrder.verify(mSupplicantStaIfaceHal).isInitializationStarted();
         mInOrder.verify(mSupplicantStaIfaceHal).terminate();
+        mInOrder.verify(mMainlineSupplicant).isActive();
+        mInOrder.verify(mMainlineSupplicant).unregisterFrameworkDeathHandler();
+        mInOrder.verify(mMainlineSupplicant).stopService();
         mInOrder.verify(mSupplicantStaIfaceHal).getAdvancedCapabilities(ifaceName);
         mInOrder.verify(mSupplicantStaIfaceHal).getWpaDriverFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getSupportedFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getTwtCapabilities(ifaceName);
+        mInOrder.verify(mSupplicantStaIfaceHal).getUsdCapabilities(ifaceName);
         mInOrder.verify(mWifiVendorHal).getUsableChannels(anyInt(), anyInt(), anyInt());
     }
 
@@ -634,6 +677,7 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         mInOrder.verify(mSupplicantStaIfaceHal).getWpaDriverFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getSupportedFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getTwtCapabilities(ifaceName);
+        mInOrder.verify(mSupplicantStaIfaceHal).getUsdCapabilities(ifaceName);
         mInOrder.verify(mWifiVendorHal).getUsableChannels(anyInt(), anyInt(), anyInt());
         mInOrder.verify(mWifiVendorHal).enableStaChannelForPeerNetwork(anyBoolean(), anyBoolean());
     }
@@ -647,6 +691,7 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         mInOrder.verify(mSupplicantStaIfaceHal).getWpaDriverFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getSupportedFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getTwtCapabilities(ifaceName);
+        mInOrder.verify(mSupplicantStaIfaceHal).getUsdCapabilities(ifaceName);
         mInOrder.verify(mWifiVendorHal).getUsableChannels(anyInt(), anyInt(), anyInt());
     }
 
@@ -978,6 +1023,24 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         verify(mStatusListener).onStatusChanged(true);
     }
 
+    /**
+     * Verifies the setup of a client interface and mainline supplicant death handling.
+     */
+    @Test
+    public void testSetupClientInterfaceAndMainlineSupplicantDied() throws Exception {
+        executeAndValidateSetupClientInterface(
+                false, false, IFACE_NAME_0, mIfaceCallback0, mIfaceDestroyedListenerCaptor0,
+                mNetworkObserverCaptor0);
+        verify(mMainlineSupplicant, times(1))
+                .registerFrameworkDeathHandler(mMainlineSupplicantDeathHandlerCaptor.capture());
+
+        // Trigger mainline supplicant death
+        mMainlineSupplicantDeathHandlerCaptor.getValue().onDeath();
+        mLooper.dispatchAll();
+        verify(mStatusListener).onStatusChanged(false);
+        verify(mStatusListener).onStatusChanged(true);
+    }
+
     /**
      * Verifies the setup of a soft ap interface and hostapd death handling.
      */
@@ -1397,19 +1460,26 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
             mInOrder.verify(mSupplicantStaIfaceHal).isInitializationComplete();
             mInOrder.verify(mSupplicantStaIfaceHal).registerDeathHandler(any());
             when(mSupplicantStaIfaceHal.isInitializationStarted()).thenReturn(true);
+
+            mInOrder.verify(mMainlineSupplicant).isAvailable();
+            mInOrder.verify(mMainlineSupplicant).startService();
+            mInOrder.verify(mMainlineSupplicant).registerFrameworkDeathHandler(any());
         }
         mInOrder.verify(mSupplicantStaIfaceHal).setupIface(ifaceName);
         if (failureCode == STA_FAILURE_CODE_SETUP_INTERFACE) {
             mInOrder.verify(mWifiVendorHal).isVendorHalSupported();
             mInOrder.verify(mWifiVendorHal).removeStaIface(ifaceName);
             mInOrder.verify(mWifiMetrics).incrementNumSetupClientInterfaceFailureDueToSupplicant();
-        } else {
-            mInOrder.verify(mSupplicantStaIfaceHal).getAdvancedCapabilities(ifaceName);
-            mInOrder.verify(mSupplicantStaIfaceHal).getWpaDriverFeatureSet(ifaceName);
-            mInOrder.verify(mWifiVendorHal).getSupportedFeatureSet(ifaceName);
-            mInOrder.verify(mWifiVendorHal).getTwtCapabilities(ifaceName);
-            mInOrder.verify(mWifiVendorHal).getUsableChannels(anyInt(), anyInt(), anyInt());
+            return;
         }
+        mInOrder.verify(mMainlineSupplicant).isActive();
+        mInOrder.verify(mMainlineSupplicant).addStaInterface(ifaceName);
+        mInOrder.verify(mSupplicantStaIfaceHal).getAdvancedCapabilities(ifaceName);
+        mInOrder.verify(mSupplicantStaIfaceHal).getWpaDriverFeatureSet(ifaceName);
+        mInOrder.verify(mWifiVendorHal).getSupportedFeatureSet(ifaceName);
+        mInOrder.verify(mWifiVendorHal).getTwtCapabilities(ifaceName);
+        mInOrder.verify(mSupplicantStaIfaceHal).getUsdCapabilities(ifaceName);
+        mInOrder.verify(mWifiVendorHal).getUsableChannels(anyInt(), anyInt(), anyInt());
     }
 
     /**
@@ -1499,6 +1569,7 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
                 false, false, true, IFACE_NAME_0, mIfaceDestroyedListenerCaptor0,
                 mNetworkObserverCaptor0, true, 0);
         verify(mSupplicantStaIfaceHal, atLeastOnce()).isInitializationStarted();
+        verify(mMainlineSupplicant, atLeastOnce()).isActive();
         verify(mWifiVendorHal, never()).stopVendorHal();
         verify(mWifiP2pNative).stopP2pSupplicantIfNecessary();
     }
@@ -1733,6 +1804,8 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
             mInOrder.verify(mNetdWrapper).unregisterObserver(networkObserver);
         }
         mInOrder.verify(mSupplicantStaIfaceHal).teardownIface(ifaceName);
+        mInOrder.verify(mMainlineSupplicant).isActive();
+        mInOrder.verify(mMainlineSupplicant).removeStaInterface(anyString());
         mInOrder.verify(mWificondControl).tearDownClientInterface(ifaceName);
 
         if (!anyOtherStaIface) {
@@ -1743,6 +1816,9 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
                 mInOrder.verify(mSupplicantStaIfaceHal).terminate();
             }
             when(mSupplicantStaIfaceHal.isInitializationStarted()).thenReturn(false);
+            mInOrder.verify(mMainlineSupplicant).isActive();
+            mInOrder.verify(mMainlineSupplicant).unregisterFrameworkDeathHandler();
+            mInOrder.verify(mMainlineSupplicant).stopService();
         }
         if (!anyOtherStaIface && !anyOtherApIface && !anyOtherP2pIface && !anyOtherNanIface) {
             mInOrder.verify(mWificondControl).tearDownInterfaces();
@@ -1884,6 +1960,7 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         mInOrder.verify(mSupplicantStaIfaceHal).getWpaDriverFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getSupportedFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getTwtCapabilities(ifaceName);
+        mInOrder.verify(mSupplicantStaIfaceHal).getUsdCapabilities(ifaceName);
         mInOrder.verify(mWifiVendorHal).getUsableChannels(anyInt(), anyInt(), anyInt());
         mInOrder.verify(mWifiVendorHal).enableStaChannelForPeerNetwork(anyBoolean(), anyBoolean());
     }
@@ -2066,6 +2143,8 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
                         mNetworkObserverCaptor0.getValue());
                 if (mWifiNative.hasAnyStaIfaceForConnectivity()) {
                     mInOrder.verify(mSupplicantStaIfaceHal).teardownIface(ifaceName);
+                    mInOrder.verify(mMainlineSupplicant).isActive();
+                    mInOrder.verify(mMainlineSupplicant).removeStaInterface(ifaceName);
                 }
                 mInOrder.verify(mWificondControl).tearDownClientInterface(ifaceName);
                 if (mWifiNative.hasAnyStaIfaceForConnectivity()) {
@@ -2073,6 +2152,8 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
                     mInOrder.verify(mSupplicantStaIfaceHal).deregisterDeathHandler();
                     mInOrder.verify(mSupplicantStaIfaceHal).isInitializationStarted();
                     mInOrder.verify(mSupplicantStaIfaceHal).terminate();
+                    mInOrder.verify(mMainlineSupplicant).isActive();
+                    mInOrder.verify(mMainlineSupplicant).stopService();
                     when(mSupplicantStaIfaceHal.isInitializationStarted()).thenReturn(false);
                 }
                 mInOrder.verify(mWifiVendorHal).isVendorHalReady();
@@ -2100,6 +2181,7 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         mInOrder.verify(mSupplicantStaIfaceHal).getWpaDriverFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getSupportedFeatureSet(ifaceName);
         mInOrder.verify(mWifiVendorHal).getTwtCapabilities(ifaceName);
+        mInOrder.verify(mSupplicantStaIfaceHal).getUsdCapabilities(ifaceName);
         mInOrder.verify(mWifiVendorHal).getUsableChannels(anyInt(), anyInt(), anyInt());
     }
 
@@ -2275,6 +2357,11 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
                     mInOrder.verify(mWifiP2pNative).stopP2pSupplicantIfNecessary();
                 }
             }
+            mInOrder.verify(mMainlineSupplicant, atLeastOnce()).isActive();
+            if (isSupplicantStartedBefore) {
+                mInOrder.verify(mMainlineSupplicant).unregisterFrameworkDeathHandler();
+                mInOrder.verify(mMainlineSupplicant).stopService();
+            }
         }
     }
 
@@ -2291,6 +2378,10 @@ public class WifiNativeInterfaceManagementTest extends WifiBaseTest {
         validateStartHal(hasStaIface || hasApIface || hasP2pIface || hasNanIface, true);
         assertNotNull(mActiveNanIface);
         assertEquals(mActiveNanIface.iface, mActiveWifiNanIface);
+        // Make sure switch client interface will not work on Aware interfaces
+        assertFalse(mWifiNative.switchClientInterfaceToScanMode(IFACE_NAME_AWARE, TEST_WORKSOURCE));
+        assertFalse(mWifiNative.switchClientInterfaceToConnectivityMode(IFACE_NAME_AWARE,
+                TEST_WORKSOURCE));
     }
 
     private void executeAndValidateTeardownNanInterface(
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiNativeTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiNativeTest.java
index 0ac9231988..9c07645fa0 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiNativeTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiNativeTest.java
@@ -75,6 +75,7 @@ import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.coex.CoexManager;
 import com.android.server.wifi.hal.WifiChip;
+import com.android.server.wifi.mainline_supplicant.MainlineSupplicant;
 import com.android.server.wifi.p2p.WifiP2pNative;
 import com.android.server.wifi.proto.WifiStatsLog;
 import com.android.server.wifi.util.NativeUtil;
@@ -264,6 +265,11 @@ public class WifiNativeTest extends WifiBaseTest {
     private static final RadioChainInfo MOCK_NATIVE_RADIO_CHAIN_INFO_2 = new RadioChainInfo(0, -78);
     private static final WorkSource TEST_WORKSOURCE = new WorkSource();
     private static final WorkSource TEST_WORKSOURCE2 = new WorkSource();
+    private static final int USD_MAX_SSI_LEN = 1024;
+    private static final int USD_MAX_SERVICE_NAME_LEN = 255;
+    private static final int USD_MAX_MATCH_FILTER_LEN = 255;
+    private static final int USD_MAX_NUM_PUBLISH_SESSIONS = 10;
+    private static final int USD_MAX_NUM_SUBSCRIBE_SESSIONS = 10;
 
     MockResources mResources;
 
@@ -271,6 +277,7 @@ public class WifiNativeTest extends WifiBaseTest {
     @Mock private WifiVendorHal mWifiVendorHal;
     @Mock private WifiNl80211Manager mWificondControl;
     @Mock private SupplicantStaIfaceHal mStaIfaceHal;
+    @Mock private MainlineSupplicant mMainlineSupplicant;
     @Mock private HostapdHal mHostapdHal;
     @Mock private WifiMonitor mWifiMonitor;
     @Mock private PropertyService mPropertyService;
@@ -336,6 +343,9 @@ public class WifiNativeTest extends WifiBaseTest {
         when(mHostapdHal.isInitializationComplete()).thenReturn(true);
         when(mHostapdHal.registerDeathHandler(any())).thenReturn(true);
 
+        when(mMainlineSupplicant.isAvailable()).thenReturn(true);
+        when(mMainlineSupplicant.startService()).thenReturn(true);
+
         when(mWifiInjector.makeNetdWrapper()).thenReturn(mNetdWrapper);
         when(mWifiInjector.getCoexManager()).thenReturn(mCoexManager);
 
@@ -346,6 +356,7 @@ public class WifiNativeTest extends WifiBaseTest {
         when(mWifiInjector.getWifiP2pNative()).thenReturn(mWifiP2pNative);
         mResources = getMockResources();
         mResources.setBoolean(R.bool.config_wifiNetworkCentricQosPolicyFeatureEnabled, false);
+        mResources.setBoolean(R.bool.config_wifiUsdPublisherSupported, false);
         when(mContext.getResources()).thenReturn(mResources);
         when(mSettingsConfigStore.get(eq(WIFI_NATIVE_EXTENDED_SUPPORTED_FEATURES)))
                 .thenReturn(WIFI_TEST_FEATURE.toLongArray());
@@ -368,7 +379,7 @@ public class WifiNativeTest extends WifiBaseTest {
         mWifiNative = new WifiNative(
                 mWifiVendorHal, mStaIfaceHal, mHostapdHal, mWificondControl,
                 mWifiMonitor, mPropertyService, mWifiMetrics,
-                mHandler, mRandom, mBuildProperties, mWifiInjector);
+                mHandler, mRandom, mBuildProperties, mWifiInjector, mMainlineSupplicant);
         mWifiNative.enableVerboseLogging(true, true);
         mWifiNative.initialize();
         assertNull(mWifiNative.mUnknownAkmMap);
@@ -1177,9 +1188,30 @@ public class WifiNativeTest extends WifiBaseTest {
     @Test
     public void testRemoveIfaceInstanceFromBridgedApIface() throws Exception {
         mWifiNative.removeIfaceInstanceFromBridgedApIface(
-                "br_" + WIFI_IFACE_NAME, WIFI_IFACE_NAME);
+                "br_" + WIFI_IFACE_NAME, WIFI_IFACE_NAME, false);
+        verify(mHostapdHal, never()).removeLinkFromMultipleLinkBridgedApIface(anyString(),
+                anyString());
         verify(mWifiVendorHal).removeIfaceInstanceFromBridgedApIface(
                 "br_" + WIFI_IFACE_NAME, WIFI_IFACE_NAME);
+
+        // verify removeLinkFromMultipleLinkBridgedApIface never call when flags is not enabled.
+        when(Flags.mloSap()).thenReturn(false);
+        mWifiNative.removeIfaceInstanceFromBridgedApIface(
+                "br_" + WIFI_IFACE_NAME, WIFI_IFACE_NAME, true);
+        verify(mHostapdHal, never()).removeLinkFromMultipleLinkBridgedApIface(anyString(),
+                anyString());
+        verify(mWifiVendorHal, times(2)).removeIfaceInstanceFromBridgedApIface(
+                "br_" + WIFI_IFACE_NAME, WIFI_IFACE_NAME);
+
+        // verify removeLinkFromMultipleLinkBridgedApIface will be called when feature flag
+        // is enabled.
+        when(Flags.mloSap()).thenReturn(true);
+        mWifiNative.removeIfaceInstanceFromBridgedApIface(
+                "br_" + WIFI_IFACE_NAME, WIFI_IFACE_NAME, true);
+        verify(mHostapdHal).removeLinkFromMultipleLinkBridgedApIface("br_" + WIFI_IFACE_NAME,
+                WIFI_IFACE_NAME);
+        verify(mWifiVendorHal, times(3)).removeIfaceInstanceFromBridgedApIface(
+                "br_" + WIFI_IFACE_NAME, WIFI_IFACE_NAME);
     }
 
     /**
@@ -1723,6 +1755,35 @@ public class WifiNativeTest extends WifiBaseTest {
         assertEquals(3, mWifiNative.getSupportedBandsForSta(WIFI_IFACE_NAME));
     }
 
+    /**
+     * Verifies that getSupportedBandsForStaFromWifiCond() calls underlying wificond
+     * when all 5G available channels are DFS channels.
+     */
+    @Test
+    public void testGetSupportedBandsWhenOnly5DhsExist() throws Exception {
+        when(mWificondControl.getChannelsMhzForBand(WifiScanner.WIFI_BAND_24_GHZ)).thenReturn(
+                new int[]{2412});
+        when(mWificondControl.getChannelsMhzForBand(WifiScanner.WIFI_BAND_5_GHZ)).thenReturn(
+                new int[0]);
+        when(mWificondControl.getChannelsMhzForBand(WifiScanner.WIFI_BAND_5_GHZ_DFS_ONLY))
+                .thenReturn(new int[]{5500});
+        when(mWificondControl.getChannelsMhzForBand(WifiScanner.WIFI_BAND_6_GHZ)).thenReturn(
+                new int[0]);
+        when(mWificondControl.getChannelsMhzForBand(WifiScanner.WIFI_BAND_60_GHZ)).thenReturn(
+                new int[0]);
+        when(mWifiVendorHal.getUsableChannels(WifiScanner.WIFI_BAND_24_5_WITH_DFS_6_60_GHZ,
+                WifiAvailableChannel.OP_MODE_STA,
+                WifiAvailableChannel.FILTER_REGULATORY)).thenReturn(null);
+        mWifiNative.setupInterfaceForClientInScanMode(null, TEST_WORKSOURCE,
+                mConcreteClientModeManager);
+        mWifiNative.switchClientInterfaceToConnectivityMode(WIFI_IFACE_NAME, TEST_WORKSOURCE);
+        verify(mWificondControl, times(2)).getChannelsMhzForBand(WifiScanner.WIFI_BAND_24_GHZ);
+        verify(mWificondControl, times(2)).getChannelsMhzForBand(WifiScanner.WIFI_BAND_5_GHZ);
+        verify(mWificondControl, times(2))
+                .getChannelsMhzForBand(WifiScanner.WIFI_BAND_5_GHZ_DFS_ONLY);
+        assertEquals(3, mWifiNative.getSupportedBandsForSta(WIFI_IFACE_NAME));
+    }
+
     /**
      * Verifies that isSoftApInstanceDiedHandlerSupported() calls underlying HostapdHal.
      */
@@ -1813,7 +1874,8 @@ public class WifiNativeTest extends WifiBaseTest {
                         mHandler,
                         mRandom,
                         mBuildProperties,
-                        mWifiInjector);
+                        mWifiInjector,
+                        mMainlineSupplicant);
         assertNull(wifiNativeInstance.mUnknownAkmMap);
 
         // Test that UnknownAkmMap is not set if non-integer values are added in the config.
@@ -1831,7 +1893,8 @@ public class WifiNativeTest extends WifiBaseTest {
                         mHandler,
                         mRandom,
                         mBuildProperties,
-                        mWifiInjector);
+                        mWifiInjector,
+                        mMainlineSupplicant);
         assertNull(wifiNativeInstance.mUnknownAkmMap);
 
         // Test that UnknownAkmMap is not set when an invalid AKM is set in the known AKM field
@@ -1850,7 +1913,8 @@ public class WifiNativeTest extends WifiBaseTest {
                         mHandler,
                         mRandom,
                         mBuildProperties,
-                        mWifiInjector);
+                        mWifiInjector,
+                        mMainlineSupplicant);
         assertNull(wifiNativeInstance.mUnknownAkmMap);
 
         // Test that UnknownAkmMap is set for a valid configuration
@@ -1869,7 +1933,8 @@ public class WifiNativeTest extends WifiBaseTest {
                         mHandler,
                         mRandom,
                         mBuildProperties,
-                        mWifiInjector);
+                        mWifiInjector,
+                        mMainlineSupplicant);
         assertEquals(1, wifiNativeInstance.mUnknownAkmMap.size());
         assertEquals(ScanResult.KEY_MGMT_EAP, wifiNativeInstance.mUnknownAkmMap.get(9846784));
 
@@ -1891,7 +1956,8 @@ public class WifiNativeTest extends WifiBaseTest {
                         mHandler,
                         mRandom,
                         mBuildProperties,
-                        mWifiInjector);
+                        mWifiInjector,
+                        mMainlineSupplicant);
         assertEquals(2, wifiNativeInstance.mUnknownAkmMap.size());
         assertEquals(ScanResult.KEY_MGMT_EAP, wifiNativeInstance.mUnknownAkmMap.get(9846784));
         assertEquals(ScanResult.KEY_MGMT_SAE_EXT_KEY, wifiNativeInstance.mUnknownAkmMap.get(1234));
@@ -1964,7 +2030,7 @@ public class WifiNativeTest extends WifiBaseTest {
         mWifiNative = new WifiNative(
                 mWifiVendorHal, mStaIfaceHal, mHostapdHal, mWificondControl,
                 mWifiMonitor, mPropertyService, mWifiMetrics,
-                mHandler, mRandom, mBuildProperties, mWifiInjector);
+                mHandler, mRandom, mBuildProperties, mWifiInjector, mMainlineSupplicant);
         assertTrue(mWifiNative.isMLDApSupportMLO());
         when(Flags.mloSap()).thenReturn(false);
         assertFalse(mWifiNative.isMLDApSupportMLO());
@@ -1972,4 +2038,50 @@ public class WifiNativeTest extends WifiBaseTest {
         when(mWifiGlobals.isMLDApSupported()).thenReturn(false);
         assertFalse(mWifiNative.isMLDApSupportMLO());
     }
+
+    /**
+     * Test USD capabilities when config_wifiUsdPublisherSupported = false in the overlay.
+     */
+    @Test
+    public void testUsdPublishSupportOverriddenByOverlay() throws Exception {
+        mResources.setBoolean(R.bool.config_wifiUsdPublisherSupported, false);
+        SupplicantStaIfaceHal.UsdCapabilitiesInternal usdCapabilities =
+                new SupplicantStaIfaceHal.UsdCapabilitiesInternal(true, true, USD_MAX_SSI_LEN,
+                        USD_MAX_SERVICE_NAME_LEN, USD_MAX_MATCH_FILTER_LEN,
+                        USD_MAX_NUM_PUBLISH_SESSIONS, USD_MAX_NUM_SUBSCRIBE_SESSIONS);
+
+        when(mStaIfaceHal.getUsdCapabilities(WIFI_IFACE_NAME)).thenReturn(usdCapabilities);
+        mWifiNative.setupInterfaceForClientInScanMode(null, TEST_WORKSOURCE,
+                mConcreteClientModeManager);
+        SupplicantStaIfaceHal.UsdCapabilitiesInternal halUsdCapabilities =
+                mWifiNative.getUsdCapabilities();
+        // Publisher is disabled even though the device is capable of supporting.
+        assertFalse(halUsdCapabilities.isUsdPublisherSupported);
+    }
+
+    /**
+     * Test USD capabilities when config_wifiUsdPublisherSupported = true in the overlay.
+     */
+    @Test
+    public void testGetUsdCapabilities() {
+        mResources.setBoolean(R.bool.config_wifiUsdPublisherSupported, true);
+        SupplicantStaIfaceHal.UsdCapabilitiesInternal usdCapabilities =
+                new SupplicantStaIfaceHal.UsdCapabilitiesInternal(true, true, USD_MAX_SSI_LEN,
+                        USD_MAX_SERVICE_NAME_LEN, USD_MAX_MATCH_FILTER_LEN,
+                        USD_MAX_NUM_PUBLISH_SESSIONS, USD_MAX_NUM_SUBSCRIBE_SESSIONS);
+
+        when(mStaIfaceHal.getUsdCapabilities(WIFI_IFACE_NAME)).thenReturn(usdCapabilities);
+        mWifiNative.setupInterfaceForClientInScanMode(null, TEST_WORKSOURCE,
+                mConcreteClientModeManager);
+        SupplicantStaIfaceHal.UsdCapabilitiesInternal halUsdCapabilities =
+                mWifiNative.getUsdCapabilities();
+        // Publisher is supported and enabled
+        assertTrue(halUsdCapabilities.isUsdPublisherSupported);
+        assertTrue(halUsdCapabilities.isUsdSubscriberSupported);
+        assertEquals(USD_MAX_SSI_LEN, halUsdCapabilities.maxLocalSsiLengthBytes);
+        assertEquals(USD_MAX_SERVICE_NAME_LEN, halUsdCapabilities.maxServiceNameLengthBytes);
+        assertEquals(USD_MAX_MATCH_FILTER_LEN, halUsdCapabilities.maxMatchFilterLengthBytes);
+        assertEquals(USD_MAX_NUM_PUBLISH_SESSIONS, halUsdCapabilities.maxNumPublishSessions);
+        assertEquals(USD_MAX_NUM_SUBSCRIBE_SESSIONS, halUsdCapabilities.maxNumSubscribeSessions);
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkFactoryTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkFactoryTest.java
index 0a8fccac7c..329a7a8ef0 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkFactoryTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkFactoryTest.java
@@ -294,12 +294,12 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
             requestListener.onAnswer(mClientModeManager);
             return null;
         }).when(mActiveModeWarden).requestLocalOnlyClientModeManager(any(), any(), any(), any(),
-                anyBoolean());
+                anyBoolean(), anyBoolean());
         when(mClientModeManager.getRole()).thenReturn(ActiveModeManager.ROLE_CLIENT_PRIMARY);
         when(mFrameworkFacade.getSettingsWorkSource(any())).thenReturn(
                 new WorkSource(Process.SYSTEM_UID, "system-service"));
 
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(
                         WifiManager.WIFI_FEATURE_WPA3_SAE, WifiManager.WIFI_FEATURE_OWE));
 
@@ -736,6 +736,20 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         verify(mWifiMetrics).incrementNetworkRequestApiNumRequest();
     }
 
+    /**
+     * Verify handling of new network request with network specifier.
+     */
+    @Test
+    public void testScanScheduleWithPreferredChannel() {
+        attachDefaultWifiNetworkSpecifierAndAppInfo(TEST_UID_1, false,
+                new int[]{TEST_PREFERRED_CHANNEL_FREQ}, false);
+        mWifiNetworkFactory.needNetworkFor(mNetworkRequest);
+        verifyPeriodicScans(false, 0, 0,
+                PERIODIC_SCAN_INTERVAL_MS,     // 10s
+                PERIODIC_SCAN_INTERVAL_MS,     // 10s
+                PERIODIC_SCAN_INTERVAL_MS);    // 10s
+    }
+
     /**
      * Validates handling of new network request with unsupported network specifier.
      */
@@ -1721,34 +1735,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         verifyNoMoreInteractions(mClientModeManager, mWifiConfigManager);
     }
 
-    /**
-     * Verify handling of connection timeout.
-     * The timeouts should trigger connection retries until we hit the max.
-     */
-    @Test
-    public void testNetworkSpecifierHandleConnectionTimeout() throws Exception {
-        sendNetworkRequestAndSetupForConnectionStatus();
-
-        // Simulate connection timeout beyond the retry limit to trigger the failure handling.
-        for (int i = 0; i <= WifiNetworkFactory.USER_SELECTED_NETWORK_CONNECT_RETRY_MAX; i++) {
-            mConnectionTimeoutAlarmListenerArgumentCaptor.getValue().onAlarm();
-            mLooper.dispatchAll();
-        }
-
-        mInOrder = inOrder(mAlarmManager, mClientModeManager, mConnectHelper);
-        validateConnectionRetryAttempts(true);
-
-        // Fail the request after all the retries are exhausted.
-        verify(mNetworkRequestMatchCallback).onAbort();
-        // Verify that we sent the connection failure callback.
-        verify(mNetworkRequestMatchCallback).onUserSelectionConnectFailure(
-                argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // Verify we reset the network request handling.
-        verify(mWifiConnectivityManager).setSpecificNetworkRequestInProgress(false);
-        verify(mActiveModeWarden).removeClientModeManager(any());
-        verify(mConnectivityManager).declareNetworkRequestUnfulfillable(eq(mNetworkRequest));
-    }
-
     /**
      * Verify handling of connection trigger failure.
      * The trigger failures should trigger connection retries until we hit the max.
@@ -1759,23 +1745,19 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
 
         // Send failure message beyond the retry limit to trigger the failure handling.
         for (int i = 0; i <= WifiNetworkFactory.USER_SELECTED_NETWORK_CONNECT_RETRY_MAX; i++) {
-            assertNotNull(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
             mConnectListenerArgumentCaptor.getValue()
                     .sendFailure(WifiManager.ActionListener.FAILURE_INTERNAL_ERROR);
         }
         mLooper.dispatchAll();
 
         mInOrder = inOrder(mAlarmManager, mClientModeManager, mConnectHelper);
-        validateConnectionRetryAttempts(false);
+        validateConnectionRetryAttempts();
 
         // Fail the request after all the retries are exhausted.
         verify(mNetworkRequestMatchCallback).onAbort();
         // Verify that we sent the connection failure callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectFailure(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        mInOrder.verify(mAlarmManager).cancel(
-                mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we reset the network request handling.
         verify(mWifiConnectivityManager).setSpecificNetworkRequestInProgress(false);
         verify(mActiveModeWarden).removeClientModeManager(any());
@@ -1804,15 +1786,12 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         }
 
         mInOrder = inOrder(mAlarmManager, mClientModeManager, mConnectHelper);
-        validateConnectionRetryAttempts(false);
+        validateConnectionRetryAttempts();
 
         verify(mNetworkRequestMatchCallback).onAbort();
         // Verify that we sent the connection failure callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectFailure(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        mInOrder.verify(mAlarmManager).cancel(
-                mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we reset the network request handling.
         verify(mWifiConnectivityManager).setSpecificNetworkRequestInProgress(false);
         verify(mActiveModeWarden).removeClientModeManager(any());
@@ -1845,9 +1824,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection failure callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectFailure(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        mInOrder.verify(mAlarmManager).cancel(
-                mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we reset the network request handling.
         verify(mWifiConnectivityManager).setSpecificNetworkRequestInProgress(false);
         verify(mActiveModeWarden).removeClientModeManager(any());
@@ -1873,9 +1849,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
 
         // Verify that we did not send the connection failure callback.
         verify(mNetworkRequestMatchCallback, never()).onUserSelectionConnectFailure(any());
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager, never())
-                .cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we don't reset the network request handling.
         verify(mWifiConnectivityManager, never())
                 .setSpecificNetworkRequestInProgress(false);
@@ -1889,14 +1862,11 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         }
 
         mInOrder = inOrder(mAlarmManager, mClientModeManager, mConnectHelper);
-        validateConnectionRetryAttempts(false);
+        validateConnectionRetryAttempts();
 
         // Verify that we sent the connection failure callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectFailure(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        mInOrder.verify(mAlarmManager).cancel(
-                mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we reset the network request handling.
         verify(mWifiConnectivityManager).setSpecificNetworkRequestInProgress(false);
         verify(mActiveModeWarden).removeClientModeManager(any());
@@ -1917,9 +1887,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
 
         // Verify that we did not send the connection failure callback.
         verify(mNetworkRequestMatchCallback, never()).onUserSelectionConnectFailure(any());
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager, never())
-                .cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we don't reset the network request handling.
         verify(mWifiConnectivityManager, never())
                 .setSpecificNetworkRequestInProgress(false);
@@ -1933,14 +1900,11 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         }
 
         mInOrder = inOrder(mAlarmManager, mClientModeManager, mConnectHelper);
-        validateConnectionRetryAttempts(false);
+        validateConnectionRetryAttempts();
 
         // Verify that we sent the connection failure callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectFailure(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        mInOrder.verify(mAlarmManager).cancel(
-                mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we reset the network request handling.
         verify(mWifiConnectivityManager).setSpecificNetworkRequestInProgress(false);
         verify(mActiveModeWarden).removeClientModeManager(any());
@@ -1962,8 +1926,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we disabled fw roaming.
         verify(mClientModeManager).enableRoaming(false);
 
@@ -1996,8 +1958,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we disabled fw roaming.
         verify(mClientModeManager, never()).enableRoaming(false);
 
@@ -2028,8 +1988,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we disabled fw roaming.
         verify(mClientModeManager).enableRoaming(false);
 
@@ -2059,8 +2017,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify we disabled fw roaming.
         verify(mClientModeManager).enableRoaming(false);
         verify(mWifiMetrics).incrementNetworkRequestApiNumConnectSuccessOnSecondaryIface();
@@ -2097,8 +2053,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
 
         verify(mWifiMetrics).incrementNetworkRequestApiNumConnectSuccessOnPrimaryIface();
         verify(mNetworkRequestMatchCallback, atLeastOnce()).asBinder();
@@ -2126,8 +2080,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
 
         // verify that we did not send out the success callback and did not stop the alarm timeout.
         verify(mNetworkRequestMatchCallback, never()).onUserSelectionConnectSuccess(any());
-        verify(mAlarmManager, never())
-                .cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
 
         // Send network connection success to the correct network indication.
         mWifiNetworkFactory.handleConnectionAttemptEnded(
@@ -2136,8 +2088,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
     }
 
     /**
@@ -2154,8 +2104,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
 
         // verify that we did not send out the success callback and did not stop the alarm timeout.
         verify(mNetworkRequestMatchCallback, never()).onUserSelectionConnectSuccess(any());
-        verify(mAlarmManager, never())
-                .cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
 
         // Send network connection success to the correct network indication.
         mWifiNetworkFactory.handleConnectionAttemptEnded(
@@ -2164,8 +2112,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
     }
 
     /**
@@ -2188,8 +2134,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         when(mWifiConfigManager.getConfiguredNetwork(wcmNetwork.getProfileKey()))
                 .thenReturn(wcmNetwork);
         mWifiNetworkFactory.releaseNetworkFor(mNetworkRequest);
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         // Verify that we triggered a disconnect.
         verify(mClientModeManager, times(2)).disconnect();
         verify(mWifiConfigManager).removeNetwork(
@@ -2215,8 +2159,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         verify(mWifiMetrics).incrementNetworkRequestApiNumConnectSuccessOnPrimaryIface();
 
         long connectionDurationMillis = 5665L;
@@ -2262,8 +2204,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         verify(mWifiMetrics).incrementNetworkRequestApiNumConnectSuccessOnSecondaryIface();
 
         // Now release the network request.
@@ -2309,8 +2249,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         // Verify that we sent the connection success callback.
         verify(mNetworkRequestMatchCallback).onUserSelectionConnectSuccess(
                 argThat(new WifiConfigMatcher(mSelectedNetwork)));
-        // verify we canceled the timeout alarm.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         verify(mWifiMetrics).incrementNetworkRequestApiNumConnectSuccessOnSecondaryIface();
 
         // Indicate secondary connection via CMI listener.
@@ -2430,7 +2368,7 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
     @Test
     public void testHandleNewNetworkRequestWithSpecifierWhenAwaitingCmRetrieval() throws Exception {
         doNothing().when(mActiveModeWarden).requestLocalOnlyClientModeManager(
-                any(), any(), any(), any(), anyBoolean());
+                any(), any(), any(), any(), anyBoolean(), anyBoolean());
         WorkSource ws = new WorkSource(TEST_UID_1, TEST_PACKAGE_NAME_1);
 
         when(mClock.getElapsedSinceBootMillis()).thenReturn(0L);
@@ -2452,7 +2390,7 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
                         ActiveModeWarden.ExternalClientModeManagerRequestListener.class);
         verify(mActiveModeWarden).requestLocalOnlyClientModeManager(
                 cmListenerCaptor.capture(), eq(ws),
-                eq("\"" + TEST_SSID_1 + "\""), eq(TEST_BSSID_1), eq(true));
+                eq("\"" + TEST_SSID_1 + "\""), eq(TEST_BSSID_1), eq(true), eq(false));
         assertNotNull(cmListenerCaptor.getValue());
 
         NetworkRequest oldRequest = new NetworkRequest(mNetworkRequest);
@@ -2477,7 +2415,7 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
 
         // Ensure we request a new ClientModeManager.
         verify(mActiveModeWarden, times(2)).requestLocalOnlyClientModeManager(
-                any(), any(), any(), any(), anyBoolean());
+                any(), any(), any(), any(), anyBoolean(), anyBoolean());
 
         // Now return the CM instance for the previous request.
         cmListenerCaptor.getValue().onAnswer(mClientModeManager);
@@ -2545,7 +2483,7 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
 
         // Ensure we don't request a new ClientModeManager.
         verify(mActiveModeWarden, never()).requestLocalOnlyClientModeManager(
-                any(), any(), any(), any(), anyBoolean());
+                any(), any(), any(), any(), anyBoolean(), anyBoolean());
 
         // Ignore stale callbacks.
         WifiConfiguration selectedNetwork = WifiConfigurationTestUtil.createOpenNetwork();
@@ -2586,14 +2524,13 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
 
         // Ensure we don't request a new ClientModeManager.
         verify(mActiveModeWarden, times(1)).requestLocalOnlyClientModeManager(
-                any(), any(), any(), any(), anyBoolean());
+                any(), any(), any(), any(), anyBoolean(), anyBoolean());
 
         verify(mNetworkRequestMatchCallback).onAbort();
         verify(mNetworkRequestMatchCallback, atLeastOnce()).asBinder();
         verify(mWifiConnectivityManager, times(1)).setSpecificNetworkRequestInProgress(true);
         verify(mWifiScanner, times(2)).getSingleScanResults();
         verify(mWifiScanner, times(2)).startScan(any(), any(), any(), any());
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         verify(mClientModeManager, times(3)).getRole();
 
         // Remove the stale request1 & ensure nothing happens.
@@ -2623,8 +2560,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         assertNotNull(mSelectedNetwork);
         mWifiNetworkFactory.handleConnectionAttemptEnded(
                 WifiMetrics.ConnectionEvent.FAILURE_NONE, mSelectedNetwork, TEST_BSSID_1, WifiMetricsProto.ConnectionEvent.FAILURE_REASON_UNKNOWN);
-        // Cancel the connection timeout.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         verify(mClientModeManager).enableRoaming(false);
 
         NetworkRequest oldRequest = new NetworkRequest(mNetworkRequest);
@@ -2634,7 +2569,7 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
 
         // Ensure we do request a new ClientModeManager.
         verify(mActiveModeWarden, times(1)).requestLocalOnlyClientModeManager(
-                any(), any(), any(), any(), anyBoolean());
+                any(), any(), any(), any(), anyBoolean(), anyBoolean());
 
         verify(mWifiConnectivityManager, times(1)).setSpecificNetworkRequestInProgress(true);
         verify(mWifiScanner, times(2)).getSingleScanResults();
@@ -2673,8 +2608,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         assertNotNull(mSelectedNetwork);
         mWifiNetworkFactory.handleConnectionAttemptEnded(
                 WifiMetrics.ConnectionEvent.FAILURE_NONE, mSelectedNetwork, TEST_BSSID_1, WifiMetricsProto.ConnectionEvent.FAILURE_REASON_UNKNOWN);
-        // Cancel the connection timeout.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
 
         clearInvocations(mWifiConnectivityManager, mWifiScanner, mClientModeManager, mAlarmManager);
 
@@ -2699,8 +2632,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         assertNotNull(mSelectedNetwork);
         mWifiNetworkFactory.handleConnectionAttemptEnded(
                 WifiMetrics.ConnectionEvent.FAILURE_NONE, mSelectedNetwork, TEST_BSSID_1, WifiMetricsProto.ConnectionEvent.FAILURE_REASON_UNKNOWN);
-        // Cancel the connection timeout.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         verify(mClientModeManager).enableRoaming(false);
 
         // Send second request & we simulate the user selecting the request & connecting to it.
@@ -2712,8 +2643,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         mWifiNetworkFactory.handleConnectionAttemptEnded(
                 WifiMetrics.ConnectionEvent.FAILURE_NONE, mSelectedNetwork, TEST_BSSID_2, WifiMetricsProto.ConnectionEvent.FAILURE_REASON_UNKNOWN);
         verify(mClientModeManager, times(2)).enableRoaming(false);
-        // Cancel the connection timeout.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
 
         // We shouldn't explicitly disconnect, the new connection attempt will implicitly disconnect
         // from the connected network.
@@ -2755,8 +2684,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         assertNotNull(mSelectedNetwork);
         mWifiNetworkFactory.handleConnectionAttemptEnded(
                 WifiMetrics.ConnectionEvent.FAILURE_NONE, mSelectedNetwork, TEST_BSSID_1, WifiMetricsProto.ConnectionEvent.FAILURE_REASON_UNKNOWN);
-        // Cancel the connection timeout.
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
 
         // Send second request & we simulate the user rejecting the request.
         reset(mNetworkRequestMatchCallback, mWifiScanner, mAlarmManager);
@@ -2909,7 +2836,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         mModeChangeCallbackCaptor.getValue().onActiveModeManagerRemoved(mClientModeManager);
         mLooper.dispatchAll();
 
-        verify(mAlarmManager).cancel(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         verify(mNetworkRequestMatchCallback).onAbort();
         verify(mWifiConnectivityManager).setSpecificNetworkRequestInProgress(false);
         verify(mConnectivityManager).declareNetworkRequestUnfulfillable(eq(mNetworkRequest));
@@ -3416,6 +3342,7 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
                 WifiConfigurationTestUtil.createPskNetwork(), TEST_UID_1, TEST_PACKAGE_NAME_1,
                 new int[0]);
         mWifiNetworkFactory.needNetworkFor(mNetworkRequest);
+        setScreenState(false);
 
         // Verify we did not trigger the UI for the second request.
         verify(mContext, never()).startActivityAsUser(any(), any());
@@ -3720,7 +3647,7 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         mLooper.dispatchAll();
 
         verify(mActiveModeWarden, never()).requestLocalOnlyClientModeManager(
-                any(), any(), any(), any(), anyBoolean());
+                any(), any(), any(), any(), anyBoolean(), anyBoolean());
         verify(mActiveModeWarden, atLeastOnce()).getPrimaryClientModeManager();
         if (SdkLevel.isAtLeastS()) {
             verify(mPrimaryClientModeManager, atLeastOnce()).getConnectedWifiConfiguration();
@@ -3744,11 +3671,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
                 mConnectListenerArgumentCaptor.capture(), anyInt(), any(), any());
         verify(mWifiMetrics, atLeastOnce()).incrementNetworkRequestApiNumConnectOnPrimaryIface();
 
-        // Start the connection timeout alarm.
-        mInOrder.verify(mAlarmManager).set(eq(AlarmManager.ELAPSED_REALTIME_WAKEUP),
-                eq((long) WifiNetworkFactory.NETWORK_CONNECTION_TIMEOUT_MS), any(),
-                mConnectionTimeoutAlarmListenerArgumentCaptor.capture(), any());
-        assertNotNull(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
         assertTrue(mWifiNetworkFactory.shouldHaveInternetCapabilities());
     }
 
@@ -3783,7 +3705,7 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         mLooper.dispatchAll();
 
         verify(mActiveModeWarden, atLeastOnce()).requestLocalOnlyClientModeManager(
-                any(), any(), any(), any(), anyBoolean());
+                any(), any(), any(), any(), anyBoolean(), anyBoolean());
         if (SdkLevel.isAtLeastS()) {
             verify(mClientModeManager, atLeastOnce()).getConnectedWifiConfiguration();
             verify(mClientModeManager, atLeastOnce()).getConnectingWifiConfiguration();
@@ -3813,12 +3735,6 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
             verify(mWifiMetrics, atLeastOnce())
                     .incrementNetworkRequestApiNumConnectOnSecondaryIface();
         }
-
-        // Start the connection timeout alarm.
-        mInOrder.verify(mAlarmManager).set(eq(AlarmManager.ELAPSED_REALTIME_WAKEUP),
-                eq((long) WifiNetworkFactory.NETWORK_CONNECTION_TIMEOUT_MS), any(),
-                mConnectionTimeoutAlarmListenerArgumentCaptor.capture(), any());
-        assertNotNull(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
     }
 
     private void sendNetworkRequestAndSetupForUserSelection() throws RemoteException {
@@ -3917,11 +3833,13 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
             if (stopAtLastSchedule && i == scanParams.length - 2) {
                 break;
             }
-            mInOrder.verify(mAlarmManager).set(eq(AlarmManager.ELAPSED_REALTIME_WAKEUP),
-                    eq(expectedNextIntervalInMs + nowMs), any(),
-                    mPeriodicScanListenerArgumentCaptor.capture(), any());
-            alarmListener = mPeriodicScanListenerArgumentCaptor.getValue();
-            assertNotNull(alarmListener);
+            if (expectedNextIntervalInMs != 0) {
+                mInOrder.verify(mAlarmManager).set(eq(AlarmManager.ELAPSED_REALTIME_WAKEUP),
+                        eq(expectedNextIntervalInMs + nowMs), any(),
+                        mPeriodicScanListenerArgumentCaptor.capture(), any());
+                alarmListener = mPeriodicScanListenerArgumentCaptor.getValue();
+                assertNotNull(alarmListener);
+            }
         }
 
         mInOrder.verifyNoMoreInteractions();
@@ -3959,7 +3877,7 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         mNetworkCapabilities.setRequestorPackageName(packageName);
         mNetworkCapabilities.setNetworkSpecifier(
                 new WifiNetworkSpecifier(ssidPatternMatch, bssidPatternMatch,
-                        ScanResult.UNSPECIFIED, wifiConfiguration, channels));
+                        ScanResult.UNSPECIFIED, wifiConfiguration, channels, false));
         mNetworkRequest = new NetworkRequest.Builder()
                 .setCapabilities(mNetworkCapabilities)
                 .build();
@@ -4039,27 +3957,15 @@ public class WifiNetworkFactoryTest extends WifiBaseTest {
         }
     }
 
-    private void validateConnectionRetryAttempts(boolean onTimeout) {
-        for (int i = 0; i < WifiNetworkFactory.USER_SELECTED_NETWORK_CONNECT_RETRY_MAX; i++) {
-            if (!onTimeout) {
-                // Cancel the existing connection timeout.
-                mInOrder.verify(mAlarmManager).cancel(
-                        mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
-            }
-
-            // Trigger new connection.
-            mInOrder.verify(mConnectHelper).connectToNetwork(
-                    eq(mClientModeManager),
-                    eq(new NetworkUpdateResult(TEST_NETWORK_ID_1)),
-                    mConnectListenerArgumentCaptor.capture(),
-                    anyInt(), any(), any());
-
-            // Start the new connection timeout alarm.
-            mInOrder.verify(mAlarmManager).set(eq(AlarmManager.ELAPSED_REALTIME_WAKEUP),
-                    eq((long) WifiNetworkFactory.NETWORK_CONNECTION_TIMEOUT_MS), any(),
-                    mConnectionTimeoutAlarmListenerArgumentCaptor.capture(), any());
-            assertNotNull(mConnectionTimeoutAlarmListenerArgumentCaptor.getValue());
-        }
+    private void validateConnectionRetryAttempts() {
+        // Trigger new connection.
+        mInOrder.verify(mConnectHelper,
+                        times(WifiNetworkFactory.USER_SELECTED_NETWORK_CONNECT_RETRY_MAX + 1))
+                .connectToNetwork(
+                        eq(mClientModeManager),
+                        eq(new NetworkUpdateResult(TEST_NETWORK_ID_1)),
+                        mConnectListenerArgumentCaptor.capture(),
+                        anyInt(), any(), any());
     }
 
     private void validateScanSettings(@Nullable String hiddenSsid, int[] channels) {
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkSelectorTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkSelectorTest.java
index e966f51f9a..191d7d007e 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkSelectorTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkSelectorTest.java
@@ -159,7 +159,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
         when(mWifiInjector.getWifiGlobals()).thenReturn(mWifiGlobals);
         when(mWifiGlobals.getWifiLowConnectedScoreThresholdToTriggerScanForMbb()).thenReturn(
                 ConnectedScore.WIFI_TRANSITION_SCORE);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(new BitSet());
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(new BitSet());
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mClientModeManager);
         if (WifiNetworkSelector.PRESET_CANDIDATE_SCORER_NAME.equals(
                 mThroughputScorer.getIdentifier())) {
@@ -2288,7 +2288,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
         int[] levels = {mThresholdMinimumRssi2G, mThresholdMinimumRssi5G + RSSI_BUMP,
                 mThresholdMinimumRssi2G + RSSI_BUMP};
         mPlaceholderNominator.setNominatorToSelectCandidate(false);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WIFI_FEATURE_OWE));
 
         List<ScanDetail> scanDetails = WifiNetworkSelectorTestUtil.buildScanDetails(
@@ -2328,7 +2328,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
 
         BitSet supportedFeatures = new BitSet();
         supportedFeatures.set(WIFI_FEATURE_OWE, false);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(supportedFeatures);
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(supportedFeatures);
 
         List<ScanDetail> scanDetails = WifiNetworkSelectorTestUtil.buildScanDetails(
                 ssids, bssids, freqs, caps, levels, mClock);
@@ -2859,7 +2859,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testSaeAutoUpgradeWithPskNetworkWhenAutoUpgradeEnabled() {
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WIFI_FEATURE_WPA3_SAE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
         when(mWifiGlobals.isWpa3SaeUpgradeOffloadEnabled()).thenReturn(true);
@@ -2915,7 +2915,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testSaeAutoUpgradeWithPskNetworkWhenPskTypeIsDisabled() {
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WIFI_FEATURE_WPA3_SAE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
         when(mWifiGlobals.isWpa3SaeUpgradeOffloadEnabled()).thenReturn(false);
@@ -2951,7 +2951,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testSaeNoAutoUpgradeWithPskNetworkWhenAutoUpgradeDisabled() {
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WIFI_FEATURE_WPA3_SAE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(false);
         when(mWifiGlobals.isWpa3SaeUpgradeOffloadEnabled()).thenReturn(false);
@@ -2985,7 +2985,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testSaeNoAutoUpgradeWithPskNetworkWhenSaeNotSupported() {
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(new BitSet());
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(new BitSet());
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
         when(mWifiGlobals.isWpa3SaeUpgradeOffloadEnabled()).thenReturn(true);
 
@@ -3021,7 +3021,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testOweAutoUpgradeWithOpenNetworkWhenAutoUpgradeEnabled() {
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WIFI_FEATURE_OWE));
         when(mWifiGlobals.isOweUpgradeEnabled()).thenReturn(true);
 
@@ -3064,7 +3064,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testOweAutoUpgradeWithOpenNetworkWhenOpenTypeIsDisabled() {
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WIFI_FEATURE_OWE));
         when(mWifiGlobals.isOweUpgradeEnabled()).thenReturn(true);
 
@@ -3100,7 +3100,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testOweNoAutoUpgradeWithOpenNetworkWhenAutoUpgradeDisabled() {
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WIFI_FEATURE_OWE));
         when(mWifiGlobals.isOweUpgradeEnabled()).thenReturn(false);
 
@@ -3133,7 +3133,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testOweNoAutoUpgradeWithOweNetworkWhenOweNotSupported() {
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(new BitSet());
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(new BitSet());
         when(mWifiGlobals.isOweUpgradeEnabled()).thenReturn(true);
 
         when(mScanRequestProxy.isOpenOnlyNetworkInRange(eq(TEST_AUTO_UPGRADE_SSID)))
@@ -3242,7 +3242,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
 
     @Test
     public void verifySecurityParamsSelectionForPskSaeConfigAndSaeScan() {
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WIFI_FEATURE_WPA3_SAE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
         setupMultiConfigAndSingleScanAndVerify("[RSN-SAE-CCMP][ESS][MFPR]",
@@ -3253,14 +3253,14 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
     public void verifySecurityParamsSelectionForPskSaeConfigAndSaeScanNegative() {
         BitSet supportedFeatures = new BitSet();
         supportedFeatures.set(WIFI_FEATURE_WPA3_SAE, false);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(supportedFeatures);
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(supportedFeatures);
         setupMultiConfigAndSingleScanAndVerify("[RSN-SAE-CCMP][ESS][MFPR]",
                 SECURITY_PSK | SECURITY_SAE, -1);
     }
 
     @Test
     public void verifySecurityParamsSelectionForOpenOweConfigAndOweScan() {
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(WIFI_FEATURE_OWE));
         when(mWifiGlobals.isOweUpgradeEnabled()).thenReturn(true);
         setupMultiConfigAndSingleScanAndVerify("[OWE-SAE-CCMP][ESS][MFPR]",
@@ -3271,7 +3271,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
     public void verifySecurityParamsSelectionForOpenOweConfigAndOweScanNegative() {
         BitSet supportedFeatures = new BitSet();
         supportedFeatures.set(WIFI_FEATURE_OWE, false);
-        when(mClientModeManager.getSupportedFeatures()).thenReturn(supportedFeatures);
+        when(mClientModeManager.getSupportedFeaturesBitSet()).thenReturn(supportedFeatures);
         setupMultiConfigAndSingleScanAndVerify("[OWE-SAE-CCMP][ESS][MFPR]",
                 SECURITY_NONE | SECURITY_OWE, -1);
     }
@@ -3325,7 +3325,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testPskWithPskOnlyForPskSaeTransitionNetworks() {
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WIFI_FEATURE_WPA3_SAE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
         when(mWifiGlobals.isWpa3SaeUpgradeOffloadEnabled()).thenReturn(true);
@@ -3363,7 +3363,7 @@ public class WifiNetworkSelectorTest extends WifiBaseTest {
      */
     @Test
     public void testNetworkSelectionForUserSelectedNetwork() {
-        when(mClientModeManager.getSupportedFeatures())
+        when(mClientModeManager.getSupportedFeaturesBitSet())
                 .thenReturn(createCapabilityBitset(WIFI_FEATURE_WPA3_SAE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
 
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkSuggestionsManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkSuggestionsManagerTest.java
index 00aa72a519..346cc96d93 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkSuggestionsManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiNetworkSuggestionsManagerTest.java
@@ -265,7 +265,7 @@ public class WifiNetworkSuggestionsManagerTest extends WifiBaseTest {
         when(mWifiPermissionsUtil.doesUidBelongToCurrentUserOrDeviceOwner(anyInt()))
                 .thenReturn(true);
         when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mPrimaryClientModeManager);
-        when(mPrimaryClientModeManager.getSupportedFeatures()).thenReturn(
+        when(mPrimaryClientModeManager.getSupportedFeaturesBitSet()).thenReturn(
                 createCapabilityBitset(
                         WifiManager.WIFI_FEATURE_WPA3_SAE, WifiManager.WIFI_FEATURE_OWE));
         when(mWifiGlobals.isWpa3SaeUpgradeEnabled()).thenReturn(true);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiServiceImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiServiceImplTest.java
index 522967a856..0b6181aa89 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiServiceImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiServiceImplTest.java
@@ -92,9 +92,9 @@ import static org.mockito.ArgumentMatchers.anyList;
 import static org.mockito.ArgumentMatchers.anySet;
 import static org.mockito.ArgumentMatchers.notNull;
 import static org.mockito.ArgumentMatchers.nullable;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.argThat;
@@ -116,7 +116,6 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.validateMockitoUsage;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 import android.Manifest;
@@ -267,6 +266,7 @@ import com.android.server.wifi.util.ApConfigUtil;
 import com.android.server.wifi.util.LastCallerInfoManager;
 import com.android.server.wifi.util.WifiPermissionsUtil;
 import com.android.server.wifi.util.WifiPermissionsWrapper;
+import com.android.server.wifi.util.WorkSourceHelper;
 import com.android.wifi.flags.FeatureFlags;
 import com.android.wifi.resources.R;
 
@@ -376,8 +376,6 @@ public class WifiServiceImplTest extends WifiBaseTest {
     private WifiThreadRunner mWifiThreadRunner;
     private PowerManager mPowerManager;
     private PhoneStateListener mPhoneStateListener;
-    private int mPid;
-    private int mPid2 = Process.myPid();
     private OsuProvider mOsuProvider;
     private SoftApCallbackInternal mStateMachineSoftApCallback;
     private SoftApCallbackInternal mLohsApCallback;
@@ -390,7 +388,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
     private static final String DPP_PRODUCT_INFO = "DPP:some_dpp_uri_info";
     private static final WorkSource SETTINGS_WORKSOURCE =
             new WorkSource(Process.SYSTEM_UID, "system-service");
-
+    private static final String EXTERNAL_SCORER_PKG_NAME = "com.scorer";
     private final ArgumentCaptor<BroadcastReceiver> mBroadcastReceiverCaptor =
             ArgumentCaptor.forClass(BroadcastReceiver.class);
 
@@ -515,6 +513,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
     @Captor ArgumentCaptor<List> mListCaptor;
     @Mock TwtManager mTwtManager;
     @Mock WifiResourceCache mResourceCache;
+    @Mock WorkSourceHelper mWorkSourceHelper;
 
     @Rule
     // For frameworks
@@ -540,8 +539,8 @@ public class WifiServiceImplTest extends WifiBaseTest {
         when(mResourceCache.getInteger(R.integer.config_wifiHardwareSoftapMaxClientCount))
                 .thenReturn(10);
         WifiInjector.sWifiInjector = mWifiInjector;
-        when(mRequestInfo.getPid()).thenReturn(mPid);
-        when(mRequestInfo2.getPid()).thenReturn(mPid2);
+        when(mRequestInfo.getPid()).thenReturn(TEST_PID);
+        when(mRequestInfo2.getPid()).thenReturn(TEST_PID2);
         when(mWifiInjector.getContext()).thenReturn(mContext);
         when(mWifiInjector.getUserManager()).thenReturn(mUserManager);
         when(mWifiInjector.getWifiCountryCode()).thenReturn(mWifiCountryCode);
@@ -572,6 +571,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
                 .thenReturn(mWifiDeviceStateChangeManager);
         when(mWifiInjector.getWifiSettingsBackupRestore()).thenReturn(mWifiSettingsBackupRestore);
         when(mWifiInjector.getBackupRestoreController()).thenReturn(mBackupRestoreController);
+        when(mWifiInjector.makeWsHelper(any())).thenReturn(mWorkSourceHelper);
         when(mHandlerThread.getThreadHandler()).thenReturn(new Handler(mLooper.getLooper()));
         when(mHandlerThread.getLooper()).thenReturn(mLooper.getLooper());
         when(mContext.getResources()).thenReturn(mResources);
@@ -676,6 +676,11 @@ public class WifiServiceImplTest extends WifiBaseTest {
         when(mWifiPermissionsUtil.isTargetSdkLessThan(any(),
                 eq(Build.VERSION_CODES.UPSIDE_DOWN_CAKE),
                 anyInt())).thenReturn(true);
+        if (SdkLevel.isAtLeastS()) {
+            // AttributionSource arg is only available from S.
+            when(mWifiPermissionsUtil.checkNearbyDevicesPermission(any(), anyBoolean(), any()))
+                    .thenReturn(true);
+        }
         when(mWifiInjector.getWifiCarrierInfoManager()).thenReturn(mWifiCarrierInfoManager);
         when(mWifiInjector.getWifiPseudonymManager()).thenReturn(mWifiPseudonymManager);
         when(mWifiInjector.getOpenNetworkNotifier()).thenReturn(mOpenNetworkNotifier);
@@ -774,6 +779,9 @@ public class WifiServiceImplTest extends WifiBaseTest {
         mWifiConfig.networkId = TEST_NETWORK_ID;
 
         setup24GhzSupported();
+        SoftApConfiguration lohsConfig = createValidSoftApConfiguration();
+        when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
+                eq(mContext), eq(null), any(), eq(false))).thenReturn(lohsConfig);
     }
 
     /**
@@ -1834,7 +1842,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
     public void testSetWifiApConfigurationNullConfigNotSaved() throws Exception {
         when(mWifiPermissionsUtil.checkConfigOverridePermission(anyInt())).thenReturn(true);
         assertFalse(mWifiServiceImpl.setWifiApConfiguration(null, TEST_PACKAGE_NAME));
-        verify(mWifiApConfigStore, never()).setApConfiguration(isNull(SoftApConfiguration.class));
+        verify(mWifiApConfigStore, never()).setApConfiguration(isNull());
     }
 
     /**
@@ -1895,7 +1903,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
     public void testSetSoftApConfigurationNullConfigNotSaved() throws Exception {
         when(mWifiPermissionsUtil.checkConfigOverridePermission(anyInt())).thenReturn(true);
         assertFalse(mWifiServiceImpl.setSoftApConfiguration(null, TEST_PACKAGE_NAME));
-        verify(mWifiApConfigStore, never()).setApConfiguration(isNull(SoftApConfiguration.class));
+        verify(mWifiApConfigStore, never()).setApConfiguration(isNull());
         verify(mActiveModeWarden, never()).updateSoftApConfiguration(any());
         verify(mWifiPermissionsUtil).checkConfigOverridePermission(anyInt());
     }
@@ -2387,6 +2395,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
      */
     @Test
     public void testStartTetheredHotspotRequestWithPermissions() {
+        assumeTrue(Build.VERSION.SDK_INT < Build.VERSION_CODES.BAKLAVA);
         TetheringManager.TetheringRequest request = new TetheringManager.TetheringRequest.Builder(
                 TetheringManager.TETHERING_WIFI).build();
         mWifiServiceImpl.startTetheredHotspotRequest(request,
@@ -2399,6 +2408,27 @@ public class WifiServiceImplTest extends WifiBaseTest {
                 anyInt(), anyInt(), anyString(), eq(true));
     }
 
+    /**
+     * Verify startTetheredHotspot with TetheringRequest use the TetheringRequest's config.
+     */
+    @Test
+    public void testStartTetheredHotspotRequestWithSoftApConfiguration() {
+        assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.BAKLAVA);
+        SoftApConfiguration config = createValidSoftApConfiguration();
+        TetheringManager.TetheringRequest request = new TetheringManager.TetheringRequest.Builder(
+                TetheringManager.TETHERING_WIFI)
+                .setSoftApConfiguration(config)
+                .build();
+        mWifiServiceImpl.startTetheredHotspotRequest(request,
+                mClientSoftApCallback, TEST_PACKAGE_NAME);
+        verify(mActiveModeWarden).startSoftAp(mSoftApModeConfigCaptor.capture(),
+                eq(new WorkSource(Binder.getCallingUid(), TEST_PACKAGE_NAME)));
+        assertThat(mSoftApModeConfigCaptor.getValue().getSoftApConfiguration()).isEqualTo(config);
+        assertThat(mSoftApModeConfigCaptor.getValue().getTetheringRequest()).isEqualTo(request);
+        verify(mLastCallerInfoManager).put(eq(WifiManager.API_TETHERED_HOTSPOT), anyInt(),
+                anyInt(), anyInt(), anyString(), eq(true));
+    }
+
     /**
      * Verify caller with proper permissions but an invalid config does not start softap.
      */
@@ -3826,9 +3856,8 @@ public class WifiServiceImplTest extends WifiBaseTest {
      */
     @Test
     public void testStopLocalOnlyHotspotDoesNothingWithRemainingRequest() throws Exception {
-
         // register a request that will remain after the stopLOHS call
-        mWifiServiceImpl.registerLOHSForTest(mPid, mRequestInfo);
+        mWifiServiceImpl.registerLOHSForTest(TEST_PID, mRequestInfo);
         mLooper.dispatchAll();
         setupLocalOnlyHotspot();
         // Since we are calling with the same pid, the second register call will be removed
@@ -3866,10 +3895,10 @@ public class WifiServiceImplTest extends WifiBaseTest {
     public void testStartLocalOnlyHotspotAt2Ghz() {
         SoftApConfiguration lohsConfig = createValidSoftApConfiguration();
         when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(null), any())).thenReturn(lohsConfig);
+                eq(mContext), eq(null), any(), eq(false))).thenReturn(lohsConfig);
         registerLOHSRequestFull();
         verify(mWifiApConfigStore).generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(null), any());
+                eq(mContext), eq(null), any(), eq(false));
         verifyLohsBand(SoftApConfiguration.BAND_2GHZ);
     }
 
@@ -3946,7 +3975,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
                 .build();
 
         setupForCustomLohs();
-        mWifiServiceImpl.registerLOHSForTest(mPid,
+        mWifiServiceImpl.registerLOHSForTest(TEST_PID,
                 new LocalOnlyHotspotRequestInfo(mLooper.getLooper(), new WorkSource(),
                         sharedCallback, WifiServiceImplTest::nopDeathCallback, null));
         assertThat(mWifiServiceImpl.startLocalOnlyHotspot(exclusiveCallback, TEST_PACKAGE_NAME,
@@ -3958,15 +3987,18 @@ public class WifiServiceImplTest extends WifiBaseTest {
 
     @Test
     public void testCustomLohs_ExclusiveBeforeShared() {
+        when(mWorkSourceHelper.getRequestorWsPriority())
+                .thenReturn(WorkSourceHelper.PRIORITY_SYSTEM);
         mLooper.startAutoDispatch();
         FakeLohsCallback sharedCallback = new FakeLohsCallback();
         FakeLohsCallback exclusiveCallback = new FakeLohsCallback();
         SoftApConfiguration exclusiveConfig = new SoftApConfiguration.Builder()
                 .setSsid("customSsid")
                 .build();
-
+        when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
+                eq(mContext), eq(exclusiveConfig), any(), eq(true))).thenReturn(exclusiveConfig);
         setupForCustomLohs();
-        mWifiServiceImpl.registerLOHSForTest(mPid,
+        mWifiServiceImpl.registerLOHSForTest(TEST_PID,
                 new LocalOnlyHotspotRequestInfo(mLooper.getLooper(), new WorkSource(),
                         exclusiveCallback, WifiServiceImplTest::nopDeathCallback, exclusiveConfig));
         stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
@@ -3983,7 +4015,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
                 .setPassphrase("passphrase", SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                 .build();
         when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(config), any())).thenReturn(config);
+                eq(mContext), eq(config), any(), eq(true))).thenReturn(config);
         FakeLohsCallback callback = new FakeLohsCallback();
         mLooper.startAutoDispatch();
         setupForCustomLohs();
@@ -3992,7 +4024,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
                         config, mExtras, true)).isEqualTo(REQUEST_REGISTERED);
         stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
         verify(mWifiApConfigStore).generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(config), any());
+                eq(mContext), eq(config), any(), eq(true));
         // Use app's worksouce.
         verify(mActiveModeWarden).startSoftAp(any(),
                 eq(new WorkSource(Binder.getCallingUid(), TEST_PACKAGE_NAME)));
@@ -4009,7 +4041,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
                 .setSsid("customSsid")
                 .build();
         when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(config), any())).thenReturn(config);
+                eq(mContext), eq(config), any(), eq(true))).thenReturn(config);
         FakeLohsCallback callback = new FakeLohsCallback();
         mLooper.startAutoDispatch();
         setupForCustomLohs();
@@ -4018,7 +4050,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
                         config, mExtras, true)).isEqualTo(REQUEST_REGISTERED);
         stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
         verify(mWifiApConfigStore).generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(config), any());
+                eq(mContext), eq(config), any(), eq(true));
         // Use app's worksouce.
         verify(mActiveModeWarden).startSoftAp(any(),
                 eq(new WorkSource(Binder.getCallingUid(), TEST_PACKAGE_NAME)));
@@ -4036,7 +4068,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
                 .setPassphrase("passphrase", SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                 .build();
         when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(customizedConfig), any()))
+                eq(mContext), eq(customizedConfig), any(), eq(true)))
                 .thenReturn(lohsConfig);
         mLooper.startAutoDispatch();
         FakeLohsCallback callback = new FakeLohsCallback();
@@ -4047,7 +4079,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
                         customizedConfig, mExtras, true)).isEqualTo(REQUEST_REGISTERED);
         stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
         verify(mWifiApConfigStore).generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(customizedConfig), any());
+                eq(mContext), eq(customizedConfig), any(), eq(true));
         // Use app's worksouce.
         verify(mActiveModeWarden).startSoftAp(any(),
                 eq(new WorkSource(Binder.getCallingUid(), TEST_PACKAGE_NAME)));
@@ -4068,7 +4100,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
         }
         SoftApConfiguration customizedConfig = customizedConfigBuilder.build();
         when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(customizedConfig), any()))
+                eq(mContext), eq(customizedConfig), any(), eq(true)))
                 .thenReturn(customizedConfig);
         FakeLohsCallback callback = new FakeLohsCallback();
 
@@ -4080,7 +4112,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
 
         // Use app's worksouce.
         verify(mWifiApConfigStore).generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(customizedConfig), any());
+                eq(mContext), eq(customizedConfig), any(), eq(true));
         verify(mActiveModeWarden).startSoftAp(any(),
                 eq(new WorkSource(Binder.getCallingUid(), TEST_PACKAGE_NAME)));
         assertThat(callback.mIsStarted).isTrue();
@@ -4114,7 +4146,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
 
         // registering a request directly from the test will not trigger a message to start
         // softap mode
-        mWifiServiceImpl.registerLOHSForTest(mPid, mRequestInfo);
+        mWifiServiceImpl.registerLOHSForTest(TEST_PID, mRequestInfo);
         mLooper.dispatchAll();
 
         setupLocalOnlyHotspot();
@@ -4495,7 +4527,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
         changeLohsState(WIFI_AP_STATE_ENABLED, WIFI_AP_STATE_DISABLED, HOTSPOT_NO_ERROR);
 
         mLooper.dispatchAll();
-        verifyZeroInteractions(ignoreStubs(mLohsCallback));
+        verifyNoMoreInteractions(ignoreStubs(mLohsCallback));
     }
 
     /**
@@ -4633,10 +4665,10 @@ public class WifiServiceImplTest extends WifiBaseTest {
             throws Exception {
         SoftApConfiguration lohsConfig = createValidSoftApConfiguration();
         when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(null), any())).thenReturn(lohsConfig);
+                eq(mContext), eq(null), any(), eq(false))).thenReturn(lohsConfig);
         registerLOHSRequestFull();
         verify(mWifiApConfigStore).generateLocalOnlyHotspotConfig(
-                eq(mContext), eq(null), any());
+                eq(mContext), eq(null), any(), eq(false));
         mWifiServiceImpl.registerLOHSForTest(TEST_PID, mRequestInfo);
 
         mWifiServiceImpl.updateInterfaceIpState(WIFI_IFACE_NAME, IFACE_IP_MODE_LOCAL_ONLY);
@@ -4686,7 +4718,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
         // unregistered
         mWifiServiceImpl.updateInterfaceIpState(WIFI_IFACE_NAME, IFACE_IP_MODE_CONFIGURATION_ERROR);
         mLooper.dispatchAll();
-        verifyZeroInteractions(ignoreStubs(mLohsCallback));
+        verifyNoMoreInteractions(ignoreStubs(mLohsCallback));
     }
 
     /**
@@ -4724,7 +4756,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
         clearInvocations(mLohsCallback);
 
         mWifiServiceImpl.updateInterfaceIpState(WIFI_IFACE_NAME, IFACE_IP_MODE_TETHERED);
-        verifyZeroInteractions(ignoreStubs(mLohsCallback));
+        verifyNoMoreInteractions(ignoreStubs(mLohsCallback));
     }
 
     /**
@@ -4735,7 +4767,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
     public void testRegisterLocalOnlyHotspotRequestWhenStoppedDoesNotGetOnStoppedCallback()
             throws Exception {
         registerLOHSRequestFull();
-        verifyZeroInteractions(ignoreStubs(mLohsCallback));
+        verifyNoMoreInteractions(ignoreStubs(mLohsCallback));
     }
 
     /**
@@ -6574,6 +6606,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
         mBroadcastReceiverCaptor.getValue().onReceive(mContext, intent);
         mLooper.dispatchAll();
 
+        verify(mResourceCache).reset();
         verify(mWifiConfigManager).resetSimNetworks();
         verify(mWifiConfigManager).stopRestrictingAutoJoinToSubscriptionId();
         verify(mSimRequiredNotifier, never()).dismissSimRequiredNotification();
@@ -6602,6 +6635,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
         mBroadcastReceiverCaptor.getValue().onReceive(mContext, intent);
         mLooper.dispatchAll();
 
+        verify(mResourceCache).reset();
         verify(mWifiConfigManager, never()).resetSimNetworks();
         verify(mPasspointManager, never()).resetSimPasspointNetwork();
         verify(mWifiNetworkSuggestionsManager, never()).resetSimNetworkSuggestions();
@@ -6629,6 +6663,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
         mBroadcastReceiverCaptor.getValue().onReceive(mContext, intent);
         mLooper.dispatchAll();
 
+        verify(mResourceCache).reset();
         verify(mWifiConfigManager).resetSimNetworks();
         verify(mWifiConfigManager).stopRestrictingAutoJoinToSubscriptionId();
         verify(mSimRequiredNotifier, never()).dismissSimRequiredNotification();
@@ -7891,7 +7926,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
         startLohsAndTethering(true);
 
         // verify LOHS didn't get stopped
-        verifyZeroInteractions(ignoreStubs(mLohsCallback));
+        verifyNoMoreInteractions(ignoreStubs(mLohsCallback));
         verify(mActiveModeWarden, never()).stopSoftAp(anyInt());
     }
 
@@ -9177,9 +9212,15 @@ public class WifiServiceImplTest extends WifiBaseTest {
      */
     @Test
     public void testSetWifiConnectedNetworkScorerAndVerify() throws Exception {
+        when(mPackageManager.getPackagesForUid(anyInt()))
+                .thenReturn(new String[]{EXTERNAL_SCORER_PKG_NAME});
+        when(mContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);
         mLooper.startAutoDispatch();
+
         mWifiServiceImpl.setWifiConnectedNetworkScorer(mAppBinder, mWifiConnectedNetworkScorer);
         mLooper.stopAutoDispatch();
+
+        assertNotNull(mWifiServiceImpl.mScorerServiceConnection);
         verify(mActiveModeWarden).setWifiConnectedNetworkScorer(
                 mAppBinder, mWifiConnectedNetworkScorer, myUid());
     }
@@ -9187,10 +9228,31 @@ public class WifiServiceImplTest extends WifiBaseTest {
     /**
      * Verify that clearWifiConnectedNetworkScorer clears scorer from {@link WifiScoreReport}.
      */
+    @Test
+    public void testClearWifiConnectedNetworkScorerUnbindService() throws Exception {
+        when(mPackageManager.getPackagesForUid(anyInt()))
+                .thenReturn(new String[]{EXTERNAL_SCORER_PKG_NAME});
+        when(mContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);
+        mLooper.startAutoDispatch();
+        mWifiServiceImpl.setWifiConnectedNetworkScorer(mAppBinder, mWifiConnectedNetworkScorer);
+        mLooper.stopAutoDispatch();
+        assertNotNull(mWifiServiceImpl.mScorerServiceConnection);
+
+        mWifiServiceImpl.clearWifiConnectedNetworkScorer();
+        mLooper.dispatchAll();
+
+        verify(mContext).unbindService(any());
+        verify(mActiveModeWarden).clearWifiConnectedNetworkScorer();
+    }
+
     @Test
     public void testClearWifiConnectedNetworkScorerAndVerify() throws Exception {
+        mWifiServiceImpl.mScorerServiceConnection = null;
+
         mWifiServiceImpl.clearWifiConnectedNetworkScorer();
         mLooper.dispatchAll();
+
+        verify(mContext, never()).unbindService(any());
         verify(mActiveModeWarden).clearWifiConnectedNetworkScorer();
     }
 
@@ -9721,6 +9783,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
 
         Intent intent = new Intent(Intent.ACTION_LOCALE_CHANGED);
         mBroadcastReceiverCaptor.getValue().onReceive(mContext, intent);
+        verify(mResourceCache).handleLocaleChange();
         verify(mWifiNotificationManager).createNotificationChannels();
         verify(mWifiNetworkSuggestionsManager).resetNotification();
         verify(mWifiCarrierInfoManager).resetNotification();
@@ -10196,15 +10259,24 @@ public class WifiServiceImplTest extends WifiBaseTest {
                                 ScanResult.CHANNEL_WIDTH_20MHZ)));
         when(mWifiNative.getUsableChannels(eq(WIFI_BAND_60_GHZ), anyInt(), anyInt()))
                 .thenReturn(null);
-
         mWifiServiceImpl.mCountryCodeTracker.onDriverCountryCodeChanged(TEST_COUNTRY_CODE);
         mLooper.dispatchAll();
-
         verify(mWifiSettingsConfigStore).put(
                 eq(WifiSettingsConfigStore.WIFI_SOFT_AP_COUNTRY_CODE), eq(TEST_COUNTRY_CODE));
         verify(mWifiSettingsConfigStore).put(
                 eq(WifiSettingsConfigStore.WIFI_AVAILABLE_SOFT_AP_FREQS_MHZ),
                 eq("[2452,5180,5955]"));
+
+        // Make sure CC change to world mode won't update WIFI_SOFT_AP_COUNTRY_CODE
+        when(mWifiSettingsConfigStore.get(WifiSettingsConfigStore.WIFI_SOFT_AP_COUNTRY_CODE))
+                .thenReturn(TEST_COUNTRY_CODE);
+        when(mWifiCountryCode.isDriverCountryCodeWorldMode()).thenReturn(true);
+        String testWorldModeCountryCode = "00";
+        mWifiServiceImpl.mCountryCodeTracker.onDriverCountryCodeChanged(testWorldModeCountryCode);
+        mLooper.dispatchAll();
+        verify(mWifiSettingsConfigStore, never()).put(
+                eq(WifiSettingsConfigStore.WIFI_SOFT_AP_COUNTRY_CODE),
+                        eq(testWorldModeCountryCode));
     }
 
     private List<WifiConfiguration> setupMultiTypeConfigs(
@@ -10813,7 +10885,7 @@ public class WifiServiceImplTest extends WifiBaseTest {
                 .setPassphrase("thisIsABadPassword", SoftApConfiguration.SECURITY_TYPE_WPA3_SAE)
                 .build();
         when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
-                any(), any(), any())).thenReturn(customizedConfig);
+                any(), any(), any(), eq(true))).thenReturn(customizedConfig);
         // Expect the result is registered but it should get failure because non-supported
         // configuration
         int result = mWifiServiceImpl.startLocalOnlyHotspot(mLohsCallback, TEST_PACKAGE_NAME,
@@ -10858,6 +10930,8 @@ public class WifiServiceImplTest extends WifiBaseTest {
     @Test
     public void unregisterLohsSoftApCallbackRemovesCallback() throws Exception {
         assumeTrue(SdkLevel.isAtLeastT());
+        AttributionSource attributionSource = mock(AttributionSource.class);
+        mExtras.putParcelable(WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE, attributionSource);
         registerLohsSoftApCallbackAndVerify(mClientSoftApCallback, mExtras);
 
         mWifiServiceImpl.unregisterLocalOnlyHotspotSoftApCallback(mClientSoftApCallback, mExtras);
@@ -10878,6 +10952,8 @@ public class WifiServiceImplTest extends WifiBaseTest {
     public void unregisterLohsSoftApCallbackDoesNotRemoveCallbackIfCallbackNotMatching()
             throws Exception {
         assumeTrue(SdkLevel.isAtLeastT());
+        AttributionSource attributionSource = mock(AttributionSource.class);
+        mExtras.putParcelable(WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE, attributionSource);
         registerLohsSoftApCallbackAndVerify(mClientSoftApCallback, mExtras);
 
         mWifiServiceImpl.unregisterLocalOnlyHotspotSoftApCallback(mAnotherSoftApCallback, mExtras);
@@ -10899,6 +10975,8 @@ public class WifiServiceImplTest extends WifiBaseTest {
         assumeTrue(SdkLevel.isAtLeastT());
         WifiClient testWifiClient = new WifiClient(MacAddress.fromString("22:33:44:55:66:77"),
                 WIFI_IFACE_NAME2);
+        AttributionSource attributionSource = mock(AttributionSource.class);
+        mExtras.putParcelable(WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE, attributionSource);
         registerLohsSoftApCallbackAndVerify(mClientSoftApCallback, mExtras);
         mLooper.dispatchAll();
 
@@ -10944,6 +11022,8 @@ public class WifiServiceImplTest extends WifiBaseTest {
     @Test
     public void registersForBinderDeathOnRegisterLohsSoftApCallback() throws Exception {
         assumeTrue(SdkLevel.isAtLeastT());
+        AttributionSource attributionSource = mock(AttributionSource.class);
+        mExtras.putParcelable(WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE, attributionSource);
         registerLohsSoftApCallbackAndVerify(mClientSoftApCallback, mExtras);
         verify(mAppBinder).linkToDeath(any(IBinder.DeathRecipient.class), anyInt());
     }
@@ -10956,6 +11036,8 @@ public class WifiServiceImplTest extends WifiBaseTest {
         assumeTrue(SdkLevel.isAtLeastT());
         ArgumentCaptor<IBinder.DeathRecipient> drCaptor =
                 ArgumentCaptor.forClass(IBinder.DeathRecipient.class);
+        AttributionSource attributionSource = mock(AttributionSource.class);
+        mExtras.putParcelable(WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE, attributionSource);
         registerLohsSoftApCallbackAndVerify(mClientSoftApCallback, mExtras);
         verify(mAppBinder).linkToDeath(drCaptor.capture(), anyInt());
 
@@ -11002,6 +11084,31 @@ public class WifiServiceImplTest extends WifiBaseTest {
         mWifiServiceImpl.unregisterLocalOnlyHotspotSoftApCallback(mClientSoftApCallback, mExtras);
     }
 
+    /**
+     * Verifies that a LOHS SoftApCallback is ignored if its AttributionSource no longer has the
+     * NEARBY_WIFI_DEVICES permission
+     */
+    @Test
+    public void testRegisterLocalOnlyHotspotSoftApCallbackIgnoredWhenPermissionRevoked()
+            throws Exception {
+        assumeTrue(SdkLevel.isAtLeastT());
+        AttributionSource attributionSource = mock(AttributionSource.class);
+        mExtras.putParcelable(WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE, attributionSource);
+        registerLohsSoftApCallbackAndVerify(mClientSoftApCallback, mExtras);
+
+        // Revoke NEARBY_WIFI_DEVICES permission
+        when(mWifiPermissionsUtil.checkNearbyDevicesPermission(any(), anyBoolean(), any()))
+                .thenReturn(false);
+
+        // Callback should be ignored
+        reset(mClientSoftApCallback);
+        mLohsApCallback.onConnectedClientsOrInfoChanged(
+                mTestSoftApInfos, mTestSoftApClients, false);
+        mLooper.dispatchAll();
+        verify(mClientSoftApCallback, never()).onConnectedClientsOrInfoChanged(
+                any(), any(), anyBoolean(), anyBoolean());
+    }
+
     /**
      * Verify getStaConcurrencyForMultiInternetMode
      */
@@ -13178,4 +13285,124 @@ public class WifiServiceImplTest extends WifiBaseTest {
             fail("expected SecurityException");
         } catch (SecurityException expected) { }
     }
+
+    @Test
+    public void testCustomLohs_NotExclusive5GConfigButNewRequestorLowerPriority() {
+        assumeTrue(Environment.isSdkAtLeastB());
+        when(mFeatureFlags.publicBandsForLohs()).thenReturn(true);
+        when(mWorkSourceHelper.getRequestorWsPriority())
+                .thenReturn(WorkSourceHelper.PRIORITY_FG_APP)
+                .thenReturn(WorkSourceHelper.PRIORITY_BG);
+        setupForCustomLohs();
+        setup5GhzSupported();
+        SoftApConfiguration custom5GBandConfig = new SoftApConfiguration.Builder()
+                .setSsid("TestAp")
+                .setBand(SoftApConfiguration.BAND_5GHZ)
+                .build();
+        when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
+                any(), any(), any(), eq(false))).thenReturn(custom5GBandConfig);
+        when(mRequestInfo.getCustomConfig()).thenReturn(custom5GBandConfig);
+        when(mRequestInfo2.getCustomConfig()).thenReturn(null);
+        mLooper.startAutoDispatch();
+        assertThat(mWifiServiceImpl.registerLOHSForTest(TEST_PID, mRequestInfo))
+                .isEqualTo(REQUEST_REGISTERED);
+        stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
+        // Test second requestor gets fail since it has lower priority
+        assertThat(mWifiServiceImpl.registerLOHSForTest(TEST_PID2, mRequestInfo2))
+                .isEqualTo(ERROR_GENERIC);
+    }
+
+    @Test
+    public void testCustomLohs_NotExclusive2GConfigSharedEvenIfNewRequestorLowerPriority()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        when(mFeatureFlags.publicBandsForLohs()).thenReturn(true);
+        when(mWorkSourceHelper.getRequestorWsPriority())
+                .thenReturn(WorkSourceHelper.PRIORITY_FG_APP)
+                .thenReturn(WorkSourceHelper.PRIORITY_BG);
+        setupForCustomLohs();
+        SoftApConfiguration custom2GBandConfig = new SoftApConfiguration.Builder()
+                .setSsid("TestAp")
+                .setBand(SoftApConfiguration.BAND_2GHZ)
+                .build();
+        when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
+                any(), any(), any(), eq(false))).thenReturn(custom2GBandConfig);
+        when(mRequestInfo.getCustomConfig()).thenReturn(custom2GBandConfig);
+        when(mRequestInfo2.getCustomConfig()).thenReturn(null);
+        mLooper.startAutoDispatch();
+        assertThat(mWifiServiceImpl.registerLOHSForTest(TEST_PID, mRequestInfo))
+                .isEqualTo(REQUEST_REGISTERED);
+        stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
+        mLooper.startAutoDispatch();
+        // Test second requestor gets registered even if it has lower priority
+        assertThat(mWifiServiceImpl.registerLOHSForTest(TEST_PID2, mRequestInfo2))
+                .isEqualTo(REQUEST_REGISTERED);
+        verify(mRequestInfo, never()).unlinkDeathRecipient();
+        verify(mRequestInfo2).sendHotspotStartedMessage(eq(custom2GBandConfig));
+        stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
+    }
+
+    @Test
+    public void testCustomLohs_NotExclusive5GConfigButNewRequestorHigherPriority()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        when(mFeatureFlags.publicBandsForLohs()).thenReturn(true);
+        when(mWorkSourceHelper.getRequestorWsPriority())
+                .thenReturn(WorkSourceHelper.PRIORITY_FG_APP) // first requestor
+                .thenReturn(WorkSourceHelper.PRIORITY_FG_APP) // new requestor
+                .thenReturn(WorkSourceHelper.PRIORITY_BG); // first requestor to BG
+        setupForCustomLohs();
+        setup5GhzSupported();
+        SoftApConfiguration custom5GBandConfig = new SoftApConfiguration.Builder()
+                .setSsid("TestAp")
+                .setBand(SoftApConfiguration.BAND_5GHZ)
+                .build();
+        when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
+                any(), any(), any(), eq(false))).thenReturn(custom5GBandConfig);
+        when(mRequestInfo.getCustomConfig()).thenReturn(custom5GBandConfig);
+        when(mRequestInfo2.getCustomConfig()).thenReturn(null);
+        mLooper.startAutoDispatch();
+        assertThat(mWifiServiceImpl.registerLOHSForTest(TEST_PID, mRequestInfo))
+                .isEqualTo(REQUEST_REGISTERED);
+        stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
+        mLooper.startAutoDispatch();
+        // Test second requestor gets succeeded since it has higher priority
+        assertThat(mWifiServiceImpl.registerLOHSForTest(TEST_PID2, mRequestInfo2))
+                .isEqualTo(REQUEST_REGISTERED);
+        // Make sure first requestor dead since it was replaced by second requestor.
+        verify(mRequestInfo).sendHotspotFailedMessage(eq(ERROR_INCOMPATIBLE_MODE));
+        verify(mRequestInfo).unlinkDeathRecipient();
+        stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
+    }
+
+    @Test
+    public void testCustomLohs_NotExclusive2GConfigSharedWhenNewRequestorHihgerPriority()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        when(mFeatureFlags.publicBandsForLohs()).thenReturn(true);
+        when(mWorkSourceHelper.getRequestorWsPriority())
+                .thenReturn(WorkSourceHelper.PRIORITY_BG)
+                .thenReturn(WorkSourceHelper.PRIORITY_FG_APP);
+        setupForCustomLohs();
+        SoftApConfiguration custom2GBandConfig = new SoftApConfiguration.Builder()
+                .setSsid("TestAp")
+                .setBand(SoftApConfiguration.BAND_2GHZ)
+                .build();
+        when(mWifiApConfigStore.generateLocalOnlyHotspotConfig(
+                any(), any(), any(), eq(false))).thenReturn(custom2GBandConfig);
+        when(mRequestInfo.getCustomConfig()).thenReturn(custom2GBandConfig);
+        when(mRequestInfo2.getCustomConfig()).thenReturn(null);
+        mLooper.startAutoDispatch();
+        assertThat(mWifiServiceImpl.registerLOHSForTest(TEST_PID, mRequestInfo))
+                .isEqualTo(REQUEST_REGISTERED);
+        stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
+        mLooper.startAutoDispatch();
+        // Test second requestor gets succeeded since it has higher priority
+        assertThat(mWifiServiceImpl.registerLOHSForTest(TEST_PID2, mRequestInfo2))
+                .isEqualTo(REQUEST_REGISTERED);
+        // Make sure first requestor still alive since 2.4G can be shared.
+        verify(mRequestInfo2).sendHotspotStartedMessage(eq(custom2GBandConfig));
+        verify(mRequestInfo, never()).unlinkDeathRecipient();
+        stopAutoDispatchWithDispatchAllBeforeStopAndIgnoreExceptions(mLooper);
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiSettingsStoreTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiSettingsStoreTest.java
index 0f78f921af..0e4cf81c67 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiSettingsStoreTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiSettingsStoreTest.java
@@ -37,8 +37,8 @@ import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
diff --git a/service/tests/wifitests/src/com/android/server/wifi/WifiVendorHalTest.java b/service/tests/wifitests/src/com/android/server/wifi/WifiVendorHalTest.java
index b1ba78ec3c..13d883eda8 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/WifiVendorHalTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/WifiVendorHalTest.java
@@ -32,7 +32,6 @@ import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyInt;
-import static org.mockito.Mockito.anyObject;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.mock;
@@ -1421,7 +1420,7 @@ public class WifiVendorHalTest extends WifiBaseTest {
         mWifiChipEventCallback.onDebugRingBufferDataAvailable(
                 new WifiNative.RingBufferStatus(), errorData);
         mLooper.dispatchAll();
-        verify(eventHandler, never()).onRingBufferData(anyObject(), anyObject());
+        verify(eventHandler, never()).onRingBufferData(any(), any());
     }
 
     /**
@@ -1683,7 +1682,7 @@ public class WifiVendorHalTest extends WifiBaseTest {
         assertTrue(mWifiVendorHal.resetLogHandler());
         chipCallback.onDebugErrorAlert(errorCode, errorData);
         mLooper.dispatchAll();
-        verify(eventHandler, never()).onWifiAlert(anyInt(), anyObject());
+        verify(eventHandler, never()).onWifiAlert(anyInt(), any());
     }
 
     private void startBgScan(WifiNative.ScanEventHandler eventHandler) throws Exception {
diff --git a/service/tests/wifitests/src/com/android/server/wifi/aware/WifiAwareNativeApiTest.java b/service/tests/wifitests/src/com/android/server/wifi/aware/WifiAwareNativeApiTest.java
index e53efc1884..97076e1dbf 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/aware/WifiAwareNativeApiTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/aware/WifiAwareNativeApiTest.java
@@ -24,7 +24,7 @@ import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyShort;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
diff --git a/service/tests/wifitests/src/com/android/server/wifi/aware/WifiAwareStateManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/aware/WifiAwareStateManagerTest.java
index c2f2e835d8..a4ebf7b185 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/aware/WifiAwareStateManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/aware/WifiAwareStateManagerTest.java
@@ -34,7 +34,6 @@ import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
-import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyByte;
@@ -42,6 +41,7 @@ import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyShort;
 import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.isNull;
 import static org.mockito.Mockito.atLeastOnce;
@@ -121,7 +121,6 @@ import com.android.server.wifi.WifiSettingsConfigStore;
 import com.android.server.wifi.WifiThreadRunner;
 import com.android.server.wifi.hal.WifiNanIface.NanRangingIndication;
 import com.android.server.wifi.hal.WifiNanIface.NanStatusCode;
-import com.android.server.wifi.proto.WifiStatsLog;
 import com.android.server.wifi.util.NetdWrapper;
 import com.android.server.wifi.util.WaitingState;
 import com.android.server.wifi.util.WifiPermissionsUtil;
@@ -217,7 +216,6 @@ public class WifiAwareStateManagerTest extends WifiBaseTest {
         mSession = ExtendedMockito.mockitoSession()
                 .strictness(Strictness.LENIENT)
                 .mockStatic(WifiInjector.class)
-                .mockStatic(WifiStatsLog.class)
                 .startMocking();
 
         when(WifiInjector.getInstance()).thenReturn(mWifiInjector);
@@ -319,8 +317,6 @@ public class WifiAwareStateManagerTest extends WifiBaseTest {
                 mPullAtomCallbackArgumentCaptor.capture());
         assertEquals(StatsManager.PULL_SUCCESS, mPullAtomCallbackArgumentCaptor.getValue()
                 .onPullAtom(WIFI_AWARE_CAPABILITIES, new ArrayList<>()));
-        ExtendedMockito.verify(() -> WifiStatsLog.buildStatsEvent(
-                WIFI_AWARE_CAPABILITIES, true, true, true, 0, 1, 1, 2));
     }
 
     /**
@@ -2975,7 +2971,7 @@ public class WifiAwareStateManagerTest extends WifiBaseTest {
                 null, messageId, 0);
         mMockLooper.dispatchAll();
         inOrder.verify(mMockNative).sendMessage(transactionId.capture(), eq(subscribeId),
-                eq(requestorId), eq(peerMac), isNull(byte[].class), eq(messageId));
+                eq(requestorId), eq(peerMac), isNull(), eq(messageId));
         short tid = transactionId.getValue();
         mDut.onMessageSendQueuedSuccessResponse(tid);
         mMockLooper.dispatchAll();
@@ -3877,6 +3873,7 @@ public class WifiAwareStateManagerTest extends WifiBaseTest {
         validateCorrectAwareStatusChangeBroadcast(inOrder);
         inOrder.verify(mMockNative).disable(transactionId.capture());
         mDut.onDisableResponse(transactionId.getValue(), NanStatusCode.SUCCESS);
+        mDut.onAwareDownNotification(NanStatusCode.SUCCESS);
         mMockLooper.dispatchAll();
         assertFalse(mDut.isDeviceAttached());
         collector.checkThat("usage disabled", mDut.isUsageEnabled(), equalTo(false));
diff --git a/service/tests/wifitests/src/com/android/server/wifi/hal/WifiRttControllerAidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/hal/WifiRttControllerAidlImplTest.java
index 199b0e3313..16eec8465d 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/hal/WifiRttControllerAidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/hal/WifiRttControllerAidlImplTest.java
@@ -20,11 +20,14 @@ import static org.hamcrest.core.IsEqual.equalTo;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.clearInvocations;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
+import android.hardware.wifi.Akm;
+import android.hardware.wifi.CipherSuite;
 import android.hardware.wifi.IWifiRttController;
 import android.hardware.wifi.IWifiRttControllerEventCallback;
 import android.hardware.wifi.RttBw;
@@ -87,6 +90,7 @@ public class WifiRttControllerAidlImplTest extends WifiBaseTest {
         verify(mIWifiRttControllerMock)
                 .registerEventCallback(mEventCallbackCaptor.capture());
         verify(mIWifiRttControllerMock).getCapabilities();
+        clearInvocations(mIWifiRttControllerMock);
     }
 
     /**
@@ -125,6 +129,79 @@ public class WifiRttControllerAidlImplTest extends WifiBaseTest {
 
     }
 
+    /**
+     * Validate successful 802.11az secure ranging flow.
+     */
+    @Test
+    public void testOpportunisticSecureRangeRequest() throws Exception {
+        int cmdId = 66;
+        RangingRequest request = RttTestUtils.getDummySecureRangingRequest(
+                RangingRequest.SECURITY_MODE_OPPORTUNISTIC);
+        // Issue range request
+        mDut.rangeRequest(cmdId, request);
+        // Verify HAL call and parameters
+        verify(mIWifiRttControllerMock).rangeRequest(eq(cmdId), mRttConfigCaptor.capture());
+        // Verify contents of HAL request (hard codes knowledge from getDummySecureRangingRequest
+        RttConfig[] halRequest = mRttConfigCaptor.getValue();
+        collector.checkThat("number of entries", halRequest.length,
+                equalTo(request.mRttPeers.size()));
+        verifyNoMoreInteractions(mIWifiRttControllerMock);
+
+        // 1. SAE with password
+        RttConfig rttConfig = halRequest[0];
+        collector.checkThat("entry 0: MAC", rttConfig.type,
+                equalTo(RttType.TWO_SIDED_11AZ_NTB_SECURE));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.enableSecureHeLtf,
+                equalTo(true));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnComebackCookie,
+                equalTo(new byte[]{1, 2, 3, 4, 5}));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.baseAkm,
+                equalTo(Akm.SAE));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.cipherSuite,
+                equalTo(CipherSuite.GCMP_256));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.passphrase,
+                equalTo("TEST_PASSWORD".getBytes()));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.pmkid,
+                equalTo(null));
+
+        // 2. SAE with no password will downgraded to unauthenticated PASN in case of
+        // SECURITY_MODE_OPPORTUNISTIC
+        rttConfig = halRequest[1];
+        collector.checkThat("entry 0: MAC", rttConfig.type,
+                equalTo(RttType.TWO_SIDED_11AZ_NTB_SECURE));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.enableSecureHeLtf,
+                equalTo(true));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnComebackCookie,
+                equalTo(null));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.baseAkm,
+                equalTo(Akm.PASN));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.cipherSuite,
+                equalTo(CipherSuite.GCMP_256));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.passphrase,
+                equalTo(null));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.pmkid,
+                equalTo(null));
+
+        // 3. Secure ranging with unauthenticated PASN
+        rttConfig = halRequest[2];
+        collector.checkThat("entry 0: MAC", rttConfig.type,
+                equalTo(RttType.TWO_SIDED_11AZ_NTB_SECURE));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.enableSecureHeLtf,
+                equalTo(true));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnComebackCookie,
+                equalTo(null));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.baseAkm,
+                equalTo(Akm.PASN));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.cipherSuite,
+                equalTo(CipherSuite.GCMP_256));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig.pasnConfig.pmkid,
+                equalTo(null));
+
+        // 4. Open security will use TWO_SIDED_11AZ_NTB
+        rttConfig = halRequest[3];
+        collector.checkThat("entry 0: MAC", rttConfig.type, equalTo(RttType.TWO_SIDED_11AZ_NTB));
+        collector.checkThat("entry 0: secure Config", rttConfig.secureConfig, equalTo(null));
+    }
     /**
      * Validate successful ranging flow.
      */
@@ -258,6 +335,61 @@ public class WifiRttControllerAidlImplTest extends WifiBaseTest {
         verifyNoMoreInteractions(mIWifiRttControllerMock);
     }
 
+    /**
+     * Validate IEEE 802.11az ranging request on an IEEE 802.11mc capable device. Expectation is
+     * RTT type has to be downgraded to 11mc and pre-amble needs to be adjusted based on the band
+     * of operation.
+     */
+    @Test
+    public void test11azRangeRequestOn11mcCapableDevice() throws Exception {
+        int cmdId = 55;
+        RangingRequest request = RttTestUtils.getDummyRangingRequestWith11az((byte) 0);
+
+        // update capabilities to enable 11mc only
+        RttCapabilities cap = getFullRttCapabilities();
+        cap.ntbInitiatorSupported = false;
+        reset(mIWifiRttControllerMock);
+        when(mIWifiRttControllerMock.getCapabilities()).thenReturn(cap);
+        createAndInitializeDut();
+
+        mDut.rangeRequest(cmdId, request);
+        verify(mIWifiRttControllerMock).rangeRequest(eq(cmdId), mRttConfigCaptor.capture());
+        RttConfig[] halRequest = mRttConfigCaptor.getValue();
+
+        collector.checkThat("number of entries", halRequest.length,
+                equalTo(request.mRttPeers.size()));
+
+        RttConfig rttConfig = halRequest[0];
+        collector.checkThat("entry 0: MAC", rttConfig.addr,
+                equalTo(MacAddress.fromString("00:01:02:03:04:00").toByteArray()));
+        collector.checkThat("entry 0: rtt type", rttConfig.type, equalTo(RttType.TWO_SIDED));
+        collector.checkThat("entry 0: peer type", rttConfig.peer, equalTo(RttPeerType.AP));
+        collector.checkThat("", rttConfig.preamble, equalTo(RttPreamble.VHT));
+
+        rttConfig = halRequest[1];
+        collector.checkThat("entry 1: MAC", rttConfig.addr,
+                equalTo(MacAddress.fromString("0A:0B:0C:0D:0E:00").toByteArray()));
+        collector.checkThat("entry 1: rtt type", rttConfig.type, equalTo(RttType.ONE_SIDED));
+        collector.checkThat("entry 1: peer type", rttConfig.peer, equalTo(RttPeerType.AP));
+        collector.checkThat("", rttConfig.preamble, equalTo(RttPreamble.HT));
+
+        rttConfig = halRequest[2];
+        collector.checkThat("entry 2: MAC", rttConfig.addr,
+                equalTo(MacAddress.fromString("08:09:08:07:06:05").toByteArray()));
+        collector.checkThat("entry 2: rtt type", rttConfig.type, equalTo(RttType.TWO_SIDED));
+        collector.checkThat("entry 2: peer type", rttConfig.peer, equalTo(RttPeerType.NAN_TYPE));
+        collector.checkThat("", rttConfig.preamble, equalTo(RttPreamble.HT));
+
+        rttConfig = halRequest[3];
+        collector.checkThat("entry 3: MAC", rttConfig.addr,
+                equalTo(MacAddress.fromString("00:11:22:33:44:00").toByteArray()));
+        collector.checkThat("entry 3: rtt type", rttConfig.type, equalTo(RttType.TWO_SIDED_11MC));
+        collector.checkThat("entry 3: peer type", rttConfig.peer, equalTo(RttPeerType.AP));
+        collector.checkThat("entry 3: preamble", rttConfig.preamble, equalTo(RttPreamble.VHT));
+
+        verifyNoMoreInteractions(mIWifiRttControllerMock);
+
+    }
     /**
      * Validate successful ranging flow - with privileges access but with limited capabilities:
      * - Very limited BW
@@ -422,6 +554,84 @@ public class WifiRttControllerAidlImplTest extends WifiBaseTest {
                 equalTo(ScanResult.CHANNEL_WIDTH_80MHZ));
         verifyNoMoreInteractions(mIWifiRttControllerMock);
     }
+
+    /**
+     * Validate correct 11az NTB secure result conversion from HAL to framework.
+     */
+    @Test
+    public void test11azNtbSecureRangeResults() throws Exception {
+        int cmdId = 55;
+        RttResult[] results = new RttResult[1];
+        RttResult res = createRttResult();
+        res.type = RttType.TWO_SIDED_11AZ_NTB_SECURE;
+        res.addr = MacAddress.byteAddrFromStringAddr("05:06:07:08:09:0A");
+        res.ntbMaxMeasurementTime = 10; // 10 * 10000 us = 100000 us
+        res.ntbMinMeasurementTime = 100; // 100 * 100 us = 10000 us
+        res.numRxSpatialStreams = 2;
+        res.numTxSpatialStreams = 3;
+        res.i2rTxLtfRepetitionCount = 3;
+        res.r2iTxLtfRepetitionCount = 2;
+        res.status = RttStatus.SUCCESS;
+        res.distanceInMm = 1500;
+        res.timeStampInUs = 6000;
+        res.packetBw = RttBw.BW_80MHZ;
+        // Fill in secure ranging results
+        res.pasnComebackAfterMillis = 1000;
+        res.baseAkm  = Akm.PASN | Akm.SAE;
+        res.isRangingFrameProtectionEnabled = true;
+        res.isSecureLtfEnabled = true;
+        res.secureHeLtfProtocolVersion = 1;
+        res.pasnComebackCookie = new byte[] {1, 2, 3};
+        results[0] = res;
+
+        // (1) have the HAL call us with results
+        mEventCallbackCaptor.getValue().onResults(cmdId, results);
+
+        // (2) verify call to framework
+        verify(mRangingResultsCallbackMock).onRangingResults(eq(cmdId), mRttResultCaptor.capture());
+
+        // verify contents of the framework results
+        List<RangingResult> rttR = mRttResultCaptor.getValue();
+
+        collector.checkThat("number of entries", rttR.size(), equalTo(1));
+
+        RangingResult rttResult = rttR.get(0);
+        collector.checkThat("Type", rttResult.is80211azNtbMeasurement(), equalTo(true));
+        collector.checkThat("status", rttResult.getStatus(),
+                equalTo(WifiRttController.FRAMEWORK_RTT_STATUS_SUCCESS));
+        collector.checkThat("mac", rttResult.getMacAddress().toByteArray(),
+                equalTo(MacAddress.fromString("05:06:07:08:09:0A").toByteArray()));
+        collector.checkThat("ntbMaxMeasurementTime",
+                rttResult.getMaxTimeBetweenNtbMeasurementsMicros(), equalTo(100000L));
+        collector.checkThat("ntbMinMeasurementTime",
+                rttResult.getMinTimeBetweenNtbMeasurementsMicros(), equalTo(10000L));
+        collector.checkThat("numRxSpatialStreams", rttResult.get80211azNumberOfRxSpatialStreams(),
+                equalTo(2));
+        collector.checkThat("numTxSpatialStreams", rttResult.get80211azNumberOfTxSpatialStreams(),
+                equalTo(3));
+        collector.checkThat("i2rTxLtfRepetitionCount",
+                rttResult.get80211azInitiatorTxLtfRepetitionsCount(), equalTo(3));
+        collector.checkThat("r2iTxLtfRepetitionCount",
+                rttResult.get80211azResponderTxLtfRepetitionsCount(), equalTo(2));
+        collector.checkThat("distanceCm", rttResult.getDistanceMm(), equalTo(1500));
+        collector.checkThat("timestamp", rttResult.getRangingTimestampMillis(), equalTo(6L));
+        collector.checkThat("channelBw", rttResult.getMeasurementBandwidth(),
+                equalTo(ScanResult.CHANNEL_WIDTH_80MHZ));
+        // check secure ranging parameters
+        collector.checkThat("pasnComebackAfterMillis", rttResult.getPasnComebackAfterMillis(),
+                equalTo(1000L));
+        collector.checkThat("baseAkm", rttResult.isRangingAuthenticated(), equalTo(true));
+        collector.checkThat("isRangingFrameProtectionEnabled", rttResult.isRangingFrameProtected(),
+                equalTo(true));
+        collector.checkThat("isSecureLtfEnabled", rttResult.isSecureHeLtfEnabled(), equalTo(true));
+        collector.checkThat("secureHeLtfProtocolVersion", rttResult.getSecureHeLtfProtocolVersion(),
+                equalTo(1));
+        collector.checkThat("pasnComebackCookie", rttResult.getPasnComebackCookie(),
+                equalTo(new byte[]{1, 2, 3}));
+        verifyNoMoreInteractions(mIWifiRttControllerMock);
+    }
+
+
     /**
      * Validate correct cleanup when a null array of results is provided by HAL.
      */
@@ -510,6 +720,13 @@ public class WifiRttControllerAidlImplTest extends WifiBaseTest {
                         | RttBw.BW_160MHZ;
         cap.azBwSupport = cap.bwSupport;
         cap.mcVersion = 1; // unused
+        cap.akmsSupported = Akm.PASN | Akm.SAE;
+        cap.cipherSuitesSupported =
+                CipherSuite.GCMP_256 | CipherSuite.GCMP_128 | CipherSuite.CCMP_128
+                        | CipherSuite.CCMP_256;
+        cap.secureHeLtfSupported = true;
+        cap.rangingFrameProtectionSupported = true;
+        cap.maxSupportedSecureHeLtfProtocolVersion = 0;
 
         return cap;
     }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/hal/WifiRttControllerHidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/hal/WifiRttControllerHidlImplTest.java
index fdd63d31e1..34f8671637 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/hal/WifiRttControllerHidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/hal/WifiRttControllerHidlImplTest.java
@@ -415,4 +415,42 @@ public class WifiRttControllerHidlImplTest extends WifiBaseTest {
 
         return cap;
     }
+
+    /**
+     * Verify RTT burst duration with respect to different burst sizes.
+     */
+    @Test
+    public void testBurstDuration() throws Exception {
+        int cmdId = 55;
+        RangingRequest request = RttTestUtils.getDummyRangingRequestMcOnly((byte) 0, 8);
+        mDut.rangeRequest(cmdId, request);
+        verify(mockRttController).rangeRequest(eq(cmdId), mRttConfigCaptor.capture());
+        ArrayList<RttConfig> halRequest = mRttConfigCaptor.getValue();
+        collector.checkThat("number of entries", halRequest.size(),
+                equalTo(request.mRttPeers.size()));
+        RttConfig rttConfig = halRequest.get(0);
+        collector.checkThat("(1) Rtt burst size", rttConfig.numFramesPerBurst, equalTo(8));
+        collector.checkThat("(1) Rtt burst duration", rttConfig.burstDuration, equalTo(9));
+
+        cmdId = 56;
+        request = RttTestUtils.getDummyRangingRequestMcOnly((byte) 0, 20);
+        mDut.rangeRequest(cmdId, request);
+        verify(mockRttController).rangeRequest(eq(cmdId), mRttConfigCaptor.capture());
+        halRequest = mRttConfigCaptor.getValue();
+        rttConfig = halRequest.get(0);
+        collector.checkThat("(2) Rtt burst size", rttConfig.numFramesPerBurst, equalTo(20));
+        collector.checkThat("(2) Rtt burst duration", rttConfig.burstDuration, equalTo(10));
+
+        cmdId = 57;
+        request = RttTestUtils.getDummyRangingRequestMcOnly((byte) 0, 30);
+        mDut.rangeRequest(cmdId, request);
+        verify(mockRttController).rangeRequest(eq(cmdId), mRttConfigCaptor.capture());
+        halRequest = mRttConfigCaptor.getValue();
+        rttConfig = halRequest.get(0);
+        collector.checkThat("(3) Rtt burst size", rttConfig.numFramesPerBurst, equalTo(30));
+        collector.checkThat("(3) Rtt burst duration", rttConfig.burstDuration, equalTo(11));
+
+        verifyNoMoreInteractions(mockRttController);
+    }
+
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/hotspot2/ANQPRequestManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/hotspot2/ANQPRequestManagerTest.java
index 748cae1dd5..fe920fbd6f 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/hotspot2/ANQPRequestManagerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/hotspot2/ANQPRequestManagerTest.java
@@ -22,7 +22,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.anyLong;
-import static org.mockito.Mockito.anyObject;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.times;
@@ -270,7 +270,7 @@ public class ANQPRequestManagerTest extends WifiBaseTest {
         when(mClock.getElapsedSinceBootMillis()).thenReturn(startTime + 1);
         mManager.requestANQPElements(TEST_BSSID, TEST_ANQP_KEY, false,
                 NetworkDetail.HSRelease.R1);
-        verify(mHandler, never()).requestANQP(anyLong(), anyObject());
+        verify(mHandler, never()).requestANQP(anyLong(), any());
 
         // Attempt another request will succeed after the hold off time is up.
         when(mHandler.requestANQP(TEST_BSSID, R1_ANQP_WITHOUT_RC)).thenReturn(true);
@@ -309,7 +309,7 @@ public class ANQPRequestManagerTest extends WifiBaseTest {
             when(mClock.getElapsedSinceBootMillis()).thenReturn(currentTime);
             mManager.requestANQPElements(TEST_BSSID, TEST_ANQP_KEY, false,
                     NetworkDetail.HSRelease.R1);
-            verify(mHandler, never()).requestANQP(anyLong(), anyObject());
+            verify(mHandler, never()).requestANQP(anyLong(), any());
 
             // Request will succeed when the hold off time is up.
             currentTime += 1;
@@ -329,7 +329,7 @@ public class ANQPRequestManagerTest extends WifiBaseTest {
         when(mClock.getElapsedSinceBootMillis()).thenReturn(currentTime);
         mManager.requestANQPElements(TEST_BSSID, TEST_ANQP_KEY, false,
                 NetworkDetail.HSRelease.R1);
-        verify(mHandler, never()).requestANQP(anyLong(), anyObject());
+        verify(mHandler, never()).requestANQP(anyLong(), any());
 
         currentTime += 1;
         when(mHandler.requestANQP(TEST_BSSID, R1_ANQP_WITHOUT_RC)).thenReturn(true);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/hotspot2/NetworkDetailTest.java b/service/tests/wifitests/src/com/android/server/wifi/hotspot2/NetworkDetailTest.java
index 707f2e81a7..fc3262d332 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/hotspot2/NetworkDetailTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/hotspot2/NetworkDetailTest.java
@@ -193,5 +193,34 @@ public class NetworkDetailTest extends WifiBaseTest {
                     TextUtils.equals(bssidStr1, bssidStr2));
         }
     }
+
+    /**
+     * Test IEEE 802.11az NTB Secure Ranging Parameters.
+     */
+    @Test
+    public void verifyIeee80211azNtbSecureRangingParameters() {
+        InformationElement[] ies = new InformationElement[2];
+
+        ies[0] = new InformationElement();
+        ies[0].id = InformationElement.EID_EXTENDED_CAPS;
+        ies[0].bytes = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+                (byte) 0x00, (byte) 0x61, (byte) 0x00, (byte) 0x0c };
+
+        ies[1] = new InformationElement();
+        ies[1].id = InformationElement.EID_RSN_EXTENSION;
+        ies[1].bytes = new byte[]{
+                // Length
+                (byte) 0x02,
+                // Extended RSN capabilities - Secure HE-LTF and URNM-MFPR enabled
+                (byte) 0x81, (byte) 0x00,
+        };
+        NetworkDetail networkDetail = new NetworkDetail(TEST_BSSID, ies,
+                Collections.emptyList(), 5745);
+
+        assertTrue(networkDetail.is80211azNtbResponder());
+        assertTrue(networkDetail.isRangingFrameProtectionRequired());
+        assertTrue(networkDetail.isSecureHeLtfSupported());
+    }
 }
 
diff --git a/service/tests/wifitests/src/com/android/server/wifi/mainline_supplicant/MainlineSupplicantTest.java b/service/tests/wifitests/src/com/android/server/wifi/mainline_supplicant/MainlineSupplicantTest.java
index e27c46f5dd..2312fc6c33 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/mainline_supplicant/MainlineSupplicantTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/mainline_supplicant/MainlineSupplicantTest.java
@@ -16,17 +16,30 @@
 
 package com.android.server.wifi.mainline_supplicant;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.net.wifi.usd.PublishConfig;
+import android.net.wifi.usd.SubscribeConfig;
 import android.net.wifi.util.Environment;
+import android.os.Handler;
 import android.os.IBinder;
+import android.os.test.TestLooper;
 import android.system.wifi.mainline_supplicant.IMainlineSupplicant;
+import android.system.wifi.mainline_supplicant.IStaInterface;
+
+import com.android.server.wifi.WifiNative;
+import com.android.server.wifi.WifiThreadRunner;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -38,9 +51,15 @@ import org.mockito.MockitoAnnotations;
  * Unit tests for {@link MainlineSupplicant}.
  */
 public class MainlineSupplicantTest {
+    private static final String IFACE_NAME = "wlan0";
+    private static final String USD_SERVICE_NAME = "usd_service";
+
     private @Mock IMainlineSupplicant mIMainlineSupplicantMock;
     private @Mock IBinder mIBinderMock;
+    private @Mock WifiNative.SupplicantDeathEventHandler mFrameworkDeathHandler;
+    private @Mock IStaInterface mIStaInterface;
     private MainlineSupplicantSpy mDut;
+    private TestLooper mLooper = new TestLooper();
 
     private ArgumentCaptor<IBinder.DeathRecipient> mDeathRecipientCaptor =
             ArgumentCaptor.forClass(IBinder.DeathRecipient.class);
@@ -48,7 +67,7 @@ public class MainlineSupplicantTest {
     // Spy version of this class allows us to override methods for testing.
     private class MainlineSupplicantSpy extends MainlineSupplicant {
         MainlineSupplicantSpy() {
-            super();
+            super(new WifiThreadRunner(new Handler(mLooper.getLooper())));
         }
 
         @Override
@@ -62,6 +81,7 @@ public class MainlineSupplicantTest {
         assumeTrue(Environment.isSdkAtLeastB());
         MockitoAnnotations.initMocks(this);
         when(mIMainlineSupplicantMock.asBinder()).thenReturn(mIBinderMock);
+        when(mIMainlineSupplicantMock.addStaInterface(anyString())).thenReturn(mIStaInterface);
         mDut = new MainlineSupplicantSpy();
     }
 
@@ -103,4 +123,95 @@ public class MainlineSupplicantTest {
         mDeathRecipientCaptor.getValue().binderDied(mIBinderMock);
         assertFalse(mDut.isActive());
     }
+
+    /**
+     * Verify that the framework death handler is called on death, if registered.
+     */
+    @Test
+    public void testRegisterFrameworkDeathHandler() throws Exception {
+        validateServiceStart();
+        mDut.registerFrameworkDeathHandler(mFrameworkDeathHandler);
+
+        mDeathRecipientCaptor.getValue().binderDied(mIBinderMock);
+        verify(mFrameworkDeathHandler, times(1)).onDeath();
+    }
+
+    /**
+     * Verify that the framework death handler is not called on death,
+     * if it has been unregistered.
+     */
+    @Test
+    public void testUnregisterFrameworkDeathHandler() throws Exception {
+        validateServiceStart();
+        // Register and immediately unregister the framework death handler
+        mDut.registerFrameworkDeathHandler(mFrameworkDeathHandler);
+        mDut.unregisterFrameworkDeathHandler();
+
+        mDeathRecipientCaptor.getValue().binderDied(mIBinderMock);
+        verify(mFrameworkDeathHandler, never()).onDeath();
+    }
+
+    /**
+     * Verify the behavior of {@link MainlineSupplicant#addStaInterface(String)}
+     */
+    @Test
+    public void testAddStaInterface() throws Exception {
+        validateServiceStart();
+        assertTrue(mDut.addStaInterface(IFACE_NAME));
+
+        // Re-adding an existing interface should return a result from the cache
+        assertTrue(mDut.addStaInterface(IFACE_NAME));
+        verify(mIMainlineSupplicantMock, times(1)).addStaInterface(anyString());
+    }
+
+    /**
+     * Verify the behavior of {@link MainlineSupplicant#removeStaInterface(String)}
+     */
+    @Test
+    public void testRemoveStaInterface() throws Exception {
+        // Normal add and remove should succeed
+        validateServiceStart();
+        assertTrue(mDut.addStaInterface(IFACE_NAME));
+        assertTrue(mDut.removeStaInterface(IFACE_NAME));
+
+        // Removal a non-existent interface should fail
+        assertFalse(mDut.removeStaInterface(IFACE_NAME)); // already removed
+        assertFalse(mDut.removeStaInterface(IFACE_NAME + "new")); // never existed
+
+        // Only the valid remove request should reach have reached the service
+        verify(mIMainlineSupplicantMock, times(1)).removeStaInterface(anyString());
+    }
+
+    private void verifyUsdBaseConfigDefaultValues(IStaInterface.UsdBaseConfig baseConfig) {
+        assertNotNull(baseConfig.serviceName);
+        assertNotNull(baseConfig.freqsMhz);
+        assertNotNull(baseConfig.serviceSpecificInfo);
+        assertNotNull(baseConfig.rxMatchFilter);
+        assertNotNull(baseConfig.txMatchFilter);
+        assertEquals(MainlineSupplicant.DEFAULT_USD_FREQ_MHZ, baseConfig.defaultFreqMhz);
+    }
+
+    /**
+     * Verify that the proper default values are assigned during the
+     * USD Publish Config conversion.
+     */
+    @Test
+    public void testUsdPublishConfigConversionDefaultValues() {
+        PublishConfig frameworkConfig = new PublishConfig.Builder(USD_SERVICE_NAME).build();
+        IStaInterface.UsdPublishConfig aidlConfig =
+                MainlineSupplicant.frameworkToHalUsdPublishConfig(frameworkConfig);
+        verifyUsdBaseConfigDefaultValues(aidlConfig.baseConfig);
+    }
+
+    /**
+     * Verify that the proper default values are assigned during the
+     * USD Subscribe Config conversion.
+     */
+    @Test
+    public void testUsdSubscribeConfigConversionDefaultValues() {
+        SubscribeConfig frameworkConfig = new SubscribeConfig.Builder(USD_SERVICE_NAME).build();
+        IStaInterface.UsdSubscribeConfig aidlConfig =
+                MainlineSupplicant.frameworkToHalUsdSubscribeConfig(frameworkConfig);
+        verifyUsdBaseConfigDefaultValues(aidlConfig.baseConfig);
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackAidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackAidlImplTest.java
index 4b3135ad63..c90a6048b4 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackAidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackAidlImplTest.java
@@ -17,13 +17,15 @@ package com.android.server.wifi.p2p;
 
 import static com.android.net.module.util.Inet4AddressUtils.intToInet4AddressHTL;
 
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -37,14 +39,17 @@ import android.hardware.wifi.common.OuiKeyedData;
 import android.hardware.wifi.supplicant.KeyMgmtMask;
 import android.hardware.wifi.supplicant.P2pClientEapolIpAddressInfo;
 import android.hardware.wifi.supplicant.P2pDeviceFoundEventParams;
+import android.hardware.wifi.supplicant.P2pDirInfo;
 import android.hardware.wifi.supplicant.P2pGoNegotiationReqEventParams;
 import android.hardware.wifi.supplicant.P2pGroupStartedEventParams;
 import android.hardware.wifi.supplicant.P2pInvitationEventParams;
+import android.hardware.wifi.supplicant.P2pPairingBootstrappingMethodMask;
 import android.hardware.wifi.supplicant.P2pPeerClientDisconnectedEventParams;
 import android.hardware.wifi.supplicant.P2pPeerClientJoinedEventParams;
 import android.hardware.wifi.supplicant.P2pProvDiscStatusCode;
 import android.hardware.wifi.supplicant.P2pProvisionDiscoveryCompletedEventParams;
 import android.hardware.wifi.supplicant.P2pStatusCode;
+import android.hardware.wifi.supplicant.P2pUsdBasedServiceDiscoveryResultParams;
 import android.hardware.wifi.supplicant.WpsConfigMethods;
 import android.hardware.wifi.supplicant.WpsDevPasswordId;
 import android.net.MacAddress;
@@ -53,9 +58,11 @@ import android.net.wifi.WifiMigration;
 import android.net.wifi.WpsInfo;
 import android.net.wifi.p2p.WifiP2pConfig;
 import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pProvDiscEvent;
 import android.net.wifi.p2p.nsd.WifiP2pServiceResponse;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceResponse;
 import android.net.wifi.util.Environment;
 import android.os.PersistableBundle;
 
@@ -110,6 +117,8 @@ public class SupplicantP2pIfaceCallbackAidlImplTest extends WifiBaseTest {
     private short mTestConfigMethods = 0x1234;
     private byte mTestCapabilities = 123;
     private int mTestGroupCapabilities = 456;
+    private static final byte[] TEST_NONCE = {10, 20, 30, 40, 50, 60, 70, 80};
+    private static final byte[] TEST_DIR_TAG = {11, 22, 33, 44, 55, 66, 77, 88};
 
     private class SupplicantP2pIfaceCallbackImplSpy extends SupplicantP2pIfaceCallbackAidlImpl {
         SupplicantP2pIfaceCallbackImplSpy(String iface, WifiP2pMonitor monitor,
@@ -127,7 +136,7 @@ public class SupplicantP2pIfaceCallbackAidlImplTest extends WifiBaseTest {
                 .mockStatic(Flags.class, withSettings().lenient())
                 .mockStatic(WifiMigration.class, withSettings().lenient())
                 .startMocking();
-        when(Flags.wifiDirectR2()).thenReturn(false);
+        when(Flags.wifiDirectR2()).thenReturn(true);
     }
 
     @After
@@ -783,15 +792,15 @@ public class SupplicantP2pIfaceCallbackAidlImplTest extends WifiBaseTest {
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor).broadcastP2pProvisionDiscoveryEnterPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.ENTER_PIN, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_ENTER_PIN, discEventCaptor.getValue().event);
 
         configMethods = WpsConfigMethods.KEYPAD;
         mDut.onProvisionDiscoveryCompleted(
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor).broadcastP2pProvisionDiscoveryShowPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.SHOW_PIN, discEventCaptor.getValue().event);
-        assertEquals(generatedPin, discEventCaptor.getValue().pin);
+        assertEquals(WifiP2pProvDiscEvent.WPS_SHOW_PIN, discEventCaptor.getValue().event);
+        assertEquals(generatedPin, discEventCaptor.getValue().wpsPin);
 
         isRequest = true;
         configMethods = WpsConfigMethods.KEYPAD;
@@ -799,15 +808,15 @@ public class SupplicantP2pIfaceCallbackAidlImplTest extends WifiBaseTest {
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor, times(2)).broadcastP2pProvisionDiscoveryEnterPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.ENTER_PIN, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_ENTER_PIN, discEventCaptor.getValue().event);
 
         configMethods = WpsConfigMethods.DISPLAY;
         mDut.onProvisionDiscoveryCompleted(
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor, times(2)).broadcastP2pProvisionDiscoveryShowPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.SHOW_PIN, discEventCaptor.getValue().event);
-        assertEquals(generatedPin, discEventCaptor.getValue().pin);
+        assertEquals(WifiP2pProvDiscEvent.WPS_SHOW_PIN, discEventCaptor.getValue().event);
+        assertEquals(generatedPin, discEventCaptor.getValue().wpsPin);
 
         isRequest = false;
         configMethods = WpsConfigMethods.PUSHBUTTON;
@@ -815,14 +824,14 @@ public class SupplicantP2pIfaceCallbackAidlImplTest extends WifiBaseTest {
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor).broadcastP2pProvisionDiscoveryPbcResponse(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.PBC_RSP, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_PBC_RSP, discEventCaptor.getValue().event);
 
         isRequest = true;
         mDut.onProvisionDiscoveryCompleted(
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor).broadcastP2pProvisionDiscoveryPbcRequest(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.PBC_REQ, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_PBC_REQ, discEventCaptor.getValue().event);
     }
 
     /**
@@ -844,42 +853,42 @@ public class SupplicantP2pIfaceCallbackAidlImplTest extends WifiBaseTest {
         mDut.onProvisionDiscoveryCompletedEvent(params);
         verify(mMonitor).broadcastP2pProvisionDiscoveryEnterPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.ENTER_PIN, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_ENTER_PIN, discEventCaptor.getValue().event);
 
         params.configMethods = WpsConfigMethods.KEYPAD;
         mDut.onProvisionDiscoveryCompletedEvent(params);
         verify(mMonitor).broadcastP2pProvisionDiscoveryShowPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.SHOW_PIN, discEventCaptor.getValue().event);
-        assertEquals("12345678", discEventCaptor.getValue().pin);
+        assertEquals(WifiP2pProvDiscEvent.WPS_SHOW_PIN, discEventCaptor.getValue().event);
+        assertEquals("12345678", discEventCaptor.getValue().wpsPin);
 
         params.isRequest = true;
         params.configMethods = WpsConfigMethods.KEYPAD;
         mDut.onProvisionDiscoveryCompletedEvent(params);
         verify(mMonitor, times(2)).broadcastP2pProvisionDiscoveryEnterPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.ENTER_PIN, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_ENTER_PIN, discEventCaptor.getValue().event);
 
         params.configMethods = WpsConfigMethods.DISPLAY;
         mDut.onProvisionDiscoveryCompletedEvent(params);
         verify(mMonitor, times(2)).broadcastP2pProvisionDiscoveryShowPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.SHOW_PIN, discEventCaptor.getValue().event);
-        assertEquals("12345678", discEventCaptor.getValue().pin);
+        assertEquals(WifiP2pProvDiscEvent.WPS_SHOW_PIN, discEventCaptor.getValue().event);
+        assertEquals("12345678", discEventCaptor.getValue().wpsPin);
 
         params.isRequest = false;
         params.configMethods = WpsConfigMethods.PUSHBUTTON;
         mDut.onProvisionDiscoveryCompletedEvent(params);
         verify(mMonitor).broadcastP2pProvisionDiscoveryPbcResponse(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.PBC_RSP, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_PBC_RSP, discEventCaptor.getValue().event);
 
         params.isRequest = true;
         params.groupInterfaceName = "group name";
         mDut.onProvisionDiscoveryCompletedEvent(params);
         verify(mMonitor).broadcastP2pProvisionDiscoveryPbcRequest(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.PBC_REQ, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_PBC_REQ, discEventCaptor.getValue().event);
     }
 
     /**
@@ -907,7 +916,7 @@ public class SupplicantP2pIfaceCallbackAidlImplTest extends WifiBaseTest {
         mDut.onProvisionDiscoveryCompletedEvent(params);
         verify(mMonitor).broadcastP2pProvisionDiscoveryEnterPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.ENTER_PIN, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_ENTER_PIN, discEventCaptor.getValue().event);
         assertEquals(frameworkVendorData, discEventCaptor.getValue().getVendorData());
     }
 
@@ -1351,6 +1360,237 @@ public class SupplicantP2pIfaceCallbackAidlImplTest extends WifiBaseTest {
                 expectedVsieList, p2pDeviceCaptor.getValue().getVendorElements());
     }
 
+    /**
+     * Test a successful call to onUsdBasedServiceDiscoveryResult.
+     */
+    @Test
+    public void testOnUsdBasedServiceDiscoveryResult() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+
+        byte[] testSsi = {0x1, 0x3, 0x4, 0x7};
+        P2pUsdBasedServiceDiscoveryResultParams params =
+                new P2pUsdBasedServiceDiscoveryResultParams();
+        params.peerMacAddress = DEVICE_ADDRESS;
+        params.sessionId = 1;
+        params.peerSessionId = 2;
+        params.serviceProtocolType = 3;
+        params.serviceSpecificInfo = testSsi;
+
+        ArgumentCaptor<List<WifiP2pServiceResponse>> respListCaptor =
+                ArgumentCaptor.forClass(List.class);
+
+        mDut.onUsdBasedServiceDiscoveryResult(params);
+
+        verify(mMonitor).broadcastP2pServiceDiscoveryResponse(anyString(),
+                respListCaptor.capture());
+        assertNotNull(respListCaptor.getValue());
+        List<WifiP2pServiceResponse> services = respListCaptor.getValue();
+        WifiP2pServiceResponse resp = services.get(0);
+        assertNotNull(resp);
+        WifiP2pUsdBasedServiceResponse usdResponse = resp.getWifiP2pUsdBasedServiceResponse();
+        assertNotNull(usdResponse);
+        assertEquals(1, resp.getUsdSessionId());
+        assertEquals(3, usdResponse.getServiceProtocolType());
+        assertArrayEquals(testSsi, usdResponse.getServiceSpecificInfo());
+        assertNotNull(resp.getSrcDevice());
+        assertEquals(DEVICE_ADDRESS_STR, resp.getSrcDevice().deviceAddress);
+    }
+
+    /**
+     * Test a successful call to onUsdBasedServiceDiscoveryTerminated
+     */
+    @Test
+    public void testOnUsdBasedServiceDiscoveryTerminated() {
+        assumeTrue(Environment.isSdkAtLeastB());
+        mDut.onUsdBasedServiceDiscoveryTerminated(1, 3);
+        verify(mMonitor).broadcastUsdBasedServiceDiscoveryTerminated(eq(mIface),
+                eq(1), eq(3));
+    }
+
+    /**
+     * Test a successful call to onUsdBasedServiceAdvertisementTerminated
+     */
+    @Test
+    public void testOnUsdBasedServiceAdvertisementTerminated() {
+        assumeTrue(Environment.isSdkAtLeastB());
+        mDut.onUsdBasedServiceAdvertisementTerminated(4, 2);
+        verify(mMonitor).broadcastUsdBasedServiceAdvertisementTerminated(eq(mIface),
+                eq(4), eq(2));
+    }
+
+    /**
+     * Test a successful call to onDeviceFoundWithParams with P2P2 info
+     */
+    @Test
+    public void testOnDeviceFoundWithP2p2Info() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        initializeDut(4 /* serviceVersion */);
+        String fakeDeviceName = "test device name";
+
+        P2pDirInfo aidlDirInfo = new P2pDirInfo();
+        aidlDirInfo.cipherVersion = P2pDirInfo.CipherVersion.DIRA_CIPHER_VERSION_128_BIT;
+        aidlDirInfo.deviceInterfaceMacAddress = DEVICE_ADDRESS;
+        aidlDirInfo.dirTag = TEST_DIR_TAG;
+        aidlDirInfo.nonce = TEST_NONCE;
+
+        P2pDeviceFoundEventParams params = new P2pDeviceFoundEventParams();
+        params.p2pDeviceAddress = DEVICE_ADDRESS;
+        params.deviceName = fakeDeviceName;
+        params.dirInfo = aidlDirInfo;
+        params.pairingBootstrappingMethods = P2pPairingBootstrappingMethodMask
+                .BOOTSTRAPPING_OPPORTUNISTIC | P2pPairingBootstrappingMethodMask
+                .BOOTSTRAPPING_DISPLAY_PINCODE;
+
+
+        mDut.onDeviceFoundWithParams(params);
+        ArgumentCaptor<WifiP2pDevice> p2pDeviceCaptor =
+                ArgumentCaptor.forClass(WifiP2pDevice.class);
+        verify(mMonitor).broadcastP2pDeviceFound(eq(mIface), p2pDeviceCaptor.capture());
+        WifiP2pDevice device = p2pDeviceCaptor.getValue();
+        assertTrue(device.isOpportunisticBootstrappingMethodSupported());
+        assertTrue(device.isPinCodeDisplayBootstrappingMethodSupported());
+        WifiP2pDirInfo dirInfo = device.dirInfo;
+        assertEquals(android.net.MacAddress.fromBytes(DEVICE_ADDRESS), dirInfo.getMacAddress());
+        assertArrayEquals(TEST_DIR_TAG, dirInfo.getDirTag());
+        assertArrayEquals(TEST_NONCE, dirInfo.getNonce());
+    }
+
+    /**
+     * Test a successful call to onProvisionDiscoveryCompletedEvent with P2P2 pairing bootstrapping
+     * information.
+     */
+    @Test
+    public void testOnProvisionDiscoveryCompletedEventWithP2pPairingBootstrappingMethod() throws
+            Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        initializeDut(4 /* serviceVersion */);
+        P2pProvisionDiscoveryCompletedEventParams params =
+                new P2pProvisionDiscoveryCompletedEventParams();
+        params.p2pDeviceAddress = DEVICE_ADDRESS;
+        params.isRequest = true;
+        params.status = P2pProvDiscStatusCode.INFO_UNAVAILABLE;
+        params.pairingBootstrappingMethod =
+                P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OPPORTUNISTIC;
+        params.password = "";
+
+        ArgumentCaptor<WifiP2pProvDiscEvent> discEventCaptor =
+                ArgumentCaptor.forClass(WifiP2pProvDiscEvent.class);
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor).broadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticRequest(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ,
+                discEventCaptor.getValue().event);
+        assertTrue(discEventCaptor.getValue().isComeback);
+        assertEquals(DEVICE_ADDRESS_STR, discEventCaptor.getValue().device.deviceAddress);
+
+
+        params.isRequest = false;
+        params.status = P2pProvDiscStatusCode.SUCCESS;
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor).broadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticResponse(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP,
+                discEventCaptor.getValue().event);
+        assertFalse(discEventCaptor.getValue().isComeback);
+
+        params.isRequest = true;
+        params.pairingBootstrappingMethod =
+                P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PINCODE;
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor).broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN,
+                discEventCaptor.getValue().event);
+
+        params.isRequest = false;
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor).broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PIN,
+                discEventCaptor.getValue().event);
+
+        params.isRequest = true;
+        params.pairingBootstrappingMethod =
+                P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PASSPHRASE;
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor, times(2))
+                .broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE,
+                discEventCaptor.getValue().event);
+
+        params.isRequest = false;
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor, times(2))
+                .broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE,
+                discEventCaptor.getValue().event);
+
+        params.isRequest = true;
+        params.pairingBootstrappingMethod =
+                P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PINCODE;
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor, times(3))
+                .broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PIN,
+                discEventCaptor.getValue().event);
+
+        params.isRequest = false;
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor, times(3))
+                .broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN,
+                discEventCaptor.getValue().event);
+
+        params.isRequest = true;
+        params.pairingBootstrappingMethod =
+                P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PASSPHRASE;
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor, times(4))
+                .broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE,
+                discEventCaptor.getValue().event);
+        assertEquals(DEVICE_ADDRESS_STR, discEventCaptor.getValue().device.deviceAddress);
+
+        params.isRequest = false;
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor, times(4))
+                .broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(
+                anyString(), discEventCaptor.capture());
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE,
+                discEventCaptor.getValue().event);
+    }
+
+    /**
+     * Test a successful call to onProvisionDiscoveryCompletedEvent with P2P2 pairing bootstrapping
+     * information and failure status code.
+     */
+    @Test
+    public void testOnProvisionDiscoveryFailureEventWithP2pPairingBootstrappingMethod() throws
+            Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        initializeDut(4 /* serviceVersion */);
+        P2pProvisionDiscoveryCompletedEventParams params =
+                new P2pProvisionDiscoveryCompletedEventParams();
+        params.p2pDeviceAddress = DEVICE_ADDRESS;
+        params.isRequest = true;
+        params.status = P2pProvDiscStatusCode.REJECTED;
+        params.pairingBootstrappingMethod =
+                P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OPPORTUNISTIC;
+
+        ArgumentCaptor<WifiP2pProvDiscEvent> discEventCaptor =
+                ArgumentCaptor.forClass(WifiP2pProvDiscEvent.class);
+        mDut.onProvisionDiscoveryCompletedEvent(params);
+        verify(mMonitor).broadcastP2pProvisionDiscoveryFailure(eq(mIface),
+                eq(WifiP2pMonitor.PROV_DISC_STATUS_REJECTED), discEventCaptor.capture());
+        WifiP2pProvDiscEvent event = discEventCaptor.getValue();
+        assertEquals(DEVICE_ADDRESS_STR, event.device.deviceAddress);
+    }
+
     /**
      * Helper function for comparing InformationElement lists.
      *
diff --git a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackHidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackHidlImplTest.java
index 916fc5afaf..780cfe1ce7 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackHidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceCallbackHidlImplTest.java
@@ -18,9 +18,9 @@ package com.android.server.wifi.p2p;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -432,15 +432,15 @@ public class SupplicantP2pIfaceCallbackHidlImplTest extends WifiBaseTest {
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor).broadcastP2pProvisionDiscoveryEnterPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.ENTER_PIN, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_ENTER_PIN, discEventCaptor.getValue().event);
 
         configMethods = WpsConfigMethods.KEYPAD;
         mDut.onProvisionDiscoveryCompleted(
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor).broadcastP2pProvisionDiscoveryShowPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.SHOW_PIN, discEventCaptor.getValue().event);
-        assertEquals(generatedPin, discEventCaptor.getValue().pin);
+        assertEquals(WifiP2pProvDiscEvent.WPS_SHOW_PIN, discEventCaptor.getValue().event);
+        assertEquals(generatedPin, discEventCaptor.getValue().wpsPin);
 
         isRequest = true;
         configMethods = WpsConfigMethods.KEYPAD;
@@ -448,15 +448,15 @@ public class SupplicantP2pIfaceCallbackHidlImplTest extends WifiBaseTest {
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor, times(2)).broadcastP2pProvisionDiscoveryEnterPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.ENTER_PIN, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_ENTER_PIN, discEventCaptor.getValue().event);
 
         configMethods = WpsConfigMethods.DISPLAY;
         mDut.onProvisionDiscoveryCompleted(
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor, times(2)).broadcastP2pProvisionDiscoveryShowPin(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.SHOW_PIN, discEventCaptor.getValue().event);
-        assertEquals(generatedPin, discEventCaptor.getValue().pin);
+        assertEquals(WifiP2pProvDiscEvent.WPS_SHOW_PIN, discEventCaptor.getValue().event);
+        assertEquals(generatedPin, discEventCaptor.getValue().wpsPin);
 
         isRequest = false;
         configMethods = WpsConfigMethods.PUSHBUTTON;
@@ -464,14 +464,14 @@ public class SupplicantP2pIfaceCallbackHidlImplTest extends WifiBaseTest {
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor).broadcastP2pProvisionDiscoveryPbcResponse(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.PBC_RSP, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_PBC_RSP, discEventCaptor.getValue().event);
 
         isRequest = true;
         mDut.onProvisionDiscoveryCompleted(
                 p2pDeviceAddr, isRequest, status, configMethods, generatedPin);
         verify(mMonitor).broadcastP2pProvisionDiscoveryPbcRequest(
                 anyString(), discEventCaptor.capture());
-        assertEquals(WifiP2pProvDiscEvent.PBC_REQ, discEventCaptor.getValue().event);
+        assertEquals(WifiP2pProvDiscEvent.WPS_PBC_REQ, discEventCaptor.getValue().event);
     }
 
     private void verifyProvisionDiscoveryFailureEvent(
diff --git a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalAidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalAidlImplTest.java
index c04ce9aa11..142eb27de2 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalAidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalAidlImplTest.java
@@ -24,13 +24,14 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.AdditionalMatchers.aryEq;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyByte;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyByte;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doNothing;
@@ -43,6 +44,8 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
+import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.app.test.MockAnswerUtil.AnswerWithArguments;
 import android.hardware.wifi.supplicant.FreqRange;
 import android.hardware.wifi.supplicant.ISupplicant;
@@ -54,8 +57,10 @@ import android.hardware.wifi.supplicant.KeyMgmtMask;
 import android.hardware.wifi.supplicant.MacAddress;
 import android.hardware.wifi.supplicant.MiracastMode;
 import android.hardware.wifi.supplicant.P2pConnectInfo;
+import android.hardware.wifi.supplicant.P2pDirInfo;
 import android.hardware.wifi.supplicant.P2pExtListenInfo;
 import android.hardware.wifi.supplicant.P2pFrameTypeMask;
+import android.hardware.wifi.supplicant.P2pPairingBootstrappingMethodMask;
 import android.hardware.wifi.supplicant.SupplicantStatusCode;
 import android.hardware.wifi.supplicant.WpsProvisionMethod;
 import android.net.wifi.CoexUnsafeChannel;
@@ -64,11 +69,16 @@ import android.net.wifi.ScanResult;
 import android.net.wifi.WpsInfo;
 import android.net.wifi.p2p.WifiP2pConfig;
 import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pExtListenParams;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pPairingBootstrappingConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
 import android.net.wifi.util.Environment;
 import android.os.IBinder;
 import android.os.PersistableBundle;
@@ -123,16 +133,16 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     final String mSsid = "\"SSID\"";
     final byte[] mSsidBytes = {'S', 'S', 'I', 'D'};
     final String mPeerMacAddress = "00:11:22:33:44:55";
-    final byte[] mPeerMacAddressBytes = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55 };
+    final byte[] mPeerMacAddressBytes = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
     final String mGroupOwnerMacAddress = "01:12:23:34:45:56";
-    final byte[] mGroupOwnerMacAddressBytes = { 0x01, 0x12, 0x23, 0x34, 0x45, 0x56 };
+    final byte[] mGroupOwnerMacAddressBytes = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56};
     final String mInvalidMacAddress1 = "00:11:22:33:44";
     final String mInvalidMacAddress2 = ":::::";
     final String mInvalidMacAddress3 = "invalid";
     final byte[] mInvalidMacAddressBytes1 = null;
-    final byte[] mInvalidMacAddressBytes2 = { };
-    final byte[] mInvalidMacAddressBytes3 = { 0x00, 0x01, 0x02, 0x03, 0x04 };
-    final byte[] mInvalidMacAddressBytes4 = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };
+    final byte[] mInvalidMacAddressBytes2 = {};
+    final byte[] mInvalidMacAddressBytes3 = {0x00, 0x01, 0x02, 0x03, 0x04};
+    final byte[] mInvalidMacAddressBytes4 = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06};
     HashSet<String> mInvalidMacAddresses = new HashSet<String>(Arrays.asList(
             mInvalidMacAddress1, mInvalidMacAddress2,
             mInvalidMacAddress3));
@@ -140,7 +150,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     final String mInvalidService1 = null;
     final String mInvalidService2 = "service";
     final String mValidServiceRequestString = "30313233";
-    final byte[] mValidServiceRequestBytes = { 0x30, 0x31, 0x32, 0x33 };
+    final byte[] mValidServiceRequestBytes = {0x30, 0x31, 0x32, 0x33};
     final String mInvalidServiceRequestString = "not a hex string";
     final String mInvalidUpnpService1 = "upnp";
     final String mInvalidUpnpService2 = "upnp 1";
@@ -162,6 +172,18 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     final int mGroupOwnerBand = WifiP2pConfig.GROUP_OWNER_BAND_5GHZ;
     final boolean mIsPersistent = false;
 
+    private static final String TEST_USD_SERVICE_NAME = "test_service_name";
+    private static final String TEST_GROUP_INTERFACE_NAME = "test_group_if_name";
+    private static final int TEST_USD_PROTOCOL_TYPE = 4;
+    private static final byte[] TEST_USD_SERVICE_SPECIFIC_INFO = {10, 20, 30, 40, 50, 60};
+    private static final int TEST_USD_DISCOVERY_CHANNEL_FREQUENCY_MHZ = 2437;
+    private static final int[] TEST_USD_DISCOVERY_CHANNEL_FREQUENCIES_MHZ = {2412, 2437, 2462};
+    private static final int TEST_USD_TIMEOUT_S = 30;
+    private static final int TEST_USD_SESSION_ID = 3;
+    private static final int TEST_DEV_IK_ID = 2;
+    private static final byte[] TEST_NONCE = {10, 20, 30, 40, 50, 60, 70, 80};
+    private static final byte[] TEST_DIR_TAG = {11, 22, 33, 44, 55, 66, 77, 88};
+
     private class SupplicantP2pIfaceHalSpy extends SupplicantP2pIfaceHalAidlImpl {
         SupplicantP2pIfaceHalSpy() {
             super(mWifiMonitor, mWifiInjector);
@@ -324,7 +346,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testFind_failure() throws Exception {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
-            .when(mISupplicantP2pIfaceMock).find(anyInt());
+                .when(mISupplicantP2pIfaceMock).find(anyInt());
         assertFalse(mDut.find(1));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
@@ -338,13 +360,13 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         doNothing().when(mISupplicantP2pIfaceMock).find(anyInt());
         // Default value when service is not yet initialized.
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_FULL,
-                              WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
+                WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
 
         executeAndValidateInitializationSequence(false, false);
         assertTrue(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_FULL,
-                             WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
+                WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_FULL,
-                              WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, -1));
+                WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, -1));
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_FULL, 2412, -1));
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_FULL, -1, 1));
     }
@@ -357,9 +379,9 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testFindFullScan_failure() throws Exception {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
-            .when(mISupplicantP2pIfaceMock).find(anyInt());
+                .when(mISupplicantP2pIfaceMock).find(anyInt());
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_FULL,
-                              WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
+                WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
     }
@@ -372,13 +394,13 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         doNothing().when(mISupplicantP2pIfaceMock).findOnSocialChannels(anyInt());
         // Default value when service is not yet initialized.
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SOCIAL,
-                              WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
+                WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
 
         executeAndValidateInitializationSequence(false, false);
         assertTrue(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SOCIAL,
-                             WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
+                WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SOCIAL,
-                              WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, -1));
+                WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, -1));
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SOCIAL, 2412, -1));
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SOCIAL, -1, 1));
     }
@@ -390,9 +412,9 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testFindSocialOnly_failure() throws Exception {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
-            .when(mISupplicantP2pIfaceMock).findOnSocialChannels(anyInt());
+                .when(mISupplicantP2pIfaceMock).findOnSocialChannels(anyInt());
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SOCIAL,
-                              WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
+                WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
     }
@@ -412,7 +434,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SINGLE_FREQ, freq, -1));
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SINGLE_FREQ, -1, 1));
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SINGLE_FREQ,
-                              WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
+                WifiP2pManager.WIFI_P2P_SCAN_FREQ_UNSPECIFIED, 1));
     }
 
     /**
@@ -422,7 +444,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testFindSpecificFrequency_failure() throws Exception {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
-            .when(mISupplicantP2pIfaceMock).findOnSpecificFrequency(anyInt(), anyInt());
+                .when(mISupplicantP2pIfaceMock).findOnSpecificFrequency(anyInt(), anyInt());
         assertFalse(mDut.find(WifiP2pManager.WIFI_P2P_SCAN_SINGLE_FREQ, 2412, 1));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
@@ -447,7 +469,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testStopFind_failure() throws Exception {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
-            .when(mISupplicantP2pIfaceMock).stopFind();
+                .when(mISupplicantP2pIfaceMock).stopFind();
         assertFalse(mDut.stopFind());
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
@@ -1211,9 +1233,9 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testReinvoke_success() throws Exception {
         doNothing().when(mISupplicantP2pIfaceMock).reinvoke(anyInt(), eq(mPeerMacAddressBytes));
         // Default value when service is not initialized.
-        assertFalse(mDut.reinvoke(0, mPeerMacAddress));
+        assertFalse(mDut.reinvoke(0, mPeerMacAddress, -1));
         executeAndValidateInitializationSequence(false, false);
-        assertTrue(mDut.reinvoke(0, mPeerMacAddress));
+        assertTrue(mDut.reinvoke(0, mPeerMacAddress, -1));
     }
 
     /**
@@ -1224,7 +1246,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false);
         doNothing().when(mISupplicantP2pIfaceMock).reinvoke(anyInt(), eq(mPeerMacAddressBytes));
         for (String address : mInvalidMacAddresses) {
-            assertFalse(mDut.reinvoke(0, address));
+            assertFalse(mDut.reinvoke(0, address, -1));
         }
     }
 
@@ -1236,7 +1258,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
                 .when(mISupplicantP2pIfaceMock).reinvoke(anyInt(), any(byte[].class));
-        assertFalse(mDut.reinvoke(0, mPeerMacAddress));
+        assertFalse(mDut.reinvoke(0, mPeerMacAddress, -1));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
     }
@@ -1249,7 +1271,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new RemoteException()).when(mISupplicantP2pIfaceMock)
                 .reinvoke(anyInt(), any(byte[].class));
-        assertFalse(mDut.reinvoke(0, mPeerMacAddress));
+        assertFalse(mDut.reinvoke(0, mPeerMacAddress, -1));
         // Check service is dead.
         assertFalse(mDut.isInitializationComplete());
     }
@@ -1261,9 +1283,9 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testGroupAdd_success() throws Exception {
         doNothing().when(mISupplicantP2pIfaceMock).addGroup(eq(true), eq(3));
         // Default value when service is not initialized.
-        assertFalse(mDut.groupAdd(3, true));
+        assertFalse(mDut.groupAdd(3, true, false));
         executeAndValidateInitializationSequence(false, false);
-        assertTrue(mDut.groupAdd(3, true));
+        assertTrue(mDut.groupAdd(3, true, false));
     }
 
     /**
@@ -1274,7 +1296,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
                 .when(mISupplicantP2pIfaceMock).addGroup(anyBoolean(), anyInt());
-        assertFalse(mDut.groupAdd(0, true));
+        assertFalse(mDut.groupAdd(0, true, false));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
     }
@@ -1287,7 +1309,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new RemoteException()).when(mISupplicantP2pIfaceMock)
                 .addGroup(anyBoolean(), anyInt());
-        assertFalse(mDut.groupAdd(0, true));
+        assertFalse(mDut.groupAdd(0, true, false));
         // Check service is dead.
         assertFalse(mDut.isInitializationComplete());
     }
@@ -1788,7 +1810,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
                 .when(mISupplicantP2pIfaceMock).addUpnpService(anyInt(), anyString());
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
                 .when(mISupplicantP2pIfaceMock)
-                        .addBonjourService(any(byte[].class), any(byte[].class));
+                .addBonjourService(any(byte[].class), any(byte[].class));
 
         assertFalse(mDut.serviceAdd(createPlaceholderP2pServiceInfo(mValidUpnpService)));
         assertFalse(mDut.serviceAdd(createPlaceholderP2pServiceInfo(mValidBonjourService)));
@@ -1891,7 +1913,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false);
 
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
-            .when(mISupplicantP2pIfaceMock).removeUpnpService(anyInt(), anyString());
+                .when(mISupplicantP2pIfaceMock).removeUpnpService(anyInt(), anyString());
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
                 .when(mISupplicantP2pIfaceMock).removeBonjourService(any(byte[].class));
 
@@ -2024,7 +2046,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testCancelServiceDiscovery_failure() throws Exception {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
-            .when(mISupplicantP2pIfaceMock).cancelServiceDiscovery(anyLong());
+                .when(mISupplicantP2pIfaceMock).cancelServiceDiscovery(anyLong());
         assertFalse(mDut.cancelServiceDiscovery(SERVICE_IDENTIFIER_STR));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
@@ -2286,7 +2308,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testCancelWps_failure() throws Exception {
         executeAndValidateInitializationSequence(false, false);
         doThrow(new ServiceSpecificException(SupplicantStatusCode.FAILURE_UNKNOWN))
-            .when(mISupplicantP2pIfaceMock).cancelWps(anyString());
+                .when(mISupplicantP2pIfaceMock).cancelWps(anyString());
         assertFalse(mDut.cancelWps(mIfaceName));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
@@ -2404,6 +2426,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
             public byte[] bssid;
             public boolean isGroupOwner;
             public boolean isCurrent;
+
             P2pGroupInfo(String ssid, byte[] bssid, boolean isGroupOwner, boolean isCurrent) {
                 this.ssid = ssid;
                 this.bssid = bssid;
@@ -2465,7 +2488,8 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
                             return groups.get(networkId).isGroupOwner;
                         }
                     }).when(mISupplicantP2pNetworkMock).isGroupOwner();
-                } catch (RemoteException e) { }
+                } catch (RemoteException e) {
+                }
                 return mISupplicantP2pNetworkMock;
             }
         }).when(mISupplicantP2pIfaceMock).getNetwork(anyInt());
@@ -2665,9 +2689,9 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testSetVendorElementsSuccess() throws Exception {
         doNothing().when(mISupplicantP2pIfaceMock).setVendorElements(anyInt(), any());
         executeAndValidateInitializationSequence(false, false);
-        Set<ScanResult.InformationElement> ies =  new HashSet<>();
+        Set<ScanResult.InformationElement> ies = new HashSet<>();
         ies.add(new ScanResult.InformationElement(221, 0, new byte[]{(byte) 0xb}));
-        byte[] iesBytes = new byte[] {(byte) 221, (byte) 1, (byte) 0xb};
+        byte[] iesBytes = new byte[]{(byte) 221, (byte) 1, (byte) 0xb};
 
         assertTrue(mDut.setVendorElements(ies));
         verify(mISupplicantP2pIfaceMock).setVendorElements(
@@ -2682,7 +2706,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
     public void testSetVendorElementsSuccessWithEmptyVsieList() throws Exception {
         doNothing().when(mISupplicantP2pIfaceMock).setVendorElements(anyInt(), any());
         executeAndValidateInitializationSequence(false, false);
-        Set<ScanResult.InformationElement> ies =  new HashSet<>();
+        Set<ScanResult.InformationElement> ies = new HashSet<>();
         byte[] iesBytes = new byte[0];
 
         assertTrue(mDut.setVendorElements(ies));
@@ -2711,7 +2735,7 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
                 .setVendorElements(anyInt(), any(byte[].class));
 
         executeAndValidateInitializationSequence(false, false);
-        Set<ScanResult.InformationElement> ies =  new HashSet<>();
+        Set<ScanResult.InformationElement> ies = new HashSet<>();
 
         assertFalse(mDut.setVendorElements(ies));
         verify(mISupplicantP2pIfaceMock).setVendorElements(
@@ -2789,6 +2813,24 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         }
     }
 
+    /**
+     * Create new placeholder WifiP2pConfig instance.
+     */
+    private WifiP2pConfig createP2pConfigWithBootstrappingMethod(@NonNull byte[] macAddress,
+            @WifiP2pPairingBootstrappingConfig.PairingBootstrappingMethod int method,
+            @Nullable String password, boolean authorize) {
+        WifiP2pPairingBootstrappingConfig pairingBootstrappingConfig =
+                new WifiP2pPairingBootstrappingConfig(method, password);
+        WifiP2pConfig config = new WifiP2pConfig.Builder()
+                .setDeviceAddress(NativeUtil.getMacAddressOrNull(
+                        NativeUtil.macAddressFromByteArray(macAddress)))
+                .setPairingBootstrappingConfig(pairingBootstrappingConfig)
+                .setAuthorizeConnectionFromPeerEnabled(authorize)
+                .build();
+        config.groupOwnerIntent = WifiP2pServiceImpl.DEFAULT_GROUP_OWNER_INTENT;
+        return config;
+    }
+
     /**
      * Create new placeholder WifiP2pConfig instance.
      */
@@ -2869,4 +2911,545 @@ public class SupplicantP2pIfaceHalAidlImplTest extends WifiBaseTest {
         assertFalse(mDut.isInitializationComplete());
         verify(mSupplicantHalDeathHandler, never()).onDeath();
     }
+
+    /**
+     * Test the handling of start an Un-synchronized Service Discovery (USD) based service
+     * discovery.
+     */
+    @Test
+    public void testStartUsdBasedServiceDiscoverySuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pUsdBasedServiceDiscoveryConfig>
+                usdBasedServiceDiscoveryConfigCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pUsdBasedServiceDiscoveryConfig.class);
+        when(mISupplicantP2pIfaceMock.startUsdBasedServiceDiscovery(any()))
+                .thenReturn(TEST_USD_SESSION_ID);
+
+        WifiP2pUsdBasedServiceConfig usdConfig = new WifiP2pUsdBasedServiceConfig.Builder(
+                TEST_USD_SERVICE_NAME)
+                .setServiceProtocolType(TEST_USD_PROTOCOL_TYPE)
+                .setServiceSpecificInfo(TEST_USD_SERVICE_SPECIFIC_INFO).build();
+        WifiP2pUsdBasedServiceDiscoveryConfig serviceDiscoveryConfig =
+                new WifiP2pUsdBasedServiceDiscoveryConfig.Builder()
+                        .setFrequenciesMhz(TEST_USD_DISCOVERY_CHANNEL_FREQUENCIES_MHZ).build();
+
+        executeAndValidateInitializationSequence(false, false);
+
+        assertEquals(TEST_USD_SESSION_ID, mDut.startUsdBasedServiceDiscovery(usdConfig,
+                serviceDiscoveryConfig, TEST_USD_TIMEOUT_S));
+
+        verify(mISupplicantP2pIfaceMock).startUsdBasedServiceDiscovery(
+                usdBasedServiceDiscoveryConfigCaptor.capture());
+        android.hardware.wifi.supplicant.P2pUsdBasedServiceDiscoveryConfig aidlUsdConfig =
+                usdBasedServiceDiscoveryConfigCaptor.getValue();
+
+        assertEquals(TEST_USD_SERVICE_NAME, aidlUsdConfig.serviceName);
+        assertEquals(TEST_USD_PROTOCOL_TYPE, aidlUsdConfig.serviceProtocolType);
+        assertArrayEquals(TEST_USD_SERVICE_SPECIFIC_INFO, aidlUsdConfig.serviceSpecificInfo);
+        assertEquals(0, aidlUsdConfig.bandMask);
+        assertArrayEquals(TEST_USD_DISCOVERY_CHANNEL_FREQUENCIES_MHZ,
+                aidlUsdConfig.frequencyListMhz);
+        assertEquals(TEST_USD_TIMEOUT_S, aidlUsdConfig.timeoutInSeconds);
+    }
+
+    /**
+     * Test the handling of stop an Un-synchronized Service Discovery (USD) based service discovery.
+     */
+    @Test
+    public void testStopUsdBasedServiceDiscoverySuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+
+        doNothing().when(mISupplicantP2pIfaceMock).stopUsdBasedServiceDiscovery(anyInt());
+
+        executeAndValidateInitializationSequence(false, false);
+
+        mDut.stopUsdBasedServiceDiscovery(TEST_USD_SESSION_ID);
+        verify(mISupplicantP2pIfaceMock).stopUsdBasedServiceDiscovery(eq(TEST_USD_SESSION_ID));
+    }
+
+    /**
+     * Test the handling of start an Un-synchronized Service Discovery (USD) based service
+     * advertisement.
+     */
+    @Test
+    public void testStartUsdBasedServiceAdvertisementSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pUsdBasedServiceAdvertisementConfig>
+                usdBasedServiceAdvertisementConfigCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pUsdBasedServiceAdvertisementConfig.class);
+        when(mISupplicantP2pIfaceMock.startUsdBasedServiceAdvertisement(any()))
+                .thenReturn(TEST_USD_SESSION_ID);
+
+        WifiP2pUsdBasedServiceConfig usdConfig = new WifiP2pUsdBasedServiceConfig.Builder(
+                TEST_USD_SERVICE_NAME)
+                .setServiceProtocolType(TEST_USD_PROTOCOL_TYPE)
+                .setServiceSpecificInfo(TEST_USD_SERVICE_SPECIFIC_INFO).build();
+        WifiP2pUsdBasedLocalServiceAdvertisementConfig serviceAdvertisementConfig =
+                new WifiP2pUsdBasedLocalServiceAdvertisementConfig.Builder()
+                        .setFrequencyMhz(TEST_USD_DISCOVERY_CHANNEL_FREQUENCY_MHZ).build();
+
+        executeAndValidateInitializationSequence(false, false);
+
+        assertEquals(TEST_USD_SESSION_ID, mDut.startUsdBasedServiceAdvertisement(usdConfig,
+                serviceAdvertisementConfig, TEST_USD_TIMEOUT_S));
+
+        verify(mISupplicantP2pIfaceMock).startUsdBasedServiceAdvertisement(
+                usdBasedServiceAdvertisementConfigCaptor.capture());
+        android.hardware.wifi.supplicant.P2pUsdBasedServiceAdvertisementConfig aidlUsdConfig =
+                usdBasedServiceAdvertisementConfigCaptor.getValue();
+
+        assertEquals(TEST_USD_SERVICE_NAME, aidlUsdConfig.serviceName);
+        assertEquals(TEST_USD_PROTOCOL_TYPE, aidlUsdConfig.serviceProtocolType);
+        assertArrayEquals(TEST_USD_SERVICE_SPECIFIC_INFO, aidlUsdConfig.serviceSpecificInfo);
+        assertEquals(TEST_USD_DISCOVERY_CHANNEL_FREQUENCY_MHZ, aidlUsdConfig.frequencyMHz);
+        assertEquals(TEST_USD_TIMEOUT_S, aidlUsdConfig.timeoutInSeconds);
+    }
+
+    /**
+     * Test the handling of stop an Un-synchronized Service Discovery (USD) based service
+     * advertisement.
+     */
+    @Test
+    public void testStopUsdBasedServiceAdvertisementSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+
+        doNothing().when(mISupplicantP2pIfaceMock).stopUsdBasedServiceAdvertisement(anyInt());
+
+        executeAndValidateInitializationSequence(false, false);
+
+        mDut.stopUsdBasedServiceAdvertisement(TEST_USD_SESSION_ID);
+        verify(mISupplicantP2pIfaceMock).stopUsdBasedServiceAdvertisement(eq(TEST_USD_SESSION_ID));
+    }
+
+    /**
+     * Test the handling of getting the Device Identity Resolution (DIR) Information.
+     */
+    @Test
+    public void testGetDirInfoSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+
+        P2pDirInfo aidlDirInfo = new P2pDirInfo();
+        aidlDirInfo.cipherVersion = P2pDirInfo.CipherVersion.DIRA_CIPHER_VERSION_128_BIT;
+        aidlDirInfo.deviceInterfaceMacAddress = mPeerMacAddressBytes;
+        aidlDirInfo.dirTag = TEST_DIR_TAG;
+        aidlDirInfo.nonce = TEST_NONCE;
+
+        doReturn(aidlDirInfo).when(mISupplicantP2pIfaceMock).getDirInfo();
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pDirInfo dirInfo = mDut.getDirInfo();
+        assertNotNull(dirInfo);
+        assertEquals(android.net.MacAddress.fromBytes(mPeerMacAddressBytes),
+                dirInfo.getMacAddress());
+        assertArrayEquals(TEST_DIR_TAG, dirInfo.getDirTag());
+        assertArrayEquals(TEST_NONCE, dirInfo.getNonce());
+    }
+
+    /**
+     * Test the handling of Validating the Device Identity Resolution (DIR) Information
+     */
+    @Test
+    public void testValidateDirInfoSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+
+        WifiP2pDirInfo dirInfo = new WifiP2pDirInfo(
+                android.net.MacAddress.fromBytes(mPeerMacAddressBytes), TEST_NONCE, TEST_DIR_TAG);
+
+
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pDirInfo>
+                p2pDirInfoCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pDirInfo.class);
+        when(mISupplicantP2pIfaceMock.validateDirInfo(any())).thenReturn(TEST_DEV_IK_ID);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        assertEquals(TEST_DEV_IK_ID, mDut.validateDirInfo(dirInfo));
+
+        verify(mISupplicantP2pIfaceMock).validateDirInfo(
+                p2pDirInfoCaptor.capture());
+        android.hardware.wifi.supplicant.P2pDirInfo aidlDirInfo = p2pDirInfoCaptor.getValue();
+        assertEquals(P2pDirInfo.CipherVersion.DIRA_CIPHER_VERSION_128_BIT,
+                aidlDirInfo.cipherVersion);
+        assertArrayEquals(mPeerMacAddressBytes, aidlDirInfo.deviceInterfaceMacAddress);
+        assertArrayEquals(TEST_DIR_TAG, aidlDirInfo.dirTag);
+        assertArrayEquals(TEST_NONCE, aidlDirInfo.nonce);
+    }
+
+    /**
+     * Test the handling of groupAdd with P2P version.
+     */
+    @Test
+    public void testCreateGroupOwnerSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doNothing().when(mISupplicantP2pIfaceMock).addGroup(anyBoolean(), anyInt());
+        doNothing().when(mISupplicantP2pIfaceMock).createGroupOwner(any());
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pCreateGroupOwnerInfo>
+                p2pGroupInfoCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pCreateGroupOwnerInfo.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        assertTrue(mDut.groupAdd(-1, false, true));
+        verify(mISupplicantP2pIfaceMock, never()).addGroup(anyBoolean(), anyInt());
+        verify(mISupplicantP2pIfaceMock).createGroupOwner(
+                p2pGroupInfoCaptor.capture());
+        android.hardware.wifi.supplicant.P2pCreateGroupOwnerInfo aidlGroupInfo =
+                p2pGroupInfoCaptor.getValue();
+        assertFalse(aidlGroupInfo.persistent);
+        assertEquals(-1, aidlGroupInfo.persistentNetworkId);
+        assertTrue(aidlGroupInfo.isP2pV2);
+    }
+
+    /**
+     * Test the handling of ProvisionDiscovery with pairing bootstrapping method.
+     */
+    @Test
+    public void testProvisionDiscoveryWithBootStrappingMethodSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doNothing().when(mISupplicantP2pIfaceMock).provisionDiscoveryWithParams(any());
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pProvisionDiscoveryParams>
+                p2pProvDiscParamsCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pProvisionDiscoveryParams.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pConfig config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC,
+                "", false);
+        assertTrue(mDut.provisionDiscovery(config));
+        verify(mISupplicantP2pIfaceMock).provisionDiscoveryWithParams(
+                p2pProvDiscParamsCaptor.capture());
+        android.hardware.wifi.supplicant.P2pProvisionDiscoveryParams aidlProvDiscParams =
+                p2pProvDiscParamsCaptor.getValue();
+        assertArrayEquals(mPeerMacAddressBytes, aidlProvDiscParams.peerMacAddress);
+        assertEquals(WpsProvisionMethod.NONE, aidlProvDiscParams.provisionMethod);
+        assertEquals(P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OPPORTUNISTIC,
+                aidlProvDiscParams.pairingBootstrappingMethod);
+    }
+
+    /**
+     * Test the mapping of user provided pairing bootstrapping method to the method filled in
+     * provision discovery request packet.
+     */
+    @Test
+    public void testProvisionDiscovery() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        executeAndValidateInitializationSequence(false, false);
+        testProvisionDiscoveryBootstrappingMethodMapping(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE, "1234",
+                P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PINCODE, 4);
+        testProvisionDiscoveryBootstrappingMethodMapping(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE,
+                "abed", P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PASSPHRASE, 4);
+        testProvisionDiscoveryBootstrappingMethodMapping(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE,
+                "", P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PINCODE, 4);
+        testProvisionDiscoveryBootstrappingMethodMapping(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE,
+                "", P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PASSPHRASE, 4);
+        testProvisionDiscoveryBootstrappingMethodMapping(WpsInfo.DISPLAY, "",
+                WpsProvisionMethod.KEYPAD, 3);
+        testProvisionDiscoveryBootstrappingMethodMapping(WpsInfo.KEYPAD, "12345670",
+                WpsProvisionMethod.DISPLAY, 3);
+        testProvisionDiscoveryBootstrappingMethodMapping(WpsInfo.PBC, "",
+                WpsProvisionMethod.PBC, 3);
+    }
+
+    private void testProvisionDiscoveryBootstrappingMethodMapping(int frameworkMethod,
+            String passwordOrPin, int expectedAidlMethod, int serviceVersion) throws Exception {
+        setCachedServiceVersion(serviceVersion);
+        if (serviceVersion >= 4) { // Version 4 and above use provisionDiscoveryWithParams
+            doNothing().when(mISupplicantP2pIfaceMock).provisionDiscoveryWithParams(argThat(
+                    params -> params.pairingBootstrappingMethod == expectedAidlMethod
+                            && params.provisionMethod == WpsProvisionMethod.NONE));
+        } else { // Version 3 and below use the older provisionDiscovery
+            doNothing().when(mISupplicantP2pIfaceMock).provisionDiscovery(
+                    aryEq(mPeerMacAddressBytes), eq(expectedAidlMethod));
+        }
+
+        WifiP2pConfig config;
+        if (serviceVersion >= 4) {
+            config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                    frameworkMethod, passwordOrPin, false);
+        } else {
+            config = createPlaceholderP2pConfig(mPeerMacAddress, frameworkMethod,
+                    passwordOrPin);
+        }
+
+        assertTrue(mDut.provisionDiscovery(config));
+
+        // Verification is handled by the ArgumentMatcher in doNothing().when().
+    }
+
+    /**
+     * Test that a ProvisionDiscovery request with pairing bootstrapping method Out Of Band fails.
+     */
+    @Test
+    public void testProvisionDiscoveryForOobBootstrappingFails() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doNothing().when(mISupplicantP2pIfaceMock).provisionDiscoveryWithParams(any());
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pConfig config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_OUT_OF_BAND,
+                "1234", false);
+        assertFalse(mDut.provisionDiscovery(config));
+    }
+
+    /**
+     * Test the handling of connect with pairing bootstrapping method: Opportunistic.
+     */
+    @Test
+    public void testConnectWithBootStrappingMethodOpportunisticSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doReturn("").when(mISupplicantP2pIfaceMock).connectWithParams(any());
+
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pConnectInfo>
+                connectInfoCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pConnectInfo.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pConfig config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC,
+                "", false);
+        assertTrue(mDut.connect(config, false).isEmpty());
+        verify(mISupplicantP2pIfaceMock).connectWithParams(connectInfoCaptor.capture());
+        android.hardware.wifi.supplicant.P2pConnectInfo aidlConnectInfo =
+                connectInfoCaptor.getValue();
+        assertArrayEquals(mPeerMacAddressBytes, aidlConnectInfo.peerAddress);
+        assertEquals(WpsProvisionMethod.NONE, aidlConnectInfo.provisionMethod);
+        assertEquals(P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OPPORTUNISTIC,
+                aidlConnectInfo.pairingBootstrappingMethod);
+        assertTrue(TextUtils.isEmpty(aidlConnectInfo.password));
+        assertEquals(0, aidlConnectInfo.frequencyMHz);
+        assertFalse(aidlConnectInfo.authorizeConnectionFromPeer);
+        assertNull(aidlConnectInfo.groupInterfaceName);
+    }
+
+    /**
+     * Test the handling of connect with pairing bootstrapping method: display pin-code.
+     */
+    @Test
+    public void testConnectWithBootStrappingMethodDisplayPinCodeSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doReturn("").when(mISupplicantP2pIfaceMock).connectWithParams(any());
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pConnectInfo>
+                connectInfoCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pConnectInfo.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pConfig config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE,
+                "1234", false);
+        assertTrue(mDut.connect(config, false).isEmpty());
+        verify(mISupplicantP2pIfaceMock).connectWithParams(connectInfoCaptor.capture());
+        android.hardware.wifi.supplicant.P2pConnectInfo aidlConnectInfo =
+                connectInfoCaptor.getValue();
+        assertArrayEquals(mPeerMacAddressBytes, aidlConnectInfo.peerAddress);
+        assertEquals(WpsProvisionMethod.NONE, aidlConnectInfo.provisionMethod);
+        assertEquals(P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PINCODE,
+                aidlConnectInfo.pairingBootstrappingMethod);
+        assertEquals("1234", aidlConnectInfo.password);
+        assertEquals(0, aidlConnectInfo.frequencyMHz);
+        assertFalse(aidlConnectInfo.authorizeConnectionFromPeer);
+        assertNull(aidlConnectInfo.groupInterfaceName);
+    }
+
+    /**
+     * Test the handling of connect with pairing bootstrapping method: display passphrase.
+     */
+    @Test
+    public void testConnectWithBootStrappingMethodDisplayPassphraseSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doReturn("").when(mISupplicantP2pIfaceMock).connectWithParams(any());
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pConnectInfo>
+                connectInfoCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pConnectInfo.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pConfig config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE,
+                "abed", false);
+        assertTrue(mDut.connect(config, false).isEmpty());
+        verify(mISupplicantP2pIfaceMock).connectWithParams(connectInfoCaptor.capture());
+        android.hardware.wifi.supplicant.P2pConnectInfo aidlConnectInfo =
+                connectInfoCaptor.getValue();
+        assertArrayEquals(mPeerMacAddressBytes, aidlConnectInfo.peerAddress);
+        assertEquals(WpsProvisionMethod.NONE, aidlConnectInfo.provisionMethod);
+        assertEquals(P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_DISPLAY_PASSPHRASE,
+                aidlConnectInfo.pairingBootstrappingMethod);
+        assertEquals("abed", aidlConnectInfo.password);
+    }
+
+    /**
+     * Test the handling of connect with pairing bootstrapping method: keypad pin-code.
+     */
+    @Test
+    public void testConnectWithBootStrappingMethodKeypadPinCodeSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doReturn("").when(mISupplicantP2pIfaceMock).connectWithParams(any());
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pConnectInfo>
+                connectInfoCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pConnectInfo.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pConfig config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE,
+                "", false);
+        config.getPairingBootstrappingConfig().setPairingBootstrappingPassword("1234");
+        assertTrue(mDut.connect(config, false).isEmpty());
+        verify(mISupplicantP2pIfaceMock).connectWithParams(connectInfoCaptor.capture());
+        android.hardware.wifi.supplicant.P2pConnectInfo aidlConnectInfo =
+                connectInfoCaptor.getValue();
+        assertArrayEquals(mPeerMacAddressBytes, aidlConnectInfo.peerAddress);
+        assertEquals(WpsProvisionMethod.NONE, aidlConnectInfo.provisionMethod);
+        assertEquals(P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PINCODE,
+                aidlConnectInfo.pairingBootstrappingMethod);
+        assertEquals("1234", aidlConnectInfo.password);
+    }
+
+    /**
+     * Test the handling of connect with pairing bootstrapping method: keypad passphrase.
+     */
+    @Test
+    public void testConnectWithBootStrappingMethodKeypadPassphraseSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doReturn("").when(mISupplicantP2pIfaceMock).connectWithParams(any());
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pConnectInfo>
+                connectInfoCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pConnectInfo.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pConfig config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE,
+                "", false);
+        config.getPairingBootstrappingConfig().setPairingBootstrappingPassword("abed");
+        assertTrue(mDut.connect(config, false).isEmpty());
+        verify(mISupplicantP2pIfaceMock).connectWithParams(connectInfoCaptor.capture());
+        android.hardware.wifi.supplicant.P2pConnectInfo aidlConnectInfo =
+                connectInfoCaptor.getValue();
+        assertArrayEquals(mPeerMacAddressBytes, aidlConnectInfo.peerAddress);
+        assertEquals(WpsProvisionMethod.NONE, aidlConnectInfo.provisionMethod);
+        assertEquals(P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_KEYPAD_PASSPHRASE,
+                aidlConnectInfo.pairingBootstrappingMethod);
+        assertEquals("abed", aidlConnectInfo.password);
+    }
+
+    /**
+     * Test the handling of connect with pairing bootstrapping method: out of band
+     */
+    @Test
+    public void testConnectWithBootStrappingMethodOutOfBandSuccess() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doReturn("").when(mISupplicantP2pIfaceMock).connectWithParams(any());
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pConnectInfo>
+                connectInfoCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pConnectInfo.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pConfig config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_OUT_OF_BAND,
+                "", false);
+        config.getPairingBootstrappingConfig().setPairingBootstrappingPassword("abed");
+        assertTrue(mDut.connect(config, false).isEmpty());
+        verify(mISupplicantP2pIfaceMock).connectWithParams(connectInfoCaptor.capture());
+        android.hardware.wifi.supplicant.P2pConnectInfo aidlConnectInfo =
+                connectInfoCaptor.getValue();
+        assertArrayEquals(mPeerMacAddressBytes, aidlConnectInfo.peerAddress);
+        assertEquals(WpsProvisionMethod.NONE, aidlConnectInfo.provisionMethod);
+        assertEquals(P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OUT_OF_BAND,
+                aidlConnectInfo.pairingBootstrappingMethod);
+        assertEquals("abed", aidlConnectInfo.password);
+    }
+
+    /**
+     * Test the handling of authorize connection request to an existing group owner.
+     */
+    @Test
+    public void testAuthorizeConnectRequestOnGroupOwner() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        doReturn("").when(mISupplicantP2pIfaceMock).connectWithParams(any());
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pConnectInfo>
+                connectInfoCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pConnectInfo.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        WifiP2pConfig config = createP2pConfigWithBootstrappingMethod(mPeerMacAddressBytes,
+                WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_OUT_OF_BAND,
+                "1234", true);
+        assertTrue(mDut.authorizeConnectRequestOnGroupOwner(config,
+                TEST_GROUP_INTERFACE_NAME));
+        verify(mISupplicantP2pIfaceMock).connectWithParams(connectInfoCaptor.capture());
+        android.hardware.wifi.supplicant.P2pConnectInfo aidlConnectInfo =
+                connectInfoCaptor.getValue();
+        assertArrayEquals(mPeerMacAddressBytes, aidlConnectInfo.peerAddress);
+        assertEquals(WpsProvisionMethod.NONE, aidlConnectInfo.provisionMethod);
+        assertEquals(P2pPairingBootstrappingMethodMask.BOOTSTRAPPING_OUT_OF_BAND,
+                aidlConnectInfo.pairingBootstrappingMethod);
+        assertEquals(TEST_GROUP_INTERFACE_NAME, aidlConnectInfo.groupInterfaceName);
+        assertTrue(aidlConnectInfo.authorizeConnectionFromPeer);
+    }
+
+    /**
+     * Test the handling of reinvokePersistentGroup() with P2P version.
+     */
+    @Test
+    public void testReinvokeVersionHandling() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        setCachedServiceVersion(4);
+        ArgumentCaptor<android.hardware.wifi.supplicant.P2pReinvokePersistentGroupParams>
+                persistentGroupParamsCaptor = ArgumentCaptor.forClass(
+                android.hardware.wifi.supplicant.P2pReinvokePersistentGroupParams.class);
+
+        executeAndValidateInitializationSequence(false, false);
+
+        // Successful case.
+        doNothing().when(mISupplicantP2pIfaceMock).reinvoke(anyInt(), any());
+        doNothing().when(mISupplicantP2pIfaceMock).reinvokePersistentGroup(any());
+        assertTrue(mDut.reinvoke(-1, mPeerMacAddress, TEST_DEV_IK_ID));
+        verify(mISupplicantP2pIfaceMock).reinvokePersistentGroup(
+                persistentGroupParamsCaptor.capture());
+        android.hardware.wifi.supplicant.P2pReinvokePersistentGroupParams
+                aidlPersistentGroupParams = persistentGroupParamsCaptor.getValue();
+        assertArrayEquals(mPeerMacAddressBytes, aidlPersistentGroupParams.peerMacAddress);
+        assertEquals(-1, aidlPersistentGroupParams.persistentNetworkId);
+        assertEquals(TEST_DEV_IK_ID, aidlPersistentGroupParams.deviceIdentityEntryId);
+
+        // Invalid network ID and DIK ID
+        assertFalse(mDut.reinvoke(-1, mPeerMacAddress, -1));
+
+        // Valid network ID and invalid DIK ID - Reinvoke P2P V1 group
+        assertTrue(mDut.reinvoke(2, mPeerMacAddress, -1));
+        verify(mISupplicantP2pIfaceMock).reinvoke(eq(2), eq(mPeerMacAddressBytes));
+
+        // Valid network ID and invalid DIK ID on older HAL - Reinvoke P2P V1 group with old HAL
+        setCachedServiceVersion(3);
+        assertTrue(mDut.reinvoke(1, mPeerMacAddress, -1));
+        verify(mISupplicantP2pIfaceMock).reinvoke(eq(1), eq(mPeerMacAddressBytes));
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalHidlImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalHidlImplTest.java
index fff3d7bc0e..eaa2de685e 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalHidlImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalHidlImplTest.java
@@ -19,13 +19,13 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyByte;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyByte;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.inOrder;
@@ -1258,9 +1258,9 @@ public class SupplicantP2pIfaceHalHidlImplTest extends WifiBaseTest {
         when(mISupplicantP2pIfaceMock.reinvoke(anyInt(), eq(mPeerMacAddressBytes)))
                 .thenReturn(mStatusSuccess);
         // Default value when service is not initialized.
-        assertFalse(mDut.reinvoke(0, mPeerMacAddress));
+        assertFalse(mDut.reinvoke(0, mPeerMacAddress, -1));
         executeAndValidateInitializationSequence(false, false, false);
-        assertTrue(mDut.reinvoke(0, mPeerMacAddress));
+        assertTrue(mDut.reinvoke(0, mPeerMacAddress, -1));
     }
 
     /**
@@ -1273,8 +1273,10 @@ public class SupplicantP2pIfaceHalHidlImplTest extends WifiBaseTest {
                 .thenReturn(mStatusSuccess);
 
         for (String address : mInvalidMacAddresses) {
-            assertFalse(mDut.reinvoke(0, address));
+            assertFalse(mDut.reinvoke(0, address, -1));
         }
+
+        assertFalse(mDut.reinvoke(1, mPeerMacAddress, 1));
     }
 
     /**
@@ -1285,7 +1287,7 @@ public class SupplicantP2pIfaceHalHidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false, false);
         when(mISupplicantP2pIfaceMock.reinvoke(anyInt(), any(byte[].class)))
                 .thenReturn(mStatusFailure);
-        assertFalse(mDut.reinvoke(0, mPeerMacAddress));
+        assertFalse(mDut.reinvoke(0, mPeerMacAddress, -1));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
     }
@@ -1298,7 +1300,7 @@ public class SupplicantP2pIfaceHalHidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false, false);
         when(mISupplicantP2pIfaceMock.reinvoke(anyInt(), any(byte[].class)))
                 .thenThrow(mRemoteException);
-        assertFalse(mDut.reinvoke(0, mPeerMacAddress));
+        assertFalse(mDut.reinvoke(0, mPeerMacAddress, -1));
         // Check service is dead.
         assertFalse(mDut.isInitializationComplete());
     }
@@ -1312,9 +1314,9 @@ public class SupplicantP2pIfaceHalHidlImplTest extends WifiBaseTest {
         when(mISupplicantP2pIfaceMock.addGroup(eq(true), eq(3)))
                 .thenReturn(mStatusSuccess);
         // Default value when service is not initialized.
-        assertFalse(mDut.groupAdd(3, true));
+        assertFalse(mDut.groupAdd(3, true, false));
         executeAndValidateInitializationSequence(false, false, false);
-        assertTrue(mDut.groupAdd(3, true));
+        assertTrue(mDut.groupAdd(3, true, false));
     }
 
     /**
@@ -1325,7 +1327,7 @@ public class SupplicantP2pIfaceHalHidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false, false);
         when(mISupplicantP2pIfaceMock.addGroup(anyBoolean(), anyInt()))
                 .thenReturn(mStatusFailure);
-        assertFalse(mDut.groupAdd(0, true));
+        assertFalse(mDut.groupAdd(0, true, false));
         // Check that service is still alive.
         assertTrue(mDut.isInitializationComplete());
     }
@@ -1338,7 +1340,7 @@ public class SupplicantP2pIfaceHalHidlImplTest extends WifiBaseTest {
         executeAndValidateInitializationSequence(false, false, false);
         when(mISupplicantP2pIfaceMock.addGroup(anyBoolean(), anyInt()))
                 .thenThrow(mRemoteException);
-        assertFalse(mDut.groupAdd(0, true));
+        assertFalse(mDut.groupAdd(0, true, false));
         // Check service is dead.
         assertFalse(mDut.isInitializationComplete());
     }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalTest.java b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalTest.java
index dd8a5f6081..df953f3820 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/p2p/SupplicantP2pIfaceHalTest.java
@@ -19,6 +19,7 @@ package com.android.server.wifi.p2p;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
@@ -30,12 +31,18 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.net.MacAddress;
 import android.net.wifi.CoexUnsafeChannel;
 import android.net.wifi.p2p.WifiP2pConfig;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
+import android.net.wifi.util.Environment;
 
 import com.android.server.wifi.WifiBaseTest;
 import com.android.server.wifi.WifiGlobals;
@@ -71,8 +78,20 @@ public class SupplicantP2pIfaceHalTest extends WifiBaseTest {
     private static final String RESPONSE = "blahblahblah";
     private static final String PIN = "5678";
     private static final boolean ENABLE = true;
+    private static final boolean DISABLE = false;
     private static final int NETWORK_ID = 2;
     private static final int CHANNEL = 3;
+    private static final String TEST_USD_SERVICE_NAME = "test_service_name";
+    private static final int TEST_USD_PROTOCOL_TYPE = 4;
+    private static final byte[] TEST_USD_SERVICE_SPECIFIC_INFO = {10, 20, 30, 40, 50, 60};
+    private static final int TEST_USD_DISCOVERY_CHANNEL_FREQUENCY_MHZ = 2437;
+    private static final int[] TEST_USD_DISCOVERY_CHANNEL_FREQUENCIES_MHZ = {2412, 2437, 2462};
+    private static final int TEST_USD_TIMEOUT_SEC = 30;
+    private static final int TEST_USD_SESSION_ID = 2;
+    private static final byte[] TEST_NONCE = {10, 20, 30, 40, 50, 60, 70, 80};
+    private static final byte[] TEST_DIR_TAG = {11, 22, 33, 44, 55, 66, 77, 88};
+    private static final WifiP2pDirInfo TEST_DIR_INFO = new WifiP2pDirInfo(
+            MacAddress.fromString(BSSID), TEST_NONCE, TEST_DIR_TAG);
 
     private class SupplicantP2pIfaceHalSpy extends SupplicantP2pIfaceHal {
         SupplicantP2pIfaceHalSpy() {
@@ -412,9 +431,9 @@ public class SupplicantP2pIfaceHalTest extends WifiBaseTest {
     @Test
     public void testReinvoke() {
         initializeWithAidlImpl(true);
-        when(mP2pIfaceHalAidlMock.reinvoke(anyInt(), anyString())).thenReturn(true);
-        assertTrue(mDut.reinvoke(NETWORK_ID, BSSID));
-        verify(mP2pIfaceHalAidlMock).reinvoke(eq(NETWORK_ID), eq(BSSID));
+        when(mP2pIfaceHalAidlMock.reinvoke(anyInt(), anyString(), anyInt())).thenReturn(true);
+        assertTrue(mDut.reinvoke(NETWORK_ID, BSSID, -1));
+        verify(mP2pIfaceHalAidlMock).reinvoke(eq(NETWORK_ID), eq(BSSID), eq(-1));
     }
 
     /**
@@ -423,9 +442,9 @@ public class SupplicantP2pIfaceHalTest extends WifiBaseTest {
     @Test
     public void testGroupAdd() {
         initializeWithAidlImpl(true);
-        when(mP2pIfaceHalAidlMock.groupAdd(anyInt(), anyBoolean())).thenReturn(true);
-        assertTrue(mDut.groupAdd(NETWORK_ID, ENABLE));
-        verify(mP2pIfaceHalAidlMock).groupAdd(eq(NETWORK_ID), eq(ENABLE));
+        when(mP2pIfaceHalAidlMock.groupAdd(anyInt(), anyBoolean(), anyBoolean())).thenReturn(true);
+        assertTrue(mDut.groupAdd(NETWORK_ID, ENABLE, DISABLE));
+        verify(mP2pIfaceHalAidlMock).groupAdd(eq(NETWORK_ID), eq(ENABLE), eq(DISABLE));
     }
 
     /**
@@ -434,9 +453,9 @@ public class SupplicantP2pIfaceHalTest extends WifiBaseTest {
     @Test
     public void testGroupAddWrapper() {
         initializeWithAidlImpl(true);
-        when(mP2pIfaceHalAidlMock.groupAdd(anyInt(), anyBoolean())).thenReturn(true);
-        assertTrue(mDut.groupAdd(ENABLE));
-        verify(mP2pIfaceHalAidlMock).groupAdd(eq(-1) /* set by wrapper */, eq(ENABLE));
+        when(mP2pIfaceHalAidlMock.groupAdd(anyInt(), anyBoolean(), anyBoolean())).thenReturn(true);
+        assertTrue(mDut.groupAdd(ENABLE, DISABLE));
+        verify(mP2pIfaceHalAidlMock).groupAdd(eq(-1) /* set by wrapper */, eq(ENABLE), eq(DISABLE));
     }
 
     /**
@@ -849,4 +868,96 @@ public class SupplicantP2pIfaceHalTest extends WifiBaseTest {
         assertTrue(mDut.deregisterDeathHandler());
         verify(mP2pIfaceHalAidlMock).deregisterDeathHandler();
     }
+
+    /**
+     * Test the start of an Unsynchronized Service Discovery (USD) based P2P service discovery.
+     */
+    @Test
+    public void testStartUsdBasedServiceDiscovery() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        initializeWithAidlImpl(true);
+        when(mP2pIfaceHalAidlMock.startUsdBasedServiceDiscovery(any(), any(), anyInt()))
+                .thenReturn(TEST_USD_SESSION_ID);
+        WifiP2pUsdBasedServiceConfig usdConfig = new WifiP2pUsdBasedServiceConfig.Builder(
+                TEST_USD_SERVICE_NAME)
+                .setServiceProtocolType(TEST_USD_PROTOCOL_TYPE)
+                .setServiceSpecificInfo(TEST_USD_SERVICE_SPECIFIC_INFO).build();
+        WifiP2pUsdBasedServiceDiscoveryConfig serviceDiscoveryConfig =
+                new WifiP2pUsdBasedServiceDiscoveryConfig.Builder()
+                        .setFrequenciesMhz(TEST_USD_DISCOVERY_CHANNEL_FREQUENCIES_MHZ).build();
+        assertEquals(TEST_USD_SESSION_ID, mDut.startUsdBasedServiceDiscovery(
+                usdConfig, serviceDiscoveryConfig, TEST_USD_TIMEOUT_SEC));
+        verify(mP2pIfaceHalAidlMock).startUsdBasedServiceDiscovery(eq(usdConfig),
+                eq(serviceDiscoveryConfig), eq(TEST_USD_TIMEOUT_SEC));
+    }
+
+    /**
+     * Test the stop of an Unsynchronized Service Discovery (USD) based P2P service discovery.
+     */
+    @Test
+    public void testStopUsdBasedServiceDiscovery() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        initializeWithAidlImpl(true);
+        doNothing().when(mP2pIfaceHalAidlMock).stopUsdBasedServiceDiscovery(anyInt());
+        mDut.stopUsdBasedServiceDiscovery(TEST_USD_SESSION_ID);
+        verify(mP2pIfaceHalAidlMock).stopUsdBasedServiceDiscovery(eq(TEST_USD_SESSION_ID));
+    }
+
+    /**
+     * Test the start of an Unsynchronized Service Discovery (USD) based service advertisement.
+     */
+    @Test
+    public void testStartUsdBasedServiceAdvertisement() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        initializeWithAidlImpl(true);
+        when(mP2pIfaceHalAidlMock.startUsdBasedServiceAdvertisement(any(), any(), anyInt()))
+                .thenReturn(TEST_USD_SESSION_ID);
+        WifiP2pUsdBasedServiceConfig usdConfig = new WifiP2pUsdBasedServiceConfig.Builder(
+                TEST_USD_SERVICE_NAME)
+                .setServiceProtocolType(TEST_USD_PROTOCOL_TYPE)
+                .setServiceSpecificInfo(TEST_USD_SERVICE_SPECIFIC_INFO).build();
+        WifiP2pUsdBasedLocalServiceAdvertisementConfig serviceAdvertisementConfig =
+                new WifiP2pUsdBasedLocalServiceAdvertisementConfig.Builder()
+                        .setFrequencyMhz(TEST_USD_DISCOVERY_CHANNEL_FREQUENCY_MHZ).build();
+        assertEquals(TEST_USD_SESSION_ID, mDut.startUsdBasedServiceAdvertisement(
+                usdConfig, serviceAdvertisementConfig, TEST_USD_TIMEOUT_SEC));
+        verify(mP2pIfaceHalAidlMock).startUsdBasedServiceAdvertisement(eq(usdConfig),
+                eq(serviceAdvertisementConfig), eq(TEST_USD_TIMEOUT_SEC));
+    }
+
+    /**
+     * Test the stop of an Unsynchronized Service Discovery (USD) based service advertisement.
+     */
+    @Test
+    public void testStopUsdBasedServiceAdvertisement() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        initializeWithAidlImpl(true);
+        doNothing().when(mP2pIfaceHalAidlMock).stopUsdBasedServiceAdvertisement(anyInt());
+        mDut.stopUsdBasedServiceAdvertisement(TEST_USD_SESSION_ID);
+        verify(mP2pIfaceHalAidlMock).stopUsdBasedServiceAdvertisement(eq(TEST_USD_SESSION_ID));
+    }
+
+    /**
+     * Test get Device Identity Resolution (DIR) Information.
+     */
+    @Test
+    public void testGetDirInfo() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        initializeWithAidlImpl(true);
+        when(mP2pIfaceHalAidlMock.getDirInfo()).thenReturn(TEST_DIR_INFO);
+        assertEquals(TEST_DIR_INFO, mDut.getDirInfo());
+        verify(mP2pIfaceHalAidlMock).getDirInfo();
+    }
+
+    /**
+     * Test validate Device Identity Resolution (DIR) Information.
+     */
+    @Test
+    public void testValidateDirInfo() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        initializeWithAidlImpl(true);
+        when(mP2pIfaceHalAidlMock.validateDirInfo(any())).thenReturn(1);
+        assertEquals(1, mDut.validateDirInfo(TEST_DIR_INFO));
+        verify(mP2pIfaceHalAidlMock).validateDirInfo(eq(TEST_DIR_INFO));
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pMonitorTest.java b/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pMonitorTest.java
index be6da7112d..3f041e77c6 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pMonitorTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pMonitorTest.java
@@ -42,6 +42,8 @@ public class WifiP2pMonitorTest extends WifiBaseTest {
     private static final String P2P_IFACE_NAME = "p2p0";
     private static final String SECOND_P2P_IFACE_NAME = "p2p1";
     private static final int TEST_GROUP_FREQUENCY = 5180;
+    private static final int TEST_USD_SESSION_ID = 1;
+    private static final int TEST_USD_TERMINATED_REASON_CODE = 2;
     private WifiP2pMonitor mWifiP2pMonitor;
     private TestLooper mLooper;
     private Handler mHandlerSpy;
@@ -168,4 +170,162 @@ public class WifiP2pMonitorTest extends WifiBaseTest {
         assertEquals(event.device.deviceAddress,
                 ((WifiP2pProvDiscEvent) messageCaptor.getValue().obj).device.deviceAddress);
     }
+
+    /**
+     * Broadcast message when provision discovery request event with requested
+     * method: opportunistic
+     */
+    @Test
+    public void testBroadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticRequest()
+            throws Exception {
+        mWifiP2pMonitor.registerHandler(
+                P2P_IFACE_NAME, WifiP2pMonitor
+                        .P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT,
+                mHandlerSpy);
+        WifiP2pProvDiscEvent event = new WifiP2pProvDiscEvent();
+        event.device = new WifiP2pDevice();
+        event.device.deviceAddress = "11:22:33:44:55:66";
+        event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ;
+        mWifiP2pMonitor.broadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticRequest(
+                P2P_IFACE_NAME, event);
+        mLooper.dispatchAll();
+
+        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(mHandlerSpy).handleMessage(messageCaptor.capture());
+        assertEquals(WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT,
+                messageCaptor.getValue().what);
+        assertEquals(event.device.deviceAddress,
+                ((WifiP2pProvDiscEvent) messageCaptor.getValue().obj).device.deviceAddress);
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ,
+                ((WifiP2pProvDiscEvent) messageCaptor.getValue().obj).event);
+    }
+
+    /**
+     * Broadcast message when provision discovery response event with requested
+     * method: opportunistic
+     */
+    @Test
+    public void testBroadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticResponse()
+            throws Exception {
+        mWifiP2pMonitor.registerHandler(
+                P2P_IFACE_NAME, WifiP2pMonitor
+                        .P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT,
+                mHandlerSpy);
+        WifiP2pProvDiscEvent event = new WifiP2pProvDiscEvent();
+        event.device = new WifiP2pDevice();
+        event.device.deviceAddress = "11:22:33:44:55:66";
+        event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP;
+        mWifiP2pMonitor.broadcastP2pProvisionDiscoveryPairingBootstrappingOpportunisticResponse(
+                P2P_IFACE_NAME, event);
+        mLooper.dispatchAll();
+
+        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(mHandlerSpy).handleMessage(messageCaptor.capture());
+        assertEquals(WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT,
+                messageCaptor.getValue().what);
+        assertEquals(event.device.deviceAddress,
+                ((WifiP2pProvDiscEvent) messageCaptor.getValue().obj).device.deviceAddress);
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP,
+                ((WifiP2pProvDiscEvent) messageCaptor.getValue().obj).event);
+    }
+
+    /**
+     * Broadcast message when provision discovery response event with requested
+     * method: Keypad pin-code or passphrase
+     */
+    @Test
+    public void testBroadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase()
+            throws Exception {
+        mWifiP2pMonitor.registerHandler(
+                P2P_IFACE_NAME, WifiP2pMonitor
+                        .P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                mHandlerSpy);
+        WifiP2pProvDiscEvent event = new WifiP2pProvDiscEvent();
+        event.device = new WifiP2pDevice();
+        event.device.deviceAddress = "11:22:33:44:55:66";
+        event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN;
+        mWifiP2pMonitor.broadcastP2pProvisionDiscoveryEnterPairingBootstrappingPinOrPassphrase(
+                P2P_IFACE_NAME, event);
+        mLooper.dispatchAll();
+
+        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(mHandlerSpy).handleMessage(messageCaptor.capture());
+        assertEquals(WifiP2pMonitor
+                        .P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                messageCaptor.getValue().what);
+        assertEquals(event.device.deviceAddress,
+                ((WifiP2pProvDiscEvent) messageCaptor.getValue().obj).device.deviceAddress);
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN,
+                ((WifiP2pProvDiscEvent) messageCaptor.getValue().obj).event);
+    }
+
+    /**
+     * Broadcast message when provision discovery response event with requested
+     * method: Display pin-code or passphrase
+     */
+    @Test
+    public void testBroadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase()
+            throws Exception {
+        mWifiP2pMonitor.registerHandler(
+                P2P_IFACE_NAME, WifiP2pMonitor
+                        .P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                mHandlerSpy);
+        WifiP2pProvDiscEvent event = new WifiP2pProvDiscEvent();
+        event.device = new WifiP2pDevice();
+        event.device.deviceAddress = "11:22:33:44:55:66";
+        event.event = WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE;
+        mWifiP2pMonitor.broadcastP2pProvisionDiscoveryShowPairingBootstrappingPinOrPassphrase(
+                P2P_IFACE_NAME, event);
+        mLooper.dispatchAll();
+
+        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(mHandlerSpy).handleMessage(messageCaptor.capture());
+        assertEquals(WifiP2pMonitor
+                        .P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                messageCaptor.getValue().what);
+        assertEquals(event.device.deviceAddress,
+                ((WifiP2pProvDiscEvent) messageCaptor.getValue().obj).device.deviceAddress);
+        assertEquals(WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE,
+                ((WifiP2pProvDiscEvent) messageCaptor.getValue().obj).event);
+    }
+
+    /**
+     * Broadcast message when USD based service discovery is terminated.
+     */
+    @Test
+    public void testBroadcastUsdBasedServiceDiscoveryTerminated() throws Exception {
+        mWifiP2pMonitor.registerHandler(
+                P2P_IFACE_NAME, WifiP2pMonitor.USD_BASED_SERVICE_DISCOVERY_TERMINATED_EVENT,
+                mHandlerSpy);
+        mWifiP2pMonitor.broadcastUsdBasedServiceDiscoveryTerminated(P2P_IFACE_NAME,
+                TEST_USD_SESSION_ID, TEST_USD_TERMINATED_REASON_CODE);
+        mLooper.dispatchAll();
+
+        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(mHandlerSpy).handleMessage(messageCaptor.capture());
+        assertEquals(WifiP2pMonitor.USD_BASED_SERVICE_DISCOVERY_TERMINATED_EVENT,
+                messageCaptor.getValue().what);
+        assertEquals(TEST_USD_SESSION_ID, messageCaptor.getValue().arg1);
+        assertEquals(TEST_USD_TERMINATED_REASON_CODE, messageCaptor.getValue().arg2);
+    }
+
+    /**
+     * Broadcast message when USD based service advertisement is terminated.
+     */
+    @Test
+    public void testBroadcastUsdBasedServiceAdvertisementTerminated() throws Exception {
+        mWifiP2pMonitor.registerHandler(
+                P2P_IFACE_NAME, WifiP2pMonitor.USD_BASED_SERVICE_ADVERTISEMENT_TERMINATED_EVENT,
+                mHandlerSpy);
+        mWifiP2pMonitor.broadcastUsdBasedServiceAdvertisementTerminated(P2P_IFACE_NAME,
+                TEST_USD_SESSION_ID, TEST_USD_TERMINATED_REASON_CODE);
+        mLooper.dispatchAll();
+
+        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(mHandlerSpy).handleMessage(messageCaptor.capture());
+        assertEquals(WifiP2pMonitor.USD_BASED_SERVICE_ADVERTISEMENT_TERMINATED_EVENT,
+                messageCaptor.getValue().what);
+        assertEquals(TEST_USD_SESSION_ID, messageCaptor.getValue().arg1);
+        assertEquals(TEST_USD_TERMINATED_REASON_CODE, messageCaptor.getValue().arg2);
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pNativeTest.java b/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pNativeTest.java
index 0a32786e26..d90160e3b9 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pNativeTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pNativeTest.java
@@ -26,6 +26,7 @@ import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -33,15 +34,20 @@ import static org.mockito.Mockito.withSettings;
 
 import android.app.test.MockAnswerUtil.AnswerWithArguments;
 import android.hardware.wifi.V1_0.IWifiP2pIface;
+import android.net.MacAddress;
 import android.net.wifi.WifiMigration;
 import android.net.wifi.nl80211.WifiNl80211Manager;
 import android.net.wifi.p2p.WifiP2pConfig;
 import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceInfo;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
 import android.net.wifi.util.Environment;
 import android.os.Handler;
 import android.os.WorkSource;
@@ -100,6 +106,17 @@ public class WifiP2pNativeTest extends WifiBaseTest {
     private static final String TEST_NFC_SELECT_MSG = "select";
     private static final String TEST_CLIENT_LIST = "aa:bb:cc:dd:ee:ff 11:22:33:44:55:66";
     private static final String TEST_R2_DEVICE_INFO_HEX = "00020064";
+    private static final String TEST_USD_SERVICE_NAME = "test_service_name";
+    private static final int TEST_USD_PROTOCOL_TYPE = 4;
+    private static final byte[] TEST_USD_SERVICE_SPECIFIC_INFO = {10, 20, 30, 40, 50, 60};
+    private static final int TEST_USD_DISCOVERY_CHANNEL_FREQUENCY_MHZ = 2437;
+    private static final int[] TEST_USD_DISCOVERY_CHANNEL_FREQUENCIES_MHZ = {2412, 2437, 2462};
+    private static final int TEST_USD_TIMEOUT_SEC = 30;
+    private static final int TEST_USD_SESSION_ID = 2;
+    private static final byte[] TEST_NONCE = {10, 20, 30, 40, 50, 60, 70, 80};
+    private static final byte[] TEST_DIR_TAG = {11, 22, 33, 44, 55, 66, 77, 88};
+    private static final WifiP2pDirInfo TEST_DIR_INFO = new WifiP2pDirInfo(
+            MacAddress.fromString(TEST_BSSID), TEST_NONCE, TEST_DIR_TAG);
 
     @Mock private WifiNl80211Manager mWifiCondManager;
     @Mock private WifiNative mWifiNative;
@@ -751,9 +768,9 @@ public class WifiP2pNativeTest extends WifiBaseTest {
      */
     @Test
     public void testJoinGroup() {
-        when(mSupplicantP2pIfaceHalMock.groupAdd(anyBoolean())).thenReturn(true);
-        assertTrue(mWifiP2pNative.p2pGroupAdd(true));
-        verify(mSupplicantP2pIfaceHalMock).groupAdd(eq(true));
+        when(mSupplicantP2pIfaceHalMock.groupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
+        assertTrue(mWifiP2pNative.p2pGroupAdd(true, false));
+        verify(mSupplicantP2pIfaceHalMock).groupAdd(eq(true), eq(false));
     }
 
     /**
@@ -761,9 +778,10 @@ public class WifiP2pNativeTest extends WifiBaseTest {
      */
     @Test
     public void testJoinGroupWithNetworkId() {
-        when(mSupplicantP2pIfaceHalMock.groupAdd(anyInt(), anyBoolean())).thenReturn(true);
-        assertTrue(mWifiP2pNative.p2pGroupAdd(5));
-        verify(mSupplicantP2pIfaceHalMock).groupAdd(eq(5), eq(true));
+        when(mSupplicantP2pIfaceHalMock.groupAdd(anyInt(), anyBoolean(), anyBoolean()))
+                .thenReturn(true);
+        assertTrue(mWifiP2pNative.p2pGroupAdd(5, false));
+        verify(mSupplicantP2pIfaceHalMock).groupAdd(eq(5), eq(true), eq(false));
     }
 
     /**
@@ -909,13 +927,14 @@ public class WifiP2pNativeTest extends WifiBaseTest {
     }
 
     /**
-     * Verifies reinvoking a device from a persiste group..
+     * Verifies reinvoking a device from a persistent group.
      */
     @Test
     public void testP2pReinvoke() {
-        when(mSupplicantP2pIfaceHalMock.reinvoke(anyInt(), anyString())).thenReturn(true);
-        assertTrue(mWifiP2pNative.p2pReinvoke(5, TEST_BSSID));
-        verify(mSupplicantP2pIfaceHalMock).reinvoke(eq(5), eq(TEST_BSSID));
+        when(mSupplicantP2pIfaceHalMock.reinvoke(anyInt(), anyString(), anyInt()))
+                .thenReturn(true);
+        assertTrue(mWifiP2pNative.p2pReinvoke(5, TEST_BSSID, -1));
+        verify(mSupplicantP2pIfaceHalMock).reinvoke(eq(5), eq(TEST_BSSID), eq(-1));
     }
 
     /**
@@ -1223,4 +1242,122 @@ public class WifiP2pNativeTest extends WifiBaseTest {
                         | WifiP2pManager.FEATURE_GROUP_OWNER_IPV6_LINK_LOCAL_ADDRESS_PROVIDED,
                 mWifiP2pNative.getSupportedFeatures());
     }
+
+    /**
+     * Test the start of an Unsynchronized Service Discovery (USD) based P2P service discovery.
+     */
+    @Test
+    public void testStartUsdBasedServiceDiscovery() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        when(mSupplicantP2pIfaceHalMock.startUsdBasedServiceDiscovery(
+                any(), any(), anyInt())).thenReturn(TEST_USD_SESSION_ID);
+        WifiP2pUsdBasedServiceConfig usdConfig = new WifiP2pUsdBasedServiceConfig.Builder(
+                TEST_USD_SERVICE_NAME)
+                .setServiceProtocolType(TEST_USD_PROTOCOL_TYPE)
+                .setServiceSpecificInfo(TEST_USD_SERVICE_SPECIFIC_INFO).build();
+        WifiP2pUsdBasedServiceDiscoveryConfig serviceDiscoveryConfig =
+                new WifiP2pUsdBasedServiceDiscoveryConfig.Builder()
+                        .setFrequenciesMhz(TEST_USD_DISCOVERY_CHANNEL_FREQUENCIES_MHZ).build();
+        ArgumentCaptor<WifiP2pUsdBasedServiceConfig> usdConfigCaptor = ArgumentCaptor.forClass(
+                WifiP2pUsdBasedServiceConfig.class);
+        ArgumentCaptor<WifiP2pUsdBasedServiceDiscoveryConfig> discoveryConfigCaptor =
+                ArgumentCaptor.forClass(WifiP2pUsdBasedServiceDiscoveryConfig.class);
+        assertEquals(TEST_USD_SESSION_ID, mWifiP2pNative.startUsdBasedServiceDiscovery(
+                usdConfig, serviceDiscoveryConfig, TEST_USD_TIMEOUT_SEC));
+        verify(mSupplicantP2pIfaceHalMock).startUsdBasedServiceDiscovery(
+                usdConfigCaptor.capture(),
+                discoveryConfigCaptor.capture(), eq(TEST_USD_TIMEOUT_SEC));
+        assertEquals(usdConfig, usdConfigCaptor.getValue());
+        assertEquals(serviceDiscoveryConfig, discoveryConfigCaptor.getValue());
+    }
+
+    /**
+     * Test the stop of an Unsynchronized Service Discovery (USD) based P2P service discovery.
+     */
+    @Test
+    public void testStopUsdBasedServiceDiscovery() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        doNothing().when(mSupplicantP2pIfaceHalMock).stopUsdBasedServiceDiscovery(anyInt());
+        mWifiP2pNative.stopUsdBasedServiceDiscovery(TEST_USD_SESSION_ID);
+        verify(mSupplicantP2pIfaceHalMock).stopUsdBasedServiceDiscovery(eq(TEST_USD_SESSION_ID));
+    }
+
+    /**
+     * Test the start of an Unsynchronized Service Discovery (USD) based service advertisement.
+     */
+    @Test
+    public void testStartUsdBasedServiceAdvertisement() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        when(mSupplicantP2pIfaceHalMock.startUsdBasedServiceAdvertisement(
+                any(), any(), anyInt())).thenReturn(TEST_USD_SESSION_ID);
+        WifiP2pUsdBasedServiceConfig usdConfig = new WifiP2pUsdBasedServiceConfig.Builder(
+                TEST_USD_SERVICE_NAME)
+                .setServiceProtocolType(TEST_USD_PROTOCOL_TYPE)
+                .setServiceSpecificInfo(TEST_USD_SERVICE_SPECIFIC_INFO).build();
+        WifiP2pUsdBasedLocalServiceAdvertisementConfig serviceAdvertisementConfig =
+                new WifiP2pUsdBasedLocalServiceAdvertisementConfig.Builder()
+                        .setFrequencyMhz(TEST_USD_DISCOVERY_CHANNEL_FREQUENCY_MHZ).build();
+        ArgumentCaptor<WifiP2pUsdBasedServiceConfig> usdConfigCaptor = ArgumentCaptor.forClass(
+                WifiP2pUsdBasedServiceConfig.class);
+        ArgumentCaptor<WifiP2pUsdBasedLocalServiceAdvertisementConfig>
+                serviceAdvertisementConfigCaptor = ArgumentCaptor.forClass(
+                WifiP2pUsdBasedLocalServiceAdvertisementConfig.class);
+        assertEquals(TEST_USD_SESSION_ID, mWifiP2pNative.startUsdBasedServiceAdvertisement(
+                usdConfig, serviceAdvertisementConfig,
+                TEST_USD_TIMEOUT_SEC));
+        verify(mSupplicantP2pIfaceHalMock).startUsdBasedServiceAdvertisement(
+                usdConfigCaptor.capture(),
+                serviceAdvertisementConfigCaptor.capture(), eq(TEST_USD_TIMEOUT_SEC));
+        assertEquals(usdConfig, usdConfigCaptor.getValue());
+        assertEquals(serviceAdvertisementConfig, serviceAdvertisementConfigCaptor.getValue());
+    }
+
+    /**
+     * Test the stop of an Unsynchronized Service Discovery (USD) based service advertisement.
+     */
+    @Test
+    public void testStopUsdBasedServiceAdvertisement() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        doNothing().when(mSupplicantP2pIfaceHalMock).stopUsdBasedServiceAdvertisement(anyInt());
+        mWifiP2pNative.stopUsdBasedServiceAdvertisement(TEST_USD_SESSION_ID);
+        verify(mSupplicantP2pIfaceHalMock).stopUsdBasedServiceAdvertisement(
+                eq(TEST_USD_SESSION_ID));
+    }
+
+    /**
+     * Test get Device Identity Resolution (DIR) Information.
+     */
+    @Test
+    public void testGetDirInfo() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        when(mSupplicantP2pIfaceHalMock.getDirInfo()).thenReturn(TEST_DIR_INFO);
+        assertEquals(TEST_DIR_INFO, mWifiP2pNative.getDirInfo());
+        verify(mSupplicantP2pIfaceHalMock).getDirInfo();
+    }
+
+    /**
+     * Test validate Device Identity Resolution (DIR) Information.
+     */
+    @Test
+    public void testValidateDirInfo() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        when(mSupplicantP2pIfaceHalMock.validateDirInfo(any())).thenReturn(1);
+        assertEquals(1, mWifiP2pNative.validateDirInfo(TEST_DIR_INFO));
+        verify(mSupplicantP2pIfaceHalMock).validateDirInfo(eq(TEST_DIR_INFO));
+    }
+
+    /**
+     * Test authorize a connection request to an existing Group Owner.
+     */
+    @Test
+    public void testAuthorizeConnectRequestOnGroupOwner() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        when(mSupplicantP2pIfaceHalMock.authorizeConnectRequestOnGroupOwner(any(), anyString()))
+                .thenReturn(true);
+        WifiP2pConfig config = new WifiP2pConfig();
+        config.deviceAddress = TEST_BSSID;
+        assertTrue(mWifiP2pNative.authorizeConnectRequestOnGroupOwner(config, TEST_IFACE));
+        verify(mSupplicantP2pIfaceHalMock).authorizeConnectRequestOnGroupOwner(
+                eq(config), eq(TEST_IFACE));
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pServiceImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pServiceImplTest.java
index 1298be08b0..dd1e7a9937 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pServiceImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/p2p/WifiP2pServiceImplTest.java
@@ -21,6 +21,11 @@ import static android.net.NetworkInfo.DetailedState.DISCONNECTED;
 import static android.net.NetworkInfo.DetailedState.FAILED;
 import static android.net.NetworkInfo.DetailedState.IDLE;
 import static android.net.wifi.WifiManager.EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE;
+import static android.net.wifi.p2p.WifiP2pConfig.GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL;
+import static android.net.wifi.p2p.WifiP2pManager.EXTRA_PARAM_KEY_USD_BASED_LOCAL_SERVICE_ADVERTISEMENT_CONFIG;
+import static android.net.wifi.p2p.WifiP2pManager.EXTRA_PARAM_KEY_USD_BASED_SERVICE_DISCOVERY_CONFIG;
+import static android.net.wifi.p2p.WifiP2pManager.WIFI_P2P_USD_BASED_ADD_LOCAL_SERVICE;
+import static android.net.wifi.p2p.WifiP2pManager.WIFI_P2P_USD_BASED_SERVICE_DISCOVERY;
 
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
 import static com.android.net.module.util.Inet4AddressUtils.inet4AddressToIntHTL;
@@ -29,7 +34,6 @@ import static com.android.server.wifi.WifiSettingsConfigStore.WIFI_P2P_DEVICE_AD
 import static com.android.server.wifi.WifiSettingsConfigStore.WIFI_P2P_DEVICE_NAME;
 import static com.android.server.wifi.WifiSettingsConfigStore.WIFI_P2P_PENDING_FACTORY_RESET;
 import static com.android.server.wifi.WifiSettingsConfigStore.WIFI_VERBOSE_LOGGING_ENABLED;
-import static com.android.server.wifi.p2p.WifiP2pServiceImpl.IPC_DHCP_RESULTS;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -41,13 +45,13 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.argThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.ArgumentMatchers.isNull;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doNothing;
@@ -79,7 +83,6 @@ import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.location.LocationManager;
 import android.net.ConnectivityManager;
-import android.net.DhcpResultsParcelable;
 import android.net.InetAddresses;
 import android.net.LinkAddress;
 import android.net.MacAddress;
@@ -100,15 +103,20 @@ import android.net.wifi.p2p.IWifiP2pListener;
 import android.net.wifi.p2p.WifiP2pConfig;
 import android.net.wifi.p2p.WifiP2pDevice;
 import android.net.wifi.p2p.WifiP2pDeviceList;
+import android.net.wifi.p2p.WifiP2pDirInfo;
 import android.net.wifi.p2p.WifiP2pExtListenParams;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pInfo;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pPairingBootstrappingConfig;
 import android.net.wifi.p2p.WifiP2pProvDiscEvent;
+import android.net.wifi.p2p.WifiP2pUsdBasedLocalServiceAdvertisementConfig;
+import android.net.wifi.p2p.WifiP2pUsdBasedServiceDiscoveryConfig;
 import android.net.wifi.p2p.WifiP2pWfdInfo;
 import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
 import android.net.wifi.p2p.nsd.WifiP2pServiceRequest;
+import android.net.wifi.p2p.nsd.WifiP2pUsdBasedServiceConfig;
 import android.net.wifi.util.Environment;
 import android.os.Binder;
 import android.os.Build;
@@ -205,7 +213,6 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     private static final String thisDeviceName = "thisDeviceName";
     private static final String ANONYMIZED_DEVICE_ADDRESS = "02:00:00:00:00:00";
     private static final String TEST_PACKAGE_NAME = "com.p2p.test";
-    private static final String TEST_PACKAGE2_NAME = "com.p2p.test2";
     private static final String TEST_NETWORK_NAME = "DIRECT-xy-NEW";
     private static final String TEST_ANDROID_ID = "314Deadbeef";
     private static final String[] TEST_REQUIRED_PERMISSIONS_T =
@@ -222,6 +229,16 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     private static final int P2P_PEER_AUTH_TIMEOUT_MS = 1000;
     private static final int P2P_EXT_LISTEN_PERIOD_MS = 250;
     private static final int P2P_EXT_LISTEN_INTERVAL_MS = 450;
+    private static final String TEST_DEVICE_MAC_ADDRESS_STRING = "00:11:22:33:44:55";
+    private static final byte[] TEST_NONCE = {10, 20, 30, 40, 50, 60, 70, 80};
+    private static final byte[] TEST_DIR_TAG = {11, 22, 33, 44, 55, 66, 77, 88};
+    private static final String TEST_USD_SERVICE_NAME = "test_service_name";
+    private static final int TEST_USD_PROTOCOL_TYPE = 4;
+    private static final byte[] TEST_USD_SERVICE_SPECIFIC_INFO = {10, 20, 30, 40, 50, 60};
+    private static final int TEST_USD_DISCOVERY_CHANNEL_FREQUENCY_MHZ = 2437;
+    private static final int[] TEST_USD_DISCOVERY_CHANNEL_FREQUENCIES_MHZ = {2412, 2437, 2462};
+    private static final int TEST_USD_SESSION_ID = 2;
+    private static final int TEST_DIK_ID = 3;
 
     private ArgumentCaptor<BroadcastReceiver> mBcastRxCaptor = ArgumentCaptor.forClass(
             BroadcastReceiver.class);
@@ -234,10 +251,8 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     private BroadcastReceiver mTetherStateReceiver;
     private BroadcastReceiver mUserRestrictionReceiver;
     private Handler mClientHandler;
-    private Handler mClient2Handler;
     private Messenger mP2pStateMachineMessenger;
     private Messenger mClientMessenger;
-    private Messenger mClient2Messenger;
     private WifiP2pServiceImpl mWifiP2pServiceImpl;
     private TestLooper mClientHanderLooper;
     private TestLooper mLooper;
@@ -245,9 +260,11 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     private WifiP2pConfig mTestWifiP2pPeerConfig;
     private WifiP2pConfig mTestWifiP2pFastConnectionConfig;
     private WifiP2pConfig mTestWifiP2pJoinExistingGroupConfig;
+    private WifiP2pConfig mTestWifiP2pV2PeerConfig;
     private WifiP2pGroup mTestWifiP2pNewPersistentGoGroup;
     private WifiP2pGroup mTestWifiP2pGroup;
     private WifiP2pDevice mTestWifiP2pDevice;
+    private WifiP2pDevice mTestWifiP2pV2Device;
     private WifiP2pGroupList mGroups = new WifiP2pGroupList(null, null);
     private WifiP2pDevice mTestThisDevice;
     private ArgumentCaptor<Message> mMessageCaptor = ArgumentCaptor.forClass(Message.class);
@@ -258,10 +275,14 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     private TetheringManager.TetheringEventCallback mTetheringEventCallback;
     private Bundle mExtras = new Bundle();
     private IWifiP2pListener mP2pListener = mock(IWifiP2pListener.class);
-    private IWifiP2pListener mP2pListener2 = mock(IWifiP2pListener.class);
     private ArgumentCaptor<WifiSettingsConfigStore.OnSettingsChangedListener>
             mD2DAllowedSettingsCallbackCaptor =
             ArgumentCaptor.forClass(WifiSettingsConfigStore.OnSettingsChangedListener.class);
+    private WifiP2pServiceInfo mTestUsdServiceInfo;
+    private WifiP2pUsdBasedServiceConfig mTestUsdConfig;
+    private WifiP2pUsdBasedLocalServiceAdvertisementConfig mTestUsdServiceAdvertisementConfig;
+    private WifiP2pServiceRequest mTestUsdServiceRequest;
+    private WifiP2pUsdBasedServiceDiscoveryConfig mTestUsdServiceDiscoveryConfig;
 
     @Mock Bundle mBundle;
     @Mock Context mContext;
@@ -319,6 +340,12 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         mTestWifiP2pDevice.deviceName = "TestDeviceName";
         mTestWifiP2pDevice.deviceAddress = "aa:bb:cc:dd:ee:ff";
 
+        if (Environment.isSdkAtLeastB()) {
+            mTestWifiP2pV2Device = spy(new WifiP2pDevice());
+            mTestWifiP2pV2Device.deviceName = "TestV2DeviceName";
+            mTestWifiP2pV2Device.deviceAddress = TEST_DEVICE_MAC_ADDRESS_STRING;
+        }
+
         mTestWifiP2pPeerAddress = MacAddress.fromString(mTestWifiP2pDevice.deviceAddress);
 
         // for general connect command
@@ -371,6 +398,19 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         mTestThisDevice.deviceName = thisDeviceName;
         mTestThisDevice.deviceAddress = thisDeviceMac;
         mTestThisDevice.primaryDeviceType = "10-0050F204-5";
+
+        if (Environment.isSdkAtLeastB()) {
+            mTestUsdConfig = new WifiP2pUsdBasedServiceConfig.Builder(
+                    TEST_USD_SERVICE_NAME)
+                    .setServiceProtocolType(TEST_USD_PROTOCOL_TYPE)
+                    .setServiceSpecificInfo(TEST_USD_SERVICE_SPECIFIC_INFO).build();
+            mTestUsdServiceInfo = new WifiP2pServiceInfo(mTestUsdConfig);
+            mTestUsdServiceAdvertisementConfig = new WifiP2pUsdBasedLocalServiceAdvertisementConfig
+                    .Builder().setFrequencyMhz(TEST_USD_DISCOVERY_CHANNEL_FREQUENCY_MHZ).build();
+            mTestUsdServiceRequest = new WifiP2pServiceRequest(mTestUsdConfig);
+            mTestUsdServiceDiscoveryConfig = new WifiP2pUsdBasedServiceDiscoveryConfig.Builder()
+                    .setFrequenciesMhz(TEST_USD_DISCOVERY_CHANNEL_FREQUENCIES_MHZ).build();
+        }
     }
 
     /**
@@ -659,10 +699,9 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     /**
      * Send WifiP2pMonitor.P2P_GROUP_REMOVED_EVENT.
      */
-    private void sendGroupRemovedMsg(WifiP2pGroup group) throws Exception {
+    private void sendGroupRemovedMsg() throws Exception {
         Message msg = Message.obtain();
         msg.what = WifiP2pMonitor.P2P_GROUP_REMOVED_EVENT;
-        msg.obj = group;
         mP2pStateMachineMessenger.send(Message.obtain(msg));
         mLooper.dispatchAll();
     }
@@ -1391,9 +1430,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         generatorTestData();
         mClientHanderLooper = new TestLooper();
         mClientHandler = spy(new Handler(mClientHanderLooper.getLooper()));
-        mClient2Handler = spy(new Handler(mClientHanderLooper.getLooper()));
         mClientMessenger =  new Messenger(mClientHandler);
-        mClient2Messenger =  new Messenger(mClient2Handler);
         mLooper = new TestLooper();
 
         when(mContext.getSystemService(Context.ALARM_SERVICE))
@@ -1527,7 +1564,6 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         when(mDeviceConfigFacade.isP2pFailureBugreportEnabled()).thenReturn(false);
         when(mContext.getSystemService(TetheringManager.class)).thenReturn(mTetheringManager);
         when(mP2pListener.asBinder()).thenReturn(mock(IBinder.class));
-        when(mP2pListener2.asBinder()).thenReturn(mock(IBinder.class));
 
         mWifiP2pServiceImpl = new WifiP2pServiceImpl(mContext, mWifiInjector);
         if (supported) {
@@ -1586,8 +1622,8 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         when(mView.findViewById(eq(R.id.info))).thenReturn(mock(ViewGroup.class));
         ArrayList<InetAddress> p2pInetAddresses = new ArrayList<>();
         p2pInetAddresses.add(InetAddresses.parseNumericAddress(P2P_GO_IP));
-        when(mP2pNetworkInterface.getInetAddresses())
-                .thenReturn(Collections.enumeration(p2pInetAddresses));
+        doAnswer(invocation -> Collections.enumeration(new ArrayList<>(p2pInetAddresses)))
+                .when(mP2pNetworkInterface).getInetAddresses();
 
         setUpWifiP2pServiceImpl(true);
         mClient1 = new Binder();
@@ -1596,7 +1632,12 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         mWifiP2pServiceImpl.handleBootCompleted();
         if (SdkLevel.isAtLeastT()) {
             mWifiP2pServiceImpl.registerWifiP2pListener(mP2pListener, TEST_PACKAGE_NAME, mExtras);
-            mWifiP2pServiceImpl.registerWifiP2pListener(mP2pListener2, TEST_PACKAGE2_NAME, mExtras);
+        }
+
+        if (Environment.isSdkAtLeastB()) {
+            when(mWifiNative.getSupportedFeatures()).thenReturn(
+                    WifiP2pManager.FEATURE_WIFI_DIRECT_R2);
+            when(mFeatureFlags.wifiDirectR2()).thenReturn(true);
         }
     }
 
@@ -1685,6 +1726,9 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
      */
     private void mockPeersList() throws Exception {
         sendDeviceFoundEventMsg(mTestWifiP2pDevice);
+        if (Environment.isSdkAtLeastB()) {
+            sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        }
     }
 
     /**
@@ -2079,7 +2123,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
 
         sendCreateGroupMsgWithConfigValidAsGroup(mClientMessenger);
         assertTrue(mClientHandler.hasMessages(WifiP2pManager.CREATE_GROUP_FAILED));
-        verify(mWifiNative, never()).p2pGroupAdd(anyBoolean());
+        verify(mWifiNative, never()).p2pGroupAdd(anyBoolean(), anyBoolean());
         verify(mWifiNative, never()).p2pGroupAdd(any(), anyBoolean());
     }
 
@@ -2096,7 +2140,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         sendChannelInfoUpdateMsg("wrongpkg", "testFeature", mClient1, mClientMessenger);
         sendCreateGroupMsgWithConfigValidAsGroup(mClientMessenger);
         assertTrue(mClientHandler.hasMessages(WifiP2pManager.CREATE_GROUP_FAILED));
-        verify(mWifiNative, never()).p2pGroupAdd(anyBoolean());
+        verify(mWifiNative, never()).p2pGroupAdd(anyBoolean(), anyBoolean());
         verify(mWifiNative, never()).p2pGroupAdd(any(), anyBoolean());
     }
 
@@ -2119,7 +2163,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         }
         sendCreateGroupMsgWithConfigValidAsGroup(mClientMessenger);
         assertTrue(mClientHandler.hasMessages(WifiP2pManager.CREATE_GROUP_FAILED));
-        verify(mWifiNative, never()).p2pGroupAdd(anyBoolean());
+        verify(mWifiNative, never()).p2pGroupAdd(anyBoolean(), anyBoolean());
         verify(mWifiNative, never()).p2pGroupAdd(any(), anyBoolean());
         if (SdkLevel.isAtLeastT()) {
             verify(mWifiPermissionsUtil, atLeastOnce()).checkNearbyDevicesPermission(
@@ -2974,407 +3018,6 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
                 anyInt(), anyInt(), anyString(), eq(true));
     }
 
-    /**
-     * Sets up the environment for P2P Ownership test where Client1 is the group owner.
-     */
-    private void groupOwnershipConfigTestSetup() throws Exception {
-        assumeTrue(SdkLevel.isAtLeastV());
-        when(mFeatureFlags.p2pOwnership()).thenReturn(true);
-        forceP2pEnabled(mClient1);
-        sendChannelInfoUpdateMsg(TEST_PACKAGE2_NAME, "testFeature", mClient2, mClient2Messenger);
-
-        // group created by client1
-        when(mWifiNative.p2pGroupAdd(any(), eq(false))).thenReturn(true);
-        sendCreateGroupMsgWithConfigValidAsGroup(mClientMessenger);
-        verify(mWifiNative).p2pGroupAdd(any(), eq(false));
-        assertTrue(mClientHandler.hasMessages(WifiP2pManager.CREATE_GROUP_SUCCEEDED));
-        assertFalse(mClient2Handler.hasMessages(WifiP2pManager.CREATE_GROUP_SUCCEEDED));
-
-        WifiP2pGroup group = new WifiP2pGroup();
-        group.setNetworkName("DIRECT-test");
-        group.setOwner(new WifiP2pDevice("thisDeviceMac"));
-        group.setIsGroupOwner(true);
-        group.setInterface(IFACE_NAME_P2P);
-        sendGroupStartedMsg(group);
-        simulateTetherReady();
-        reset(mClientHandler);
-    }
-
-    /**
-     * Sets up the environment for P2P Ownership test with WPS group.
-     */
-    private void groupOwnershipWpsTestSetup() throws Exception {
-        assumeTrue(SdkLevel.isAtLeastV());
-        mWifiP2pServiceImpl.registerWifiP2pListener(mP2pListener2, TEST_PACKAGE2_NAME, mExtras);
-        forceP2pEnabled(mClient1);
-        sendChannelInfoUpdateMsg(TEST_PACKAGE2_NAME, "testFeature", mClient2, mClient2Messenger);
-
-        // WPS group created
-        WifiP2pGroup group = new WifiP2pGroup();
-        group.setNetworkId(WifiP2pGroup.NETWORK_ID_PERSISTENT);
-        group.setNetworkName(TEST_NETWORK_NAME);
-        group.setOwner(new WifiP2pDevice("thisDeviceMac"));
-        group.setIsGroupOwner(true);
-        group.setInterface(IFACE_NAME_P2P);
-        sendGroupStartedMsg(group);
-        simulateTetherReady();
-    }
-
-    /** Verify that only the group owner can send an invitation connection */
-    @Test
-    public void testGroupOwnershipConfigJoinInvite() throws Exception {
-        groupOwnershipConfigTestSetup();
-
-        // client2 cannot send an invitation to join
-        sendConnectMsg(mClient2Messenger, mTestWifiP2pPeerConfig);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CONNECT_FAILED, message.what);
-        assertEquals(WifiP2pManager.BUSY, message.arg1);
-
-        // client1 can send an invitation to join
-        when(mWifiNative.p2pInvite(any(), any())).thenReturn(true);
-        mockPeersList();
-        sendConnectMsg(mClientMessenger, mTestWifiP2pPeerConfig);
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CONNECT_SUCCEEDED, message.what);
-    }
-
-    /** Verify that any client can send an invitation connection */
-    @Test
-    public void testGroupOwnershipWpsJoinInvite() throws Exception {
-        groupOwnershipWpsTestSetup();
-
-        // client1 can send an invitation to join
-        when(mWifiNative.p2pInvite(any(), any())).thenReturn(true);
-        mockPeersList();
-        sendConnectMsg(mClientMessenger, mTestWifiP2pPeerConfig);
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CONNECT_SUCCEEDED, message.what);
-
-        // client2 can send an invitation to join
-        sendConnectMsg(mClient2Messenger, mTestWifiP2pPeerConfig);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CONNECT_SUCCEEDED, message.what);
-    }
-
-    /** Verify that only the group owner can cancel an invitation connection */
-    @Test
-    public void testGroupOwnershipConfigCancelInvitationConnect() throws Exception {
-        groupOwnershipConfigTestSetup();
-
-        // client2 cannot cancel invitation connection
-        sendSimpleMsg(mClient2Messenger, WifiP2pManager.CANCEL_CONNECT);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CANCEL_CONNECT_FAILED, message.what);
-        assertEquals(WifiP2pManager.BUSY, message.arg1);
-
-        // client1 can cancel invitation connection
-        sendSimpleMsg(mClientMessenger, WifiP2pManager.CANCEL_CONNECT);
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CANCEL_CONNECT_SUCCEEDED, message.what);
-    }
-
-    /** Verify that any client can cancel an invitation connection */
-    @Test
-    public void testGroupOwnershipWpsCancelInvitationConnect() throws Exception {
-        groupOwnershipWpsTestSetup();
-
-        // client1 can cancel invitation connection
-        sendSimpleMsg(mClientMessenger, WifiP2pManager.CANCEL_CONNECT);
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CANCEL_CONNECT_SUCCEEDED, message.what);
-
-        // client2 can cancel invitation connection
-        sendSimpleMsg(mClient2Messenger, WifiP2pManager.CANCEL_CONNECT);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CANCEL_CONNECT_SUCCEEDED, message.what);
-    }
-
-    /** Verify that only the client that initiated the connection can cancel it */
-    @Test
-    public void testGroupOwnershipConfigCancelConnect() throws Exception {
-        assumeTrue(SdkLevel.isAtLeastV());
-        when(mFeatureFlags.p2pOwnership()).thenReturn(true);
-        forceP2pEnabled(mClient1);
-        sendChannelInfoUpdateMsg(TEST_PACKAGE2_NAME, "testFeature", mClient2, mClient2Messenger);
-
-        // group created by client1
-        when(mWifiNative.p2pGroupAdd(any(), eq(false))).thenReturn(true);
-        sendCreateGroupMsgWithConfigValidAsGroup(mClientMessenger);
-        verify(mWifiNative).p2pGroupAdd(any(), eq(false));
-        reset(mClientHandler);
-
-        // client2 cannot cancel connection
-        sendSimpleMsg(mClient2Messenger, WifiP2pManager.CANCEL_CONNECT);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CANCEL_CONNECT_FAILED, message.what);
-        assertEquals(WifiP2pManager.BUSY, message.arg1);
-
-        // client1 can cancel connection
-        sendSimpleMsg(mClientMessenger, WifiP2pManager.CANCEL_CONNECT);
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CANCEL_CONNECT_SUCCEEDED, message.what);
-    }
-
-    /** Verify that any client can cancel an ongoing WPS connection */
-    @Test
-    public void testGroupOwnershipWpsCancelConnect() throws Exception {
-        assumeTrue(SdkLevel.isAtLeastV());
-        when(mFeatureFlags.p2pOwnership()).thenReturn(true);
-        forceP2pEnabled(mClient1);
-        sendChannelInfoUpdateMsg(TEST_PACKAGE2_NAME, "testFeature", mClient2, mClient2Messenger);
-
-        // connection initiated by client1
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
-        mockEnterGroupNegotiationState();
-
-        // client2 can cancel connection
-        sendSimpleMsg(mClient2Messenger, WifiP2pManager.CANCEL_CONNECT);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.CANCEL_CONNECT_SUCCEEDED, message.what);
-    }
-
-    /** Verify that only the group owner can remove the group */
-    @Test
-    public void testGroupOwnershipConfigRemoveGroup() throws Exception {
-        groupOwnershipConfigTestSetup();
-
-        // client2 cannot remove group
-        sendSimpleMsg(mClient2Messenger, WifiP2pManager.REMOVE_GROUP);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.REMOVE_GROUP_FAILED, message.what);
-        assertEquals(WifiP2pManager.BUSY, message.arg1);
-
-        // client1 can remove group
-        when(mWifiNative.p2pGroupRemove(eq(IFACE_NAME_P2P))).thenReturn(true);
-        sendSimpleMsg(mClientMessenger, WifiP2pManager.REMOVE_GROUP);
-        verify(mWifiNative).p2pGroupRemove(eq(IFACE_NAME_P2P));
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.REMOVE_GROUP_SUCCEEDED, message.what);
-    }
-
-    /** Verify that any client can remove the group */
-    @Test
-    public void testGroupOwnershipWpsRemoveGroup() throws Exception {
-        groupOwnershipWpsTestSetup();
-
-        // client2 can remove group
-        when(mWifiNative.p2pGroupRemove(eq(IFACE_NAME_P2P))).thenReturn(true);
-        sendSimpleMsg(mClient2Messenger, WifiP2pManager.REMOVE_GROUP);
-        verify(mWifiNative).p2pGroupRemove(eq(IFACE_NAME_P2P));
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        assertEquals(WifiP2pManager.REMOVE_GROUP_SUCCEEDED, message.what);
-    }
-
-    /** Verify that only the group owner can get group info */
-    @Test
-    public void testGroupOwnershipConfigGetGroupInformation() throws Exception {
-        groupOwnershipConfigTestSetup();
-
-        // client2 cannot get P2P group info
-        sendRequestGroupInfoMsg(mClient2Messenger);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        assertEquals(WifiP2pManager.RESPONSE_GROUP_INFO, mMessageCaptor.getValue().what);
-        WifiP2pGroup wifiP2pGroup = (WifiP2pGroup) mMessageCaptor.getValue().obj;
-        assertNull(wifiP2pGroup);
-
-        // client1 can get P2P group info
-        sendRequestGroupInfoMsg(mClientMessenger);
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        assertEquals(WifiP2pManager.RESPONSE_GROUP_INFO, mMessageCaptor.getValue().what);
-        wifiP2pGroup = (WifiP2pGroup) mMessageCaptor.getValue().obj;
-        assertNotNull(wifiP2pGroup);
-    }
-
-    /** Verify that any client can get group info */
-    @Test
-    public void testGroupOwnershipWpsGetGroupInformation() throws Exception {
-        groupOwnershipWpsTestSetup();
-
-        // client1 can get P2P group info
-        sendRequestGroupInfoMsg(mClientMessenger);
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        assertEquals(WifiP2pManager.RESPONSE_GROUP_INFO, mMessageCaptor.getValue().what);
-        WifiP2pGroup wifiP2pGroup = (WifiP2pGroup) mMessageCaptor.getValue().obj;
-        assertNotNull(wifiP2pGroup);
-
-        // client2 can get P2P group info
-        sendRequestGroupInfoMsg(mClient2Messenger);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        assertEquals(WifiP2pManager.RESPONSE_GROUP_INFO, mMessageCaptor.getValue().what);
-        wifiP2pGroup = (WifiP2pGroup) mMessageCaptor.getValue().obj;
-        assertNotNull(wifiP2pGroup);
-    }
-
-    /** Verify that only the group owner can get connection info */
-    @Test
-    public void testGroupOwnershipConfigGetConnectionInfo() throws Exception {
-        groupOwnershipConfigTestSetup();
-
-        // client2 cannot get P2P connection info
-        sendSimpleMsg(mClient2Messenger, WifiP2pManager.REQUEST_CONNECTION_INFO);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        WifiP2pInfo info = (WifiP2pInfo) message.obj;
-        assertEquals(WifiP2pManager.RESPONSE_CONNECTION_INFO, message.what);
-        assertEquals((new WifiP2pInfo()).toString(), info.toString());
-
-        // client1 can get P2P connection info
-        sendSimpleMsg(mClientMessenger, WifiP2pManager.REQUEST_CONNECTION_INFO);
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        message = mMessageCaptor.getValue();
-        info = (WifiP2pInfo) message.obj;
-        assertEquals(WifiP2pManager.RESPONSE_CONNECTION_INFO, mMessageCaptor.getValue().what);
-        assertTrue(info.groupFormed);
-    }
-
-    /** Verify that any client can get connection info */
-    @Test
-    public void testGroupOwnershipWpsGetConnectionInfo() throws Exception {
-        groupOwnershipWpsTestSetup();
-
-        // client1 can get P2P connection info
-        sendSimpleMsg(mClientMessenger, WifiP2pManager.REQUEST_CONNECTION_INFO);
-        verify(mClientHandler).sendMessage(mMessageCaptor.capture());
-        Message message = mMessageCaptor.getValue();
-        WifiP2pInfo info = (WifiP2pInfo) message.obj;
-        assertEquals(WifiP2pManager.RESPONSE_CONNECTION_INFO, mMessageCaptor.getValue().what);
-        assertTrue(info.groupFormed);
-
-        // client2 can get P2P connection info
-        sendSimpleMsg(mClient2Messenger, WifiP2pManager.REQUEST_CONNECTION_INFO);
-        verify(mClient2Handler).sendMessage(mMessageCaptor.capture());
-        message = mMessageCaptor.getValue();
-        info = (WifiP2pInfo) message.obj;
-        assertEquals(WifiP2pManager.RESPONSE_CONNECTION_INFO, mMessageCaptor.getValue().what);
-        assertTrue(info.groupFormed);
-    }
-
-    /** Verify that only the group owner receives the connection changed broadcast */
-    @Test
-    public void testGroupOwnershipConfigBroadcast() throws Exception {
-        groupOwnershipConfigTestSetup();
-
-        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(mContext, atLeastOnce()).sendBroadcast(intentCaptor.capture(), any(), any());
-
-        ArrayList<Intent> intentArrayList = new ArrayList<>();
-        for (int i = 0; i < intentCaptor.getAllValues().size(); i++) {
-            Intent intent = intentCaptor.getAllValues().get(i);
-            if (intent.getAction().equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)) {
-                intentArrayList.add(intent);
-            }
-        }
-        // Connection changed broadcast is sent 3 times:
-        // 1. Entering P2pEnabledState
-        // 2. Entering GroupCreatingState
-        // 3. Entering GroupCreatedState
-        // Each time, sendBroadcast is called twice (refer sendBroadcastWithExcludedPermissions)
-        // Verify group created broadcast only sent to client1
-        Intent intent = intentArrayList.get(4);
-        assertEquals(TEST_PACKAGE_NAME, intent.getPackage());
-        // Verify broadcast sent to NEARBY_WIFI_DEVICES apps do not have the package name set
-        intent = intentArrayList.get(5);
-        assertNull(intent.getPackage());
-    }
-
-    /** Verify that all clients receive the connection changed broadcast */
-    @Test
-    public void testGroupOwnershipWpsBroadcast() throws Exception {
-        groupOwnershipWpsTestSetup();
-
-        WifiP2pDevice connectedClientDevice = new WifiP2pDevice(mTestWifiP2pDevice);
-        connectedClientDevice.setInterfaceMacAddress(MacAddress.fromString(PEER_INTERFACE_ADDRESS));
-        sendApStaConnectedEvent(connectedClientDevice);
-        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(mContext, atLeastOnce()).sendBroadcast(intentCaptor.capture(), any(), any());
-
-        ArrayList<Intent> intentArrayList = new ArrayList<>();
-        for (int i = 0; i < intentCaptor.getAllValues().size(); i++) {
-            Intent intent = intentCaptor.getAllValues().get(i);
-            if (intent.getAction().equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)) {
-                intentArrayList.add(intent);
-            }
-        }
-        // Connection changed broadcast is sent 3 times:
-        // 1. Entering P2pEnabledState
-        // 2. Entering GroupCreatingState
-        // 3. Peer connection in GroupCreatedState
-        // Each time, sendBroadcast is called twice (refer sendBroadcastWithExcludedPermissions)
-        // Verify group created broadcast sent to all clients
-        Intent intent = intentArrayList.get(4);
-        assertNull(intent.getPackage());
-    }
-
-    /** Verify that only the group owner receives the group related callback */
-    @Test
-    public void testGroupOwnershipConfigP2pListener() throws Exception {
-        groupOwnershipConfigTestSetup();
-
-        verify(mP2pListener).onGroupCreated(any(), any());
-        verify(mP2pListener2, never()).onGroupCreated(any(), any());
-
-        WifiP2pDevice peerClientDevice = new WifiP2pDevice();
-        peerClientDevice.deviceName = "peerClientDeviceName";
-        peerClientDevice.deviceAddress = "11:22:33:aa:bb:cc";
-        peerClientDevice.setInterfaceMacAddress(MacAddress.fromString(PEER_INTERFACE_ADDRESS));
-        sendSimpleMsg(null, WifiP2pMonitor.AP_STA_CONNECTED_EVENT, peerClientDevice);
-        verify(mP2pListener).onPeerClientJoined(any(), any());
-        verify(mP2pListener2, never()).onPeerClientJoined(any(), any());
-
-        sendSimpleMsg(null, WifiP2pMonitor.AP_STA_DISCONNECTED_EVENT, peerClientDevice);
-        verify(mP2pListener).onPeerClientDisconnected(any(), any());
-        verify(mP2pListener2, never()).onPeerClientDisconnected(any(), any());
-
-        sendSimpleMsg(null, WifiP2pMonitor.P2P_FREQUENCY_CHANGED_EVENT, TEST_GROUP_FREQUENCY);
-        verify(mP2pListener).onFrequencyChanged(any(), any());
-        verify(mP2pListener2, never()).onFrequencyChanged(any(), any());
-    }
-
-    /** Verify that all clients receive the group related callback */
-    @Test
-    public void testGroupOwnershipWpsP2pListener() throws Exception {
-        groupOwnershipWpsTestSetup();
-
-        DhcpResultsParcelable dhcpResults = new DhcpResultsParcelable();
-        dhcpResults.serverAddress = P2P_GO_IP;
-        sendSimpleMsg(mClientMessenger, IPC_DHCP_RESULTS, dhcpResults);
-        verify(mP2pListener).onGroupCreated(any(), any());
-        verify(mP2pListener2).onGroupCreated(any(), any());
-
-        WifiP2pDevice connectedClientDevice = new WifiP2pDevice(mTestWifiP2pDevice);
-        connectedClientDevice.setInterfaceMacAddress(MacAddress.fromString(PEER_INTERFACE_ADDRESS));
-        sendApStaConnectedEvent(connectedClientDevice);
-        verify(mP2pListener).onPeerClientJoined(any(), any());
-        verify(mP2pListener2).onPeerClientJoined(any(), any());
-
-        // Need to connect a second peer device before testing disconnect to avoid removing group
-        WifiP2pDevice secondPeerDevice = new WifiP2pDevice(connectedClientDevice);
-        secondPeerDevice.deviceAddress = "11:22:33:aa:bb:cc";
-        sendApStaConnectedEvent(secondPeerDevice);
-        sendSimpleMsg(null, WifiP2pMonitor.AP_STA_DISCONNECTED_EVENT, connectedClientDevice);
-        verify(mP2pListener).onPeerClientDisconnected(any(), any());
-        verify(mP2pListener2).onPeerClientDisconnected(any(), any());
-
-        sendSimpleMsg(null, WifiP2pMonitor.P2P_FREQUENCY_CHANGED_EVENT, TEST_GROUP_FREQUENCY);
-        verify(mP2pListener).onFrequencyChanged(any(), any());
-        verify(mP2pListener2).onFrequencyChanged(any(), any());
-    }
-
     /** Verify the p2p randomized MAC feature is enabled if OEM supports it. */
     @Test
     public void testP2pRandomMacWithOemSupport() throws Exception {
@@ -3587,7 +3230,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         WifiP2pGroup groupCaptured = groupCaptor.getValue();
         assertEquals(mTestWifiP2pNewPersistentGoGroup.toString(), groupCaptured.toString());
 
-        sendGroupRemovedMsg(groupCaptured);
+        sendGroupRemovedMsg();
         verify(mWifiP2pMetrics).endGroupEvent();
     }
 
@@ -3631,7 +3274,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testStartReinvokeConnectionEventWhenSendConnect() throws Exception {
         setTargetSdkGreaterThanT();
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyInt()))
+        when(mWifiNative.p2pGroupAdd(anyInt(), anyBoolean()))
                 .thenReturn(true);
         when(mTestWifiP2pDevice.isGroupOwner()).thenReturn(true);
         when(mWifiNative.p2pGetSsid(eq(mTestWifiP2pDevice.deviceAddress)))
@@ -4024,7 +3667,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testEndConnectionEventWhenTimeout() throws Exception {
         setTargetSdkGreaterThanT();
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
 
         mockEnterGroupNegotiationState();
         if (SdkLevel.isAtLeastT()) {
@@ -4050,7 +3693,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     @Test
     public void testAcceptFrequencyConflictDialogSendsDisconnectWifiRequest() throws Exception {
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
         AsyncChannel wifiChannel = mAsyncChannel;
         sendChannelHalfConnectedEvent(mClientMessenger, wifiChannel);
         WifiDialogManager.DialogHandle dialogHandle = mock(WifiDialogManager.DialogHandle.class);
@@ -4119,7 +3762,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     @Test
     public void testDeclineFrequencyConflictDialogEndsP2pConnectionEvent() throws Exception {
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
         AsyncChannel wifiChannel = mock(AsyncChannel.class);
         sendChannelHalfConnectedEvent(mClientMessenger, wifiChannel);
         WifiDialogManager.DialogHandle dialogHandle = mock(WifiDialogManager.DialogHandle.class);
@@ -4158,7 +3801,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     @Test
     public void testFrequencyConflictDialogDismissedOnStateExit() throws Exception {
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
         AsyncChannel wifiChannel = mock(AsyncChannel.class);
         sendChannelHalfConnectedEvent(mClientMessenger, wifiChannel);
         WifiDialogManager.DialogHandle dialogHandle = mock(WifiDialogManager.DialogHandle.class);
@@ -4199,7 +3842,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testEndConnectionEventWhenCancel() throws Exception {
         setTargetSdkGreaterThanT();
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
 
         mockEnterGroupNegotiationState();
         if (SdkLevel.isAtLeastT()) {
@@ -4225,7 +3868,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testEndConnectionEventWhenProvDiscFailure() throws Exception {
         setTargetSdkGreaterThanT();
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
 
         mockEnterProvisionDiscoveryState();
         if (SdkLevel.isAtLeastT()) {
@@ -4254,7 +3897,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testEndConnectionEventWhenGroupRemoval() throws Exception {
         setTargetSdkGreaterThanT();
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
 
         mockEnterGroupNegotiationState();
         if (SdkLevel.isAtLeastT()) {
@@ -4319,7 +3962,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testEndConnectionEventWhenInvitationFailure() throws Exception {
         setTargetSdkGreaterThanT();
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
 
         mockEnterGroupNegotiationState();
         if (SdkLevel.isAtLeastT()) {
@@ -4345,7 +3988,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testEndConnectionEventWhenPeerRejectTheConnectRequestInNegotiationFlow()
             throws Exception {
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
         mockEnterGroupNegotiationState();
 
         WifiP2pProvDiscEvent pdEvent = new WifiP2pProvDiscEvent();
@@ -6743,7 +6386,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
 
         WifiP2pProvDiscEvent pdEvent = new WifiP2pProvDiscEvent();
         pdEvent.device = mTestWifiP2pDevice;
-        pdEvent.pin = "pin";
+        pdEvent.wpsPin = "pin";
         sendSimpleMsg(null,
                 WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT,
                 pdEvent);
@@ -6753,7 +6396,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
             verify(mAlertDialog).show();
         } else {
             verify(mWifiDialogManager).createP2pInvitationSentDialog(
-                    pdEvent.device.deviceName, pdEvent.pin, Display.DEFAULT_DISPLAY);
+                    pdEvent.device.deviceName, pdEvent.wpsPin, Display.DEFAULT_DISPLAY);
             verify(mDialogHandle).launchDialog();
         }
     }
@@ -6773,7 +6416,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         sendDeviceFoundEventMsg(mTestWifiP2pDevice);
         WifiP2pProvDiscEvent pdEvent = new WifiP2pProvDiscEvent();
         pdEvent.device = mTestWifiP2pDevice;
-        pdEvent.pin = "pin";
+        pdEvent.wpsPin = "pin";
         sendSimpleMsg(null,
                 WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT,
                 pdEvent);
@@ -6782,7 +6425,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
             verify(mAlertDialog).show();
         } else {
             verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
-                    eq(pdEvent.device.deviceName), eq(false), eq(pdEvent.pin),
+                    eq(pdEvent.device.deviceName), eq(false), eq(pdEvent.wpsPin),
                     anyInt(), anyInt(), any(), any());
             verify(mDialogHandle).launchDialog();
         }
@@ -6925,7 +6568,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
      */
     @Test
     public void testGroupCreatingFailureDueToTethering() throws Exception {
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
         when(mWifiNative.p2pGroupRemove(eq(IFACE_NAME_P2P))).thenReturn(true);
         when(mWifiPermissionsUtil.checkCanAccessWifiDirect(eq(TEST_PACKAGE_NAME), eq("testFeature"),
                 anyInt(), anyBoolean())).thenReturn(true);
@@ -7632,7 +7275,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
 
         WifiP2pProvDiscEvent pdEvent = new WifiP2pProvDiscEvent();
         pdEvent.device = mTestWifiP2pDevice;
-        pdEvent.pin = "pin";
+        pdEvent.wpsPin = "pin";
         sendSimpleMsg(null,
                 WifiP2pMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT,
                 pdEvent);
@@ -7913,7 +7556,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     @Test
     public void testProvDiscRejectEventForProvDisc() throws Exception {
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
 
         mockEnterProvisionDiscoveryState();
 
@@ -7936,7 +7579,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     @Test
     public void testSendP2pRejectWhenCancelRequest() throws Exception {
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
 
         mockEnterProvisionDiscoveryState();
 
@@ -7951,7 +7594,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
      */
     @Test
     public void testSendP2pRejectOnRejectRequest() throws Exception {
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
         forceP2pEnabled(mClient1);
 
         mockEnterUserAuthorizingNegotiationRequestState(WpsInfo.PBC);
@@ -7970,7 +7613,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
      */
     @Test
     public void testBroadcastDisconnectedStateOnRejectRequest() throws Exception {
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
         forceP2pEnabled(mClient1);
 
         mockEnterUserAuthorizingNegotiationRequestState(WpsInfo.PBC);
@@ -7984,7 +7627,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     @Test
     public void testDismissDialogOnReceiveProvDiscFailureEvent() throws Exception {
         assumeTrue(SdkLevel.isAtLeastT());
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
         forceP2pEnabled(mClient1);
 
         mockEnterUserAuthorizingNegotiationRequestState(WpsInfo.PBC);
@@ -8000,7 +7643,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     @Test
     public void testDismissDialogOnReceiveProvDiscFailureEventPreT() throws Exception {
         assumeFalse(SdkLevel.isAtLeastT());
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
         forceP2pEnabled(mClient1);
 
         mockEnterUserAuthorizingNegotiationRequestState(WpsInfo.PBC);
@@ -8069,7 +7712,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testPbcReconnectForUnknownGroupInvitation() throws Exception {
         forceP2pEnabled(mClient1);
         when(mWifiNative.getGroupCapability(any())).thenReturn(0);
-        when(mWifiNative.p2pReinvoke(anyInt(), any())).thenReturn(true);
+        when(mWifiNative.p2pReinvoke(anyInt(), any(), anyInt())).thenReturn(true);
         when(mWifiNative.p2pGetSsid(any())).thenReturn(null);
         when(mTestWifiP2pDevice.isGroupOwner()).thenReturn(false);
         when(mTestWifiP2pDevice.isInvitationCapable()).thenReturn(true);
@@ -8090,7 +7733,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testPinReconnectForUnknownGroupInvitation() throws Exception {
         forceP2pEnabled(mClient1);
         when(mWifiNative.getGroupCapability(any())).thenReturn(0);
-        when(mWifiNative.p2pReinvoke(anyInt(), any())).thenReturn(true);
+        when(mWifiNative.p2pReinvoke(anyInt(), any(), anyInt())).thenReturn(true);
         when(mWifiNative.p2pGetSsid(any())).thenReturn(null);
         when(mTestWifiP2pDevice.isGroupOwner()).thenReturn(false);
         when(mTestWifiP2pDevice.isInvitationCapable()).thenReturn(true);
@@ -8234,7 +7877,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         verify(mWifiP2pMetrics).startGroupEvent(group);
         verify(mWifiNative).p2pStopFind();
         verify(mWifiNative).p2pExtListen(eq(false), anyInt(), anyInt(), eq(null));
-        sendGroupRemovedMsg(group);
+        sendGroupRemovedMsg();
 
         //force to back disabled state
         mockEnterDisabledState();
@@ -8249,7 +7892,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         lenient().when(Process.myUid()).thenReturn(Process.SYSTEM_UID);
         when(mWifiNative.p2pFind(anyInt())).thenReturn(true);
         forceP2pEnabled(mClient1);
-        when(mWifiNative.p2pGroupAdd(anyBoolean())).thenReturn(true);
+        when(mWifiNative.p2pGroupAdd(anyBoolean(), anyBoolean())).thenReturn(true);
 
         mockEnterProvisionDiscoveryState();
 
@@ -8269,7 +7912,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     public void testFallbackToNegotiationOnInviteStatusCodeInfoUnavailable() throws Exception {
         forceP2pEnabled(mClient1);
         when(mWifiNative.getGroupCapability(any())).thenReturn(0);
-        when(mWifiNative.p2pReinvoke(anyInt(), any())).thenReturn(true);
+        when(mWifiNative.p2pReinvoke(anyInt(), any(), anyInt())).thenReturn(true);
         when(mWifiNative.p2pGetSsid(any())).thenReturn(null);
         when(mTestWifiP2pDevice.isGroupOwner()).thenReturn(false);
         when(mTestWifiP2pDevice.isInvitationCapable()).thenReturn(true);
@@ -8294,7 +7937,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         when(mWifiNative.p2pGetSsid(eq(mTestWifiP2pDevice.deviceAddress)))
                 .thenReturn(mTestWifiP2pGroup.getNetworkName() + "unknown");
         sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
-        verify(mWifiNative, never()).p2pGroupAdd(anyInt());
+        verify(mWifiNative, never()).p2pGroupAdd(anyInt(), anyBoolean());
         verify(mWifiNative).p2pConnect(any(), anyBoolean());
     }
 
@@ -8305,7 +7948,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         when(mWifiNative.p2pGetSsid(eq(mTestWifiP2pDevice.deviceAddress)))
                 .thenReturn(mTestWifiP2pGroup.getNetworkName());
         sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
-        verify(mWifiNative).p2pGroupAdd(anyInt());
+        verify(mWifiNative).p2pGroupAdd(anyInt(), anyBoolean());
     }
 
     @Test
@@ -8313,7 +7956,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
         forceP2pEnabled(mClient1);
         when(mWifiNative.p2pExtListen(anyBoolean(), anyInt(), anyInt(), any())).thenReturn(true);
         when(mWifiNative.getGroupCapability(any())).thenReturn(0);
-        when(mWifiNative.p2pReinvoke(anyInt(), any())).thenReturn(true);
+        when(mWifiNative.p2pReinvoke(anyInt(), any(), anyInt())).thenReturn(true);
         when(mWifiNative.p2pGetSsid(any())).thenReturn(null);
         when(mTestWifiP2pDevice.isGroupOwner()).thenReturn(false);
         when(mTestWifiP2pDevice.isInvitationCapable()).thenReturn(true);
@@ -8574,7 +8217,7 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
                 p2pGroupCaptor.capture());
         assertEquals(TEST_GROUP_FREQUENCY, p2pGroupCaptor.getValue().getFrequency());
 
-        sendGroupRemovedMsg(p2pGroup);
+        sendGroupRemovedMsg();
         mockEnterDisabledState();
         mLooper.dispatchAll();
         verify(mP2pListener).onGroupRemoved();
@@ -8666,19 +8309,962 @@ public class WifiP2pServiceImplTest extends WifiBaseTest {
     @Test
     public void testValidateDirInfo() throws Exception {
         assumeTrue(Environment.isSdkAtLeastB());
+
+        WifiP2pDirInfo dirInfo = new WifiP2pDirInfo(
+                MacAddress.fromString(TEST_DEVICE_MAC_ADDRESS_STRING), TEST_NONCE, TEST_DIR_TAG);
+        Message msg = Message.obtain();
+        msg.what = WifiP2pManager.VALIDATE_DIR_INFO;
+        msg.replyTo = mClientMessenger;
+        msg.obj = new AttributionSource(1000, TEST_PACKAGE_NAME, null);
+        Bundle extras = new Bundle();
+        extras.putParcelable(WifiP2pManager.EXTRA_PARAM_KEY_DIR_INFO, dirInfo);
+        msg.getData().putBundle(WifiP2pManager.EXTRA_PARAM_KEY_BUNDLE, extras);
+
+
         forceP2pEnabled(mClient1);
         when(mWifiPermissionsUtil.checkNearbyDevicesPermission(any(), anyBoolean(), any()))
                 .thenReturn(false);
-        sendSimpleMsg(mClientMessenger, WifiP2pManager.VALIDATE_DIR_INFO);
-        assertTrue(mClientHandler.hasMessages(WifiP2pManager.VALIDATE_DIR_INFO_FAILED));
+        mP2pStateMachineMessenger.send(Message.obtain(msg));
+        mLooper.dispatchAll();
+        assertTrue(mClientHandler.hasMessages(WifiP2pManager.VALIDATE_DIR_INFO_FAILED));
 
         when(mWifiPermissionsUtil.checkNearbyDevicesPermission(any(), anyBoolean(), any()))
                 .thenReturn(true);
-        sendSimpleMsg(mClientMessenger, WifiP2pManager.VALIDATE_DIR_INFO);
+        mP2pStateMachineMessenger.send(Message.obtain(msg));
+        mLooper.dispatchAll();
 
         verify(mClientHandler, times(2)).sendMessage(mMessageCaptor.capture());
         List<Message> messages = mMessageCaptor.getAllValues();
         assertEquals(WifiP2pManager.VALIDATE_DIR_INFO_FAILED, messages.get(0).what);
         assertEquals(WifiP2pManager.RESPONSE_VALIDATE_DIR_INFO, messages.get(1).what);
     }
+
+    private void createTestP2pV2PeerConfig(
+            @WifiP2pPairingBootstrappingConfig.PairingBootstrappingMethod
+            int method, @Nullable String pairingPinOrPassphrase, boolean authorize) {
+        WifiP2pPairingBootstrappingConfig pairingBootstrappingConfig =
+                new WifiP2pPairingBootstrappingConfig(
+                        method,
+                        pairingPinOrPassphrase);
+        mTestWifiP2pV2PeerConfig = new WifiP2pConfig.Builder()
+                .setDeviceAddress(MacAddress.fromString((mTestWifiP2pV2Device.deviceAddress)))
+                .setPairingBootstrappingConfig(pairingBootstrappingConfig)
+                .setAuthorizeConnectionFromPeerEnabled(authorize)
+                .build();
+    }
+
+    private WifiP2pProvDiscEvent createWifiP2pProvDiscEventForV2Connection(int event,
+            boolean comeback) {
+        WifiP2pProvDiscEvent provDiscEvent = new WifiP2pProvDiscEvent();
+        provDiscEvent.device = mTestWifiP2pV2Device;
+        provDiscEvent.event = event;
+        provDiscEvent.isComeback = comeback;
+        return provDiscEvent;
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: opportunistic on initiator device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithOpportunisticMethodOnInitiator()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+
+        forceP2pEnabled(mClient1);
+
+        createTestP2pV2PeerConfig(WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC, "", false);
+        mockEnterProvisionDiscoveryState(mTestWifiP2pV2PeerConfig);
+
+        // Send a provision discovery response event with comeback = true
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT,
+                pdEvent);
+        // Framework doesn't send connect to supplicant if comeback is set to true
+        verify(mWifiNative, never()).p2pConnect(any(), anyBoolean());
+
+        // Send a provision discovery response event with comeback = false
+        pdEvent = createWifiP2pProvDiscEventForV2Connection(WifiP2pProvDiscEvent
+                .PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP, false);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_RSP_EVENT,
+                pdEvent);
+        // Framework is expected to send connect to supplicant if comeback is set to false.
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig.PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2PeerConfig.deviceAddress);
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: display pincode on
+     * initiator device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithDisplayPinCodeMethodOnInitiator()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> pincodeCaptor =
+                ArgumentCaptor.forClass(String.class);
+
+        forceP2pEnabled(mClient1);
+
+        // create a config without passing the pairing pincode.
+        // Framework is expected to generate a random pincode on receiving the provision discovery
+        // response.
+        createTestP2pV2PeerConfig(WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE, "",
+                false);
+        mockEnterProvisionDiscoveryState(mTestWifiP2pV2PeerConfig);
+
+        // Send a provision discovery response event with comeback = true
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PIN, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+        // Framework doesn't send connect to supplicant if comeback is set to true
+        verify(mWifiNative, never()).p2pConnect(any(), anyBoolean());
+        verify(mWifiDialogManager).createP2pInvitationSentDialog(
+                eq(mTestWifiP2pV2Device.deviceName), pincodeCaptor.capture(),
+                eq(Display.DEFAULT_DISPLAY));
+        String pincode = pincodeCaptor.getValue();
+        assertTrue(pincode.matches("\\d{8}"));
+        verify(mDialogHandle).launchDialog();
+
+        // Send a provision discovery response event with comeback = false
+        pdEvent = createWifiP2pProvDiscEventForV2Connection(WifiP2pProvDiscEvent
+                .PAIRING_BOOTSTRAPPING_SHOW_PIN, false);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+        // Framework is expected to send connect to supplicant if comeback is set to false.
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2PeerConfig.deviceAddress);
+        assertEquals(pincode,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingPassword());
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: Display passphrase on initiator
+     * device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithDisplayPassphraseMethodOnInitiator()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> passphraseCaptor =
+                ArgumentCaptor.forClass(String.class);
+
+        forceP2pEnabled(mClient1);
+
+        // create a config without passing the pairing passphrase
+        // Framework is expected to generate a random passphrase on receiving the provision
+        // discovery response.
+        createTestP2pV2PeerConfig(WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE, "",
+                false);
+        mockEnterProvisionDiscoveryState(mTestWifiP2pV2PeerConfig);
+
+        // Send a provision discovery response event with comeback = true
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+        // Framework doesn't send connect to supplicant if comeback is set to true
+        verify(mWifiNative, never()).p2pConnect(any(), anyBoolean());
+        verify(mWifiDialogManager).createP2pInvitationSentDialog(
+                eq(mTestWifiP2pV2Device.deviceName), passphraseCaptor.capture(),
+                eq(Display.DEFAULT_DISPLAY));
+        String passphrase = passphraseCaptor.getValue();
+        assertTrue(passphrase.matches(".*[\\x00-\\x7F]{8}.*"));
+
+        verify(mDialogHandle).launchDialog();
+
+        // Send a provision discovery response event with comeback = false
+        pdEvent = createWifiP2pProvDiscEventForV2Connection(WifiP2pProvDiscEvent
+                .PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE, false);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+        // Framework is expected to send connect to supplicant if comeback is set to false.
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2PeerConfig.deviceAddress);
+        assertEquals(passphrase,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingPassword());
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: Keypad pincode on initiator
+     * device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithKeypadPincodeMethodOnInitiator()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> displayPinOrPassphraseCaptor =
+                ArgumentCaptor.forClass(String.class);
+
+        forceP2pEnabled(mClient1);
+
+        // create a config
+        createTestP2pV2PeerConfig(WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE, "",
+                false);
+        mockEnterProvisionDiscoveryState(mTestWifiP2pV2PeerConfig);
+
+        // Send a provision discovery response event with comeback = true
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+        // Framework doesn't send connect to supplicant until user enters the PIN
+        verify(mWifiNative, never()).p2pConnect(any(), anyBoolean());
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(true),
+                displayPinOrPassphraseCaptor.capture(), anyInt(), anyInt(), any(), any());
+        verify(mDialogHandle).launchDialog();
+        assertTrue(TextUtils.isEmpty(displayPinOrPassphraseCaptor.getValue()));
+
+        // Framework is expected to send connect if user accepts the connection request.
+        sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2PeerConfig.deviceAddress);
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: Keypad passphrase on initiator
+     * device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithKeypadPassphraseMethodOnInitiator()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> displayPinOrPassphraseCaptor =
+                ArgumentCaptor.forClass(String.class);
+
+        forceP2pEnabled(mClient1);
+
+        // create a config
+        createTestP2pV2PeerConfig(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE, "",
+                false);
+        mockEnterProvisionDiscoveryState(mTestWifiP2pV2PeerConfig);
+
+        // Send a provision discovery response event with comeback = true
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+        // Framework doesn't send connect to supplicant until user enters the PIN
+        verify(mWifiNative, never()).p2pConnect(any(), anyBoolean());
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(true),
+                displayPinOrPassphraseCaptor.capture(), anyInt(), anyInt(), any(), any());
+        verify(mDialogHandle).launchDialog();
+        assertTrue(TextUtils.isEmpty(displayPinOrPassphraseCaptor.getValue()));
+
+        // Framework is expected to send connect if user accepts the connection request.
+        sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2PeerConfig.deviceAddress);
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: opportunistic on responder device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithOpportunisticMethodOnResponder()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        forceP2pEnabled(mClient1);
+
+        //  Send a provision discovery request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(false), any(),
+                anyInt(), anyInt(), any(), any());
+        verify(mDialogHandle).launchDialog();
+        verify(mWifiNative, never()).p2pConnect(any(), anyBoolean());
+
+        // Framework is expected to send connect if user accepts the connection request.
+        sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2Device.deviceAddress);
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: keypad pincode on responder device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithKeypadPincodeMethodOnResponder()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> displayPinOrPassphraseCaptor =
+                ArgumentCaptor.forClass(String.class);
+        forceP2pEnabled(mClient1);
+
+        // Send a provision discovery request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(true),
+                displayPinOrPassphraseCaptor.capture(), anyInt(), anyInt(), any(), any());
+        verify(mDialogHandle).launchDialog();
+        assertTrue(TextUtils.isEmpty(displayPinOrPassphraseCaptor.getValue()));
+
+
+        // Framework is expected to send connect if user accepts the connection request.
+        sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2Device.deviceAddress);
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: keypad passphrase on responder
+     * device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithKeypadPassphraseMethodOnResponder()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> displayPinOrPassphraseCaptor =
+                ArgumentCaptor.forClass(String.class);
+        forceP2pEnabled(mClient1);
+
+        // Send a provision discovery request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(true),
+                displayPinOrPassphraseCaptor.capture(), anyInt(), anyInt(), any(), any());
+        verify(mDialogHandle).launchDialog();
+        assertTrue(TextUtils.isEmpty(displayPinOrPassphraseCaptor.getValue()));
+
+
+        // Framework is expected to send connect if user accepts the connection request.
+        sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2Device.deviceAddress);
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: display pincode on
+     * responder device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithDisplayPinCodeMethodOnResponder()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> pincodeCaptor =
+                ArgumentCaptor.forClass(String.class);
+        forceP2pEnabled(mClient1);
+
+        // Send a provision discovery request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PIN, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(false), pincodeCaptor.capture(),
+                anyInt(), anyInt(), any(), any());
+        String pincode = pincodeCaptor.getValue();
+        assertTrue(pincode.matches("\\d{8}"));
+        verify(mDialogHandle).launchDialog();
+
+
+        // Framework is expected to send connect as soon as the PIN is Displayed
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2Device.deviceAddress);
+        assertEquals(pincode,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingPassword());
+        assertTrue(config.isAuthorizeConnectionFromPeerEnabled());
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: display passphrase on
+     * responder device.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithDisplayPassphraseMethodOnResponder()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> passphraseCaptor =
+                ArgumentCaptor.forClass(String.class);
+        forceP2pEnabled(mClient1);
+
+        // Send a provision discovery request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(false), passphraseCaptor.capture(),
+                anyInt(), anyInt(), any(), any());
+        String passphrase = passphraseCaptor.getValue();
+        assertTrue(passphrase.matches(".*[\\x00-\\x7F]{8}.*"));
+        verify(mDialogHandle).launchDialog();
+
+
+        // Framework is expected to send connect as soon as the Passphrase is Displayed
+        verify(mWifiNative, times(1)).p2pConnect(configCaptor.capture(),
+                eq(false));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2Device.deviceAddress);
+        assertEquals(passphrase,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingPassword());
+        assertTrue(config.isAuthorizeConnectionFromPeerEnabled());
+        assertEquals(GROUP_CLIENT_IP_PROVISIONING_MODE_IPV6_LINK_LOCAL,
+                config.getGroupClientIpProvisioningMode());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: opportunistic on P2P group owner.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithOpportunisticMethodOnGroupOwner()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+
+        mockEnterGroupCreatedState();
+
+        // Send a provision discovery request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_PAIRING_BOOTSTRAPPING_OPPORTUNISTIC_REQ_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(false), any(),
+                anyInt(), anyInt(), any(), any());
+        verify(mDialogHandle).launchDialog();
+        verify(mWifiNative, never()).authorizeConnectRequestOnGroupOwner(any(), anyString());
+
+        // Framework is expected to send authorize if user accepts the connection request.
+        sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
+        verify(mWifiNative, times(1)).authorizeConnectRequestOnGroupOwner(
+                configCaptor.capture(),
+                eq(IFACE_NAME_P2P));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertTrue(config.isAuthorizeConnectionFromPeerEnabled());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: keypad pincode on group owner.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithKeypadPincodeMethodOnGroupOwner()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> displayPinOrPassphraseCaptor =
+                ArgumentCaptor.forClass(String.class);
+        mockEnterGroupCreatedState();
+
+        // Send a provision discovery request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PIN, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(true),
+                displayPinOrPassphraseCaptor.capture(), anyInt(), anyInt(), any(), any());
+        verify(mDialogHandle).launchDialog();
+        assertTrue(TextUtils.isEmpty(displayPinOrPassphraseCaptor.getValue()));
+
+
+        // Framework is expected to send authorize if user accepts the connection request.
+        sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
+        verify(mWifiNative, times(1)).authorizeConnectRequestOnGroupOwner(
+                configCaptor.capture(),
+                eq(IFACE_NAME_P2P));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PINCODE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertTrue(config.isAuthorizeConnectionFromPeerEnabled());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: keypad passphrase on group owner.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithKeypadPassphraseMethodOnGroupOwner()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> displayPinOrPassphraseCaptor =
+                ArgumentCaptor.forClass(String.class);
+        mockEnterGroupCreatedState();
+
+        // Send a provision discovery request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_ENTER_PASSPHRASE, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_ENTER_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(true),
+                displayPinOrPassphraseCaptor.capture(), anyInt(), anyInt(), any(), any());
+        verify(mDialogHandle).launchDialog();
+        assertTrue(TextUtils.isEmpty(displayPinOrPassphraseCaptor.getValue()));
+
+        // Framework is expected to send authorize if user accepts the connection request.
+        sendSimpleMsg(null, WifiP2pServiceImpl.PEER_CONNECTION_USER_ACCEPT);
+        verify(mWifiNative, times(1)).authorizeConnectRequestOnGroupOwner(
+                configCaptor.capture(),
+                eq(IFACE_NAME_P2P));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_KEYPAD_PASSPHRASE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertTrue(config.isAuthorizeConnectionFromPeerEnabled());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: display pincode on
+     * group owner.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithDisplayPinCodeMethodOnGroupOwner()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> pincodeCaptor =
+                ArgumentCaptor.forClass(String.class);
+        mockEnterGroupCreatedState();
+
+        // Send a provision discovery request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PIN, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(false), pincodeCaptor.capture(),
+                anyInt(), anyInt(), any(), any());
+        String pincode = pincodeCaptor.getValue();
+        assertTrue(pincode.matches("\\d{8}"));
+        verify(mDialogHandle).launchDialog();
+
+
+        // Framework is expected to send authorize as soon as the PIN is Displayed
+        verify(mWifiNative, times(1)).authorizeConnectRequestOnGroupOwner(
+                configCaptor.capture(),
+                eq(IFACE_NAME_P2P));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PINCODE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2Device.deviceAddress);
+        assertEquals(pincode,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingPassword());
+        assertTrue(config.isAuthorizeConnectionFromPeerEnabled());
+    }
+
+    /**
+     * Verify the pairing bootstrapping negotiation with method: display passphrase on
+     * group owner.
+     */
+    @Test
+    public void verifyPairingBootstrappingNegotiationWithDisplayPassphraseMethodOnGroupOwner()
+            throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        ArgumentCaptor<WifiP2pConfig> configCaptor =
+                ArgumentCaptor.forClass(WifiP2pConfig.class);
+        ArgumentCaptor<String> passphraseCaptor =
+                ArgumentCaptor.forClass(String.class);
+        mockEnterGroupCreatedState();
+
+        // Send a PD request event with comeback = true
+        sendDeviceFoundEventMsg(mTestWifiP2pV2Device);
+        WifiP2pProvDiscEvent pdEvent = createWifiP2pProvDiscEventForV2Connection(
+                WifiP2pProvDiscEvent.PAIRING_BOOTSTRAPPING_SHOW_PASSPHRASE, true);
+        sendSimpleMsg(null,
+                WifiP2pMonitor.P2P_PROV_DISC_SHOW_PAIRING_BOOTSTRAPPING_PIN_OR_PASSPHRASE_EVENT,
+                pdEvent);
+
+        verify(mWifiDialogManager).createP2pInvitationReceivedDialog(
+                eq(pdEvent.device.deviceName), eq(false), passphraseCaptor.capture(),
+                anyInt(), anyInt(), any(), any());
+        String passphrase = passphraseCaptor.getValue();
+        assertTrue(passphrase.matches(".*[\\x00-\\x7F]{8}.*"));
+        verify(mDialogHandle).launchDialog();
+
+
+        // Framework is expected to send authorize as soon as the PIN is Displayed
+        verify(mWifiNative, times(1)).authorizeConnectRequestOnGroupOwner(
+                configCaptor.capture(),
+                eq(IFACE_NAME_P2P));
+        WifiP2pConfig config = configCaptor.getValue();
+        assertEquals(WifiP2pPairingBootstrappingConfig
+                        .PAIRING_BOOTSTRAPPING_METHOD_DISPLAY_PASSPHRASE,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingMethod());
+        assertEquals(config.deviceAddress, mTestWifiP2pV2Device.deviceAddress);
+        assertEquals(passphrase,
+                config.getPairingBootstrappingConfig().getPairingBootstrappingPassword());
+        assertTrue(config.isAuthorizeConnectionFromPeerEnabled());
+    }
+
+    /**
+     * Mock send WifiP2pManager.ADD_SERVICE_REQUEST with USD based service configuration.
+     *
+     * @param replyMessenger for checking replied message.
+     */
+    private void sendAddUsdServiceRequestMsg(Messenger replyMessenger) throws Exception {
+        Message msg = Message.obtain();
+        msg.what = WifiP2pManager.ADD_SERVICE_REQUEST;
+        msg.replyTo = replyMessenger;
+        msg.obj = mTestUsdServiceRequest;
+        mP2pStateMachineMessenger.send(Message.obtain(msg));
+        mLooper.dispatchAll();
+    }
+
+    /**
+     * Mock send WifiP2pManager.DISCOVER_SERVICES to discover USD based services.
+     *
+     * @param replyMessenger for checking replied message.
+     */
+    private void sendDiscoverUsdServiceMsg(Messenger replyMessenger) throws Exception {
+        Message msg = Message.obtain();
+        Bundle extras = new Bundle();
+        extras.putParcelable(EXTRA_PARAM_KEY_USD_BASED_SERVICE_DISCOVERY_CONFIG,
+                mTestUsdServiceDiscoveryConfig);
+        msg.what = WifiP2pManager.DISCOVER_SERVICES;
+        msg.arg1 = WIFI_P2P_USD_BASED_SERVICE_DISCOVERY;
+        msg.obj = new AttributionSource(1000, TEST_PACKAGE_NAME, null);
+        msg.getData().putBundle(WifiP2pManager.EXTRA_PARAM_KEY_BUNDLE, extras);
+        msg.replyTo = replyMessenger;
+        mP2pStateMachineMessenger.send(Message.obtain(msg));
+        mLooper.dispatchAll();
+    }
+
+    /**
+     * Mock send WifiP2pManager.ADD_LOCAL_SERVICE with USD service configuration.
+     *
+     * @param replyMessenger for checking replied message.
+     */
+    private void sendStartUsdBasedLocalServiceAdvertisementMsg(Messenger replyMessenger)
+            throws Exception {
+        Message msg = Message.obtain();
+        Bundle extras = new Bundle();
+        extras.putParcelable(WifiP2pManager.EXTRA_PARAM_KEY_SERVICE_INFO, mTestUsdServiceInfo);
+        extras.putParcelable(EXTRA_PARAM_KEY_USD_BASED_LOCAL_SERVICE_ADVERTISEMENT_CONFIG,
+                mTestUsdServiceAdvertisementConfig);
+        msg.what = WifiP2pManager.ADD_LOCAL_SERVICE;
+        msg.arg1 = WIFI_P2P_USD_BASED_ADD_LOCAL_SERVICE;
+        msg.obj = new AttributionSource(1000, TEST_PACKAGE_NAME, null);
+        msg.getData().putBundle(WifiP2pManager.EXTRA_PARAM_KEY_BUNDLE, extras);
+        msg.replyTo = replyMessenger;
+        mP2pStateMachineMessenger.send(Message.obtain(msg));
+        mLooper.dispatchAll();
+    }
+
+    private void verifyUsdBasedServiceDiscoveryRequest() throws Exception {
+        when(mWifiNative.startUsdBasedServiceDiscovery(any(), any(), anyInt()))
+                .thenReturn(TEST_USD_SESSION_ID);
+        ArgumentCaptor<WifiP2pUsdBasedServiceConfig> usdConfigCaptor = ArgumentCaptor.forClass(
+                WifiP2pUsdBasedServiceConfig.class);
+        ArgumentCaptor<WifiP2pUsdBasedServiceDiscoveryConfig> discoveryConfigCaptor =
+                ArgumentCaptor.forClass(WifiP2pUsdBasedServiceDiscoveryConfig.class);
+        sendAddUsdServiceRequestMsg(mClientMessenger);
+        sendDiscoverUsdServiceMsg(mClientMessenger);
+        assertTrue(mClientHandler.hasMessages(WifiP2pManager.DISCOVER_SERVICES_SUCCEEDED));
+        verify(mWifiNative).startUsdBasedServiceDiscovery(usdConfigCaptor.capture(),
+                discoveryConfigCaptor.capture(), eq(WifiP2pServiceImpl
+                        .USD_BASED_SERVICE_ADVERTISEMENT_DISCOVERY_TIMEOUT_S));
+        assertEquals(mTestUsdServiceRequest.getWifiP2pUsdBasedServiceConfig(),
+                usdConfigCaptor.getValue());
+        assertEquals(mTestUsdServiceDiscoveryConfig, discoveryConfigCaptor.getValue());
+    }
+
+
+    /**
+     * Verify the message WifiP2pManager.DISCOVER_SERVICES to discover USD based services.
+     */
+    @Test
+    public void testUsdBasedServiceDiscoveryRequestMessage() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        forceP2pEnabled(mClient1);
+
+        verifyUsdBasedServiceDiscoveryRequest();
+    }
+
+    /**
+     * Verify the message WifiP2pManager.REMOVE_SERVICE_REQUEST to stop USD based service discovery
+     */
+    @Test
+    public void testRemoveUsdBasedServiceDiscoveryRequest() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        forceP2pEnabled(mClient1);
+
+        verifyUsdBasedServiceDiscoveryRequest();
+
+        sendRemoveServiceRequestMsg(mClientMessenger, mTestUsdServiceRequest);
+        verify(mWifiNative).stopUsdBasedServiceDiscovery(anyInt());
+        assertTrue(mClientHandler.hasMessages(WifiP2pManager.REMOVE_SERVICE_REQUEST_SUCCEEDED));
+    }
+
+    /**
+     * Verify the message WifiP2pManager.CLEAR_SERVICE_REQUESTS to stop USD based service discovery
+     */
+    @Test
+    public void testClearUsdBasedServiceDiscoveryRequests() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        forceP2pEnabled(mClient1);
+
+        verifyUsdBasedServiceDiscoveryRequest();
+
+        sendSimpleMsg(mClientMessenger, WifiP2pManager.CLEAR_SERVICE_REQUESTS);
+        verify(mWifiNative).stopUsdBasedServiceDiscovery(anyInt());
+        assertTrue(mClientHandler.hasMessages(WifiP2pManager.CLEAR_SERVICE_REQUESTS_SUCCEEDED));
+    }
+
+    private void verifyUsdBasedServiceAdvertisementRequest() throws Exception {
+        when(mWifiNative.startUsdBasedServiceAdvertisement(any(), any(), anyInt()))
+                .thenReturn(TEST_USD_SESSION_ID);
+        ArgumentCaptor<WifiP2pUsdBasedServiceConfig> usdConfigCaptor = ArgumentCaptor.forClass(
+                WifiP2pUsdBasedServiceConfig.class);
+        ArgumentCaptor<WifiP2pUsdBasedLocalServiceAdvertisementConfig>
+                serviceAdvertisementConfigCaptor = ArgumentCaptor.forClass(
+                WifiP2pUsdBasedLocalServiceAdvertisementConfig.class);
+        sendStartUsdBasedLocalServiceAdvertisementMsg(mClientMessenger);
+        assertTrue(mClientHandler.hasMessages(WifiP2pManager.ADD_LOCAL_SERVICE_SUCCEEDED));
+
+        verify(mWifiNative).startUsdBasedServiceAdvertisement(usdConfigCaptor.capture(),
+                serviceAdvertisementConfigCaptor.capture(), eq(WifiP2pServiceImpl
+                        .USD_BASED_SERVICE_ADVERTISEMENT_DISCOVERY_TIMEOUT_S));
+        assertEquals(mTestUsdServiceInfo.getWifiP2pUsdBasedServiceConfig(),
+                usdConfigCaptor.getValue());
+        assertEquals(mTestUsdServiceAdvertisementConfig,
+                serviceAdvertisementConfigCaptor.getValue());
+    }
+
+    /**
+     * Verify the message WifiP2pManager.ADD_LOCAL_SERVICE to advertise USD based services.
+     */
+    @Test
+    public void testUsdBasedServiceAdvertisementRequestMessage() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        forceP2pEnabled(mClient1);
+
+        verifyUsdBasedServiceAdvertisementRequest();
+    }
+
+    /**
+     * Verify the message WifiP2pManager.REMOVE_LOCAL_SERVICE to stop advertising
+     * USD based services.
+     */
+    @Test
+    public void testRemoveUsdBasedServiceAdvertisement() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        forceP2pEnabled(mClient1);
+
+        verifyUsdBasedServiceAdvertisementRequest();
+
+        sendRemoveLocalServiceMsg(mClientMessenger, mTestUsdServiceInfo);
+        verify(mWifiNative).stopUsdBasedServiceAdvertisement(anyInt());
+        assertTrue(mClientHandler.hasMessages(WifiP2pManager.REMOVE_LOCAL_SERVICE_SUCCEEDED));
+    }
+
+    /**
+     * Verify the message WifiP2pManager.CLEAR_LOCAL_SERVICES to stop advertising
+     * USD based services.
+     */
+    @Test
+    public void testClearUsdBasedServiceAdvertisements() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        forceP2pEnabled(mClient1);
+
+        verifyUsdBasedServiceAdvertisementRequest();
+
+        sendSimpleMsg(mClientMessenger, WifiP2pManager.CLEAR_LOCAL_SERVICES);
+        verify(mWifiNative).stopUsdBasedServiceAdvertisement(anyInt());
+        assertTrue(mClientHandler.hasMessages(WifiP2pManager.CLEAR_LOCAL_SERVICES_SUCCEEDED));
+    }
+
+    /**
+     * Verify the handling of WifiP2pManager.CONNECT triggering re-invoke of P2P connection for
+     * V2 connection when the device identity key is available.
+     */
+    @Test
+    public void testReinvokeForV2Connection() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        forceP2pEnabled(mClient1);
+
+        mTestWifiP2pV2Device.dirInfo = new WifiP2pDirInfo(
+                MacAddress.fromString(TEST_DEVICE_MAC_ADDRESS_STRING), TEST_NONCE, TEST_DIR_TAG);
+        when(mWifiNative.validateDirInfo(any())).thenReturn(TEST_DIK_ID);
+        when(mWifiNative.p2pReinvoke(anyInt(), any(), anyInt())).thenReturn(true);
+        when(mTestWifiP2pV2Device.isGroupOwner()).thenReturn(false);
+        when(mTestWifiP2pV2Device.isInvitationCapable()).thenReturn(true);
+
+        mockPeersList();
+
+        createTestP2pV2PeerConfig(WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC, "", false);
+        sendConnectMsg(mClientMessenger, mTestWifiP2pV2PeerConfig);
+
+        verify(mWifiNative, never()).p2pProvisionDiscovery(any());
+        verify(mWifiNative).p2pReinvoke(eq(-1), eq(TEST_DEVICE_MAC_ADDRESS_STRING),
+                eq(TEST_DIK_ID));
+    }
+
+    /**
+     * Verify the handling of WifiP2pManager.CONNECT triggering provision discovery
+     * when the device identity key is not available.
+     */
+    @Test
+    public void testTriggerProvisionDiscoveryWhenDikInfoIsNotAvailable() throws Exception {
+        assumeTrue(Environment.isSdkAtLeastB());
+        forceP2pEnabled(mClient1);
+
+        mTestWifiP2pV2Device.dirInfo = new WifiP2pDirInfo(
+                MacAddress.fromString(TEST_DEVICE_MAC_ADDRESS_STRING), TEST_NONCE, TEST_DIR_TAG);
+        when(mWifiNative.validateDirInfo(any())).thenReturn(-1);
+        when(mWifiNative.p2pReinvoke(anyInt(), any(), anyInt())).thenReturn(true);
+        when(mTestWifiP2pV2Device.isGroupOwner()).thenReturn(false);
+        when(mTestWifiP2pV2Device.isInvitationCapable()).thenReturn(true);
+
+        mockPeersList();
+
+        createTestP2pV2PeerConfig(WifiP2pPairingBootstrappingConfig
+                .PAIRING_BOOTSTRAPPING_METHOD_OPPORTUNISTIC, "", false);
+        sendConnectMsg(mClientMessenger, mTestWifiP2pV2PeerConfig);
+
+        verify(mWifiNative).p2pProvisionDiscovery(any());
+        verify(mWifiNative, never()).p2pReinvoke(anyInt(), any(), anyInt());
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/rtt/RttServiceImplTest.java b/service/tests/wifitests/src/com/android/server/wifi/rtt/RttServiceImplTest.java
index cc570c77c7..e63c67512f 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/rtt/RttServiceImplTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/rtt/RttServiceImplTest.java
@@ -23,10 +23,12 @@ import static android.net.wifi.rtt.WifiRttManager.CHARACTERISTICS_KEY_BOOLEAN_ON
 
 import static com.android.server.wifi.WifiSettingsConfigStore.WIFI_VERBOSE_LOGGING_ENABLED;
 import static com.android.server.wifi.rtt.RttTestUtils.compareListContentsNoOrdering;
+import static com.android.server.wifi.rtt.RttTestUtils.getDummyRangingResults;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.any;
@@ -55,7 +57,9 @@ import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.location.LocationManager;
 import android.net.MacAddress;
+import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiManager;
+import android.net.wifi.WifiSsid;
 import android.net.wifi.aware.IWifiAwareMacAddressProvider;
 import android.net.wifi.aware.MacAddrMapping;
 import android.net.wifi.aware.PeerHandle;
@@ -84,7 +88,9 @@ import com.android.modules.utils.build.SdkLevel;
 import com.android.server.wifi.Clock;
 import com.android.server.wifi.HalDeviceManager;
 import com.android.server.wifi.MockResources;
+import com.android.server.wifi.SsidTranslator;
 import com.android.server.wifi.WifiBaseTest;
+import com.android.server.wifi.WifiConfigManager;
 import com.android.server.wifi.WifiSettingsConfigStore;
 import com.android.server.wifi.hal.WifiRttController;
 import com.android.server.wifi.proto.nano.WifiMetricsProto;
@@ -178,6 +184,11 @@ public class RttServiceImplTest extends WifiBaseTest {
 
     @Mock
     WifiSettingsConfigStore mWifiSettingsConfigStore;
+    @Mock
+    WifiConfigManager mWifiConfigManager;
+    WifiConfiguration mWifiConfiguration = new WifiConfiguration();
+    @Mock
+    SsidTranslator mSsidTranslator;
 
     /**
      * Using instead of spy to avoid native crash failures - possibly due to
@@ -248,7 +259,8 @@ public class RttServiceImplTest extends WifiBaseTest {
         doAnswer(mBinderUnlinkToDeathCounter).when(mockIbinder).unlinkToDeath(any(), anyInt());
 
         mDut.start(mMockLooper.getLooper(), mockClock, mockAwareManager, mockMetrics,
-                mockPermissionUtil, mWifiSettingsConfigStore, mockHalDeviceManager);
+                mockPermissionUtil, mWifiSettingsConfigStore, mockHalDeviceManager,
+                mWifiConfigManager, mSsidTranslator);
         mMockLooper.dispatchAll();
         ArgumentCaptor<BroadcastReceiver> bcastRxCaptor = ArgumentCaptor.forClass(
                 BroadcastReceiver.class);
@@ -370,6 +382,59 @@ public class RttServiceImplTest extends WifiBaseTest {
                 mAlarmManager.getAlarmManager());
     }
 
+    /**
+     * Validate a successful secure ranging flow.
+     */
+    @Test
+    public void testSecureRanging() throws RemoteException {
+        RangingRequest request = RttTestUtils.getDummySecureRangingRequest(
+                RangingRequest.SECURITY_MODE_OPPORTUNISTIC);
+        mWifiConfiguration.preSharedKey = "TEST_PASSWORD";
+        WifiSsid ssid = request.mRttPeers.get(
+                1).getSecureRangingConfig().getPasnConfig().getWifiSsid();
+        when(mWifiConfigManager.getConfiguredNetworkWithPassword(eq(ssid),
+                eq(WifiConfiguration.SECURITY_TYPE_SAE))).thenReturn(mWifiConfiguration);
+        when(mSsidTranslator.getTranslatedSsid(eq(ssid))).thenReturn(ssid);
+
+        // Make sure the second peer is configured with no password for SAE.
+        assertNull(request.mRttPeers.get(1).getSecureRangingConfig().getPasnConfig().getPassword());
+
+        ClockAnswer clock = new ClockAnswer();
+        doAnswer(clock).when(mockClock).getWallClockMillis();
+        clock.time = 100;
+        mDut.startRanging(mockIbinder, mPackageName, mFeatureId, null, request, mockCallback,
+                mExtras);
+        mMockLooper.dispatchAll();
+        verify(mockRttControllerHal).rangeRequest(mIntCaptor.capture(), mRequestCaptor.capture());
+        verifyWakeupSet(false, 0);
+        RangingRequest halRequest = mRequestCaptor.getValue();
+        assertNotEquals("Request to WifiRttController is not null", null, halRequest);
+        assertEquals("Size of request", request.mRttPeers.size(), halRequest.mRttPeers.size());
+
+        for (int i = 0; i < request.mRttPeers.size(); ++i) {
+            assertEquals("SecureRangingConfig is not same",
+                    request.mRttPeers.get(i).getSecureRangingConfig(),
+                    halRequest.mRttPeers.get(i).getSecureRangingConfig());
+        }
+
+        // Make sure password is set for second peer from WifiConfiguration for the SAE.
+        assertEquals("Password is not set", "TEST_PASSWORD", halRequest.mRttPeers.get(
+                1).getSecureRangingConfig().getPasnConfig().getPassword());
+
+        // Verify ranging results are processed correctly
+        Pair<List<RangingResult>, List<RangingResult>> resultsPair = getDummyRangingResults(
+                halRequest);
+        mRangingResultsCbCaptor.getValue().onRangingResults(mIntCaptor.getValue(),
+                resultsPair.first);
+        mMockLooper.dispatchAll();
+        verify(mockCallback).onRangingResults(mListCaptor.capture());
+        assertTrue(compareListContentsNoOrdering(resultsPair.second, mListCaptor.getValue()));
+
+        verifyWakeupCancelled();
+        verifyNoMoreInteractions(mockRttControllerHal, mockCallback,
+                mAlarmManager.getAlarmManager());
+    }
+
     /**
      * Validate a successful ranging flow with PeerHandles (i.e. verify translations)
      */
diff --git a/service/tests/wifitests/src/com/android/server/wifi/rtt/RttTestUtils.java b/service/tests/wifitests/src/com/android/server/wifi/rtt/RttTestUtils.java
index 1e7df0db7a..d19f79b851 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/rtt/RttTestUtils.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/rtt/RttTestUtils.java
@@ -18,9 +18,12 @@ package com.android.server.wifi.rtt;
 
 import android.net.MacAddress;
 import android.net.wifi.ScanResult;
+import android.net.wifi.WifiSsid;
+import android.net.wifi.rtt.PasnConfig;
 import android.net.wifi.rtt.RangingRequest;
 import android.net.wifi.rtt.RangingResult;
 import android.net.wifi.rtt.ResponderConfig;
+import android.net.wifi.rtt.SecureRangingConfig;
 import android.util.Pair;
 
 import java.util.ArrayList;
@@ -76,6 +79,90 @@ public class RttTestUtils {
         return builder.build();
     }
 
+    /**
+     * Get placeholder request for secure ranging.
+     *
+     * @param securityMode Security mode to use.
+     * @return Returns a ranging request with peers supporting SAE with password, SAE with no
+     * password, Unauthenticated PASN and Open security.
+     */
+    public static RangingRequest getDummySecureRangingRequest(
+            @RangingRequest.SecurityMode int securityMode) {
+        RangingRequest.Builder builder = new RangingRequest.Builder().setSecurityMode(securityMode);
+        // SAE
+        PasnConfig pasnConfig = new PasnConfig
+                .Builder(PasnConfig.AKM_SAE, PasnConfig.CIPHER_GCMP_256)
+                .setWifiSsid(WifiSsid.fromString("\"TEST_SSID\""))
+                .setPassword("TEST_PASSWORD")
+                .setPasnComebackCookie(new byte[]{1, 2, 3, 4, 5})
+                .build();
+        SecureRangingConfig secureRangingConfig = new SecureRangingConfig
+                .Builder(pasnConfig)
+                .setRangingFrameProtectionEnabled(true)
+                .setSecureHeLtfEnabled(true)
+                .build();
+        ResponderConfig config = new ResponderConfig.Builder()
+                .setMacAddress(MacAddress.fromString("00:11:22:33:44:55"))
+                .setResponderType(ResponderConfig.RESPONDER_AP)
+                .setChannelWidth(ScanResult.CHANNEL_WIDTH_80MHZ)
+                .setPreamble(ScanResult.PREAMBLE_HE)
+                .set80211azNtbSupported(true)
+                .setSecureRangingConfig(secureRangingConfig)
+                .build();
+        builder.addResponder(config);
+
+        // SAE with no password configured
+        pasnConfig = new PasnConfig
+                .Builder(PasnConfig.AKM_SAE, PasnConfig.CIPHER_GCMP_256)
+                .setWifiSsid(WifiSsid.fromString("\"TEST_SSID\""))
+                .build();
+        secureRangingConfig = new SecureRangingConfig
+                .Builder(pasnConfig)
+                .setRangingFrameProtectionEnabled(true)
+                .setSecureHeLtfEnabled(true)
+                .build();
+        config = new ResponderConfig.Builder()
+                .setMacAddress(MacAddress.fromString("00:11:22:33:44:56"))
+                .setResponderType(ResponderConfig.RESPONDER_AP)
+                .setChannelWidth(ScanResult.CHANNEL_WIDTH_80MHZ)
+                .setPreamble(ScanResult.PREAMBLE_HE)
+                .set80211azNtbSupported(true)
+                .setSecureRangingConfig(secureRangingConfig).build();
+        builder.addResponder(config);
+
+        // Unauthenticated PASN
+        pasnConfig = new PasnConfig
+                .Builder(PasnConfig.AKM_PASN, PasnConfig.CIPHER_GCMP_256).build();
+        secureRangingConfig = new SecureRangingConfig
+                .Builder(pasnConfig)
+                .setRangingFrameProtectionEnabled(true)
+                .setSecureHeLtfEnabled(true)
+                .build();
+        config = new ResponderConfig
+                .Builder()
+                .setMacAddress(MacAddress.fromString("00:11:22:33:44:57"))
+                .setResponderType(ResponderConfig.RESPONDER_AP)
+                .setChannelWidth(ScanResult.CHANNEL_WIDTH_80MHZ)
+                .setPreamble(ScanResult.PREAMBLE_HE)
+                .set80211azNtbSupported(true)
+                .setSecureRangingConfig(secureRangingConfig)
+                .build();
+        builder.addResponder(config);
+
+        // Open mode
+        config = new ResponderConfig
+                .Builder()
+                .setMacAddress(MacAddress.fromString("00:11:22:33:44:58"))
+                .setResponderType(ResponderConfig.RESPONDER_AP)
+                .setChannelWidth(ScanResult.CHANNEL_WIDTH_80MHZ)
+                .setPreamble(ScanResult.PREAMBLE_HE)
+                .set80211azNtbSupported(true)
+                .build();
+        builder.addResponder(config);
+
+        return builder.build();
+    }
+
     /**
      * Returns a placeholder ranging request with 4 requests and a non-default in-range burst size:
      * - First: 802.11mc capable
@@ -85,26 +172,50 @@ public class RttTestUtils {
      */
     public static RangingRequest getDummyRangingRequestWith11az(byte lastMacByte) {
         RangingRequest.Builder builder = new RangingRequest.Builder();
+        ScanResult.InformationElement vhtCap = new ScanResult.InformationElement();
+        vhtCap.id = ScanResult.InformationElement.EID_VHT_CAPABILITIES;
 
-        ScanResult scan1 = new ScanResult();
-        scan1.BSSID = "00:01:02:03:04:" + String.format("%02d", lastMacByte);
-        scan1.setFlag(ScanResult.FLAG_80211mc_RESPONDER);
-        scan1.channelWidth = ScanResult.CHANNEL_WIDTH_40MHZ;
+        ScanResult.InformationElement heCap = new ScanResult.InformationElement();
+        heCap.id = ScanResult.InformationElement.EID_EXTENSION_PRESENT;
+        heCap.idExt = ScanResult.InformationElement.EID_EXT_HE_CAPABILITIES;
+
+        ScanResult.InformationElement ehtCap = new ScanResult.InformationElement();
+        ehtCap.id = ScanResult.InformationElement.EID_EXTENSION_PRESENT;
+        ehtCap.idExt = ScanResult.InformationElement.EID_EXT_EHT_CAPABILITIES;
+
+        ScanResult.InformationElement[] ie = new ScanResult.InformationElement[3];
+        ie[0] = vhtCap;
+        ie[1] = heCap;
+        ie[2] = ehtCap;
+
+        // peer 0: 11mc only
+        ScanResult scan1 = new ScanResult.Builder()
+                .setBssid("00:01:02:03:04:" + String.format("%02d", lastMacByte))
+                .setIs80211McRTTResponder(true)
+                .setChannelWidth(ScanResult.CHANNEL_WIDTH_40MHZ)
+                .setFrequency(5200)
+                .build();
+        scan1.informationElements = ie;
+        builder.addAccessPoint(scan1);
+        // peer 1: one-sided only
         ScanResult scan2 = new ScanResult();
         scan2.BSSID = "0A:0B:0C:0D:0E:" + String.format("%02d", lastMacByte);
         scan2.channelWidth = ScanResult.CHANNEL_WIDTH_20MHZ;
         MacAddress mac1 = MacAddress.fromString("08:09:08:07:06:05");
-
-        builder.addAccessPoint(scan1);
         builder.addNon80211mcCapableAccessPoint(scan2);
-        // Changing default RTT burst size to a valid, but maximum, value
+        // peer 2: Aware
         builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
         builder.addWifiAwarePeer(mac1);
-        // Add 11az & 11mc supported AP
-        scan1.BSSID = "00:11:22:33:44:" + String.format("%02d", lastMacByte);
-        scan1.setFlag(ScanResult.FLAG_80211mc_RESPONDER);
-        scan1.setFlag(ScanResult.FLAG_80211az_NTB_RESPONDER);
-        scan1.channelWidth = ScanResult.CHANNEL_WIDTH_40MHZ;
+        // peer 3: 11az & 11mc supported AP. Since the device supports 11mc only, the expectation is
+        // preamble will be adjusted as VHT since ranging request is in 5 Ghz.
+        scan1 = new ScanResult.Builder()
+                .setBssid("00:11:22:33:44:" + String.format("%02d", lastMacByte))
+                .setIs80211McRTTResponder(true)
+                .setIs80211azNtbRTTResponder(true)
+                .setChannelWidth(ScanResult.CHANNEL_WIDTH_40MHZ)
+                .setFrequency(5200)
+                .build();
+        scan1.informationElements = ie;
         builder.addAccessPoint(scan1);
         return builder.build();
     }
@@ -159,19 +270,6 @@ public class RttTestUtils {
 
         if (request != null) {
             for (ResponderConfig peer : request.mRttPeers) {
-                halResults.add(new RangingResult.Builder()
-                        .setStatus(RangingResult.STATUS_SUCCESS)
-                        .setMacAddress(peer.getMacAddress())
-                        .setDistanceMm(rangeCmBase)
-                        .setDistanceStdDevMm(rangeStdDevCmBase)
-                        .setRssi(rssiBase)
-                        .setNumAttemptedMeasurements(8)
-                        .setNumSuccessfulMeasurements(5)
-                        .setRangingTimestampMillis(rangeTimestampBase)
-                        .set80211mcMeasurement(true)
-                        .setMeasurementChannelFrequencyMHz(5180)
-                        .setMeasurementBandwidth(ScanResult.CHANNEL_WIDTH_40MHZ)
-                        .build());
                 RangingResult.Builder builder = new RangingResult.Builder()
                         .setStatus(RangingResult.STATUS_SUCCESS)
                         .setDistanceMm(rangeCmBase++)
@@ -183,13 +281,24 @@ public class RttTestUtils {
                         .set80211mcMeasurement(true)
                         .setMeasurementChannelFrequencyMHz(5180)
                         .setMeasurementBandwidth(ScanResult.CHANNEL_WIDTH_40MHZ);
+                if (peer.getSecureRangingConfig() != null) {
+                    builder.setRangingAuthenticated(true);
+                    builder.setRangingFrameProtected(true);
+                    builder.setSecureHeLtfEnabled(true);
+                    builder.setSecureHeLtfProtocolVersion(1);
+                }
+                halResults.add(builder.setMacAddress(peer.getMacAddress()).build());
                 if (peer.peerHandle == null) {
                     builder.setMacAddress(peer.getMacAddress());
                 } else {
+                    // Make sure MAC address null when peer handle is set.
+                    builder.setMacAddress(null);
                     builder.setPeerHandle(peer.peerHandle);
                 }
-                RangingResult rangingResult = builder.build();
-                results.add(rangingResult);
+                results.add(builder.build());
+                rangeCmBase++;
+                rangeStdDevCmBase++;
+                rssiBase++;
             }
         } else {
             results.add(new RangingResult.Builder()
diff --git a/service/tests/wifitests/src/com/android/server/wifi/scanner/WifiScanningServiceTest.java b/service/tests/wifitests/src/com/android/server/wifi/scanner/WifiScanningServiceTest.java
index ff8bcfb8fd..a4711cb567 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/scanner/WifiScanningServiceTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/scanner/WifiScanningServiceTest.java
@@ -2188,7 +2188,7 @@ public class WifiScanningServiceTest extends WifiBaseTest {
      * Register a single scan listener and do a single scan
      */
     @Test
-    public void deregisterScanListener() throws Exception {
+    public void testDeregisterScanListener() throws Exception {
         WifiScanner.ScanSettings requestSettings = createRequest(WifiScanner.WIFI_BAND_BOTH, 0,
                 0, 20, WifiScanner.REPORT_EVENT_AFTER_EACH_SCAN);
         WifiNative.ScanSettings nativeSettings = computeSingleScanNativeSettings(requestSettings);
@@ -2233,6 +2233,21 @@ public class WifiScanningServiceTest extends WifiBaseTest {
         assertDumpContainsRequestLog("deregisterScanListener");
     }
 
+    /**
+     * Verify back to back calls to registerScanListener and deregisterScanListener works
+     */
+    @Test
+    public void testRegisterAndDeregisterListener() throws Exception {
+        startServiceAndLoadDriver();
+
+        TestClient client = new TestClient();
+        client.registerScanListener();
+        client.deregisterScanListener();
+        mLooper.dispatchAll();
+        client.verifySuccessfulResponse();
+        client.verifyUnlinkedToDeath();
+    }
+
     /**
      * Send a single scan request and then two more before the first completes. Neither are
      * satisfied by the first scan. Verify that the first completes and the second two are merged.
diff --git a/service/tests/wifitests/src/com/android/server/wifi/scanner/WificondScannerTest.java b/service/tests/wifitests/src/com/android/server/wifi/scanner/WificondScannerTest.java
index b037b168ee..18eb867784 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/scanner/WificondScannerTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/scanner/WificondScannerTest.java
@@ -141,12 +141,9 @@ public class WificondScannerTest extends BaseWifiScannerImplTest {
     public void externalScanResultsDoNotCauseSpuriousTimerCancellationOrCrash() {
         mWifiMonitor.sendMessage(IFACE_NAME, WifiMonitor.SCAN_RESULTS_EVENT);
         mLooper.dispatchAll();
-        verify(mAlarmManager.getAlarmManager(), never()).cancel(any(PendingIntent.class));
+        verify(mAlarmManager.getAlarmManager(), never()).cancel(nullable(PendingIntent.class));
         verify(mAlarmManager.getAlarmManager(), never())
-                .cancel(any(AlarmManager.OnAlarmListener.class));
-        verify(mAlarmManager.getAlarmManager(), never()).cancel(isNull(PendingIntent.class));
-        verify(mAlarmManager.getAlarmManager(), never())
-                .cancel(isNull(AlarmManager.OnAlarmListener.class));
+                .cancel(nullable(AlarmManager.OnAlarmListener.class));
     }
 
     @Test
@@ -166,12 +163,11 @@ public class WificondScannerTest extends BaseWifiScannerImplTest {
 
         mWifiMonitor.sendMessage(IFACE_NAME, WifiMonitor.SCAN_RESULTS_EVENT);
         mLooper.dispatchAll();
-        verify(mAlarmManager.getAlarmManager(), never()).cancel(any(PendingIntent.class));
+        verify(mAlarmManager.getAlarmManager(), never()).cancel(nullable(PendingIntent.class));
         verify(mAlarmManager.getAlarmManager(), times(1))
                 .cancel(any(AlarmManager.OnAlarmListener.class));
-        verify(mAlarmManager.getAlarmManager(), never()).cancel(isNull(PendingIntent.class));
         verify(mAlarmManager.getAlarmManager(), never())
-                .cancel(isNull(AlarmManager.OnAlarmListener.class));
+                .cancel((AlarmManager.OnAlarmListener)isNull());
     }
 
     @Test
@@ -198,12 +194,9 @@ public class WificondScannerTest extends BaseWifiScannerImplTest {
         mWifiMonitor.sendMessage(IFACE_NAME, WifiMonitor.SCAN_RESULTS_EVENT);
         mLooper.dispatchAll();
 
-        verify(mAlarmManager.getAlarmManager(), never()).cancel(any(PendingIntent.class));
-        verify(mAlarmManager.getAlarmManager(), never())
-                .cancel(any(AlarmManager.OnAlarmListener.class));
-        verify(mAlarmManager.getAlarmManager(), never()).cancel(isNull(PendingIntent.class));
+        verify(mAlarmManager.getAlarmManager(), never()).cancel(nullable(PendingIntent.class));
         verify(mAlarmManager.getAlarmManager(), never())
-                .cancel(isNull(AlarmManager.OnAlarmListener.class));
+                .cancel(nullable(AlarmManager.OnAlarmListener.class));
     }
 
     /**
diff --git a/service/tests/wifitests/src/com/android/server/wifi/usd/UsdRequestManagerTest.java b/service/tests/wifitests/src/com/android/server/wifi/usd/UsdRequestManagerTest.java
new file mode 100644
index 0000000000..ae911e693f
--- /dev/null
+++ b/service/tests/wifitests/src/com/android/server/wifi/usd/UsdRequestManagerTest.java
@@ -0,0 +1,403 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi.usd;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.app.AlarmManager;
+import android.net.wifi.IBooleanListener;
+import android.net.wifi.usd.Characteristics;
+import android.net.wifi.usd.Config;
+import android.net.wifi.usd.IPublishSessionCallback;
+import android.net.wifi.usd.ISubscribeSessionCallback;
+import android.net.wifi.usd.PublishConfig;
+import android.net.wifi.usd.SessionCallback;
+import android.net.wifi.usd.SubscribeConfig;
+import android.os.IBinder;
+import android.os.RemoteException;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.wifi.ActiveModeWarden;
+import com.android.server.wifi.ClientModeManager;
+import com.android.server.wifi.Clock;
+import com.android.server.wifi.SupplicantStaIfaceHal;
+import com.android.server.wifi.SupplicantStaIfaceHal.UsdCapabilitiesInternal;
+import com.android.server.wifi.WifiBaseTest;
+import com.android.server.wifi.WifiNative;
+import com.android.server.wifi.WifiThreadRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Unit test for {@link UsdRequestManager}.
+ */
+@SmallTest
+public class UsdRequestManagerTest extends WifiBaseTest {
+    private static final int TEST_PUBLISH_ID = 1;
+    private static final int TEST_SUBSCRIBE_ID = 2;
+    private UsdRequestManager mUsdRequestManager;
+    @Mock
+    private UsdNativeManager mUsdNativeManager;
+    @Mock
+    private WifiThreadRunner mWifiThreadRunner;
+    private static final String USD_INTERFACE_NAME = "wlan0";
+    private static final int USD_REQUEST_COMMAND_ID = 100;
+    private static final String USD_TEST_SERVICE_NAME = "UsdTest";
+    private static final int USD_TEST_PERIOD_MILLIS = 200;
+    private static final int USD_TTL_SEC = 3000;
+    @Mock
+    private Clock mClock;
+    @Mock
+    ISubscribeSessionCallback mSubscribeSessionCallback;
+    @Mock
+    IPublishSessionCallback mPublishSessionCallback;
+
+    private SupplicantStaIfaceHal.UsdCapabilitiesInternal mUsdCapabilities;
+    @Mock
+    private WifiNative mWifiNative;
+    @Mock
+    private IBinder mAppBinder;
+    private InOrder mInOrderAppBinder;
+    @Mock
+    private AlarmManager mAlarmManager;
+    private byte[] mSsi = new byte[]{1, 2, 3};
+    private int[] mFreqs = new int[]{2437};
+    private List<byte[]> mFilter;
+    @Mock
+    ActiveModeWarden mActiveModeWarden;
+    @Mock
+    ClientModeManager mClientModeManager;
+    @Mock
+    IBooleanListener mPublisherListener;
+    @Mock
+    IBooleanListener mSubscriberListener;
+    UsdRequestManager.UsdNativeEventsCallback mUsdNativeEventsCallback;
+
+    @Before
+    public void setUp() throws Exception {
+        initMocks(this);
+        mUsdCapabilities = getMockUsdCapabilities();
+        //mUsdNativeManager = new UsdNativeManager(mWifiNative);
+        when(mWifiNative.getUsdCapabilities()).thenReturn(mUsdCapabilities);
+        when(mActiveModeWarden.getPrimaryClientModeManager()).thenReturn(mClientModeManager);
+        when(mClientModeManager.getInterfaceName()).thenReturn(USD_INTERFACE_NAME);
+        // Capture argument for mUsdNativeManager.registerUsdEventsCallback
+        doAnswer(invocation -> {
+            mUsdNativeEventsCallback = invocation.getArgument(0);
+            return null;
+        }).when(mUsdNativeManager).registerUsdEventsCallback(any());
+        mUsdRequestManager = new UsdRequestManager(mUsdNativeManager, mWifiThreadRunner,
+                mActiveModeWarden, mClock, mAlarmManager);
+        UsdCapabilitiesInternal mockUsdCapabilities = getMockUsdCapabilities();
+        mFilter = new ArrayList<>();
+        mFilter.add(new byte[]{10, 11});
+        mFilter.add(new byte[]{12, 13, 14});
+        mInOrderAppBinder = inOrder(mAppBinder);
+        when(mUsdNativeManager.getUsdCapabilities()).thenReturn(mockUsdCapabilities);
+        // Get USD capabilities to update the cache
+        mUsdRequestManager.getCharacteristics();
+    }
+
+    private UsdCapabilitiesInternal getMockUsdCapabilities() {
+        return new UsdCapabilitiesInternal(true, true, 1024, 255,
+                255, 1, 1);
+    }
+
+    /**
+     * Test {@link UsdRequestManager#getCharacteristics()}.
+     */
+    @Test
+    public void testUsdGetCharacteristics() {
+        Characteristics characteristics = mUsdRequestManager.getCharacteristics();
+        assertEquals(mUsdCapabilities.maxNumSubscribeSessions,
+                characteristics.getMaxNumberOfSubscribeSessions());
+        assertEquals(mUsdCapabilities.maxNumPublishSessions,
+                characteristics.getMaxNumberOfPublishSessions());
+        assertEquals(mUsdCapabilities.maxServiceNameLengthBytes,
+                characteristics.getMaxServiceNameLength());
+        assertEquals(mUsdCapabilities.maxMatchFilterLengthBytes,
+                characteristics.getMaxMatchFilterLength());
+        assertEquals(mUsdCapabilities.maxLocalSsiLengthBytes,
+                characteristics.getMaxServiceSpecificInfoLength());
+    }
+
+    /**
+     * Test USD subscribe.
+     */
+    @Test
+    public void testUsdSubscribe() throws RemoteException {
+        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)
+                .setServiceSpecificInfo(mSsi)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setTtlSeconds(USD_TTL_SEC).build();
+        when(mSubscribeSessionCallback.asBinder()).thenReturn(mAppBinder);
+        when(mUsdNativeManager.subscribe(USD_INTERFACE_NAME, USD_REQUEST_COMMAND_ID,
+                subscribeConfig)).thenReturn(true);
+        mUsdRequestManager.subscribe(subscribeConfig, mSubscribeSessionCallback);
+        verify(mSubscribeSessionCallback, times(0)).onSubscribeFailed(anyInt());
+        mInOrderAppBinder.verify(mAppBinder).linkToDeath(any(IBinder.DeathRecipient.class),
+                anyInt());
+        mUsdNativeEventsCallback.onUsdSubscribeStarted(USD_REQUEST_COMMAND_ID, TEST_SUBSCRIBE_ID);
+        verify(mSubscribeSessionCallback, times(1)).onSubscribeStarted(TEST_SUBSCRIBE_ID);
+    }
+
+    /**
+     * Test USD publish.
+     */
+    @Test
+    public void testUsdPublish() throws RemoteException {
+        PublishConfig publishConfig = new PublishConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setAnnouncementPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setEventsEnabled(true)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setServiceSpecificInfo(mSsi)
+                .setSolicitedTransmissionType(Config.TRANSMISSION_TYPE_UNICAST)
+                .setTtlSeconds(USD_TTL_SEC)
+                .build();
+        when(mPublishSessionCallback.asBinder()).thenReturn(mAppBinder);
+        when(mUsdNativeManager.publish(eq(USD_INTERFACE_NAME), eq(USD_REQUEST_COMMAND_ID),
+                eq(publishConfig))).thenReturn(true);
+        mUsdRequestManager.publish(publishConfig, mPublishSessionCallback);
+        verify(mPublishSessionCallback, times(0)).onPublishFailed(anyInt());
+        mUsdNativeEventsCallback.onUsdPublishStarted(USD_REQUEST_COMMAND_ID, TEST_PUBLISH_ID);
+        verify(mPublishSessionCallback).onPublishStarted(TEST_PUBLISH_ID);
+    }
+
+    /**
+     * Test USD publish when already a subscriber running.
+     */
+    @Test
+    public void testUsdPublishFailureWhenSubscriberRunning() throws RemoteException {
+        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)
+                .setServiceSpecificInfo(mSsi)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setTtlSeconds(USD_TTL_SEC).build();
+        PublishConfig publishConfig = new PublishConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setAnnouncementPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setEventsEnabled(true)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setServiceSpecificInfo(mSsi)
+                .setSolicitedTransmissionType(Config.TRANSMISSION_TYPE_UNICAST)
+                .setTtlSeconds(USD_TTL_SEC)
+                .build();
+
+        when(mSubscribeSessionCallback.asBinder()).thenReturn(mAppBinder);
+        when(mUsdNativeManager.subscribe(USD_INTERFACE_NAME, USD_REQUEST_COMMAND_ID,
+                subscribeConfig)).thenReturn(true);
+        mUsdRequestManager.subscribe(subscribeConfig, mSubscribeSessionCallback);
+        mUsdRequestManager.publish(publishConfig, mPublishSessionCallback);
+        verify(mPublishSessionCallback).onPublishFailed(SessionCallback.FAILURE_NOT_AVAILABLE);
+    }
+
+    /**
+     * Test USD subscribe when already a publisher running.
+     */
+    @Test
+    public void testUsdSubscribeFailureWhenPublisherRunning() throws RemoteException {
+        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)
+                .setServiceSpecificInfo(mSsi)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setTtlSeconds(USD_TTL_SEC).build();
+        PublishConfig publishConfig = new PublishConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setAnnouncementPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setEventsEnabled(true)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setServiceSpecificInfo(mSsi)
+                .setSolicitedTransmissionType(Config.TRANSMISSION_TYPE_UNICAST)
+                .setTtlSeconds(USD_TTL_SEC)
+                .build();
+        when(mPublishSessionCallback.asBinder()).thenReturn(mAppBinder);
+        when(mUsdNativeManager.publish(eq(USD_INTERFACE_NAME), eq(USD_REQUEST_COMMAND_ID),
+                eq(publishConfig))).thenReturn(true);
+        mUsdRequestManager.publish(publishConfig, mPublishSessionCallback);
+        mUsdRequestManager.subscribe(subscribeConfig, mSubscribeSessionCallback);
+        verify(mSubscribeSessionCallback).onSubscribeFailed(SessionCallback.FAILURE_NOT_AVAILABLE);
+    }
+
+    /**
+     * Test USD subscribe failure when unsupported.
+     */
+    @Test
+    public void testUsdSubscribeFailureWhenUnsupported() throws RemoteException {
+        when(mWifiNative.getUsdCapabilities()).thenReturn(new UsdCapabilitiesInternal(false,
+                true, 1024, 255, 255, 1, 1));
+        mUsdRequestManager.getCharacteristics();
+        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)
+                .setServiceSpecificInfo(mSsi)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setTtlSeconds(USD_TTL_SEC).build();
+        mUsdRequestManager.subscribe(subscribeConfig, mSubscribeSessionCallback);
+        verify(mSubscribeSessionCallback).onSubscribeFailed(SessionCallback.FAILURE_NOT_AVAILABLE);
+    }
+
+    /**
+     * Test USD publish failure when unsupported.
+     */
+    @Test
+    public void testUsdPublishFailureWhenUnsupported() throws RemoteException {
+        when(mWifiNative.getUsdCapabilities()).thenReturn(new UsdCapabilitiesInternal(true,
+                false, 1024, 255, 255, 1, 1));
+        mUsdRequestManager.getCharacteristics();
+        PublishConfig publishConfig = new PublishConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setAnnouncementPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setEventsEnabled(true)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setServiceSpecificInfo(mSsi)
+                .setSolicitedTransmissionType(Config.TRANSMISSION_TYPE_UNICAST)
+                .setTtlSeconds(USD_TTL_SEC)
+                .build();
+        mUsdRequestManager.publish(publishConfig, mPublishSessionCallback);
+        verify(mPublishSessionCallback).onPublishFailed(SessionCallback.FAILURE_NOT_AVAILABLE);
+    }
+
+    /**
+     * Test USD status listener for publisher and subscriber.
+     * @throws RemoteException
+     */
+    @Test
+    public void testUsdStatusListener() throws RemoteException {
+        when(mPublisherListener.asBinder()).thenReturn(mAppBinder);
+        when(mSubscriberListener.asBinder()).thenReturn(mAppBinder);
+        mUsdRequestManager.registerPublisherStatusListener(mPublisherListener);
+        mUsdRequestManager.registerSubscriberStatusListener(mSubscriberListener);
+        // Initially, publisher and  should be available
+        verify(mPublisherListener).onResult(true);
+        verify(mSubscriberListener).onResult(true);
+
+        // Start a publish session
+        PublishConfig publishConfig = new PublishConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setAnnouncementPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setEventsEnabled(true)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setServiceSpecificInfo(mSsi)
+                .setSolicitedTransmissionType(Config.TRANSMISSION_TYPE_UNICAST)
+                .setTtlSeconds(USD_TTL_SEC)
+                .build();
+        when(mPublishSessionCallback.asBinder()).thenReturn(mAppBinder);
+        when(mUsdNativeManager.publish(eq(USD_INTERFACE_NAME), eq(USD_REQUEST_COMMAND_ID),
+                eq(publishConfig))).thenReturn(true);
+        mUsdRequestManager.publish(publishConfig, mPublishSessionCallback);
+        verify(mPublishSessionCallback, times(0)).onPublishFailed(anyInt());
+        mUsdNativeEventsCallback.onUsdPublishStarted(USD_REQUEST_COMMAND_ID, TEST_PUBLISH_ID);
+        verify(mPublishSessionCallback).onPublishStarted(TEST_PUBLISH_ID);
+
+        // After starting, subscriber should be unavailable
+        verify(mSubscriberListener, times(1)).onResult(false);
+
+        // Stop publish session.
+        mUsdRequestManager.cancelPublish(TEST_PUBLISH_ID);
+        verify(mUsdNativeManager).cancelPublish(USD_INTERFACE_NAME, TEST_PUBLISH_ID);
+        // Subscriber should be available again
+        verify(mPublisherListener, times(1)).onResult(true);
+    }
+
+    /**
+     * Test USD publish when interface name is null.
+     */
+    @Test
+    public void testPublishWithNullInterfaceName() throws RemoteException {
+        when(mClientModeManager.getInterfaceName()).thenReturn(null);
+        PublishConfig publishConfig = new PublishConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setAnnouncementPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setEventsEnabled(true)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setServiceSpecificInfo(mSsi)
+                .setSolicitedTransmissionType(Config.TRANSMISSION_TYPE_UNICAST)
+                .setTtlSeconds(USD_TTL_SEC)
+                .build();
+        mUsdRequestManager.publish(publishConfig, mPublishSessionCallback);
+        verify(mPublishSessionCallback).onPublishFailed(SessionCallback.FAILURE_NOT_AVAILABLE);
+    }
+
+    /**
+     * Test USD subscribe when interface name is null.
+     */
+    @Test
+    public void testSubscribeWithNullInterfaceName() throws RemoteException {
+        when(mClientModeManager.getInterfaceName()).thenReturn(null);
+        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder(USD_TEST_SERVICE_NAME)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setOperatingFrequenciesMhz(mFreqs)
+                .setRxMatchFilter(mFilter)
+                .setTxMatchFilter(mFilter)
+                .setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)
+                .setServiceSpecificInfo(mSsi)
+                .setServiceProtoType(Config.SERVICE_PROTO_TYPE_CSA_MATTER)
+                .setQueryPeriodMillis(USD_TEST_PERIOD_MILLIS)
+                .setTtlSeconds(USD_TTL_SEC).build();
+        mUsdRequestManager.subscribe(subscribeConfig, mSubscribeSessionCallback);
+        verify(mSubscribeSessionCallback).onSubscribeFailed(SessionCallback.FAILURE_NOT_AVAILABLE);
+    }
+}
diff --git a/service/tests/wifitests/src/com/android/server/wifi/util/ApConfigUtilTest.java b/service/tests/wifitests/src/com/android/server/wifi/util/ApConfigUtilTest.java
index aabfb3883c..39eca8f05c 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/util/ApConfigUtilTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/util/ApConfigUtilTest.java
@@ -1483,7 +1483,8 @@ public class ApConfigUtilTest extends WifiBaseTest {
                 .thenReturn(false);
         /* 11be is disallowed when IEEE80211_BE feature is not supported */
         assertFalse(ApConfigUtil.is11beAllowedForThisConfiguration(mDeviceWiphyCapabilities,
-                mContext, config, true, 0, false));
+                mContext, config, true, 2 /* maximumSupportedMLD */, 0 /* currentExistingMLD */,
+                false));
 
         when(mResources.getBoolean(R.bool.config_wifiSoftapIeee80211beSupported))
                 .thenReturn(true);
@@ -1493,35 +1494,42 @@ public class ApConfigUtilTest extends WifiBaseTest {
                 .thenReturn(true);
         /* 11be is allowed if chip supports single link MLO in bridged mode */
         assertTrue(ApConfigUtil.is11beAllowedForThisConfiguration(mDeviceWiphyCapabilities,
-                mContext, config, true, 0, false));
+                mContext, config, true, 2 /* maximumSupportedMLD */, 0 /* currentExistingMLD */,
+                false));
 
         /* 11be is not allowed if chip doesn't support single link MLO in bridged mode */
         when(mResources.getBoolean(R.bool.config_wifiSoftApSingleLinkMloInBridgedModeSupported))
                 .thenReturn(false);
         assertFalse(ApConfigUtil.is11beAllowedForThisConfiguration(mDeviceWiphyCapabilities,
-                mContext, config, true, 0, false));
+                mContext, config, true, 1 /* maximumSupportedMLD */, 0 /* currentExistingMLD */,
+                false));
 
         when(Flags.mloSap()).thenReturn(true);
         // two MLDs supported, allow 11be on bridged mode.
         when(mResources.getInteger(R.integer.config_wifiSoftApMaxNumberMLDSupported))
                 .thenReturn(2);
         assertTrue(ApConfigUtil.is11beAllowedForThisConfiguration(mDeviceWiphyCapabilities,
-                mContext, config, true, 0, false));
+                mContext, config, true, 2 /* maximumSupportedMLD */, 0 /* currentExistingMLD */,
+                false));
 
-        // One MLD only, disallow 11be on bridged AP.
+        // One MLD supported only, disallow 11be on bridged AP.
         when(mResources.getInteger(R.integer.config_wifiSoftApMaxNumberMLDSupported))
                 .thenReturn(1);
         assertFalse(ApConfigUtil.is11beAllowedForThisConfiguration(mDeviceWiphyCapabilities,
-                mContext, config, true, 0, false));
+                mContext, config, true, 1 /* maximumSupportedMLD */, 0 /* currentExistingMLD */,
+                false));
 
-        // One MLD only, disallow 11be when there is existing 11be AP.
+        // One MLD supported only, disallow 11be when there is existing 11be AP.
         assertFalse(ApConfigUtil.is11beAllowedForThisConfiguration(mDeviceWiphyCapabilities,
-                mContext, config, false, 1, false));
+                mContext, config, false, 1 /* maximumSupportedMLD */, 1 /* currentExistingMLD */,
+                false));
 
-        // One MLD only but chip support MultilinksOnMLD, allow 11be on bridged AP.
+        // One MLD supported only but chip support MultilinksOnMLD, allow 11be on bridged AP.
         assertTrue(ApConfigUtil.is11beAllowedForThisConfiguration(mDeviceWiphyCapabilities,
-                mContext, config, true, 0, true));
+                mContext, config, true, 1 /* maximumSupportedMLD */, 0 /* currentExistingMLD */,
+                true));
     }
+
     @Test
     public void testIs11beDisabledForSecurityType() throws Exception {
         assertTrue(ApConfigUtil.is11beDisabledForSecurityType(SECURITY_TYPE_OPEN));
@@ -1531,4 +1539,41 @@ public class ApConfigUtilTest extends WifiBaseTest {
         assertFalse(ApConfigUtil.is11beDisabledForSecurityType(SECURITY_TYPE_WPA3_OWE));
         assertTrue(ApConfigUtil.is11beDisabledForSecurityType(SECURITY_TYPE_WPA3_OWE_TRANSITION));
     }
+
+    @Test
+    public void testGetMaximumSupportedMLD() throws Exception {
+        // Old overlay, no MLD number is configured
+        when(mResources.getInteger(R.integer.config_wifiSoftApMaxNumberMLDSupported))
+                .thenReturn(0);
+        // 1 MLD supported only no matter whether multiple MLD supported.
+        when(mResources.getBoolean(R.bool.config_wifiSoftApSingleLinkMloInBridgedModeSupported))
+                .thenReturn(false);
+        assertEquals(1, ApConfigUtil.getMaximumSupportedMLD(mContext,
+                false /* isMultipleMLMDSupportedOnSap */));
+        assertEquals(1, ApConfigUtil.getMaximumSupportedMLD(mContext,
+                true /* isMultipleMLMDSupportedOnSap */));
+
+        // 2 MLDs supported when overlay is true and no matter whether multiple MLD supported.
+        when(mResources.getBoolean(R.bool.config_wifiSoftApSingleLinkMloInBridgedModeSupported))
+                .thenReturn(true);
+        assertEquals(2, ApConfigUtil.getMaximumSupportedMLD(mContext,
+                false /* isMultipleMLMDSupportedOnSap */));
+        assertEquals(2, ApConfigUtil.getMaximumSupportedMLD(mContext,
+                true /* isMultipleMLMDSupportedOnSap */));
+
+        // New overlay, MLD number is configured. It will check multiple MLD supported value.
+        when(Flags.multipleMldOnSapSupported()).thenReturn(true);
+        when(mResources.getInteger(R.integer.config_wifiSoftApMaxNumberMLDSupported))
+                .thenReturn(2);
+        assertEquals(1, ApConfigUtil.getMaximumSupportedMLD(mContext,
+                false /* isMultipleMLMDSupportedOnSap */));
+        assertEquals(2, ApConfigUtil.getMaximumSupportedMLD(mContext,
+                true /* isMultipleMLMDSupportedOnSap */));
+
+        // Make sure it uses overlay value even though chip supports multiple MLD.
+        when(mResources.getInteger(R.integer.config_wifiSoftApMaxNumberMLDSupported))
+                .thenReturn(1);
+        assertEquals(1, ApConfigUtil.getMaximumSupportedMLD(mContext,
+                true /* isMultipleMLMDSupportedOnSap */));
+    }
 }
diff --git a/service/tests/wifitests/src/com/android/server/wifi/util/FeatureBitsetUtilsTest.java b/service/tests/wifitests/src/com/android/server/wifi/util/FeatureBitsetUtilsTest.java
new file mode 100644
index 0000000000..52c3a3ead1
--- /dev/null
+++ b/service/tests/wifitests/src/com/android/server/wifi/util/FeatureBitsetUtilsTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi.util;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertTrue;
+
+import android.net.wifi.WifiManager;
+
+import org.junit.Test;
+
+import java.util.BitSet;
+
+/**
+ * Unit tests for {@link FeatureBitsetUtils}
+ */
+public class FeatureBitsetUtilsTest {
+    /**
+     * Verify that formatting a null or empty BitSet produces the default value.
+     */
+    @Test
+    public void testNoFeatures() {
+        assertEquals("[]", FeatureBitsetUtils.formatSupportedFeatures(null));
+        assertEquals("[]", FeatureBitsetUtils.formatSupportedFeatures(new BitSet()));
+    }
+
+    /**
+     * Verify that a simple BitSet can be formatted successfully.
+     */
+    @Test
+    public void testSuccessfulFormatting() {
+        BitSet features = new BitSet();
+        features.set(WifiManager.WIFI_FEATURE_AP_STA);
+        features.set(WifiManager.WIFI_FEATURE_AWARE);
+        String formatted = FeatureBitsetUtils.formatSupportedFeatures(features);
+        assertTrue(formatted.contains("WIFI_FEATURE_AP_STA"));
+        assertTrue(formatted.contains("WIFI_FEATURE_AWARE"));
+    }
+
+    /**
+     * Verify that the newest feature is formatted successfully.
+     */
+    @Test
+    public void testNewestFeatureFormatting() {
+        BitSet features = new BitSet();
+        features.set(FeatureBitsetUtils.NEWEST_FEATURE_INDEX);
+        String formatted = FeatureBitsetUtils.formatSupportedFeatures(features);
+        String newestFeatureName = (String) FeatureBitsetUtils.ALL_FEATURES.get(
+                FeatureBitsetUtils.NEWEST_FEATURE_INDEX);
+        assertTrue(formatted.contains(newestFeatureName));
+    }
+
+    /**
+     * Verify that an unrecognized feature produces the expected warning text.
+     */
+    @Test
+    public void testUnrecognizedFeature() {
+        BitSet features = new BitSet();
+        features.set(FeatureBitsetUtils.NEWEST_FEATURE_INDEX + 1);
+        String formatted = FeatureBitsetUtils.formatSupportedFeatures(features);
+        assertTrue(formatted.contains("UNRECOGNIZED FEATURE"));
+    }
+}
diff --git a/service/tests/wifitests/src/com/android/server/wifi/util/InformationElementUtilTest.java b/service/tests/wifitests/src/com/android/server/wifi/util/InformationElementUtilTest.java
index abc04e5f9d..0c6dfe15ce 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/util/InformationElementUtilTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/util/InformationElementUtilTest.java
@@ -515,7 +515,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                                 (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x0F,
                                 (byte) 0xAC, (byte) 0x02, (byte) 0x00, (byte) 0x00 };
         verifyCapabilityStringFromIeWithoutOweSupported(ie,
-                "[WPA2-PSK-CCMP+TKIP][RSN-PSK-CCMP+TKIP]");
+                "[WPA2-PSK-CCMP-128+TKIP][RSN-PSK-CCMP-128+TKIP]");
     }
 
     /**
@@ -537,7 +537,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                                 (byte) 0x00, (byte) 0x00 // RSN capabilities
         };
         verifyCapabilityStringFromIeWithoutOweSupported(ie,
-                "[RSN-?-CCMP+TKIP]");
+                "[RSN-?-CCMP-128+TKIP]");
     }
 
     /**
@@ -576,7 +576,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x0c,
         };
         verifyCapabilityStringFromIeWithoutOweSupported(ie,
-                "[WPA2-EAP/SHA1-CCMP+TKIP][RSN-EAP/SHA1-CCMP+TKIP][MFPR]");
+                "[WPA2-EAP/SHA1-CCMP-128+TKIP][RSN-EAP/SHA1-CCMP-128+TKIP][MFPR]");
     }
 
     /**
@@ -608,8 +608,8 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x0c,
         };
         verifyCapabilityStringFromIeWithoutOweSupported(ie,
-                "[WPA2-EAP/SHA256-CCMP]"
-                        + "[RSN-EAP/SHA256-CCMP][MFPR][MFPC]");
+                "[WPA2-EAP/SHA256-CCMP-128]"
+                        + "[RSN-EAP/SHA256-CCMP-128][MFPR][MFPC]");
     }
 
     /**
@@ -637,8 +637,8 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0xc0, (byte) 0x00,
         };
         verifyCapabilityStringFromIeWithoutOweSupported(ie,
-                "[WPA2-EAP/SHA256-CCMP]"
-                        + "[RSN-EAP/SHA256-CCMP][MFPR][MFPC]");
+                "[WPA2-EAP/SHA256-CCMP-128]"
+                        + "[RSN-EAP/SHA256-CCMP-128][MFPR][MFPC]");
     }
 
     /**
@@ -672,8 +672,8 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x0c,
         };
         verifyCapabilityStringFromIeWithoutOweSupported(ie,
-                "[WPA2-EAP/SHA1+EAP/SHA256-CCMP]"
-                        + "[RSN-EAP/SHA1+EAP/SHA256-CCMP][MFPC]");
+                "[WPA2-EAP/SHA1+EAP/SHA256-CCMP-128]"
+                        + "[RSN-EAP/SHA1+EAP/SHA256-CCMP-128][MFPC]");
     }
 
     /**
@@ -703,7 +703,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x40, (byte) 0x00,
         };
         verifyCapabilityStringFromIeWithoutOweSupported(ie,
-                "[WPA2-EAP/SHA1-CCMP+TKIP][RSN-EAP/SHA1-CCMP+TKIP][MFPR]");
+                "[WPA2-EAP/SHA1-CCMP-128+TKIP][RSN-EAP/SHA1-CCMP-128+TKIP][MFPR]");
     }
 
     /**
@@ -736,7 +736,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                                 (byte) 0x00, (byte) 0x50, (byte) 0xF2, (byte) 0x02,
                                 (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x50,
                                 (byte) 0xF2, (byte) 0x02, (byte) 0x00, (byte) 0x00 };
-        verifyCapabilityStringFromIeWithoutOweSupported(ie, "[WPA-PSK-CCMP+TKIP]");
+        verifyCapabilityStringFromIeWithoutOweSupported(ie, "[WPA-PSK-CCMP-128+TKIP]");
     }
 
     /**
@@ -757,7 +757,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                                 (byte) 0x01, (byte) 0x00, // AKM count
                                 (byte) 0x00, (byte) 0x50, (byte) 0x99, (byte) 0x99, // Unknown AKM
                                 (byte) 0x00, (byte) 0x00};
-        verifyCapabilityStringFromIeWithoutOweSupported(ie, "[WPA-?-CCMP+TKIP]");
+        verifyCapabilityStringFromIeWithoutOweSupported(ie, "[WPA-?-CCMP-128+TKIP]");
     }
 
     /**
@@ -805,7 +805,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 0x1 << 4,
                 false,
                 false,
-                "[WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][RSN-PSK-CCMP+TKIP]",
+                "[WPA-PSK-CCMP-128+TKIP][WPA2-PSK-CCMP-128+TKIP][RSN-PSK-CCMP-128+TKIP]",
                 null);
     }
 
@@ -835,7 +835,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 // Padding
                 (byte) 0x00, (byte) 0x00 };
         verifyCapabilityStringFromIeWithOweSupported(
-                ieRsn, "[WPA2-PSK-CCMP][RSN-PSK+SAE-CCMP]", null);
+                ieRsn, "[WPA2-PSK-CCMP-128][RSN-PSK+SAE-CCMP-128]", null);
     }
 
     /**
@@ -863,7 +863,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x09,
                 // Padding
                 (byte) 0x00, (byte) 0x00 };
-        verifyCapabilityStringFromIeWithOweSupported(ieRsn, "[RSN-SAE+FT/SAE-CCMP]", null);
+        verifyCapabilityStringFromIeWithOweSupported(ieRsn, "[RSN-SAE+FT/SAE-CCMP-128]", null);
     }
 
     /**
@@ -891,7 +891,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x18,
                 // Padding
                 (byte) 0x00, (byte) 0x00 };
-        verifyCapabilityStringFromIeWithOweSupported(ieRsn, "[RSN-SAE+SAE_EXT_KEY-CCMP]", null);
+        verifyCapabilityStringFromIeWithOweSupported(ieRsn, "[RSN-SAE+SAE_EXT_KEY-CCMP-128]", null);
     }
 
     /**
@@ -921,7 +921,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 // Padding
                 (byte) 0x00, (byte) 0x00 };
         verifyCapabilityStringFromIeWithOweSupported(
-                ieRsn, "[RSN-SAE_EXT_KEY+FT/SAE_EXT_KEY-CCMP]", null);
+                ieRsn, "[RSN-SAE_EXT_KEY+FT/SAE_EXT_KEY-CCMP-128]", null);
     }
 
     /**
@@ -947,7 +947,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x12,
                 // Padding
                 (byte) 0x00, (byte) 0x00 };
-        verifyCapabilityStringFromIeWithOweSupported(ieRsn, "[RSN-OWE-CCMP]", null);
+        verifyCapabilityStringFromIeWithOweSupported(ieRsn, "[RSN-OWE-CCMP-128]", null);
     }
 
     /**
@@ -963,7 +963,8 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x50, (byte) 0x6F, (byte) 0x9A, (byte) 0x1C,
                 // OWE IE contains BSSID, SSID and channel of other BSS, but we don't parse it.
                 (byte) 0x00, (byte) 0x000, (byte) 0x00, (byte) 0x00 };
-        verifyCapabilityStringFromIe(ieOwe, 0x1 << 0, true, "[RSN-OWE_TRANSITION-CCMP][ESS]", null);
+        verifyCapabilityStringFromIe(ieOwe, 0x1 << 0, true, "[RSN-OWE_TRANSITION-CCMP-128][ESS]",
+                null);
     }
 
     /**
@@ -1014,6 +1015,38 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 "[RSN-EAP_SUITE_B_192-GCMP-256][MFPR]");
     }
 
+    /**
+     * Test Capabilities.generateCapabilitiesString() with RSN IE, GCMP-128 and SUITE_B_192.
+     * Expect the function to return a string with the proper security information.
+     */
+    @Test
+    public void buildCapabilities_rsnSuiteB192ElementWithGcmp128() {
+        InformationElement ieRsn = new InformationElement();
+        ieRsn.id = InformationElement.EID_RSN;
+        ieRsn.bytes = new byte[] {
+                // RSNE Version (0x0001)
+                (byte) 0x01, (byte) 0x00,
+                // Group cipher suite: GCMP-128
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x09,
+                // Number of cipher suites (1)
+                (byte) 0x01, (byte) 0x00,
+                // Cipher suite: GCMP-256
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x08,
+                // Number of AKMs (1)
+                (byte) 0x01, (byte) 0x00,
+                // SUITE_B_192 AKM
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x0C,
+                // RSN capabilities
+                (byte) 0x40, (byte) 0x00,
+                // PMKID count
+                (byte) 0x00, (byte) 0x00,
+                // Group mgmt cipher suite: BIP_GMAC_256
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x0c,
+        };
+        verifyCapabilityStringFromIeWithoutOweSupported(ieRsn,
+                "[RSN-EAP_SUITE_B_192-GCMP-128][MFPR]");
+    }
+
     /**
      * Test Capabilities.generateCapabilitiesString() with RSN IE,
      * CCMP and FILS SHA256. Expect the function to return a string
@@ -1044,8 +1077,8 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x00, (byte) 0x00 };
         verifyCapabilityStringFromIeWithOweSupported(
                 ieRsn,
-                "[WPA2-EAP/SHA1+EAP/SHA256+EAP-FILS-SHA256-CCMP]"
-                        + "[RSN-EAP/SHA1+EAP/SHA256+EAP-FILS-SHA256-CCMP]",
+                "[WPA2-EAP/SHA1+EAP/SHA256+EAP-FILS-SHA256-CCMP-128]"
+                        + "[RSN-EAP/SHA1+EAP/SHA256+EAP-FILS-SHA256-CCMP-128]",
                 null);
     }
 
@@ -1079,8 +1112,8 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 (byte) 0x00, (byte) 0x00 };
         verifyCapabilityStringFromIeWithOweSupported(
                 ieRsn,
-                "[WPA2-EAP/SHA1+EAP/SHA256+EAP-FILS-SHA384-CCMP]"
-                        + "[RSN-EAP/SHA1+EAP/SHA256+EAP-FILS-SHA384-CCMP]",
+                "[WPA2-EAP/SHA1+EAP/SHA256+EAP-FILS-SHA384-CCMP-128]"
+                        + "[RSN-EAP/SHA1+EAP/SHA256+EAP-FILS-SHA384-CCMP-128]",
                 null);
     }
 
@@ -1130,7 +1163,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                     (byte) 0x00
                 };
         verifyCapabilityStringFromIeWithOweSupported(
-                ieRsn, "[RSN-SAE_EXT_KEY-CCMP]", unknownAkmMap);
+                ieRsn, "[RSN-SAE_EXT_KEY-CCMP-128]", unknownAkmMap);
     }
 
     /**
@@ -1212,7 +1245,8 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 0x1 << 4,
                 true,
                 true,
-                "[WPA2-PSK-CCMP][RSN-PSK-CCMP][RSN-SAE-CCMP][RSN-SAE_EXT_KEY-GCMP-256][MFPC][RSNO]",
+                "[WPA2-PSK-CCMP-128][RSN-PSK-CCMP-128][RSN-SAE-CCMP-128][RSN-SAE_EXT_KEY-GCMP-256"
+                        + "][MFPC][RSNO]",
                 null);
     }
 
@@ -1274,7 +1308,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 0x1 << 4,
                 true,
                 true,
-                "[RSN-SAE-CCMP][RSN-SAE_EXT_KEY-GCMP-256][MFPR][MFPC][RSNO]",
+                "[RSN-SAE-CCMP-128][RSN-SAE_EXT_KEY-GCMP-256][MFPR][MFPC][RSNO]",
                 null);
     }
 
@@ -1333,7 +1367,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
                 0x1 << 4,
                 true,
                 false,
-                "[WPA2-PSK-CCMP][RSN-PSK-CCMP]",
+                "[WPA2-PSK-CCMP-128][RSN-PSK-CCMP-128]",
                 null);
     }
 
@@ -1380,7 +1414,7 @@ public class InformationElementUtilTest extends WifiBaseTest {
         ieWps.bytes = new byte[] { (byte) 0x00, (byte) 0x50, (byte) 0xF2, (byte) 0x04 };
 
         InformationElement[] ies = new InformationElement[] { ieWpa, ieWps };
-        verifyCapabilityStringFromIes(ies, 0x1 << 4, false, false, "[WPA-PSK-CCMP+TKIP][WPS]",
+        verifyCapabilityStringFromIes(ies, 0x1 << 4, false, false, "[WPA-PSK-CCMP-128+TKIP][WPS]",
                 null);
     }
 
@@ -2831,4 +2865,92 @@ public class InformationElementUtilTest extends WifiBaseTest {
         assertEquals(6105, ehtOperation.getCenterFreq1(ScanResult.WIFI_BAND_6_GHZ));
 
     }
+
+    /**
+     * Test Capabilities.generateCapabilitiesString() with a RSN IE.
+     * Expect the function to return a string with the proper security information.
+     */
+    @Test
+    public void buildCapabilities_rsnElementWithPasnSae() {
+        InformationElement ie = new InformationElement();
+        ie.id = InformationElement.EID_RSN;
+        ie.bytes = new byte[] {
+                // Version
+                (byte) 0x01, (byte) 0x00,
+                // Group cipher suite: TKIP
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x02,
+                // Pairwise cipher count
+                (byte) 0x02, (byte) 0x00,
+                // Pairwise cipher suite: CCMP
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x04,
+                // Pairwise cipher suite: GCMP_256
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x09,
+                // AKM count
+                (byte) 0x02, (byte) 0x00,
+                // AMK suite: PASN
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x15,
+                // AKM suite: SAE
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x08,
+                // RSN capabilities
+                (byte) 0x40, (byte) 0x00,
+        };
+        verifyCapabilityStringFromIeWithoutOweSupported(ie,
+                     "[RSN-PASN+SAE-CCMP-128+GCMP-256][MFPR]");
+    }
+
+    /**
+     * Test Capabilities.generateCapabilitiesString() with a RSN IE.
+     * Expect the function to return a string with the proper security information.
+     */
+    @Test
+    public void buildCapabilities_rsnElementWithPasnSaeAndCcmp256() {
+        InformationElement ie = new InformationElement();
+        ie.id = InformationElement.EID_RSN;
+        ie.bytes = new byte[] {
+                // Version
+                (byte) 0x01, (byte) 0x00,
+                // Group cipher suite: TKIP
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x02,
+                // Pairwise cipher count
+                (byte) 0x01, (byte) 0x00,
+                // Pairwise cipher suite: CCMP-256
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x0A,
+                // AKM count
+                (byte) 0x02, (byte) 0x00,
+                // AMK suite: PASN
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x15,
+                // AKM suite: SAE
+                (byte) 0x00, (byte) 0x0F, (byte) 0xAC, (byte) 0x08,
+                // RSN capabilities
+                (byte) 0x40, (byte) 0x00,
+        };
+        verifyCapabilityStringFromIeWithoutOweSupported(ie,
+                "[RSN-PASN+SAE-CCMP-256][MFPR]");
+    }
+
+    /**
+     * Test RSNXE capabilities for IEEE 802.11az secure ranging support.
+     * <ul>
+     *     <li> Bit 8 : Secure HE-LTF Support
+     *     <li> Bit 15: URNM-MFPR
+     * </ul>
+     */
+    @Test
+    public void testRsnExtensionWithIeee80211azSecuritySupported() {
+        InformationElement ie = new InformationElement();
+        ie.id = InformationElement.EID_RSN_EXTENSION;
+        ie.bytes = new byte[]{
+                // Length
+                (byte) 0x02,
+                // Extended RSN capabilities - Secure HE-LTF and URNM-MFPR enabled
+                (byte) 0x81, (byte) 0x00,
+        };
+
+        InformationElementUtil.Rsnxe rsnxe = new InformationElementUtil.Rsnxe();
+        rsnxe.from(ie);
+        assertTrue(rsnxe.isRangingFrameProtectionRequired());
+        assertTrue(rsnxe.isSecureHeLtfSupported());
+    }
+
 }
+
diff --git a/service/tests/wifitests/src/com/android/server/wifi/util/RssiUtilTest.java b/service/tests/wifitests/src/com/android/server/wifi/util/RssiUtilTest.java
index 3e924173c0..6089651d3f 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/util/RssiUtilTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/util/RssiUtilTest.java
@@ -30,7 +30,6 @@ import android.net.wifi.IWifiManager;
 import android.net.wifi.WifiInfo;
 import android.net.wifi.WifiManager;
 import android.os.Build;
-import android.os.Looper;
 
 import androidx.test.filters.SmallTest;
 
@@ -117,7 +116,7 @@ public class RssiUtilTest extends WifiBaseTest {
         when(context.getApplicationInfo()).thenReturn(applicationInfo);
         when(context.getOpPackageName()).thenReturn("TestPackage");
         WifiManager wifiManager = new WifiManager(
-                context, iWifiManager, mock(Looper.class));
+                context, iWifiManager);
 
         int level = wifiManager.getMaxSignalLevel();
         assertThat(level).isEqualTo(4);
diff --git a/service/tests/wifitests/src/com/android/server/wifi/util/WifiPermissionsUtilTest.java b/service/tests/wifitests/src/com/android/server/wifi/util/WifiPermissionsUtilTest.java
index a53ace0010..947b45b7bf 100644
--- a/service/tests/wifitests/src/com/android/server/wifi/util/WifiPermissionsUtilTest.java
+++ b/service/tests/wifitests/src/com/android/server/wifi/util/WifiPermissionsUtilTest.java
@@ -29,8 +29,8 @@ import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.nullable;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
diff --git a/tests/OWNERS b/tests/OWNERS
index bde782479f..288dd244e8 100644
--- a/tests/OWNERS
+++ b/tests/OWNERS
@@ -4,4 +4,3 @@ include platform/packages/modules/Wifi:/WIFI_OWNERS
 # Engprod - Not owner of the test but help maintaining the module as an example
 jdesprez@google.com
 frankfeng@google.com
-murj@google.com
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/Android.bp b/tests/hostsidetests/multidevices/com.google.snippet.wifi/Android.bp
index bcbcb8532c..84c90e3ab1 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/Android.bp
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/Android.bp
@@ -7,17 +7,16 @@ package {
 android_test {
     name: "wifi_mobly_snippet",
     sdk_version: "system_current",
-    srcs: [
-        "aware/*.java",
-        "direct/*.java",
-    ],
+    srcs: ["**/*.java"],
     manifest: "AndroidManifest.xml",
     static_libs: [
         "androidx.test.runner",
         "compatibility-device-util-axt",
+        "gson",
         "guava",
         "mobly-snippet-lib",
         "mobly-bundled-snippets-lib",
+        "wifi_aconfig_flags_lib",
     ],
     min_sdk_version: "31",
     target_sdk_version: "35",
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/AndroidManifest.xml b/tests/hostsidetests/multidevices/com.google.snippet.wifi/AndroidManifest.xml
index b8e9f824c8..719d3fe6cb 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/AndroidManifest.xml
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/AndroidManifest.xml
@@ -25,6 +25,8 @@
         android:value="com.google.snippet.wifi.aware.WifiAwareManagerSnippet,
                        com.google.snippet.wifi.aware.ConnectivityManagerSnippet,
                        com.google.snippet.wifi.direct.WifiP2pManagerSnippet,
+                       com.google.snippet.wifi.softap.TetheringManagerSnippet,
+                       com.google.snippet.wifi.WifiManagerSnippet,
                        com.google.android.mobly.snippet.bundled.WifiManagerSnippet"/>
     <meta-data
         android:name="mobly-object-converter"
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/WifiJsonConverter.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/WifiJsonConverter.java
new file mode 100644
index 0000000000..47c408268d
--- /dev/null
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/WifiJsonConverter.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.snippet.wifi;
+
+import android.net.wifi.SoftApConfiguration;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * The converter class that allows users to use custom type as snippet RPC arguments and return
+ * values.
+ */
+public final class WifiJsonConverter {
+    private static final Gson GSON = new GsonBuilder().serializeNulls().create();
+
+    /**
+     * Remove the extra quotation marks from the beginning and the end of a string.
+     *
+     * <p>This is useful for strings like the SSID field of Android's Wi-Fi configuration.
+     */
+    public static String trimQuotationMarks(String originalString) {
+        String result = originalString;
+        if (originalString.length() > 2
+                && originalString.charAt(0) == '"'
+                && originalString.charAt(originalString.length() - 1) == '"') {
+            result = originalString.substring(1, originalString.length() - 1);
+        }
+        return result;
+    }
+
+    /**
+     * Serializes a complex type object to {@link JSONObject}.
+     **
+     * @param object The object to convert to "serialize".
+     * @return A JSONObject representation of the input object.
+     * @throws JSONException if there is an error serializing the object.
+     */
+    public static JSONObject serialize(Object object) throws JSONException {
+        // If the RPC method requires a custom return type with special serialization
+        // considerations we need to define it here.
+        if (object instanceof SoftApConfiguration) {
+            return serializeSoftApConfiguration((SoftApConfiguration) object);
+        }
+
+        // By default, depends on Gson to serialize correctly.
+        return new JSONObject(GSON.toJson(object));
+    }
+
+    private static JSONObject serializeSoftApConfiguration(SoftApConfiguration data)
+            throws JSONException {
+        JSONObject result = new JSONObject(GSON.toJson(data));
+        result.put("SSID", trimQuotationMarks(data.getWifiSsid().toString()));
+        return result;
+    }
+
+    private WifiJsonConverter() {}
+}
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/WifiManagerSnippet.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/WifiManagerSnippet.java
new file mode 100644
index 0000000000..3a0ce0d57b
--- /dev/null
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/WifiManagerSnippet.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.snippet.wifi;
+
+import static android.net.wifi.DeauthenticationReasonCode.REASON_UNKNOWN;
+
+import android.content.Context;
+import android.net.wifi.SoftApConfiguration;
+import android.net.wifi.SoftApInfo;
+import android.net.wifi.WifiClient;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiManager;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.compatibility.common.util.PollingCheck;
+import com.android.wifi.flags.Flags;
+
+import com.google.android.mobly.snippet.Snippet;
+import com.google.android.mobly.snippet.event.EventCache;
+import com.google.android.mobly.snippet.event.SnippetEvent;
+import com.google.android.mobly.snippet.rpc.AsyncRpc;
+import com.google.android.mobly.snippet.rpc.Rpc;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+/** Snippet class for WifiManager. */
+public class WifiManagerSnippet implements Snippet {
+
+    private static final String TAG = "WifiManagerSnippet";
+    private static final long POLLING_TIMEOUT_MS = TimeUnit.SECONDS.toMillis(10);
+
+    private final WifiManager mWifiManager;
+    private final Handler mHandler;
+    private final Object mLock = new Object();
+
+    private WifiManagerSnippet.SnippetSoftApCallback mSoftApCallback;
+    private WifiManager.LocalOnlyHotspotReservation mLocalOnlyHotspotReservation;
+
+    /** Callback to listen in and verify events to SoftAp. */
+    private static class SnippetSoftApCallback implements WifiManager.SoftApCallback {
+        private final String mCallbackId;
+
+        SnippetSoftApCallback(String callbackId) {
+            mCallbackId = callbackId;
+        }
+
+        @Override
+        public void onConnectedClientsChanged(@NonNull SoftApInfo info,
+                @NonNull List<WifiClient> clients) {
+            Log.d(TAG, "onConnectedClientsChanged, info=" + info + ", clients=" + clients);
+            SnippetEvent event = new SnippetEvent(mCallbackId, "onConnectedClientsChanged");
+            event.getData().putInt("connectedClientsCount", clients.size());
+            String macAddress = null;
+            if (!clients.isEmpty()) {
+                // In our Mobly test cases, there is only ever one other device.
+                WifiClient client = clients.getFirst();
+                macAddress = client.getMacAddress().toString();
+            }
+            event.getData().putString("clientMacAddress", macAddress);
+            EventCache.getInstance().postEvent(event);
+        }
+
+        @Override
+        public void onClientsDisconnected(@NonNull SoftApInfo info,
+                @NonNull List<WifiClient> clients) {
+            Log.d(TAG, "onClientsDisconnected, info=" + info + ", clients=" + clients);
+            SnippetEvent event = new SnippetEvent(mCallbackId, "onClientsDisconnected");
+            event.getData().putInt("disconnectedClientsCount", clients.size());
+            String macAddress = null;
+            int disconnectReason = REASON_UNKNOWN;
+            if (!clients.isEmpty()) {
+                // In our Mobly test cases, there is only ever one other device.
+                WifiClient client = clients.getFirst();
+                macAddress = client.getMacAddress().toString();
+                disconnectReason = client.getDisconnectReason();
+            }
+            event.getData().putString("clientMacAddress", macAddress);
+            event.getData().putInt("clientDisconnectReason", disconnectReason);
+            EventCache.getInstance().postEvent(event);
+        }
+    }
+
+    /** Callback class to get the results of local hotspot start. */
+    private class SnippetLocalOnlyHotspotCallback extends WifiManager.LocalOnlyHotspotCallback {
+        private final String mCallbackId;
+
+        SnippetLocalOnlyHotspotCallback(String callbackId) {
+            mCallbackId = callbackId;
+        }
+
+        @Override
+        public void onStarted(WifiManager.LocalOnlyHotspotReservation reservation) {
+            Log.d(TAG, "Local-only hotspot onStarted");
+            synchronized (mLock) {
+                mLocalOnlyHotspotReservation = reservation;
+            }
+            SoftApConfiguration currentConfiguration = reservation.getSoftApConfiguration();
+            SnippetEvent event = new SnippetEvent(mCallbackId, "onStarted");
+            event.getData().putString("ssid",
+                    WifiJsonConverter.trimQuotationMarks(
+                            currentConfiguration.getWifiSsid().toString()));
+            event.getData()
+                    .putString(
+                            "passphrase",
+                            currentConfiguration.getPassphrase());
+            EventCache.getInstance().postEvent(event);
+        }
+    }
+
+    public WifiManagerSnippet() {
+        Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        mWifiManager = context.getSystemService(WifiManager.class);
+        HandlerThread handlerThread = new HandlerThread(getClass().getSimpleName());
+        handlerThread.start();
+        mHandler = new Handler(handlerThread.getLooper());
+    }
+
+    /**
+     * Starts local-only hotspot.
+     *
+     * @param callbackId A unique identifier assigned automatically by Mobly.
+     */
+    @AsyncRpc(description = "Call to start local-only hotspot.")
+    public void wifiStartLocalOnlyHotspot(String callbackId) {
+        mWifiManager.startLocalOnlyHotspot(new SnippetLocalOnlyHotspotCallback(callbackId),
+                mHandler);
+    }
+
+    /**
+     * Stop local-only hotspot.
+     */
+    @Rpc(description = "Call to stop local-only hotspot.")
+    public void wifiStopLocalOnlyHotspot() {
+        synchronized (mLock) {
+            if (mLocalOnlyHotspotReservation == null) {
+                Log.w(TAG, "Requested to stop local-only hotspot which was already stopped.");
+                return;
+            }
+
+            mLocalOnlyHotspotReservation.close();
+            mLocalOnlyHotspotReservation = null;
+        }
+    }
+
+    /**
+     * Registers a callback for Soft AP.
+     *
+     * @param callbackId A unique identifier assigned automatically by Mobly.
+     */
+    @AsyncRpc(description = "Call to register SoftApCallback.")
+    public void wifiRegisterSoftApCallback(String callbackId) {
+        if (mSoftApCallback == null) {
+            mSoftApCallback = new SnippetSoftApCallback(callbackId);
+            mWifiManager.registerSoftApCallback(mHandler::post, mSoftApCallback);
+        }
+    }
+
+
+    /**
+     * Registers a callback for local-only hotspot.
+     *
+     * @param callbackId A unique identifier assigned automatically by Mobly.
+     */
+    @AsyncRpc(description = "Call to register SoftApCallback for local-only hotspot.")
+    public void wifiRegisterLocalOnlyHotspotSoftApCallback(String callbackId) {
+        if (mSoftApCallback == null) {
+            mSoftApCallback = new SnippetSoftApCallback(callbackId);
+            mWifiManager.registerLocalOnlyHotspotSoftApCallback(mHandler::post,
+                    mSoftApCallback);
+        }
+    }
+
+    /**
+     * Checks if the device supports portable hotspot.
+     *
+     * @return {@code true} if the device supports portable hotspot, {@code false} otherwise.
+     */
+    @Rpc(description = "Check if the device supports portable hotspot.")
+    public boolean wifiIsPortableHotspotSupported() {
+        return mWifiManager.isPortableHotspotSupported();
+    }
+
+    /**
+     * Unregisters soft AP callback function.
+     */
+    @Rpc(description = "Unregister soft AP callback function.")
+    public void wifiUnregisterSoftApCallback() {
+        if (mSoftApCallback == null) {
+            return;
+        }
+
+        mWifiManager.unregisterSoftApCallback(mSoftApCallback);
+        mSoftApCallback = null;
+    }
+
+    /**
+     * Unregisters soft AP callback function.
+     */
+    @Rpc(description = "Unregister soft AP callback function.")
+    public void wifiUnregisterLocalOnlyHotspotSoftApCallback() {
+        if (mSoftApCallback == null) {
+            return;
+        }
+
+        mWifiManager.unregisterLocalOnlyHotspotSoftApCallback(mSoftApCallback);
+        mSoftApCallback = null;
+    }
+
+    /**
+     * Enables all saved networks.
+     */
+    @Rpc(description = "Enable all saved networks.")
+    public void wifiEnableAllSavedNetworks() {
+        for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
+            mWifiManager.enableNetwork(savedNetwork.networkId, false);
+        }
+    }
+
+    /**
+     * Disables all saved networks.
+     */
+    @Rpc(description = "Disable all saved networks.")
+    public void wifiDisableAllSavedNetworks() {
+        for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
+            mWifiManager.disableNetwork(savedNetwork.networkId);
+        }
+    }
+
+    /**
+     * Checks the softap_disconnect_reason flag.
+     *
+     * @return {@code true} if the softap_disconnect_reason flag is enabled, {@code false}
+     * otherwise.
+     */
+    @Rpc(description = "Checks SoftApDisconnectReason flag.")
+    public boolean wifiCheckSoftApDisconnectReasonFlag() {
+        return Flags.softapDisconnectReason();
+    }
+
+    /**
+     * Gets the Wi-Fi tethered AP Configuration.
+     *
+     * @return AP details in {@link SoftApConfiguration} as JSON format.
+     */
+    @Rpc(description = "Get current SoftApConfiguration.")
+    public JSONObject wifiGetSoftApConfiguration() throws JSONException {
+        return WifiJsonConverter.serialize(mWifiManager.getSoftApConfiguration());
+    }
+
+    /**
+     * Waits for tethering to be disabled.
+     *
+     * @return {@code true} if tethering is disabled within the timeout, {@code false} otherwise.
+     */
+    @Rpc(description = "Call to wait for tethering to be disabled.")
+    public boolean wifiWaitForTetheringDisabled() {
+        try {
+            PollingCheck.check("Tethering NOT disabled", POLLING_TIMEOUT_MS,
+                    () -> !mWifiManager.isWifiApEnabled());
+        } catch (Exception e) {
+            return false;
+        }
+        return true;
+    }
+}
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/Android.bp b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/Android.bp
index 6a11ceff24..c0edd5286f 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/Android.bp
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/Android.bp
@@ -19,7 +19,7 @@ package {
 
 android_test {
     name: "wifi_aware_snippet",
-    sdk_version: "current",
+    sdk_version: "system_current",
     srcs: [
         "CallbackUtils.java",
         "WifiAwareSnippet.java",
@@ -37,7 +37,7 @@ android_test {
 
 android_test {
     name: "wifi_aware_snippet_new",
-    sdk_version: "current",
+    sdk_version: "system_current",
     srcs: [
         "ConnectivityManagerSnippet.java",
         "PermissionUtils.java",
@@ -53,6 +53,7 @@ android_test {
         "compatibility-device-util-axt",
         "guava",
         "mobly-snippet-lib",
+        "mobly-bundled-snippets-lib",
     ],
-    min_sdk_version: "30",
+    min_sdk_version: "31",
 }
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/AndroidManifestNew.xml b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/AndroidManifestNew.xml
index 7dc04dffee..cf13a13964 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/AndroidManifestNew.xml
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/AndroidManifestNew.xml
@@ -1,6 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest
         xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools"
         package="com.google.snippet.wifi.aware">
     <!-- Declare the minimum Android SDK version and internet permission,
          which are required by Mobly Snippet Lib since it uses network socket. -->
@@ -20,8 +21,10 @@
              of a snippet class -->
         <meta-data
                 android:name="mobly-snippets"
+                tools:replace="android:value"
                 android:value="com.google.snippet.wifi.aware.WifiAwareManagerSnippet,
-                       com.google.snippet.wifi.aware.ConnectivityManagerSnippet,"/>
+                       com.google.snippet.wifi.aware.ConnectivityManagerSnippet,
+                       com.google.android.mobly.snippet.bundled.WifiManagerSnippet"/>
         <meta-data
                 android:name="mobly-object-converter"
                 android:value="com.google.snippet.wifi.aware.WifiAwareSnippetConverter"/>
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/ConnectivityManagerSnippet.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/ConnectivityManagerSnippet.java
index 18ec37c86c..37fa4110c5 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/ConnectivityManagerSnippet.java
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/ConnectivityManagerSnippet.java
@@ -19,6 +19,7 @@ import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.Network;
 import android.net.NetworkCapabilities;
+import android.net.LinkProperties;
 import android.net.NetworkRequest;
 import android.net.TransportInfo;
 import android.net.wifi.aware.WifiAwareChannelInfo;
@@ -40,17 +41,22 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
 import java.net.ServerSocket;
+import java.net.SocketException;
 import java.net.Socket;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.Enumeration;
 
 public class ConnectivityManagerSnippet implements Snippet {
     private static final String EVENT_KEY_CB_NAME = "callbackName";
     private static final String EVENT_KEY_NETWORK = "network";
     private static final String EVENT_KEY_NETWORK_CAP = "networkCapabilities";
+    private static final String EVENT_KEY_NETWORK_INTERFACE ="interfaceName";
     private static final String EVENT_KEY_TRANSPORT_INFO_CLASS = "transportInfoClassName";
     private static final String EVENT_KEY_TRANSPORT_INFO_CHANNEL_IN_MHZ = "channelInMhz";
     private static final int CLOSE_SOCKET_TIMEOUT = 15 * 1000;
@@ -138,12 +144,86 @@ public class ConnectivityManagerSnippet implements Snippet {
                 event.getData().putIntegerArrayList(
                     EVENT_KEY_TRANSPORT_INFO_CHANNEL_IN_MHZ, channelFrequencies
                 );
-
+                String ipv6 = newWorkInfo.getPeerIpv6Addr().toString();
+                if (ipv6.charAt(0) == '/') {
+                    ipv6 = ipv6.substring(1);
+                }
+                event.getData().putString("aware_ipv6", ipv6);
+                int port = newWorkInfo.getPort();
+                if (port != 0) {
+                    event.getData().putInt("port", port);
+                }
+                if (newWorkInfo.getTransportProtocol() != -1) {
+                    event.getData().putInt("aware_transport_protocol",
+                    newWorkInfo.getTransportProtocol());
+                }
             }
             EventCache.getInstance().postEvent(event);
         }
+
+        @Override
+        public void onLinkPropertiesChanged(Network network,
+               LinkProperties linkProperties) {
+            Log.v("NetworkCallback onLinkPropertiesChanged");
+            SnippetEvent event = new SnippetEvent(mCallBackId, "NetworkCallback");
+            event.getData().putString(EVENT_KEY_CB_NAME, "onLinkPropertiesChanged");
+            event.getData().putParcelable(EVENT_KEY_NETWORK, network);
+            event.getData().putString(EVENT_KEY_NETWORK_INTERFACE,
+                   linkProperties.getInterfaceName());
+            EventCache.getInstance().postEvent(event);
+        }
+
+        @Override
+        public void onLost(@NonNull Network network) {
+            Log.v("Network onLost");
+            SnippetEvent event = new SnippetEvent(mCallBackId, "CallbackLost");
+            event.getData().putString(EVENT_KEY_CB_NAME, "Lost");
+            event.getData().putParcelable(EVENT_KEY_NETWORK, network);
+            EventCache.getInstance().postEvent(event);
+        }
     }
 
+    private Enumeration<InetAddress> getInetAddrsForInterface(String ifaceName) {
+        NetworkInterface iface = null;
+        try {
+            iface = NetworkInterface.getByName(ifaceName);
+        } catch (SocketException e) {
+            return null;
+        }
+
+        if (iface == null)
+            return null;
+        return iface.getInetAddresses();
+    }
+    /**
+     * Returns the link local IPv6 address of the interface.
+     *
+     * @param ifaceName network interface name.
+     */
+    @Rpc(description = "Returns the link local IPv6 address of the interface.")
+    public String connectivityGetLinkLocalIpv6Address(String ifaceName) {
+        Inet6Address inet6Address = null;
+        Enumeration<InetAddress> inetAddresses = getInetAddrsForInterface(ifaceName);
+        if (inetAddresses == null) {
+            return null;
+        }
+
+        while (inetAddresses.hasMoreElements()) {
+            InetAddress addr = inetAddresses.nextElement();
+            if (addr instanceof Inet6Address) {
+                if (((Inet6Address) addr).isLinkLocalAddress()) {
+                    inet6Address = (Inet6Address) addr;
+                    break;
+                }
+            }
+        }
+
+        if (inet6Address == null) {
+            return null;
+        }
+
+        return inet6Address.getHostAddress();
+    }
     /**
      * Requests a network with the specified network request and sets a callback for network
      * events.
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareJsonDeserializer.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareJsonDeserializer.java
index a17b855418..70a0a639f6 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareJsonDeserializer.java
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareJsonDeserializer.java
@@ -55,6 +55,7 @@ public class WifiAwareJsonDeserializer {
     private static final String SUBSCRIBE_TYPE = "subscribe_type";
     private static final String TERMINATE_NOTIFICATION_ENABLED = "terminate_notification_enabled";
     private static final String MAX_DISTANCE_MM = "max_distance_mm";
+    private static final String MIN_DISTANCE_MM = "min_distance_mm";
     private static final String PAIRING_CONFIG = "pairing_config";
     private static final String TTL_SEC = "TtlSec";
     private static final String INSTANTMODE_ENABLE = "InstantModeEnabled";
@@ -95,7 +96,6 @@ public class WifiAwareJsonDeserializer {
     private static final String RANGING_REQUEST_PEER_IDS = "peer_ids";
     private static final String RANGING_REQUEST_PEER_MACS = "peer_mac_addresses";
 
-
     private WifiAwareJsonDeserializer() {
     }
 
@@ -151,6 +151,12 @@ public class WifiAwareJsonDeserializer {
                 builder.setMaxDistanceMm(maxDistanceMm);
             }
         }
+        if (jsonObject.has(MIN_DISTANCE_MM)) {
+            int minDistanceMm = jsonObject.getInt(MIN_DISTANCE_MM);
+            if (minDistanceMm >= 0) {
+                builder.setMinDistanceMm(minDistanceMm);
+            }
+        }
         if (jsonObject.has(PAIRING_CONFIG)) {
             JSONObject pairingConfigObject = jsonObject.getJSONObject(PAIRING_CONFIG);
             AwarePairingConfig pairingConfig = jsonToAwarePairingConfig(pairingConfigObject);
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareManagerSnippet.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareManagerSnippet.java
index 24804c7a0e..3cf9fffddc 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareManagerSnippet.java
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareManagerSnippet.java
@@ -16,12 +16,14 @@
 
 package com.google.snippet.wifi.aware;
 
+import android.app.UiAutomation;
 import android.Manifest;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
+import android.net.NetworkSpecifier;
 import android.net.MacAddress;
 import android.net.wifi.aware.AttachCallback;
 import android.net.wifi.aware.Characteristics;
@@ -41,12 +43,20 @@ import android.net.wifi.rtt.RangingRequest;
 import android.net.wifi.rtt.RangingResult;
 import android.net.wifi.rtt.RangingResultCallback;
 import android.net.wifi.rtt.WifiRttManager;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.HandlerThread;
+import android.text.TextUtils;
+import android.util.Base64;
+
+import android.os.RemoteException;
 
 import androidx.annotation.NonNull;
 import androidx.test.core.app.ApplicationProvider;
+import androidx.test.platform.app.InstrumentationRegistry;
 
 import com.google.android.mobly.snippet.Snippet;
 import com.google.android.mobly.snippet.event.EventCache;
@@ -56,11 +66,15 @@ import com.google.android.mobly.snippet.rpc.Rpc;
 import com.google.android.mobly.snippet.rpc.RpcOptional;
 import com.google.android.mobly.snippet.util.Log;
 
+import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
 import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
+import java.util.ListIterator;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
@@ -70,6 +84,7 @@ public class WifiAwareManagerSnippet implements Snippet {
     private final Context mContext;
     private final WifiAwareManager mWifiAwareManager;
     private final WifiRttManager mWifiRttManager;
+    private final WifiManager mWifiManager;
     private final Handler mHandler;
     // WifiAwareSession will be initialized after attach.
     private final ConcurrentHashMap<String, WifiAwareSession> mAttachSessions =
@@ -100,10 +115,38 @@ public class WifiAwareManagerSnippet implements Snippet {
         mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
         checkWifiAwareManager();
         mWifiRttManager = mContext.getSystemService(WifiRttManager.class);
+        mWifiManager = mContext.getSystemService(WifiManager.class);
         HandlerThread handlerThread = new HandlerThread("Snippet-Aware");
         handlerThread.start();
         mHandler = new Handler(handlerThread.getLooper());
     }
+    private void adoptShellPermission() throws RemoteException {
+        UiAutomation uia = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        uia.adoptShellPermissionIdentity();
+    }
+
+    private void dropShellPermission() throws RemoteException {
+        UiAutomation uia = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        uia.dropShellPermissionIdentity();
+    }
+
+    /**
+     * Returns the MAC address of the currently active access point.
+     */
+    @Rpc(description = "Returns information about the currently active access point.")
+    public String wifiGetActiveNetworkMacAddress() throws Exception {
+        WifiInfo info = null;
+        try {
+            adoptShellPermission();
+            info = mWifiManager.getConnectionInfo();
+        } catch (RemoteException e) {
+            Log.e("RemoteException message: " + e);
+        } finally {
+            // cleanup
+            dropShellPermission();
+        }
+        return info.getMacAddress();
+    }
 
     /**
      * Returns whether Wi-Fi Aware is supported.
@@ -309,6 +352,10 @@ public class WifiAwareManagerSnippet implements Snippet {
     /**
      * Checks if Wi-Fi RTT is available.
      */
+    @Rpc(description = "Check if Wi-Fi Aware is available")
+    public Boolean wifiRttIsAvailable() {
+        return mWifiRttManager.isAvailable();
+    }
     private void checkWifiRttAvailable() throws WifiAwareManagerSnippetException {
         if (!mWifiRttManager.isAvailable()) {
             throw new WifiAwareManagerSnippetException("WiFi RTT is not available now.");
@@ -661,11 +708,14 @@ public class WifiAwareManagerSnippet implements Snippet {
                     + "request"
     )
     public String wifiAwareCreateNetworkSpecifier(
-            String discoverySessionId, int peerId, boolean isAcceptAnyPeer,
+            String discoverySessionId, Integer peerId, boolean isAcceptAnyPeer,
             @RpcOptional JSONObject jsonObject
     ) throws JSONException, WifiAwareManagerSnippetException {
         DiscoverySession session = getDiscoverySession(discoverySessionId);
-        PeerHandle handle = getPeerHandler(peerId);
+        PeerHandle handle = null;
+        if (peerId != null && peerId > 0){
+            handle = getPeerHandler(peerId);
+        }
         WifiAwareNetworkSpecifier.Builder builder;
         if (isAcceptAnyPeer) {
             builder = new WifiAwareNetworkSpecifier.Builder((PublishDiscoverySession) session);
@@ -677,6 +727,48 @@ public class WifiAwareManagerSnippet implements Snippet {
         return SerializationUtil.parcelableToString(specifier);
     }
 
+    /**
+     * Creates a oob NetworkSpecifier for requesting a Wi-Fi Aware network via ConnectivityManager.
+     *
+     * @param sessionId The Id of the AwareSession session,
+     * @param role             The role of this device: AwareDatapath Role.
+     * @param macAddress    The MAC address of the peer's Aware discovery interface.
+     * @return A {@link NetworkSpecifier}  to be used to construct
+     * @throws WifiAwareManagerSnippetException if there is an error creating the network
+     *                                          specifier.
+     */
+    @Rpc(
+            description = "Create a oob network specifier to be used when specifying a Aware "
+                    + "network request"
+    )
+    public NetworkSpecifier createNetworkSpecifierOob(String sessionId, int role, String macAddress,
+        String passphrase, String pmk)
+            throws WifiAwareManagerSnippetException {
+            WifiAwareSession session = getWifiAwareSession(sessionId);
+             NetworkSpecifier specifier = null;
+            byte[] peermac = null;
+            byte[] pmkDecoded = null;
+            if (!TextUtils.isEmpty(pmk)){
+                pmkDecoded = Base64.decode(pmk, Base64.DEFAULT);
+            }
+            if (macAddress != null) {
+                peermac = MacAddress.fromString(macAddress).toByteArray();
+            }
+            if (passphrase != null && !passphrase.isEmpty()) {
+                specifier = session.createNetworkSpecifierPassphrase(role, peermac, passphrase);
+            }
+            else if (pmk != null) {
+                specifier = session.createNetworkSpecifierPmk(role, peermac, pmkDecoded);
+            }
+            else if (peermac != null){
+                specifier = session.createNetworkSpecifierOpen(role, peermac);
+            } else {
+            throw new WifiAwareManagerSnippetException(
+                "At least one of passphrase, or macAddress must be provided.");
+            }
+            return specifier;
+    }
+
     @Override
     public void shutdown() throws Exception {
         wifiAwareCloseAllWifiAwareSession();
@@ -749,6 +841,98 @@ public class WifiAwareManagerSnippet implements Snippet {
 
     }
 
+    /**
+     * Converts a JSON representation of a ScanResult to an actual ScanResult object. Mirror of
+     * the code in
+     * {@link com.googlecode.android_scripting.jsonrpc.JsonBuilder#buildJsonScanResult(ScanResult)}.
+     *
+     * @param j JSON object representing a ScanResult.
+     * @return a ScanResult object
+     * @throws JSONException on any JSON errors
+     */
+    public static ScanResult getScanResult(JSONObject j) throws JSONException {
+        if (j == null) {
+            return null;
+        }
+
+        ScanResult scanResult = new ScanResult();
+
+        if (j.has("BSSID")) {
+            scanResult.BSSID = j.getString("BSSID");
+        }
+        if (j.has("SSID")) {
+            scanResult.SSID = j.getString("SSID");
+        }
+        if (j.has("frequency")) {
+            scanResult.frequency = j.getInt("frequency");
+        }
+        if (j.has("level")) {
+            scanResult.level = j.getInt("level");
+        }
+        if (j.has("capabilities")) {
+            scanResult.capabilities = j.getString("capabilities");
+        }
+        if (j.has("timestamp")) {
+            scanResult.timestamp = j.getLong("timestamp");
+        }
+        if (j.has("centerFreq0")) {
+            scanResult.centerFreq0 = j.getInt("centerFreq0");
+        }
+        if (j.has("centerFreq1")) {
+            scanResult.centerFreq1 = j.getInt("centerFreq1");
+        }
+        if (j.has("channelWidth")) {
+            scanResult.channelWidth = j.getInt("channelWidth");
+        }
+        if (j.has("operatorFriendlyName")) {
+            scanResult.operatorFriendlyName = j.getString("operatorFriendlyName");
+        }
+        if (j.has("venueName")) {
+            scanResult.venueName = j.getString("venueName");
+        }
+
+        return scanResult;
+    }
+
+    /**
+     * Converts a JSONArray toa a list of ScanResult.
+     *
+     * @param j JSONArray representing a collection of ScanResult objects
+     * @return a list of ScanResult objects
+     * @throws JSONException on any JSON error
+     */
+    public static List<ScanResult> getScanResults(JSONArray j) throws JSONException {
+        if (j == null || j.length() == 0) {
+            return null;
+        }
+
+        ArrayList<ScanResult> scanResults = new ArrayList<>(j.length());
+        for (int i = 0; i < j.length(); ++i) {
+            scanResults.add(getScanResult(j.getJSONObject(i)));
+        }
+
+        return scanResults;
+    }
+
+    /**
+     * Starts Wi-Fi RTT ranging with Wi-Fi Aware access points.
+     *
+     * @param callbackId        Assigned automatically by mobly for all async RPCs.
+     * @param requestJsonObject The ranging request in JSONArray type for calling {@link
+     *                          android.net.wifi.ScanResult}.
+     */
+    @AsyncRpc(description = "Start ranging to an Access Points.")
+    public void wifiRttStartRangingToAccessPoints(
+            String callbackId, JSONArray requestJsonObject
+    ) throws JSONException, WifiAwareManagerSnippetException {
+        Log.v("wifiRttStartRangingToAccessPoints: " + requestJsonObject);
+        RangingRequest request = new RangingRequest.Builder().addAccessPoints(
+                            getScanResults(requestJsonObject)).build();
+        Log.v("Starting Wi-Fi RTT ranging with access point: " + request.toString());
+        RangingCallback rangingCb = new RangingCallback(eventCache, callbackId);
+        mWifiRttManager.startRanging(request, command -> mHandler.post(command), rangingCb);
+    }
+
     /**
      * Starts Wi-Fi RTT ranging with Wi-Fi Aware peers.
      *
@@ -786,7 +970,7 @@ public class WifiAwareManagerSnippet implements Snippet {
         public void onRangingFailure(int code) {
             SnippetEvent event = new SnippetEvent(mCallbackId, EVENT_NAME_RANGING_RESULT);
             event.getData().putString("callbackName", "onRangingFailure");
-            event.getData().putInt("statusCode", code);
+            event.getData().putInt("status", code);
             mEventCache.postEvent(event);
         }
 
@@ -800,8 +984,20 @@ public class WifiAwareManagerSnippet implements Snippet {
                 RangingResult result = results.get(i);
                 resultBundles[i] = new Bundle();
                 resultBundles[i].putInt("status", result.getStatus());
-                resultBundles[i].putInt("distanceMm", result.getDistanceMm());
-                resultBundles[i].putInt("rssi", result.getRssi());
+                if (result.getStatus() == RangingResult.STATUS_SUCCESS) {
+                    resultBundles[i].putInt("distanceMm", result.getDistanceMm());
+                    resultBundles[i].putInt("rssi", result.getRssi());
+                    resultBundles[i].putInt("distanceStdDevMm", result.getDistanceStdDevMm());
+                    resultBundles[i].putInt(
+                        "numAttemptedMeasurements",
+                        result.getNumAttemptedMeasurements());
+                    resultBundles[i].putInt(
+                        "numSuccessfulMeasurements",
+                        result.getNumSuccessfulMeasurements());
+                    resultBundles[i].putByteArray("lci", result.getLci());
+                    resultBundles[i].putByteArray("lcr", result.getLcr());
+                    resultBundles[i].putLong("timestamp", result.getRangingTimestampMillis());
+                }
                 PeerHandle peer = result.getPeerHandle();
                 if (peer != null) {
                     resultBundles[i].putInt("peerId", peer.hashCode());
@@ -810,6 +1006,8 @@ public class WifiAwareManagerSnippet implements Snippet {
                 }
                 MacAddress mac = result.getMacAddress();
                 resultBundles[i].putString("mac", mac != null ? mac.toString() : null);
+                resultBundles[i].putString("macAsString",
+                    mac != null ? result.getMacAddress().toString() : null);
             }
             event.getData().putParcelableArray("results", resultBundles);
             mEventCache.postEvent(event);
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareSnippetConverter.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareSnippetConverter.java
index 7fdb388cec..edcfeac0ca 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareSnippetConverter.java
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/aware/WifiAwareSnippetConverter.java
@@ -19,13 +19,17 @@ package com.google.snippet.wifi.aware;
 import android.net.NetworkRequest;
 import android.net.wifi.aware.PublishConfig;
 import android.net.wifi.aware.SubscribeConfig;
+import android.net.wifi.ScanResult;
+import android.net.wifi.aware.WifiAwareNetworkSpecifier;
 
 import com.google.android.mobly.snippet.SnippetObjectConverter;
+import com.google.android.mobly.snippet.util.Log;
 
 import org.json.JSONException;
 import org.json.JSONObject;
 
 import java.lang.reflect.Type;
+import java.util.List;
 
 /**
  * The converter class that allows users to use custom type as snippet RPC arguments and return
@@ -33,15 +37,52 @@ import java.lang.reflect.Type;
  */
 public class WifiAwareSnippetConverter implements SnippetObjectConverter {
 
+
+    public static String trimQuotationMarks(String originalString) {
+        String result = originalString;
+        if (originalString == null)
+            return result;
+        if (originalString.length() > 2
+                && originalString.charAt(0) == '"'
+                && originalString.charAt(originalString.length() - 1) == '"') {
+            result = originalString.substring(1, originalString.length() - 1);
+        }
+        return result;
+    }
+
     @Override
     public JSONObject serialize(Object object) throws JSONException {
         // If the RPC method requires a custom return type, e.g. SubscribeConfig, PublishConfig, we
         // need to define it here.
         // If the object type is not recognized, you can throw an exception or return null
         // depending on your application's needs.
+        JSONObject result = new JSONObject();
+        if (object instanceof WifiAwareNetworkSpecifier) {
+            WifiAwareNetworkSpecifier frame = (WifiAwareNetworkSpecifier) object;
+            result.put("result", SerializationUtil.parcelableToString(frame));
+            return result;
+        }
         return null;
     }
 
+    public static JSONObject serializeScanResult(ScanResult data) throws JSONException {
+        JSONObject result = new JSONObject();
+        result.put("BSSID", data.BSSID);
+        result.put("SSID", trimQuotationMarks(data.getWifiSsid().toString()));
+        result.put("capabilities", data.capabilities);
+        result.put("centerFreq0", data.centerFreq0);
+        result.put("centerFreq1", data.centerFreq1);
+        result.put("channelWidth", data.channelWidth);
+        result.put("frequency", data.frequency);
+        result.put("level", data.level);
+        result.put("operatorFriendlyName",
+            (data.operatorFriendlyName != null) ? data.operatorFriendlyName.toString() : "");
+        result.put("timestamp", data.timestamp);
+        result.put("venueName", (data.venueName != null) ? data.venueName.toString() : "");
+        result.put("scan_result_parcel", SerializationUtil.parcelableToString(data));
+        return result;
+    }
+
     @Override
     public Object deserialize(JSONObject jsonObject, Type type) throws JSONException {
         // The parameters of Mobly RPC directly reference the Object type.
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/JsonDeserializer.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/JsonDeserializer.java
index 3d91054b3a..f8fdf3b7a0 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/JsonDeserializer.java
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/JsonDeserializer.java
@@ -33,7 +33,13 @@ public class JsonDeserializer {
     private static final String NETWORK_NAME = "network_name";
     private static final String PASSPHRASE = "passphrase";
 
-    /** Converts Python dict to android.net.wifi.p2p.WifiP2pConfig. */
+    /**
+     * Converts Python dict to {@link WifiP2pConfig}.
+     *
+     * @param jsonObject Python dict representing {@link WifiP2pConfig}.
+     * @return {@link WifiP2pConfig}.
+     * @throws JSONException if the JSON object is malformed.
+     */
     public static WifiP2pConfig jsonToWifiP2pConfig(JSONObject jsonObject) throws JSONException {
         if (jsonObject.has("wps_setup")) {
             // Create WifiP2pConfig directly.
@@ -55,7 +61,8 @@ public class JsonDeserializer {
         }
         if (jsonObject.has(GROUP_CLIENT_IP_PROVISIONING_MODE)) {
             builder.setGroupClientIpProvisioningMode(
-                    jsonObject.getInt(GROUP_CLIENT_IP_PROVISIONING_MODE));
+                    jsonObject.getInt(GROUP_CLIENT_IP_PROVISIONING_MODE)
+            );
         }
         if (jsonObject.has(GROUP_OPERATING_BAND)) {
             builder.setGroupOperatingBand(jsonObject.getInt(GROUP_OPERATING_BAND));
@@ -71,4 +78,5 @@ public class JsonDeserializer {
         }
         return builder.build();
     }
+
 }
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/WifiDirectSnippet.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/WifiDirectSnippet.java
index 8aad73e326..81a751cefa 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/WifiDirectSnippet.java
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/WifiDirectSnippet.java
@@ -41,6 +41,9 @@ import com.google.android.mobly.snippet.rpc.Rpc;
 
 import org.json.JSONException;
 
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
 public class WifiDirectSnippet implements Snippet {
 
     private static final String TAG = "WifiDirectSnippet";
@@ -110,17 +113,25 @@ public class WifiDirectSnippet implements Snippet {
 
     class WifiP2pActionListener implements WifiP2pManager.ActionListener {
         private final String mOperation;
+        private final CountDownLatch mCountDownLatch;
         WifiP2pActionListener(String action) {
+            mCountDownLatch = new CountDownLatch(1);
             mOperation = action;
         }
 
+        public void await() throws InterruptedException {
+            mCountDownLatch.await(1000, TimeUnit.MILLISECONDS);
+        }
+
         @Override
         public void onSuccess() {
             Log.d(TAG, mOperation + " OnSuccess");
+            mCountDownLatch.countDown();
         }
         @Override
         public void onFailure(int reason) {
             Log.d(TAG, mOperation + " onFailure - reason: " + reason);
+            mCountDownLatch.countDown();
         }
     }
 
@@ -174,6 +185,13 @@ public class WifiDirectSnippet implements Snippet {
     @Rpc(description = "Close P2P channel")
     public void closeP2p() throws JSONException {
         if (mChannel != null) {
+            try {
+                WifiP2pActionListener actionListener = new WifiP2pActionListener("RemoveGroup");
+                mP2pManager.removeGroup(mChannel, actionListener);
+                actionListener.await();
+            } catch (InterruptedException e) {
+                Log.d(TAG, "RemoveGroup request failed");
+            }
             mChannel.close();
             mChannel = null;
             Log.d(TAG, "Wifi Direct close called");
@@ -189,9 +207,15 @@ public class WifiDirectSnippet implements Snippet {
             Log.d(TAG, "p2pCreateGroup failed -should call initializeP2p first ");
             return false;
         }
+        WifiP2pActionListener actionListener = new WifiP2pActionListener("CreateGroup");
         WifiP2pConfig wifiP2pConfig = buildWifiP2pConfig(networkName, passphrase, frequency);
-        mP2pManager.createGroup(mChannel, wifiP2pConfig,
-                new WifiP2pActionListener("CreateGroup"));
+        try {
+            mP2pManager.createGroup(mChannel, wifiP2pConfig, actionListener);
+            actionListener.await();
+        } catch (InterruptedException e) {
+            Log.d(TAG, "p2pCreateGroup request failed");
+            return false;
+        }
         Log.d(TAG, "p2pCreateGroup succeeded");
         return true;
     }
@@ -203,10 +227,16 @@ public class WifiDirectSnippet implements Snippet {
             Log.d(TAG, "p2pConnect failed- should call initializeP2p first");
             return -1;
         }
+        WifiP2pActionListener actionListener = new WifiP2pActionListener("Connect");
         WifiP2pConfig wifiP2pConfig = buildWifiP2pConfig(networkName, passphrase, frequency);
         long startTime = System.currentTimeMillis();
-        mP2pManager.connect(mChannel, wifiP2pConfig,
-                new WifiP2pActionListener("Connect"));
+        try {
+            mP2pManager.connect(mChannel, wifiP2pConfig, actionListener);
+            actionListener.await();
+        } catch (InterruptedException e) {
+            Log.d(TAG, "p2pConnect request failed");
+            return -1;
+        }
 
         synchronized (mLock) {
             mLock.wait(5000);
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/WifiP2pManagerSnippet.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/WifiP2pManagerSnippet.java
index 10480c453d..3bf57c246a 100644
--- a/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/WifiP2pManagerSnippet.java
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/direct/WifiP2pManagerSnippet.java
@@ -24,12 +24,19 @@ import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
 import android.net.NetworkInfo;
+import android.net.wifi.p2p.WifiP2pConfig;
 import android.net.wifi.p2p.WifiP2pDevice;
 import android.net.wifi.p2p.WifiP2pDeviceList;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pGroupList;
 import android.net.wifi.p2p.WifiP2pInfo;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceRequest;
+import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pServiceRequest;
+import android.net.wifi.p2p.nsd.WifiP2pUpnpServiceInfo;
+import android.net.wifi.p2p.nsd.WifiP2pUpnpServiceRequest;
 import android.os.Bundle;
 import android.widget.Button;
 
@@ -46,12 +53,19 @@ import com.google.android.mobly.snippet.event.EventCache;
 import com.google.android.mobly.snippet.event.SnippetEvent;
 import com.google.android.mobly.snippet.rpc.AsyncRpc;
 import com.google.android.mobly.snippet.rpc.Rpc;
+import com.google.android.mobly.snippet.rpc.RpcDefault;
 import com.google.android.mobly.snippet.rpc.RpcOptional;
 import com.google.android.mobly.snippet.util.Log;
 
+import org.json.JSONArray;
 import org.json.JSONObject;
 
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
 import java.util.UUID;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.TimeUnit;
@@ -61,6 +75,7 @@ import java.util.regex.Pattern;
 
 /** Snippet class for WifiP2pManager. */
 public class WifiP2pManagerSnippet implements Snippet {
+    private static final String TAG = "WifiP2pManagerSnippet";
     private static final int TIMEOUT_SHORT_MS = 10000;
     private static final int UI_ACTION_SHORT_TIMEOUT_MS = 5000;
     private static final int UI_ACTION_LONG_TIMEOUT_MS = 30000;
@@ -70,6 +85,13 @@ public class WifiP2pManagerSnippet implements Snippet {
     private static final String EVENT_KEY_P2P_INFO = "p2pInfo";
     private static final String EVENT_KEY_P2P_GROUP = "p2pGroup";
     private static final String EVENT_KEY_PEER_LIST = "peerList";
+    private static final String EVENT_KEY_SERVICE_LIST = "serviceList";
+    private static final String EVENT_KEY_INSTANCE_NAME = "instanceName";
+    private static final String EVENT_KEY_REGISTRATION_TYPE = "registrationType";
+    private static final String EVENT_KEY_SOURCE_DEVICE = "sourceDevice";
+    private static final String EVENT_KEY_FULL_DOMAIN_NAME = "fullDomainName";
+    private static final String EVENT_KEY_TXT_RECORD_MAP = "txtRecordMap";
+    private static final String EVENT_KEY_TIMESTAMP_MS = "timestampMs";
     private static final String ACTION_LISTENER_ON_SUCCESS = "onSuccess";
     public static final String ACTION_LISTENER_ON_FAILURE = "onFailure";
 
@@ -77,13 +99,17 @@ public class WifiP2pManagerSnippet implements Snippet {
     private final IntentFilter mIntentFilter;
     private final WifiP2pManager mP2pManager;
 
-    private Instrumentation mInstrumentation =
-            InstrumentationRegistry.getInstrumentation();
+    private Instrumentation mInstrumentation = InstrumentationRegistry.getInstrumentation();
     private UiDevice mUiDevice = UiDevice.getInstance(mInstrumentation);
 
-    private WifiP2pManager.Channel mChannel = null;
+    private final HashMap<Integer, WifiP2pManager.Channel> mChannels = new HashMap<>();
     private WifiP2pStateChangedReceiver mStateChangedReceiver = null;
 
+    private int mServiceRequestCnt = 0;
+    private int mChannelCnt = -1;
+
+    private final Map<Integer, WifiP2pServiceRequest> mServiceRequests;
+
 
     private static class WifiP2pManagerException extends Exception {
         WifiP2pManagerException(String message) {
@@ -100,8 +126,7 @@ public class WifiP2pManagerSnippet implements Snippet {
 
         checkPermissions(mContext, Manifest.permission.ACCESS_WIFI_STATE,
                 Manifest.permission.CHANGE_WIFI_STATE, Manifest.permission.ACCESS_FINE_LOCATION,
-                Manifest.permission.NEARBY_WIFI_DEVICES
-        );
+                Manifest.permission.NEARBY_WIFI_DEVICES);
 
         mP2pManager = mContext.getSystemService(WifiP2pManager.class);
 
@@ -111,107 +136,200 @@ public class WifiP2pManagerSnippet implements Snippet {
         mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
         mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
 
+        mServiceRequests = new HashMap<Integer, WifiP2pServiceRequest>();
     }
 
-    /** Register the application with the Wi-Fi framework. */
+    /**
+     * Initialize the application with the Wi-Fi P2P framework and registers necessary receivers.
+     *
+     * @param callbackId The callback ID assigned by Mobly
+     * @return The ID of the initialized channel. Use this ID to specify which channel to
+     *         operate on in future operations.
+     * @throws WifiP2pManagerException If the Wi-Fi P2P has already been initialized.
+     */
     @AsyncRpc(description = "Register the application with the Wi-Fi framework.")
-    public void wifiP2pInitialize(String callbackId) throws WifiP2pManagerException {
-        if (mChannel != null) {
-            throw new WifiP2pManagerException(
-                    "Channel has already created, please close current section before initliaze a "
-                            + "new one.");
-
+    public int wifiP2pInitialize(String callbackId) throws WifiP2pManagerException {
+        if (mStateChangedReceiver != null) {
+            throw new WifiP2pManagerException("WifiP2pManager has already been initialized. "
+                    + "Please call `p2pClose()` close the current connection.");
+        }
+        if (mChannelCnt != -1) {
+            throw new WifiP2pManagerException("Please call `p2pClose()` to close the current "
+                    + "connection before initializing a new one.");
         }
         checkP2pManager();
+        // Initialize the first channel. This channel will be used by default if an Wi-Fi P2P RPC
+        // method is called without a channel ID.
         mStateChangedReceiver = new WifiP2pStateChangedReceiver(callbackId);
-        mContext.registerReceiver(
-                mStateChangedReceiver, mIntentFilter, Context.RECEIVER_NOT_EXPORTED);
-        mChannel = mP2pManager.initialize(mContext, mContext.getMainLooper(), null);
+        mContext.registerReceiver(mStateChangedReceiver, mIntentFilter,
+                Context.RECEIVER_NOT_EXPORTED);
+        WifiP2pManager.Channel channel =
+                mP2pManager.initialize(mContext, mContext.getMainLooper(), null);
+        mChannelCnt += 1;
+        mChannels.put(mChannelCnt, channel);
+        return mChannelCnt;
+    }
+
+    /**
+     * Initialize an extra Wi-Fi P2P channel. This is for multi-channel tests.
+     *
+     * @return The id of the new channel.
+     */
+    @Rpc(description = "Initialize an extra Wi-Fi P2P channel. This is needed when you need to "
+            + "test with multiple channels.")
+    public int wifiP2pInitExtraChannel() {
+        if (mChannelCnt == -1) {
+            throw new IllegalStateException("Main channel has not been initialized. Please call "
+                    + "`wifiP2pInitialize` first.");
+        }
+        WifiP2pManager.Channel channel =
+                mP2pManager.initialize(mContext, mContext.getMainLooper(), null);
+        mChannelCnt += 1;
+        mChannels.put(mChannelCnt, channel);
+        return mChannelCnt;
     }
 
-    /** Request the device information in the form of WifiP2pDevice. */
+    /**
+     * Request the device information in the form of WifiP2pDevice.
+     *
+     * @param callbackId The callback ID assigned by Mobly.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws WifiP2pManagerException If got invalid channel ID.
+     */
     @AsyncRpc(description = "Request the device information in the form of WifiP2pDevice.")
-    public void wifiP2pRequestDeviceInfo(String callbackId) throws WifiP2pManagerException {
-        checkChannel();
-        mP2pManager.requestDeviceInfo(mChannel, new DeviceInfoListener(callbackId));
+    public void wifiP2pRequestDeviceInfo(String callbackId,
+            @RpcDefault(value = "0") Integer channelId)
+            throws WifiP2pManagerException {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        mP2pManager.requestDeviceInfo(channel, new DeviceInfoListener(callbackId));
+    }
+
+    /**
+     * Request the connection information in the form of WifiP2pDevice.
+     *
+     * @param callbackId The callback ID assigned by Mobly.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     */
+    @AsyncRpc(description = "Request the connection information in the form of WifiP2pDevice.")
+    public void wifiP2pRequestConnectionInfo(String callbackId,
+            @RpcDefault(value = "0") Integer channelId)
+            throws WifiP2pManagerException {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        mP2pManager.requestConnectionInfo(channel,
+            new WifiP2pConnectionInfoListener(callbackId));
     }
 
     /**
      * Initiate peer discovery. A discovery process involves scanning for available Wi-Fi peers for
      * the purpose of establishing a connection.
      *
-     * @throws Throwable If this failed to initiate discovery, or the action timed out.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If the P2P operation failed or timed out, or got invalid channel ID.
      */
-    @Rpc(
-            description = "Initiate peer discovery. A discovery process involves scanning for "
-                    + "available Wi-Fi peers for the purpose of establishing a connection.")
-    public void wifiP2pDiscoverPeers() throws Throwable {
-        checkChannel();
+    @Rpc(description = "Initiate peer discovery. A discovery process involves scanning for "
+            + "available Wi-Fi peers for the purpose of establishing a connection.")
+    public void wifiP2pDiscoverPeers(@RpcDefault(value = "0") Integer channelId) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
         String callbackId = UUID.randomUUID().toString();
-        mP2pManager.discoverPeers(mChannel, new ActionListener(callbackId));
+        mP2pManager.discoverPeers(channel, new ActionListener(callbackId));
         verifyActionListenerSucceed(callbackId);
     }
 
+    /**
+     * Request peers that are discovered for wifi p2p.
+     *
+     * @param callbackId The callback ID assigned by Mobly.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If the P2P operation failed or timed out, or got invalid channel ID.
+     */
+    @AsyncRpc(description = "Request peers that are discovered for wifi p2p.")
+    public void wifiP2pRequestPeers(String callbackId, @RpcDefault(value = "0") Integer channelId)
+            throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        mP2pManager.requestPeers(channel, new PeerListListener(callbackId));
+    }
+
     /**
      * Cancel any ongoing p2p group negotiation.
      *
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
      * @return The event posted by the callback methods of {@link ActionListener}.
+     * @throws Throwable If the P2P operation failed or timed out, or got invalid channel ID.
      */
     @Rpc(description = "Cancel any ongoing p2p group negotiation.")
-    public Bundle wifiP2pCancelConnect() throws Throwable {
-        checkChannel();
+    public Bundle wifiP2pCancelConnect(@RpcDefault(value = "0") Integer channelId)
+            throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
         String callbackId = UUID.randomUUID().toString();
-        mP2pManager.cancelConnect(mChannel, new ActionListener((callbackId)));
+        mP2pManager.cancelConnect(channel, new ActionListener((callbackId)));
         return waitActionListenerResult(callbackId);
     }
 
     /**
      * Stop current ongoing peer discovery.
      *
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
      * @return The event posted by the callback methods of {@link ActionListener}.
+     * @throws Throwable If the P2P operation failed or timed out, or got invalid channel ID.
      */
     @Rpc(description = "Stop current ongoing peer discovery.")
-    public Bundle wifiP2pStopPeerDiscovery() throws Throwable {
-        checkChannel();
+    public Bundle wifiP2pStopPeerDiscovery(@RpcDefault(value = "0") Integer channelId)
+            throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
         String callbackId = UUID.randomUUID().toString();
-        mP2pManager.stopPeerDiscovery(mChannel, new ActionListener(callbackId));
+        mP2pManager.stopPeerDiscovery(channel, new ActionListener(callbackId));
         return waitActionListenerResult(callbackId);
     }
 
     /**
      * Create a p2p group with the current device as the group owner.
      *
-     * @throws Throwable If this failed to initiate discovery, or the action timed out.
+     * @param  wifiP2pConfig The configuration for the p2p group.
+     * @param  channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If the P2P operation failed or timed out, or got invalid channel ID.
      */
-    @AsyncRpc(description = "Create a p2p group with the current device as the group owner.")
-    public void wifiP2pCreateGroup(String callbackId, @RpcOptional JSONObject wifiP2pConfig)
-            throws Throwable {
-        checkChannel();
+    @Rpc(description = "Create a p2p group with the current device as the group owner.")
+    public void wifiP2pCreateGroup(
+            @RpcOptional JSONObject wifiP2pConfig,
+            @RpcDefault(value = "0") Integer channelId
+    ) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        String callbackId = UUID.randomUUID().toString();
         ActionListener actionListener = new ActionListener(callbackId);
-        if (wifiP2pConfig == null) {
-            mP2pManager.createGroup(mChannel, actionListener);
-        } else {
-            mP2pManager.createGroup(
-                    mChannel, JsonDeserializer.jsonToWifiP2pConfig(wifiP2pConfig), actionListener);
+        WifiP2pConfig config = null;
+        if (wifiP2pConfig != null) {
+            config = JsonDeserializer.jsonToWifiP2pConfig(wifiP2pConfig);
         }
+        Log.d("Creating wifi p2p group with config: " + String.valueOf(config));
+        mP2pManager.createGroup(channel, config, actionListener);
         verifyActionListenerSucceed(callbackId);
     }
 
     /**
      * Start a p2p connection to a device with the specified configuration.
      *
-     * @throws Throwable If this failed to initiate discovery, or the action timed out.
+     * @param wifiP2pConfig The configuration for the p2p connection.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If the P2P operation failed or timed out, or got invalid channel ID.
      */
     @Rpc(description = "Start a p2p connection to a device with the specified configuration.")
-    public void wifiP2pConnect(JSONObject wifiP2pConfig) throws Throwable {
-        checkChannel();
+    public void wifiP2pConnect(
+            JSONObject wifiP2pConfig,
+            @RpcDefault(value = "0") Integer channelId) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
         String callbackId = UUID.randomUUID().toString();
-        mP2pManager.connect(mChannel, JsonDeserializer.jsonToWifiP2pConfig(wifiP2pConfig),
-                new ActionListener(callbackId));
+        WifiP2pConfig config = JsonDeserializer.jsonToWifiP2pConfig(wifiP2pConfig);
+        Log.d("Connecting p2p group with config: " + String.valueOf(config));
+        mP2pManager.connect(channel, config, new ActionListener(callbackId));
         verifyActionListenerSucceed(callbackId);
     }
 
-    /** Accept p2p connection invitation through clicking on UI. */
+    /**
+     * Accept p2p connection invitation through clicking on UI.
+     *
+     * @param deviceName The name of the device to connect.
+     * @throws WifiP2pManagerException If failed to accept invitation through UI.
+     */
     @Rpc(description = "Accept p2p connection invitation through clicking on UI.")
     public void wifiP2pAcceptInvitation(String deviceName) throws WifiP2pManagerException {
         if (!mUiDevice.wait(Until.hasObject(By.text("Invitation to connect")),
@@ -236,55 +354,503 @@ public class WifiP2pManagerSnippet implements Snippet {
         acceptButton.click();
     }
 
+    /**
+     * Get p2p connect PIN code after calling {@link #wifiP2pConnect(JSONObject,Integer)} with
+     * WPS PIN.
+     *
+     * @param deviceName The name of the device to connect.
+     * @return The generated PIN as a String.
+     * @throws Throwable If failed to get PIN code.
+     */
+    @Rpc(description = "Get p2p connect PIN code after calling wifiP2pConnect with WPS PIN.")
+    public String wifiP2pGetPinCode(String deviceName) throws Throwable {
+        // Wait for the 'Invitation sent' dialog to appear
+        if (!mUiDevice.wait(Until.hasObject(By.text("Invitation sent")),
+                UI_ACTION_LONG_TIMEOUT_MS)) {
+            throw new WifiP2pManagerException(
+                    "Invitation sent dialog did not appear within timeout.");
+        }
+        if (!mUiDevice.wait(Until.hasObject(By.text(deviceName)), UI_ACTION_SHORT_TIMEOUT_MS)) {
+            throw new WifiP2pManagerException(
+                    "The connect invitation is not triggered by expected peer device.");
+        }
+        // Find the UI lement with text='PIN:'
+        UiObject2 pinLabel = mUiDevice.findObject(By.text("PIN:"));
+        if (pinLabel == null) {
+            throw new WifiP2pManagerException("PIN label not found.");
+        }
+        // Get the sibling UI element that contains the PIN code. Use regex pattern "\d+" as PIN
+        // code must be composed entirely of numbers.
+        Pattern pattern = Pattern.compile("\\d+");
+        UiObject2 pinValue = pinLabel.getParent().findObject(By.text(pattern));
+        if (pinValue == null) {
+            throw new WifiP2pManagerException("Failed to find Pin code UI element.");
+        }
+        String pinCode = pinValue.getText();
+        Log.d("Retrieved PIN code: " + pinCode);
+        // Click 'OK' to close the PIN code alert
+        UiObject2 okButton = mUiDevice.findObject(By.text("OK").clazz(Button.class));
+        if (okButton == null) {
+            throw new WifiP2pManagerException(
+                    "OK button not found in the p2p connection invitation pop-up window.");
+        }
+        okButton.click();
+        Log.d("Closed the p2p connect invitation pop-up window.");
+        return pinCode;
+    }
+
+    /**
+     * Get p2p connect PIN code after calling {@link #wifiP2pConnect(JSONObject,Integer)} with
+     * WPS PIN.
+     *
+     * @param deviceName The name of the device to connect.
+     * @return The generated PIN as a String.
+     * @throws Throwable If failed to get PIN code.
+     */
+    @Rpc(description = "Get p2p connect PIN code after calling wifiP2pConnect with WPS PIN.")
+    public String wifiP2pGetKeypadPinCode(String deviceName) throws Throwable {
+        // Wait for the 'Invitation sent' dialog to appear
+        if (!mUiDevice.wait(Until.hasObject(By.text("Invitation to connect")),
+                UI_ACTION_LONG_TIMEOUT_MS)) {
+            throw new WifiP2pManagerException(
+                    "Invitation sent dialog did not appear within timeout.");
+        }
+        if (!mUiDevice.wait(Until.hasObject(By.text(deviceName)), UI_ACTION_SHORT_TIMEOUT_MS)) {
+            throw new WifiP2pManagerException(
+                    "The connect invitation is not triggered by expected peer device.");
+        }
+        // Find the UI lement with text='PIN:'
+        UiObject2 pinLabel = mUiDevice.findObject(By.text("PIN:"));
+        if (pinLabel == null) {
+            throw new WifiP2pManagerException("PIN label not found.");
+        }
+        Log.d("pinLabel = " + pinLabel);
+        // Get the sibling UI element that contains the PIN code. Use regex pattern "\d+" as PIN
+        // code must be composed entirely of numbers.
+        Pattern pattern = Pattern.compile("\\d+");
+        UiObject2 pinValue = pinLabel.getParent().findObject(By.text(pattern));
+        if (pinValue == null) {
+            throw new WifiP2pManagerException("Failed to find Pin code UI element.");
+        }
+        String pinCode = pinValue.getText();
+        Log.d("Retrieved PIN code: " + pinCode);
+        // Click 'OK' to close the PIN code alert
+        UiObject2 okButton = mUiDevice.findObject(By.text("Accept").clazz(Button.class));
+        if (okButton == null) {
+            throw new WifiP2pManagerException(
+                    "OK button not found in the p2p connection invitation pop-up window.");
+        }
+        okButton.click();
+        Log.d("Closed the p2p connect invitation pop-up window.");
+        return pinCode;
+    }
+
+    /**
+     * Enters the given PIN code to accept a P2P connection invitation.
+     *
+     * @param pinCode    The PIN to enter.
+     * @param deviceName The name of the device that initiated the connection.
+     * @throws WifiP2pManagerException If the PIN entry field is not found within timeout.
+     */
+    @Rpc(description = "Enter the PIN code to accept a P2P connection invitation.")
+    public void wifiP2pEnterPin(String pinCode, String deviceName) throws WifiP2pManagerException {
+        // Wait for the 'Invitation to connect' dialog to appear
+        if (!mUiDevice.wait(Until.hasObject(By.textContains("Invitation to connect")),
+                UI_ACTION_LONG_TIMEOUT_MS)) {
+            throw new WifiP2pManagerException(
+                    "Invitation to connect dialog did not appear within timeout.");
+        }
+        if (!mUiDevice.wait(Until.hasObject(By.text(deviceName)), UI_ACTION_SHORT_TIMEOUT_MS)) {
+            throw new WifiP2pManagerException(
+                    "The connect invitation is not triggered by expected peer device.");
+        }
+        // Find the PIN entry field
+        UiObject2 pinEntryField = mUiDevice.findObject(By.focused(true));
+        if (pinEntryField == null) {
+            throw new WifiP2pManagerException("PIN entry field not found.");
+        }
+        // Enter the PIN code
+        pinEntryField.setText(pinCode);
+        Log.d("Entered PIN code: " + pinCode);
+        // Accept the invitation
+        Pattern acceptPattern = Pattern.compile("(ACCEPT|OK|Accept)", Pattern.CASE_INSENSITIVE);
+        UiObject2 acceptButton = mUiDevice.findObject(By.clazz(Button.class).text(acceptPattern));
+        if (acceptButton == null) {
+            throw new WifiP2pManagerException(
+                    "Failed to find accept button for p2p connect invitation.");
+        }
+        acceptButton.click();
+        Log.d("Accepted the connection.");
+    }
+
     /**
      * Remove the current p2p group.
      *
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
      * @return The event posted by the callback methods of {@link ActionListener}.
+     * @throws Throwable If the P2P operation failed or timed out, or got invalid channel ID.
      */
     @Rpc(description = "Remove the current p2p group.")
-    public Bundle wifiP2pRemoveGroup() throws Throwable {
-        checkChannel();
+    public Bundle wifiP2pRemoveGroup(@RpcDefault(value = "0") Integer channelId) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
         String callbackId = UUID.randomUUID().toString();
-        mP2pManager.removeGroup(mChannel, new ActionListener(callbackId));
+        mP2pManager.removeGroup(channel, new ActionListener(callbackId));
         return waitActionListenerResult(callbackId);
     }
 
-    /** Request the number of persistent p2p group. */
+    /**
+     * Request the number of persistent p2p group.
+     *
+     * @param callbackId The callback ID assigned by Mobly.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If this failed to request persistent group info, or got invalid channel ID.
+     */
     @AsyncRpc(description = "Request the number of persistent p2p group")
-    public void wifiP2pRequestPersistentGroupInfo(String callbackId) throws Throwable {
-        checkChannel();
-        mP2pManager.requestPersistentGroupInfo(
-                mChannel, new PersistentGroupInfoListener(callbackId));
+    public void wifiP2pRequestPersistentGroupInfo(
+            String callbackId,
+            @RpcDefault(value = "0") Integer channelId) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        mP2pManager.requestPersistentGroupInfo(channel,
+                new PersistentGroupInfoListener(callbackId));
     }
 
     /**
      * Delete the persistent p2p group with the given network ID.
      *
+     * @param networkId The network ID of the persistent p2p group to delete.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
      * @return The event posted by the callback methods of {@link ActionListener}.
+     * @throws Throwable If this failed to delete persistent group, or got invalid channel ID.
      */
     @Rpc(description = "Delete the persistent p2p group with the given network ID.")
-    public Bundle wifiP2pDeletePersistentGroup(int networkId) throws Throwable {
-        checkChannel();
+    public Bundle wifiP2pDeletePersistentGroup(int networkId,
+            @RpcDefault(value = "0") Integer channelId) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
         String callbackId = UUID.randomUUID().toString();
-        mP2pManager.deletePersistentGroup(mChannel, networkId, new ActionListener(callbackId));
+        mP2pManager.deletePersistentGroup(channel, networkId, new ActionListener(callbackId));
         return waitActionListenerResult(callbackId);
     }
 
+    /**
+     * Register Upnp service as a local Wi-Fi p2p service for service discovery.
+     * @param uuid The UUID to be passed to
+     *     {@link WifiP2pUpnpServiceInfo#newInstance(String, String, List)}.
+     * @param device The device to be passed to
+     *     {@link WifiP2pUpnpServiceInfo#newInstance(String, String, List)}.
+     * @param services The services to be passed to
+     *     {@link WifiP2pUpnpServiceInfo#newInstance(String, String, List)}.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If failed to add local service or got invalid channel ID.
+     */
+    @Rpc(description = "Register Upnp service as a local Wi-Fi p2p service for service discovery.")
+    public void wifiP2pAddUpnpLocalService(
+            String uuid,
+            String device,
+            JSONArray services,
+            @RpcDefault(value = "0"
+            ) Integer channelId) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        List<String> serviceList = new ArrayList<String>();
+        for (int i = 0; i < services.length(); i++) {
+            serviceList.add(services.getString(i));
+            Log.d("wifiP2pAddUpnpLocalService, services: " + services.getString(i));
+        }
+        WifiP2pServiceInfo serviceInfo =
+                WifiP2pUpnpServiceInfo.newInstance(uuid, device, serviceList);
+
+        String callbackId = UUID.randomUUID().toString();
+        mP2pManager.addLocalService(channel, serviceInfo, new ActionListener(callbackId));
+        verifyActionListenerSucceed(callbackId);
+    }
+
+    /**
+     * Register Bonjour service as a local Wi-Fi p2p service for service discovery.
+     *
+     * @param instanceName The instance name to be passed to
+     *     {@link WifiP2pDnsSdServiceInfo#newInstance(String, String, Map)}.
+     * @param serviceType The serviceType to be passed to
+     *     {@link WifiP2pDnsSdServiceInfo#newInstance(String, String, Map)}.
+     * @param txtMap The TXT record to be passed to
+     *     {@link WifiP2pDnsSdServiceInfo#newInstance(String, String, Map)}.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If failed to add local service or got invalid channel ID.
+     */
+    @Rpc(description = "Register Bonjour service as a local Wi-Fi p2p service for service"
+            + " discovery.")
+    public void wifiP2pAddBonjourLocalService(String instanceName,
+            String serviceType,
+            @RpcOptional JSONObject txtMap,
+            @RpcDefault(value = "0") Integer channelId
+    ) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        Map<String, String> map = null;
+        if (txtMap != null) {
+            map = new HashMap<String, String>();
+            Iterator<String> keyIterator = txtMap.keys();
+            while (keyIterator.hasNext()) {
+                String key = keyIterator.next();
+                map.put(key, txtMap.getString(key));
+            }
+        }
+        WifiP2pDnsSdServiceInfo serviceInfo =
+                WifiP2pDnsSdServiceInfo.newInstance(instanceName, serviceType, map);
+
+        String callbackId = UUID.randomUUID().toString();
+        mP2pManager.addLocalService(channel, serviceInfo, new ActionListener(callbackId));
+        verifyActionListenerSucceed(callbackId);
+    }
+
+    /**
+     * Clear all registered local services of service discovery.
+     *
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If failed to clear local services or got invalid channel ID.
+     */
+    @Rpc(description = "Clear all registered local services of service discovery.")
+    public void wifiP2pClearLocalServices(@RpcDefault(value = "0") Integer channelId)
+            throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        String callbackId = UUID.randomUUID().toString();
+        mP2pManager.clearLocalServices(channel, new ActionListener(callbackId));
+        waitActionListenerResult(callbackId);
+    }
+
+    /**
+     * Add a service discovery request.
+     *
+     * @param protocolType The protocol type of the service discovery request.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @return The ID of the service request, which is used when calling
+     * @throws Throwable If add service request action timed out or got invalid channel ID.
+     */
+    @Rpc(description = "Add a service discovery request.")
+    public Integer wifiP2pAddServiceRequest(
+            int protocolType, @RpcDefault(value = "0") Integer channelId
+    ) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+
+        WifiP2pServiceRequest request = WifiP2pServiceRequest.newInstance(protocolType);
+        mServiceRequestCnt += 1;
+        mServiceRequests.put(mServiceRequestCnt, request);
+
+        String callbackId = UUID.randomUUID().toString();
+        mP2pManager.addServiceRequest(channel, request, new ActionListener(callbackId));
+        verifyActionListenerSucceed(callbackId);
+        return mServiceRequestCnt;
+    }
+
+    /**
+     * Add a service Upnp discovery request.
+     *
+     * @param serviceType The service type to be passed to {@link WifiP2pUpnpServiceRequest}.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @return The ID of the service request, which is used when calling
+     *     {@link #wifiP2pRemoveServiceRequest(int, Integer)}.
+     * @throws Throwable If add service request action timed out or got invalid channel ID.
+     */
+    @Rpc(description = "Add a service Upnp discovery request.")
+    public Integer wifiP2pAddUpnpServiceRequest(
+            @RpcOptional String serviceType,
+            @RpcDefault(value = "0") Integer channelId
+    ) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        WifiP2pUpnpServiceRequest request;
+        if (serviceType == null) {
+            request = WifiP2pUpnpServiceRequest.newInstance();
+        } else {
+            request = WifiP2pUpnpServiceRequest.newInstance(serviceType);
+        }
+        mServiceRequestCnt += 1;
+        mServiceRequests.put(mServiceRequestCnt, request);
+
+        String callbackId = UUID.randomUUID().toString();
+        mP2pManager.addServiceRequest(channel, request, new ActionListener(callbackId));
+        verifyActionListenerSucceed(callbackId);
+        return mServiceRequestCnt;
+    }
+
+    /**
+     * Add a service Bonjour discovery request.
+     *
+     * @param instanceName The instance name to be passed to
+     *     {@link WifiP2pDnsSdServiceRequest#newInstance(String, String)}.
+     * @param serviceType The service type to be passed to
+     *     {@link WifiP2pDnsSdServiceRequest#newInstance(String, String)}.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @return The ID of the service request, which is used when calling
+     *     {@link #wifiP2pRemoveServiceRequest(int, Integer)}.
+     *  @throws Throwable If add service request action timed out or got invalid channel ID.
+     */
+    @Rpc(description = "Add a service Bonjour discovery request.")
+    public Integer wifiP2pAddBonjourServiceRequest(
+            @RpcOptional String instanceName,
+            @RpcOptional String serviceType,
+            @RpcDefault(value = "0") Integer channelId
+    ) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        WifiP2pDnsSdServiceRequest request;
+        if (instanceName != null) {
+            request = WifiP2pDnsSdServiceRequest.newInstance(instanceName, serviceType);
+        } else if (serviceType == null) {
+            request = WifiP2pDnsSdServiceRequest.newInstance();
+        } else {
+            request = WifiP2pDnsSdServiceRequest.newInstance(serviceType);
+        }
+        mServiceRequestCnt += 1;
+        mServiceRequests.put(mServiceRequestCnt, request);
+
+        String callbackId = UUID.randomUUID().toString();
+        mP2pManager.addServiceRequest(channel, request, new ActionListener(callbackId));
+        verifyActionListenerSucceed(callbackId);
+        return mServiceRequestCnt;
+    }
+
+    /**
+     * Remove a service discovery request.
+     *
+     * @param index The index of the service request to remove.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If remove service request action timed out or got invalid channel ID.
+     */
+    @Rpc(description = "Remove a service discovery request.")
+    public void wifiP2pRemoveServiceRequest(int index, @RpcDefault(value = "0") Integer channelId)
+            throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        String callbackId = UUID.randomUUID().toString();
+        WifiP2pServiceRequest serviceRequest = mServiceRequests.remove(index);
+        if (serviceRequest == null) {
+            throw new WifiP2pManagerException("Service request not found. Please use the request ID"
+                    + " returned by `wifiP2pAddServiceRequest`.");
+        }
+        mP2pManager.removeServiceRequest(channel, serviceRequest,
+                new ActionListener(callbackId));
+        verifyActionListenerSucceed(callbackId);
+    }
+
+    /**
+     * Clear all registered service discovery requests.
+     *
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If clear service requests action timed out or got invalid channel ID.
+     */
+    @Rpc(description = "Clear all registered service discovery requests.")
+    public void wifiP2pClearServiceRequests(@RpcDefault(value = "0") Integer channelId)
+            throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        String callbackId = UUID.randomUUID().toString();
+        mP2pManager.clearServiceRequests(channel, new ActionListener(callbackId));
+        waitActionListenerResult(callbackId);
+    }
+
+    /**
+     * Set a callback to be invoked on receiving Upnp service discovery response.
+     *
+     * @param callbackId The callback ID assigned by Mobly.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws WifiP2pManagerException If the channel is not created.
+     */
+    @AsyncRpc(description = "Set a callback to be invoked on receiving Upnp service discovery "
+            + " response.")
+    public void wifiP2pSetUpnpResponseListener(String callbackId,
+            @RpcDefault(value = "0") Integer channelId)
+            throws WifiP2pManagerException {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        mP2pManager.setUpnpServiceResponseListener(channel,
+                new UpnpServiceResponseListener(callbackId));
+    }
+
+    /**
+     * Unset the Upnp service response callback set by `wifiP2pSetUpnpResponseListener`.
+     *
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws WifiP2pManagerException If the channel is not created.
+     */
+    @Rpc(description = "Unset the Upnp service response callback set by "
+            + "`wifiP2pSetUpnpResponseListener`.")
+    public void wifiP2pUnsetUpnpResponseListener(@RpcDefault(value = "0") Integer channelId)
+            throws WifiP2pManagerException {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        mP2pManager.setUpnpServiceResponseListener(channel, null);
+    }
+
+    /**
+     * Set a callback to be invoked on receiving Bonjour service discovery response.
+     *
+     * @param callbackId The callback ID assigned by Mobly.
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws WifiP2pManagerException If the channel is not created.
+     */
+    @AsyncRpc(description = "Set a callback to be invoked on receiving Bonjour service discovery"
+            + " response.")
+    public void wifiP2pSetDnsSdResponseListeners(String callbackId,
+            @RpcDefault(value = "0") Integer channelId)
+            throws WifiP2pManagerException {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        mP2pManager.setDnsSdResponseListeners(channel, new DnsSdServiceResponseListener(callbackId),
+                new DnsSdTxtRecordListener(callbackId));
+    }
+
+    /**
+     * Unset the Bonjour service response callback set by `wifiP2pSetDnsSdResponseListeners`.
+     *
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws WifiP2pManagerException If the channel is not created.
+     */
+    @Rpc(description = "Unset the Bonjour service response callback set by "
+            + "`wifiP2pSetDnsSdResponseListeners`.")
+    public void wifiP2pUnsetDnsSdResponseListeners(@RpcDefault(value = "0") Integer channelId)
+            throws WifiP2pManagerException {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        mP2pManager.setDnsSdResponseListeners(channel, null, null);
+    }
+
+    /**
+     * Initiate service discovery.
+     *
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @throws Throwable If the P2P operation failed or timed out, or got invalid channel ID.
+     */
+    @Rpc(description = "Initiate service discovery.")
+    public void wifiP2pDiscoverServices(
+            @RpcDefault(value = "0") Integer channelId
+    ) throws Throwable {
+        WifiP2pManager.Channel channel = getChannel(channelId);
+        String callbackId = UUID.randomUUID().toString();
+        mP2pManager.discoverServices(channel, new ActionListener(callbackId));
+        verifyActionListenerSucceed(callbackId);
+    }
+
     /**
      * Close the current P2P connection and indicate to the P2P service that connections created by
      * the app can be removed.
      */
-    @Rpc(
-            description =
-                    "Close the current P2P connection and indicate to the P2P service that"
-                            + " connections created by the app can be removed.")
+    @Rpc(description = "Close all P2P connections and indicate to the P2P service that"
+            + " connections created by the app can be removed.")
     public void p2pClose() {
-        if (mChannel == null) {
-            Log.d("Channel has already closed, skip WifiP2pManager.Channel.close()");
-            return;
+        for (Map.Entry<Integer, WifiP2pManager.Channel> entry : mChannels.entrySet()) {
+            Integer channelId = entry.getKey();
+            WifiP2pManager.Channel channel = entry.getValue();
+            Log.d("Cleaning p2p resources associated with channelId=" + channelId);
+            if (channel != null) {
+                try {
+                    wifiP2pClearServiceRequests(channelId);
+                } catch (Throwable e) {
+                    Log.e("Failed to clear service requests on channelId=" + channelId
+                            + ", error message: " + e.getMessage());
+                }
+                mP2pManager.setDnsSdResponseListeners(channel, null, null);
+                mP2pManager.setUpnpServiceResponseListener(channel, null);
+                try {
+                    wifiP2pClearLocalServices(channelId);
+                } catch (Throwable e) {
+                    Log.e("Failed to clear local services on channelId=" + channelId
+                            + ", error message: " + e.getMessage());
+                }
+                channel.close();
+            }
         }
-        mChannel.close();
-        mChannel = null;
+        mChannels.clear();
+        mChannelCnt = -1;
         if (mStateChangedReceiver != null) {
             mContext.unregisterReceiver(mStateChangedReceiver);
             mStateChangedReceiver = null;
@@ -307,7 +873,8 @@ public class WifiP2pManagerSnippet implements Snippet {
         public void onReceive(Context mContext, Intent intent) {
             String action = intent.getAction();
             SnippetEvent event = new SnippetEvent(mCallbackId, action);
-            String logPrefix = "Got intent: action=" + action + ", ";
+            String logPrefix = TAG + ": WifiP2pStateChangedReceiver: onReceive: Got intent: action="
+                    + action + ", ";
             switch (action) {
                 case WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION:
                     int wifiP2pState = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, 0);
@@ -317,7 +884,7 @@ public class WifiP2pManagerSnippet implements Snippet {
                 case WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION:
                     WifiP2pDeviceList peerList = (WifiP2pDeviceList) intent.getParcelableExtra(
                             WifiP2pManager.EXTRA_P2P_DEVICE_LIST);
-                    Log.d(logPrefix + "p2pPeerList=" + peerList.toString());
+                    Log.d(logPrefix + "p2pPeerList=" + BundleUtils.fromWifiP2pDeviceList(peerList));
                     event.getData().putParcelableArrayList(
                             EVENT_KEY_PEER_LIST, BundleUtils.fromWifiP2pDeviceList(peerList));
                     break;
@@ -329,11 +896,9 @@ public class WifiP2pManagerSnippet implements Snippet {
                     WifiP2pGroup p2pGroup = (WifiP2pGroup) intent.getParcelableExtra(
                             WifiP2pManager.EXTRA_WIFI_P2P_GROUP);
                     Log.d(logPrefix + "networkInfo=" + String.valueOf(networkInfo) + ", p2pInfo="
-                            + String.valueOf(p2pInfo) + ", p2pGroup=" + String.valueOf(p2pGroup)
-                    );
+                            + String.valueOf(p2pInfo) + ", p2pGroup=" + String.valueOf(p2pGroup));
                     if (networkInfo != null) {
-                        event.getData().putBoolean(
-                                "isConnected", networkInfo.isConnected());
+                        event.getData().putBoolean("isConnected", networkInfo.isConnected());
                     } else {
                         event.getData().putBoolean("isConnected", false);
                     }
@@ -372,6 +937,27 @@ public class WifiP2pManagerSnippet implements Snippet {
         }
     }
 
+    private static class  WifiP2pConnectionInfoListener
+        implements WifiP2pManager.ConnectionInfoListener {
+        public static final String EVENT_NAME_ON_CONNECTION_INFO =
+            "WifiP2pOnConnectionInfoAvailable";
+        private final String mCallbackId;
+
+        public WifiP2pConnectionInfoListener(String callbackId) {
+            this.mCallbackId = callbackId;
+        }
+
+        @Override
+        public void onConnectionInfoAvailable(WifiP2pInfo info) {
+            Log.d(TAG + ": onConnectionInfoAvailable: " + info.toString());
+            SnippetEvent event = new SnippetEvent(mCallbackId, EVENT_NAME_ON_CONNECTION_INFO);
+            event.getData().putBoolean("groupFormed", info.groupFormed);
+            event.getData().putBoolean("isGroupOwner", info.isGroupOwner);
+            event.getData().putString("groupOwnerHostAddress", info.groupOwnerAddress.toString());
+            EventCache.getInstance().postEvent(event);
+        }
+    }
+
     private static class DeviceInfoListener implements WifiP2pManager.DeviceInfoListener {
         public static final String EVENT_NAME_ON_DEVICE_INFO = "WifiP2pOnDeviceInfoAvailable";
 
@@ -386,33 +972,33 @@ public class WifiP2pManagerSnippet implements Snippet {
             if (device == null) {
                 return;
             }
-            Log.d("onDeviceInfoAvailable: " + device.toString());
+            Log.d(TAG + ": onDeviceInfoAvailable: " + device.toString());
             SnippetEvent event = new SnippetEvent(mCallbackId, EVENT_NAME_ON_DEVICE_INFO);
             event.getData().putBundle(EVENT_KEY_P2P_DEVICE, BundleUtils.fromWifiP2pDevice(device));
             EventCache.getInstance().postEvent(event);
         }
     }
 
-    private static class WifiP2pPeerListListener implements WifiP2pManager.PeerListListener {
+    private static class PeerListListener implements WifiP2pManager.PeerListListener {
         private final String mCallbackId;
 
-        WifiP2pPeerListListener(String callbackId) {
+        PeerListListener(String callbackId) {
             this.mCallbackId = callbackId;
         }
 
         @Override
         public void onPeersAvailable(WifiP2pDeviceList newPeers) {
-            Log.d("onPeersAvailable: " + newPeers.getDeviceList());
+            Log.d(TAG + ": onPeersAvailable: " + newPeers.getDeviceList());
             ArrayList<Bundle> devices = BundleUtils.fromWifiP2pDeviceList(newPeers);
             SnippetEvent event = new SnippetEvent(mCallbackId, "WifiP2pOnPeersAvailable");
             event.getData().putParcelableArrayList(EVENT_KEY_PEER_LIST, devices);
-            event.getData().putLong("timestampMs", System.currentTimeMillis());
+            event.getData().putLong(EVENT_KEY_TIMESTAMP_MS, System.currentTimeMillis());
             EventCache.getInstance().postEvent(event);
         }
     }
 
-    private static class PersistentGroupInfoListener implements
-            WifiP2pManager.PersistentGroupInfoListener {
+    private static class PersistentGroupInfoListener
+            implements WifiP2pManager.PersistentGroupInfoListener {
         private final String mCallbackId;
 
         PersistentGroupInfoListener(String callbackId) {
@@ -421,27 +1007,114 @@ public class WifiP2pManagerSnippet implements Snippet {
 
         @Override
         public void onPersistentGroupInfoAvailable(@NonNull WifiP2pGroupList groups) {
-            Log.d("onPersistentGroupInfoAvailable: " + groups.toString());
+            Log.d(TAG + ": onPersistentGroupInfoAvailable: " + groups.toString());
             SnippetEvent event = new SnippetEvent(mCallbackId, "onPersistentGroupInfoAvailable");
-            event.getData().putParcelableArrayList(
-                    "groupList", BundleUtils.fromWifiP2pGroupList(groups));
+            event.getData()
+                    .putParcelableArrayList("groupList", BundleUtils.fromWifiP2pGroupList(groups));
+            EventCache.getInstance().postEvent(event);
+        }
+    }
+
+    private static class UpnpServiceResponseListener
+            implements WifiP2pManager.UpnpServiceResponseListener {
+        private final String mCallbackId;
+
+        UpnpServiceResponseListener(String callbackId) {
+            this.mCallbackId = callbackId;
+        }
+
+        @Override
+        public void onUpnpServiceAvailable(List<String> uniqueServiceNames,
+                WifiP2pDevice srcDevice) {
+            Log.d(TAG + ": onUpnpServiceAvailable: service names: " + uniqueServiceNames);
+            SnippetEvent event = new SnippetEvent(mCallbackId, "onUpnpServiceAvailable");
+            event.getData()
+                    .putBundle(EVENT_KEY_SOURCE_DEVICE, BundleUtils.fromWifiP2pDevice(srcDevice));
+            event.getData()
+                    .putStringArrayList(EVENT_KEY_SERVICE_LIST, new ArrayList(uniqueServiceNames));
+            EventCache.getInstance().postEvent(event);
+        }
+    }
+
+    private static class DnsSdServiceResponseListener
+            implements WifiP2pManager.DnsSdServiceResponseListener {
+        private final String mCallbackId;
+
+        DnsSdServiceResponseListener(String callbackId) {
+            this.mCallbackId = callbackId;
+        }
+
+        @Override
+        public void onDnsSdServiceAvailable(String instanceName, String registrationType,
+                WifiP2pDevice srcDevice) {
+            SnippetEvent event = new SnippetEvent(mCallbackId, "onDnsSdServiceAvailable");
+            event.getData().putString(EVENT_KEY_INSTANCE_NAME, instanceName);
+            event.getData().putString(EVENT_KEY_REGISTRATION_TYPE, registrationType);
+            event.getData()
+                    .putBundle(EVENT_KEY_SOURCE_DEVICE, BundleUtils.fromWifiP2pDevice(srcDevice));
+            EventCache.getInstance().postEvent(event);
+        }
+    }
+
+    private static class DnsSdTxtRecordListener implements WifiP2pManager.DnsSdTxtRecordListener {
+        private final String mCallbackId;
+
+        DnsSdTxtRecordListener(String callbackId) {
+            this.mCallbackId = callbackId;
+        }
+
+        @Override
+        public void onDnsSdTxtRecordAvailable(String fullDomainName,
+                Map<String, String> txtRecordMap, WifiP2pDevice srcDevice) {
+            SnippetEvent event = new SnippetEvent(mCallbackId, "onDnsSdTxtRecordAvailable");
+            event.getData().putString(EVENT_KEY_FULL_DOMAIN_NAME, fullDomainName);
+            Bundle txtMap = new Bundle();
+            for (String key : txtRecordMap.keySet()) {
+                txtMap.putString(key, txtRecordMap.get(key));
+            }
+            event.getData().putBundle(EVENT_KEY_TXT_RECORD_MAP, txtMap);
+            event.getData()
+                    .putBundle(EVENT_KEY_SOURCE_DEVICE, BundleUtils.fromWifiP2pDevice(srcDevice));
             EventCache.getInstance().postEvent(event);
         }
     }
 
-    private void checkChannel() throws WifiP2pManagerException {
-        if (mChannel == null) {
+    /**
+     * Get the channel by channel ID.
+     *
+     * @param channelId The ID of the channel for Wi-Fi P2P to operate on.
+     * @return The channel.
+     * @throws WifiP2pManagerException If the channel is not created.
+     */
+    private WifiP2pManager.Channel getChannel(int channelId)
+            throws WifiP2pManagerException {
+        WifiP2pManager.Channel channel = mChannels.get(channelId);
+        if (channel == null) {
+            Log.e(TAG + ": getChannel : channel keys" + mChannels.keySet());
             throw new WifiP2pManagerException(
-                    "Channel is not created, please call 'wifiP2pInitialize' first.");
+                    "The channelId " + channelId + " is wrong. Please use the channelId returned "
+                            + "by calling `wifiP2pInitialize` or `wifiP2pInitExtraChannel`.");
         }
+        return channel;
     }
 
+    /**
+     * Check if the device supports Wi-Fi Direct.
+     *
+     * @throws WifiP2pManagerException If the device does not support Wi-Fi Direct.
+     */
     private void checkP2pManager() throws WifiP2pManagerException {
         if (mP2pManager == null) {
             throw new WifiP2pManagerException("Device does not support Wi-Fi Direct.");
         }
     }
 
+    /**
+     * Check permissions for the given permissions.
+     *
+     * @param context The context to check permissions.
+     * @param permissions The permissions to check.
+     */
     private static void checkPermissions(Context context, String... permissions) {
         for (String permission : permissions) {
             if (context.checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
@@ -451,31 +1124,52 @@ public class WifiP2pManagerSnippet implements Snippet {
         }
     }
 
-    /** Wait until any callback of {@link ActionListener} is triggered. */
+    /**
+     * Wait until any callback of {@link ActionListener} is triggered.
+     *
+     * @param callbackId The callback ID associated with the action listener.
+     * @return The event posted by the callback methods of {@link ActionListener}.
+     * @throws Throwable If the action timed out.
+     */
     private Bundle waitActionListenerResult(String callbackId) throws Throwable {
-        SnippetEvent event = waitForSnippetEvent(
-                callbackId, ActionListener.CALLBACK_EVENT_NAME, TIMEOUT_SHORT_MS);
+        SnippetEvent event = waitForSnippetEvent(callbackId, ActionListener.CALLBACK_EVENT_NAME,
+                TIMEOUT_SHORT_MS);
         Log.d("Got action listener result event: " + event.getData().toString());
         return event.getData();
     }
 
-    /** Wait until any callback of {@link ActionListener} is triggered and verify it succeeded. */
+    /**
+     * Wait until any callback of {@link ActionListener} is triggered and verify it succeeded.
+     *
+     * @param callbackId The callback ID associated with the action listener.
+     * @throws Throwable If the action timed out or failed.
+     */
     private void verifyActionListenerSucceed(String callbackId) throws Throwable {
         Bundle eventData = waitActionListenerResult(callbackId);
         String result = eventData.getString(EVENT_KEY_CALLBACK_NAME);
-        if (result == ACTION_LISTENER_ON_SUCCESS) {
+        if (Objects.equals(ACTION_LISTENER_ON_SUCCESS, result)) {
             return;
         }
-        if (result == ACTION_LISTENER_ON_FAILURE) {
+        if (Objects.equals(ACTION_LISTENER_ON_FAILURE, result)) {
+            // Please keep reason code in error message for client side to check the reason.
             throw new WifiP2pManagerException(
-                "Action failed with reason code: " + eventData.getInt(EVENT_KEY_REASON)
+                    "Action failed with reason_code=" + eventData.getInt(EVENT_KEY_REASON)
             );
         }
         throw new WifiP2pManagerException("Action got unknown event: " + eventData.toString());
     }
 
-    private static SnippetEvent waitForSnippetEvent(
-            String callbackId, String eventName, Integer timeout) throws Throwable {
+    /**
+     * Wait for a SnippetEvent with the given callbackId and eventName.
+     *
+     * @param callbackId The callback ID associated with the action listener.
+     * @param eventName The event name to wait for.
+     * @param timeout The timeout in milliseconds.
+     * @return The SnippetEvent.
+     * @throws Throwable If the action timed out.
+     */
+    private static SnippetEvent waitForSnippetEvent(String callbackId, String eventName,
+            Integer timeout) throws Throwable {
         String qId = EventCache.getQueueId(callbackId, eventName);
         LinkedBlockingDeque<SnippetEvent> q = EventCache.getInstance().getEventDeque(qId);
         SnippetEvent result;
diff --git a/tests/hostsidetests/multidevices/com.google.snippet.wifi/softap/TetheringManagerSnippet.java b/tests/hostsidetests/multidevices/com.google.snippet.wifi/softap/TetheringManagerSnippet.java
new file mode 100644
index 0000000000..ce1bc5f61e
--- /dev/null
+++ b/tests/hostsidetests/multidevices/com.google.snippet.wifi/softap/TetheringManagerSnippet.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.snippet.wifi.softap;
+
+import android.content.Context;
+import android.net.TetheringManager;
+import android.net.TetheringManager.TetheringRequest;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.util.Log;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.google.android.mobly.snippet.Snippet;
+import com.google.android.mobly.snippet.event.EventCache;
+import com.google.android.mobly.snippet.event.SnippetEvent;
+import com.google.android.mobly.snippet.rpc.AsyncRpc;
+import com.google.android.mobly.snippet.rpc.Rpc;
+
+/** Snippet class for TetheringManager. */
+public class TetheringManagerSnippet implements Snippet {
+    private static final String TAG = "TetheringManagerSnippet";
+
+    private final TetheringManager mTetheringManager;
+    private final Handler mHandler;
+
+
+    /** Callback class to get the results of tethering start. */
+    private static class SnippetStartTetheringCallback implements
+            TetheringManager.StartTetheringCallback {
+        private final String mCallbackId;
+
+        SnippetStartTetheringCallback(String callbackId) {
+            mCallbackId = callbackId;
+        }
+
+        @Override
+        public void onTetheringStarted() {
+            Log.d(TAG, "onTetheringStarted");
+            SnippetEvent event = new SnippetEvent(mCallbackId, "onTetheringStarted");
+            EventCache.getInstance().postEvent(event);
+        }
+
+        @Override
+        public void onTetheringFailed(final int error) {
+            Log.d(TAG, "onTetheringFailed, error=" + error);
+            SnippetEvent event = new SnippetEvent(mCallbackId, "onTetheringFailed");
+            event.getData().putInt("error", error);
+            EventCache.getInstance().postEvent(event);
+        }
+    }
+
+    public TetheringManagerSnippet() {
+        Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        mTetheringManager = context.getSystemService(TetheringManager.class);
+        HandlerThread handlerThread = new HandlerThread(getClass().getSimpleName());
+        handlerThread.start();
+        mHandler = new Handler(handlerThread.getLooper());
+    }
+
+    /**
+     * Starts tethering.
+     *
+     * @param callbackId A unique identifier assigned automatically by Mobly.
+     */
+    @AsyncRpc(description = "Call to start tethering.")
+    public void tetheringStartTethering(String callbackId) {
+        TetheringRequest request =
+                new TetheringRequest.Builder(TetheringManager.TETHERING_WIFI).build();
+
+        SnippetStartTetheringCallback callback = new SnippetStartTetheringCallback(callbackId);
+        mTetheringManager.startTethering(request, mHandler::post, callback);
+    }
+
+    /**
+     * Stop tethering.
+     */
+    @Rpc(description = "Call to stop tethering.")
+    public void tetheringStopTethering() {
+        mTetheringManager.stopTethering(TetheringManager.TETHERING_WIFI);
+    }
+}
diff --git a/tests/hostsidetests/multidevices/test/Android.bp b/tests/hostsidetests/multidevices/test/Android.bp
index 9956fa590e..3d3ef73ee5 100644
--- a/tests/hostsidetests/multidevices/test/Android.bp
+++ b/tests/hostsidetests/multidevices/test/Android.bp
@@ -39,14 +39,9 @@ python_defaults {
         "mobly",
     ],
     test_suites: [
-        "cts",
+        "cts-interactive",
         "general-tests",
     ],
-    version: {
-        py3: {
-            embedded_launcher: true,
-        },
-    },
 }
 
 python_test_host {
@@ -57,7 +52,6 @@ python_test_host {
     device_common_data: [
         // Package the snippet with the mobly test
         ":wifi_aware_snippet",
-        "requirements.txt",
     ],
     test_options: {
         unit_test: false,
@@ -66,23 +60,31 @@ python_test_host {
 }
 
 python_test_host {
-    name: "WifiAwareManagerTestCases",
-    main: "aware/wifi_aware_manager_test.py",
-    srcs: ["aware/wifi_aware_manager_test.py"],
-    device_common_data: [":wifi_mobly_snippet"],
+    name: "CtsWifiAwareTests",
+    main: "aware/cts_wifi_aware_test_suite.py",
+    test_config: "aware/AndroidTestNew.xml",
+    srcs: [
+        "aware/cts_wifi_aware_test_suite.py",
+        "aware/wifi_aware_network_test.py",
+        "aware/wifi_aware_discovery_ranging_test.py",
+        "aware/aware_snippet_utils.py",
+    ],
     libs: [
         "aware_lib_utils",
         "mobly",
         "wifi_aware_constants",
         "wifi_test_utils",
+        "platform-test-py-annotations",
     ],
-    test_suites: [
-        "general-tests",
-    ],
+    device_common_data: [":wifi_mobly_snippet"],
     test_options: {
         unit_test: false,
-        tags: ["mobly"],
+        runner: "mobly",
     },
+    test_suites: [
+        "general-tests",
+        "cts-v-host",
+    ],
 }
 
 python_library_host {
@@ -90,6 +92,15 @@ python_library_host {
     srcs: ["direct/constants.py"],
 }
 
+python_library_host {
+    name: "wifi_direct_test_utils",
+    srcs: ["direct/p2p_utils.py"],
+    libs: [
+        "wifi_direct_constants",
+        "mobly",
+    ],
+}
+
 python_test_host {
     name: "WifiDirectMoblyTests",
     main: "direct/wifi_direct_test.py",
@@ -104,31 +115,58 @@ python_test_host {
         tags: ["mobly"],
     },
     test_suites: ["general-tests"],
-    version: {
-        py3: {
-            embedded_launcher: true,
-        },
-    },
 }
 
 python_test_host {
-    name: "WifiDirectGoNegTests",
-    main: "direct/group_owner_negotiation_test.py",
-    srcs: ["direct/group_owner_negotiation_test.py"],
+    name: "WifiDirectTests",
+    main: "direct/wifi_direct_test_suite.py",
+    srcs: [
+        "direct/group_owner_negotiation_test.py",
+        "direct/group_owner_test.py",
+        "direct/group_owner_with_config_test.py",
+        "direct/service_discovery_test.py",
+        "direct/wifi_direct_test_suite.py",
+    ],
+    test_config: "direct/AndroidTest.xml",
     libs: [
         "mobly",
         "wifi_direct_constants",
         "wifi_test_utils",
+        "wifi_direct_test_utils",
+        "platform-test-py-annotations",
     ],
     device_common_data: [":wifi_mobly_snippet"],
     test_options: {
         unit_test: false,
-        tags: ["mobly"],
+        runner: "mobly",
     },
-    test_suites: ["general-tests"],
-    version: {
-        py3: {
-            embedded_launcher: true,
-        },
+    test_suites: [
+        "general-tests",
+    ],
+}
+
+python_library_host {
+    name: "wifi_softap_constants",
+    srcs: ["softap/constants.py"],
+}
+
+python_test_host {
+    name: "CtsWifiSoftApTestCases",
+    main: "softap/wifi_softap_test.py",
+    srcs: ["softap/wifi_softap_test.py"],
+    test_config: "softap/AndroidTest.xml",
+    libs: [
+        "mobly",
+        "wifi_test_utils",
+        "wifi_softap_constants",
+    ],
+    device_common_data: [":wifi_mobly_snippet"],
+    test_options: {
+        unit_test: false,
+        runner: "mobly",
     },
+    test_suites: [
+        "general-tests",
+        "cts-v-host",
+    ],
 }
diff --git a/tests/hostsidetests/multidevices/test/aware/AndroidTestNew.xml b/tests/hostsidetests/multidevices/test/aware/AndroidTestNew.xml
new file mode 100644
index 0000000000..69de107885
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/AndroidTestNew.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+          http://www.apache.org/licenses/LICENSE-2.0
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Test config for Wi-Fi Aware multi-device CTS tests">
+  <option name="test-suite-tag" value="cts-v-host" />
+  <option name="config-descriptor:metadata" key="component" value="wifi" />
+  <option name="config-descriptor:metadata" key="parameter" value="not_instant_app" />
+  <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+  <option name="config-descriptor:metadata" key="parameter" value="secondary_user" />
+
+  <device name="AndroidDevice">
+    <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+      <option name="required_feature" value="android.hardware.wifi.aware" />
+    </target_preparer>
+    <target_preparer class="AndroidInstallAppsDecorator" />
+  </device>
+  <device name="AndroidDevice">
+    <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+      <option name="required_feature" value="android.hardware.wifi.aware" />
+    </target_preparer>
+    <target_preparer class="AndroidInstallAppsDecorator" />
+  </device>
+
+  <test class="MoblyAospPackageTest" />
+
+  <option name="mobly_pkg" key="file" value="CtsWifiAwareTests" />
+  <option name="build_apk" key="file" value="wifi_mobly_snippet.apk" />
+</configuration>
\ No newline at end of file
diff --git a/tests/hostsidetests/multidevices/test/aware/aware_lib_utils.py b/tests/hostsidetests/multidevices/test/aware/aware_lib_utils.py
index b445c10856..c780cb86b4 100644
--- a/tests/hostsidetests/multidevices/test/aware/aware_lib_utils.py
+++ b/tests/hostsidetests/multidevices/test/aware/aware_lib_utils.py
@@ -25,7 +25,9 @@ from aware import constants
 
 from mobly import asserts
 from mobly.controllers import android_device
+from mobly.controllers.android_device_lib import adb
 from mobly.controllers.android_device_lib import callback_handler_v2
+from mobly.snippet import callback_event
 from mobly.snippet import errors
 
 
@@ -34,6 +36,18 @@ _TIMEOUT_INTERVAL_IN_SEC = 1
 _WAIT_WIFI_STATE_TIME_OUT = datetime.timedelta(seconds=10)
 _WAIT_TIME_SEC = 3
 _CONTROL_WIFI_TIMEOUT_SEC = 10
+_REQUEST_NETWORK_TIMEOUT_MS = 15 * 1000
+# arbitrary timeout for events
+_EVENT_TIMEOUT = 10
+
+# Alias variable.
+_CALLBACK_NAME = constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
+_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
+_TRANSPORT_TYPE_WIFI_AWARE = (
+    constants.NetworkCapabilities.Transport.TRANSPORT_WIFI_AWARE
+)
+# Definition for timeout and retries.
+_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
 
 
 def callback_no_response(
@@ -332,6 +346,22 @@ def reset_device_parameters(ad: android_device.AndroidDevice):
   """
   ad.adb.shell("cmd wifiaware reset")
 
+def aware_cap_str_to_dict(cap_string:str) -> dict:
+    idx = cap_string.find('[maxConcurrentAwareClusters')
+    # Remove the braces from the string.
+    new_string = cap_string[idx:-1].strip('[]')
+    # split the string into key-value pairs
+    pairs = new_string.split(', ')
+    # Converting the values to integer or bool into dictionary
+    capabilities = {}
+    for pair in pairs:
+      key, value = pair.split('=')
+      try:
+          capabilities[key] = int(value)
+      except ValueError:
+          capabilities[key] = bool(value)
+    return capabilities
+
 
 def reset_device_statistics(ad: android_device.AndroidDevice,):
   """Reset device statistics.
@@ -349,7 +379,16 @@ def get_aware_capabilities(ad: android_device.AndroidDevice):
     ad: the Android device
   Returns: the capability dictionary.
   """
-    return json.loads(ad.adb.shell('cmd wifiaware state_mgr get_capabilities'))
+    try:
+      result = ad.adb.shell('cmd wifiaware state_mgr get_capabilities')
+      return json.loads(result)
+    except adb.AdbError:
+      ad.log.info('Another way to get capabilities- dumpsys and parse string.')
+      result = ad.adb.shell('dumpsys wifiaware |grep mCapabilities').decode()
+      pairs = aware_cap_str_to_dict(result)
+      ad.log.info(pairs)
+    return pairs
+
 
 def create_discovery_config(service_name,
                             p_type=None,
@@ -392,3 +431,355 @@ def create_discovery_config(service_name,
     config[constants.TTL_SEC] = ttl
     config[constants.TERMINATE_NOTIFICATION_ENABLED] = term_cb_enable
     return config
+
+def start_attach(
+    ad: android_device.AndroidDevice,
+    is_ranging_enabled: bool = True,
+) -> str:
+  """Starts the attach process on the provided device."""
+  attach_handler = ad.wifi_aware_snippet.wifiAwareAttached(
+      is_ranging_enabled
+  )
+  attach_event = attach_handler.waitAndGet(
+      event_name=constants.AttachCallBackMethodType.ATTACHED,
+      timeout=_DEFAULT_TIMEOUT,
+  )
+  asserts.assert_true(
+      ad.wifi_aware_snippet.wifiAwareIsSessionAttached(
+          attach_event.callback_id
+      ),
+      f'{ad} attach succeeded, but Wi-Fi Aware session is still null.',
+  )
+  mac_address = None
+  if is_ranging_enabled:
+    identity_changed_event = attach_handler.waitAndGet(
+        event_name=constants.AttachCallBackMethodType.ID_CHANGED,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    mac_address = identity_changed_event.data.get('mac', None)
+    asserts.assert_true(bool(mac_address), 'Mac address should not be empty')
+  ad.log.info('Attach Wi-Fi Aware session succeeded.')
+  return attach_event.callback_id, mac_address
+
+def create_discovery_pair(
+    p_dut: android_device.AndroidDevice,
+    s_dut: android_device.AndroidDevice,
+    p_config: dict[str, any],
+    s_config: dict[str, any],
+    device_startup_delay: int=1,
+    msg_id=None,
+):
+  """Creates a discovery session (publish and subscribe), and pair each other.
+
+  wait for service discovery - at that point the sessions are connected and
+  ready for further messaging of data-path setup.
+
+  Args:
+      p_dut: Device to use as publisher.
+      s_dut: Device to use as subscriber.
+      p_config: Publish configuration.
+      s_config: Subscribe configuration.
+      device_startup_delay: Number of seconds to offset the enabling of NAN
+        on the two devices.
+      msg_id: Controls whether a message is sent from Subscriber to Publisher
+        (so that publisher has the sub's peer ID). If None then not sent,
+        otherwise should be an int for the message id.
+
+  Returns:
+      variable size list of:
+      p_id: Publisher attach session id
+      s_id: Subscriber attach session id
+      p_disc_id: Publisher discovery session id
+      s_disc_id: Subscriber discovery session id
+      peer_id_on_sub: Peer ID of the Publisher as seen on the Subscriber
+      peer_id_on_pub: Peer ID of the Subscriber as seen on the Publisher. Only
+                      included if |msg_id| is not None.
+  """
+  # attach and wait for confirmation
+  p_id, _ = start_attach(p_dut)
+  time.sleep(device_startup_delay)
+  s_id, _ = start_attach(s_dut)
+  p_disc_id = p_dut.wifi_aware_snippet.wifiAwarePublish(
+      p_id, p_config
+      )
+  p_dut.log.info('Created the publish session.')
+  p_discovery = p_disc_id.waitAndGet(
+      constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT)
+  callback_name = p_discovery.data[_CALLBACK_NAME]
+  asserts.assert_equal(
+      constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+      callback_name,
+      f'{p_dut} publish failed, got callback: {callback_name}.',
+      )
+  time.sleep(device_startup_delay)
+  # Subscriber: start subscribe and wait for confirmation
+  s_disc_id = s_dut.wifi_aware_snippet.wifiAwareSubscribe(
+      s_id, s_config
+      )
+  s_dut.log.info('Created the subscribe session.')
+  s_discovery = s_disc_id.waitAndGet(
+      constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT)
+  callback_name = s_discovery.data[_CALLBACK_NAME]
+  asserts.assert_equal(
+      constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+      callback_name,
+      f'{s_dut} subscribe failed, got callback: {callback_name}.',
+      )
+  # Subscriber: wait for service discovery
+  discovery_event = s_disc_id.waitAndGet(
+      constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED)
+  peer_id_on_sub = discovery_event.data[
+      constants.WifiAwareSnippetParams.PEER_ID
+  ]
+  # Optionally send a message from Subscriber to Publisher
+  if msg_id is not None:
+    ping_msg = 'PING'
+    # Subscriber: send message to peer (Publisher)
+    s_dut.wifi_aware_snippet.wifiAwareSendMessage(
+        s_disc_id.callback_id, peer_id_on_sub, msg_id, ping_msg
+        )
+    message_send_result = s_disc_id.waitAndGet(
+        event_name=
+        constants.DiscoverySessionCallbackMethodType.MESSAGE_SEND_RESULT,
+        timeout=_DEFAULT_TIMEOUT,
+        )
+    actual_send_message_id = message_send_result.data[
+        constants.DiscoverySessionCallbackParamsType.MESSAGE_ID
+        ]
+    asserts.assert_equal(
+        actual_send_message_id,
+        msg_id,
+        f'{s_dut} send message succeeded but message ID mismatched.'
+        )
+    pub_rx_msg_event = p_disc_id.waitAndGet(
+        event_name=
+        constants.DiscoverySessionCallbackMethodType.MESSAGE_RECEIVED,
+        timeout=_DEFAULT_TIMEOUT,
+        )
+    peer_id_on_pub = pub_rx_msg_event.data[
+        constants.WifiAwareSnippetParams.PEER_ID
+        ]
+    received_message_raw = pub_rx_msg_event.data[
+        constants.WifiAwareSnippetParams.RECEIVED_MESSAGE
+        ]
+    received_message = bytes(received_message_raw).decode('utf-8')
+    asserts.assert_equal(
+        received_message,
+        ping_msg,
+        f'{p_dut} Subscriber -> Publisher message corrupted.'
+        )
+    return p_id, s_id, p_disc_id, s_disc_id, peer_id_on_sub, peer_id_on_pub
+  return p_id, s_id, p_disc_id, s_disc_id, peer_id_on_sub
+
+def request_network(
+    ad: android_device.AndroidDevice,
+    discovery_session: str,
+    peer: int,
+    net_work_request_id: str,
+    network_specifier_params: (
+        constants.WifiAwareNetworkSpecifier | None
+    ) = None,
+    is_accept_any_peer: bool = False,
+) -> callback_handler_v2.CallbackHandlerV2:
+  """Requests and configures a Wi-Fi Aware network connection."""
+  network_specifier_parcel = (
+      ad.wifi_aware_snippet.wifiAwareCreateNetworkSpecifier(
+          discovery_session,
+          peer,
+          is_accept_any_peer,
+          network_specifier_params.to_dict()
+          if network_specifier_params
+          else None,
+      )
+  )
+  network_request_dict = constants.NetworkRequest(
+      transport_type=_TRANSPORT_TYPE_WIFI_AWARE,
+      network_specifier_parcel=network_specifier_parcel,
+  ).to_dict()
+  ad.log.debug('Requesting Wi-Fi Aware network: %r', network_request_dict)
+  return ad.wifi_aware_snippet.connectivityRequestNetwork(
+      net_work_request_id, network_request_dict, _REQUEST_NETWORK_TIMEOUT_MS
+  )
+
+def wait_for_network(
+    ad: android_device.AndroidDevice,
+    request_network_cb_handler: callback_handler_v2.CallbackHandlerV2,
+    expected_channel: str | None = None,
+) -> callback_event.CallbackEvent:
+  """Waits for and verifies the establishment of a Wi-Fi Aware network."""
+  network_callback_event = request_network_cb_handler.waitAndGet(
+      event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+      timeout=_DEFAULT_TIMEOUT,
+  )
+  callback_name = network_callback_event.data[_CALLBACK_NAME]
+  if callback_name == constants.NetworkCbName.ON_UNAVAILABLE:
+    asserts.fail(
+        f'{ad} failed to request the network, got callback {callback_name}.'
+    )
+  elif callback_name == constants.NetworkCbName.ON_CAPABILITIES_CHANGED:
+    # `network` is the network whose capabilities have changed.
+    network = network_callback_event.data[constants.NetworkCbEventKey.NETWORK]
+    network_capabilities = network_callback_event.data[
+        constants.NetworkCbEventKey.NETWORK_CAPABILITIES
+    ]
+    asserts.assert_true(
+        network and network_capabilities,
+        f'{ad} received a null Network or NetworkCapabilities!?.',
+    )
+    transport_info_class_name = network_callback_event.data[
+        constants.NetworkCbEventKey.TRANSPORT_INFO_CLASS_NAME
+    ]
+    ad.log.info(f'got class_name {transport_info_class_name}')
+    asserts.assert_equal(
+        transport_info_class_name,
+        constants.AWARE_NETWORK_INFO_CLASS_NAME,
+        f'{ad} network capabilities changes but it is not a WiFi Aware'
+        ' network.',
+    )
+    if expected_channel:
+      mhz_list = network_callback_event.data[
+          constants.NetworkCbEventKey.CHANNEL_IN_MHZ
+      ]
+      asserts.assert_equal(
+          mhz_list,
+          [expected_channel],
+          f'{ad} Channel freq is not match the request.',
+      )
+  elif callback_name == constants.NetworkCbName.ON_PROPERTIES_CHANGED:
+    iface_name = network_callback_event.data[
+        constants.NetworkCbEventKey.NETWORK_INTERFACE_NAME
+    ]
+    ad.log.info('interface name = %s', iface_name)
+  else:
+    asserts.fail(
+        f'{ad} got unknown request network callback {callback_name}.'
+    )
+  return network_callback_event
+
+def wait_for_link(
+    ad: android_device.AndroidDevice,
+    request_network_cb_handler: callback_handler_v2.CallbackHandlerV2,
+) -> callback_event.CallbackEvent:
+  """Waits for and verifies the establishment of a Wi-Fi Aware network."""
+  network_callback_event = request_network_cb_handler.waitAndGet(
+      event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+      timeout=_DEFAULT_TIMEOUT,
+  )
+  callback_name = network_callback_event.data[_CALLBACK_NAME]
+  if callback_name == constants.NetworkCbName.ON_UNAVAILABLE:
+    asserts.fail(
+        f'{ad} failed to request the network, got callback {callback_name}.'
+    )
+  elif callback_name == constants.NetworkCbName.ON_PROPERTIES_CHANGED:
+    iface_name = network_callback_event.data[
+        constants.NetworkCbEventKey.NETWORK_INTERFACE_NAME
+    ]
+    ad.log.info('interface name = %s', iface_name)
+  else:
+    asserts.fail(
+        f'{ad} got unknown request network callback {callback_name}.'
+    )
+  ad.log.info('type = %s', type(network_callback_event))
+  return network_callback_event
+
+
+def _wait_accept_success(
+    pub_accept_handler: callback_handler_v2.CallbackHandlerV2
+) -> None:
+    pub_accept_event = pub_accept_handler.waitAndGet(
+        event_name=constants.SnippetEventNames.SERVER_SOCKET_ACCEPT,
+        timeout=_DEFAULT_TIMEOUT
+    )
+    is_accept = pub_accept_event.data.get(constants.SnippetEventParams.IS_ACCEPT, False)
+    if not is_accept:
+        error = pub_accept_event.data[constants.SnippetEventParams.ERROR]
+        asserts.fail(
+            f'Publisher failed to accept the connection. Error: {error}'
+        )
+
+
+def _send_socket_msg(
+    sender_ad: android_device.AndroidDevice,
+    receiver_ad: android_device.AndroidDevice,
+    msg: str,
+    send_callback_id: str,
+    receiver_callback_id: str,
+):
+    """Sends a message from one device to another and verifies receipt."""
+    is_write_socket = sender_ad.wifi_aware_snippet.connectivityWriteSocket(
+        send_callback_id, msg
+    )
+    asserts.assert_true(
+        is_write_socket,
+        f'{sender_ad} Failed to write data to the socket.'
+    )
+    sender_ad.log.info('Wrote data to the socket.')
+    # Verify received message
+    received_message = receiver_ad.wifi_aware_snippet.connectivityReadSocket(
+        receiver_callback_id, len(msg)
+    )
+    asserts.assert_equal(
+        received_message,
+        msg,
+        f'{receiver_ad} received message mismatched.Failure:Expected {msg} but got '
+        f'{received_message}.'
+    )
+    receiver_ad.log.info('Read data from the socket.')
+
+
+def establish_socket_and_send_msg(
+    publisher: android_device.AndroidDevice,
+    subscriber: android_device.AndroidDevice,
+    pub_accept_handler: callback_handler_v2.CallbackHandlerV2,
+    network_id: str,
+    pub_local_port: int
+):
+    """Handles socket-based communication between publisher and subscriber."""
+    # Init socket
+    # Create a ServerSocket and makes it listen for client connections.
+    subscriber.wifi_aware_snippet.connectivityCreateSocketOverWiFiAware(
+        network_id, pub_local_port
+    )
+    _wait_accept_success(pub_accept_handler)
+    # Subscriber Send socket data
+    subscriber.log.info('Subscriber create a socket.')
+    _send_socket_msg(
+        sender_ad=subscriber,
+        receiver_ad=publisher,
+        msg=constants.WifiAwareTestConstants.MSG_CLIENT_TO_SERVER,
+        send_callback_id=network_id,
+        receiver_callback_id=network_id
+    )
+    _send_socket_msg(
+        sender_ad=publisher,
+        receiver_ad=subscriber,
+        msg=constants.WifiAwareTestConstants.MSG_SERVER_TO_CLIENT,
+        send_callback_id=network_id,
+        receiver_callback_id=network_id
+    )
+    publisher.wifi_aware_snippet.connectivityCloseWrite(network_id)
+    subscriber.wifi_aware_snippet.connectivityCloseWrite(network_id)
+    publisher.wifi_aware_snippet.connectivityCloseRead(network_id)
+    subscriber.wifi_aware_snippet.connectivityCloseRead(network_id)
+    logging.info('Communicated through socket connection of Wi-Fi Aware network successfully.')
+
+
+def run_ping6(dut: android_device.AndroidDevice, peer_ipv6: str):
+  """Run a ping6 over the specified device/link.
+
+  Args:
+    dut: Device on which to execute ping6.
+    peer_ipv6: Scoped IPv6 address of the peer to ping.
+  """
+  cmd = 'ping6 -c 3 -W 5 %s' % peer_ipv6
+  try:
+    dut.log.info(cmd)
+    results = dut.adb.shell(cmd)
+  except adb.AdbError:
+    time.sleep(1)
+    dut.log.info('CMD RETRY: %s', cmd)
+    results = dut.adb.shell(cmd)
+
+  dut.log.info("cmd='%s' -> '%s'", cmd, results)
+  if not results:
+    asserts.fail("ping6 empty results - seems like a failure")
diff --git a/tests/hostsidetests/multidevices/test/aware/aware_snippet_utils.py b/tests/hostsidetests/multidevices/test/aware/aware_snippet_utils.py
new file mode 100644
index 0000000000..bb7f1edeff
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/aware_snippet_utils.py
@@ -0,0 +1,501 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+"""Utility functions for interacting with the Wi-Fi Aware snippet RPCs."""
+
+import datetime
+import random
+
+from aware import constants
+from mobly import asserts
+from mobly.controllers import android_device
+from mobly.controllers.android_device_lib import callback_handler_v2
+from mobly.snippet import callback_event
+
+
+_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
+_REQUEST_NETWORK_TIMEOUT = datetime.timedelta(seconds=15)
+_CALLBACK_NAME = constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
+_IS_SESSION_INIT = constants.DiscoverySessionCallbackParamsType.IS_SESSION_INIT
+_TRANSPORT_TYPE_WIFI_AWARE = (
+    constants.NetworkCapabilities.Transport.TRANSPORT_WIFI_AWARE
+)
+
+
+def start_attach(
+    ad: android_device.AndroidDevice,
+    is_ranging_enabled: bool,
+) -> (str, str):
+    """Starts the attach process on the Android device.
+
+    Args:
+      ad: The Android device controller.
+      is_ranging_enabled: Whether to enable ranging.
+
+    Returns:
+      A tuple of the attach session ID and the mac address of the aware
+      interface. The mac address will be None if ranging is disabled.
+    """
+    attach_handler = ad.wifi.wifiAwareAttached(is_ranging_enabled)
+    attach_event = attach_handler.waitAndGet(
+        event_name=constants.AttachCallBackMethodType.ATTACHED,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    asserts.assert_true(
+        ad.wifi.wifiAwareIsSessionAttached(attach_event.callback_id),
+        f'{ad} attach succeeded, but Wi-Fi Aware session is still null.',
+    )
+    mac_address = None
+    if is_ranging_enabled:
+        identity_changed_event = attach_handler.waitAndGet(
+            event_name=constants.AttachCallBackMethodType.ID_CHANGED,
+            timeout=_DEFAULT_TIMEOUT,
+        )
+        mac_address = identity_changed_event.data.get('mac', None)
+        asserts.assert_true(
+            bool(mac_address), 'Mac address should not be empty'
+        )
+    ad.log.info(
+        'Attached Wi-Fi Aware session with ID %s and mac address %s.',
+        attach_event.callback_id,
+        mac_address,
+    )
+    return attach_event.callback_id, mac_address
+
+
+def publish_and_subscribe(
+    publisher: android_device.AndroidDevice,
+    pub_config: constants.PublishConfig,
+    pub_attach_session: str,
+    subscriber: android_device.AndroidDevice,
+    sub_config: constants.SubscribeConfig,
+    sub_attach_session: str,
+) -> tuple[
+    str,
+    callback_handler_v2.CallbackHandlerV2,
+    str,
+    callback_handler_v2.CallbackHandlerV2,
+    int,
+]:
+    """Creates discovery sessions and waits for service discovery.
+
+    This publishes a discovery session on the publisher, and subscribes to it
+    on the subscriber. After this method returns, the sessions are connected
+    and ready for further messaging.
+
+    Args:
+        publisher: The publisher.
+        pub_config: The publish disocvery session configuration.
+        pub_attach_session: The attach session ID of the publisher.
+        subscriber: The subscriber.
+        sub_config: The subscribe disocvery session configuration.
+        sub_attach_session: The attach session ID of the subscriber.
+
+    Returns:
+        A tuple of the publish session ID, the publish session handler, the
+        subscribe session ID, the subscribe session handler, and the peer ID
+        of the subscriber.
+    """
+    # Initialize discovery sessions (publish and subscribe).
+    pub_session_handler, pub_session = _start_publish(
+        publisher=publisher,
+        attach_session_id=pub_attach_session,
+        pub_config=pub_config,
+    )
+    sub_session_handler, sub_session = _start_subscribe(
+        subscriber=subscriber,
+        attach_session_id=sub_attach_session,
+        sub_config=sub_config,
+    )
+    # Wait for discovery.
+    subscriber_peer = _wait_for_discovery(
+        subscriber,
+        sub_session_handler,
+        pub_service_specific_info=pub_config.service_specific_info,
+        is_ranging_enabled=pub_config.ranging_enabled,
+    )
+    subscriber.log.info('The subscriber discovered the published service.')
+    return (
+        pub_session,
+        pub_session_handler,
+        sub_session,
+        sub_session_handler,
+        subscriber_peer,
+    )
+
+
+def _start_publish(
+    publisher: android_device.AndroidDevice,
+    attach_session_id: str,
+    pub_config: constants.PublishConfig,
+) -> tuple[callback_handler_v2.CallbackHandlerV2, str]:
+    """Starts a publish session on the publisher device.
+
+    Args:
+        publisher: The Android device controller of the publisher.
+        attach_session_id: The attach session ID of the publisher.
+        pub_config: The publish configuration.
+
+    Returns:
+        A tuple of the callback handler for the publish session and the
+        publish session ID.
+    """
+    # Start the publish session.
+    publish_handler = publisher.wifi.wifiAwarePublish(
+        attach_session_id, pub_config.to_dict()
+    )
+
+    # Wait for session start result.
+    discovery_event = publish_handler.waitAndGet(
+        event_name=constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    callback_name = discovery_event.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+        callback_name,
+        f'{publisher} publish failed, got callback: {callback_name}.',
+    )
+
+    is_session_init = discovery_event.data[_IS_SESSION_INIT]
+    asserts.assert_true(
+        is_session_init,
+        f'{publisher} publish succeeded, but null discovery session returned.',
+    )
+    publisher.log.info('Created the publish session.')
+    return publish_handler, publish_handler.callback_id
+
+
+def _start_subscribe(
+    subscriber: android_device.AndroidDevice,
+    attach_session_id: str,
+    sub_config: constants.SubscribeConfig,
+) -> tuple[callback_handler_v2.CallbackHandlerV2, str]:
+    """Starts a subscribe session on the subscriber device.
+
+    Args:
+        subscriber: The Android device controller of the subscriber.
+        attach_session_id: The attach session ID of the subscriber.
+        sub_config: The subscribe configuration.
+
+    Returns:
+        A tuple of the callback handler for the subscribe session and the
+        subscribe session ID.
+    """
+    # Start the subscribe session.
+    subscribe_handler = subscriber.wifi.wifiAwareSubscribe(
+        attach_session_id, sub_config.to_dict()
+    )
+
+    # Wait for session start result.
+    discovery_event = subscribe_handler.waitAndGet(
+        event_name=constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    callback_name = discovery_event.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+        callback_name,
+        f'{subscriber} subscribe failed, got callback: {callback_name}.',
+    )
+    is_session_init = discovery_event.data[_IS_SESSION_INIT]
+    asserts.assert_true(
+        is_session_init,
+        f'{subscriber} subscribe succeeded, but null session returned.',
+    )
+    subscriber.log.info('Created subscribe session.')
+    return subscribe_handler, subscribe_handler.callback_id
+
+
+def _wait_for_discovery(
+    subscriber: android_device.AndroidDevice,
+    sub_session_handler: callback_handler_v2.CallbackHandlerV2,
+    pub_service_specific_info: bytes,
+    is_ranging_enabled: bool,
+) -> int:
+    """Waits for discovery of the publisher's service by the subscriber.
+
+    Args:
+        subscriber: The Android device controller of the subscriber.
+        sub_session_handler: The callback handler for the subscribe session.
+        pub_service_specific_info: The service info set on the publisher.
+        is_ranging_enabled: Whether the publisher has ranging enabled.
+
+    Returns:
+        The peer ID of the publisher as seen on the subscriber.
+    """
+    event_name = constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED
+    if is_ranging_enabled:
+        event_name = (
+            constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED_WITHIN_RANGE
+        )
+    discover_data = sub_session_handler.waitAndGet(
+        event_name=event_name, timeout=_DEFAULT_TIMEOUT
+    )
+
+    service_info = bytes(
+        discover_data.data[
+            constants.WifiAwareSnippetParams.SERVICE_SPECIFIC_INFO
+        ]
+    )
+    asserts.assert_equal(
+        service_info,
+        pub_service_specific_info,
+        f'{subscriber} got unexpected service info in discovery'
+        f' callback event "{event_name}".',
+    )
+    match_filters = discover_data.data[
+        constants.WifiAwareSnippetParams.MATCH_FILTER
+    ]
+    match_filters = [
+        bytes(filter[constants.WifiAwareSnippetParams.MATCH_FILTER_VALUE])
+        for filter in match_filters
+    ]
+    asserts.assert_equal(
+        match_filters,
+        [constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
+        f'{subscriber} got unexpected match filter data in discovery'
+        f' callback event "{event_name}".',
+    )
+    return discover_data.data[constants.WifiAwareSnippetParams.PEER_ID]
+
+
+def send_msg_through_discovery_session(
+    sender: android_device.AndroidDevice,
+    sender_discovery_session_handler: callback_handler_v2.CallbackHandlerV2,
+    receiver: android_device.AndroidDevice,
+    receiver_discovery_session_handler: callback_handler_v2.CallbackHandlerV2,
+    discovery_session: str,
+    peer_on_sender: int,
+    send_message: str,
+    send_message_id: int | None = None,
+) -> int:
+    """Sends a message through a discovery session and verifies receipt.
+
+    Args:
+        sender: The Android device controller of the sender.
+        sender_discovery_session_handler: The callback handler for the sender's
+            discovery session.
+        receiver: The Android device controller of the receiver.
+        receiver_discovery_session_handler: The callback handler for the
+            receiver's discovery session.
+        discovery_session: The discovery session ID.
+        peer_on_sender: The peer ID of the receiver as seen on the sender.
+        send_message: The message to send.
+        send_message_id: The message ID. If not provided, a random ID will be
+            generated.
+
+    Returns:
+        The peer ID of the sender as seen on the receiver.
+    """
+    send_message_id = send_message_id or random.randint(1000, 5000)
+    sender.wifi.wifiAwareSendMessage(
+        discovery_session, peer_on_sender, send_message_id, send_message
+    )
+    message_send_result = sender_discovery_session_handler.waitAndGet(
+        event_name=constants.DiscoverySessionCallbackMethodType.MESSAGE_SEND_RESULT,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    callback_name = message_send_result.data[
+        constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
+    ]
+    asserts.assert_equal(
+        callback_name,
+        constants.DiscoverySessionCallbackMethodType.MESSAGE_SEND_SUCCEEDED,
+        f'{sender} failed to send message with an unexpected callback.',
+    )
+    actual_send_message_id = message_send_result.data[
+        constants.DiscoverySessionCallbackParamsType.MESSAGE_ID
+    ]
+    asserts.assert_equal(
+        actual_send_message_id,
+        send_message_id,
+        f'{sender} send message succeeded but message ID mismatched.',
+    )
+    receive_message_event = receiver_discovery_session_handler.waitAndGet(
+        event_name=constants.DiscoverySessionCallbackMethodType.MESSAGE_RECEIVED,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    received_message_raw = receive_message_event.data[
+        constants.WifiAwareSnippetParams.RECEIVED_MESSAGE
+    ]
+    received_message = bytes(received_message_raw).decode('utf-8')
+    asserts.assert_equal(
+        received_message,
+        send_message,
+        f'{receiver} received the message but message content mismatched.',
+    )
+    return receive_message_event.data[constants.WifiAwareSnippetParams.PEER_ID]
+
+
+def create_server_socket(
+    publisher: android_device.AndroidDevice,
+):
+    """Creates a server socket listening on a local port."""
+    server_accept_handler = publisher.wifi.connectivityServerSocketAccept()
+    network_id = server_accept_handler.callback_id
+    server_local_port = server_accept_handler.ret_value
+    return server_accept_handler, network_id, server_local_port
+
+
+def request_aware_network(
+    ad: android_device.AndroidDevice,
+    discovery_session: str,
+    peer: int,
+    network_id: str,
+    network_specifier_params: constants.WifiAwareNetworkSpecifier,
+    is_accept_any_peer: bool = False,
+) -> callback_handler_v2.CallbackHandlerV2:
+    """Sends the command to request a Wi-Fi Aware network.
+
+    This does not wait for the network to be established.
+
+    Args:
+        ad: The Android device controller.
+        discovery_session: The discovery session ID.
+        peer: The ID of the peer to establish a Wi-Fi Aware connection with.
+        network_id: The network ID.
+        network_specifier_params: The network specifier parameters.
+        is_accept_any_peer: Whether to accept any peer. If True, the argument
+            peer will be ignored.
+
+    Returns:
+        The callback handler for querying the network status.
+    """
+    network_specifier_parcel = ad.wifi.wifiAwareCreateNetworkSpecifier(
+        discovery_session,
+        peer,
+        is_accept_any_peer,
+        network_specifier_params.to_dict(),
+    )
+    network_request = constants.NetworkRequest(
+        transport_type=_TRANSPORT_TYPE_WIFI_AWARE,
+        network_specifier_parcel=network_specifier_parcel,
+    )
+    ad.log.debug('Requesting Wi-Fi Aware network: %r', network_request)
+    return ad.wifi.connectivityRequestNetwork(
+        network_id,
+        network_request.to_dict(),
+        _REQUEST_NETWORK_TIMEOUT.total_seconds() * 1000,
+    )
+
+
+def wait_for_aware_network(
+    ad: android_device.AndroidDevice,
+    request_network_handler: callback_handler_v2.CallbackHandlerV2,
+) -> callback_event.CallbackEvent:
+    """Waits for and verifies the establishment of a Wi-Fi Aware network.
+
+    Args:
+        ad: The Android device controller.
+        request_network_handler: The callback handler for requesting network.
+
+    Returns:
+        The callback event for network capabilities changed event, providing
+        information of the new network connection.
+    """
+    network_callback_event = request_network_handler.waitAndGet(
+        event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    callback_name = network_callback_event.data[_CALLBACK_NAME]
+    if callback_name == constants.NetworkCbName.ON_UNAVAILABLE:
+        asserts.fail(
+            f'{ad} failed to request the network, got callback'
+            f' {callback_name}.'
+        )
+    elif callback_name == constants.NetworkCbName.ON_CAPABILITIES_CHANGED:
+        # `network` is the network whose capabilities have changed.
+        network = network_callback_event.data[
+            constants.NetworkCbEventKey.NETWORK
+        ]
+        network_capabilities = network_callback_event.data[
+            constants.NetworkCbEventKey.NETWORK_CAPABILITIES
+        ]
+        asserts.assert_true(
+            network and network_capabilities,
+            f'{ad} received a null Network or NetworkCapabilities!?.',
+        )
+        transport_info_class_name = network_callback_event.data[
+            constants.NetworkCbEventKey.TRANSPORT_INFO_CLASS_NAME
+        ]
+        asserts.assert_equal(
+            transport_info_class_name,
+            constants.AWARE_NETWORK_INFO_CLASS_NAME,
+            f'{ad} network capabilities changes but it is not a WiFi Aware'
+            ' network.',
+        )
+        return network_callback_event
+    else:
+        asserts.fail(
+            f'{ad} got unknown request network callback {callback_name}.'
+        )
+
+
+def establish_socket_connection(
+    publisher: android_device.AndroidDevice,
+    subscriber: android_device.AndroidDevice,
+    pub_accept_handler: callback_handler_v2.CallbackHandlerV2,
+    network_id: str,
+    pub_local_port: int,
+):
+    """Establishes a socket connection between the publisher and subscriber.
+
+    Args:
+        publisher: The publisher.
+        subscriber: The subscriber.
+        pub_accept_handler: The callback handler returned when the publisher
+            called snippet RPC `connectivityServerSocketAccept`.
+        network_id: The network ID.
+        pub_local_port: The local port of the publisher's server socket.
+    """
+    subscriber.wifi.connectivityCreateSocketOverWiFiAware(
+        network_id, pub_local_port
+    )
+    pub_accept_event = pub_accept_handler.waitAndGet(
+        event_name=constants.SnippetEventNames.SERVER_SOCKET_ACCEPT,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    is_accept = pub_accept_event.data.get(
+        constants.SnippetEventParams.IS_ACCEPT, False
+    )
+    if not is_accept:
+        error = pub_accept_event.data[constants.SnippetEventParams.ERROR]
+        asserts.fail(
+            f'{publisher} Failed to accept the connection. Error: {error}'
+        )
+    subscriber.log.info('Subscriber created a socket to the publisher.')
+
+
+def send_socket_msg(
+    sender_ad: android_device.AndroidDevice,
+    receiver_ad: android_device.AndroidDevice,
+    msg: str,
+    network_id: str,
+):
+    """Sends a message from one device to another and verifies receipt."""
+    is_write_socket = sender_ad.wifi.connectivityWriteSocket(network_id, msg)
+    asserts.assert_true(
+        is_write_socket, f'{sender_ad} Failed to write data to the socket.'
+    )
+    sender_ad.log.info('Wrote data to the socket.')
+    received_message = receiver_ad.wifi.connectivityReadSocket(
+        network_id, len(msg)
+    )
+    asserts.assert_equal(
+        received_message,
+        msg,
+        f'{receiver_ad} received message mismatched.Failure:Expected {msg} but '
+        f'got {received_message}.',
+    )
+    receiver_ad.log.info('Read data from the socket.')
diff --git a/tests/hostsidetests/multidevices/test/aware/constants.py b/tests/hostsidetests/multidevices/test/aware/constants.py
index 9742b436d5..64d9b384b7 100644
--- a/tests/hostsidetests/multidevices/test/aware/constants.py
+++ b/tests/hostsidetests/multidevices/test/aware/constants.py
@@ -15,73 +15,82 @@
 # Lint as: python3
 """Constants for Wifi-Aware Mobly test"""
 
-import enum
 import dataclasses
 import datetime
+import enum
 import operator
 
 from mobly import utils
 
 # Package name for the Wi-Fi Aware snippet application
-WIFI_AWARE_SNIPPET_PACKAGE_NAME = "com.google.snippet.wifi.aware"
-WIFI_SNIPPET_PACKAGE_NAME = "com.google.snippet.wifi"
+WIFI_AWARE_SNIPPET_PACKAGE_NAME = 'com.google.snippet.wifi.aware'
+WIFI_SNIPPET_PACKAGE_NAME = 'com.google.snippet.wifi'
 # Timeout duration for Wi-Fi state change operations
 WAIT_WIFI_STATE_TIME_OUT = datetime.timedelta(seconds=30)
-AWARE_NETWORK_INFO_CLASS_NAME = "android.net.wifi.aware.WifiAwareNetworkInfo"
-
-SERVICE_NAME = "service_name"
-SERVICE_SPECIFIC_INFO = "service_specific_info"
-MATCH_FILTER = "match_filter"
-MATCH_FILTER_LIST = "MatchFilterList"
-SUBSCRIBE_TYPE = "subscribe_type"
-PUBLISH_TYPE = "publish_type"
-TERMINATE_NOTIFICATION_ENABLED = "terminate_notification_enabled"
-MAX_DISTANCE_MM = "max_distance_mm"
-PAIRING_CONFIG = "pairing_config"
-AWARE_NETWORK_INFO_CLASS_NAME = "android.net.wifi.aware.WifiAwareNetworkInfo"
-TTL_SEC = "TtlSec"
-INSTANTMODE_ENABLE = "InstantModeEnabled"
-FEATURE_WIFI_AWARE = "feature:android.hardware.wifi.aware"
-
-#onServiceLost reason code
+AWARE_NETWORK_INFO_CLASS_NAME = 'android.net.wifi.aware.WifiAwareNetworkInfo'
+
+SERVICE_NAME = 'service_name'
+SERVICE_SPECIFIC_INFO = 'service_specific_info'
+MATCH_FILTER = 'match_filter'
+MATCH_FILTER_LIST = 'MatchFilterList'
+SUBSCRIBE_TYPE = 'subscribe_type'
+PUBLISH_TYPE = 'publish_type'
+TERMINATE_NOTIFICATION_ENABLED = 'terminate_notification_enabled'
+MAX_DISTANCE_MM = 'max_distance_mm'
+PAIRING_CONFIG = 'pairing_config'
+AWARE_NETWORK_INFO_CLASS_NAME = 'android.net.wifi.aware.WifiAwareNetworkInfo'
+TTL_SEC = 'TtlSec'
+INSTANTMODE_ENABLE = 'InstantModeEnabled'
+FEATURE_WIFI_AWARE = 'feature:android.hardware.wifi.aware'
+DISCOVERY_KEY_RANGING_ENABLED = 'ranging_enabled'
+DISCOVERY_KEY_MIN_DISTANCE_MM = 'MinDistanceMm'
+DISCOVERY_KEY_MAX_DISTANCE_MM = 'MaxDistanceMm'
+
+
+# onServiceLost reason code
 EASON_PEER_NOT_VISIBLE = 1
 
+
 class WifiAwareTestConstants:
     """Constants for Wi-Fi Aware test."""
-    SERVICE_NAME = "CtsVerifierTestService"
-    MATCH_FILTER_BYTES = "bytes used for matching".encode("utf-8")
-    PUB_SSI = "Extra bytes in the publisher discovery".encode("utf-8")
-    SUB_SSI = "Arbitrary bytes for the subscribe discovery".encode("utf-8")
+
+    SERVICE_NAME = 'CtsVerifierTestService'
+    MATCH_FILTER_BYTES = 'bytes used for matching'.encode('utf-8')
+    PUB_SSI = 'Extra bytes in the publisher discovery'.encode('utf-8')
+    SUB_SSI = 'Arbitrary bytes for the subscribe discovery'.encode('utf-8')
     LARGE_ENOUGH_DISTANCE_MM = 100000
-    PASSWORD = "Some super secret password"
-    ALIAS_PUBLISH = "publisher"
-    ALIAS_SUBSCRIBE = "subscriber"
+    PASSWORD = 'Some super secret password'
+    ALIAS_PUBLISH = 'publisher'
+    ALIAS_SUBSCRIBE = 'subscriber'
     TEST_WAIT_DURATION_MS = 10000
-    TEST_MESSAGE = "test message!"
+    TEST_MESSAGE = 'test message!'
     MESSAGE_ID = 1234
-    MSG_CLIENT_TO_SERVER = 'GET SOME BYTES [Random Identifier: %s]' % utils.rand_ascii_str(5)
-    MSG_SERVER_TO_CLIENT = 'PUT SOME OTHER BYTES [Random Identifier: %s]' % utils.rand_ascii_str(5)
-    PMK = "01234567890123456789012345678901"
+    MSG_CLIENT_TO_SERVER = (
+        'GET SOME BYTES [Random Identifier: %s]' % utils.rand_ascii_str(5)
+    )
+    MSG_SERVER_TO_CLIENT = (
+        'PUT SOME OTHER BYTES [Random Identifier: %s]' % utils.rand_ascii_str(5)
+    )
+    PMK = '01234567890123456789012345678901'
     # 6 == TCP
     TRANSPORT_PROTOCOL_TCP = 6
     CHANNEL_IN_MHZ = 5745
 
 
-
 @enum.unique
 class WifiAwareSnippetEventName(enum.StrEnum):
     """Represents event names for Wi-Fi Aware snippet operations."""
 
-    GET_PAIRED_DEVICE = "getPairedDevices"
-    ON_AVAILABLE = "onAvailable"
-    ON_LOST = "onLost"
+    GET_PAIRED_DEVICE = 'getPairedDevices'
+    ON_AVAILABLE = 'onAvailable'
+    ON_LOST = 'onLost'
 
 
 @enum.unique
 class WifiAwareSnippetParams(enum.StrEnum):
     """Represents parameters for Wi-Fi Aware snippet events."""
 
-    ALIAS_LIST = "getPairedDevices"
+    ALIAS_LIST = 'getPairedDevices'
 
 
 @enum.unique
@@ -92,54 +101,58 @@ class DiscoverySessionCallbackMethodType(enum.StrEnum):
     https://developer.android.com/reference/android/net/wifi/aware/DiscoverySessionCallback
     """
 
-    PUBLISH_STARTED = "onPublishStarted"
-    SUBSCRIBE_STARTED = "onSubscribeStarted"
-    SESSION_CONFIG_UPDATED = "onSessionConfigUpdated"
-    SESSION_CONFIG_FAILED = "onSessionConfigFailed"
-    SESSION_TERMINATED = "onSessionTerminated"
-    SERVICE_DISCOVERED = "onServiceDiscovered"
-    SERVICE_DISCOVERED_WITHIN_RANGE = "onServiceDiscoveredWithinRange"
-    MESSAGE_SEND_SUCCEEDED = "onMessageSendSucceeded"
-    MESSAGE_SEND_FAILED = "onMessageSendFailed"
-    MESSAGE_RECEIVED = "onMessageReceived"
-    PAIRING_REQUEST_RECEIVED = "onPairingSetupRequestReceived"
-    PAIRING_SETUP_SUCCEEDED = "onPairingSetupSucceeded"
-    PAIRING_SETUP_FAILED = "onPairingSetupFailed"
-    PAIRING_VERIFICATION_SUCCEEDED = "onPairingVerificationSucceed"
-    PAIRING_VERIFICATION_FAILED = "onPairingVerificationFailed"
-    BOOTSTRAPPING_SUCCEEDED = "onBootstrappingSucceeded"
-    BOOTSTRAPPING_FAILED = "onBootstrappingFailed"
+    PUBLISH_STARTED = 'onPublishStarted'
+    SUBSCRIBE_STARTED = 'onSubscribeStarted'
+    SESSION_CONFIG_UPDATED = 'onSessionConfigUpdated'
+    SESSION_CONFIG_FAILED = 'onSessionConfigFailed'
+    SESSION_TERMINATED = 'onSessionTerminated'
+    SERVICE_DISCOVERED = 'onServiceDiscovered'
+    SERVICE_DISCOVERED_WITHIN_RANGE = 'onServiceDiscoveredWithinRange'
+    MESSAGE_SEND_SUCCEEDED = 'onMessageSendSucceeded'
+    MESSAGE_SEND_FAILED = 'onMessageSendFailed'
+    MESSAGE_RECEIVED = 'onMessageReceived'
+    PAIRING_REQUEST_RECEIVED = 'onPairingSetupRequestReceived'
+    PAIRING_SETUP_SUCCEEDED = 'onPairingSetupSucceeded'
+    PAIRING_SETUP_FAILED = 'onPairingSetupFailed'
+    PAIRING_VERIFICATION_SUCCEEDED = 'onPairingVerificationSucceed'
+    PAIRING_VERIFICATION_FAILED = 'onPairingVerificationFailed'
+    BOOTSTRAPPING_SUCCEEDED = 'onBootstrappingSucceeded'
+    BOOTSTRAPPING_FAILED = 'onBootstrappingFailed'
     # Event for the publish or subscribe step: triggered by onPublishStarted or SUBSCRIBE_STARTED or
     # onSessionConfigFailed
-    DISCOVER_RESULT = "discoveryResult"
+    DISCOVER_RESULT = 'discoveryResult'
     # Event for the message send result.
-    MESSAGE_SEND_RESULT = "messageSendResult"
-    SESSION_CB_ON_SERVICE_LOST = "WifiAwareSessionOnServiceLost"
-    SESSION_CB_KEY_LOST_REASON = "lostReason"
+    MESSAGE_SEND_RESULT = 'messageSendResult'
+    SESSION_CB_ON_SERVICE_LOST = 'WifiAwareSessionOnServiceLost'
+    SESSION_CB_KEY_LOST_REASON = 'lostReason'
 
 
 @enum.unique
 class DiscoverySessionCallbackParamsType(enum.StrEnum):
-    CALLBACK_NAME = "callbackName"
-    IS_SESSION_INIT = "isSessionInitialized"
-    MESSAGE_ID = "messageId"
-    RECEIVE_MESSAGE = "receivedMessage"
+    CALLBACK_NAME = 'callbackName'
+    IS_SESSION_INIT = 'isSessionInitialized'
+    MESSAGE_ID = 'messageId'
+    RECEIVE_MESSAGE = 'receivedMessage'
 
 
 @enum.unique
 class NetworkCbEventName(enum.StrEnum):
     """Represents the event name for ConnectivityManager network callbacks."""
-    NETWORK_CALLBACK = "NetworkCallback"
+
+    NETWORK_CALLBACK = 'NetworkCallback'
+    NETWORK_CB_LOST = 'CallbackLost'
 
 
 @enum.unique
 class NetworkCbEventKey(enum.StrEnum):
     """Represents event data keys for ConnectivityManager network callbacks."""
-    NETWORK = "network"
-    CALLBACK_NAME = "callbackName"
-    NETWORK_CAPABILITIES = "networkCapabilities"
-    TRANSPORT_INFO_CLASS_NAME = "transportInfoClassName"
-    CHANNEL_IN_MHZ = "channelInMhz"
+
+    NETWORK = 'network'
+    CALLBACK_NAME = 'callbackName'
+    NETWORK_CAPABILITIES = 'networkCapabilities'
+    TRANSPORT_INFO_CLASS_NAME = 'transportInfoClassName'
+    CHANNEL_IN_MHZ = 'channelInMhz'
+    NETWORK_INTERFACE_NAME = 'interfaceName'
 
 
 @enum.unique
@@ -149,8 +162,13 @@ class NetworkCbName(enum.StrEnum):
     These callbacks are correspond to DiscoverySessionCallback in the Android documentation:
     https://developer.android.com/reference/android/net/ConnectivityManager.NetworkCallback
     """
-    ON_UNAVAILABLE = "onUnavailable"
-    ON_CAPABILITIES_CHANGED = "onCapabilitiesChanged"
+
+    ON_UNAVAILABLE = 'onUnavailable'
+    ON_CAPABILITIES_CHANGED = 'onCapabilitiesChanged'
+    ON_PROPERTIES_CHANGED = 'onLinkPropertiesChanged'
+    NET_CAP_IPV6 = 'aware_ipv6'
+    NET_CAP_PORT = 'port'
+    NET_CAP_TRANSPORT_PROTOCOL = 'aware_transport_protocol'
 
 
 @enum.unique
@@ -159,47 +177,64 @@ class RangingResultCb(enum.StrEnum):
 
     # Callback methods related to RangingResultCallback:
     # https://developer.android.com/reference/android/net/wifi/rtt/RangingResultCallback
-    CB_METHOD_ON_RANGING_RESULT = "onRangingResults"
-    CB_METHOD_ON_RANGING_FAILURE = "onRangingFailure"
+    CB_METHOD_ON_RANGING_RESULT = 'onRangingResults'
+    CB_METHOD_ON_RANGING_FAILURE = 'onRangingFailure'
 
     # Other constants related to snippet implementation.
-    EVENT_NAME_ON_RANGING_RESULT = "WifiRttRangingOnRangingResult"
-    DATA_KEY_CALLBACK_NAME = "callbackName"
+    EVENT_NAME_ON_RANGING_RESULT = 'WifiRttRangingOnRangingResult'
+    DATA_KEY_CALLBACK_NAME = 'callbackName'
     DATA_KEY_RESULTS = 'results'
     DATA_KEY_RESULT_STATUS = 'status'
     DATA_KEY_RESULT_DISTANCE_MM = 'distanceMm'
     DATA_KEY_RESULT_RSSI = 'rssi'
     DATA_KEY_PEER_ID = 'peerId'
     DATA_KEY_MAC = 'mac'
+    DATA_KEY_DISTANCE_STD_DEV_MM = 'distanceStdDevMm'
+    DATA_KEY_NUM_ATTEMPTED_MEASUREMENTS = 'numAttemptedMeasurements'
+    DATA_KEY_NUM_SUCCESSFUL_MEASUREMENTS = 'numSuccessfulMeasurements'
+    DATA_KEY_LCI = 'lci'
+    DATA_KEY_LCR = 'lcr'
+    DATA_KEY_TIMESTAMP = 'timestamp'
+    DATA_KEY_MAC_AS_STRING = 'macAsString'
+
+
+@enum.unique
+class RangingStatusCb(enum.IntEnum):
+    """Constant for handling RTT status."""
+
+    EVENT_CB_RANGING_STATUS_SUCCESS = 0
+    EVENT_CB_RANGING_STATUS_FAIL = 1
+    EVENT_CB_RANGING_STATUS_RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC = 2
 
 
 @enum.unique
 class RangingResultStatusCode(enum.IntEnum):
-  """Ranging result status code.
+    """Ranging result status code.
 
-  This corresponds to status constants in RangingRequest:
-  https://developer.android.com/reference/android/net/wifi/rtt/RangingResult
-  """
+    This corresponds to status constants in RangingRequest:
+    https://developer.android.com/reference/android/net/wifi/rtt/RangingResult
+    """
 
-  SUCCESS = 0
-  FAIL = 1
-  RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC = 2
+    SUCCESS = 0
+    FAIL = 1
+    RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC = 2
 
 
 @enum.unique
 class WifiAwareSnippetParams(enum.StrEnum):
     """Represents parameters for Wi-Fi Aware snippet events."""
-    SERVICE_SPECIFIC_INFO = "serviceSpecificInfo"
-    RECEIVED_MESSAGE = "receivedMessage"
-    PEER_HANDLE = "peerHandle"
-    MATCH_FILTER = "matchFilter"
-    MATCH_FILTER_VALUE = "value"
-    PAIRING_CONFIG = "pairingConfig"
-    DISTANCE_MM = "distanceMm"
-    LAST_MESSAGE_ID = "lastMessageId"
-    PAIRING_REQUEST_ID = "pairingRequestId"
-    BOOTSTRAPPING_METHOD = "bootstrappingMethod"
-    PEER_ID = "peerId"
+
+    SERVICE_SPECIFIC_INFO = 'serviceSpecificInfo'
+    RECEIVED_MESSAGE = 'receivedMessage'
+    PEER_HANDLE = 'peerHandle'
+    MATCH_FILTER = 'matchFilter'
+    MATCH_FILTER_VALUE = 'value'
+    PAIRING_CONFIG = 'pairingConfig'
+    DISTANCE_MM = 'distanceMm'
+    LAST_MESSAGE_ID = 'lastMessageId'
+    PAIRING_REQUEST_ID = 'pairingRequestId'
+    BOOTSTRAPPING_METHOD = 'bootstrappingMethod'
+    PEER_ID = 'peerId'
 
 
 @enum.unique
@@ -233,6 +268,7 @@ class BootstrappingMethod(enum.IntEnum):
     documentation:
     https://developer.android.com/reference/android/net/wifi/aware/AwarePairingConfig#summary
     """
+
     OPPORTUNISTIC = 1
     PIN_CODE_DISPLAY = 2
     PASSPHRASE_DISPLAY = 4
@@ -251,14 +287,17 @@ class AwarePairingConfig:
     These configurations correspond to AwarePairingConfig in the Android documentation:
     https://developer.android.com/reference/android/net/wifi/aware/AwarePairingConfig?hl=en
     """
+
     pairing_cache_enabled: bool = False
     pairing_setup_enabled: bool = False
     pairing_verification_enabled: bool = False
-    bootstrapping_methods: BootstrappingMethod = BootstrappingMethod.OPPORTUNISTIC
+    bootstrapping_methods: BootstrappingMethod = (
+        BootstrappingMethod.OPPORTUNISTIC
+    )
 
     def to_dict(self) -> dict[str, int | bool]:
         result = dataclasses.asdict(self)
-        result["bootstrapping_methods"] = self.bootstrapping_methods.value
+        result['bootstrapping_methods'] = self.bootstrapping_methods.value
         return result
 
 
@@ -269,31 +308,44 @@ class SubscribeConfig:
     These configurations correspond to SubscribeConfig in the Android documentation:
     https://developer.android.com/reference/android/net/wifi/aware/SubscribeConfig
     """
+
     subscribe_type: SubscribeType
     service_specific_info: bytes = WifiAwareTestConstants.SUB_SSI
-    match_filter: list[bytes] | None = (WifiAwareTestConstants.MATCH_FILTER_BYTES, )
+    match_filter: list[bytes] | None = (
+        WifiAwareTestConstants.MATCH_FILTER_BYTES,
+    )
+    min_distance_mm: int | None = None
     max_distance_mm: int | None = None
     pairing_config: AwarePairingConfig | None = None
     terminate_notification_enabled: bool = True
     service_name: str = WifiAwareTestConstants.SERVICE_NAME
 
-    def to_dict(self) -> dict[str, str | bool | list[str] | int | dict[str, int | bool | None]]:
+    def to_dict(
+        self,
+    ) -> dict[str, str | bool | list[str] | int | dict[str, int | bool | None]]:
         result = dataclasses.asdict(self)
-        result["subscribe_type"] = self.subscribe_type.value
-        result["service_specific_info"] = self.service_specific_info.decode("utf-8")
+        result['subscribe_type'] = self.subscribe_type.value
+        result['service_specific_info'] = self.service_specific_info.decode(
+            'utf-8'
+        )
 
         if self.match_filter is None:
-            del result["match_filter"]
+            del result['match_filter']
         else:
-            result["match_filter"] = [mf.decode("utf-8") for mf in self.match_filter]
+            result['match_filter'] = [
+                mf.decode('utf-8') for mf in self.match_filter
+            ]
 
         if self.pairing_config is None:
-            del result["pairing_config"]
+            del result['pairing_config']
         else:
-            result["pairing_config"] = self.pairing_config.to_dict()
+            result['pairing_config'] = self.pairing_config.to_dict()
 
         if self.max_distance_mm is None:
-            del result["max_distance_mm"]
+            del result['max_distance_mm']
+
+        if self.min_distance_mm is None:
+            del result["min_distance_mm"]
 
         return result
 
@@ -305,9 +357,12 @@ class PublishConfig:
     These configurations correspond to PublishConfig in the Android documentation:
     https://developer.android.com/reference/android/net/wifi/aware/PublishConfig
     """
+
     publish_type: PublishType
     service_specific_info: bytes = WifiAwareTestConstants.PUB_SSI
-    match_filter: list[bytes] | None = (WifiAwareTestConstants.MATCH_FILTER_BYTES, )
+    match_filter: list[bytes] | None = (
+        WifiAwareTestConstants.MATCH_FILTER_BYTES,
+    )
     ranging_enabled: bool = False
     terminate_notification_enabled: bool = True
     pairing_config: AwarePairingConfig | None = None
@@ -318,17 +373,21 @@ class PublishConfig:
     ) -> dict:
         """Convert PublishConfig to dict."""
         result = dataclasses.asdict(self)
-        result["publish_type"] = self.publish_type.value
-        result["service_specific_info"] = self.service_specific_info.decode("utf-8")
+        result['publish_type'] = self.publish_type.value
+        result['service_specific_info'] = self.service_specific_info.decode(
+            'utf-8'
+        )
         if self.match_filter is None:
-            del result["match_filter"]
+            del result['match_filter']
         else:
-            result["match_filter"] = [mf.decode("utf-8") for mf in self.match_filter]
+            result['match_filter'] = [
+                mf.decode('utf-8') for mf in self.match_filter
+            ]
 
         if self.pairing_config is None:
-            del result["pairing_config"]
+            del result['pairing_config']
         else:
-            result["pairing_config"] = self.pairing_config.to_dict()
+            result['pairing_config'] = self.pairing_config.to_dict()
         return result
 
 
@@ -369,6 +428,7 @@ class NetworkCapabilities:
 
         https://developer.android.com/reference/android/net/NetworkCapabilities#TRANSPORT_CELLULAR
         """
+
         TRANSPORT_CELLULAR = 0
         TRANSPORT_WIFI = 1
         TRANSPORT_BLUETOOTH = 2
@@ -382,6 +442,7 @@ class NetworkCapabilities:
 
         https://developer.android.com/reference/android/net/NetworkCapabilities#NET_CAPABILITY_MMS
         """
+
         NET_CAPABILITY_MMS = 0
         NET_CAPABILITY_SUPL = 1
         NET_CAPABILITY_DUN = 2
@@ -426,15 +487,16 @@ class NetworkRequest:
 
     https://developer.android.com/reference/android/net/NetworkRequest
     """
+
     transport_type: NetworkCapabilities.Transport
     network_specifier_parcel: str
 
     def to_dict(self) -> dict:
         result = dataclasses.asdict(self)
         if not self.network_specifier_parcel:
-            del result["network_specifier_parcel"]
+            del result['network_specifier_parcel']
         if self.transport_type:
-            result["transport_type"] = self.transport_type.value
+            result['transport_type'] = self.transport_type.value
         return result
 
 
@@ -443,6 +505,7 @@ class Characteristics(enum.IntEnum):
 
     https://developer.android.com/reference/android/net/wifi/aware/Characteristics
     """
+
     WIFI_AWARE_CIPHER_SUITE_NCS_SK_128 = 1
 
 
@@ -452,17 +515,20 @@ class WifiAwareDataPathSecurityConfig:
 
     https://developer.android.com/reference/android/net/wifi/aware/WifiAwareNetworkSpecifier
     """
+
     pmk: str | None = None
-    cipher_suite: Characteristics | None = Characteristics.WIFI_AWARE_CIPHER_SUITE_NCS_SK_128
+    cipher_suite: Characteristics | None = (
+        Characteristics.WIFI_AWARE_CIPHER_SUITE_NCS_SK_128
+    )
 
     def to_dict(self) -> dict:
         result = dataclasses.asdict(self)
         if not self.pmk:
-            del result["pmk"]
+            del result['pmk']
         if not self.cipher_suite:
-            del result["cipher_suite"]
+            del result['cipher_suite']
         else:
-            result["cipher_suite"] = self.cipher_suite.value
+            result['cipher_suite'] = self.cipher_suite.value
         return result
 
 
@@ -472,6 +538,7 @@ class WifiAwareNetworkSpecifier:
 
     https://developer.android.com/reference/android/net/wifi/aware/WifiAwareNetworkSpecifier
     """
+
     psk_passphrase: str | None = None
     port: int | None = None
     transport_protocol: int | None = None
@@ -482,33 +549,36 @@ class WifiAwareNetworkSpecifier:
     def to_dict(self) -> dict:
         result = dataclasses.asdict(self)
         if not self.psk_passphrase:
-            del result["psk_passphrase"]
+            del result['psk_passphrase']
         if not self.port:
-            del result["port"]
+            del result['port']
         if not self.transport_protocol:
-            del result["transport_protocol"]
+            del result['transport_protocol']
         if not self.pmk:
-            del result["pmk"]
+            del result['pmk']
         if not self.data_path_security_config:
-            del result["data_path_security_config"]
+            del result['data_path_security_config']
         else:
-            result["data_path_security_config"] = self.data_path_security_config.to_dict()
+            result['data_path_security_config'] = (
+                self.data_path_security_config.to_dict()
+            )
         if not self.channel_frequency_m_hz:
-            del result["channel_frequency_m_hz"]
+            del result['channel_frequency_m_hz']
         return result
 
 
 class SnippetEventNames:
     """Represents event names for Wi-Fi Aware snippet operations."""
 
-    SERVER_SOCKET_ACCEPT = "ServerSocketAccept"
+    SERVER_SOCKET_ACCEPT = 'ServerSocketAccept'
 
 
 class SnippetEventParams:
     """Represents parameters for Wi-Fi Aware snippet events."""
-    IS_ACCEPT = "isAccept"
-    ERROR = "error"
-    LOCAL_PORT = "localPort"
+
+    IS_ACCEPT = 'isAccept'
+    ERROR = 'error'
+    LOCAL_PORT = 'localPort'
 
 
 @enum.unique
@@ -517,6 +587,7 @@ class AttachCallBackMethodType(enum.StrEnum):
 
     https://developer.android.com/reference/android/net/wifi/aware/AttachCallback
     """
+
     ATTACHED = 'onAttached'
     ATTACH_FAILED = 'onAttachFailed'
     AWARE_SESSION_TERMINATED = 'onAwareSessionTerminated'
@@ -525,16 +596,16 @@ class AttachCallBackMethodType(enum.StrEnum):
 
 @enum.unique
 class WifiAwareBroadcast(enum.StrEnum):
-    WIFI_AWARE_AVAILABLE = "WifiAwareStateAvailable"
-    WIFI_AWARE_NOT_AVAILABLE = "WifiAwareStateNotAvailable"
+    WIFI_AWARE_AVAILABLE = 'WifiAwareStateAvailable'
+    WIFI_AWARE_NOT_AVAILABLE = 'WifiAwareStateNotAvailable'
 
 
 @enum.unique
 class DeviceidleState(enum.StrEnum):
-    ACTIVE = "ACTIVE"
-    IDLE = "IDLE"
-    INACTIVE = "INACTIVE"
-    OVERRIDE = "OVERRIDE"
+    ACTIVE = 'ACTIVE'
+    IDLE = 'IDLE'
+    INACTIVE = 'INACTIVE'
+    OVERRIDE = 'OVERRIDE'
 
 
 @enum.unique
@@ -548,10 +619,25 @@ class Operator(enum.Enum):
     LESS = operator.lt
     LESS_EQUAL = operator.le
 
+
 @enum.unique
 class AndroidVersion(enum.IntEnum):
-  """Android OS version."""
-  R = 11
-  S = 12
-  T = 13
-  U = 14
+    """Android OS version."""
+
+    R = 11
+    S = 12
+    T = 13
+    U = 14
+
+
+@enum.unique
+class CountryCode(enum.StrEnum):
+    """Country Code abbreviation."""
+    AUSTRALIA = 'AU'
+    CHINA = 'CN'
+    GERMANY = 'DE'
+    JAPAN = 'JP'
+    UK = 'GB'
+    US = 'US'
+    UNKNOWN = 'UNKNOWN'
+
diff --git a/tests/hostsidetests/multidevices/test/aware/cts_wifi_aware_test_suite.py b/tests/hostsidetests/multidevices/test/aware/cts_wifi_aware_test_suite.py
new file mode 100644
index 0000000000..51e0c51f9d
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/cts_wifi_aware_test_suite.py
@@ -0,0 +1,41 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+"""CTS Wi-Fi Aware test suite."""
+
+import sys
+
+from aware import wifi_aware_discovery_ranging_test
+from aware import wifi_aware_network_test
+from mobly import base_suite
+from mobly import suite_runner
+
+
+class CtsWifiAwareTestSuite(base_suite.BaseSuite):
+    """CTS Wi-Fi Aware test suite."""
+
+    def setup_suite(self, config):
+        del config  # unused
+        self.add_test_class(wifi_aware_network_test.WifiAwareNetworkTest)
+        self.add_test_class(
+            wifi_aware_discovery_ranging_test.WifiAwareDiscoveryRangingTest
+        )
+
+
+if __name__ == '__main__':
+    # Take test args
+    if '--' in sys.argv:
+        index = sys.argv.index('--')
+        sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+    suite_runner.run_suite_class()
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/Android.bp b/tests/hostsidetests/multidevices/test/aware/integration/Android.bp
index 95ee662ac3..a6cd3130fa 100644
--- a/tests/hostsidetests/multidevices/test/aware/integration/Android.bp
+++ b/tests/hostsidetests/multidevices/test/aware/integration/Android.bp
@@ -21,6 +21,29 @@ python_test_host {
     name: "WifiAwareAttachTestCases",
     main: "wifi_aware_attached_test.py",
     srcs: ["wifi_aware_attached_test.py"],
+    device_common_data: [
+        ":wifi_aware_snippet_new",
+        ":wifi_mobly_snippet",
+    ],
+    libs: [
+        "aware_lib_utils",
+        "mobly",
+        "wifi_aware_constants",
+        "platform-test-py-annotations",
+    ],
+    test_suites: [
+        "general-tests",
+    ],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+}
+
+python_test_host {
+    name: "WifiAwareCapabilitiesTestCases",
+    main: "wifi_aware_capabilities_test.py",
+    srcs: ["wifi_aware_capabilities_test.py"],
     device_common_data: [":wifi_aware_snippet_new"],
     libs: [
         "aware_lib_utils",
@@ -40,11 +63,35 @@ python_test_host {
     name: "WifiAwareDiscoveryCases",
     main: "wifi_aware_discovery_test.py",
     srcs: ["wifi_aware_discovery_test.py"],
+    device_common_data: [
+        ":wifi_aware_snippet_new",
+        ":wifi_mobly_snippet",
+    ],
+    libs: [
+        "aware_lib_utils",
+        "mobly",
+        "wifi_aware_constants",
+        "platform-test-py-annotations",
+    ],
+    test_suites: [
+        "general-tests",
+    ],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+}
+
+python_test_host {
+    name: "WiFiAwareDiscoveryWithRangingTestCases",
+    main: "wifi_aware_discovery_with_ranging_test.py",
+    srcs: ["wifi_aware_discovery_with_ranging_test.py"],
     device_common_data: [":wifi_aware_snippet_new"],
     libs: [
         "aware_lib_utils",
         "mobly",
         "wifi_aware_constants",
+        "platform-test-py-annotations",
     ],
     test_suites: [
         "general-tests",
@@ -59,11 +106,35 @@ python_test_host {
     name: "WifiAwareMessageCases",
     main: "wifi_aware_message_test.py",
     srcs: ["wifi_aware_message_test.py"],
+    device_common_data: [
+        ":wifi_aware_snippet_new",
+        ":wifi_mobly_snippet",
+    ],
+    libs: [
+        "aware_lib_utils",
+        "mobly",
+        "wifi_aware_constants",
+        "platform-test-py-annotations",
+    ],
+    test_suites: [
+        "general-tests",
+    ],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+}
+
+python_test_host {
+    name: "WifiAwareMacRandomTestCases",
+    main: "wifi_aware_mac_random_test.py",
+    srcs: ["wifi_aware_mac_random_test.py"],
     device_common_data: [":wifi_aware_snippet_new"],
     libs: [
         "aware_lib_utils",
         "mobly",
         "wifi_aware_constants",
+        "platform-test-py-annotations",
     ],
     test_suites: [
         "general-tests",
@@ -78,11 +149,128 @@ python_test_host {
     name: "WifiAwareMatchFilterCases",
     main: "wifi_aware_matchfilter_test.py",
     srcs: ["wifi_aware_matchfilter_test.py"],
+    device_common_data: [
+        ":wifi_aware_snippet_new",
+        ":wifi_mobly_snippet",
+    ],
+    libs: [
+        "aware_lib_utils",
+        "mobly",
+        "wifi_aware_constants",
+        "platform-test-py-annotations",
+    ],
+    test_suites: [
+        "general-tests",
+    ],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+}
+
+python_test_host {
+    name: "WifiAwareMultiCountryProtocolsTestCases",
+    main: "wifi_aware_protocols_multi_country_test.py",
+    srcs: ["wifi_aware_protocols_multi_country_test.py"],
     device_common_data: [":wifi_aware_snippet_new"],
     libs: [
         "aware_lib_utils",
         "mobly",
         "wifi_aware_constants",
+        "platform-test-py-annotations",
+    ],
+    test_suites: [
+        "general-tests",
+    ],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+}
+
+python_test_host {
+    name: "WifiAwareDatapathTestCases",
+    main: "wifi_aware_datapath_test.py",
+    srcs: ["wifi_aware_datapath_test.py"],
+    device_common_data: [":wifi_aware_snippet_new"],
+    libs: [
+        "aware_lib_utils",
+        "mobly",
+        "wifi_aware_constants",
+        "platform-test-py-annotations",
+    ],
+    test_suites: [
+        "general-tests",
+    ],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+}
+
+python_test_host {
+    name: "WifiRttDisableTestCases",
+    main: "wifi_rtt_disable_test.py",
+    srcs: ["wifi_rtt_disable_test.py"],
+    device_common_data: [":wifi_aware_snippet_new"],
+    libs: [
+        "aware_lib_utils",
+        "mobly",
+        "wifi_aware_constants",
+    ],
+    test_suites: [
+        "general-tests",
+    ],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+}
+
+python_test_host {
+    name: "WifiAwareProtocolsTestCases",
+    main: "wifi_aware_protocols_test.py",
+    srcs: ["wifi_aware_protocols_test.py"],
+    device_common_data: [":wifi_aware_snippet_new"],
+    libs: [
+        "aware_lib_utils",
+        "mobly",
+        "wifi_aware_constants",
+    ],
+    test_suites: [
+        "general-tests",
+    ],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+}
+
+python_test_host {
+    name: "WifiAwareIntegrationTestSuite",
+    main: "wifi_aware_integration_test_suite.py",
+    srcs: [
+        "wifi_aware_integration_test_suite.py",
+        "wifi_aware_attached_test.py",
+        "wifi_aware_capabilities_test.py",
+        "wifi_aware_datapath_test.py",
+        "wifi_aware_discovery_test.py",
+        "wifi_aware_discovery_with_ranging_test.py",
+        "wifi_aware_mac_random_test.py",
+        "wifi_aware_matchfilter_test.py",
+        "wifi_aware_message_test.py",
+        "wifi_aware_protocols_multi_country_test.py",
+        "wifi_aware_protocols_test.py",
+    ],
+    device_common_data: [
+        ":wifi_aware_snippet_new",
+        ":wifi_mobly_snippet",
+    ],
+    libs: [
+        "aware_lib_utils",
+        "mobly",
+        "wifi_aware_constants",
+        "platform-test-py-annotations",
     ],
     test_suites: [
         "general-tests",
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_attached_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_attached_test.py
index 908b9c1f57..5e8414c469 100644
--- a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_attached_test.py
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_attached_test.py
@@ -16,6 +16,7 @@
 """ACTS Wi-Fi Aware Attached test reimplemented in Mobly."""
 import sys
 
+from android.platform.test.annotations import ApiTest
 from aware import aware_lib_utils as autils
 from aware import constants
 from mobly import asserts
@@ -32,7 +33,10 @@ RUNTIME_PERMISSIONS = (
     'android.permission.NEARBY_WIFI_DEVICES',
 )
 PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
-
+snippets_to_load = [
+    ('wifi_aware_snippet', PACKAGE_NAME),
+    ('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME),
+]
 
 class WifiAwareAttachTest(base_test.BaseTestClass):
   """Wi-Fi Aware Attach test class."""
@@ -44,9 +48,10 @@ class WifiAwareAttachTest(base_test.BaseTestClass):
     self.ads = self.register_controller(android_device, min_number=1)
 
     def setup_device(device: android_device.AndroidDevice):
-      device.load_snippet('wifi_aware_snippet', PACKAGE_NAME)
+      for snippet_name, package_name in snippets_to_load:
+                device.load_snippet(snippet_name, package_name)
       for permission in RUNTIME_PERMISSIONS:
-        device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+        device.adb.shell(['pm', 'grant', package_name, permission])
       asserts.abort_all_if(
           not device.wifi_aware_snippet.wifiAwareIsAvailable(),
           f'{device} Wi-Fi Aware is not available.',
@@ -62,7 +67,7 @@ class WifiAwareAttachTest(base_test.BaseTestClass):
 
   def setup_test(self):
     for ad in self.ads:
-      autils.control_wifi(ad, True)
+      ad.wifi.wifiEnable()
       aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
       if not aware_avail:
         ad.log.info('Aware not available. Waiting ...')
@@ -85,14 +90,21 @@ class WifiAwareAttachTest(base_test.BaseTestClass):
   def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
     ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
     ad.wifi_aware_snippet.wifiAwareMonitorStopStateChange()
-    autils.set_airplane_mode(ad, False)
-    autils.control_wifi(ad, True)
+    ad.wifi.wifiEnable()
+    if ad.is_adb_root:
+          autils.set_airplane_mode(ad, False)
 
   def on_fail(self, record: records.TestResult) -> None:
     android_device.take_bug_reports(
         self.ads, destination=self.current_test_info.output_path
     )
 
+  @ApiTest(
+      apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+      ]
+  )
+
   def test_attach(self) -> None:
     """Basic attaching request.
 
@@ -106,6 +118,12 @@ class WifiAwareAttachTest(base_test.BaseTestClass):
         handler, constants.AttachCallBackMethodType.ID_CHANGED
     )
 
+  @ApiTest(
+      apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+      ]
+  )
+
   def test_attach_with_identity(self) -> None:
     """Basic attaching request with extra callback.
 
@@ -117,6 +135,12 @@ class WifiAwareAttachTest(base_test.BaseTestClass):
     handler.waitAndGet(constants.AttachCallBackMethodType.ATTACHED)
     handler.waitAndGet(constants.AttachCallBackMethodType.ID_CHANGED)
 
+  @ApiTest(
+      apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+      ]
+  )
+
   def test_attach_multiple_sessions(self):
     """Multiple attaching request.
 
@@ -138,6 +162,12 @@ class WifiAwareAttachTest(base_test.BaseTestClass):
         handler_3, constants.AttachCallBackMethodType.ID_CHANGED, 10, True
     )
 
+  @ApiTest(
+      apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+      ]
+  )
+
   def test_attach_with_no_wifi(self):
     """WiFi Aware attempt to attach with wifi off.
 
@@ -153,6 +183,12 @@ class WifiAwareAttachTest(base_test.BaseTestClass):
     attach_callback.waitAndGet(constants.AttachCallBackMethodType.ATTACH_FAILED)
     dut.wifi_aware_snippet.wifiAwareMonitorStopStateChange()
 
+  @ApiTest(
+      apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+      ]
+  )
+
   def test_attach_with_location_off(self):
     """Function/Attach test cases/attempt to attach with location mode off.
 
@@ -176,6 +212,12 @@ class WifiAwareAttachTest(base_test.BaseTestClass):
     state_handler.waitAndGet(constants.WifiAwareBroadcast.WIFI_AWARE_AVAILABLE)
     dut.wifi_aware_snippet.wifiAwareMonitorStopStateChange()
 
+  @ApiTest(
+      apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+      ]
+  )
+
   def test_attach_apm_toggle_attach_again(self):
     """Function/Attach test cases/attempt to attach with airplane mode on.
 
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_capabilities_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_capabilities_test.py
new file mode 100644
index 0000000000..49c654d49f
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_capabilities_test.py
@@ -0,0 +1,430 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Wi-Fi Aware Capabilities test reimplemented in Mobly."""
+import string
+import sys
+from typing import Any, Dict, Union
+
+from aware import aware_lib_utils as autils
+from aware import constants
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+from mobly.controllers.android_device_lib import callback_handler_v2
+from mobly.snippet import callback_event
+
+RUNTIME_PERMISSIONS = (
+    'android.permission.ACCESS_FINE_LOCATION',
+    'android.permission.ACCESS_COARSE_LOCATION',
+    'android.permission.NEARBY_WIFI_DEVICES',
+)
+PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+
+_CALLBACK_NAME = constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
+
+# Publish & Subscribe Config keys.
+_PAYLOAD_SIZE_MIN = 0
+_PAYLOAD_SIZE_TYPICAL = 1
+_PAYLOAD_SIZE_MAX = 2
+
+# Definition for timeout and retries.
+_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
+_REQUEST_NETWORK_TIMEOUT_MS = 15 * 1000
+_MAX_TX_RETRIES = 5
+
+_TRANSPORT_TYPE_WIFI_AWARE = (
+    constants.NetworkCapabilities.Transport.TRANSPORT_WIFI_AWARE
+)
+
+
+class WifiAwareCapabilitiesTest(base_test.BaseTestClass):
+  """Set of tests for Wi-Fi Aware Capabilities - verifying that the provided
+  capabilities are real (i.e. available)."""
+  # message ID counter to make sure all uses are unique
+  msg_id = 0
+
+  ads: list[android_device.AndroidDevice]
+  SERVICE_NAME = 'GoogleTestXYZ'
+
+  def setup_class(self):
+    # Register two Android devices.
+    self.ads = self.register_controller(android_device, min_number=1)
+
+    def setup_device(device: android_device.AndroidDevice):
+      device.load_snippet('wifi_aware_snippet', PACKAGE_NAME)
+      for permission in RUNTIME_PERMISSIONS:
+        device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+      asserts.abort_all_if(
+          not device.wifi_aware_snippet.wifiAwareIsAvailable(),
+          f'{device} Wi-Fi Aware is not available.',
+      )
+
+    # Set up devices in parallel.
+    utils.concurrent_exec(
+        setup_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+
+  def setup_test(self):
+    for ad in self.ads:
+      autils.control_wifi(ad, True)
+      aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
+      if not aware_avail:
+        ad.log.info('Aware not available. Waiting ...')
+        state_handler = ad.wifi_aware_snippet.wifiAwareMonitorStateChange()
+        state_handler.waitAndGet(
+            constants.WifiAwareBroadcast.WIFI_AWARE_AVAILABLE
+        )
+
+  def teardown_test(self):
+    utils.concurrent_exec(
+        self._teardown_test_on_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+    utils.concurrent_exec(
+        lambda d: d.services.create_output_excerpts_all(self.current_test_info),
+        param_list=[[ad] for ad in self.ads],
+        raise_on_exception=True,
+    )
+
+  def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
+    ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+    ad.wifi_aware_snippet.wifiAwareMonitorStopStateChange()
+    autils.set_airplane_mode(ad, False)
+    autils.control_wifi(ad, True)
+
+  def on_fail(self, record: records.TestResult) -> None:
+    android_device.take_bug_reports(
+        self.ads, destination=self.current_test_info.output_path
+    )
+
+  def create_base_config(
+      self,
+      is_publish: bool,
+      ptype: Union[int, None],
+      stype: Union[int, None],
+      payload_size: int,
+      ttl: int,
+      term_ind_on: bool,
+      null_match: bool,
+      service_name: str,
+  ) -> Dict[str, Any]:
+    config = {}
+    if is_publish:
+      config[constants.PUBLISH_TYPE] = ptype
+    else:
+      config[constants.SUBSCRIBE_TYPE] = stype
+    config[constants.TTL_SEC] = ttl
+    config[constants.TERMINATE_NOTIFICATION_ENABLED] = term_ind_on
+    if payload_size == _PAYLOAD_SIZE_MIN:
+      config[constants.SERVICE_NAME] = (
+          'a' if not service_name else service_name
+      )
+      config[constants.SERVICE_SPECIFIC_INFO] = None
+      config[constants.MATCH_FILTER] = []
+    elif payload_size == _PAYLOAD_SIZE_TYPICAL:
+      config[constants.SERVICE_NAME] = (
+          'GoogleTestServiceX' if not service_name else service_name
+      )
+      if is_publish:
+        config[constants.SERVICE_SPECIFIC_INFO] = string.ascii_letters
+      else:
+        config[constants.SERVICE_SPECIFIC_INFO] = string.ascii_letters[::-1]
+      config[constants.MATCH_FILTER] = autils.encode_list([
+          (10).to_bytes(1, byteorder='big'),
+          'hello there string' if not null_match else None,
+          bytes(range(40)),
+      ])
+    else:  # aware_constant.PAYLOAD_SIZE_MAX
+      config[constants.SERVICE_NAME] = (
+          'VeryLong' + 'X' * (len('maxServiceNameLen') - 8)
+          if not service_name
+          else service_name
+      )
+      config[constants.SERVICE_SPECIFIC_INFO] = (
+          'P' if is_publish else 'S'
+      ) * len('maxServiceSpecificInfoLen')
+      mf = autils.construct_max_match_filter(len('maxMatchFilterLen'))
+      if null_match:
+        mf[2] = None
+      config[constants.MATCH_FILTER] = autils.encode_list(mf)
+    return config
+
+  def get_next_msg_id(self) -> int:
+    """Increment the message ID and returns the new value.
+
+    Guarantees that each call to the method returns a unique value.
+
+    Returns:
+      A new message id value.
+    """
+
+    self.msg_id = self.msg_id + 1
+    return self.msg_id
+
+  def create_publish_config(
+      self,
+      ptype: int,
+      payload_size: int,
+      ttl: int,
+      term_ind_on: bool,
+      null_match: bool,
+      service_name: str = '',
+  ) -> Dict[str, Any]:
+    return self.create_base_config(
+        True,
+        ptype,
+        None,
+        payload_size,
+        ttl,
+        term_ind_on,
+        null_match,
+        service_name,
+    )
+
+  def create_subscribe_config(
+      self,
+      stype: int,
+      payload_size: int,
+      ttl: int,
+      term_ind_on: bool,
+      null_match: bool,
+      service_name: str = '',
+  ) -> Dict[str, Any]:
+    return self.create_base_config(
+        False,
+        None,
+        stype,
+        payload_size,
+        ttl,
+        term_ind_on,
+        null_match,
+        service_name,
+    )
+
+  def _start_attach(self, ad: android_device.AndroidDevice) -> str:
+    """Starts the attach process on the provided device."""
+    handler = ad.wifi_aware_snippet.wifiAwareAttach()
+    attach_event = handler.waitAndGet(
+        event_name=constants.AttachCallBackMethodType.ATTACHED,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    asserts.assert_true(
+        ad.wifi_aware_snippet.wifiAwareIsSessionAttached(handler.callback_id),
+        f'{ad} attach succeeded, but Wi-Fi Aware session is still null.',
+    )
+    ad.log.info('Attach Wi-Fi Aware session succeeded.')
+    return attach_event.callback_id
+
+  def _start_discovery_session(
+      self, dut, session_id, is_publish, dtype, service_name, expect_success
+  ) -> callback_event.CallbackEvent:
+    """Start a discovery session.
+
+    Args:
+      dut: Device under test
+      session_id: ID of the Aware session in which to start discovery
+      is_publish: True for a publish session, False for subscribe session
+      dtype: Type of the discovery session
+      service_name: Service name to use for the discovery session
+      expect_success: True if expect session to be created, False otherwise
+
+    Returns:
+      Discovery session ID.
+    """
+    if is_publish:
+      p_config = self.create_publish_config(
+          dtype,
+          _PAYLOAD_SIZE_TYPICAL,
+          ttl=0,
+          term_ind_on=False,
+          null_match=False,
+          service_name=service_name,
+      )
+      dut.log.info(
+          'Created the publish session with type is %s, service_name is %s',
+          dtype,
+          p_config[constants.SERVICE_NAME],
+      )
+      disc_id = dut.wifi_aware_snippet.wifiAwarePublish(session_id, p_config)
+      event_name = constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED
+    else:
+      s_config = self.create_subscribe_config(
+          dtype,
+          _PAYLOAD_SIZE_TYPICAL,
+          ttl=0,
+          term_ind_on=False,
+          null_match=False,
+          service_name=service_name,
+      )
+      dut.log.info(
+          'Created the subscribe session with type is %s, service_name is %s',
+          dtype,
+          s_config[constants.SERVICE_NAME],
+      )
+      disc_id = dut.wifi_aware_snippet.wifiAwareSubscribe(session_id, s_config)
+      event_name = (
+          constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED
+      )
+
+    if expect_success:
+      discovery_result = disc_id.waitAndGet(
+          constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+          timeout=_DEFAULT_TIMEOUT,
+      )
+      callback_name = discovery_result.data[_CALLBACK_NAME]
+      asserts.assert_equal(
+          event_name,
+          callback_name,
+          f'{dut} {service_name} failed, got callback: {callback_name}.',
+      )
+    else:
+      disc_id.waitAndGet(
+          constants.DiscoverySessionCallbackMethodType.SESSION_CONFIG_FAILED
+      )
+      dut.log.info(
+          f'Got the expect value- {service_name} session config failed.'
+      )
+
+    dut.log.info('_start_discovery_session return: %s', disc_id.callback_id)
+    return disc_id
+
+  def test_max_discovery_sessions(self) -> None:
+    """Validate device capabilities.
+
+    Validate that the device can create as many discovery sessions as are
+    indicated in the device capabilities.
+    """
+    dut = self.ads[0]
+    dut.log.info('test_max_discovery_sessions start ...')
+    session_id = self._start_attach(dut)
+    pub_disc_id: callback_event.CallbackEvent = None
+    sub_disc_id: callback_event.CallbackEvent = None
+
+    service_name_template = 'GoogleTestService-%s-%d'
+    # Start the max number of publish sessions.
+    for i in range(autils.get_aware_capabilities(dut)['maxPublishes']):
+      # Create publish discovery session of both types.
+      pub_disc_id = self._start_discovery_session(
+          dut,
+          session_id,
+          True,
+          constants.PublishType.UNSOLICITED
+          if i % 2 == 0
+          else constants.PublishType.SOLICITED,
+          service_name_template % ('pub', i),
+          True,
+      )
+    asserts.assert_true(
+        pub_disc_id is not None,
+        'publish sessions initialize failed',
+    )
+    # Start the max number of subscribe sessions.
+    for i in range(autils.get_aware_capabilities(dut)['maxSubscribes']):
+      # Create publish discovery session of both types.
+      sub_disc_id = self._start_discovery_session(
+          dut,
+          session_id,
+          False,
+          constants.SubscribeType.PASSIVE
+          if i % 2 == 0
+          else constants.SubscribeType.ACTIVE,
+          service_name_template % ('sub', i),
+          True,
+      )
+    asserts.assert_true(
+        sub_disc_id is not None,
+        'subscribe sessions initialize failed',
+    )
+    # Start another publish & subscribe and expect failure.
+    self._start_discovery_session(
+        dut,
+        session_id,
+        True,
+        constants.PublishType.UNSOLICITED,
+        service_name_template % ('pub', 900),
+        False,
+    )
+    self._start_discovery_session(
+        dut,
+        session_id,
+        False,
+        constants.SubscribeType.ACTIVE,
+        service_name_template % ('sub', 901),
+        False,
+    )
+
+    # Delete one of the publishes and try again (see if can create subscribe
+    # instead - should not).
+    dut.log.info('Close last one of the publish session.')
+    dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        pub_disc_id.callback_id
+    )
+    self._start_discovery_session(
+        dut,
+        session_id,
+        False,
+        constants.SubscribeType.ACTIVE,
+        service_name_template % ('sub', 902),
+        False,
+    )
+    self._start_discovery_session(
+        dut,
+        session_id,
+        True,
+        constants.PublishType.UNSOLICITED,
+        service_name_template % ('pub', 903),
+        True,
+    )
+
+    # Delete one of the subscribes and try again (see if can create publish
+    # instead - should not).
+    dut.log.info('Close last one of the subscribe session.')
+    dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        sub_disc_id.callback_id
+    )
+    self._start_discovery_session(
+        dut,
+        session_id,
+        True,
+        constants.PublishType.UNSOLICITED,
+        service_name_template % ('pub', 904),
+        False,
+    )
+    self._start_discovery_session(
+        dut,
+        session_id,
+        False,
+        constants.SubscribeType.ACTIVE,
+        service_name_template % ('sub', 905),
+        True,
+    )
+
+
+if __name__ == '__main__':
+  # Take test args
+  if '--' in sys.argv:
+    index = sys.argv.index('--')
+    sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+  test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_datapath_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_datapath_test.py
new file mode 100644
index 0000000000..6233347ef9
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_datapath_test.py
@@ -0,0 +1,3283 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Wi-Fi Aware Datapath test reimplemented in Mobly."""
+import base64
+import logging
+import sys
+import time
+import re
+
+from android.platform.test.annotations import ApiTest
+from aware import aware_lib_utils as autils
+from aware import constants
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+from mobly.controllers.android_device_lib import callback_handler_v2
+from mobly.snippet import callback_event
+
+RUNTIME_PERMISSIONS = (
+    'android.permission.ACCESS_FINE_LOCATION',
+    'android.permission.ACCESS_COARSE_LOCATION',
+    'android.permission.NEARBY_WIFI_DEVICES',
+)
+PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
+_CALLBACK_NAME = constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
+_IS_SESSION_INIT = constants.DiscoverySessionCallbackParamsType.IS_SESSION_INIT
+_MESSAGE_SEND_SUCCEEDED = (
+    constants.DiscoverySessionCallbackMethodType.MESSAGE_SEND_SUCCEEDED
+    )
+_MESSAGE_RECEIVED = (
+    constants.DiscoverySessionCallbackMethodType.MESSAGE_RECEIVED
+    )
+_MESSAGE_SEND_RESULT = (
+    constants.DiscoverySessionCallbackMethodType.MESSAGE_SEND_RESULT
+    )
+_TRANSPORT_TYPE_WIFI_AWARE = (
+    constants.NetworkCapabilities.Transport.TRANSPORT_WIFI_AWARE
+)
+
+_NETWORK_CB_KEY_NETWORK_SPECIFIER = "network_specifier"
+
+_NETWORK_CB_LINK_PROPERTIES_CHANGED = constants.NetworkCbName.ON_PROPERTIES_CHANGED
+_NETWORK_CB_KEY_INTERFACE_NAME = "interfaceName"
+_CAP_MAX_NDI_INTERFACES = "maxNdiInterfaces"
+
+
+# Aware Data-Path Constants
+_DATA_PATH_INITIATOR = 0
+_DATA_PATH_RESPONDER = 1
+
+# Publish & Subscribe Config keys.
+_PAYLOAD_SIZE_MIN = 0
+_PAYLOAD_SIZE_TYPICAL = 1
+_PAYLOAD_SIZE_MAX = 2
+_PUBLISH_TYPE_UNSOLICITED = 0
+_PUBLISH_TYPE_SOLICITED = 1
+_SUBSCRIBE_TYPE_PASSIVE = 0
+_SUBSCRIBE_TYPE_ACTIVE = 1
+
+_REQUEST_NETWORK_TIMEOUT_MS = 15 * 1000
+
+
+class WifiAwareDatapathTest(base_test.BaseTestClass):
+    """Set of tests for Wi-Fi Aware data-path."""
+
+    # message ID counter to make sure all uses are unique
+    msg_id = 0
+
+    # number of second to 'reasonably' wait to make sure that devices synchronize
+    # with each other - useful for OOB test cases, where the OOB discovery would
+    # take some time
+    WAIT_FOR_CLUSTER = 5
+
+    EVENT_NDP_TIMEOUT = 20
+
+    # configuration parameters used by tests
+    ENCR_TYPE_OPEN = 0
+    ENCR_TYPE_PASSPHRASE = 1
+    ENCR_TYPE_PMK = 2
+
+    PASSPHRASE = "This is some random passphrase - very very secure!!"
+    PASSPHRASE_MIN = "01234567"
+    PASSPHRASE_MAX = "012345678901234567890123456789012345678901234567890123456789012"
+    PMK = "ODU0YjE3YzdmNDJiNWI4NTQ2NDJjNDI3M2VkZTQyZGU="
+    PASSPHRASE2 = "This is some random passphrase - very very secure - but diff!!"
+    PMK2 = "MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI="
+
+    PING_MSG = "ping"
+
+
+    SERVICE_NAME = "GoogleTestServiceDataPath"
+
+    ads: list[android_device.AndroidDevice]
+    publisher: android_device.AndroidDevice
+    subscriber: android_device.AndroidDevice
+
+    def setup_class(self):
+        # Register two Android devices.
+        self.ads = self.register_controller(android_device, min_number=2)
+        self.publisher = self.ads[0]
+        self.subscriber = self.ads[1]
+
+        def setup_device(device: android_device.AndroidDevice):
+            device.load_snippet(
+                'wifi_aware_snippet', PACKAGE_NAME
+            )
+            for permission in RUNTIME_PERMISSIONS:
+                device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+            asserts.abort_all_if(
+                not device.wifi_aware_snippet.wifiAwareIsAvailable(),
+                f'{device} Wi-Fi Aware is not available.',
+            )
+
+        # Set up devices in parallel.
+        utils.concurrent_exec(
+            setup_device,
+            ((self.publisher,), (self.subscriber,)),
+            max_workers=2,
+            raise_on_exception=True,
+        )
+
+    def setup_test(self):
+        for ad in self.ads:
+            autils.control_wifi(ad, True)
+            aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
+            if not aware_avail:
+                ad.log.info('Aware not available. Waiting ...')
+                state_handler = ad.wifi_aware_snippet.wifiAwareMonitorStateChange()
+                state_handler.waitAndGet(
+                    constants.WifiAwareBroadcast.WIFI_AWARE_AVAILABLE)
+
+    def teardown_test(self):
+        utils.concurrent_exec(
+            self._teardown_test_on_device,
+            ((self.publisher,), (self.subscriber,)),
+            max_workers=2,
+            raise_on_exception=True,
+        )
+        utils.concurrent_exec(
+            lambda d: d.services.create_output_excerpts_all(
+                self.current_test_info),
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+
+    def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
+        ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+        ad.wifi_aware_snippet.connectivityReleaseAllSockets()
+        if ad.is_adb_root:
+          autils.reset_device_parameters(ad)
+          autils.validate_forbidden_callbacks(ad)
+          autils.reset_device_statistics(ad)
+
+    def on_fail(self, record: records.TestResult) -> None:
+        android_device.take_bug_reports(self.ads,
+                                        destination =
+                                        self.current_test_info.output_path)
+
+    def _start_attach(self, ad: android_device.AndroidDevice) -> str:
+        """Starts the attach process on the provided device."""
+        handler = ad.wifi_aware_snippet.wifiAwareAttach()
+        attach_event = handler.waitAndGet(
+            event_name = constants.AttachCallBackMethodType.ATTACHED,
+            timeout = _DEFAULT_TIMEOUT,
+        )
+        asserts.assert_true(
+            ad.wifi_aware_snippet.wifiAwareIsSessionAttached(handler.callback_id),
+            f'{ad} attach succeeded, but Wi-Fi Aware session is still null.'
+        )
+        ad.log.info('Attach Wi-Fi Aware session succeeded.')
+        return attach_event.callback_id
+
+    def get_next_msg_id(self):
+        """Increment the message ID and returns the new value.
+        Guarantees that each call to the method returns a unique value.
+
+        Returns: a new message id value.
+        """
+
+        self.msg_id = self.msg_id + 1
+        return self.msg_id
+
+    def _request_network(
+        self,
+        ad: android_device.AndroidDevice,
+        discovery_session: str,
+        peer: int,
+        net_work_request_id: str,
+        network_specifier_params: constants.WifiAwareNetworkSpecifier | None = None,
+        is_accept_any_peer: bool = False,
+    ) -> callback_handler_v2.CallbackHandlerV2:
+        """Requests and configures a Wi-Fi Aware network connection."""
+        network_specifier_parcel = (
+            ad.wifi_aware_snippet.wifiAwareCreateNetworkSpecifier(
+                discovery_session,
+                peer,
+                is_accept_any_peer,
+                network_specifier_params.to_dict() if network_specifier_params else None,
+            )
+        )
+        network_request_dict = constants.NetworkRequest(
+            transport_type=_TRANSPORT_TYPE_WIFI_AWARE,
+            network_specifier_parcel=network_specifier_parcel,
+        ).to_dict()
+        ad.log.debug('Requesting Wi-Fi Aware network: %s', network_request_dict)
+        return ad.wifi_aware_snippet.connectivityRequestNetwork(
+            net_work_request_id, network_request_dict, _REQUEST_NETWORK_TIMEOUT_MS
+        )
+
+    def set_up_discovery(self,
+                         ptype,
+                         stype,
+                         get_peer_id,
+                         pub_on_both=False,
+                         pub_on_both_same=True):
+        """Set up discovery sessions and wait for service discovery.
+
+        Args:
+            ptype: Publish discovery type
+            stype: Subscribe discovery type
+            get_peer_id: Send a message across to get the peer's id
+            pub_on_both: If True then set up a publisher on both devices.
+                         The second publisher isn't used (existing to test
+                          use-case).
+            pub_on_both_same: If True then the second publish uses an identical
+                        service name, otherwise a different service name.
+        """
+        p_dut = self.ads[0]
+        s_dut = self.ads[1]
+        p_dut.pretty_name = "Publisher"
+        s_dut.pretty_name = "Subscriber"
+
+        # Publisher+Subscriber: attach and wait for confirmation
+        p_id = self._start_attach(p_dut)
+        s_id = self._start_attach(s_dut)
+
+        # Publisher: start publish and wait for confirmation
+        p_config = autils.create_discovery_config(self.SERVICE_NAME,
+                                                  p_type =ptype,
+                                                  s_type = None)
+        p_disc_id = p_dut.wifi_aware_snippet.wifiAwarePublish(
+            p_id, p_config
+                )
+        logging.info('Created the DUT publish session %s', p_disc_id)
+        p_discovery = p_disc_id.waitAndGet(
+            constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT)
+        callback_name = p_discovery.data[_CALLBACK_NAME]
+        asserts.assert_equal(
+            constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+            callback_name,
+            f'{p_dut} DUT publish failed, got callback: {callback_name}.',
+            )
+        # Optionally set up a publish session on the Subscriber device
+        if pub_on_both:
+            p2_config = autils.create_discovery_config(self.SERVICE_NAME,
+                                                  p_type = ptype,
+                                                  s_type = None)
+            if not pub_on_both_same:
+                p2_config[constants.SERVICE_NAME] = (
+                        p2_config[constants.SERVICE_NAME] + "-XYZXYZ")
+            s_disc_id= s_dut.wifi_aware_snippet.wifiAwarePublish(
+                s_id, p2_config)
+            s_dut.log.info('Created the DUT publish session %s', s_disc_id)
+            s_discovery = s_disc_id.waitAndGet(
+                constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT)
+            callback_name = s_discovery.data[_CALLBACK_NAME]
+            asserts.assert_equal(
+                constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+                callback_name,
+                f'{s_dut} DUT publish failed, got callback: {callback_name}.',
+            )
+
+        # Subscriber: start subscribe and wait for confirmation
+        s_config = autils.create_discovery_config(self.SERVICE_NAME,
+                                                  p_type = None,
+                                                  s_type = stype
+                                                  )
+        s_disc_id = s_dut.wifi_aware_snippet.wifiAwareSubscribe(
+            s_id, s_config
+                )
+        s_dut.log.info('Created the DUT subscribe session.: %s', s_disc_id)
+        s_discovery = s_disc_id.waitAndGet(
+                constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+                timeout=_DEFAULT_TIMEOUT)
+        callback_name = s_discovery.data[_CALLBACK_NAME]
+        asserts.assert_equal(
+            constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+            callback_name,
+            f'{s_dut} DUT subscribe failed, got callback: {callback_name}.',
+            )
+        discovered_event = s_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED)
+        peer_id_on_sub =(
+            discovered_event.data[constants.WifiAwareSnippetParams.PEER_ID])
+        peer_id_on_pub = None
+        if get_peer_id:  # only need message to receive peer ID
+            # Subscriber: send message to peer (Publisher - so it knows our address)
+            s_dut.wifi_aware_snippet.wifiAwareSendMessage(
+                s_disc_id.callback_id,
+                peer_id_on_sub,
+                self.get_next_msg_id(),
+                self.PING_MSG,
+                )
+            tx_event = s_disc_id.waitAndGet(
+            event_name = _MESSAGE_SEND_RESULT,
+            timeout = _DEFAULT_TIMEOUT,
+            )
+            # Publisher: wait for received message
+            rx_event = p_disc_id.waitAndGet(
+                event_name = _MESSAGE_RECEIVED,
+                timeout = _DEFAULT_TIMEOUT,
+            )
+            pub_rx_msg_event = rx_event.data[
+                constants.WifiAwareSnippetParams.RECEIVED_MESSAGE
+            ]
+            peer_id_on_pub = rx_event.data[
+                constants.WifiAwareSnippetParams.PEER_ID]
+        return (p_dut, s_dut, p_id, s_id, p_disc_id, s_disc_id, peer_id_on_sub,
+                peer_id_on_pub)
+
+    def verify_network_info(self, p_data, s_data, open, port,
+                            transport_protocol):
+        """Verify that the port and transport protocol information is correct.
+            - should only exist on subscriber (received from publisher)
+              and match transmitted values
+            - should only exist on an encrypted NDP
+
+        Args:
+            p_data, s_data: Pub and Sub (respectively) net cap event data.
+            open: True if NDP unencrypted, False if encrypted.
+            port: Expected port value.
+            transport_protocol: Expected transport protocol value.
+        """
+        asserts.assert_true(constants.NetworkCbName.NET_CAP_PORT not in p_data,
+                            "port info not expected on Pub")
+        asserts.assert_true(
+            constants.NetworkCbName.NET_CAP_TRANSPORT_PROTOCOL not in p_data,
+            "transport protocol info not expected on Pub")
+        if open:
+            asserts.assert_true(
+                constants.NetworkCbName.NET_CAP_PORT not in s_data,
+                "port info not expected on Sub (open NDP)")
+            asserts.assert_true(
+                constants.NetworkCbName.NET_CAP_TRANSPORT_PROTOCOL not in s_data,
+                "transport protocol info not expected on Sub (open NDP)")
+        else:
+            asserts.assert_equal(
+                s_data[constants.NetworkCbName.NET_CAP_PORT], port,
+                "Port info does not match on Sub (from Pub)")
+            asserts.assert_equal(
+                s_data[constants.NetworkCbName.NET_CAP_TRANSPORT_PROTOCOL],
+                transport_protocol,
+                "Transport protocol info does not match on Sub (from Pub)")
+
+    def _wait_accept_success(
+        self,
+        pub_accept_handler: callback_handler_v2.CallbackHandlerV2
+    ) -> None:
+        pub_accept_event = pub_accept_handler.waitAndGet(
+            event_name=constants.SnippetEventNames.SERVER_SOCKET_ACCEPT,
+            timeout=_DEFAULT_TIMEOUT
+        )
+        is_accept = pub_accept_event.data.get(
+            constants.SnippetEventParams.IS_ACCEPT, False)
+        if not is_accept:
+            error = pub_accept_event.data[constants.SnippetEventParams.ERROR]
+            asserts.fail(
+                f'{self.publisher} Failed to accept the connection.'+
+                ' Error: {error}'
+            )
+
+    def _send_socket_msg(
+        self,
+        sender_ad: android_device.AndroidDevice,
+        receiver_ad: android_device.AndroidDevice,
+        msg: str,
+        send_callback_id: str,
+        receiver_callback_id: str,
+    ):
+        """Sends a message from one device to another and verifies receipt."""
+        is_write_socket = sender_ad.wifi_aware_snippet.connectivityWriteSocket(
+            send_callback_id, msg
+        )
+        asserts.assert_true(
+            is_write_socket,
+            f'{sender_ad} Failed to write data to the socket.'
+        )
+        sender_ad.log.info('Wrote data to the socket.')
+        self.publisher.log.info('Server socket accepted the connection.')
+        # Verify received message
+        received_message = receiver_ad.wifi_aware_snippet.connectivityReadSocket(
+            receiver_callback_id, len(msg)
+        )
+        logging.info("msg: %s,received_message: %s",msg, received_message)
+        asserts.assert_equal(
+            received_message,
+            msg,
+            f'{receiver_ad} received message mismatched.Failure:Expected {msg} but got '
+            f'{received_message}.'
+        )
+        receiver_ad.log.info('Read data from the socket.')
+
+
+    def _establish_socket_and_send_msg(
+        self,
+        pub_accept_handler: callback_handler_v2.CallbackHandlerV2,
+        network_id: str,
+        pub_local_port: int
+    ):
+        """Handles socket-based communication between publisher and subscriber."""
+        # Init socket
+        # Create a ServerSocket and makes it listen for client connections.
+        self.subscriber.wifi_aware_snippet.connectivityCreateSocketOverWiFiAware(
+            network_id, pub_local_port
+        )
+        self._wait_accept_success(pub_accept_handler)
+        # Subscriber Send socket data
+        self.subscriber.log.info('Subscriber create a socket.')
+        self._send_socket_msg(
+            sender_ad=self.subscriber,
+            receiver_ad=self.publisher,
+            msg=constants.WifiAwareTestConstants.MSG_CLIENT_TO_SERVER,
+            send_callback_id=network_id,
+            receiver_callback_id=network_id
+        )
+        self._send_socket_msg(
+            sender_ad=self.publisher,
+            receiver_ad=self.subscriber,
+            msg=constants.WifiAwareTestConstants.MSG_SERVER_TO_CLIENT,
+            send_callback_id=network_id,
+            receiver_callback_id=network_id
+        )
+        self.publisher.wifi_aware_snippet.connectivityCloseWrite(network_id)
+        self.subscriber.wifi_aware_snippet.connectivityCloseWrite(network_id)
+        self.publisher.wifi_aware_snippet.connectivityCloseRead(network_id)
+        self.subscriber.wifi_aware_snippet.connectivityCloseRead(network_id)
+        logging.info('Communicated through socket connection of'+
+            'Wi-Fi Aware network successfully.')
+
+    def run_ib_data_path_test(self,
+                              ptype,
+                              stype,
+                              encr_type,
+                              use_peer_id,
+                              passphrase_to_use=None,
+                              pub_on_both=False,
+                              pub_on_both_same=True,
+                              expect_failure=False):
+        """Runs the in-band data-path tests.
+
+        Args:
+            ptype: Publish discovery type
+            stype: Subscribe discovery type
+            encr_type: Encryption type, one of ENCR_TYPE_*
+            use_peer_id: On Responder (publisher): True to use peer ID, False
+                        toaccept any request
+            passphrase_to_use: The passphrase to use if encr_type=
+                ENCR_TYPE_PASSPHRASE If None then use self.PASSPHRASE
+            pub_on_both: If True then set up a publisher on both devices.
+             The second publisher isn't used (existing to test use-case).
+            pub_on_both_same: If True then the second publish uses an identical
+                        service name, otherwise a different service name.
+        expect_failure: If True then don't expect NDP formation, otherwise expect
+                      NDP setup to succeed.
+        """
+        (p_dut, s_dut, p_id, s_id, p_disc_id, s_disc_id, peer_id_on_sub,
+                peer_id_on_pub) = self.set_up_discovery(
+             ptype, stype, use_peer_id, pub_on_both=pub_on_both, pub_on_both_same=pub_on_both_same)
+        passphrase = None
+        pmk = None
+
+        if encr_type == self.ENCR_TYPE_PASSPHRASE:
+            passphrase = (self.PASSPHRASE
+                          if passphrase_to_use == None else passphrase_to_use)
+        elif encr_type == self.ENCR_TYPE_PMK:
+            pmk = base64.b64decode(self.PMK).decode("utf-8")
+
+        port = 1234
+        transport_protocol = 6  # TCP/IP
+
+        # Publisher: request network
+        pub_accept_handler = p_dut.wifi_aware_snippet.connectivityServerSocketAccept()
+        network_id = pub_accept_handler.callback_id
+        pub_local_port = pub_accept_handler.ret_value
+        self.publish_session = p_disc_id.callback_id
+        self.subscribe_session = s_disc_id.callback_id
+        if encr_type == self.ENCR_TYPE_OPEN:
+            p_req_key = self._request_network(
+                ad=p_dut,
+                discovery_session=self.publish_session,
+                peer=peer_id_on_pub if use_peer_id else None,
+                net_work_request_id=network_id,
+                network_specifier_params=constants.WifiAwareNetworkSpecifier(
+                    psk_passphrase=passphrase,
+                    pmk=pmk,
+                    ),
+                 is_accept_any_peer = False if use_peer_id else True,
+                 )
+
+        else:
+            p_req_key = self._request_network(
+                ad=p_dut,
+                discovery_session=self.publish_session,
+                peer=peer_id_on_pub if use_peer_id else None,
+                net_work_request_id=network_id,
+                network_specifier_params = constants.WifiAwareNetworkSpecifier(
+                    psk_passphrase=passphrase,
+                    pmk=pmk,
+                    port=pub_local_port,
+                    transport_protocol=transport_protocol
+                    ),
+                is_accept_any_peer = False if use_peer_id else True,
+                )
+        # Subscriber: request network
+        s_req_key = self._request_network(
+                ad=s_dut,
+                discovery_session=self.subscribe_session,
+                peer=peer_id_on_sub,
+                net_work_request_id=network_id,
+                network_specifier_params=constants.WifiAwareNetworkSpecifier(
+                    psk_passphrase=passphrase,
+                    pmk=pmk,
+                    ),
+                )
+        p_network_callback_event = p_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        p_callback_name = p_network_callback_event.data[_CALLBACK_NAME]
+        s_network_callback_event = s_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        s_callback_name = s_network_callback_event.data[_CALLBACK_NAME]
+
+
+        if expect_failure:
+            asserts.assert_equal(
+                p_callback_name, constants.NetworkCbName.ON_UNAVAILABLE,
+                f'{p_dut} failed to request the network, got callback'
+                f' {p_callback_name}.'
+                )
+            asserts.assert_equal(
+                s_callback_name, constants.NetworkCbName.ON_UNAVAILABLE,
+                f'{s_dut} failed to request the network, got callback'
+                f' {s_callback_name}.'
+                )
+        else:
+            # # Publisher & Subscriber: wait for network formation
+            asserts.assert_equal(
+                p_callback_name, constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+                f'{p_dut} succeeded to request the network, got callback'
+                f' {p_callback_name}.'
+                )
+            network = p_network_callback_event.data[
+                constants.NetworkCbEventKey.NETWORK]
+            network_capabilities = p_network_callback_event.data[
+                constants.NetworkCbEventKey.NETWORK_CAPABILITIES]
+            asserts.assert_true(
+                network and network_capabilities,
+                f'{p_dut} received a null Network or NetworkCapabilities!?.'
+            )
+            asserts.assert_equal(
+                s_callback_name, constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+                f'{s_dut} succeeded to request the network, got callback'
+                f' {s_callback_name}.'
+                )
+            network = s_network_callback_event.data[
+                constants.NetworkCbEventKey.NETWORK]
+            network_capabilities = s_network_callback_event.data[
+                constants.NetworkCbEventKey.NETWORK_CAPABILITIES]
+            asserts.assert_true(
+                network and network_capabilities,
+                f'{s_dut} received a null Network or NetworkCapabilities!?.'
+            )
+            p_net_event_nc = p_network_callback_event.data
+            s_net_event_nc = s_network_callback_event.data
+
+        # validate no leak of information
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in p_net_event_nc,
+             "Network specifier leak!")
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in s_net_event_nc,
+             "Network specifier leak!")
+
+        #To get ipv6 ip address
+        s_ipv6= p_net_event_nc[constants.NetworkCbName.NET_CAP_IPV6]
+        p_ipv6 = s_net_event_nc[constants.NetworkCbName.NET_CAP_IPV6]
+        # note that Pub <-> Sub since IPv6 are of peer's!
+        self.verify_network_info(
+            p_network_callback_event.data,
+            s_network_callback_event.data,
+            encr_type == self.ENCR_TYPE_OPEN,
+            port = pub_local_port,
+            transport_protocol = transport_protocol)
+
+        p_network_callback_LINK = p_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        asserts.assert_equal(
+                p_network_callback_LINK.data[_CALLBACK_NAME],
+                _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+                f'{p_dut} succeeded to request the LinkPropertiesChanged,'+
+                ' got callback'
+                f' {p_network_callback_LINK.data[_CALLBACK_NAME]}.'
+                )
+
+        s_network_callback_LINK = s_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        asserts.assert_equal(
+                s_network_callback_LINK.data[_CALLBACK_NAME],
+                _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+                f'{s_dut} succeeded to request the LinkPropertiesChanged,'+
+                ' got callback'
+                f' {s_network_callback_LINK.data[_CALLBACK_NAME]}.'
+                )
+        p_aware_if = p_network_callback_LINK.data[
+                                _NETWORK_CB_KEY_INTERFACE_NAME]
+        s_aware_if = s_network_callback_LINK.data[
+                                _NETWORK_CB_KEY_INTERFACE_NAME]
+
+        logging.info("Interface names: p=%s, s=%s", p_aware_if,
+                      s_aware_if)
+        logging.info("Interface addresses (IPv6): p=%s, s=%s", p_ipv6,
+                      s_ipv6)
+        self._establish_socket_and_send_msg(
+            pub_accept_handler=pub_accept_handler,
+            network_id=network_id,
+            pub_local_port=pub_local_port
+            )
+
+        # terminate sessions and wait for ON_LOST callbacks
+        p_dut.wifi_aware_snippet.wifiAwareDetach(p_id)
+        s_dut.wifi_aware_snippet.wifiAwareDetach(s_id)
+        time.sleep(10)
+        p_network_callback_lost = p_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CB_LOST,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        s_network_callback_lost = s_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CB_LOST,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        p_dut.wifi_aware_snippet.connectivityUnregisterNetwork(network_id)
+        s_dut.wifi_aware_snippet.connectivityUnregisterNetwork(network_id)
+
+
+    def attach_with_identity(self, dut):
+        """Start an Aware session (attach) and wait for confirmation and
+        identity information (mac address).
+
+        Args:
+            dut: Device under test
+        Returns:
+            id: Aware session ID.
+        mac: Discovery MAC address of this device.
+        """
+        handler = dut.wifi_aware_snippet.wifiAwareAttached(True)
+        id = handler.waitAndGet(constants.AttachCallBackMethodType.ATTACHED)
+        even = handler.waitAndGet(constants.AttachCallBackMethodType.ID_CHANGED)
+        mac = even.data["mac"]
+        return id.callback_id, mac
+
+    def request_oob_network(
+        self,
+        ad: android_device.AndroidDevice,
+        aware_session : str,
+        role: int,
+        mac: str,
+        passphrase:str,
+        pmk:str,
+        net_work_request_id: str,
+    ) -> callback_handler_v2.CallbackHandlerV2:
+        """Requests a Wi-Fi Aware network."""
+        network_specifier_parcel = (
+            ad.wifi_aware_snippet.createNetworkSpecifierOob(
+              aware_session, role, mac, passphrase, pmk)
+        )
+        logging.info("network_specifier_parcel: %s", network_specifier_parcel)
+        network_request_dict = constants.NetworkRequest(
+            transport_type=constants.NetworkCapabilities.Transport.TRANSPORT_WIFI_AWARE,
+            network_specifier_parcel=network_specifier_parcel["result"],
+        ).to_dict()
+        logging.info("network_request_dict: %s", network_request_dict)
+        return ad.wifi_aware_snippet.connectivityRequestNetwork(
+            net_work_request_id, network_request_dict, _REQUEST_NETWORK_TIMEOUT_MS
+        )
+
+
+    def run_oob_data_path_test(self,
+                               encr_type,
+                               use_peer_id,
+                               setup_discovery_sessions=False,
+                               expect_failure=False):
+        """Runs the out-of-band data-path tests.
+
+        Args:
+        encr_type: Encryption type, one of ENCR_TYPE_*
+        setup_discovery_sessions: If True also set up a (spurious) discovery
+            session (pub on both sides, sub on Responder side). Validates a corner
+            case.
+        expect_failure: If True then don't expect NDP formation, otherwise expect
+                        NDP setup to succeed.
+        """
+        init_dut = self.ads[0]
+        init_dut.pretty_name = "Initiator"
+        resp_dut = self.ads[1]
+        resp_dut.pretty_name = "Responder"
+        init_id, init_mac = self.attach_with_identity(init_dut)
+        resp_id, resp_mac = self.attach_with_identity(resp_dut)
+        time.sleep(self.WAIT_FOR_CLUSTER)
+        if setup_discovery_sessions:
+            pconfig = autils.create_discovery_config(
+                self.SERVICE_NAME, p_type =_PUBLISH_TYPE_UNSOLICITED,
+                s_type = None)
+            init_disc_id = init_dut.wifi_aware_snippet.wifiAwarePublish(
+                init_id, pconfig
+                    )
+            logging.info('Created the DUT publish session %s', init_disc_id)
+            init_discovery = init_disc_id.waitAndGet(
+                constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT)
+            init_name = init_discovery.data[_CALLBACK_NAME]
+            asserts.assert_equal(
+                constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+                init_name,
+                f'{init_dut} DUT publish failed, got callback: {init_name}.',
+                )
+
+            resp_disc_id = resp_dut.wifi_aware_snippet.wifiAwarePublish(
+                resp_id, pconfig
+                    )
+            logging.info('Created the DUT publish session %s', resp_disc_id)
+            resp_discovery = resp_disc_id.waitAndGet(
+                constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT)
+            resp_name = resp_discovery.data[_CALLBACK_NAME]
+            asserts.assert_equal(
+                constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+                resp_name,
+                f'{resp_dut} DUT publish failed, got callback: {resp_name}.',
+                )
+            sconfig = autils.create_discovery_config(
+                self.SERVICE_NAME, p_type =None, s_type =_SUBSCRIBE_TYPE_PASSIVE)
+            resp_disc_id = resp_dut.wifi_aware_snippet.wifiAwareSubscribe(
+                resp_id, sconfig
+                    )
+            resp_dut.log.info('Created the DUT subscribe session.: %s',
+            resp_disc_id)
+            resp_discovery = resp_disc_id.waitAndGet(
+                    constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+                    timeout=_DEFAULT_TIMEOUT)
+            resp_name = resp_discovery.data[_CALLBACK_NAME]
+            asserts.assert_equal(
+                constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+                resp_name,
+                f'{resp_dut} DUT subscribe failed, got callback: {resp_name}.',
+                )
+            discovered_event = resp_disc_id.waitAndGet(
+            constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED)
+        passphrase = None
+        pmk = None
+        if encr_type == self.ENCR_TYPE_PASSPHRASE:
+            passphrase = self.PASSPHRASE
+        elif encr_type == self.ENCR_TYPE_PMK:
+            pmk = self.PMK
+
+        # Responder: request network
+        init_dut_accept_handler =(
+            init_dut.wifi_aware_snippet.connectivityServerSocketAccept())
+        network_id = init_dut_accept_handler.callback_id
+        init_local_port = init_dut_accept_handler.ret_value
+        resp_req_key = self.request_oob_network(
+            resp_dut,
+            resp_id,
+            _DATA_PATH_RESPONDER,
+            init_mac if use_peer_id else None,
+            passphrase,
+            pmk,
+            network_id
+            )
+
+        # Initiator: request network
+        init_req_key = self.request_oob_network(
+            init_dut,
+            init_id,
+            _DATA_PATH_INITIATOR,
+            resp_mac,
+            passphrase,
+            pmk,
+            network_id
+            )
+        init_callback_event = init_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        init_name = init_callback_event.data[_CALLBACK_NAME]
+        resp_callback_event = resp_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        resp_name = resp_callback_event.data[_CALLBACK_NAME]
+
+        if expect_failure:
+            asserts.assert_equal(
+                init_name, constants.NetworkCbName.ON_UNAVAILABLE,
+                f'{init_dut} failed to request the network, got callback'
+                f' {init_name}.'
+                )
+            asserts.assert_equal(
+                resp_name, constants.NetworkCbName.ON_UNAVAILABLE,
+                f'{resp_dut} failed to request the network, got callback'
+                f' {resp_name}.'
+                )
+        else:
+            # # Publisher & Subscriber: wait for network formation
+            asserts.assert_equal(
+                init_name, constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+                f'{init_dut} succeeded to request the network, got callback'
+                f' {init_name}.'
+                )
+            network = init_callback_event.data[
+                constants.NetworkCbEventKey.NETWORK]
+            network_capabilities = init_callback_event.data[
+                constants.NetworkCbEventKey.NETWORK_CAPABILITIES]
+            asserts.assert_true(
+                network and network_capabilities,
+                f'{init_dut} received a null Network or NetworkCapabilities!?.'
+            )
+            asserts.assert_equal(
+                resp_name, constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+                f'{resp_dut} succeeded to request the network, got callback'
+                f' {resp_name}.'
+                )
+            network = resp_callback_event.data[
+                constants.NetworkCbEventKey.NETWORK]
+            network_capabilities = resp_callback_event.data[
+                constants.NetworkCbEventKey.NETWORK_CAPABILITIES]
+            asserts.assert_true(
+                network and network_capabilities,
+                f'{resp_dut} received a null Network or NetworkCapabilities!?.'
+            )
+            init_net_event_nc = init_callback_event.data
+            resp_net_event_nc = resp_callback_event.data
+            # validate no leak of information
+            asserts.assert_false(
+                _NETWORK_CB_KEY_NETWORK_SPECIFIER in init_net_event_nc,
+                "Network specifier leak!")
+            asserts.assert_false(
+                _NETWORK_CB_KEY_NETWORK_SPECIFIER in resp_net_event_nc,
+                "Network specifier leak!")
+
+            #To get ipv6 ip address
+            resp_ipv6= init_net_event_nc[constants.NetworkCbName.NET_CAP_IPV6]
+            init_ipv6 = resp_net_event_nc[constants.NetworkCbName.NET_CAP_IPV6]
+            # note that Pub <-> Sub since IPv6 are of peer's!
+            init_callback_LINK = init_req_key.waitAndGet(
+                    event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                    timeout=_DEFAULT_TIMEOUT,
+                )
+            asserts.assert_equal(
+                    init_callback_LINK.data[_CALLBACK_NAME],
+                    _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+                    f'{init_dut} succeeded to request the'+
+                    ' LinkPropertiesChanged, got callback'
+                    f' {init_callback_LINK.data[_CALLBACK_NAME]}.'
+                    )
+
+            resp_callback_LINK = resp_req_key.waitAndGet(
+                    event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                    timeout=_DEFAULT_TIMEOUT,
+                )
+            asserts.assert_equal(
+                    resp_callback_LINK.data[_CALLBACK_NAME],
+                    _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+                    f'{resp_dut} succeeded to request the'+
+                    'LinkPropertiesChanged, got callback'
+                    f' {resp_callback_LINK.data[_CALLBACK_NAME]}.'
+                    )
+            init_aware_if = init_callback_LINK.data[
+                _NETWORK_CB_KEY_INTERFACE_NAME]
+            resp_aware_if = resp_callback_LINK.data[
+                _NETWORK_CB_KEY_INTERFACE_NAME]
+
+            logging.info("Interface names: p=%s, s=%s", init_aware_if,
+                        resp_aware_if)
+            logging.info("Interface addresses (IPv6): p=%s, s=%s", init_ipv6,
+                        resp_ipv6)
+            self._establish_socket_and_send_msg(
+                pub_accept_handler=init_dut_accept_handler,
+                network_id=network_id,
+                pub_local_port=init_local_port
+                )
+
+            # terminate sessions and wait for ON_LOST callbacks
+            init_dut.wifi_aware_snippet.wifiAwareDetach(init_id)
+            resp_dut.wifi_aware_snippet.wifiAwareDetach(resp_id)
+            time.sleep(self.WAIT_FOR_CLUSTER)
+            init_callback_lost = init_req_key.waitAndGet(
+                    event_name=constants.NetworkCbEventName.NETWORK_CB_LOST,
+                    timeout=_DEFAULT_TIMEOUT,
+                )
+            resp_callback_lost = resp_req_key.waitAndGet(
+                    event_name=constants.NetworkCbEventName.NETWORK_CB_LOST,
+                    timeout=_DEFAULT_TIMEOUT,
+                )
+        init_dut.wifi_aware_snippet.connectivityUnregisterNetwork(init_callback_event.callback_id)
+        resp_dut.wifi_aware_snippet.connectivityUnregisterNetwork(resp_callback_event.callback_id)
+
+    def wait_for_request_responses(self, dut, req_keys, aware_ifs, aware_ipv6):
+        """Wait for network request confirmation for all request keys.
+
+        Args:
+            dut: Device under test
+            req_keys: (in) A list of the network requests
+            aware_ifs: (out) A list into which to append the network interface
+            aware_ipv6: (out) A list into which to append the network ipv6
+            address
+        """
+        network_callback_event = req_keys.waitAndGet(
+            event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+            timeout=_DEFAULT_TIMEOUT,
+            )
+            # network_callback_event=req_keys[0]
+        if network_callback_event.data[_CALLBACK_NAME] == _NETWORK_CB_LINK_PROPERTIES_CHANGED:
+            if network_callback_event.callback_id:
+                aware_ifs.append(network_callback_event.data["interfaceName"])
+            else:
+                logging.info(
+                    "Received an unexpected connectivity, the revoked "+
+                    "network request probably went through -- %s", network_callback_event)
+        elif network_callback_event.data[_CALLBACK_NAME] == (
+            constants.NetworkCbName.ON_CAPABILITIES_CHANGED) :
+            if network_callback_event.callback_id:
+                aware_ipv6.append(network_callback_event.data[
+                    constants.NetworkCbName.NET_CAP_IPV6])
+            else:
+                logging.info(
+                    "Received an unexpected connectivity, the revoked "+
+                    "network request probably went through -- %s",
+                    network_callback_event)
+                asserts.assert_false(
+                     _NETWORK_CB_KEY_NETWORK_SPECIFIER in
+                    network_callback_event.data,
+                     "Network specifier leak!")
+
+    def get_ipv6_addr(self, device, interface):
+        """Get the IPv6 address of the specified interface. Uses ifconfig and parses
+        its output. Returns a None if the interface does not have an IPv6 address
+        (indicating it is not UP).
+
+        Args:
+            device: Device on which to query the interface IPv6 address.
+            interface: Name of the interface for which to obtain the IPv6 address.
+        """
+        out = device.adb.shell("ifconfig %s" % interface)
+        res = re.search(r"inet6 addr: (.*?)/64", str(out))
+        if not res:
+            return None
+        return res.group(1)
+
+    def run_mismatched_oob_data_path_test(self,
+                                          init_mismatch_mac=False,
+                                          resp_mismatch_mac=False,
+                                          init_encr_type=ENCR_TYPE_OPEN,
+                                          resp_encr_type=ENCR_TYPE_OPEN):
+        """Runs the negative out-of-band data-path tests: mismatched information
+        between Responder and Initiator.
+
+        Args:
+            init_mismatch_mac: True to mismatch the Initiator MAC address
+            resp_mismatch_mac: True to mismatch the Responder MAC address
+            init_encr_type: Encryption type of Initiator - ENCR_TYPE_*
+            resp_encr_type: Encryption type of Responder - ENCR_TYPE_*
+        """
+
+        init_dut = self.ads[0]
+        init_dut.pretty_name = "Initiator"
+        resp_dut = self.ads[1]
+        resp_dut.pretty_name = "Responder"
+        init_handler = init_dut.wifi_aware_snippet.wifiAwareAttached(True)
+        resp_handler = resp_dut.wifi_aware_snippet.wifiAwareAttached(True)
+        init_id, init_mac = self.attach_with_identity(init_dut)
+        resp_id, resp_mac = self.attach_with_identity(resp_dut)
+        if init_mismatch_mac:  # assumes legit ones don't start with "00"
+            init_mac = "00" + init_mac[2:]
+        if resp_mismatch_mac:
+            resp_mac = "00" + resp_mac[2:]
+
+        # wait for devices to synchronize with each other - there are no other
+        # mechanisms to make sure this happens for OOB discovery (except retrying
+        # to execute the data-path request)
+        time.sleep(self.WAIT_FOR_CLUSTER)
+
+        # set up separate keys: even if types are the same we want a mismatch
+        init_passphrase = None
+        init_pmk = None
+        if init_encr_type == self.ENCR_TYPE_PASSPHRASE:
+            init_passphrase = self.PASSPHRASE
+        elif init_encr_type == self.ENCR_TYPE_PMK:
+            init_pmk = self.PMK
+        resp_passphrase = None
+        resp_pmk = None
+        if resp_encr_type == self.ENCR_TYPE_PASSPHRASE:
+            resp_passphrase = self.PASSPHRASE2
+        elif resp_encr_type == self.ENCR_TYPE_PMK:
+            resp_pmk = self.PMK2
+
+        # Responder: request network
+        init_dut_accept_handler = init_dut.wifi_aware_snippet.connectivityServerSocketAccept()
+        network_id = init_dut_accept_handler.callback_id
+        init_local_port = init_dut_accept_handler.ret_value
+        resp_req_key = self.request_oob_network(
+            resp_dut,
+            resp_id,
+            _DATA_PATH_RESPONDER,
+            init_mac,
+            resp_passphrase,
+            resp_pmk,
+            network_id
+            )
+
+        # Initiator: request network
+        init_req_key = self.request_oob_network(
+            init_dut,
+            init_id,
+            _DATA_PATH_INITIATOR,
+            resp_mac,
+            init_passphrase,
+            init_pmk,
+            network_id
+            )
+        # Initiator & Responder:
+        # - expect unavailable on the Initiator party if the
+        #   Initiator and Responder with mac or encryption mismatch
+        # - For responder:
+        #   - If mac mismatch, responder will keep waiting ...
+        #   - If encryption mismatch, responder expect unavailable
+        p_network_callback_event = init_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        p_callback_name = p_network_callback_event.data[_CALLBACK_NAME]
+        asserts.assert_equal(
+            p_callback_name, constants.NetworkCbName.ON_UNAVAILABLE,
+            f'{init_dut} failed to request the network, got callback'
+            f' {p_callback_name}.'
+            )
+        time.sleep(self.EVENT_NDP_TIMEOUT)
+        if init_mismatch_mac or resp_mismatch_mac:
+            autils.callback_no_response(
+                resp_handler, constants.NetworkCbEventName.NETWORK_CALLBACK,
+                10, True
+            )
+        else:
+            s_network_callback_event = resp_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+            s_callback_name = s_network_callback_event.data[_CALLBACK_NAME]
+            asserts.assert_equal(
+                s_callback_name, constants.NetworkCbName.ON_UNAVAILABLE,
+                f'{resp_dut} failed to request the network, got callback'
+                f' {s_callback_name}.'
+                )
+        init_dut.wifi_aware_snippet.connectivityUnregisterNetwork(network_id)
+        resp_dut.wifi_aware_snippet.connectivityUnregisterNetwork(network_id)
+
+    def get_network_specifier(self, dut, id, dev_type, peer_mac, sec, net_work_request_id):
+        """Create a network specifier for the device based on the security
+        configuration.
+
+        Args:
+        dut: device
+        id: session ID
+        dev_type: device type - Initiator or Responder
+        peer_mac: the discovery MAC address of the peer
+        sec: security configuration
+        """
+        if sec is None:
+            network_specifier_parcel = (
+                dut.wifi_aware_snippet.createNetworkSpecifierOob(
+                id, dev_type, peer_mac, None, None)
+                )
+        if isinstance(sec, str):
+            network_specifier_parcel = (
+                dut.wifi_aware_snippet.createNetworkSpecifierOob(
+                id, dev_type, peer_mac, sec, None)
+                )
+        else:
+            network_specifier_parcel = (
+                dut.wifi_aware_snippet.createNetworkSpecifierOob(
+                id, dev_type, peer_mac, None, sec)
+                )
+        network_request_dict = constants.NetworkRequest(
+            transport_type=constants.NetworkCapabilities.Transport.TRANSPORT_WIFI_AWARE,
+            network_specifier_parcel=network_specifier_parcel["result"],
+        ).to_dict()
+        return dut.wifi_aware_snippet.connectivityRequestNetwork(
+            net_work_request_id, network_request_dict, _REQUEST_NETWORK_TIMEOUT_MS
+        )
+
+    def run_mix_ib_oob(self, same_request, ib_first, inits_on_same_dut):
+        """Validate that multiple network requests issued using both in-band
+        and out-of-band discovery behave as expected.
+
+        The same_request parameter controls whether identical single NDP is
+        expected, if True, or whether multiple NDPs on different NDIs are
+        expected, if False.
+
+        Args:
+            same_request: Issue canonically identical requests (same NMI peer,
+            same passphrase) if True, if False use different passphrases.
+            ib_first: If True then the in-band network is requested first,
+            otherwise (if False) then the out-of-band network is requested first.
+            inits_on_same_dut: If True then the Initiators are run on the same
+            device, otherwise (if False) then the Initiators are run on
+            different devices. Note that Subscribe == Initiator.
+        """
+        p_dut = self.ads[0]
+        s_dut = self.ads[1]
+        if not same_request:
+            asserts.skip_if(
+                autils.get_aware_capabilities(p_dut)[
+                    _CAP_MAX_NDI_INTERFACES] < 2 or
+                autils.get_aware_capabilities(s_dut)[
+                    _CAP_MAX_NDI_INTERFACES] < 2,
+                "DUTs do not support enough NDIs")
+
+        (p_dut, s_dut, p_id, s_id, p_disc_id, s_disc_id, peer_id_on_sub,
+         peer_id_on_pub) = self.set_up_discovery(_PUBLISH_TYPE_UNSOLICITED,
+                                                 _SUBSCRIBE_TYPE_PASSIVE, True)
+        p_id2, p_mac = self.attach_with_identity(p_dut)
+        s_id2, s_mac = self.attach_with_identity(s_dut)
+        time.sleep(self.WAIT_FOR_CLUSTER)
+
+        if inits_on_same_dut:
+            resp_dut = p_dut
+            resp_id = p_id2
+            resp_mac = p_mac
+            init_dut = s_dut
+            init_id = s_id2
+            init_mac = s_mac
+
+        else:
+            resp_dut = s_dut
+            resp_id = s_id2
+            resp_mac = s_mac
+            init_dut = p_dut
+            init_id = p_id2
+            init_mac = p_mac
+
+        passphrase = None if same_request else self.PASSPHRASE
+        pub_accept_handler = (
+            p_dut.wifi_aware_snippet.connectivityServerSocketAccept())
+        network_id = pub_accept_handler.callback_id
+        self.publish_session = p_disc_id.callback_id
+        self.subscribe_session = s_disc_id.callback_id
+
+        if ib_first:
+            # request in-band network (to completion)
+            p_req_key = self._request_network(
+                ad=p_dut,
+                discovery_session=self.publish_session,
+                peer=peer_id_on_pub,
+                net_work_request_id=network_id
+                )
+            s_req_key = self._request_network(
+                ad=s_dut,
+                discovery_session=self.subscribe_session,
+                peer=peer_id_on_sub,
+                net_work_request_id=network_id
+                )
+            p_net_event_nc = autils.wait_for_network(
+                ad=p_dut,
+                request_network_cb_handler=p_req_key,
+                expected_channel=None,
+                )
+            s_net_event_nc = autils.wait_for_network(
+                ad=s_dut,
+                request_network_cb_handler=s_req_key,
+                expected_channel=None,
+                )
+            p_net_event_lp = autils.wait_for_link(
+                ad=p_dut,
+                request_network_cb_handler=p_req_key,
+                )
+            s_net_event_lp = autils.wait_for_link(
+                ad=s_dut,
+                request_network_cb_handler=s_req_key,
+                )
+            # validate no leak of information
+            asserts.assert_false(
+                _NETWORK_CB_KEY_NETWORK_SPECIFIER in p_net_event_nc.data,
+                "Network specifier leak!")
+            asserts.assert_false(
+                _NETWORK_CB_KEY_NETWORK_SPECIFIER in s_net_event_nc.data,
+                "Network specifier leak!")
+
+        # request out-of-band network
+        init_dut_accept_handler = (
+            init_dut.wifi_aware_snippet.connectivityServerSocketAccept())
+        network_id = init_dut_accept_handler.callback_id
+        resp_req_key = self.request_oob_network(
+            resp_dut,
+            resp_id,
+            _DATA_PATH_RESPONDER,
+            init_mac,
+            passphrase,
+            None,
+            network_id
+            )
+        init_req_key = self.request_oob_network(
+            init_dut,
+            init_id,
+            _DATA_PATH_INITIATOR,
+            resp_mac,
+            passphrase,
+            None,
+            network_id
+            )
+        time.sleep(5)
+        # Publisher & Subscriber: wait for network formation
+        resp_net_event_nc = autils.wait_for_network(
+            ad=resp_dut,
+            request_network_cb_handler=resp_req_key,
+            expected_channel=None,
+            )
+        init_net_event_nc = autils.wait_for_network(
+            ad=init_dut,
+            request_network_cb_handler=init_req_key,
+            expected_channel=None,
+            )
+        resp_net_event_lp = autils.wait_for_link(
+            ad=resp_dut,
+            request_network_cb_handler=resp_req_key,
+            )
+        init_net_event_lp = autils.wait_for_link(
+            ad=init_dut,
+            request_network_cb_handler=init_req_key,
+            )
+        # validate no leak of information
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in resp_net_event_nc.data,
+            "Network specifier leak!")
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in init_net_event_nc.data,
+            "Network specifier leak!")
+
+        if not ib_first:
+            # request in-band network (to completion)
+            p_req_key = self._request_network(
+                ad=p_dut,
+                discovery_session=self.publish_session,
+                peer=peer_id_on_pub,
+                net_work_request_id=network_id
+                )
+            s_req_key = self._request_network(
+                ad=s_dut,
+                discovery_session=self.subscribe_session,
+                peer=peer_id_on_sub,
+                net_work_request_id=network_id
+                )
+            # Publisher & Subscriber: wait for network formation
+            p_net_event_nc = autils.wait_for_network(
+                ad=p_dut,
+                request_network_cb_handler=p_req_key,
+                expected_channel=None,
+                )
+            s_net_event_nc = autils.wait_for_network(
+                ad=s_dut,
+                request_network_cb_handler=s_req_key,
+                expected_channel=None,
+                )
+            p_net_event_lp = autils.wait_for_link(
+                ad=p_dut,
+                request_network_cb_handler=p_req_key,
+                )
+            s_net_event_lp = autils.wait_for_link(
+                ad=s_dut,
+                request_network_cb_handler=s_req_key,
+                )
+            # validate no leak of information
+            asserts.assert_false(
+                _NETWORK_CB_KEY_NETWORK_SPECIFIER in p_net_event_nc.data,
+                "Network specifier leak!")
+            asserts.assert_false(
+                _NETWORK_CB_KEY_NETWORK_SPECIFIER in s_net_event_nc.data,
+                "Network specifier leak!")
+
+        # note that Init <-> Resp & Pub <--> Sub since IPv6 are of peer's!
+        init_ipv6 = resp_net_event_nc.data[constants.NetworkCbName.NET_CAP_IPV6]
+        resp_ipv6 = init_net_event_nc.data[constants.NetworkCbName.NET_CAP_IPV6]
+        pub_ipv6 = s_net_event_nc.data[constants.NetworkCbName.NET_CAP_IPV6]
+        sub_ipv6 = p_net_event_nc.data[constants.NetworkCbName.NET_CAP_IPV6]
+
+        # extract net info
+        pub_interface = p_net_event_lp.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        sub_interface = s_net_event_lp.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        resp_interface = resp_net_event_lp.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        init_interface = init_net_event_lp.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        logging.info(
+            "Interface names: Pub=%s, Sub=%s, Resp=%s, Init=%s",
+            pub_interface, sub_interface, resp_interface,
+            init_interface
+            )
+        logging.info(
+            "Interface addresses (IPv6): Pub=%s, Sub=%s, Resp=%s, Init=%s",
+            pub_ipv6, sub_ipv6, resp_ipv6, init_ipv6)
+
+        # validate NDP/NDI conditions (using interface names & ipv6)
+        if same_request:
+            asserts.assert_equal(
+                pub_interface, resp_interface if inits_on_same_dut else
+                init_interface, "NDP interfaces don't match on Pub/other")
+            asserts.assert_equal(
+                sub_interface, init_interface if inits_on_same_dut else
+                resp_interface, "NDP interfaces don't match on Sub/other")
+
+            asserts.assert_equal(
+                pub_ipv6, resp_ipv6 if inits_on_same_dut else init_ipv6,
+                "NDP IPv6 don't match on Pub/other")
+            asserts.assert_equal(
+                sub_ipv6, init_ipv6 if inits_on_same_dut else resp_ipv6,
+                "NDP IPv6 don't match on Sub/other")
+        else:
+            asserts.assert_false(
+                pub_interface == (
+                    resp_interface if inits_on_same_dut else init_interface),
+                "NDP interfaces match on Pub/other")
+            asserts.assert_false(
+                sub_interface == (
+                    init_interface if inits_on_same_dut else resp_interface),
+                "NDP interfaces match on Sub/other")
+
+            asserts.assert_false(
+                pub_ipv6 == (resp_ipv6 if inits_on_same_dut else init_ipv6),
+                "NDP IPv6 match on Pub/other")
+            asserts.assert_false(
+                sub_ipv6 == (init_ipv6 if inits_on_same_dut else resp_ipv6),
+                "NDP IPv6 match on Sub/other")
+
+        # release requests
+        init_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+            init_net_event_nc.callback_id)
+        resp_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+            resp_net_event_nc.callback_id)
+        p_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+            p_net_event_nc.callback_id)
+        s_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+            s_net_event_nc.callback_id)
+
+    def create_oob_ndp_on_sessions(self,
+                                   init_dut,
+                                   resp_dut,
+                                   init_id,
+                                   init_mac,
+                                   resp_id,
+                                   resp_mac):
+        """Create an NDP on top of existing Aware sessions (using OOB discovery)
+
+        Args:
+            init_dut: Initiator device
+            resp_dut: Responder device
+            init_id: Initiator attach session id
+            init_mac: Initiator discovery MAC address
+            resp_id: Responder attach session id
+            resp_mac: Responder discovery MAC address
+        Returns:
+            init_req_key: Initiator network request
+            resp_req_key: Responder network request
+            init_aware_if: Initiator Aware data interface
+            resp_aware_if: Responder Aware data interface
+            init_ipv6: Initiator IPv6 address
+            resp_ipv6: Responder IPv6 address
+        """
+        # Responder: request network
+        init_dut_accept_handler = init_dut.wifi_aware_snippet.connectivityServerSocketAccept()
+        network_id = init_dut_accept_handler.callback_id
+        init_local_port = init_dut_accept_handler.ret_value
+        resp_req_key = self.request_oob_network(
+            resp_dut,
+            resp_id,
+            _DATA_PATH_RESPONDER,
+            init_mac,
+            None,
+            None,
+            network_id
+            )
+        # Initiator: request network
+        init_req_key = self.request_oob_network(
+            init_dut,
+            init_id,
+            _DATA_PATH_INITIATOR,
+            resp_mac,
+            None,
+            None,
+            network_id
+            )
+        time.sleep(5)
+        init_callback_event = init_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        init_name = init_callback_event.data[_CALLBACK_NAME]
+        resp_callback_event = resp_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        resp_name = resp_callback_event.data[_CALLBACK_NAME]
+        asserts.assert_equal(
+            init_name, constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+            f'{init_dut} succeeded to request the network, got callback'
+            f' {init_name}.'
+            )
+        asserts.assert_equal(
+            resp_name, constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+            f'{resp_dut} succeeded to request the network, got callback'
+            f' {resp_name}.'
+            )
+        init_net_event_nc = init_callback_event.data
+        resp_net_event_nc = resp_callback_event.data
+            # validate no leak of information
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in init_net_event_nc,
+            "Network specifier leak!")
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in resp_net_event_nc,
+            "Network specifier leak!")
+
+        #To get ipv6 ip address
+        resp_ipv6= init_net_event_nc[constants.NetworkCbName.NET_CAP_IPV6]
+        init_ipv6 = resp_net_event_nc[constants.NetworkCbName.NET_CAP_IPV6]
+        # note that Pub <-> Sub since IPv6 are of peer's!
+        init_callback_LINK = init_req_key.waitAndGet(
+            event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+            timeout=_DEFAULT_TIMEOUT,
+            )
+        asserts.assert_equal(
+            init_callback_LINK.data[_CALLBACK_NAME],
+            _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+            f'{init_dut} succeeded to request the'+
+            ' LinkPropertiesChanged, got callback'
+            f' {init_callback_LINK.data[_CALLBACK_NAME]}.'
+                )
+        resp_callback_LINK = resp_req_key.waitAndGet(
+            event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+            timeout=_DEFAULT_TIMEOUT,
+            )
+        asserts.assert_equal(
+            resp_callback_LINK.data[_CALLBACK_NAME],
+            _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+            f'{resp_dut} succeeded to request the'+
+            'LinkPropertiesChanged, got callback'
+            f' {resp_callback_LINK.data[_CALLBACK_NAME]}.'
+            )
+        init_aware_if = init_callback_LINK.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        resp_aware_if = resp_callback_LINK.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        return (init_req_key, resp_req_key, init_aware_if, resp_aware_if,
+            init_ipv6, resp_ipv6)
+
+    def set_wifi_country_code(self,
+                              ad: android_device.AndroidDevice,
+                              country_code):
+        """Sets the wifi country code on the device.
+
+        Args:
+            ad: An AndroidDevice object.
+            country_code: 2 letter ISO country code
+
+        Raises:
+            An RpcException if unable to set the country code.
+        """
+        try:
+            ad.adb.shell("cmd wifi force-country-code enabled %s" % country_code)
+        except Exception as e:
+            ad.log.info(f"ADB command execution failed: {e}")
+
+    def create_data_ib_ndp(
+        self,
+        p_dut: android_device.AndroidDevice,
+        s_dut: android_device.AndroidDevice,
+        p_config: dict[str, any],
+        s_config: dict[str, any]
+        ):
+        """Create an NDP (using in-band discovery).
+        Args:
+        p_dut: Device to use as publisher.
+        s_dut: Device to use as subscriber.
+        p_config: Publish configuration.
+        s_config: Subscribe configuration.
+
+        Returns:
+        A tuple containing the following:
+            - Publisher network capabilities.
+            - Subscriber network capabilities.
+            - Publisher network interface name.
+            - Subscriber network interface name.
+            - Publisher IPv6 address.
+            - Subscriber IPv6 address.
+        """
+
+        (p_id, s_id, p_disc_id, s_disc_id, peer_id_on_sub, peer_id_on_pub) = (
+            autils.create_discovery_pair(
+                p_dut, s_dut, p_config, s_config, msg_id=9999
+                )
+        )
+        pub_accept_handler = (
+            p_dut.wifi_aware_snippet.connectivityServerSocketAccept()
+        )
+        network_id = pub_accept_handler.callback_id
+
+        # Request network Publisher (responder).
+        pub_network_cb_handler = self._request_network(
+            ad=p_dut,
+            discovery_session=p_disc_id.callback_id,
+            peer=peer_id_on_pub,
+            net_work_request_id=network_id,
+        )
+
+        # Request network for Subscriber (initiator).
+        sub_network_cb_handler = self._request_network(
+            ad=s_dut,
+            discovery_session=s_disc_id.callback_id,
+            peer=peer_id_on_sub,
+            net_work_request_id=network_id,
+        )
+        resp_net_event_nc = sub_network_cb_handler.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        # time.sleep(5)
+        init_net_event_nc = pub_network_cb_handler.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        s_ipv6 = resp_net_event_nc.data[constants.NetworkCbName.NET_CAP_IPV6]
+        p_ipv6 = init_net_event_nc.data[constants.NetworkCbName.NET_CAP_IPV6]
+        p_network_callback_LINK = pub_network_cb_handler.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        s_network_callback_LINK = sub_network_cb_handler.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        s_aware_if = s_network_callback_LINK.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        p_aware_if = p_network_callback_LINK.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        pub_network_cap = autils.wait_for_network(
+            ad=p_dut,
+            request_network_cb_handler=pub_network_cb_handler,
+            expected_channel=None,
+        )
+        sub_network_cap = autils.wait_for_network(
+            ad=s_dut,
+            request_network_cb_handler=sub_network_cb_handler,
+            expected_channel=None,
+        )
+
+        p_dut.log.info('interfaceName = %s, ipv6=%s', p_aware_if, p_ipv6)
+
+        s_dut.log.info('interfaceName = %s, ipv6=%s', s_aware_if, s_ipv6)
+        return (
+            pub_network_cap,
+            sub_network_cap,
+            p_aware_if,
+            s_aware_if,
+            p_ipv6,
+            s_ipv6,
+        )
+
+    def run_multiple_regulatory_domains(self, use_ib, init_domain,
+                                        resp_domain):
+        """Verify that a data-path setup with two conflicting regulatory domains
+            works (the result should be run in Channel 6 - but that is not tested).
+
+        Args:
+            use_ib: True to use in-band discovery, False to use out-of-band discovery.
+            init_domain: The regulatory domain of the Initiator/Subscriber.
+            resp_domain: The regulator domain of the Responder/Publisher.
+        """
+        init_dut = self.ads[0]
+        resp_dut = self.ads[1]
+        asserts.skip_if(
+            not init_dut.is_adb_root or not resp_dut.is_adb_root,
+            'Country code toggle needs Android device(s) with root permission',
+        )
+        self.set_wifi_country_code(init_dut, init_domain)
+        self.set_wifi_country_code(resp_dut, resp_domain)
+        if use_ib:
+            (resp_req_key, init_req_key, resp_aware_if, init_aware_if,
+             resp_ipv6, init_ipv6) = self.create_data_ib_ndp(
+                 resp_dut, init_dut,
+                 autils.create_discovery_config(
+                     "GoogleTestXyz", _PUBLISH_TYPE_UNSOLICITED),
+                 autils.create_discovery_config(
+                     "GoogleTestXyz", _SUBSCRIBE_TYPE_PASSIVE),
+                 )
+        else:
+            init_id, init_mac = self.attach_with_identity(init_dut)
+            resp_id, resp_mac = self.attach_with_identity(resp_dut)
+            time.sleep(self.WAIT_FOR_CLUSTER)
+            (init_req_key, resp_req_key, init_aware_if, resp_aware_if, init_ipv6,
+             resp_ipv6) = self.create_oob_ndp_on_sessions(init_dut, resp_dut, init_id,
+                                                          init_mac, resp_id, resp_mac)
+        logging.info("Interface names: I=%s, R=%s", init_aware_if,
+                      resp_aware_if)
+        logging.info("Interface addresses (IPv6): I=%s, R=%s", init_ipv6,
+                      resp_ipv6)
+        pub_accept_handler = (
+            init_dut.wifi_aware_snippet.connectivityServerSocketAccept()
+        )
+        network_id = pub_accept_handler.callback_id
+        # clean-up
+        resp_dut.wifi_aware_snippet.connectivityUnregisterNetwork(network_id)
+        init_dut.wifi_aware_snippet.connectivityUnregisterNetwork(network_id)
+
+    #######################################
+    # Positive In-Band (IB) tests key:
+    #
+    # names is: test_ib_<pub_type>_<sub_type>_<encr_type>_<peer_spec>
+    # where:
+    #
+    # pub_type: Type of publish discovery session: unsolicited or solicited.
+    # sub_type: Type of subscribe discovery session: passive or active.
+    # encr_type: Encryption type: open, passphrase
+    # peer_spec: Peer specification method: any or specific
+    #
+    # Note: In-Band means using Wi-Fi Aware for discovery and referring to the
+    # peer using the Aware-provided peer handle (as opposed to a MAC address).
+    #######################################
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+
+    def test_ib_unsolicited_passive_open_specific(self):
+        """Data-path: in-band, unsolicited/passive, open encryption, specific peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_OPEN,
+            use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+
+    def test_ib_unsolicited_passive_open_any(self):
+        """Data-path: in-band, unsolicited/passive, open encryption, any peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_OPEN,
+            use_peer_id=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+
+    def test_ib_unsolicited_passive_passphrase_specific(self):
+        """Data-path: in-band, unsolicited/passive, passphrase, specific peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_PASSPHRASE,
+            use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+
+    def test_ib_unsolicited_passive_passphrase_any(self):
+        """Data-path: in-band, unsolicited/passive, passphrase, any peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_PASSPHRASE,
+            use_peer_id=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPmk(byte[])',
+        ]
+    )
+
+    def test_ib_unsolicited_passive_pmk_specific(self):
+        """Data-path: in-band, unsolicited/passive, PMK, specific peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_PMK,
+            use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPmk(byte[])',
+        ]
+    )
+
+    def test_ib_unsolicited_passive_pmk_any(self):
+        """Data-path: in-band, unsolicited/passive, PMK, any peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_PMK,
+            use_peer_id=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+
+    def test_ib_solicited_active_open_specific(self):
+        """Data-path: in-band, solicited/active, open encryption, specific peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_SOLICITED,
+            stype=_SUBSCRIBE_TYPE_ACTIVE,
+            encr_type=self.ENCR_TYPE_OPEN,
+            use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+
+    def test_ib_solicited_active_open_any(self):
+        """Data-path: in-band, solicited/active, open encryption, any peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_SOLICITED,
+            stype=_SUBSCRIBE_TYPE_ACTIVE,
+            encr_type=self.ENCR_TYPE_OPEN,
+            use_peer_id=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+
+    def test_ib_solicited_active_passphrase_specific(self):
+        """Data-path: in-band, solicited/active, passphrase, specific peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_SOLICITED,
+            stype=_SUBSCRIBE_TYPE_ACTIVE,
+            encr_type=self.ENCR_TYPE_PASSPHRASE,
+            use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+
+    def test_ib_solicited_active_passphrase_any(self):
+        """Data-path: in-band, solicited/active, passphrase, any peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_SOLICITED,
+            stype=_SUBSCRIBE_TYPE_ACTIVE,
+            encr_type=self.ENCR_TYPE_PASSPHRASE,
+            use_peer_id=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPmk(byte[])',
+        ]
+    )
+
+    def test_ib_solicited_active_pmk_specific(self):
+        """Data-path: in-band, solicited/active, PMK, specific peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_SOLICITED,
+            stype=_SUBSCRIBE_TYPE_ACTIVE,
+            encr_type=self.ENCR_TYPE_PMK,
+            use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPmk(byte[])',
+        ]
+    )
+
+    def test_ib_solicited_active_pmk_any(self):
+        """Data-path: in-band, solicited/active, PMK, any peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_SOLICITED,
+            stype=_SUBSCRIBE_TYPE_ACTIVE,
+            encr_type=self.ENCR_TYPE_PMK,
+            use_peer_id=False)
+
+
+    #######################################
+    # Positive In-Band (IB) with a publish session running on the subscriber
+    # tests key:
+    #
+    # names is: test_ib_extra_pub_<same|diff>_<pub_type>_<sub_type>
+    #                                          _<encr_type>_<peer_spec>
+    # where:
+    #
+    # same|diff: Whether the extra publish session (on the subscriber) is the same
+    #            or different from the primary session.
+    # pub_type: Type of publish discovery session: unsolicited or solicited.
+    # sub_type: Type of subscribe discovery session: passive or active.
+    # encr_type: Encryption type: open, passphrase
+    # peer_spec: Peer specification method: any or specific
+    #
+    # Note: In-Band means using Wi-Fi Aware for discovery and referring to the
+    # peer using the Aware-provided peer handle (as opposed to a MAC address).
+    #######################################
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+
+    def test_ib_extra_pub_same_unsolicited_passive_open_specific(self):
+        """Data-path: in-band, unsolicited/passive, open encryption.
+                    specific peer.
+
+        Configuration contains a publisher (for the same service)
+        running on *both* devices.
+
+        Verifies end-to-end discovery + data-path creation.
+        """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_OPEN,
+            use_peer_id=True,
+            pub_on_both=True,
+            pub_on_both_same=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+
+    def test_ib_extra_pub_same_unsolicited_passive_open_any(self):
+        """Data-path: in-band, unsolicited/passive, open encryption.
+                    any peer.
+
+        Configuration contains a publisher (for the same service) running on
+        *both* devices.
+
+        Verifies end-to-end discovery + data-path creation.
+        """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_OPEN,
+            use_peer_id=False,
+            pub_on_both=True,
+            pub_on_both_same=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+
+    def test_ib_extra_pub_diff_unsolicited_passive_open_specific(self):
+        """Data-path: in-band, unsolicited/passive, open encryption.
+                    specific peer.
+
+        Configuration contains a publisher (for a different service) running on
+        *both* devices.
+
+        Verifies end-to-end discovery + data-path creation.
+        """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_OPEN,
+            use_peer_id=True,
+            pub_on_both=True,
+            pub_on_both_same=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+
+    def test_ib_extra_pub_diff_unsolicited_passive_open_any(self):
+        """Data-path: in-band, unsolicited/passive, open encryption, any peer.
+
+        Configuration contains a publisher (for a different service) running on
+        *both* devices.
+
+        Verifies end-to-end discovery + data-path creation.
+        """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_OPEN,
+            use_peer_id=False,
+            pub_on_both=True,
+            pub_on_both_same=False)
+
+    ##############################################################
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+
+    def test_passphrase_min(self):
+        """Data-path: minimum passphrase length
+
+        Use in-band, unsolicited/passive, any peer combination
+        """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_PASSPHRASE,
+            use_peer_id=False,
+            passphrase_to_use=self.PASSPHRASE_MIN)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+
+    def test_passphrase_max(self):
+        """Data-path: maximum passphrase length
+
+        Use in-band, unsolicited/passive, any peer combination
+        """
+        self.run_ib_data_path_test(
+            ptype=_PUBLISH_TYPE_UNSOLICITED,
+            stype=_SUBSCRIBE_TYPE_PASSIVE,
+            encr_type=self.ENCR_TYPE_PASSPHRASE,
+            use_peer_id=False,
+            passphrase_to_use=self.PASSPHRASE_MAX)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_negative_mismatch_init_mac(self):
+        """Data-path: failure when Initiator MAC address mismatch"""
+        self.run_mismatched_oob_data_path_test(
+            init_mismatch_mac=True, resp_mismatch_mac=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_negative_mismatch_resp_mac(self):
+        """Data-path: failure when Responder MAC address mismatch"""
+        self.run_mismatched_oob_data_path_test(
+            init_mismatch_mac=False, resp_mismatch_mac=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        ]
+    )
+
+    def test_negative_mismatch_passphrase(self):
+        """Data-path: failure when passphrases mismatch"""
+        self.run_mismatched_oob_data_path_test(
+            init_encr_type=self.ENCR_TYPE_PASSPHRASE,
+            resp_encr_type=self.ENCR_TYPE_PASSPHRASE)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        ]
+    )
+
+    def test_negative_mismatch_open_passphrase(self):
+        """Data-path:
+            failure when initiator is open, and responder passphrase
+        """
+        self.run_mismatched_oob_data_path_test(
+            init_encr_type=self.ENCR_TYPE_OPEN,
+            resp_encr_type=self.ENCR_TYPE_PASSPHRASE)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        ]
+    )
+
+    def test_negative_mismatch_passphrase_open(self):
+        """Data-path:
+            failure when initiator is passphrase, and responder open
+        """
+        self.run_mismatched_oob_data_path_test(
+            init_encr_type=self.ENCR_TYPE_PASSPHRASE,
+            resp_encr_type=self.ENCR_TYPE_OPEN)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        ]
+    )
+
+    def test_negative_mismatch_pmk(self):
+        """Data-path: failure when PMK mismatch"""
+        self.run_mismatched_oob_data_path_test(
+            init_encr_type=self.ENCR_TYPE_PMK,
+            resp_encr_type=self.ENCR_TYPE_PMK)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        ]
+    )
+
+    def test_negative_mismatch_open_pmk(self):
+        """Data-path: failure when initiator is open, and responder PMK"""
+        self.run_mismatched_oob_data_path_test(
+            init_encr_type=self.ENCR_TYPE_OPEN,
+            resp_encr_type=self.ENCR_TYPE_PMK)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        ]
+    )
+
+    def test_negative_mismatch_pmk_passphrase(self):
+        """Data-path: failure when initiator is pmk, and responder passphrase"""
+        self.run_mismatched_oob_data_path_test(
+            init_encr_type=self.ENCR_TYPE_PMK,
+            resp_encr_type=self.ENCR_TYPE_PASSPHRASE)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        ]
+    )
+
+    def test_negative_mismatch_pmk_open(self):
+        """Data-path: failure when initiator is PMK, and responder open"""
+        self.run_mismatched_oob_data_path_test(
+            init_encr_type=self.ENCR_TYPE_PMK,
+            resp_encr_type=self.ENCR_TYPE_OPEN)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        ]
+    )
+
+    def test_negative_mismatch_passphrase_pmk(self):
+        """Data-path: failure when initiator is passphrase, and responder pmk"""
+        self.run_mismatched_oob_data_path_test(
+            init_encr_type=self.ENCR_TYPE_PASSPHRASE,
+            resp_encr_type=self.ENCR_TYPE_PMK)
+
+    #######################################
+    # Positive Out-of-Band (OOB) tests key:
+    #
+    # names is: test_oob_<encr_type>_<peer_spec>
+    # where:
+    #
+    # encr_type: Encryption type: open, passphrase
+    # peer_spec: Peer specification method: any or specific
+    #
+    # Optionally set up an extra discovery session to test coexistence. If so
+    # add "ib_coex" to test name.
+    #
+    # Note: Out-of-Band means using a non-Wi-Fi Aware mechanism for discovery
+    # and exchange of MAC addresses and then Wi-Fi Aware for data-path.
+    #######################################
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_oob_open_specific(self):
+        """Data-path: out-of-band, open encryption, specific peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_oob_data_path_test(
+            encr_type=self.ENCR_TYPE_OPEN, use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        ]
+    )
+
+    def test_oob_passphrase_specific(self):
+        """Data-path: out-of-band, passphrase, specific peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_oob_data_path_test(
+            encr_type=self.ENCR_TYPE_PASSPHRASE, use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        ]
+    )
+
+    def test_oob_pmk_specific(self):
+        """Data-path: out-of-band, PMK, specific peer
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_oob_data_path_test(
+            encr_type=self.ENCR_TYPE_PMK, use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_oob_ib_coex_open_specific(self):
+        """Data-path: out-of-band, open encryption, specific peer - in-band coex:
+    set up a concurrent discovery session to verify no impact. The session
+    consists of Publisher on both ends, and a Subscriber on the Responder.
+
+    Verifies end-to-end discovery + data-path creation.
+    """
+        self.run_oob_data_path_test(
+            encr_type=self.ENCR_TYPE_OPEN,
+            setup_discovery_sessions=True , use_peer_id=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_identical_networks(self):
+        """Validate that creating multiple networks between 2 devices, each network
+        with identical configuration is supported over a single NDP.
+
+        Verify that the interface and IPv6 address is the same for all networks.
+        """
+        init_dut = self.ads[0]
+        init_dut.pretty_name = "Initiator"
+        resp_dut = self.ads[1]
+        resp_dut.pretty_name = "Responder"
+        N = 2  # first iteration (must be 2 to give us a chance to cancel the first)
+        M = 5  # second iteration
+
+        init_ids = []
+        resp_ids = []
+
+        # Initiator+Responder: attach and wait for confirmation & identity
+        # create N+M sessions to be used in the different (but identical) NDPs
+        for i in range(N + M):
+            id, init_mac = self.attach_with_identity(init_dut)
+            init_ids.append(id)
+            id, resp_mac = self.attach_with_identity(resp_dut)
+            resp_ids.append(id)
+
+        # wait for devices to synchronize with each other - there are no other
+        # mechanisms to make sure this happens for OOB discovery (except retrying
+        # to execute the data-path request)
+        time.sleep(self.WAIT_FOR_CLUSTER)
+
+        resp_req_keys = []
+        init_req_keys = []
+        resp_aware_ifs = []
+        init_aware_ifs = []
+        resp_aware_ipv6 = []
+        init_aware_ipv6 = []
+        init_dut_accept_handler = (
+            init_dut.wifi_aware_snippet.connectivityServerSocketAccept())
+        network_id = init_dut_accept_handler.callback_id
+        for i in range(N):
+            init_req_key = self.request_oob_network(
+                init_dut,
+                init_ids[i],
+                _DATA_PATH_INITIATOR,
+                resp_mac,
+                None,
+                None,
+                network_id
+                )
+            init_req_keys.append(init_req_key)
+            resp_ini_key = self.request_oob_network(
+                resp_dut,
+                resp_ids[i],
+                _DATA_PATH_RESPONDER,
+                init_mac,
+                None,
+                None,
+                network_id
+                )
+            resp_req_keys.append(resp_ini_key)
+            self.wait_for_request_responses(init_dut, init_req_keys[i],
+             init_aware_ifs, resp_aware_ipv6)
+            self.wait_for_request_responses(resp_dut,
+             resp_req_keys[i], resp_aware_ifs, init_aware_ipv6)
+        for i in range(M):
+            init_req_key = self.request_oob_network(
+                init_dut,
+                init_ids[N + i],
+                _DATA_PATH_INITIATOR,
+                resp_mac,
+                None,
+                None,
+                network_id
+                )
+            init_req_keys.append(init_req_key)
+            resp_ini_key = self.request_oob_network(
+                resp_dut,
+                resp_ids[N + i],
+                _DATA_PATH_RESPONDER,
+                init_mac,
+                None,
+                None,
+                network_id
+                )
+            resp_req_keys.append(resp_ini_key)
+            self.wait_for_request_responses(init_dut, init_req_keys[i],
+             init_aware_ifs, resp_aware_ipv6)
+            self.wait_for_request_responses(resp_dut, resp_req_keys[i],
+             resp_aware_ifs, init_aware_ipv6)
+        # determine whether all interfaces and ipv6 addresses are identical
+        # (single NDP)
+        init_aware_ifs = list(set(init_aware_ifs))
+        resp_aware_ifs = list(set(resp_aware_ifs))
+        init_aware_ipv6 = list(set(init_aware_ipv6))
+        resp_aware_ipv6 = list(set(resp_aware_ipv6))
+        logging.info("Interface names: I=%s, R=%s", init_aware_ifs, resp_aware_ifs)
+        logging.info("Interface IPv6: I=%s, R=%s", init_aware_ipv6, resp_aware_ipv6)
+        logging.info("Initiator requests: %s", init_req_keys)
+        logging.info("Responder requests: %s", resp_req_keys)
+        asserts.assert_equal(
+            len(init_aware_ifs), 1, "Multiple initiator interfaces")
+        asserts.assert_equal(
+            len(resp_aware_ifs), 1, "Multiple responder interfaces")
+        asserts.assert_equal(
+            len(init_aware_ipv6), 1, "Multiple initiator IPv6 addresses")
+        asserts.assert_equal(
+            len(resp_aware_ipv6), 1, "Multiple responder IPv6 addresses")
+
+        if init_dut.is_adb_root:
+            for i in range(
+                autils.get_aware_capabilities(init_dut)[_CAP_MAX_NDI_INTERFACES]):
+                if_name = "%s%d" %("aware_data",i)
+                init_ipv6 = self.get_ipv6_addr(init_dut, if_name)
+                resp_ipv6 = self.get_ipv6_addr(resp_dut, if_name)
+                asserts.assert_equal(
+                    init_ipv6 is None, if_name not in init_aware_ifs,
+                    "Initiator interface %s in unexpected state" % if_name)
+                asserts.assert_equal(
+                    resp_ipv6 is None, if_name not in resp_aware_ifs,
+                    "Responder interface %s in unexpected state" % if_name)
+        for resp_req_key in resp_req_keys:
+            resp_req_callback_event = resp_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+            resp_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+                resp_req_callback_event.callback_id)
+        for init_req_key in init_req_keys:
+            init_req_callback_event = init_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+            init_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+                init_req_callback_event.callback_id)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_identical_network_from_both_sides(self):
+        """Validate that requesting two identical NDPs (Open) each being initiated
+        from a different side, results in the same/single NDP.
+
+        Verify that the interface and IPv6 address is the same for all networks.
+        """
+        init_dut = self.ads[0]
+        resp_dut = self.ads[1]
+        init_id, init_mac = self.attach_with_identity(init_dut)
+        resp_id, resp_mac = self.attach_with_identity(resp_dut)
+        time.sleep(self.WAIT_FOR_CLUSTER)
+        # first NDP: DUT1 (Init) -> DUT2 (Resp)
+        init_dut_accept_handler = (
+            init_dut.wifi_aware_snippet.connectivityServerSocketAccept())
+        network_id = init_dut_accept_handler.callback_id
+        resp_req_key_a = self.request_oob_network(
+            resp_dut,
+            resp_id,
+            _DATA_PATH_RESPONDER, # DATA_PATH_RESPONDER = 1
+            init_mac,
+            None,
+            None,
+            network_id
+            )
+
+        # Initiator: request network
+        init_req_key_a = self.request_oob_network(
+            init_dut,
+            init_id,
+            _DATA_PATH_INITIATOR, #DATA_PATH_INITIATOR = 0
+            resp_mac,
+            None,
+            None,
+            network_id
+            )
+        i_network_callback_event_a = init_req_key_a.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        i_callback_name_a = i_network_callback_event_a.data[_CALLBACK_NAME]
+        r_network_callback_event_a = resp_req_key_a.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        r_callback_name_a = r_network_callback_event_a.data[_CALLBACK_NAME]
+
+        asserts.assert_equal(
+                i_callback_name_a,
+                constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+                f'{init_dut} succeeded to request the network, got callback'
+                f' {i_callback_name_a}.'
+                )
+        network = i_network_callback_event_a.data[
+            constants.NetworkCbEventKey.NETWORK]
+        network_capabilities = i_network_callback_event_a.data[
+            constants.NetworkCbEventKey.NETWORK_CAPABILITIES]
+        asserts.assert_true(
+            network and network_capabilities,
+            f'{init_dut} received a null Network or NetworkCapabilities!?.'
+        )
+        asserts.assert_equal(
+            r_callback_name_a, constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+            f'{resp_dut} succeeded to request the network, got callback'
+            f' {r_callback_name_a}.'
+            )
+        network = r_network_callback_event_a.data[
+            constants.NetworkCbEventKey.NETWORK]
+        network_capabilities = r_network_callback_event_a.data[
+            constants.NetworkCbEventKey.NETWORK_CAPABILITIES]
+        asserts.assert_true(
+            network and network_capabilities,
+            f'{resp_dut} received a null Network or NetworkCapabilities!?.'
+        )
+        i_net_event_nc_a = i_network_callback_event_a.data
+        r_net_event_nc_a = r_network_callback_event_a.data
+        # validate no leak of information
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in i_net_event_nc_a,
+            "Network specifier leak!")
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in r_net_event_nc_a,
+            "Network specifier leak!")
+        #To get ipv6 ip address
+        i_ipv6_1= i_net_event_nc_a[constants.NetworkCbName.NET_CAP_IPV6]
+        r_ipv6_1 = r_net_event_nc_a[constants.NetworkCbName.NET_CAP_IPV6]
+        # note that Pub <-> Sub since IPv6 are of peer's!
+        i_network_callback_LINK_a = init_req_key_a.waitAndGet(
+            event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+            timeout=_DEFAULT_TIMEOUT,
+            )
+        asserts.assert_equal(
+            i_network_callback_LINK_a.data[_CALLBACK_NAME],
+            _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+            f'{init_dut} succeeded to request the LinkPropertiesChanged,'+
+            ' got callback'
+            f' {i_network_callback_LINK_a.data[_CALLBACK_NAME]}.'
+            )
+
+        r_network_callback_LINK_a = resp_req_key_a.waitAndGet(
+            event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+            timeout=_DEFAULT_TIMEOUT,
+            )
+        asserts.assert_equal(
+            r_network_callback_LINK_a.data[_CALLBACK_NAME],
+            _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+            f'{resp_dut} succeeded to request the LinkPropertiesChanged,'+
+            ' got callback'
+            f' {r_network_callback_LINK_a.data[_CALLBACK_NAME]}.'
+            )
+        i_aware_if_1 = i_network_callback_LINK_a.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        r_aware_if_1 = r_network_callback_LINK_a.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+
+        logging.info("Interface names: p=%s, s=%s", i_aware_if_1,
+                     r_aware_if_1)
+        logging.info("Interface addresses (IPv6): p=%s, s=%s", i_ipv6_1,
+                     r_ipv6_1)
+        # second NDP: DUT2 (Init) -> DUT1 (Resp)
+        init_req_key = self.request_oob_network(
+            init_dut,
+            init_id,
+            _DATA_PATH_RESPONDER,
+            resp_mac,
+            None,
+            None,
+            network_id
+            )
+        resp_ini_key = self.request_oob_network(
+            resp_dut,
+            resp_id,
+            _DATA_PATH_INITIATOR,
+            init_mac,
+            None,
+            None,
+            network_id
+            )
+        i_network_callback_event = init_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        i_callback_name = i_network_callback_event.data[_CALLBACK_NAME]
+        r_network_callback_event = resp_ini_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+            )
+        r_callback_name = r_network_callback_event.data[_CALLBACK_NAME]
+
+        asserts.assert_equal(
+                i_callback_name,
+                constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+                f'{init_dut} succeeded to request the network, got callback'
+                f' {i_callback_name}.'
+                )
+        network = i_network_callback_event.data[
+            constants.NetworkCbEventKey.NETWORK]
+        network_capabilities = i_network_callback_event.data[
+            constants.NetworkCbEventKey.NETWORK_CAPABILITIES]
+        asserts.assert_true(
+            network and network_capabilities,
+            f'{init_dut} received a null Network or NetworkCapabilities!?.'
+        )
+        asserts.assert_equal(
+            r_callback_name, constants.NetworkCbName.ON_CAPABILITIES_CHANGED,
+            f'{resp_dut} succeeded to request the network, got callback'
+            f' {r_callback_name}.'
+            )
+        network = r_network_callback_event.data[
+            constants.NetworkCbEventKey.NETWORK]
+        network_capabilities = r_network_callback_event.data[
+            constants.NetworkCbEventKey.NETWORK_CAPABILITIES]
+        asserts.assert_true(
+            network and network_capabilities,
+            f'{resp_dut} received a null Network or NetworkCapabilities!?.'
+        )
+        i_net_event_nc = i_network_callback_event.data
+        r_net_event_nc = r_network_callback_event.data
+        # validate no leak of information
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in i_net_event_nc,
+            "Network specifier leak!")
+        asserts.assert_false(
+            _NETWORK_CB_KEY_NETWORK_SPECIFIER in r_net_event_nc,
+            "Network specifier leak!")
+        #To get ipv6 ip address
+        i_ipv6_2 = i_net_event_nc[constants.NetworkCbName.NET_CAP_IPV6]
+        r_ipv6_2 = r_net_event_nc[constants.NetworkCbName.NET_CAP_IPV6]
+        # note that Pub <-> Sub since IPv6 are of peer's!
+        i_network_callback_LINK = init_req_key.waitAndGet(
+            event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+            timeout=_DEFAULT_TIMEOUT,
+            )
+        asserts.assert_equal(
+            i_network_callback_LINK.data[_CALLBACK_NAME],
+            _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+            f'{init_dut} succeeded to request the LinkPropertiesChanged,'+
+            ' got callback'
+            f' {i_network_callback_LINK.data[_CALLBACK_NAME]}.'
+            )
+
+        r_network_callback_LINK = resp_ini_key.waitAndGet(
+            event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+            timeout=_DEFAULT_TIMEOUT,
+            )
+        asserts.assert_equal(
+            r_network_callback_LINK.data[_CALLBACK_NAME],
+            _NETWORK_CB_LINK_PROPERTIES_CHANGED,
+            f'{resp_dut} succeeded to request the LinkPropertiesChanged,'+
+            ' got callback'
+            f' {r_network_callback_LINK.data[_CALLBACK_NAME]}.'
+            )
+        i_aware_if_2 = i_network_callback_LINK.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+        r_aware_if_2 = r_network_callback_LINK.data[
+            _NETWORK_CB_KEY_INTERFACE_NAME]
+
+        logging.info("Interface names: p=%s, s=%s", i_aware_if_2,
+                     r_aware_if_2)
+        logging.info("Interface addresses (IPv6): p=%s, s=%s", i_ipv6_2,
+                     r_ipv6_2)
+        # validate equality of NDPs (using interface names & ipv6)
+        asserts.assert_equal(i_aware_if_1, i_aware_if_2,
+                             "DUT1 NDPs are on different interfaces")
+        asserts.assert_equal(r_aware_if_1, r_aware_if_2,
+                             "DUT2 NDPs are on different interfaces")
+        asserts.assert_equal(i_ipv6_1, i_ipv6_2,
+                             "DUT1 NDPs are using different IPv6 addresses")
+        asserts.assert_equal(r_ipv6_1, r_ipv6_2,
+                             "DUT2 NDPs are using different IPv6 addresses")
+        # release requests
+        init_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+            i_network_callback_event_a.callback_id)
+        resp_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+            r_network_callback_event_a.callback_id)
+        init_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+            i_network_callback_event.callback_id)
+        resp_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+            r_network_callback_event.callback_id)
+
+    def run_multiple_ndi(self, sec_configs, flip_init_resp=False):
+        """Validate that the device can create and use multiple NDIs.
+
+        The security configuration can be:
+        - None: open
+        - String: passphrase
+        - otherwise: PMK (byte array)
+
+        Args:
+        sec_configs: list of security configurations
+        flip_init_resp: if True the roles of Initiator and Responder are flipped
+                        between the 2 devices, otherwise same devices are always
+                        configured in the same role.
+        """
+        dut1 = self.ads[0]
+        dut2 = self.ads[1]
+        asserts.skip_if(
+            autils.get_aware_capabilities(dut1)[_CAP_MAX_NDI_INTERFACES] <
+            len(sec_configs)
+            or autils.get_aware_capabilities(dut2)[_CAP_MAX_NDI_INTERFACES] <
+            len(sec_configs), "DUTs do not support enough NDIs")
+
+        id1, mac1 = self.attach_with_identity(dut1)
+        id2, mac2 = self.attach_with_identity(dut2)
+        time.sleep(self.WAIT_FOR_CLUSTER)
+        dut2_req_keys = []
+        dut2_key_evens = []
+        dut1_req_keys = []
+        dut1_key_evens = []
+        dut2_aware_ifs = []
+        dut1_aware_ifs = []
+        dut2_aware_ipv6s = []
+        dut1_aware_ipv6s = []
+        dut2_type = _DATA_PATH_RESPONDER
+        dut1_type = _DATA_PATH_INITIATOR
+        dut2_is_responder = True
+        if flip_init_resp:
+            if dut2_is_responder:
+                dut2_type = _DATA_PATH_INITIATOR
+                dut1_type = _DATA_PATH_RESPONDER
+            else:
+                dut2_type = _DATA_PATH_RESPONDER
+                dut1_type = _DATA_PATH_INITIATOR
+            dut2_is_responder = not dut2_is_responder
+        # first NDP: DUT1 (Init) -> DUT2 (Resp)
+        dut1_accept_handler = (
+            dut1.wifi_aware_snippet.connectivityServerSocketAccept())
+        network_id = dut1_accept_handler.callback_id
+        for sec in sec_configs:
+            if dut2_is_responder:
+                dut2_req_key = self.get_network_specifier(
+                    dut2, id2, dut2_type, mac1, sec, network_id
+                    )
+                dut1_req_key = self.get_network_specifier(
+                    dut1, id1, dut1_type, mac2, sec, network_id
+                    )
+            else:
+                dut1_req_key = self.get_network_specifier(
+                    dut1, id1, dut1_type, mac2, sec, network_id
+                    )
+                dut2_req_key = self.get_network_specifier(
+                    dut2, id2, dut2_type, mac1,  sec, network_id
+                    )
+            dut2_req_keys.append(dut2_req_key)
+            dut1_req_keys.append(dut1_req_key)
+
+            dut1_key_even = dut1_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+                )
+            i_callback_name_a = dut1_key_even.data[_CALLBACK_NAME]
+            dut2_key_even = dut2_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+                )
+            r_callback_name_a = dut2_key_even.data[_CALLBACK_NAME]
+            dut2_aware_ipv6 = dut2_key_even.data[
+                constants.NetworkCbName.NET_CAP_IPV6]
+            dut1_aware_ipv6 = dut1_key_even.data[
+                constants.NetworkCbName.NET_CAP_IPV6]
+            dut2_key_evens.append(dut2_key_even)
+            dut1_key_evens.append(dut1_key_even)
+            asserts.assert_true(
+                constants.NetworkCbName.ON_CAPABILITIES_CHANGED in
+                dut2_key_even.data[_CALLBACK_NAME],
+                f'{dut2} succeeded to request the network, got callback'
+                f' {dut2_key_evens}.'
+                )
+            asserts.assert_true(
+                constants.NetworkCbName.ON_CAPABILITIES_CHANGED in
+                dut1_key_even.data[_CALLBACK_NAME],
+                f'{dut1} succeeded to request the network, got callback'
+                f' {dut1_key_evens}.'
+                )
+
+            dut1_key_even = dut1_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+                )
+            i_callback_name_a = dut1_key_even.data[_CALLBACK_NAME]
+            dut2_key_even = dut2_req_key.waitAndGet(
+                event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
+                timeout=_DEFAULT_TIMEOUT,
+                )
+            r_callback_name_a = dut2_key_even.data[_CALLBACK_NAME]
+
+            dut2_key_evens.append(dut2_key_even)
+            dut1_key_evens.append(dut1_key_even)
+            asserts.assert_true(
+                _NETWORK_CB_LINK_PROPERTIES_CHANGED in
+                dut2_key_even.data[_CALLBACK_NAME],
+                f'{dut2} succeeded to request the network, got callback'
+                f' {dut2_key_evens}.'
+                )
+            asserts.assert_true(
+                _NETWORK_CB_LINK_PROPERTIES_CHANGED in
+                dut1_key_even.data[_CALLBACK_NAME],
+                f'{dut1} succeeded to request the network, got callback'
+                f' {dut1_key_evens}.'
+                )
+            dut2_aware_if = dut2_key_even.data[_NETWORK_CB_KEY_INTERFACE_NAME]
+            dut1_aware_if = dut1_key_even.data[_NETWORK_CB_KEY_INTERFACE_NAME]
+            dut2_aware_ifs.append(dut2_aware_if)
+            dut1_aware_ifs.append(dut1_aware_if)
+            dut2_aware_ipv6s.append(dut2_aware_ipv6)
+            dut1_aware_ipv6s.append(dut1_aware_ipv6)
+        dut1_aware_ifs = list(set(dut1_aware_ifs))
+        dut2_aware_ifs = list(set(dut2_aware_ifs))
+        dut1_aware_ipv6s = list(set(dut1_aware_ipv6s))
+        dut2_aware_ipv6s = list(set(dut2_aware_ipv6s))
+        logging.info("Interface names: DUT1=%s, DUT2=%s", dut1_aware_ifs,
+                      dut2_aware_ifs)
+        logging.info("IPv6 addresses: DUT1=%s, DUT2=%s", dut1_aware_ipv6s,
+                      dut2_aware_ipv6s)
+        asserts.assert_equal(
+            len(dut1_aware_ifs), len(sec_configs), "Multiple DUT1 interfaces")
+        asserts.assert_equal(
+            len(dut2_aware_ifs), len(sec_configs), "Multiple DUT2 interfaces")
+        asserts.assert_equal(
+            len(dut1_aware_ipv6s), len(sec_configs),
+            "Multiple DUT1 IPv6 addresses")
+        asserts.assert_equal(
+            len(dut2_aware_ipv6s), len(sec_configs),
+            "Multiple DUT2 IPv6 addresses")
+        for i in range(len(sec_configs)):
+            if_name = "%s%d" %("aware_data",i)
+            dut1_ipv6 = self.get_ipv6_addr(dut1, if_name)
+            dut2_ipv6 = self.get_ipv6_addr(dut2, if_name)
+            asserts.assert_equal(
+                dut1_ipv6 is None, if_name not in dut1_aware_ifs,
+                "Initiator interface %s in unexpected state" % if_name)
+            asserts.assert_equal(
+                dut2_ipv6 is None, if_name not in dut2_aware_ifs,
+                "Responder interface %s in unexpected state" % if_name)
+        for dut1_req_key in dut1_req_keys:
+            dut1.wifi_aware_snippet.connectivityUnregisterNetwork(
+                dut1_key_even.callback_id)
+        for dut2_key_even in dut2_key_evens:
+            dut2.wifi_aware_snippet.connectivityUnregisterNetwork(
+                dut2_key_even.callback_id)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_open_passphrase(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (one open, one using passphrase). The result should use
+        twodifferent NDIs
+        """
+        # self.run_multiple_ndi(self.PASSPHRASE)
+        self.run_multiple_ndi([None, self.PASSPHRASE])
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_passphrases(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (using different passphrases). The result should use two
+        different NDIs
+        """
+        self.run_multiple_ndi([self.PASSPHRASE, self.PASSPHRASE2])
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_open_passphrase_flip(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (one open, one using passphrase). The result should use
+        two different NDIs.
+
+        Flip Initiator and Responder roles.
+        """
+        self.run_multiple_ndi([None, self.PASSPHRASE], flip_init_resp=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_passphrases_flip(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (using different passphrases). The result should use two
+        different NDIs
+
+        Flip Initiator and Responder roles.
+        """
+        self.run_multiple_ndi(
+            [self.PASSPHRASE, self.PASSPHRASE2], flip_init_resp=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_open_pmk(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (one open, one using pmk). The result should use two
+        different NDIs
+        """
+        self.run_multiple_ndi([None, self.PMK])
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_passphrase_pmk(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (one using passphrase, one using pmk). The result should
+        use two different NDIs
+        """
+        self.run_multiple_ndi([self.PASSPHRASE, self.PMK])
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_pmks(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (using different PMKS). The result should use two
+        different NDIs
+        """
+        self.run_multiple_ndi([self.PMK, self.PMK2])
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_open_pmk_flip(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (one open, one using pmk). The result should use two
+        different NDIs
+
+        Flip Initiator and Responder roles.
+        """
+        self.run_multiple_ndi([None, self.PMK], flip_init_resp=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_passphrase_pmk_flip(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (one using passphrase, one using pmk). The result should
+        use two different NDIs
+
+        Flip Initiator and Responder roles.
+        """
+        self.run_multiple_ndi([self.PASSPHRASE, self.PMK], flip_init_resp=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(byte[],string)',
+        'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+
+    def test_multiple_ndi_pmks_flip(self):
+        """Verify that between 2 DUTs can create 2 NDPs with different security
+        configuration (using different PMKS). The result should use two
+        different NDIs
+
+        Flip Initiator and Responder roles.
+        """
+        self.run_multiple_ndi([self.PMK, self.PMK2], flip_init_resp=True)
+
+    #######################################
+    # The device can create and use multiple NDIs tests key:
+    #
+    # names is:test_<same_request>_ndps_mix_ib_oob_
+    #          <ib_first>_<inits_on_same_dut>_polarity
+    # same_request:
+    #   Issue canonically identical requests (same NMI peer, same passphrase)
+    #   if True, if False use different passphrases.
+    # ib_first:
+    #   If True then the in-band network is requested first, otherwise (if False)
+    #   then the out-of-band network is requested first.
+    # inits_on_same_dut:
+    #   If True then the Initiators are run on the same device, otherwise
+    #   (if False) then the Initiators are run on different devices.
+    #
+    #######################################
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_identical_ndps_mix_ib_oob_ib_first_same_polarity(self):
+        """Validate that a single NDP is created for multiple identical
+        requests which are issued through either in-band (ib) or out-of-band
+        (oob) APIs.
+
+        The in-band request is issued first. Both Initiators (Sub == Initiator)
+        are run on the same device.
+        """
+        self.run_mix_ib_oob(
+            same_request=True, ib_first=True, inits_on_same_dut=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_identical_ndps_mix_ib_oob_oob_first_same_polarity(self):
+        """Validate that a single NDP is created for multiple identical
+        requests which are issued through either in-band (ib) or out-of-band
+        (oob) APIs.
+
+        The out-of-band request is issued first. Both Initiators (Sub ==
+        Initiator)
+        are run on the same device.
+        """
+        self.run_mix_ib_oob(
+            same_request=True, ib_first=False, inits_on_same_dut=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_identical_ndps_mix_ib_oob_ib_first_diff_polarity(self):
+        """Validate that a single NDP is created for multiple identical
+        requests which are issued through either in-band (ib) or out-of-band
+        (oob) APIs.
+
+        The in-band request is issued first. Initiators (Sub == Initiator) are
+        run on different devices.
+        """
+        self.run_mix_ib_oob(
+            same_request=True, ib_first=True, inits_on_same_dut=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_identical_ndps_mix_ib_oob_oob_first_diff_polarity(self):
+        """Validate that a single NDP is created for multiple identical
+        requests which are issued through either in-band (ib) or out-of-band
+        (oob) APIs.
+
+        The out-of-band request is issued first. Initiators (Sub == Initiator)
+        are run on different devices.
+        """
+        self.run_mix_ib_oob(
+            same_request=True, ib_first=False, inits_on_same_dut=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        ]
+    )
+
+    def test_multiple_ndis_mix_ib_oob_ib_first_same_polarity(self):
+
+        """Validate that multiple NDIs are created for NDPs which are requested
+        with different security configurations. Use a mix of in-band and
+        out-of-band APIs to request the different NDPs.
+
+        The in-band request is issued first. Initiators (Sub == Initiator) are
+        run on the same device.
+        """
+        self.run_mix_ib_oob(
+            same_request=False, ib_first=True, inits_on_same_dut=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        ]
+    )
+
+    def test_multiple_ndis_mix_ib_oob_oob_first_same_polarity(self):
+        """Validate that multiple NDIs are created for NDPs which are requested
+        with different security configurations. Use a mix of in-band and
+        out-of-band APIs to request the different NDPs.
+
+        The out-of-band request is issued first. Initiators (Sub == Initiator)
+        are run on the same device.
+        """
+        self.run_mix_ib_oob(
+            same_request=False, ib_first=False, inits_on_same_dut=True)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        ]
+    )
+
+    def test_multiple_ndis_mix_ib_oob_ib_first_diff_polarity(self):
+        """Validate that multiple NDIs are created for NDPs which are requested
+        with different security configurations. Use a mix of in-band and
+        out-of-band APIs to request the different NDPs.
+
+        The in-band request is issued first. Initiators (Sub == Initiator) are
+        run on different devices.
+        """
+        self.run_mix_ib_oob(
+            same_request=False, ib_first=True, inits_on_same_dut=False)
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(byte[],string)',
+        ]
+    )
+
+    def test_multiple_ndis_mix_ib_oob_oob_first_diff_polarity(self):
+        """Validate that multiple NDIs are created for NDPs which are requested
+        with different security configurations. Use a mix of in-band and
+        out-of-band APIs to request the different NDPs.
+
+        The out-of-band request is issued first. Initiators (Sub == Initiator)
+        are run on different devices.
+        """
+        self.run_mix_ib_oob(
+            same_request=False, ib_first=False, inits_on_same_dut=False)
+
+    #######################################
+    # The device can setup two conflicting regulatory domains with a data-path test:
+    # names is:test_multiple_regulator_domains_ib_(regulatorA)_(regulatorB)
+    # use_ib: True to use in-band discovery, False to use out-of-band discovery.
+    # init_domain: The regulatory domain of the Initiator/Subscriber.
+    # resp_domain: The regulator domain of the Responder/Publisher.
+    #
+    #######################################
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_multiple_regulator_domains_ib_us_jp(self):
+        """Verify data-path setup across multiple regulator domains.
+
+        - Uses in-band discovery
+        - Subscriber=US, Publisher=JP
+        """
+        self.run_multiple_regulatory_domains(
+            use_ib=True,
+            init_domain="US",
+            resp_domain="JP")
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_multiple_regulator_domains_ib_jp_us(self):
+        """Verify data-path setup across multiple regulator domains.
+
+    - Uses in-band discovery
+    - Subscriber=JP, Publisher=US
+    """
+        self.run_multiple_regulatory_domains(
+            use_ib=True,
+            init_domain="JP",
+            resp_domain="US")
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_multiple_regulator_domains_oob_us_jp(self):
+        """Verify data-path setup across multiple regulator domains.
+
+    - Uses out-f-band discovery
+    - Initiator=US, Responder=JP
+    """
+        self.run_multiple_regulatory_domains(
+            use_ib=False,
+            init_domain="US",
+            resp_domain="JP")
+
+    @ApiTest(
+    apis=[
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build',
+        'android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(byte[])',
+        ]
+    )
+
+    def test_multiple_regulator_domains_oob_jp_us(self):
+        """Verify data-path setup across multiple regulator domains.
+
+    - Uses out-of-band discovery
+    - Initiator=JP, Responder=US
+    """
+        self.run_multiple_regulatory_domains(
+            use_ib=False,
+            init_domain="JP",
+            resp_domain="US")
+
+
+if __name__ == '__main__':
+    # Take test args
+    if '--' in sys.argv:
+        index = sys.argv.index('--')
+        sys.argv = sys.argv[:1] + sys.argv[index + 1:]
+
+    test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_discovery_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_discovery_test.py
index ebf36f5965..2f35e00760 100644
--- a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_discovery_test.py
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_discovery_test.py
@@ -22,6 +22,7 @@ import sys
 import time
 from typing import Any, Dict, Union
 
+from android.platform.test.annotations import ApiTest
 from aware import aware_lib_utils as autils
 from aware import constants
 from mobly import asserts
@@ -38,6 +39,10 @@ RUNTIME_PERMISSIONS = (
     'android.permission.NEARBY_WIFI_DEVICES',
 )
 PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+snippets_to_load = [
+    ('wifi_aware_snippet', PACKAGE_NAME),
+    ('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME),
+]
 _DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
 _MSG_ID_SUB_TO_PUB = random.randint(1000, 5000)
 _MSG_ID_PUB_TO_SUB = random.randint(5001, 9999)
@@ -70,11 +75,10 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
         self.subscriber = self.ads[1]
 
         def setup_device(device: android_device.AndroidDevice):
-            device.load_snippet(
-                'wifi_aware_snippet', PACKAGE_NAME
-            )
+            for snippet_name, package_name in snippets_to_load:
+                device.load_snippet(snippet_name, package_name)
             for permission in RUNTIME_PERMISSIONS:
-                device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+                device.adb.shell(['pm', 'grant', package_name, permission])
             asserts.abort_all_if(
                 not device.wifi_aware_snippet.wifiAwareIsAvailable(),
                 f'{device} Wi-Fi Aware is not available.',
@@ -90,7 +94,7 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
 
     def setup_test(self):
         for ad in self.ads:
-            autils.control_wifi(ad, True)
+            ad.wifi.wifiEnable()
             aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
             if not aware_avail:
                 ad.log.info('Aware not available. Waiting ...')
@@ -114,8 +118,11 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
 
     def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
         ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
-        autils.reset_device_parameters(ad)
-        autils.reset_device_statistics(ad)
+        ad.wifi.wifiClearConfiguredNetworks()
+        ad.wifi.wifiEnable()
+        if ad.is_adb_root:
+          autils.reset_device_parameters(ad)
+          autils.reset_device_statistics(ad)
 
     def on_fail(self, record: records.TestResult) -> None:
         android_device.take_bug_reports(self.ads,
@@ -696,7 +703,6 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
         if p_service_name is not None:
             p_config[constants.SERVICE_NAME] = p_service_name
         if p_mf_1 is not None:
-            # p_config[constants.MATCH_FILTER] = p_mf_1.encode("utf-8")
             p_config[constants.MATCH_FILTER] = autils.encode_list(
               [(10).to_bytes(1, byteorder="big"), p_mf_1 , bytes(range(40))])
         s_config = self.create_subscribe_config(
@@ -1116,7 +1122,6 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
         SERVICE_NAME = "ServiceName"
         X_SERVICE_SSI = "ServiceSpecificInfoXXX"
         Y_SERVICE_SSI = "ServiceSpecificInfoYYY"
-        # use_id = True
         # attach and wait for confirmation
         p_id = self._start_attach(p_dut)
         s_id = self._start_attach(s_dut)
@@ -1277,7 +1282,6 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
         p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
             p_disc_id.callback_id)
         time.sleep(10)
-        # service_lost_event = s_disc_id.waitAndGet("WifiAwareSessionOnServiceLost")
         service_lost_event = s_disc_id.waitAndGet(
             constants.DiscoverySessionCallbackMethodType.SESSION_CB_ON_SERVICE_LOST)
         asserts.assert_equal(peer_id_on_sub,
@@ -1287,6 +1291,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             service_lost_event.data[constants.DiscoverySessionCallbackMethodType.SESSION_CB_KEY_LOST_REASON]
             )
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        ]
+    )
+
     def test_positive_unsolicited_passive_typical(self)-> None:
         """Functional test case / Discovery test cases / positive test case:
         - Unsolicited publish + passive subscribe
@@ -1300,6 +1314,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
              _PAYLOAD_SIZE_TYPICAL
             )
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        ]
+    )
+
     def test_positive_unsolicited_passive_min(self)-> None:
         """Functional test case / Discovery test cases / positive test case:
         - Unsolicited publish + passive subscribe
@@ -1313,6 +1337,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
              _PAYLOAD_SIZE_MIN
             )
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        ]
+    )
+
     def test_positive_unsolicited_passive_max(self)-> None:
         """Functional test case / Discovery test cases / positive test case:
         - Unsolicited publish + passive subscribe
@@ -1326,6 +1360,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
              _PAYLOAD_SIZE_MAX
             )
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        ]
+    )
+
     def test_positive_solicited_active_typical(self)-> None:
         """Functional test case / Discovery test cases / positive test case:
         - Solicited publish + active subscribe
@@ -1339,6 +1383,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
              _PAYLOAD_SIZE_TYPICAL
             )
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        ]
+    )
+
     def test_positive_solicited_active_min(self)-> None:
         """Functional test case / Discovery test cases / positive test case:
         - Solicited publish + active subscribe
@@ -1352,6 +1406,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
              _PAYLOAD_SIZE_MIN
             )
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        ]
+    )
+
     def test_positive_solicited_active_max(self)-> None:
         """Functional test case / Discovery test cases / positive test case:
         - Solicited publish + active subscribe
@@ -1376,6 +1440,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
     # term_ind: ind_on or ind_off
     #######################################
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_ttl_unsolicited_ind_on(self)-> None:
         """Functional test case / Discovery test cases / TTL test case:
         - Unsolicited publish
@@ -1387,6 +1461,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             stype=None,
             term_ind_on=True)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_ttl_unsolicited_ind_off(self)-> None:
         """Functional test case / Discovery test cases / TTL test case:
         - Unsolicited publish
@@ -1398,6 +1482,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             stype=None,
             term_ind_on=False)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_ttl_solicited_ind_on(self)-> None:
         """Functional test case / Discovery test cases / TTL test case:
         - Solicited publish
@@ -1409,6 +1503,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             stype=None,
             term_ind_on=True)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_ttl_solicited_ind_off(self)-> None:
         """Functional test case / Discovery test cases / TTL test case:
         - Solicited publish
@@ -1420,6 +1524,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             stype=None,
             term_ind_on=False)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_ttl_passive_ind_on(self)-> None:
         """Functional test case / Discovery test cases / TTL test case:
         - Passive subscribe
@@ -1431,6 +1545,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             stype=_SUBSCRIBE_TYPE_PASSIVE,
             term_ind_on=True)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_ttl_passive_ind_off(self)-> None:
         """Functional test case / Discovery test cases / TTL test case:
         - Passive subscribe
@@ -1442,6 +1566,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             stype=_SUBSCRIBE_TYPE_PASSIVE,
             term_ind_on=False)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_ttl_active_ind_on(self)-> None:
         """Functional test case / Discovery test cases / TTL test case:
         - Active subscribe
@@ -1453,6 +1587,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             stype=_SUBSCRIBE_TYPE_ACTIVE,
             term_ind_on=True)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_ttl_active_ind_off(self)-> None:
         """Functional test case / Discovery test cases / TTL test case:
         - Active subscribe
@@ -1474,6 +1618,18 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
     # sub_type: Type of subscribe discovery session: passive or active.
     #######################################
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_mismatch_service_type_unsolicited_active(self):
         """Functional test case / Discovery test cases / Mismatch service name
     - Unsolicited publish
@@ -1484,6 +1640,18 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             p_type=_PUBLISH_TYPE_UNSOLICITED,
             s_type=_SUBSCRIBE_TYPE_ACTIVE)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_mismatch_service_type_solicited_passive(self):
         """Functional test case / Discovery test cases / Mismatch service name
     - Unsolicited publish
@@ -1504,6 +1672,18 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
     # sub_type: Type of subscribe discovery session: passive or active.
     #######################################
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_mismatch_service_name_unsolicited_passive(self):
         """Functional test case / Discovery test cases / Mismatch service name
     - Unsolicited publish
@@ -1516,6 +1696,18 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             p_service_name="GoogleTestServiceXXX",
             s_service_name="GoogleTestServiceYYY")
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_mismatch_service_name_solicited_active(self):
         """Functional test case / Discovery test cases / Mismatch service name
     - Solicited publish
@@ -1538,6 +1730,18 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
     # sub_type: Type of subscribe discovery session: passive or active.
     #######################################
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_mismatch_match_filter_unsolicited_passive(self):
         """Functional test case / Discovery test cases / Mismatch match filter
     - Unsolicited publish
@@ -1550,6 +1754,18 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             p_mf_1="hello there string",
             s_mf_1="goodbye there string")
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setTerminateNotificationEnabled(SubscribeConfig.mEnableTerminateNotification)',
+            'android.net.wifi.aware.PublishConfig.Builder#setTerminateNotificationEnabled(PublishConfig.mEnableTerminateNotification)',
+        ]
+    )
+
     def test_mismatch_match_filter_solicited_active(self):
         """Functional test case / Discovery test cases / Mismatch match filter
     - Solicited publish
@@ -1566,6 +1782,17 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
     # Multiple concurrent services
     #######################################
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_multiple_concurrent_services_both_unsolicited_passive(self):
         """Validate multiple concurrent discovery sessions running on both devices.
     - DUT1 & DUT2 running Publish for X
@@ -1589,6 +1816,17 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
                 _SUBSCRIBE_TYPE_PASSIVE
             ])
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_multiple_concurrent_services_both_solicited_active(self):
         """Validate multiple concurrent discovery sessions running on both devices.
     - DUT1 & DUT2 running Publish for X
@@ -1611,6 +1849,19 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
                 _PUBLISH_TYPE_SOLICITED, _SUBSCRIBE_TYPE_ACTIVE
             ])
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_multiple_concurrent_services_mix_unsolicited_solicited(self):
         """Validate multiple concurrent discovery sessions running on both devices.
     - DUT1 & DUT2 running Publish for X
@@ -1638,6 +1889,17 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
     # Multiple concurrent services with diff ssi
     #########################################################
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_multiple_concurrent_services_diff_ssi_unsolicited_passive(self):
         """Multi service test on same service name but different Service Specific Info
         - Unsolicited publish
@@ -1647,6 +1909,17 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
             type_x=[_PUBLISH_TYPE_UNSOLICITED, _SUBSCRIBE_TYPE_PASSIVE],
             type_y=[_PUBLISH_TYPE_UNSOLICITED, _SUBSCRIBE_TYPE_PASSIVE])
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_multiple_concurrent_services_diff_ssi_solicited_active(self):
         """Multi service test on same service name but different Service Specific Info
         - Solicited publish
@@ -1658,6 +1931,17 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
 
     #########################################################
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_upper_lower_service_name_equivalence(self):
         """Validate that Service Name is case-insensitive. Publish a service name
         with mixed case, subscribe to the same service name with alternative case
@@ -1681,6 +1965,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
     # service discovery on service lost
     #########################################################
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        ]
+    )
+
     def test_service_discovery_on_service_lost_unsolicited_passive(self):
         """
         Test service discovery lost with unsolicited publish and passive subscribe
@@ -1688,6 +1982,16 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
         self.run_service_discovery_on_service_lost(_PUBLISH_TYPE_UNSOLICITED,
                                                    _SUBSCRIBE_TYPE_PASSIVE)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED,)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        ]
+    )
+
     def test_service_discovery_on_service_lost_solicited_active(self):
         """
         Test service discovery lost with solicited publish and active subscribe
@@ -1695,6 +1999,7 @@ class WifiAwareDiscoveryTest(base_test.BaseTestClass):
         self.run_service_discovery_on_service_lost(_PUBLISH_TYPE_SOLICITED,
                                                    _SUBSCRIBE_TYPE_ACTIVE)
 
+
 if __name__ == '__main__':
     # Take test args
     if '--' in sys.argv:
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_discovery_with_ranging_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_discovery_with_ranging_test.py
new file mode 100644
index 0000000000..5acd444dd2
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_discovery_with_ranging_test.py
@@ -0,0 +1,2304 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Wi-Fi Aware Discovery with ranging test reimplemented in Mobly."""
+import logging
+import statistics
+import sys
+import time
+
+from android.platform.test.annotations import ApiTest
+from aware import aware_lib_utils as autils
+from aware import constants
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+from mobly.controllers.android_device_lib import callback_handler_v2
+from mobly.snippet import callback_event
+
+RUNTIME_PERMISSIONS = (
+    'android.permission.ACCESS_FINE_LOCATION',
+    'android.permission.ACCESS_COARSE_LOCATION',
+    'android.permission.NEARBY_WIFI_DEVICES',
+)
+PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+
+_CALLBACK_NAME = constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
+_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
+
+_LARGE_ENOUGH_DISTANCE_MM = 1000000
+_IS_SESSION_INIT = constants.DiscoverySessionCallbackParamsType.IS_SESSION_INIT
+
+
+class WiFiAwareDiscoveryWithRangingTest(base_test.BaseTestClass):
+  """Set of tests for Wi-Fi Aware discovery configured with ranging (RTT)."""
+  SERVICE_NAME = 'GoogleTestServiceRRRRR'
+
+  ads: list[android_device.AndroidDevice]
+  device_startup_offset = 2
+
+  def setup_class(self):
+    # Register two Android devices.
+    logging.basicConfig(level=logging.INFO, force=True)
+    self.ads = self.register_controller(android_device, min_number=2)
+
+    def setup_device(device: android_device.AndroidDevice):
+      autils.control_wifi(device, True)
+      device.load_snippet('wifi_aware_snippet', PACKAGE_NAME)
+      for permission in RUNTIME_PERMISSIONS:
+        device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+      asserts.abort_all_if(
+          not device.wifi_aware_snippet.wifiAwareIsAvailable(),
+          f'{device} Wi-Fi Aware is not available.',
+      )
+
+    # Set up devices in parallel.
+    utils.concurrent_exec(
+        setup_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+
+  def setup_test(self):
+    logging.info('setup_test')
+    for ad in self.ads:
+      ad.log.info('setup_test: open wifi')
+      autils.control_wifi(ad, True)
+      aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
+      if not aware_avail:
+        ad.log.info('Aware not available. Waiting ...')
+        state_handler = ad.wifi_aware_snippet.wifiAwareMonitorStateChange()
+        state_handler.waitAndGet(
+            constants.WifiAwareBroadcast.WIFI_AWARE_AVAILABLE
+        )
+
+  def teardown_test(self):
+    logging.info('teardown_test')
+    utils.concurrent_exec(
+        self._teardown_test_on_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+    utils.concurrent_exec(
+        lambda d: d.services.create_output_excerpts_all(self.current_test_info),
+        param_list=[[ad] for ad in self.ads],
+        raise_on_exception=True,
+    )
+
+  def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
+    ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+    ad.wifi_aware_snippet.wifiAwareMonitorStopStateChange()
+    autils.control_wifi(ad, True)
+
+  def on_fail(self, record: records.TestResult) -> None:
+    logging.info('on_fail')
+    android_device.take_bug_reports(
+        self.ads, destination=self.current_test_info.output_path
+    )
+
+  def getname(self, level=1):
+    """Python magic to return the name of the *calling* function.
+
+    Args:
+      level: How many levels up to go for the method name. Default = calling
+        method.
+
+    Returns:
+      The name of the *calling* function.
+    """
+    logging.info('debug> %s', sys._getframe(level).f_code.co_name)
+    return sys._getframe(level).f_code.co_name
+
+  def _start_publish(
+      self,
+      p_dut: android_device.AndroidDevice,
+      attach_session_id: str,
+      pub_config: constants.PublishConfig,
+      update_pub: bool = False,
+  ) -> callback_event.CallbackEvent:
+    """Starts a publish session on the publisher device."""
+
+    # Start the publishing session and return the handler.
+    if update_pub:
+      publish_handler = p_dut.wifi_aware_snippet.wifiAwareUpdatePublish(
+          attach_session_id,
+          pub_config.to_dict(),
+      )
+    else:
+      publish_handler = p_dut.wifi_aware_snippet.wifiAwarePublish(
+          attach_session_id,
+          pub_config.to_dict(),
+      )
+
+    # Wait for publish session to start.
+    discovery_event = publish_handler.waitAndGet(
+        event_name=constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    callback_name = discovery_event.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+        callback_name,
+        f'{p_dut} {pub_config.service_name} publish failed: {callback_name}.',
+    )
+    return publish_handler
+
+  def _start_subscribe(
+      self,
+      s_dut: android_device.AndroidDevice,
+      attach_session_id: str,
+      sub_config: constants.SubscribeConfig,
+      update_sub: bool = False,
+  ) -> callback_event.CallbackEvent:
+    """Starts a subscribe session on the subscriber device."""
+
+    # Start the subscription session and return the handler.
+    if update_sub:
+      subscribe_handler = s_dut.wifi_aware_snippet.wifiAwareUpdateSubscribe(
+          attach_session_id, sub_config.to_dict()
+      )
+    else:
+      subscribe_handler = s_dut.wifi_aware_snippet.wifiAwareSubscribe(
+          attach_session_id, sub_config.to_dict()
+      )
+
+    # Wait for subscribe session to start.
+    discovery_event = subscribe_handler.waitAndGet(
+        event_name=constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    callback_name = discovery_event.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+        callback_name,
+        f'{s_dut} {sub_config.service_name} subscribe failed: {callback_name}.',
+    )
+    return subscribe_handler
+
+  def run_discovery(
+      self,
+      p_config: dict[str, any],
+      s_config: dict[str, any],
+      expect_discovery: bool,
+      expect_range: bool = False,
+  ) -> tuple[android_device.AndroidDevice, android_device.AndroidDevice,
+             callback_handler_v2.CallbackHandlerV2,
+             callback_handler_v2.CallbackHandlerV2]:
+    """Run discovery on the 2 input devices with the specified configurations.
+
+    Args:
+      p_config: Publisher discovery configuration.
+      s_config: Subscriber discovery configuration.
+      expect_discovery: True or False indicating whether discovery is expected
+      with the specified configurations.
+      expect_range: True if we expect distance results (i.e. ranging to happen).
+      Only relevant if expect_discovery is True.
+
+    Returns:
+      p_dut, s_dut: Publisher/Subscribe DUT
+      p_disc_id, s_disc_id: Publisher/Subscribe discovery session ID
+    """
+    p_dut = self.ads[0]
+    p_dut.pretty_name = 'Publisher'
+    s_dut = self.ads[1]
+    s_dut.pretty_name = 'Subscriber'
+    p_dut.log.info(p_config)
+    p_dut.log.info(s_config)
+
+    # Publisher+Subscriber: attach and wait for confirmation.
+    p_id = p_dut.wifi_aware_snippet.wifiAwareAttached(False)
+    p_id.waitAndGet(constants.AttachCallBackMethodType.ATTACHED)
+    time.sleep(self.device_startup_offset)
+    s_id = s_dut.wifi_aware_snippet.wifiAwareAttached(False)
+    s_id.waitAndGet(constants.AttachCallBackMethodType.ATTACHED)
+
+    # Publisher: start publish and wait for confirmation.
+    p_dut.log.info('start publish')
+    p_disc_id = p_dut.wifi_aware_snippet.wifiAwarePublish(p_id.callback_id,
+                                                          p_config.to_dict())
+    p_discovery = p_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT)
+    callback_name = p_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+        callback_name,
+        f'{p_dut} publish failed, got callback: {callback_name}.',
+        )
+    time.sleep(1)
+    s_dut.log.info('start subscribe')
+    # Subscriber: start subscribe and wait for confirmation.
+    s_disc_id = s_dut.wifi_aware_snippet.wifiAwareSubscribe(s_id.callback_id,
+                                                            s_config.to_dict())
+    s_discovery = s_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT)
+    callback_name = s_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+        callback_name,
+        f'{s_dut} subscribe failed, got callback: {callback_name}.',
+        )
+
+    # Subscriber: wait or fail on service discovery.
+    if expect_discovery:
+        event_name = (
+            constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED
+        )
+        if expect_range:
+            event_name = (
+                constants.DiscoverySessionCallbackMethodType
+                .SERVICE_DISCOVERED_WITHIN_RANGE
+            )
+        discover_data = s_disc_id.waitAndGet(
+            event_name=event_name, timeout=_DEFAULT_TIMEOUT
+        )
+
+        if expect_range:
+            asserts.assert_true(
+                constants.WifiAwareSnippetParams.DISTANCE_MM
+                in discover_data.data,
+                'Discovery with ranging expected!',
+            )
+            s_dut.log.info('distance=%s', discover_data.data[
+                constants.WifiAwareSnippetParams.DISTANCE_MM])
+        else:
+            asserts.assert_false(
+                constants.WifiAwareSnippetParams.DISTANCE_MM
+                in discover_data.data,
+                'Discovery with ranging NOT expected!',
+            )
+    else:
+        s_dut.log.info('onServiceDiscovered NOT expected! wait for timeout.')
+        autils.callback_no_response(
+            s_disc_id,
+            constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED,
+            timeout=_DEFAULT_TIMEOUT)
+
+    return p_dut, s_dut, p_disc_id, s_disc_id
+
+  @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+    ]
+  )
+  def test_ranged_discovery_unsolicited_passive_prange_snorange(self):
+    """Verify discovery(unsolicited/passive) with ranging.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber disables ranging
+
+    Expect: normal discovery (as if no ranging performed) - no distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+        ),
+        expect_discovery=True,
+        expect_range=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+    ]
+  )
+  def test_ranged_discovery_solicited_active_prange_snorange(self):
+    """Verify discovery(solicited/active) with ranging.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber disables ranging
+
+    Expect: normal discovery (as if no ranging performed) - no distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+        ),
+        expect_discovery=True,
+        expect_range=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+    ]
+  )
+  def test_ranged_discovery_unsolicited_passive_pnorange_smax_inrange(self):
+    """Verify discovery(unsolicited/passive) with ranging.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher disables ranging
+    - Subscriber enables ranging with max such that always within range (large
+      max)
+
+    Expect: normal discovery (as if no ranging performed) - no distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=False,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=None,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ),
+        expect_discovery=True,
+        expect_range=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+    ]
+  )
+  def test_ranged_discovery_solicited_active_pnorange_smax_inrange(self):
+    """Verify discovery(solicited/active) with ranging.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher disables ranging
+    - Subscriber enables ranging with max such that always within range (large
+      max)
+
+    Expect: normal discovery (as if no ranging performed) - no distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=False,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=None,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ),
+        expect_discovery=True,
+        expect_range=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+    ]
+  )
+  def test_ranged_discovery_unsolicited_passive_pnorange_smin_outofrange(self):
+    """Verify discovery(unsolicited/passive) with ranging.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher disables ranging
+    - Subscriber enables ranging with min such that always out of range (large
+      min)
+
+    Expect: normal discovery (as if no ranging performed) - no distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=False,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=None,
+        ),
+        expect_discovery=True,
+        expect_range=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+    ]
+  )
+  def test_ranged_discovery_solicited_active_pnorange_smin_outofrange(self):
+    """Verify discovery(solicited/active) with ranging.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher disables ranging
+    - Subscriber enables ranging with min such that always out of range (large
+      min)
+
+    Expect: normal discovery (as if no ranging performed) - no distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=False,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=None,
+        ),
+        expect_discovery=True,
+        expect_range=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+    ]
+  )
+  def test_ranged_discovery_unsolicited_passive_prange_smin_inrange(self):
+    """Verify discovery(unsolicited/passive) with ranging.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with min such that in range (min=0)
+
+    Expect: discovery with distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=0,
+            max_distance_mm=None,
+        ),
+        expect_discovery=True,
+        expect_range=True,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, java.util.List<byte[]> matchFilter, int distanceMm)',
+    ]
+  )
+  def test_ranged_discovery_unsolicited_passive_prange_smax_inrange(self):
+    """Verify discovery(unsolicited/passive) with ranging.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with max such that in range (max=large)
+
+    Expect: discovery with distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=None,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ),
+        expect_discovery=True,
+        expect_range=True,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+    ]
+  )
+  def test_ranged_discovery_unsolicited_passive_prange_sminmax_inrange(self):
+    """Verify discovery(unsolicited/passive) with ranging.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with min/max such that in range (min=0,
+      max=large)
+
+    Expect: discovery with distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=0,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ),
+        expect_discovery=True,
+        expect_range=True,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+    ]
+  )
+  def test_ranged_discovery_solicited_active_prange_smin_inrange(self):
+    """Verify discovery(solicited/active) with ranging.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with min such that in range (min=0)
+
+    Expect: discovery with distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=0,
+            max_distance_mm=None,
+        ),
+        expect_discovery=True,
+        expect_range=True,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+    ]
+  )
+  def test_ranged_discovery_solicited_active_prange_smax_inrange(self):
+    """Verify discovery(solicited/active) with ranging.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with max such that in range (max=large)
+
+    Expect: discovery with distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=None,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ),
+        expect_discovery=True,
+        expect_range=True,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+    ]
+  )
+  def test_ranged_discovery_solicited_active_prange_sminmax_inrange(self):
+    """Verify discovery(solicited/active) with ranging.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with min/max such that in range (min=0,
+      max=large)
+
+    Expect: discovery with distance
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=0,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ),
+        expect_discovery=True,
+        expect_range=True,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+    ]
+  )
+  def test_ranged_discovery_unsolicited_passive_prange_smin_outofrange(self):
+    """Verify discovery(unsolicited/passive) with ranging.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with min such that out of range (min=large)
+
+    Expect: no discovery
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=None,
+        ),
+        expect_discovery=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+    ]
+  )
+  def test_ranged_discovery_unsolicited_passive_prange_smax_outofrange(self):
+    """Verify discovery(unsolicited/passive) with ranging.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with max such that in range (max=0)
+
+    Expect: no discovery
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=None,
+            max_distance_mm=0,
+        ),
+        expect_discovery=True,
+        expect_range=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+    ]
+  )
+  def test_ranged_discovery_unsolicited_passive_prange_sminmax_outofrange(self):
+    """Verify discovery(unsolicited/passive) with ranging.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with min/max such that out of range (min=large,
+      max=large+1)
+
+    Expect: no discovery
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM + 1,
+        ),
+        expect_discovery=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+    ]
+  )
+  def test_ranged_discovery_solicited_active_prange_smin_outofrange(self):
+    """Verify discovery(solicited/active) with ranging.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with min such that out of range (min=large)
+
+    Expect: no discovery
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=None,
+        ),
+        expect_discovery=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+    ]
+  )
+  def test_ranged_discovery_solicited_active_prange_smax_outofrange(self):
+    """Verify discovery(solicited/active) with ranging.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with max such that out of range (max=0)
+
+    Expect: no discovery
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=None,
+            max_distance_mm=0,
+        ),
+        expect_discovery=True,
+        expect_range=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+    ]
+  )
+  def test_ranged_discovery_solicited_active_prange_sminmax_outofrange(self):
+    """Verify discovery(solicited/active) with ranging.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber enables ranging with min/max such that out of range (min=large,
+      max=large+1)
+
+    Expect: no discovery
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM + 1,
+        ),
+        expect_discovery=False,
+    )
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
+        s_disc_id.callback_id)
+
+  def run_discovery_prange_sminmax_outofrange(
+      self,
+      is_unsolicited_passive
+  ) -> tuple[android_device.AndroidDevice, android_device.AndroidDevice,
+             callback_handler_v2.CallbackHandlerV2,
+             callback_handler_v2.CallbackHandlerV2]:
+    """Run discovery with ranging with configuration type.
+
+    - Publisher enables ranging
+    - Subscriber enables ranging with min/max such that out of range (min=large,
+      max=large+1)
+
+    Expected: no discovery
+
+    This is a baseline test for the update-configuration tests.
+
+    Args:
+      is_unsolicited_passive: True for Unsolicited/Passive, False for
+                              Solicited/Active.
+    Returns:
+      the return arguments of the run_discovery.
+    """
+    pub_type = (constants.PublishType.UNSOLICITED if is_unsolicited_passive
+                else constants.PublishType.SOLICITED)
+    sub_type = (constants.SubscribeType.PASSIVE if is_unsolicited_passive
+                else constants.SubscribeType.ACTIVE)
+
+    return self.run_discovery(
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=pub_type,
+            service_specific_info=self.getname(2).encode(),
+            ranging_enabled=True,
+        ),
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=sub_type,
+            service_specific_info=self.getname(2).encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM + 1,
+        ),
+        expect_discovery=False,
+    )
+
+  def run_discovery_update(self,
+                           p_dut,
+                           s_dut,
+                           p_disc_id,
+                           s_disc_id,
+                           p_config,
+                           s_config,
+                           expect_discovery,
+                           expect_range=False):
+    """Run discovery on the 2 input devices with the specified update configurations.
+
+    I.e., update the existing discovery sessions with the configurations.
+
+    Args:
+      p_dut: Publisher DUTs.
+      s_dut: Subscriber DUT.
+      p_disc_id: Publisher discovery session IDs.
+      s_disc_id: Subscriber discovery session IDs.
+      p_config: Publisher discovery configuration.
+      s_config: Subscriber discovery configuration.
+      expect_discovery: True or False indicating whether discovery is expected
+      with the specified configurations.
+      expect_range: True if we expect distance results (i.e. ranging to happen).
+      Only relevant if expect_discovery is True.
+    """
+    # try to perform reconfiguration at same time (and wait once for all
+    # confirmations)
+    if p_config is not None:
+        p_dut.wifi_aware_snippet.wifiAwareUpdatePublish(
+            p_disc_id.callback_id,
+            p_config.to_dict())
+    if s_config is not None:
+        s_dut.wifi_aware_snippet.wifiAwareUpdateSubscribe(
+            s_disc_id.callback_id,
+            s_config.to_dict())
+
+    if p_config is not None and p_disc_id is not None:
+        p_dut.log.info('Check for publish config updated.')
+        p_disc_id.waitAndGet(
+            event_name=
+            constants.DiscoverySessionCallbackMethodType.SESSION_CONFIG_UPDATED,
+            timeout=_DEFAULT_TIMEOUT
+        )
+    if s_config is not None and s_disc_id is not None:
+        s_dut.log.info('Check for subscribe config updated.')
+        s_disc_id.waitAndGet(
+            event_name=
+            constants.DiscoverySessionCallbackMethodType.SESSION_CONFIG_UPDATED,
+            timeout=_DEFAULT_TIMEOUT
+        )
+
+    # Subscriber: wait or fail on service discovery.
+    if expect_discovery:
+        event_name = (
+            constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED
+        )
+        if expect_range:
+            event_name = (
+                constants.DiscoverySessionCallbackMethodType
+                .SERVICE_DISCOVERED_WITHIN_RANGE
+            )
+        discover_data = s_disc_id.waitAndGet(
+            event_name=event_name, timeout=_DEFAULT_TIMEOUT
+        )
+
+        if expect_range:
+            asserts.assert_true(
+                constants.WifiAwareSnippetParams.DISTANCE_MM
+                in discover_data.data,
+                'Discovery with ranging expected!',
+            )
+            s_dut.log.info('distance=%s', discover_data.data[
+                constants.WifiAwareSnippetParams.DISTANCE_MM])
+        else:
+            asserts.assert_false(
+                constants.WifiAwareSnippetParams.DISTANCE_MM
+                in discover_data.data,
+                'Discovery with ranging NOT expected!',
+            )
+    else:
+        s_dut.log.info('onServiceDiscovered NOT expected! wait for timeout.')
+        autils.callback_no_response(
+            s_disc_id,
+            constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED,
+            timeout=_DEFAULT_TIMEOUT)
+
+    time.sleep(autils._EVENT_TIMEOUT)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+        'android.net.wifi.aware.SubscribeDiscoverySession#updateSubscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_unsolicited_passive_oor_to_ir(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber:
+      - Starts: Ranging enabled, min/max such that out of range (min=large,
+                max=large+1)
+      - Reconfigured to: Ranging enabled, min/max such that in range (min=0,
+                        max=large)
+
+    Expect: discovery + ranging after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(True)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=0,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ),
+        expect_discovery=True,
+        expect_range=True)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+        'android.net.wifi.aware.PublishDiscoverySession#updatePublish(android.net.wifi.aware.PublishConfig publishConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_unsolicited_passive_pub_unrange(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber: Ranging enabled, min/max such that out of range (min=large,
+                  max=large+1)
+    - Reconfigured to: Publisher disables ranging
+
+    Expect: discovery w/o ranging after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(True)
+        )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+        ),
+        s_config=None,  # no updates
+        expect_discovery=True,
+        expect_range=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.SubscribeDiscoverySession#updateSubscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_unsolicited_passive_sub_unrange(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber:
+      - Starts: Ranging enabled, min/max such that out of range (min=large,
+                max=large+1)
+      - Reconfigured to: Ranging disabled
+
+    Expect: discovery w/o ranging after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(True)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+        ),
+        expect_discovery=True,
+        expect_range=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeDiscoverySession#updateSubscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_unsolicited_passive_sub_oor(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber:
+      - Starts: Ranging enabled, min/max such that out of range (min=large,
+                max=large+1)
+      - Reconfigured to: different out-of-range setting
+
+    Expect: no discovery after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(True)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM+1,
+        ),
+        expect_discovery=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.PublishDiscoverySession#updatePublish(android.net.wifi.aware.PublishConfig publishConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_unsolicited_passive_pub_same(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber: Ranging enabled, min/max such that out of range (min=large,
+                  max=large+1)
+    - Reconfigured to: Publisher with same settings (ranging enabled)
+
+    Expect: no discovery after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(True)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=None,  # no updates
+        expect_discovery=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeDiscoverySession#updateSubscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_unsolicited_passive_multi_step(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber: Ranging enabled, min/max such that out of range (min=large,
+                  max=large+1)
+      - Expect: no discovery
+    - Reconfigured to: Ranging enabled, min/max such that in-range (min=0)
+      - Expect: discovery with ranging
+    - Reconfigured to: Ranging enabled, min/max such that out-of-range
+                       (min=large)
+      - Expect: no discovery
+    - Reconfigured to: Ranging disabled
+      - Expect: discovery without ranging
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(True)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=0,
+            max_distance_mm=None,
+        ),
+        expect_discovery=True,
+        expect_range=True)
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=None),
+        expect_discovery=False)
+
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+        ),
+        expect_discovery=True,
+        expect_range=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+        'android.net.wifi.aware.SubscribeDiscoverySession#updateSubscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_solicited_active_oor_to_ir(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber:
+      - Starts: Ranging enabled, min/max such that out of range (min=large,
+                max=large+1)
+      - Reconfigured to: Ranging enabled, min/max such that in range (min=0,
+                        max=large)
+
+    Expect: discovery + ranging after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(False)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=0,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ),
+        expect_discovery=True,
+        expect_range=True)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.PublishDiscoverySession#updatePublish(android.net.wifi.aware.PublishConfig publishConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_solicited_active_pub_unrange(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber: Ranging enabled, min/max such that out of range (min=large,
+                  max=large+1)
+    - Reconfigured to: Publisher disables ranging
+
+    Expect: discovery w/o ranging after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(False)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+        ),
+        s_config=None,  # no updates
+        expect_discovery=True,
+        expect_range=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.SubscribeDiscoverySession#updateSubscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_solicited_active_sub_unrange(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber:
+      - Starts: Ranging enabled, min/max such that out of range (min=large,
+
+    Expect: discovery w/o ranging after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(False)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+        ),
+        expect_discovery=True,
+        expect_range=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeDiscoverySession#updateSubscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_solicited_active_sub_oor(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber:
+      - Starts: Ranging enabled, min/max such that out of range (min=large,
+                max=large+1)
+      - Reconfigured to: different out-of-range setting
+
+
+    Expect: no discovery after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(False)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM + 1,
+        ),
+        expect_discovery=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.PublishDiscoverySession#updatePublish(android.net.wifi.aware.PublishConfig publishConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_solicited_active_pub_same(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Solicited Publish/Active Subscribe
+    - Publisher enables ranging
+    - Subscriber: Ranging enabled, min/max such that out of range (min=large,
+                  max=large+1)
+
+    Expect: no discovery after update
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(False)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=constants.PublishConfig(
+            service_name=self.SERVICE_NAME,
+            publish_type=constants.PublishType.SOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+        s_config=None,  # no updates
+        expect_discovery=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  def _read_discovery_result(
+      self,
+      s_disc_id,
+      expect_discovery: bool,
+      expect_range: bool) -> callback_event.CallbackEvent:
+    # Subscriber: wait or fail on service discovery.
+    if expect_discovery:
+        event_name = (
+            constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED
+        )
+        if expect_range:
+            event_name = (
+                constants.DiscoverySessionCallbackMethodType
+                .SERVICE_DISCOVERED_WITHIN_RANGE
+            )
+        discover_data = s_disc_id.waitAndGet(
+            event_name=event_name, timeout=_DEFAULT_TIMEOUT
+        )
+
+        if expect_range:
+            asserts.assert_true(
+                constants.WifiAwareSnippetParams.DISTANCE_MM
+                in discover_data.data,
+                'Discovery with ranging expected!',
+            )
+            logging.info('distance=%s', discover_data.data[
+                constants.WifiAwareSnippetParams.DISTANCE_MM])
+        else:
+            asserts.assert_false(
+                constants.WifiAwareSnippetParams.DISTANCE_MM
+                in discover_data.data,
+                'Discovery with ranging NOT expected!',
+            )
+        return discover_data
+    else:
+        logging.info('onServiceDiscovered NOT expected! wait for timeout.')
+        autils.callback_no_response(
+            s_disc_id,
+            constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED,
+            timeout=_DEFAULT_TIMEOUT)
+        return None
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+        'android.net.wifi.aware.SubscribeDiscoverySession#updateSubscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig)',
+    ]
+  )
+  def test_ranged_updated_discovery_solicited_active_multi_step(self):
+    """Verify discovery with ranging operation with updated configuration.
+
+    - Unsolicited Publish/Passive Subscribe
+    - Publisher enables ranging
+    - Subscriber: Ranging enabled, min/max such that out of range (min=large,
+                  max=large+1)
+      - Expect: no discovery
+    - Reconfigured to: Ranging enabled, min/max such that in-range (min=0)
+      - Expect: discovery with ranging
+    - Reconfigured to: Ranging enabled, min/max such that out-of-range
+                       (min=large)
+    - Reconfigured to: Ranging disabled
+      - Expect: discovery without ranging
+    """
+    (p_dut, s_dut, p_disc_id, s_disc_id) = (
+        self.run_discovery_prange_sminmax_outofrange(True)
+    )
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=0,
+            max_distance_mm=None,
+        ),
+        expect_discovery=True,
+        expect_range=True)
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=None,
+        ),
+        expect_discovery=False)
+    self.run_discovery_update(
+        p_dut,
+        s_dut,
+        p_disc_id,
+        s_disc_id,
+        p_config=None,  # no updates
+        s_config=constants.SubscribeConfig(
+            service_name=self.SERVICE_NAME,
+            subscribe_type=constants.SubscribeType.ACTIVE,
+            service_specific_info=self.getname().encode(),
+        ),
+        expect_discovery=True,
+        expect_range=False)
+    p_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(p_disc_id.callback_id)
+    s_dut.wifi_aware_snippet.wifiAwareCloseDiscoverSession(s_disc_id.callback_id)
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+    ]
+  )
+  def test_ranged_discovery_multi_session(self):
+    """Verify behavior with multiple concurrent discovery session with different configurations.
+
+    Device A (Publisher):
+      Publisher AA: ranging enabled
+      Publisher BB: ranging enabled
+      Publisher CC: ranging enabled
+      Publisher DD: ranging disabled
+    Device B (Subscriber):
+      Subscriber AA: ranging out-of-range -> no match
+      Subscriber BB: ranging in-range -> match w/range
+      Subscriber CC: ranging disabled -> match w/o range
+      Subscriber DD: ranging out-of-range -> match w/o range
+    """
+    p_dut = self.ads[0]
+    p_dut.pretty_name = 'Publisher'
+    s_dut = self.ads[1]
+    s_dut.pretty_name = 'Subscriber'
+
+    # Publisher+Subscriber: attach and wait for confirmation
+    p_id = p_dut.wifi_aware_snippet.wifiAwareAttached(False)
+    p_id.waitAndGet(constants.AttachCallBackMethodType.ATTACHED)
+    time.sleep(self.device_startup_offset)
+    s_id = s_dut.wifi_aware_snippet.wifiAwareAttached(False)
+    s_id.waitAndGet(constants.AttachCallBackMethodType.ATTACHED)
+
+    # Subscriber: start sessions
+    aa_s_disc_id = s_dut.wifi_aware_snippet.wifiAwareSubscribe(
+        s_id.callback_id,
+        constants.SubscribeConfig(
+            service_name='AA',
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM + 1,
+        ).to_dict())
+
+    bb_s_disc_id = s_dut.wifi_aware_snippet.wifiAwareSubscribe(
+        s_id.callback_id,
+        constants.SubscribeConfig(
+            service_name='BB',
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=0,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ).to_dict())
+
+    cc_s_disc_id = s_dut.wifi_aware_snippet.wifiAwareSubscribe(
+        s_id.callback_id,
+        constants.SubscribeConfig(
+            service_name='CC',
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode()).to_dict())
+
+    dd_s_disc_id = s_dut.wifi_aware_snippet.wifiAwareSubscribe(
+        s_id.callback_id,
+        constants.SubscribeConfig(
+            service_name='DD',
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM + 1,
+        ).to_dict())
+
+    aa_discovery = aa_s_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT)
+    callback_name = aa_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+        callback_name,
+        f'{s_dut} aa subscribe failed, got callback: {callback_name}.',
+        )
+
+    bb_discovery = bb_s_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT)
+    callback_name = bb_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+        callback_name,
+        f'{s_dut} bb subscribe failed, got callback: {callback_name}.',
+        )
+
+    cc_discovery = cc_s_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT)
+    callback_name = cc_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+        callback_name,
+        f'{s_dut} cc subscribe failed, got callback: {callback_name}.',
+        )
+    dd_discovery = dd_s_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT)
+    callback_name = dd_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
+        callback_name,
+        f'{s_dut} dd subscribe failed, got callback: {callback_name}.',
+        )
+    # Publisher: start sessions
+    aa_p_disc_id = p_dut.wifi_aware_snippet.wifiAwarePublish(
+        p_id.callback_id,
+        constants.PublishConfig(
+            service_name='AA',
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ).to_dict())
+    bb_p_disc_id = p_dut.wifi_aware_snippet.wifiAwarePublish(
+        p_id.callback_id,
+        constants.PublishConfig(
+            service_name='BB',
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ).to_dict())
+    cc_p_disc_id = p_dut.wifi_aware_snippet.wifiAwarePublish(
+        p_id.callback_id,
+        constants.PublishConfig(
+            service_name='CC',
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ).to_dict())
+    dd_p_disc_id = p_dut.wifi_aware_snippet.wifiAwarePublish(
+        p_id.callback_id,
+        constants.PublishConfig(
+            service_name='DD',
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+        ).to_dict())
+    aa_p_discovery = aa_p_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT)
+    callback_name = aa_p_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+        callback_name,
+        f'{p_dut} aa publish failed, got callback: {callback_name}.',
+        )
+
+    bb_p_discovery = bb_p_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT)
+    callback_name = bb_p_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+        callback_name,
+        f'{p_dut} bb publish failed, got callback: {callback_name}.',
+        )
+
+    cc_p_discovery = cc_p_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT)
+    callback_name = cc_p_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+        callback_name,
+        f'{p_dut} cc publish failed, got callback: {callback_name}.',
+        )
+
+    dd_p_discovery = dd_p_disc_id.waitAndGet(
+        constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
+        timeout=_DEFAULT_TIMEOUT)
+    callback_name = dd_p_discovery.data[_CALLBACK_NAME]
+    asserts.assert_equal(
+        constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
+        callback_name,
+        f'{p_dut} dd publish failed, got callback: {callback_name}.',
+        )
+    # Expected and unexpected service discovery
+    utils.concurrent_exec(
+        self._read_discovery_result,
+        param_list=[(cc_s_disc_id, True, False),
+                    (dd_s_disc_id, True, False),
+                    (bb_s_disc_id, True, True),
+                    (aa_s_disc_id, False, False)],
+        max_workers=4,
+    )
+    time.sleep(autils._EVENT_TIMEOUT)
+
+  def _extract_stats(
+      self,
+      results,
+      range_reference_mm,
+      range_margin_mm,
+      min_rssi,
+      reference_lci=None,
+      reference_lcr=None,
+      summary_only: bool = False,
+  ):
+    """Extract statistics from a list of RTT results.
+
+     - num_results (success or fails)
+     - num_success_results
+     - num_no_results (e.g. timeout)
+     - num_failures
+     - num_range_out_of_margin (only for successes)
+     - num_invalid_rssi (only for successes)
+     - distances: extracted list of distances
+     - distance_std_devs: extracted list of distance standard-deviations
+     - rssis: extracted list of RSSI
+     - distance_mean
+     - distance_std_dev (based on distance - ignoring the individual std-devs)
+     - rssi_mean
+     - rssi_std_dev
+     - status_codes
+     - lcis: extracted list of all of the individual LCI
+     - lcrs: extracted list of all of the individual LCR
+     - any_lci_mismatch: True/False - checks if all LCI results are identical to
+                         the reference LCI.
+     - any_lcr_mismatch: True/False - checks if all LCR results are identical to
+                         the reference LCR.
+     - num_attempted_measurements: extracted list of all of the individual
+                                   number of attempted measurements.
+     - num_successful_measurements: extracted list of all of the individual
+                                    number of successful measurements.
+     - invalid_num_attempted: True/False - checks if number of attempted
+                              measurements is non-zero for successful results.
+     - invalid_num_successful: True/False - checks if number of successful
+                               measurements is non-zero for successful results.
+
+    Args:
+      results: List of RTT results.
+      range_reference_mm: Reference value for the distance (in mm)
+      range_margin_mm: Acceptable absolute margin for distance (in mm)
+      min_rssi: Acceptable minimum RSSI value.
+      reference_lci: Reference values for LCI.
+      reference_lcr: Reference value for the LCR.
+      summary_only: Only include summary keys (reduce size).
+
+    Returns:
+      A dictionary of stats.
+    """
+    if reference_lci is None:
+        reference_lci = []
+    if reference_lcr is None:
+        reference_lcr = []
+
+    stats = {}
+    stats['num_results'] = 0
+    stats['num_success_results'] = 0
+    stats['num_no_results'] = 0
+    stats['num_failures'] = 0
+    stats['num_range_out_of_margin'] = 0
+    stats['num_invalid_rssi'] = 0
+    stats['any_lci_mismatch'] = False
+    stats['any_lcr_mismatch'] = False
+    stats['invalid_num_attempted'] = False
+    stats['invalid_num_successful'] = False
+
+    range_max_mm = range_reference_mm + range_margin_mm
+    range_min_mm = range_reference_mm - range_margin_mm
+
+    distances = []
+    distance_std_devs = []
+    rssis = []
+    num_attempted_measurements = []
+    num_successful_measurements = []
+    status_codes = []
+    lcis = []
+    lcrs = []
+
+    for i in range(len(results)):
+      result = results[i]
+
+      if result is None:  # None -> timeout waiting for RTT result
+        stats['num_no_results'] = stats['num_no_results'] + 1
+        continue
+      stats['num_results'] = stats['num_results'] + 1
+
+      status_codes.append(
+          result[constants.RangingResultCb.DATA_KEY_RESULT_STATUS]
+      )
+      if (
+          status_codes[-1]
+          != constants.RangingStatusCb.EVENT_CB_RANGING_STATUS_SUCCESS
+      ):
+        stats['num_failures'] = stats['num_failures'] + 1
+        continue
+      stats['num_success_results'] = stats['num_success_results'] + 1
+
+      distance_mm = result[
+          constants.RangingResultCb.DATA_KEY_RESULT_DISTANCE_MM
+      ]
+      distances.append(distance_mm)
+      if not range_min_mm <= distance_mm <= range_max_mm:
+        stats['num_range_out_of_margin'] = stats['num_range_out_of_margin'] + 1
+      distance_std_devs.append(
+          result[constants.RangingResultCb.DATA_KEY_DISTANCE_STD_DEV_MM]
+      )
+
+      rssi = result[constants.RangingResultCb.DATA_KEY_RESULT_RSSI]
+      rssis.append(rssi)
+      if not min_rssi <= rssi <= 0:
+        stats['num_invalid_rssi'] = stats['num_invalid_rssi'] + 1
+
+      num_attempted = result[
+          constants.RangingResultCb.DATA_KEY_NUM_ATTEMPTED_MEASUREMENTS
+      ]
+
+      num_attempted_measurements.append(num_attempted)
+      if num_attempted == 0:
+        stats['invalid_num_attempted'] = True
+
+      num_successful = result[
+          constants.RangingResultCb.DATA_KEY_NUM_SUCCESSFUL_MEASUREMENTS
+      ]
+      num_successful_measurements.append(num_successful)
+      if num_successful == 0:
+        stats['invalid_num_successful'] = True
+
+      lcis.append(result[constants.RangingResultCb.DATA_KEY_LCI])
+
+      if result[constants.RangingResultCb.DATA_KEY_LCI] != reference_lci:
+        stats['any_lci_mismatch'] = True
+      lcrs.append(result[constants.RangingResultCb.DATA_KEY_LCR])
+      if result[constants.RangingResultCb.DATA_KEY_LCR] != reference_lcr:
+        stats['any_lcr_mismatch'] = True
+
+    if distances:
+      stats['distance_mean'] = statistics.mean(distances)
+    if len(distances) > 1:
+      stats['distance_std_dev'] = statistics.stdev(distances)
+    if rssis:
+      stats['rssi_mean'] = statistics.mean(rssis)
+    if len(rssis) > 1:
+      stats['rssi_std_dev'] = statistics.stdev(rssis)
+    if not summary_only:
+      stats['distances'] = distances
+      stats['distance_std_devs'] = distance_std_devs
+      stats['rssis'] = rssis
+      stats['num_attempted_measurements'] = num_attempted_measurements
+      stats['num_successful_measurements'] = num_successful_measurements
+      stats['status_codes'] = status_codes
+      stats['lcis'] = lcis
+      stats['lcrs'] = lcrs
+
+    return stats
+
+  def _perform_ranging(
+      self,
+      ad: android_device.AndroidDevice,
+      request: constants.RangingRequest,
+  ):
+    """Performs ranging and checks the ranging result."""
+    ad.log.debug('Starting ranging with request: %s', request)
+    ranging_cb_handler = ad.wifi_aware_snippet.wifiAwareStartRanging(
+        request.to_dict()
+    )
+    event = ranging_cb_handler.waitAndGet(
+        event_name=constants.RangingResultCb.EVENT_NAME_ON_RANGING_RESULT,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+
+    callback_name = event.data.get(
+        constants.RangingResultCb.DATA_KEY_CALLBACK_NAME, None
+    )
+    asserts.assert_equal(
+        callback_name,
+        constants.RangingResultCb.CB_METHOD_ON_RANGING_RESULT,
+        'Ranging failed: got unexpected callback.',
+    )
+
+    results = event.data.get(
+        constants.RangingResultCb.DATA_KEY_RESULTS, None
+    )
+    return results
+
+  @ApiTest(
+    apis = [
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean enable)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMinDistanceMm(int)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(android.net.wifi.aware.ServiceDiscoveryInfo info)',
+        'android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, List<byte[]> matchFilter, int distanceMm)',
+        'android.net.wifi.aware.SubscribeDiscoverySession#updateSubscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig)',
+    ]
+  )
+  def test_discovery_direct_concurrency(self):
+    """Verify the behavior of Wi-Fi Aware Ranging used as part of discovery and as direct ranging to a peer device.
+
+    Process:
+    - Start YYY service with ranging in-range
+    - Start XXX service with ranging out-of-range
+    - Start performing direct Ranging
+    - While above going on update XXX to be in-range
+    - Keep performing direct Ranging in context of YYY
+    - Stop direct Ranging and look for XXX to discover
+    """
+    dut1 = self.ads[0]
+    dut1.pretty_name = 'DUT1'
+    dut2 = self.ads[1]
+    dut2.pretty_name = 'DUT2'
+
+    # DUTs: attach and wait for confirmation
+    dut1_id = dut1.wifi_aware_snippet.wifiAwareAttached(False)
+    dut1_id.waitAndGet(constants.AttachCallBackMethodType.ATTACHED)
+    time.sleep(self.device_startup_offset)
+    dut2_id = dut2.wifi_aware_snippet.wifiAwareAttached(True)
+    dut2_id.waitAndGet(constants.AttachCallBackMethodType.ATTACHED)
+    identity_changed_event = dut2_id.waitAndGet(
+        event_name=constants.AttachCallBackMethodType.ID_CHANGED,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    mac_address = identity_changed_event.data.get('mac', None)
+
+    # DUT1: publishers bring-up
+    _ = self._start_publish(
+        dut1,
+        dut1_id.callback_id,
+        pub_config=constants.PublishConfig(
+            service_name='XXX',
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+    )
+
+    _ = self._start_publish(
+        dut1,
+        dut1_id.callback_id,
+        pub_config=constants.PublishConfig(
+            service_name='YYY',
+            publish_type=constants.PublishType.UNSOLICITED,
+            service_specific_info=self.getname().encode(),
+            ranging_enabled=True,
+        ),
+    )
+    # DUT2: subscribers bring-up
+    xxx_s_id = self._start_subscribe(
+        dut2,
+        dut2_id.callback_id,
+        sub_config=constants.SubscribeConfig(
+            service_name='XXX',
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM + 1,
+        ),
+    )
+    yyy_s_id = self._start_subscribe(
+        dut2,
+        dut2_id.callback_id,
+        sub_config=constants.SubscribeConfig(
+            service_name='YYY',
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=None,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ),
+    )
+    # Service discovery: YYY (with range info), but no XXX
+    result_disc = self._read_discovery_result(yyy_s_id, True, True)
+    yyy_peer_id_on_sub = result_disc.data[
+        constants.WifiAwareSnippetParams.PEER_ID
+    ]
+    self._read_discovery_result(xxx_s_id, False, False)
+
+    # Direct ranging
+    results21 = []
+    for _ in range(10):
+      key_results = self._perform_ranging(
+          dut2, constants.RangingRequest(peer_ids=[yyy_peer_id_on_sub])
+      )
+      dut2.log.info(type(key_results))
+      dut2.log.info(key_results)
+      results21.append(key_results[0])
+
+    time.sleep(5)  # while switching roles
+    results12 = []
+    for _ in range(10):
+      key_results = self._perform_ranging(
+          dut1, constants.RangingRequest(peer_mac_addresses=[mac_address])
+      )
+      dut1.log.info(type(key_results))
+      dut1.log.info(key_results[0])
+      results12.append(key_results[0])
+
+    stats = [
+        self._extract_stats(results12, 0, 0, 0),
+        self._extract_stats(results21, 0, 0, 0),
+    ]
+    # Update XXX to be within range
+    dut2.wifi_aware_snippet.wifiAwareUpdateSubscribe(
+        xxx_s_id.callback_id,
+        constants.SubscribeConfig(
+            service_name='XXX',
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            service_specific_info=self.getname().encode(),
+            min_distance_mm=None,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        ).to_dict())
+    xxx_s_id.waitAndGet(
+        event_name=
+        constants.DiscoverySessionCallbackMethodType.SESSION_CONFIG_UPDATED,
+        timeout=_DEFAULT_TIMEOUT
+    )
+    # Expect discovery on XXX - wait until discovery with ranging:
+    # - 0 or more: without ranging info (due to concurrency limitations)
+    # - 1 or more: with ranging (once concurrency limitation relieved)
+    num_events = 0
+    while True:
+        try:
+            discover_data = xxx_s_id.waitAndGet(
+                event_name=(
+                    constants.DiscoverySessionCallbackMethodType
+                    .SERVICE_DISCOVERED_WITHIN_RANGE
+                ), timeout=3
+            )
+            if constants.WifiAwareSnippetParams.DISTANCE_MM in discover_data.data:
+                break
+        except callback_handler_v2.TimeoutError:
+            logging.info('discovered with in_range timeout, skip it')
+
+        num_events = num_events + 1
+        asserts.assert_true(
+            num_events < 10,  # arbitrary safety valve
+            'Way too many discovery events without ranging!')
+    logging.info('num_events : %s', num_events)
+    asserts.explicit_pass(
+        'Discovery/Direct RTT Concurrency Pass', extras={'data': stats})
+
+
+if __name__ == '__main__':
+  # Take test args
+  if '--' in sys.argv:
+    index = sys.argv.index('--')
+    sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+  test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_integration_test_suite.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_integration_test_suite.py
new file mode 100644
index 0000000000..5b093721d3
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_integration_test_suite.py
@@ -0,0 +1,61 @@
+#  Copyright (C) 2025 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Wi-Fi Aware integration test suite in Mobly."""
+
+import sys
+
+from mobly import base_suite
+from mobly import suite_runner
+import wifi_aware_attached_test
+import wifi_aware_capabilities_test
+import wifi_aware_datapath_test
+import wifi_aware_discovery_test
+import wifi_aware_discovery_with_ranging_test
+import wifi_aware_mac_random_test
+import wifi_aware_matchfilter_test
+import wifi_aware_message_test
+import wifi_aware_protocols_multi_country_test
+import wifi_aware_protocols_test
+
+
+class WifiAwareIntegrationTestSuite(base_suite.BaseSuite):
+  """Wi-Fi Aware integration test suite."""
+
+  def setup_suite(self, config):
+    del config  # Unused.
+    self.add_test_class(wifi_aware_attached_test.WifiAwareAttachTest)
+    self.add_test_class(wifi_aware_capabilities_test.WifiAwareCapabilitiesTest)
+    self.add_test_class(wifi_aware_datapath_test.WifiAwareDatapathTest)
+    self.add_test_class(wifi_aware_discovery_test.WifiAwareDiscoveryTest)
+    self.add_test_class(
+        wifi_aware_discovery_with_ranging_test.WiFiAwareDiscoveryWithRangingTest
+    )
+    self.add_test_class(wifi_aware_mac_random_test.MacRandomTest)
+    self.add_test_class(wifi_aware_matchfilter_test.WifiAwareMatchFilterTest)
+    self.add_test_class(wifi_aware_message_test.WifiAwareMessageTest)
+    self.add_test_class(
+        wifi_aware_protocols_multi_country_test.ProtocolsMultiCountryTest
+    )
+    self.add_test_class(wifi_aware_protocols_test.WifiAwareProtocolsTest)
+
+
+if __name__ == '__main__':
+  # Take test args
+  if '--' in sys.argv:
+    index = sys.argv.index('--')
+    sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+  suite_runner.run_suite_class()
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_mac_random_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_mac_random_test.py
new file mode 100644
index 0000000000..89aec464f3
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_mac_random_test.py
@@ -0,0 +1,278 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Wi-Fi Aware MacRandom test reimplemented in Mobly."""
+import re
+import sys
+import time
+
+from android.platform.test.annotations import ApiTest
+from aware import aware_lib_utils as autils
+from aware import constants
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+
+
+RUNTIME_PERMISSIONS = (
+    'android.permission.ACCESS_FINE_LOCATION',
+    'android.permission.ACCESS_COARSE_LOCATION',
+    'android.permission.NEARBY_WIFI_DEVICES',
+)
+PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+
+# Alias variable.
+_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
+
+# Aware NDI (NAN data-interface) name prefix
+AWARE_NDI_PREFIX = 'aware_data'
+
+
+class MacRandomTest(base_test.BaseTestClass):
+  """Test Cases: MacRandomTest.
+
+  Set of tests for Wi-Fi Aware MAC address randomization of NMI (NAN
+  management interface) and NDI (NAN data interface).
+  """
+  NUM_ITERATIONS = 10
+  RANDOM_INTERVAL = 120  # minimal value in current implementation
+
+  ads: list[android_device.AndroidDevice]
+  SERVICE_NAME = 'GoogleTestXYZ'
+
+  def setup_class(self):
+    # Register two Android devices.
+    self.ads = self.register_controller(android_device, min_number=1)
+
+    def setup_device(device: android_device.AndroidDevice):
+      autils.control_wifi(device, True)
+      device.load_snippet('wifi_aware_snippet', PACKAGE_NAME)
+      for permission in RUNTIME_PERMISSIONS:
+        device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+      asserts.abort_all_if(
+          not device.wifi_aware_snippet.wifiAwareIsAvailable(),
+          f'{device} Wi-Fi Aware is not available.',
+      )
+
+    # Set up devices in parallel.
+    utils.concurrent_exec(
+        setup_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+
+  def setup_test(self):
+    for ad in self.ads:
+      autils.control_wifi(ad, True)
+      aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
+      if not aware_avail:
+        ad.log.info('Aware not available. Waiting ...')
+        state_handler = ad.wifi_aware_snippet.wifiAwareMonitorStateChange()
+        state_handler.waitAndGet(
+            constants.WifiAwareBroadcast.WIFI_AWARE_AVAILABLE
+        )
+
+  def teardown_test(self):
+    utils.concurrent_exec(
+        self._teardown_test_on_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+    utils.concurrent_exec(
+        lambda d: d.services.create_output_excerpts_all(self.current_test_info),
+        param_list=[[ad] for ad in self.ads],
+        raise_on_exception=True,
+    )
+
+  def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
+    ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+    ad.wifi_aware_snippet.wifiAwareMonitorStopStateChange()
+    autils.control_wifi(ad, True)
+
+  def on_fail(self, record: records.TestResult) -> None:
+    android_device.take_bug_reports(
+        self.ads, destination=self.current_test_info.output_path
+    )
+
+  def get_wifi_mac_address(self, ad: android_device.AndroidDevice):
+    """Get the Wi-Fi interface MAC address.
+
+    Get the Wi-Fi interface MAC address as a upper-case string of hex digits
+    without any separators (e.g. ':').
+
+    Args:
+        ad: Device on which to run.
+
+    Returns:
+        The Wi-Fi interface MAC address as a upper-case string of hex digits
+        without any separators (e.g. ':').
+    """
+    results = ad.wifi_aware_snippet.wifiGetActiveNetworkMacAddress()
+    return results.upper().replace(':', '')
+
+  def get_mac_addr(self, device: android_device.AndroidDevice, interface: str):
+    """Get the MAC address.
+
+    Get the MAC address of the specified interface. Uses ifconfig and parses
+    its output. Normalizes string to remove ':' and upper case.
+
+    Args:
+        device: Device on which to query the interface MAC address.
+        interface: Name of the interface for which to obtain the MAC address.
+
+    Returns:
+        The MAC address with upper-case string.
+    """
+    out = device.adb.shell('ifconfig %s' % interface)
+    res = re.match(r'.* HWaddr (\S+).*', out.decode(), re.S)
+    asserts.assert_true(
+        res,
+        'Unable to obtain MAC address for interface %s' % interface,
+        extras=out,
+    )
+    return res.group(1).upper().replace(':', '')
+
+  def configure_mac_random_interval(
+      self, device: android_device.AndroidDevice, interval_sec: int
+  ):
+    """Use the command-line API to configure the MAC address randomization interval.
+
+    Args:
+        device: Device on which to perform configuration
+        interval_sec: The MAC randomization interval in seconds. A value of 0
+          disables all randomization.
+    """
+    device.adb.shell(
+        'cmd wifiaware native_api set mac_random_interval_sec %d' % interval_sec
+    )
+
+  @ApiTest(
+    apis=[
+        'android.net.wifi.WifiManager#getConnectionInfo()',
+        'android.net.wifi.WifiInfo#getMacAddress()',
+    ]
+  )
+  def test_nmi_ndi_randomization_on_enable(self):
+    """Validate randomization of the NMI.
+
+    Validate randomization of the NMI (NAN management interface) and all NDIs
+    (NAN data-interface) on each enable/disable cycle.
+    """
+    dut = self.ads[0]
+    asserts.skip_if(
+        not dut.is_adb_root,
+        'APM toggle needs Android device(s) with root permission',
+    )
+    # re-enable randomization interval (since if disabled it may also disable
+    # the 'randomize on enable' feature).
+    self.configure_mac_random_interval(dut, 1800)
+
+    # DUT: attach and wait for confirmation & identity 10 times
+    mac_addresses = {}
+    for _ in range(self.NUM_ITERATIONS):
+      attach_id = dut.wifi_aware_snippet.wifiAwareAttached(True)
+      identity_changed_event = attach_id.waitAndGet(
+          event_name=constants.AttachCallBackMethodType.ID_CHANGED,
+          timeout=_DEFAULT_TIMEOUT,
+      )
+      # process NMI
+      mac = identity_changed_event.data.get('mac', None)
+      dut.log.info('NMI=%s', mac)
+      if mac in mac_addresses:
+        mac_addresses[mac] = mac_addresses[mac] + 1
+      else:
+        mac_addresses[mac] = 1
+
+      # process NDIs
+      time.sleep(5)  # wait for NDI creation to complete
+      for j in range(autils.get_aware_capabilities(dut)['maxNdiInterfaces']):
+        ndi_interface = '%s%d' % (AWARE_NDI_PREFIX, j)
+        ndi_mac = self.get_mac_addr(dut, ndi_interface)
+        dut.log.info('NDI %s=%s', ndi_interface, ndi_mac)
+        if ndi_mac in mac_addresses:
+          mac_addresses[ndi_mac] = mac_addresses[ndi_mac] + 1
+        else:
+          mac_addresses[ndi_mac] = 1
+      dut.wifi_aware_snippet.wifiAwareDetach(attach_id.callback_id)
+    # Test for uniqueness
+    for mac in mac_addresses:
+      if mac_addresses[mac] != 1:
+        asserts.fail(
+            'MAC address %s repeated %d times (all=%s)'
+            % (mac, mac_addresses[mac], mac_addresses)
+        )
+    # Verify that infra interface (e.g. wlan0) MAC address is not used for NMI
+    infra_mac = self.get_wifi_mac_address(dut)
+    asserts.assert_false(
+        infra_mac in mac_addresses,
+        'Infrastructure MAC address (%s) is used for Aware NMI (all=%s)'
+        % (infra_mac, mac_addresses),
+    )
+
+  @ApiTest(
+    apis=[
+        'android.net.wifi.aware.IdentityChangedListener#onIdentityChanged(byte[] mac)',
+    ]
+  )
+  def test_nmi_randomization_on_interval(self):
+    """Validate randomization of the NMI on different intervals.
+
+    Validate randomization of the NMI (NAN management interface) on a set
+    interval. Default value is 30 minutes - change to a small value to allow
+    testing in real-time.
+    """
+    dut = self.ads[0]
+    asserts.skip_if(
+        not dut.is_adb_root,
+        'APM toggle needs Android device(s) with root permission',
+    )
+    # set randomization interval to 120 seconds
+    self.configure_mac_random_interval(dut, self.RANDOM_INTERVAL)
+
+    attach_id = dut.wifi_aware_snippet.wifiAwareAttached(True)
+    identity_changed_event = attach_id.waitAndGet(
+        event_name=constants.AttachCallBackMethodType.ID_CHANGED,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+    mac_address1 = identity_changed_event.data.get('mac', None)
+    dut.log.info('mac1=%s', mac_address1)
+
+    identity_changed_event = attach_id.waitAndGet(
+        event_name=constants.AttachCallBackMethodType.ID_CHANGED,
+        timeout=self.RANDOM_INTERVAL + 5,
+    )
+    mac_address2 = identity_changed_event.data.get('mac', None)
+    dut.log.info('mac2=%s', mac_address2)
+
+    # validate MAC address is randomized
+    asserts.assert_false(
+        mac_address1 == mac_address2,
+        'Randomized MAC addresses (%s, %s) should be different'
+        % (mac_address1, mac_address2),
+    )
+
+
+if __name__ == '__main__':
+  # Take test args
+  if '--' in sys.argv:
+    index = sys.argv.index('--')
+    sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+  test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_matchfilter_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_matchfilter_test.py
index f61f367eae..0f4a485c6f 100644
--- a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_matchfilter_test.py
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_matchfilter_test.py
@@ -20,6 +20,7 @@ import logging
 import random
 import sys
 
+from android.platform.test.annotations import ApiTest
 from aware import aware_lib_utils as autils
 from aware import constants
 from mobly import asserts
@@ -36,6 +37,10 @@ RUNTIME_PERMISSIONS = (
     'android.permission.NEARBY_WIFI_DEVICES',
 )
 PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+snippets_to_load = [
+    ('wifi_aware_snippet', PACKAGE_NAME),
+    ('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME),
+]
 _DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
 _MSG_ID_SUB_TO_PUB = random.randint(1000, 5000)
 _MSG_ID_PUB_TO_SUB = random.randint(5001, 9999)
@@ -106,11 +111,10 @@ class WifiAwareMatchFilterTest(base_test.BaseTestClass):
         self.subscriber = self.ads[1]
 
         def setup_device(device: android_device.AndroidDevice):
-            device.load_snippet(
-                'wifi_aware_snippet', PACKAGE_NAME
-            )
+            for snippet_name, package_name in snippets_to_load:
+                device.load_snippet(snippet_name, package_name)
             for permission in RUNTIME_PERMISSIONS:
-                device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+                device.adb.shell(['pm', 'grant', package_name, permission])
             asserts.abort_all_if(
                 not device.wifi_aware_snippet.wifiAwareIsAvailable(),
                 f'{device} Wi-Fi Aware is not available.',
@@ -126,7 +130,7 @@ class WifiAwareMatchFilterTest(base_test.BaseTestClass):
 
     def setup_test(self):
         for ad in self.ads:
-            autils.control_wifi(ad, True)
+            ad.wifi.wifiEnable()
             aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
             if not aware_avail:
                 ad.log.info('Aware not available. Waiting ...')
@@ -152,9 +156,12 @@ class WifiAwareMatchFilterTest(base_test.BaseTestClass):
     def _teardown_test_on_device(self,
                                  ad: android_device.AndroidDevice) -> None:
         ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
-        autils.reset_device_parameters(ad)
-        autils.validate_forbidden_callbacks(ad)
-        autils.reset_device_statistics(ad)
+        ad.wifi.wifiClearConfiguredNetworks()
+        ad.wifi.wifiEnable()
+        if ad.is_adb_root:
+          autils.reset_device_parameters(ad)
+          autils.reset_device_statistics(ad)
+          autils.validate_forbidden_callbacks(ad)
 
     def on_fail(self, record: records.TestResult) -> None:
         android_device.take_bug_reports(self.ads,
@@ -325,12 +332,34 @@ class WifiAwareMatchFilterTest(base_test.BaseTestClass):
             "Some match filter tests are failing",
             extras={"data": fails})
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_match_filters_per_spec_unsolicited_passive(self):
         """Validate all the match filter combinations in the Wi-Fi Aware spec,
         Appendix H for Unsolicited Publish (tx filter) Passive Subscribe (rx
         filter)"""
         self.run_match_filters_per_spec(do_unsolicited_passive=True)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_match_filters_per_spec_solicited_active(self):
         """Validate all the match filter combinations in the Wi-Fi Aware spec,
         Appendix H for Solicited Publish (rx filter) Active Subscribe (tx
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_message_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_message_test.py
index badd1390f4..ce6b658143 100644
--- a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_message_test.py
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_message_test.py
@@ -18,6 +18,7 @@ import logging
 import string
 import sys
 
+from android.platform.test.annotations import ApiTest
 from aware import aware_lib_utils as autils
 from aware import constants
 from mobly import asserts
@@ -34,6 +35,10 @@ RUNTIME_PERMISSIONS = (
     'android.permission.NEARBY_WIFI_DEVICES',
 )
 PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+snippets_to_load = [
+    ('wifi_aware_snippet', PACKAGE_NAME),
+    ('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME),
+]
 _DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
 _CALLBACK_NAME = constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
 _IS_SESSION_INIT = constants.DiscoverySessionCallbackParamsType.IS_SESSION_INIT
@@ -81,11 +86,10 @@ class WifiAwareMessageTest(base_test.BaseTestClass):
         self.subscriber = self.ads[1]
 
         def setup_device(device: android_device.AndroidDevice):
-            device.load_snippet(
-                'wifi_aware_snippet', PACKAGE_NAME
-            )
+            for snippet_name, package_name in snippets_to_load:
+                device.load_snippet(snippet_name, package_name)
             for permission in RUNTIME_PERMISSIONS:
-                device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+                device.adb.shell(['pm', 'grant', package_name, permission])
             asserts.abort_all_if(
                 not device.wifi_aware_snippet.wifiAwareIsAvailable(),
                 f'{device} Wi-Fi Aware is not available.',
@@ -101,7 +105,7 @@ class WifiAwareMessageTest(base_test.BaseTestClass):
 
     def setup_test(self):
         for ad in self.ads:
-            autils.control_wifi(ad, True)
+            ad.wifi.wifiEnable()
             aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
             if not aware_avail:
                 ad.log.info('Aware not available. Waiting ...')
@@ -125,9 +129,12 @@ class WifiAwareMessageTest(base_test.BaseTestClass):
 
     def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
         ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
-        autils.reset_device_parameters(ad)
-        autils.validate_forbidden_callbacks(ad)
-        autils.reset_device_statistics(ad)
+        ad.wifi.wifiClearConfiguredNetworks()
+        ad.wifi.wifiEnable()
+        if ad.is_adb_root:
+          autils.reset_device_parameters(ad)
+          autils.reset_device_statistics(ad)
+          autils.validate_forbidden_callbacks(ad)
 
     def on_fail(self, record: records.TestResult) -> None:
         android_device.take_bug_reports(self.ads,
@@ -403,12 +410,9 @@ class WifiAwareMessageTest(base_test.BaseTestClass):
                 event_name=_MESSAGE_SEND_RESULT,
                 timeout=_DEFAULT_TIMEOUT,
                 )
-            logging.info("tx_event: %s",tx_event )
             tx_msg_id = tx_event.data[
                 constants.DiscoverySessionCallbackParamsType.MESSAGE_ID
                 ]
-            logging.info("tx_msg_id: %s",tx_msg_id )
-            logging.info("tx_msg_ids: %s",tx_msg_ids )
             tx_msg_ids[tx_msg_id] = tx_msg_ids[tx_msg_id] + 1
             if tx_msg_ids[tx_msg_id] == 1:
                 still_to_be_tx = still_to_be_tx - 1
@@ -569,6 +573,16 @@ class WifiAwareMessageTest(base_test.BaseTestClass):
         self.wait_for_messages(msgs2, msg_ids2, p_disc_id2, s_disc_id2, p_dut,
                                s_dut, payload_size == _PAYLOAD_SIZE_MIN)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
 
     def test_message_no_queue_min(self):
         """Functional / Message / No queue
@@ -576,45 +590,112 @@ class WifiAwareMessageTest(base_test.BaseTestClass):
         """
         self.run_message_no_queue(_PAYLOAD_SIZE_MIN)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_message_no_queue_typical(self):
         """Functional / Message / No queue
         - Typical payload size
         """
         self.run_message_no_queue(_PAYLOAD_SIZE_TYPICAL)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_message_no_queue_max(self):
         """Functional / Message / No queue
         - Max payload size (based on device capabilities)
         """
         self.run_message_no_queue(_PAYLOAD_SIZE_MAX)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_message_with_queue_min(self):
         """Functional / Message / With queue
     - Minimal payload size (none or "")
     """
         self.run_message_with_queue(_PAYLOAD_SIZE_MIN)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_message_with_queue_typical(self):
         """Functional / Message / With queue
     - Typical payload size
     """
         self.run_message_with_queue(_PAYLOAD_SIZE_TYPICAL)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_message_with_queue_max(self):
         """Functional / Message / With queue
     - Max payload size (based on device capabilities)
     """
         self.run_message_with_queue(_PAYLOAD_SIZE_MAX)
 
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+            'android.net.wifi.aware.DiscoverySession#sendMessage(int, byte[])',
+        ]
+    )
+
     def test_message_with_multiple_discovery_sessions_typical(self):
         """Functional / Message / Multiple sessions
 
-     Sets up 2 discovery sessions on 2 devices. Sends a message in each
-     direction on each discovery session and verifies that reaches expected
-     destination.
+    Sets up 2 discovery sessions on 2 devices. Sends a message in each
+    direction on each discovery session and verifies that reaches expected
+    destination.
     """
         self.run_message_multi_session_with_queue(_PAYLOAD_SIZE_TYPICAL)
 
+
 if __name__ == '__main__':
     # Take test args
     if '--' in sys.argv:
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_protocols_multi_country_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_protocols_multi_country_test.py
new file mode 100644
index 0000000000..6c8467f83e
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_protocols_multi_country_test.py
@@ -0,0 +1,327 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Wi-Fi Aware ProtocolsMultiCountry test reimplemented in Mobly."""
+import logging
+import sys
+import time
+
+from android.platform.test.annotations import ApiTest
+from aware import aware_lib_utils as autils
+from aware import constants
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+from mobly.snippet import callback_event
+
+RUNTIME_PERMISSIONS = (
+    'android.permission.ACCESS_FINE_LOCATION',
+    'android.permission.ACCESS_COARSE_LOCATION',
+    'android.permission.NEARBY_WIFI_DEVICES',
+)
+PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+
+
+class ProtocolsMultiCountryTest(base_test.BaseTestClass):
+  """Test Case: ProtocolsMultiCountry.
+
+  Set of tests for Wi-Fi Aware data-paths: validating (MultiCountry) protocols
+  running on top of a data-path.
+  """
+
+  device_startup_offset = 1
+
+  ads: list[android_device.AndroidDevice]
+  SERVICE_NAME = 'GoogleTestXYZ'
+  country_code = 'US,JP,DE,AU,CN,GB'
+
+  def setup_class(self):
+    # Register two Android devices.
+    logging.basicConfig(level=logging.INFO, force=True)
+    self.ads = self.register_controller(android_device, min_number=2)
+    if 'wifi_country_code' in self.user_params:
+      self.country_code = self.user_params['wifi_country_code']
+
+    logging.info('country code list for testing : %s', self.country_code)
+
+    def setup_device(device: android_device.AndroidDevice):
+      autils.control_wifi(device, True)
+      device.load_snippet('wifi_aware_snippet', PACKAGE_NAME)
+      for permission in RUNTIME_PERMISSIONS:
+        device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+      asserts.abort_all_if(
+          not device.wifi_aware_snippet.wifiAwareIsAvailable(),
+          f'{device} Wi-Fi Aware is not available.',
+      )
+
+    # Set up devices in parallel.
+    utils.concurrent_exec(
+        setup_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+
+  def setup_test(self):
+    logging.info('setup_test')
+    for ad in self.ads:
+      ad.log.info('setup_test: open wifi')
+      autils.control_wifi(ad, True)
+      aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
+      if not aware_avail:
+        ad.log.info('Aware not available. Waiting ...')
+        state_handler = ad.wifi_aware_snippet.wifiAwareMonitorStateChange()
+        state_handler.waitAndGet(
+            constants.WifiAwareBroadcast.WIFI_AWARE_AVAILABLE
+        )
+
+  def teardown_test(self):
+    logging.info('teardown_test')
+    utils.concurrent_exec(
+        self._teardown_test_on_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+    utils.concurrent_exec(
+        lambda d: d.services.create_output_excerpts_all(self.current_test_info),
+        param_list=[[ad] for ad in self.ads],
+        raise_on_exception=True,
+    )
+
+  def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
+    ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+    ad.wifi_aware_snippet.wifiAwareMonitorStopStateChange()
+    autils.control_wifi(ad, True)
+
+  def on_fail(self, record: records.TestResult) -> None:
+    logging.info('on_fail')
+    android_device.take_bug_reports(
+        self.ads, destination=self.current_test_info.output_path
+    )
+
+  def set_wifi_country_code(
+      self,
+      ad: android_device.AndroidDevice,
+      country_code: str):
+    """Sets the wifi country code on the device.
+
+    Args:
+        ad: An AndroidDevice object.
+        country_code: 2 letter ISO country code
+
+    Raises:
+        An RpcException if unable to set the country code.
+    """
+    try:
+        ad.adb.shell('cmd wifi force-country-code enabled %s' % country_code)
+    except android_device.adb.AdbError as e:
+        ad.log.error(f"Failed to set country code: {e}")
+        ad.droid.wifiSetCountryCode(constants.CountryCode.US)
+
+  def create_ib_ndp(
+      self,
+      p_dut: android_device.AndroidDevice,
+      s_dut: android_device.AndroidDevice,
+      p_config: dict[str, any],
+      s_config: dict[str, any],
+      device_startup_offset,
+  ) -> tuple[
+      callback_event.CallbackEvent,
+      callback_event.CallbackEvent,
+      str,
+      str,
+      str,
+      str,
+  ]:
+    """Create an NDP (using in-band discovery).
+
+    Args:
+      p_dut: Device to use as publisher.
+      s_dut: Device to use as subscriber.
+      p_config: Publish configuration.
+      s_config: Subscribe configuration.
+      device_startup_offset: Number of seconds to offset the enabling of NAN on
+        the two devices.
+
+    Returns:
+      A tuple containing the following:
+        - Publisher network capabilities.
+        - Subscriber network capabilities.
+        - Publisher network interface name.
+        - Subscriber network interface name.
+        - Publisher IPv6 address.
+        - Subscriber IPv6 address.
+    """
+    (_, _, p_disc_id, s_disc_id, peer_id_on_sub, peer_id_on_pub) = (
+        autils.create_discovery_pair(
+            p_dut, s_dut, p_config, s_config, device_startup_offset, msg_id=9999
+        )
+    )
+    pub_accept_handler = (
+        p_dut.wifi_aware_snippet.connectivityServerSocketAccept()
+    )
+    network_id = pub_accept_handler.callback_id
+
+    # Request network Publisher (responder).
+    pub_network_cb_handler = autils.request_network(
+        ad=p_dut,
+        discovery_session=p_disc_id.callback_id,
+        peer=peer_id_on_pub,
+        net_work_request_id=network_id,
+    )
+    time.sleep(device_startup_offset)
+    # Request network for Subscriber (initiator).
+    sub_network_cb_handler = autils.request_network(
+        ad=s_dut,
+        discovery_session=s_disc_id.callback_id,
+        peer=peer_id_on_sub,
+        net_work_request_id=network_id,
+    )
+    pub_network_cap = autils.wait_for_network(
+        ad=p_dut,
+        request_network_cb_handler=pub_network_cb_handler,
+        expected_channel=None,
+    )
+    sub_network_cap = autils.wait_for_network(
+        ad=s_dut,
+        request_network_cb_handler=sub_network_cb_handler,
+        expected_channel=None,
+    )
+    pub_network_link = autils.wait_for_link(
+        ad=p_dut,
+        request_network_cb_handler=pub_network_cb_handler,
+    )
+    p_aware_if = pub_network_link.data[
+        constants.NetworkCbEventKey.NETWORK_INTERFACE_NAME
+    ]
+    sub_network_link = autils.wait_for_link(
+        ad=s_dut,
+        request_network_cb_handler=sub_network_cb_handler,
+    )
+    s_aware_if = sub_network_link.data[
+        constants.NetworkCbEventKey.NETWORK_INTERFACE_NAME
+    ]
+
+    p_ipv6 = p_dut.wifi_aware_snippet.connectivityGetLinkLocalIpv6Address(
+        p_aware_if
+    )
+    p_dut.log.info('interfaceName = %s, ipv6=%s', p_aware_if, p_ipv6)
+    s_ipv6 = s_dut.wifi_aware_snippet.connectivityGetLinkLocalIpv6Address(
+        s_aware_if
+    )
+    s_dut.log.info('interfaceName = %s, ipv6=%s', s_aware_if, s_ipv6)
+
+    return (
+        pub_network_cap,
+        sub_network_cap,
+        p_aware_if,
+        s_aware_if,
+        p_ipv6,
+        s_ipv6,
+    )
+
+  @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_UNSOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest request, android.net.ConnectivityManager.NetworkCallback networkCallback, int timeoutMs)',
+    ]
+  )
+  def test_ping6_ib_unsolicited_passive_multicountry(self):
+    """Validate ping6 works with UNSOLICITED/PASSIVE sessions.
+
+    Validate that ping6 works correctly on an NDP created using Aware
+    discovery with UNSOLICITED/PASSIVE sessions by different country code.
+    """
+    self.ib_ping6_test(pub_type=constants.PublishType.UNSOLICITED,
+                       sub_type=constants.SubscribeType.PASSIVE)
+
+  @ApiTest(
+    apis=[
+        'android.net.wifi.aware.PublishConfig.Builder#setPublishType(PublishConfig.PUBLISH_TYPE_SOLICITED)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE)',
+        'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        'android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest request, android.net.ConnectivityManager.NetworkCallback networkCallback, int timeoutMs)',
+    ]
+  )
+  def test_ping6_ib_solicited_active_multicountry(self):
+    """"Validate ping6 works with SOLICITED/ACTIVE session.
+
+    Validate that ping6 works correctly on an NDP created using Aware
+    discovery with SOLICITED/ACTIVE sessions by different country code.
+    """
+    self.ib_ping6_test(pub_type=constants.PublishType.SOLICITED,
+                       sub_type=constants.SubscribeType.ACTIVE)
+
+  def ib_ping6_test(self, pub_type: int, sub_type: int):
+    p_dut = self.ads[0]
+    s_dut = self.ads[1]
+    asserts.skip_if(
+        not p_dut.is_adb_root or not s_dut.is_adb_root,
+        'APM toggle needs Android device(s) with root permission',
+    )
+    for code in self.country_code.split(','):
+      p_dut.log.info('testing country code : %s', code)
+      self.set_wifi_country_code(p_dut, code)
+      self.set_wifi_country_code(s_dut, code)
+      # Create NDP.
+      (
+          pub_network_cap,
+          sub_network_cap,
+          p_aware_if,
+          s_aware_if,
+          p_ipv6,
+          s_ipv6,
+      ) = self.create_ib_ndp(
+          p_dut,
+          s_dut,
+          p_config=autils.create_discovery_config(
+              self.SERVICE_NAME, p_type=pub_type
+          ),
+          s_config=autils.create_discovery_config(
+              self.SERVICE_NAME, s_type=sub_type
+          ),
+          device_startup_offset=self.device_startup_offset,
+      )
+      logging.info('Interface names: P=%s, S=%s', p_aware_if, s_aware_if)
+      logging.info('Interface addresses (IPv6): P=%s, S=%s', p_ipv6, s_ipv6)
+
+      ndpfreq = pub_network_cap.data[constants.NetworkCbEventKey.CHANNEL_IN_MHZ]
+      p_dut.log.info('Publisher freq list=%s', ndpfreq)
+
+      ndpfreq = sub_network_cap.data[constants.NetworkCbEventKey.CHANNEL_IN_MHZ]
+      s_dut.log.info('Subscriber freq list=%s', ndpfreq)
+
+      autils.run_ping6(p_dut, s_ipv6)
+      time.sleep(1)
+      autils.run_ping6(s_dut, p_ipv6)
+
+      # Session clean-up.
+      p_dut.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+      s_dut.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+
+
+if __name__ == '__main__':
+  # Take test args
+  if '--' in sys.argv:
+    index = sys.argv.index('--')
+    sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+  test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_protocols_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_protocols_test.py
new file mode 100644
index 0000000000..9cbbb40011
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_aware_protocols_test.py
@@ -0,0 +1,468 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Wi-Fi Aware Protocols test reimplemented in Mobly."""
+import logging
+import sys
+import time
+
+from aware import aware_lib_utils as autils
+from aware import constants
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+from mobly.controllers.android_device_lib import callback_handler_v2
+from mobly.snippet import callback_event
+
+RUNTIME_PERMISSIONS = (
+    'android.permission.ACCESS_FINE_LOCATION',
+    'android.permission.ACCESS_COARSE_LOCATION',
+    'android.permission.NEARBY_WIFI_DEVICES',
+)
+PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+
+_REQUEST_NETWORK_TIMEOUT_MS = 15 * 1000
+
+# The number of second to 'reasonably' wait to make sure that devices synchronize
+# with each other - useful for OOB test cases, where the OOB discovery would
+# take some time
+_WAIT_FOR_CLUSTER = 5
+
+# Aware Data-Path Constants
+_DATA_PATH_INITIATOR = 0
+_DATA_PATH_RESPONDER = 1
+
+
+class WifiAwareProtocolsTest(base_test.BaseTestClass):
+  """Set of tests for Wi-Fi Aware data-paths: validating protocols running ontop of a data-path."""
+  # The message ID counter to make sure all uses are unique.
+  msg_id = 0
+  device_startup_offset = 1
+
+  ads: list[android_device.AndroidDevice]
+  SERVICE_NAME = 'GoogleTestXYZ'
+
+  def setup_class(self):
+    # Register two Android devices.
+    logging.basicConfig(level=logging.INFO, force=True)
+    self.ads = self.register_controller(android_device, min_number=2)
+
+    def setup_device(device: android_device.AndroidDevice):
+      autils.control_wifi(device, True)
+      device.load_snippet('wifi_aware_snippet', PACKAGE_NAME)
+      for permission in RUNTIME_PERMISSIONS:
+        device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+      asserts.abort_all_if(
+          not device.wifi_aware_snippet.wifiAwareIsAvailable(),
+          f'{device} Wi-Fi Aware is not available.',
+      )
+
+    # Set up devices in parallel.
+    utils.concurrent_exec(
+        setup_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+
+  def setup_test(self):
+    for ad in self.ads:
+      ad.log.info('setup_test: open wifi')
+      autils.control_wifi(ad, True)
+      aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
+      if not aware_avail:
+        ad.log.info('Aware not available. Waiting ...')
+        state_handler = ad.wifi_aware_snippet.wifiAwareMonitorStateChange()
+        state_handler.waitAndGet(
+            constants.WifiAwareBroadcast.WIFI_AWARE_AVAILABLE
+        )
+
+  def teardown_test(self):
+    utils.concurrent_exec(
+        self._teardown_test_on_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+    utils.concurrent_exec(
+        lambda d: d.services.create_output_excerpts_all(self.current_test_info),
+        param_list=[[ad] for ad in self.ads],
+        raise_on_exception=True,
+    )
+
+  def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
+    ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+    ad.wifi_aware_snippet.wifiAwareMonitorStopStateChange()
+    autils.control_wifi(ad, True)
+
+  def on_fail(self, record: records.TestResult) -> None:
+    android_device.take_bug_reports(
+        self.ads, destination=self.current_test_info.output_path
+    )
+
+  def create_ib_ndp(
+      self,
+      p_dut: android_device.AndroidDevice,
+      s_dut: android_device.AndroidDevice,
+      p_config: dict[str, any],
+      s_config: dict[str, any],
+      device_startup_offset,
+  ) -> tuple[
+      callback_event.CallbackEvent,
+      callback_event.CallbackEvent,
+      str,
+      str,
+      str,
+      str,
+  ]:
+    """Create an NDP (using in-band discovery).
+
+    Args:
+      p_dut: Device to use as publisher.
+      s_dut: Device to use as subscriber.
+      p_config: Publish configuration.
+      s_config: Subscribe configuration.
+      device_startup_offset: Number of seconds to offset the enabling of NAN on
+        the two devices.
+
+    Returns:
+      A tuple containing the following:
+        - Publisher network capabilities.
+        - Subscriber network capabilities.
+        - Publisher network interface name.
+        - Subscriber network interface name.
+        - Publisher IPv6 address.
+        - Subscriber IPv6 address.
+    """
+    (_, _, p_disc_id, s_disc_id, peer_id_on_sub, peer_id_on_pub) = (
+        autils.create_discovery_pair(
+            p_dut, s_dut, p_config, s_config, device_startup_offset, msg_id=9999
+        )
+    )
+
+    pub_accept_handler = (
+        p_dut.wifi_aware_snippet.connectivityServerSocketAccept()
+    )
+    network_id = pub_accept_handler.callback_id
+
+    # Request network Publisher (responder).
+    pub_network_cb_handler = autils.request_network(
+        ad=p_dut,
+        discovery_session=p_disc_id.callback_id,
+        peer=peer_id_on_pub,
+        net_work_request_id=network_id,
+    )
+    # Request network for Subscriber (initiator).
+    sub_network_cb_handler = autils.request_network(
+        ad=s_dut,
+        discovery_session=s_disc_id.callback_id,
+        peer=peer_id_on_sub,
+        net_work_request_id=network_id,
+    )
+    pub_network_cap = autils.wait_for_network(
+        ad=p_dut,
+        request_network_cb_handler=pub_network_cb_handler,
+        expected_channel=None,
+    )
+    sub_network_cap = autils.wait_for_network(
+        ad=s_dut,
+        request_network_cb_handler=sub_network_cb_handler,
+        expected_channel=None,
+    )
+    pub_network_link = autils.wait_for_link(
+        ad=p_dut,
+        request_network_cb_handler=pub_network_cb_handler,
+    )
+    p_aware_if = pub_network_link.data[
+        constants.NetworkCbEventKey.NETWORK_INTERFACE_NAME
+    ]
+    sub_network_link = autils.wait_for_link(
+        ad=s_dut,
+        request_network_cb_handler=sub_network_cb_handler,
+    )
+    s_aware_if = sub_network_link.data[
+        constants.NetworkCbEventKey.NETWORK_INTERFACE_NAME
+    ]
+
+    p_ipv6 = p_dut.wifi_aware_snippet.connectivityGetLinkLocalIpv6Address(
+        p_aware_if
+    )
+    p_dut.log.info('interfaceName = %s, ipv6=%s', p_aware_if, p_ipv6)
+    s_ipv6 = s_dut.wifi_aware_snippet.connectivityGetLinkLocalIpv6Address(
+        s_aware_if
+    )
+    s_dut.log.info('interfaceName = %s, ipv6=%s', s_aware_if, s_ipv6)
+
+    return (
+        pub_network_cap,
+        sub_network_cap,
+        p_aware_if,
+        s_aware_if,
+        p_ipv6,
+        s_ipv6,
+    )
+
+  def test_ping6_ib_unsolicited_passive(self):
+    """Validate ping6 works with NSOLICITED/PASSIVE sessions..
+
+    Validate that ping6 works correctly on an NDP created using Aware
+    discovery with UNSOLICITED/PASSIVE sessions.
+    """
+    p_dut = self.ads[0]
+    s_dut = self.ads[1]
+    # Create NDP.
+    (_, _, p_aware_if, s_aware_if, p_ipv6, s_ipv6) = (
+        self.create_ib_ndp(
+            p_dut,
+            s_dut,
+            p_config=autils.create_discovery_config(
+                self.SERVICE_NAME, p_type=constants.PublishType.UNSOLICITED
+            ),
+            s_config=autils.create_discovery_config(
+                self.SERVICE_NAME, s_type=constants.SubscribeType.PASSIVE
+            ),
+            device_startup_offset=self.device_startup_offset,
+        )
+    )
+    logging.info('Interface names: P=%s, S=%s', p_aware_if, s_aware_if)
+    logging.info('Interface addresses (IPv6): P=%s, S=%s', p_ipv6, s_ipv6)
+
+    autils.run_ping6(p_dut, s_ipv6)
+    time.sleep(1)
+    autils.run_ping6(s_dut, p_ipv6)
+
+    # Session clean-up.
+    p_dut.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+    s_dut.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+
+  def test_ping6_ib_solicited_active(self):
+    """"Validate ping6 works with  SOLICITED/ACTIVE sessions.
+
+    Validate that ping6 works correctly on an NDP created using Aware
+    discovery with SOLICITED/ACTIVE sessions.
+    """
+    p_dut = self.ads[0]
+    s_dut = self.ads[1]
+    # Create NDP.
+    (_, _, p_aware_if, s_aware_if, p_ipv6, s_ipv6) = (
+        self.create_ib_ndp(
+            p_dut,
+            s_dut,
+            p_config=autils.create_discovery_config(
+                self.SERVICE_NAME, p_type=constants.PublishType.SOLICITED),
+            s_config=autils.create_discovery_config(
+                self.SERVICE_NAME, s_type=constants.SubscribeType.ACTIVE),
+            device_startup_offset=self.device_startup_offset,
+        )
+    )
+    logging.info('Interface names: P=%s, S=%s', p_aware_if, s_aware_if)
+    logging.info('Interface addresses (IPv6): P=%s, S=%s', p_ipv6, s_ipv6)
+
+    autils.run_ping6(p_dut, s_ipv6)
+    time.sleep(1)
+    autils.run_ping6(s_dut, p_ipv6)
+
+    # Session clean-up.
+    p_dut.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+    s_dut.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+
+  def request_oob_network(
+      self,
+      ad: android_device.AndroidDevice,
+      aware_session: str,
+      role: int,
+      mac: str,
+      passphrase: str | None,
+      pmk: str | None,
+      net_work_request_id: str,
+  ) -> callback_handler_v2.CallbackHandlerV2:
+    """Requests a Wi-Fi Aware network."""
+    network_specifier_parcel = (
+        ad.wifi_aware_snippet.createNetworkSpecifierOob(
+            aware_session, role, mac, passphrase, pmk
+        )
+    )
+    network_request_dict = constants.NetworkRequest(
+        transport_type=constants.NetworkCapabilities.Transport.TRANSPORT_WIFI_AWARE,
+        network_specifier_parcel=network_specifier_parcel['result'],
+    ).to_dict()
+    return ad.wifi_aware_snippet.connectivityRequestNetwork(
+        net_work_request_id, network_request_dict, _REQUEST_NETWORK_TIMEOUT_MS
+    )
+
+  def create_oob_ndp_on_sessions(
+      self,
+      init_dut,
+      resp_dut,
+      init_id,
+      init_mac,
+      resp_id,
+      resp_mac):
+    """Create an NDP on top of existing Aware sessions (using OOB discovery).
+
+    Args:
+        init_dut: Initiator device
+        resp_dut: Responder device
+        init_id: Initiator attach session id
+        init_mac: Initiator discovery MAC address
+        resp_id: Responder attach session id
+        resp_mac: Responder discovery MAC address
+    Returns:
+        init_req_key: Initiator network request
+        resp_req_key: Responder network request
+        init_aware_if: Initiator Aware data interface
+        resp_aware_if: Responder Aware data interface
+        init_ipv6: Initiator IPv6 address
+        resp_ipv6: Responder IPv6 address
+    """
+    # Responder: request network.
+    init_dut_accept_handler = (
+        init_dut.wifi_aware_snippet.connectivityServerSocketAccept())
+    network_id = init_dut_accept_handler.callback_id
+    resp_network_cb_handler = self.request_oob_network(
+        resp_dut,
+        resp_id,
+        _DATA_PATH_RESPONDER,
+        init_mac,
+        None,
+        None,
+        network_id
+        )
+    # Initiator: request network.
+    init_network_cb_handler = self.request_oob_network(
+        init_dut,
+        init_id,
+        _DATA_PATH_INITIATOR,
+        resp_mac,
+        None,
+        None,
+        network_id
+        )
+    pub_network_cap = autils.wait_for_network(
+        ad=init_dut,
+        request_network_cb_handler=init_network_cb_handler,
+        expected_channel=None,
+    )
+    sub_network_cap = autils.wait_for_network(
+        ad=resp_dut,
+        request_network_cb_handler=resp_network_cb_handler,
+        expected_channel=None,
+    )
+    # To get ipv6 ip address.
+    resp_ipv6 = pub_network_cap.data[constants.NetworkCbName.NET_CAP_IPV6]
+    init_ipv6 = sub_network_cap.data[constants.NetworkCbName.NET_CAP_IPV6]
+
+    pub_network_link = autils.wait_for_link(
+        ad=init_dut,
+        request_network_cb_handler=init_network_cb_handler,
+    )
+    init_aware_if = pub_network_link.data[
+        constants.NetworkCbEventKey.NETWORK_INTERFACE_NAME
+    ]
+    sub_network_link = autils.wait_for_link(
+        ad=resp_dut,
+        request_network_cb_handler=resp_network_cb_handler,
+    )
+    resp_aware_if = sub_network_link.data[
+        constants.NetworkCbEventKey.NETWORK_INTERFACE_NAME
+    ]
+
+    init_dut.log.info('interfaceName = %s, ipv6=%s', init_aware_if, init_ipv6)
+    resp_dut.log.info('interfaceName = %s, ipv6=%s', resp_aware_if, resp_ipv6)
+    return (init_network_cb_handler, resp_network_cb_handler,
+            init_aware_if, resp_aware_if,
+            init_ipv6, resp_ipv6)
+
+  def create_oob_ndp(
+      self,
+      init_dut: android_device.AndroidDevice,
+      resp_dut: android_device.AndroidDevice):
+    """Create an NDP (using OOB discovery).
+
+    Args:
+      init_dut: Initiator device
+      resp_dut: Responder device
+    Returns:
+      A tuple containing the following:
+        - Initiator network request
+        - Responder network request
+        - Initiator Aware data interface
+        - Responder Aware data interface
+        - Initiator IPv6 address
+        - Responder IPv6 address
+    """
+    init_dut.pretty_name = 'Initiator'
+    resp_dut.pretty_name = 'Responder'
+
+    # Initiator+Responder: attach and wait for confirmation & identity.
+    init_id, init_mac = autils.start_attach(init_dut)
+    time.sleep(self.device_startup_offset)
+    resp_id, resp_mac = autils.start_attach(resp_dut)
+
+    # Wait for devices to synchronize with each other - there are no other
+    # mechanisms to make sure this happens for OOB discovery (except retrying
+    # to execute the data-path request).
+    time.sleep(_WAIT_FOR_CLUSTER)
+    return self.create_oob_ndp_on_sessions(init_dut, resp_dut, init_id,
+                                           init_mac, resp_id, resp_mac)
+
+  def test_ping6_oob(self):
+    """Validate that ping6 works correctly on an NDP created using OOB (out-of-band) discovery."""
+    init_dut = self.ads[0]
+    resp_dut = self.ads[1]
+
+    # Create NDP.
+    (
+        init_network_cb,
+        resp_network_cb,
+        init_aware_if,
+        resp_aware_if,
+        init_ipv6,
+        resp_ipv6,
+    ) = self.create_oob_ndp(init_dut, resp_dut)
+    init_dut.log.info(
+        'Interface names: I=%s, R=%s', init_aware_if, resp_aware_if
+    )
+    resp_dut.log.info(
+        'Interface addresses (IPv6): I=%s, R=%s', init_ipv6, resp_ipv6
+    )
+
+    # Run ping6 command.
+    autils.run_ping6(init_dut, resp_ipv6)
+    time.sleep(3)
+    autils.run_ping6(resp_dut, init_ipv6)
+    time.sleep(3)
+
+    # Clean-up.
+    init_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+        init_network_cb.callback_id
+    )
+    resp_dut.wifi_aware_snippet.connectivityUnregisterNetwork(
+        resp_network_cb.callback_id
+    )
+    init_dut.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+    resp_dut.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+
+
+if __name__ == '__main__':
+  # Take test args.
+  if '--' in sys.argv:
+    index = sys.argv.index('--')
+    sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+  test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/aware/integration/wifi_rtt_disable_test.py b/tests/hostsidetests/multidevices/test/aware/integration/wifi_rtt_disable_test.py
new file mode 100644
index 0000000000..d87de30410
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/integration/wifi_rtt_disable_test.py
@@ -0,0 +1,375 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Wi-Fi Aware Rtt Disable test reimplemented in Mobly."""
+import functools
+import logging
+import signal
+import sys
+import time
+
+from aware import aware_lib_utils as autils
+from aware import constants
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+from mobly.snippet import errors
+
+RUNTIME_PERMISSIONS = (
+    'android.permission.ACCESS_FINE_LOCATION',
+    'android.permission.ACCESS_COARSE_LOCATION',
+    'android.permission.NEARBY_WIFI_DEVICES',
+)
+PACKAGE_NAME = constants.WIFI_AWARE_SNIPPET_PACKAGE_NAME
+
+# Alias variable.
+_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
+_CALLBACK_NAME = constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
+
+######################################################
+# status codes
+######################################################
+_RANGING_FAIL_CODE_GENERIC = 1
+_RANGING_FAIL_CODE_RTT_NOT_AVAILABLE = 2
+
+
+# Timeout decorator block
+class TimeoutError(Exception):
+  """Exception for timeout decorator related errors."""
+
+
+def _timeout_handler():
+  """Handler function used by signal to terminate a timed out function."""
+  raise TimeoutError()
+
+
+def timeout(sec):
+  """A decorator used to add time out check to a function.
+
+  This only works in main thread due to its dependency on signal module.
+  Do NOT use it if the decorated function does not run in the Main thread.
+
+  Args:
+      sec: Number of seconds to wait before the function times out. No timeout
+        if set to 0
+
+  Returns:
+      What the decorated function returns.
+
+  Raises:
+      TimeoutError is raised when time out happens.
+  """
+
+  def decorator(func):
+
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+      if sec:
+        signal.signal(signal.SIGALRM, _timeout_handler)
+        signal.alarm(sec)
+      try:
+        return func(*args, **kwargs)
+      except TimeoutError as exc:
+        raise TimeoutError(
+            ('Function {} timed out after {} seconds.').format(
+                func.__name__, sec
+            )
+        ) from exc
+      finally:
+        signal.alarm(0)
+
+    return wrapper
+
+  return decorator
+
+
+class RttDisableTest(base_test.BaseTestClass):
+  """Test class for RTT ranging enable/disable flows."""
+
+  MODE_DISABLE_WIFI = 0
+  MODE_DISABLE_LOCATIONING = 1
+
+  ads: list[android_device.AndroidDevice]
+
+  def setup_class(self):
+    self.ads = self.register_controller(android_device, min_number=1)
+
+    def setup_device(device: android_device.AndroidDevice):
+      autils.control_wifi(device, True)
+      device.load_snippet('wifi_aware_snippet', PACKAGE_NAME)
+      for permission in RUNTIME_PERMISSIONS:
+        device.adb.shell(['pm', 'grant', PACKAGE_NAME, permission])
+      asserts.abort_all_if(
+          not device.wifi_aware_snippet.wifiAwareIsAvailable(),
+          f'{device} Wi-Fi Aware is not available.',
+      )
+
+    # Set up devices in parallel.
+    utils.concurrent_exec(
+        setup_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+
+  def setup_test(self):
+    for ad in self.ads:
+      autils.control_wifi(ad, True)
+      self.set_location_service(ad, True)
+      aware_avail = ad.wifi_aware_snippet.wifiAwareIsAvailable()
+      if not aware_avail:
+        ad.log.info('Aware not available. Waiting ...')
+        state_handler = ad.wifi_aware_snippet.wifiAwareMonitorStateChange()
+        state_handler.waitAndGet(
+            constants.WifiAwareBroadcast.WIFI_AWARE_AVAILABLE
+        )
+
+  def teardown_test(self):
+    utils.concurrent_exec(
+        self._teardown_test_on_device,
+        param_list=[[ad] for ad in self.ads],
+        max_workers=1,
+        raise_on_exception=True,
+    )
+    utils.concurrent_exec(
+        lambda d: d.services.create_output_excerpts_all(self.current_test_info),
+        param_list=[[ad] for ad in self.ads],
+        raise_on_exception=True,
+    )
+
+  def _teardown_test_on_device(self, ad: android_device.AndroidDevice) -> None:
+    ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
+    ad.wifi_aware_snippet.wifiAwareMonitorStopStateChange()
+    # autils.control_wifi(ad, True)
+
+  def on_fail(self, record: records.TestResult) -> None:
+    android_device.take_bug_reports(
+        self.ads, destination=self.current_test_info.output_path
+    )
+
+  def scan_networks(
+      self, dut: android_device.AndroidDevice, max_tries: int = 3
+  ) -> list[dict[str, str]]:
+    """Perform a scan and return scan results.
+
+    Args:
+        dut: Device under test.
+        max_tries: Retry scan to ensure network is found
+
+    Returns:
+        an array of scan results.
+    """
+    scan_results = []
+    for _ in range(max_tries):
+        scan_results = dut.wifi_aware_snippet.wifiScanAndGetResults()
+        if scan_results:
+            break
+
+    return scan_results
+
+  def select_best_scan_results(
+      self,
+      scans: list[dict[str, str]],
+      select_count: int,
+      lowest_rssi: int = -80,
+  ):
+    """Select best result based on RSSI.
+
+    Select the strongest 'select_count' scans in the input list based on
+    highest RSSI. Exclude all very weak signals, even if results in a shorter
+    list.
+
+    Args:
+        scans: List of scan results.
+        select_count: An integer specifying how many scans to return at most.
+        lowest_rssi: The lowest RSSI to accept into the output.
+
+    Returns:
+           a list of the strongest 'select_count' scan results from the scans
+           list.
+    """
+
+    def _take_rssi(element):
+      return element['level']
+
+    result = []
+    scans.sort(key=_take_rssi, reverse=True)
+    for scan in scans:
+      logging.info(
+          'scan type: %s, %s, %s', scan['SSID'], scan['level'], scan['BSSID']
+      )
+      if len(result) == select_count:
+        break
+      if scan['level'] < lowest_rssi:
+        break  # rest are lower since we're sorted
+      result.append(scan)
+
+    return result
+
+  def set_location_service(self, ad, new_state):
+    """Set Location service on/off in Settings->Location.
+
+    Args:
+        ad: android device object.
+        new_state: new state for "Location service".
+            If new_state is False, turn off location service.
+            If new_state if True, set location service to "High accuracy".
+    """
+    ad.adb.shell('content insert --uri '
+                 ' content://com.google.settings/partner --bind '
+                 'name:s:network_location_opt_in --bind value:s:1')
+    ad.adb.shell('content insert --uri '
+                 ' content://com.google.settings/partner --bind '
+                 'name:s:use_location_for_services --bind value:s:1')
+    if new_state:
+        ad.adb.shell('settings put secure location_mode 3')
+    else:
+        ad.adb.shell('settings put secure location_mode 0')
+
+  def force_airplane_mode(self, ad, new_state, timeout_value=60):
+    """Force the device to set airplane mode on or off by adb shell command.
+
+    Args:
+        ad: android device object.
+        new_state: Turn on airplane mode if True.
+            Turn off airplane mode if False.
+        timeout_value: max wait time for 'adb wait-for-device'
+
+    Returns:
+        True if success.
+        False if timeout.
+    """
+
+    # Using timeout decorator.
+    # Wait for device with timeout. If after <timeout_value> seconds, adb
+    # is still waiting for device, throw TimeoutError exception.
+    @timeout(timeout_value)
+    def wait_for_device_with_timeout(ad):
+        ad.adb.wait_for_device()
+
+    try:
+        wait_for_device_with_timeout(ad)
+        ad.adb.shell('settings put global airplane_mode_on {}'.format(
+            1 if new_state else 0))
+        ad.adb.shell('am broadcast -a android.intent.action.AIRPLANE_MODE')
+    except TimeoutError:
+        # adb wait for device timeout
+        return False
+    return True
+
+  def run_disable_rtt(self, disable_mode):
+    """Validate the RTT ranging feature if RTT disabled.
+
+    Validate the RTT disabled flows: whether by disabling Wi-Fi or entering
+    doze mode.
+
+    Args:
+      disable_mode: The particular mechanism in which RTT is disabled. One of
+        the MODE_* constants.
+    """
+    dut = self.ads[0]
+
+    # validate start-up conditions
+    asserts.assert_true(
+        dut.wifi_aware_snippet.wifiRttIsAvailable(), 'RTT is not available'
+    )
+
+    # scan to get some APs to be used later
+    all_aps = self.select_best_scan_results(
+        self.scan_networks(dut), select_count=1
+    )
+    asserts.assert_true(all_aps, 'Need at least one visible AP!')
+
+    # disable RTT and validate broadcast & API
+    if disable_mode == self.MODE_DISABLE_WIFI:
+      # disabling Wi-Fi is not sufficient: since scan mode (and hence RTT) will
+      # remain enabled - we need to disable the Wi-Fi chip aka Airplane Mode
+      asserts.assert_true(
+          self.force_airplane_mode(dut, True),
+          'Can not turn on airplane mode on: %s' % dut.serial,
+      )
+      autils.control_wifi(dut, False)
+    elif disable_mode == self.MODE_DISABLE_LOCATIONING:
+      self.set_location_service(dut, False)
+    time.sleep(10)
+    dut.log.info(
+        'WiFi RTT status: %s', dut.wifi_aware_snippet.wifiRttIsAvailable()
+    )
+    asserts.assert_false(
+        dut.wifi_aware_snippet.wifiRttIsAvailable(), 'RTT is available'
+    )
+
+    # request a range and validate error
+    dut.log.info('access points input: %s', all_aps[0:1])
+    ranging_cb_handler = (
+        dut.wifi_aware_snippet.wifiRttStartRangingToAccessPoints(all_aps[0:1])
+    )
+    event = ranging_cb_handler.waitAndGet(
+        event_name=constants.RangingResultCb.EVENT_NAME_ON_RANGING_RESULT,
+        timeout=_DEFAULT_TIMEOUT,
+    )
+
+    callback_name = event.data.get(
+        constants.RangingResultCb.DATA_KEY_CALLBACK_NAME, None
+    )
+    dut.log.info('StartRangingToAccessPoints callback = %s', callback_name)
+    asserts.assert_equal(
+        callback_name,
+        constants.RangingResultCb.CB_METHOD_ON_RANGING_FAILURE,
+        'Should be ranging failed.',
+    )
+    status_code = event.data.get(
+        constants.RangingResultCb.DATA_KEY_RESULT_STATUS, None
+    )
+    dut.log.info('StartRangingToAccessPoints status code = %s', status_code)
+    asserts.assert_equal(
+        status_code, _RANGING_FAIL_CODE_RTT_NOT_AVAILABLE, 'Invalid error code'
+    )
+
+    # enable RTT and validate broadcast & API
+    if disable_mode == self.MODE_DISABLE_WIFI:
+      asserts.assert_true(
+          self.force_airplane_mode(dut, False),
+          'Can not turn off airplane mode on: %s' % dut.serial,
+      )
+      autils.control_wifi(dut, True)
+    elif disable_mode == self.MODE_DISABLE_LOCATIONING:
+      self.set_location_service(dut, True)
+
+    asserts.assert_true(
+        dut.wifi_aware_snippet.wifiRttIsAvailable(), 'RTT is not available'
+    )
+
+  def test_disable_wifi(self):
+    """Validate that getting expected broadcast when Wi-Fi is disabled and that any range requests are rejected.
+    """
+    self.run_disable_rtt(self.MODE_DISABLE_WIFI)
+
+  def test_disable_location(self):
+    """Validate that getting expected broadcast when locationing is disabled and that any range requests are rejected.
+    """
+    self.run_disable_rtt(self.MODE_DISABLE_LOCATIONING)
+
+
+if __name__ == '__main__':
+  # Take test args
+  if '--' in sys.argv:
+    index = sys.argv.index('--')
+    sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+  test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/aware/wifi_aware_discovery_ranging_test.py b/tests/hostsidetests/multidevices/test/aware/wifi_aware_discovery_ranging_test.py
new file mode 100644
index 0000000000..6951f36e5b
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/wifi_aware_discovery_ranging_test.py
@@ -0,0 +1,401 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+"""Wi-Fi Aware discovery ranging test module."""
+
+import logging
+import sys
+import time
+
+from android.platform.test.annotations import ApiTest
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+import wifi_test_utils
+
+from aware import aware_snippet_utils
+from aware import constants
+
+
+_SNIPPET_PACKAGE_NAME = constants.WIFI_SNIPPET_PACKAGE_NAME
+_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
+_MSG_SUB_TO_PUB = "Let's talk [Random Identifier: {random_id}]"
+_MSG_PUB_TO_SUB = 'Ready [Random Identifier: %s]'
+_LARGE_ENOUGH_DISTANCE_MM = 100000  # 100 meters
+_MIN_RSSI = -100
+_WAIT_SEC_FOR_RTT_INITIATOR_RESPONDER_SWITCH = 5
+
+
+@ApiTest(
+    apis=[
+        'android.net.wifi.rtt.RangingRequest.Builder#addWifiAwarePeer(android.net.wifi.aware.PeerHandle)',
+        'android.net.wifi.aware.PublishConfig.Builder#setRangingEnabled(boolean)',
+        'android.net.wifi.aware.SubscribeConfig.Builder#setMaxDistanceMm(int)',
+        'android.net.wifi.rtt.WifiRttManager#startRanging(android.net.wifi.rtt.RangingRequest, java.util.concurrent.Executor, android.net.wifi.rtt.RangingResultCallback)',
+        'android.net.wifi.aware.WifiAwareManager#attach(android.net.wifi.aware.AttachCallback, android.net.wifi.aware.IdentityChangedListener, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#publish(android.net.wifi.aware.PublishConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+        'android.net.wifi.aware.WifiAwareSession#subscrible(android.net.wifi.aware.SubscribeConfig, android.net.wifi.aware.DiscoverySessionCallback, android.os.Handler)',
+    ]
+)
+class WifiAwareDiscoveryRangingTest(base_test.BaseTestClass):
+    """Wi-Fi Aware discovery ranging test class.
+
+    All tests in this class share the same test steps and expected results.
+    The difference is that different tests perform ranging with different
+    configurations.
+
+    Test Preconditions:
+        * Two Android devices that support Wi-Fi Aware and Wi-Fi RTT.
+        * The devices should be placed ~20cm apart.
+
+    Test Steps:
+        1. Attach a Wi-Fi Aware session on each device.
+        2. Publisher publishes an Wi-Fi Aware service, subscriber subscribes
+           to it. Wait for service discovery.
+        3. Send messages through discovery session's API.
+        4. Perform ranging on one device to another device through Wi-Fi Aware.
+           Perform this step on the publisher and subscriber, respectively.
+
+    Expected Results:
+        Discovery ranging succeeds. In ranging result, the device that
+        performs ranging discovers the expected peer device, with a valid
+        distance and RSSI value.
+    """
+
+    ads: list[android_device.AndroidDevice]
+    publisher: android_device.AndroidDevice
+    subscriber: android_device.AndroidDevice
+
+    # Wi-Fi Aware attach session ID
+    pub_attach_session: str | None = None
+    sub_attach_session: str | None = None
+    # Wi-Fi Aware discovery session ID
+    pub_session: str | None = None
+    sub_session: str | None = None
+
+    def setup_class(self):
+        # Register and set up Android devices in parallel.
+        self.ads = self.register_controller(android_device, min_number=2)
+        self.publisher = self.ads[0]
+        self.subscriber = self.ads[1]
+
+        # Device setup
+        utils.concurrent_exec(
+            self._setup_device,
+            ((self.publisher,), (self.subscriber,)),
+            max_workers=2,
+            raise_on_exception=True,
+        )
+
+        # Device capability check
+        for device in [self.publisher, self.subscriber]:
+            asserts.abort_class_if(
+                not device.wifi.wifiAwareIsSupported(),
+                f'{device} does not support Wi-Fi Aware.',
+            )
+            asserts.abort_class_if(
+                not device.wifi.wifiAwareIsAvailable(),
+                f'Wi-Fi Aware is not available on {device}.',
+            )
+            asserts.abort_class_if(
+                not device.wifi.wifiAwareIsRttSupported(),
+                f'{device} does not support Wi-Fi RTT.',
+            )
+
+    def _setup_device(self, device: android_device.AndroidDevice):
+        device.load_snippet('wifi', _SNIPPET_PACKAGE_NAME)
+        device.wifi.wifiEnable()
+        wifi_test_utils.set_screen_on_and_unlock(device)
+        wifi_test_utils.enable_wifi_verbose_logging(device)
+
+    def test_discovery_ranging_to_peer_handle(self) -> None:
+        """Test ranging to a Wi-Fi Aware peer handle.
+
+        See class docstring for the test steps and expected results.
+        """
+        pub_config = constants.PublishConfig(
+            publish_type=constants.PublishType.UNSOLICITED,
+            ranging_enabled=True,
+        )
+        sub_config = constants.SubscribeConfig(
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        )
+
+        # Step 1 - 3: Set up Wi-Fi Aware discovery sessions, so it is ready
+        # for ranging.
+        _, _, pub_peer, sub_peer = self._setup_discovery_sessions(
+            pub_config=pub_config,
+            sub_config=sub_config,
+        )
+
+        # Step 4: Perform ranging on the publisher and subscriber, respectively.
+        self.publisher.log.info('Performing ranging to peer ID %d.', pub_peer)
+        self._perform_ranging(
+            self.publisher,
+            constants.RangingRequest(peer_ids=[pub_peer]),
+        )
+
+        # RTT initiator/responder role switch takes time. We don't have an
+        # API to enforce it. So wait a few seconds for a semi-arbitrary
+        # teardown.
+        time.sleep(_WAIT_SEC_FOR_RTT_INITIATOR_RESPONDER_SWITCH)
+        self.subscriber.log.info('Performing ranging to peer ID %d.', sub_peer)
+        self._perform_ranging(
+            self.subscriber,
+            constants.RangingRequest(peer_ids=[sub_peer]),
+        )
+
+        # Test finished, clean up.
+        self.publisher.wifi.wifiAwareCloseDiscoverSession(self.pub_session)
+        self.subscriber.wifi.wifiAwareCloseDiscoverSession(self.sub_session)
+        self.publisher.wifi.wifiAwareDetach(self.pub_attach_session)
+        self.subscriber.wifi.wifiAwareDetach(self.sub_attach_session)
+
+    def test_discovery_ranging_to_peer_mac_address(self) -> None:
+        """Test ranging to a Wi-Fi Aware peer MAC address.
+
+        See class docstring for the test steps and expected results.
+        """
+        pub_config = constants.PublishConfig(
+            publish_type=constants.PublishType.UNSOLICITED,
+            ranging_enabled=True,
+        )
+        sub_config = constants.SubscribeConfig(
+            subscribe_type=constants.SubscribeType.PASSIVE,
+            max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
+        )
+
+        # Step 1 - 3: Set up Wi-Fi Aware discovery sessions, so it is ready
+        # for ranging.
+        pub_mac_address, sub_mac_address, _, _ = self._setup_discovery_sessions(
+            pub_config=pub_config,
+            sub_config=sub_config,
+        )
+
+        # Step 4: Perform ranging on the publisher and subscriber, respectively.
+        self.publisher.log.info(
+            'Performing ranging to peer MAC address %s.', sub_mac_address
+        )
+        self._perform_ranging(
+            self.publisher,
+            constants.RangingRequest(peer_mac_addresses=[sub_mac_address]),
+        )
+
+        # RTT initiator/responder role switch takes time. We don't have an
+        # API to enforce it. So wait a few seconds for a semi-arbitrary
+        # teardown.
+        time.sleep(_WAIT_SEC_FOR_RTT_INITIATOR_RESPONDER_SWITCH)
+        self.subscriber.log.info(
+            'Performing ranging to peer MAC address %s.', pub_mac_address
+        )
+        self._perform_ranging(
+            self.subscriber,
+            constants.RangingRequest(peer_mac_addresses=[pub_mac_address]),
+        )
+
+        # Test finished, clean up.
+        self.publisher.wifi.wifiAwareCloseDiscoverSession(self.pub_session)
+        self.subscriber.wifi.wifiAwareCloseDiscoverSession(self.sub_session)
+        self.publisher.wifi.wifiAwareDetach(self.pub_attach_session)
+        self.subscriber.wifi.wifiAwareDetach(self.sub_attach_session)
+
+    def _setup_discovery_sessions(
+        self,
+        pub_config: constants.PublishConfig,
+        sub_config: constants.SubscribeConfig,
+    ) -> tuple[str, str, int, int]:
+        """Sets up Wi-Fi Aware discovery sessions.
+
+        Args:
+            pub_config: The publish configuration.
+            sub_config: The subscribe configuration.
+
+        Returns:
+            A tuple of (publisher MAC address, subscriber MAC address,
+            publisher peer ID, subscriber peer ID).
+        """
+        # Step 1: Attach Wi-Fi Aware sessions.
+        self.pub_attach_session, pub_mac_address = (
+            aware_snippet_utils.start_attach(
+                self.publisher, pub_config.ranging_enabled
+            )
+        )
+        self.sub_attach_session, sub_mac_address = (
+            aware_snippet_utils.start_attach(
+                self.subscriber, pub_config.ranging_enabled
+            )
+        )
+
+        # Step 2: Publisher publishes an Wi-Fi Aware service, subscriber
+        # subscribes to it. Wait for service discovery.
+        (
+            self.pub_session,
+            pub_session_handler,
+            self.sub_session,
+            sub_session_handler,
+            sub_peer,
+        ) = aware_snippet_utils.publish_and_subscribe(
+            publisher=self.publisher,
+            pub_config=pub_config,
+            pub_attach_session=self.pub_attach_session,
+            subscriber=self.subscriber,
+            sub_config=sub_config,
+            sub_attach_session=self.sub_attach_session,
+        )
+
+        # Step 3: Send messages through the discovery sessions.
+        msg = _MSG_SUB_TO_PUB.format(random_id=utils.rand_ascii_str(5))
+        pub_peer = aware_snippet_utils.send_msg_through_discovery_session(
+            sender=self.subscriber,
+            sender_discovery_session_handler=sub_session_handler,
+            receiver=self.publisher,
+            receiver_discovery_session_handler=pub_session_handler,
+            discovery_session=self.sub_session,
+            peer_on_sender=sub_peer,
+            send_message=msg,
+        )
+        self.subscriber.log.info(
+            'Sent a message to peer %d through discovery session.',
+            sub_peer,
+        )
+        msg = _MSG_PUB_TO_SUB.format(random_id=utils.rand_ascii_str(5))
+        aware_snippet_utils.send_msg_through_discovery_session(
+            sender=self.publisher,
+            sender_discovery_session_handler=pub_session_handler,
+            receiver=self.subscriber,
+            receiver_discovery_session_handler=sub_session_handler,
+            discovery_session=self.pub_session,
+            peer_on_sender=pub_peer,
+            send_message=msg,
+        )
+        self.publisher.log.info(
+            'Sent a message to peer %d through discovery session.',
+            pub_peer,
+        )
+        return (pub_mac_address, sub_mac_address, pub_peer, sub_peer)
+
+    def _perform_ranging(
+        self,
+        ad: android_device.AndroidDevice,
+        request: constants.RangingRequest,
+    ):
+        """Performs ranging and checks the ranging result.
+
+        Args:
+            ad: The Android device controller.
+            request: The ranging request.
+        """
+        ad.log.debug('Starting ranging with request: %s', request)
+        ranging_cb_handler = ad.wifi.wifiAwareStartRanging(request.to_dict())
+        event = ranging_cb_handler.waitAndGet(
+            event_name=constants.RangingResultCb.EVENT_NAME_ON_RANGING_RESULT,
+            timeout=_DEFAULT_TIMEOUT,
+        )
+
+        callback_name = event.data.get(
+            constants.RangingResultCb.DATA_KEY_CALLBACK_NAME, None
+        )
+        asserts.assert_equal(
+            callback_name,
+            constants.RangingResultCb.CB_METHOD_ON_RANGING_RESULT,
+            'Ranging failed: got unexpected callback.',
+        )
+
+        results = event.data.get(
+            constants.RangingResultCb.DATA_KEY_RESULTS, None
+        )
+        asserts.assert_true(
+            results is not None and len(results) == 1,
+            'Ranging got invalid results: null, empty, or wrong length.',
+        )
+
+        status_code = results[0].get(
+            constants.RangingResultCb.DATA_KEY_RESULT_STATUS, None
+        )
+        asserts.assert_equal(
+            status_code,
+            constants.RangingResultStatusCode.SUCCESS,
+            'Ranging peer failed: invalid result status code.',
+        )
+
+        distance_mm = results[0].get(
+            constants.RangingResultCb.DATA_KEY_RESULT_DISTANCE_MM, None
+        )
+        asserts.assert_true(
+            (
+                distance_mm is not None
+                and distance_mm <= _LARGE_ENOUGH_DISTANCE_MM
+            ),
+            'Ranging peer failed: invalid distance in ranging result.',
+        )
+        rssi = results[0].get(
+            constants.RangingResultCb.DATA_KEY_RESULT_RSSI, None
+        )
+        asserts.assert_true(
+            rssi is not None and rssi >= _MIN_RSSI,
+            'Ranging peer failed: invalid rssi in ranging result.',
+        )
+
+        peer_id = results[0].get(
+            constants.RangingResultCb.DATA_KEY_PEER_ID, None
+        )
+        if peer_id is not None:
+            msg = 'Ranging peer failed: invalid peer ID in ranging result.'
+            asserts.assert_in(peer_id, request.peer_ids, msg)
+
+        peer_mac = results[0].get(constants.RangingResultCb.DATA_KEY_MAC, None)
+        if peer_mac is not None:
+            msg = (
+                'Ranging peer failed: invalid peer MAC address in ranging '
+                'result.'
+            )
+            asserts.assert_in(peer_mac, request.peer_mac_addresses, msg)
+
+    def teardown_test(self):
+        utils.concurrent_exec(
+            self._teardown_on_device,
+            ((self.publisher,), (self.subscriber,)),
+            max_workers=2,
+            raise_on_exception=True,
+        )
+        self.pub_session = None
+        self.sub_session = None
+        self.pub_attach_session = None
+        self.sub_attach_session = None
+
+    def _teardown_on_device(self, ad: android_device.AndroidDevice) -> None:
+        """Releases resources and sessions after each test."""
+        try:
+            ad.wifi.connectivityReleaseAllSockets()
+            ad.wifi.wifiAwareCloseAllWifiAwareSession()
+        finally:
+            ad.services.create_output_excerpts_all(self.current_test_info)
+
+    def on_fail(self, record: records.TestResult) -> None:
+        logging.info('Collecting bugreports...')
+        android_device.take_bug_reports(
+            self.ads, destination=self.current_test_info.output_path
+        )
+
+
+if __name__ == '__main__':
+    # Take test args
+    if '--' in sys.argv:
+        index = sys.argv.index('--')
+        sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+    test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/aware/wifi_aware_manager_test.py b/tests/hostsidetests/multidevices/test/aware/wifi_aware_manager_test.py
deleted file mode 100644
index e6c24cce2e..0000000000
--- a/tests/hostsidetests/multidevices/test/aware/wifi_aware_manager_test.py
+++ /dev/null
@@ -1,1218 +0,0 @@
-#  Copyright (C) 2024 The Android Open Source Project
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#       http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-
-# Lint as: python3
-"""CTS-V Wi-Fi Aware test reimplemented in Mobly."""
-import datetime
-import enum
-import logging
-import random
-import sys
-import time
-from typing import Tuple, Any
-
-from mobly import asserts
-from mobly import base_test
-from mobly import records
-from mobly import test_runner
-from mobly import utils
-from mobly.controllers import android_device
-from mobly.controllers.android_device_lib import callback_handler_v2
-from mobly.snippet import callback_event
-import wifi_test_utils
-
-from aware import constants
-from aware import aware_lib_utils
-
-PACKAGE_NAME = constants.WIFI_SNIPPET_PACKAGE_NAME
-_DEFAULT_TIMEOUT = constants.WAIT_WIFI_STATE_TIME_OUT.total_seconds()
-_REQUEST_NETWORK_TIMEOUT_MS = 15 * 1000
-_MSG_ID_SUB_TO_PUB = random.randint(1000, 5000)
-_MSG_ID_PUB_TO_SUB = random.randint(5001, 9999)
-_MSG_SUB_TO_PUB = "Let's talk [Random Identifier: %s]" % utils.rand_ascii_str(5)
-_MSG_PUB_TO_SUB = 'Ready [Random Identifier: %s]' % utils.rand_ascii_str(5)
-_PUB_SSI = constants.WifiAwareTestConstants.PUB_SSI
-_MATCH_FILTER = [constants.WifiAwareTestConstants.MATCH_FILTER_BYTES]
-_CALLBACK_NAME = constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
-_IS_SESSION_INIT = constants.DiscoverySessionCallbackParamsType.IS_SESSION_INIT
-_TRANSPORT_TYPE_WIFI_AWARE = (
-    constants.NetworkCapabilities.Transport.TRANSPORT_WIFI_AWARE
-)
-_LARGE_ENOUGH_DISTANCE_MM = 100000  # 100 meters
-_MIN_RSSI = -100
-_WAIT_SEC_FOR_RTT_INITIATOR_RESPONDER_SWITCH = 5
-
-
-@enum.unique
-class AttachCallBackMethodType(enum.StrEnum):
-    """Represents Attach Callback Method Type in Wi-Fi Aware.
-
-    https://developer.android.com/reference/android/net/wifi/aware/AttachCallback
-    """
-    ATTACHED = 'onAttached'
-    ATTACH_FAILED = 'onAttachFailed'
-    AWARE_SESSION_TERMINATED = 'onAwareSessionTerminated'
-
-
-class WifiAwareManagerTest(base_test.BaseTestClass):
-    """Wi-Fi Aware test class."""
-
-    ads: list[android_device.AndroidDevice]
-    publisher: android_device.AndroidDevice
-    subscriber: android_device.AndroidDevice
-
-    # Wi-Fi Aware attach session ID
-    publisher_attach_session: str | None = None
-    subscriber_attach_session: str | None = None
-    # Wi-Fi Aware discovery session ID
-    publish_session: str | None = None
-    subscribe_session: str | None = None
-    # Wi-Fi Aware peer ID
-    publisher_peer: int | None = None
-    subscriber_peer: int | None = None
-    # Mac addresses.
-    publisher_mac: str | None = None
-    subscriber_mac: str | None = None
-
-    def setup_class(self):
-        # Register and set up Android devices in parallel.
-        self.ads = self.register_controller(android_device, min_number=2)
-        self.publisher = self.ads[0]
-        self.subscriber = self.ads[1]
-
-        def setup_device(device: android_device.AndroidDevice):
-            device.load_snippet(
-                'wifi_aware_snippet', PACKAGE_NAME
-            )
-            aware_lib_utils.control_wifi(device, wifi_state=True)
-            asserts.abort_all_if(
-                not device.wifi_aware_snippet.wifiAwareIsSupported(),
-                f'{device} does not support Wi-Fi Aware.',
-            )
-            wifi_test_utils.set_screen_on_and_unlock(device)
-            asserts.abort_all_if(
-                not device.wifi_aware_snippet.wifiAwareIsAvailable(),
-                f'{device} Wi-Fi Aware is not available.',
-            )
-
-        utils.concurrent_exec(
-            setup_device,
-            ((self.publisher,), (self.subscriber,)),
-            max_workers=2,
-            raise_on_exception=True,
-        )
-
-    def test_data_path_open_unsolicited_pub_and_passive_sub(self) -> None:
-        """Test OPEN Wi-Fi Aware network with unsolicited publish and passive subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.UNSOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.PASSIVE,
-            ),
-        )
-
-    def test_data_path_passphrase_unsolicited_pub_and_passive_sub(self) -> None:
-        """Test Wi-Fi Aware network with passphrase, unsolicited publish, and passive subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.UNSOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.PASSIVE,
-            ),
-            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
-                psk_passphrase=constants.WifiAwareTestConstants.PASSWORD,
-                transport_protocol=constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP,
-            ),
-            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
-                psk_passphrase=constants.WifiAwareTestConstants.PASSWORD,
-            )
-        )
-
-    def test_data_path_pmk_unsolicited_pub_and_passive_sub(self) -> None:
-        """Test Wi-Fi Aware network using PMK with unsolicited publish and passive subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.UNSOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.PASSIVE,
-            ),
-            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
-                transport_protocol=constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP,
-                pmk=constants.WifiAwareTestConstants.PMK,
-            ),
-            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
-                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
-                    pmk=constants.WifiAwareTestConstants.PMK
-                )
-            )
-        )
-
-    def test_data_path_open_solicited_pub_and_active_sub(self) -> None:
-        """Test OPEN Wi-Fi Aware network with solicited publish and active subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.SOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.ACTIVE,
-            ),
-
-        )
-
-    def test_data_path_passphrase_solicited_pub_and_active_sub(self) -> None:
-        """Test password-protected Wi-Fi Aware network with solicited publish and active subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.SOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.ACTIVE,
-            ),
-            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
-                psk_passphrase=constants.WifiAwareTestConstants.PASSWORD,
-                transport_protocol=constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP,
-            ),
-            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
-                psk_passphrase=constants.WifiAwareTestConstants.PASSWORD,
-            )
-        )
-
-    def test_data_path_pmk_solicited_pub_and_active_sub(self) -> None:
-        """Test Wi-Fi Aware network using PMK with solicited publish and active subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.SOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.ACTIVE,
-            ),
-            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
-                transport_protocol=constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP,
-                pmk=constants.WifiAwareTestConstants.PMK,
-            ),
-            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
-                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
-                    pmk=constants.WifiAwareTestConstants.PMK
-                )
-            )
-        )
-
-    def test_data_path_open_unsolicited_pub_accept_any_and_passive_sub(self) -> None:
-        """Test OPEN Wi-Fi Aware with unsolicited publish (accept any peer) and passive subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.UNSOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.PASSIVE,
-            ),
-            is_pub_accept_any_peer=True,
-        )
-
-    def test_data_path_passphrase_unsolicited_pub_accept_any_and_passive_sub(self) -> None:
-        """Test Wi-Fi Aware with passphrase unsolicited publish (accept any), and passive subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.UNSOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.PASSIVE,
-            ),
-            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
-                psk_passphrase=constants.WifiAwareTestConstants.PASSWORD,
-                transport_protocol=constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP,
-            ),
-            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
-                psk_passphrase=constants.WifiAwareTestConstants.PASSWORD,
-            ),
-            is_pub_accept_any_peer=True,
-        )
-
-    def test_data_path_pmk_unsolicited_pub_accept_any_and_passive_sub(self) -> None:
-        """Test Wi-Fi Aware with PMK, unsolicited publish (accept any), and passive subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.UNSOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.PASSIVE,
-            ),
-            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
-                transport_protocol=constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP,
-                pmk=constants.WifiAwareTestConstants.PMK,
-            ),
-            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
-                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
-                    pmk=constants.WifiAwareTestConstants.PMK
-                )
-            ),
-            is_pub_accept_any_peer=True,
-        )
-
-    def test_data_path_open_solicited_pub_accept_any_active_sub(self) -> None:
-        """Test Wi-Fi Aware with open network, solicited publish (accept any), and active subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.SOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.ACTIVE,
-            ),
-            is_pub_accept_any_peer=True,
-        )
-
-    def test_data_passphrase_solicited_pub_accept_any_and_active_sub(self) -> None:
-        """Test Wi-Fi Aware with passphrase, solicited publish (accept any), and active subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.SOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.ACTIVE,
-            ),
-            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
-                psk_passphrase=constants.WifiAwareTestConstants.PASSWORD,
-                transport_protocol=constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP,
-            ),
-            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
-                psk_passphrase=constants.WifiAwareTestConstants.PASSWORD,
-            ),
-            is_pub_accept_any_peer=True,
-        )
-
-    def test_data_path_pmk_solicited_pub_accept_any_and_active_sub(self) -> None:
-        """Test Wi-Fi Aware with PMK, solicited publish (accept any), and active subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.SOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.ACTIVE,
-            ),
-            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
-                transport_protocol=constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP,
-                pmk=constants.WifiAwareTestConstants.PMK,
-            ),
-            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
-                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
-                    pmk=constants.WifiAwareTestConstants.PMK
-                )
-            ),
-            is_pub_accept_any_peer=True,
-        )
-
-    def test_discovery_ranging_to_peer_handle(self) -> None:
-        """Test ranging to a Wi-Fi Aware peer handle.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Test ranging to Wi-Fi Aware peer handle.
-        """
-        # Check test condition.
-        self._skip_if_wifi_rtt_is_not_supported()
-
-        # Step 1 - 3. Publish and subscribe Wi-Fi Aware service.
-        self._publish_and_subscribe(
-            pub_config=constants.PublishConfig(
-                publish_type=constants.PublishType.UNSOLICITED,
-                ranging_enabled=True,
-            ),
-            sub_config=constants.SubscribeConfig(
-                subscribe_type=constants.SubscribeType.PASSIVE,
-                max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
-            ),
-        )
-
-        # 4. Perform ranging on the publisher and subscriber, respectively.
-        self.publisher.log.info(
-            'Performing ranging to peer ID %d.',  self.publisher_peer
-        )
-        self._perform_ranging(
-            self.publisher,
-            constants.RangingRequest(peer_ids=[self.publisher_peer]),
-        )
-
-        # RTT initiator/responder role switch takes time. We don't have an
-        # API to enforce it. So wait a few seconds for a semi-arbitrary
-        # teardown.
-        time.sleep(_WAIT_SEC_FOR_RTT_INITIATOR_RESPONDER_SWITCH)
-        self.subscriber.log.info(
-            'Performing ranging to peer ID %d.', self.subscriber_peer
-        )
-        self._perform_ranging(
-            self.subscriber,
-            constants.RangingRequest(peer_ids=[self.subscriber_peer]),
-        )
-
-    def test_discovery_ranging_to_peer_mac_address(self) -> None:
-        """Test ranging to a Wi-Fi Aware peer mac address.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Test ranging to Wi-Fi Aware peer mac address.
-        """
-        # Check test condition.
-        self._skip_if_wifi_rtt_is_not_supported()
-
-        # Step 1 - 3. Publish and subscribe Wi-Fi Aware service.
-        self._publish_and_subscribe(
-            pub_config=constants.PublishConfig(
-                publish_type=constants.PublishType.UNSOLICITED,
-                ranging_enabled=True,
-            ),
-            sub_config=constants.SubscribeConfig(
-                subscribe_type=constants.SubscribeType.PASSIVE,
-                max_distance_mm=_LARGE_ENOUGH_DISTANCE_MM,
-            ),
-        )
-
-        # 4. Perform ranging on the publisher and subscriber, respectively.
-        self.publisher.log.info(
-            'Performing ranging to peer MAC address %s.', self.subscriber_mac
-        )
-        self._perform_ranging(
-            self.publisher,
-            constants.RangingRequest(peer_mac_addresses=[self.subscriber_mac]),
-        )
-
-        # RTT initiator/responder role switch takes time. We don't have an
-        # API to enforce it. So wait a few seconds for a semi-arbitrary
-        # teardown.
-        time.sleep(_WAIT_SEC_FOR_RTT_INITIATOR_RESPONDER_SWITCH)
-        self.subscriber.log.info(
-            'Performing ranging to peer MAC address %s.', self.publisher_mac
-        )
-        self._perform_ranging(
-            self.subscriber,
-            constants.RangingRequest(peer_mac_addresses=[self.publisher_mac]),
-        )
-
-    def test_data_path_force_channel_setup(self):
-        """ Test Wi-Fi Aware with PMK, force channel publish, and subscribe.
-
-        Steps:
-        1. Attach a Wi-Fi Aware session on each device.
-        2. Publish and subscribe to a discovery session.
-        3. Send messages through discovery sessions API.
-        4. Request a Wi-Fi Aware network.
-        5. Establish a socket connection and send messages through it.
-        """
-        # The support of this function depends on the chip used.
-        asserts.skip_if(
-            not self.publisher.wifi_aware_snippet.wifiAwareIsSetChannelOnDataPathSupported(),
-            'Publish device not support this test feature.'
-        )
-        asserts.skip_if(
-            not self.subscriber.wifi_aware_snippet.wifiAwareIsSetChannelOnDataPathSupported(),
-            'Subscriber device not support this test feature.'
-        )
-
-        self._test_wifi_aware(
-            pub_config=constants.PublishConfig(
-                service_specific_info=constants.WifiAwareTestConstants.PUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                publish_type=constants.PublishType.UNSOLICITED,
-                ranging_enabled=False,
-            ),
-            sub_config=constants.SubscribeConfig(
-                service_specific_info=constants.WifiAwareTestConstants.SUB_SSI,
-                match_filter=[constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-                subscribe_type=constants.SubscribeType.PASSIVE,
-            ),
-            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
-                transport_protocol=constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP,
-                pmk=constants.WifiAwareTestConstants.PMK,
-                channel_frequency_m_hz=constants.WifiAwareTestConstants.CHANNEL_IN_MHZ,
-            ),
-            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
-                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
-                    pmk=constants.WifiAwareTestConstants.PMK
-                ),
-                channel_frequency_m_hz=constants.WifiAwareTestConstants.CHANNEL_IN_MHZ,
-            )
-        )
-
-    def _test_wifi_aware(
-        self,
-        pub_config: constants.PublishConfig,
-        sub_config: constants.SubscribeConfig,
-        network_specifier_on_pub: constants.WifiAwareNetworkSpecifier | None = None,
-        network_specifier_on_sub: constants.WifiAwareNetworkSpecifier | None = None,
-        is_pub_accept_any_peer: bool = False,
-    ):
-        """Tests Wi-Fi Aware using given publish and subscribe configurations."""
-        # Step 1 - 3: Publish and subscribe Wi-Fi Aware service and send
-        # messages through a Wi-Fi Aware session.
-        self._publish_and_subscribe(pub_config, sub_config)
-
-        # 4. Request a Wi-Fi Aware network.
-        pub_accept_handler = self.publisher.wifi_aware_snippet.connectivityServerSocketAccept()
-        network_id = pub_accept_handler.callback_id
-        pub_local_port = pub_accept_handler.ret_value
-        if network_specifier_on_pub and (
-            network_specifier_on_pub.psk_passphrase or network_specifier_on_pub.pmk):
-            network_specifier_on_pub.port = pub_local_port
-        pub_network_cb_handler = self._request_network(
-            ad=self.publisher,
-            discovery_session=self.publish_session,
-            peer=self.publisher_peer,
-            net_work_request_id=network_id,
-            network_specifier_params=network_specifier_on_pub,
-            is_accept_any_peer=is_pub_accept_any_peer,
-        )
-        sub_network_cb_handler = self._request_network(
-            ad=self.subscriber,
-            discovery_session=self.subscribe_session,
-            peer=self.subscriber_peer,
-            net_work_request_id=network_id,
-            network_specifier_params=network_specifier_on_sub,
-        )
-        expected_channel = None
-        if (network_specifier_on_pub and
-                network_specifier_on_pub.channel_frequency_m_hz and
-                network_specifier_on_sub and
-                network_specifier_on_sub.channel_frequency_m_hz):
-            expected_channel = network_specifier_on_sub.channel_frequency_m_hz
-        self._wait_for_network(
-            ad=self.publisher,
-            request_network_cb_handler=pub_network_cb_handler,
-            expected_channel=None,
-        )
-        self._wait_for_network(
-            ad=self.subscriber,
-            request_network_cb_handler=sub_network_cb_handler,
-            expected_channel=expected_channel,
-        )
-        # 5. Establish a socket connection and send messages through it.
-        self._establish_socket_and_send_msg(
-            pub_accept_handler=pub_accept_handler,
-            network_id=network_id,
-            pub_local_port=pub_local_port
-
-        )
-        self.publisher.wifi_aware_snippet.connectivityUnregisterNetwork(
-            network_id
-        )
-        self.subscriber.wifi_aware_snippet.connectivityUnregisterNetwork(
-            network_id
-        )
-        self.publisher.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
-            self.publish_session
-        )
-        self.publish_session = None
-        self.subscriber.wifi_aware_snippet.wifiAwareCloseDiscoverSession(
-            self.subscribe_session
-        )
-        self.subscribe_session = None
-        self.publisher.wifi_aware_snippet.wifiAwareDetach(
-            self.publisher_attach_session
-        )
-        self.publisher_attach_session = None
-        self.subscriber.wifi_aware_snippet.wifiAwareDetach(
-            self.subscriber_attach_session
-        )
-        self.subscriber_attach_session = None
-        self.publisher.wifi_aware_snippet.connectivityCloseAllSocket(network_id)
-        self.subscriber.wifi_aware_snippet.connectivityCloseAllSocket(network_id)
-
-    def _publish_and_subscribe(self, pub_config, sub_config):
-        """Publishes and subscribes a Wi-Fi Aware session."""
-        # 1. Attach Wi-Fi Aware sessions.
-        self.publisher_attach_session, self.publisher_mac = (
-            self._start_attach(
-                self.publisher, is_ranging_enabled=pub_config.ranging_enabled
-            )
-        )
-        self.subscriber_attach_session, self.subscriber_mac = (
-            self._start_attach(
-                self.subscriber, is_ranging_enabled=pub_config.ranging_enabled
-            )
-        )
-
-        # 2.1. Initialize discovery sessions (publish and subscribe).
-        pub_aware_session_cb_handler = self._start_publish(
-            attach_session_id=self.publisher_attach_session,
-            pub_config=pub_config,
-        )
-        self.publish_session = pub_aware_session_cb_handler.callback_id
-        self.publisher.log.info('Created the publish session.')
-        sub_aware_session_cb_handler = self._start_subscribe(
-            attach_session_id=self.subscriber_attach_session,
-            sub_config=sub_config,
-        )
-        self.subscribe_session = sub_aware_session_cb_handler.callback_id
-        self.subscriber.log.info('Subscribe session created.')
-        # 2.2. Wait for discovery.
-        self.subscriber_peer = self._wait_for_discovery(
-            sub_aware_session_cb_handler,
-            pub_service_specific_info=pub_config.service_specific_info,
-            is_ranging_enabled=pub_config.ranging_enabled,
-        )
-        self.subscriber.log.info('Subscriber discovered the published service.')
-        # 3. Send messages through discovery sessions API.
-        self.publisher_peer = self._send_msg_through_discovery_session(
-            sender=self.subscriber,
-            sender_aware_session_cb_handler=sub_aware_session_cb_handler,
-            receiver=self.publisher,
-            receiver_aware_session_cb_handler=pub_aware_session_cb_handler,
-            discovery_session=self.subscribe_session,
-            peer=self.subscriber_peer,
-            send_message=_MSG_SUB_TO_PUB,
-            send_message_id=_MSG_ID_SUB_TO_PUB,
-        )
-        logging.info(
-            'The subscriber sent a message and the publisher received it.'
-        )
-        self._send_msg_through_discovery_session(
-            sender=self.publisher,
-            sender_aware_session_cb_handler=pub_aware_session_cb_handler,
-            receiver=self.subscriber,
-            receiver_aware_session_cb_handler=sub_aware_session_cb_handler,
-            discovery_session=self.publish_session,
-            peer=self.publisher_peer,
-            send_message=_MSG_PUB_TO_SUB,
-            send_message_id=_MSG_ID_PUB_TO_SUB,
-        )
-        logging.info(
-            'The publisher sent a message and the subscriber received it.'
-        )
-
-    def _establish_socket_and_send_msg(
-        self,
-        pub_accept_handler: callback_handler_v2.CallbackHandlerV2,
-        network_id: str,
-        pub_local_port: int
-    ):
-        """Handles socket-based communication between publisher and subscriber."""
-        # Init socket
-        # Create a ServerSocket and makes it listen for client connections.
-        self.subscriber.wifi_aware_snippet.connectivityCreateSocketOverWiFiAware(
-            network_id, pub_local_port
-        )
-        self._wait_accept_success(pub_accept_handler)
-        # Subscriber Send socket data
-        self.subscriber.log.info('Subscriber create a socket.')
-        self._send_socket_msg(
-            sender_ad=self.subscriber,
-            receiver_ad=self.publisher,
-            msg=constants.WifiAwareTestConstants.MSG_CLIENT_TO_SERVER,
-            send_callback_id=network_id,
-            receiver_callback_id=network_id
-        )
-        self._send_socket_msg(
-            sender_ad=self.publisher,
-            receiver_ad=self.subscriber,
-            msg=constants.WifiAwareTestConstants.MSG_SERVER_TO_CLIENT,
-            send_callback_id=network_id,
-            receiver_callback_id=network_id
-        )
-        self.publisher.wifi_aware_snippet.connectivityCloseWrite(network_id)
-        self.subscriber.wifi_aware_snippet.connectivityCloseWrite(network_id)
-        self.publisher.wifi_aware_snippet.connectivityCloseRead(network_id)
-        self.subscriber.wifi_aware_snippet.connectivityCloseRead(network_id)
-        logging.info('Communicated through socket connection of Wi-Fi Aware network successfully.')
-
-    def _wait_accept_success(
-        self,
-        pub_accept_handler: callback_handler_v2.CallbackHandlerV2
-    ) -> None:
-        pub_accept_event = pub_accept_handler.waitAndGet(
-            event_name=constants.SnippetEventNames.SERVER_SOCKET_ACCEPT,
-            timeout=_DEFAULT_TIMEOUT
-        )
-        is_accept = pub_accept_event.data.get(constants.SnippetEventParams.IS_ACCEPT, False)
-        if not is_accept:
-            error = pub_accept_event.data[constants.SnippetEventParams.ERROR]
-            asserts.fail(
-                f'{self.publisher} Failed to accept the connection. Error: {error}'
-            )
-
-    def _start_attach(
-        self,
-        ad: android_device.AndroidDevice,
-        is_ranging_enabled: bool,
-    ) -> str:
-        """Starts the attach process on the provided device."""
-        attach_handler = ad.wifi_aware_snippet.wifiAwareAttached(
-            is_ranging_enabled
-        )
-        attach_event = attach_handler.waitAndGet(
-            event_name=AttachCallBackMethodType.ATTACHED,
-            timeout=_DEFAULT_TIMEOUT,
-        )
-        asserts.assert_true(
-            ad.wifi_aware_snippet.wifiAwareIsSessionAttached(attach_event.callback_id),
-            f'{ad} attach succeeded, but Wi-Fi Aware session is still null.'
-        )
-        mac_address = None
-        if is_ranging_enabled:
-            identity_changed_event = attach_handler.waitAndGet(
-                event_name='WifiAwareAttachOnIdentityChanged',
-                timeout=_DEFAULT_TIMEOUT,
-            )
-            mac_address = identity_changed_event.data.get('mac', None)
-            asserts.assert_true(bool(mac_address), 'Mac address should not be empty')
-        ad.log.info('Attach Wi-Fi Aware session succeeded.')
-        return attach_event.callback_id, mac_address
-
-    def _start_publish(
-        self,
-        attach_session_id: str,
-        pub_config: constants.PublishConfig,
-    ) -> callback_event.CallbackEvent:
-        """Starts a publish session on the publisher device."""
-
-        # Start the publishing session and return the handler.
-        publish_handler = self.publisher.wifi_aware_snippet.wifiAwarePublish(
-            attach_session_id,
-            pub_config.to_dict(),
-        )
-
-        # Wait for publish session to start.
-        discovery_event = publish_handler.waitAndGet(
-            event_name=constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
-            timeout=_DEFAULT_TIMEOUT
-        )
-        callback_name = discovery_event.data[_CALLBACK_NAME]
-        asserts.assert_equal(
-            constants.DiscoverySessionCallbackMethodType.PUBLISH_STARTED,
-            callback_name,
-            f'{self.publisher} publish failed, got callback: {callback_name}.',
-        )
-
-        is_session_init = discovery_event.data[_IS_SESSION_INIT]
-        asserts.assert_true(
-            is_session_init,
-            f'{self.publisher} publish succeeded, but null discovery session returned.'
-        )
-        return publish_handler
-
-    def _start_subscribe(
-        self,
-        attach_session_id: str,
-        sub_config: constants.SubscribeConfig,
-    ) -> callback_event.CallbackEvent:
-        """Starts a subscribe session on the subscriber device."""
-
-        # Start the subscription session and return the handler.
-        subscribe_handler = self.subscriber.wifi_aware_snippet.wifiAwareSubscribe(
-            attach_session_id,
-            sub_config.to_dict(),
-        )
-
-        # Wait for subscribe session to start.
-        discovery_event = subscribe_handler.waitAndGet(
-            event_name=constants.DiscoverySessionCallbackMethodType.DISCOVER_RESULT,
-            timeout=_DEFAULT_TIMEOUT
-        )
-        callback_name = discovery_event.data[_CALLBACK_NAME]
-        asserts.assert_equal(
-            constants.DiscoverySessionCallbackMethodType.SUBSCRIBE_STARTED,
-            callback_name,
-            f'{self.subscriber} subscribe failed, got callback: {callback_name}.'
-        )
-        is_session_init = discovery_event.data[_IS_SESSION_INIT]
-        asserts.assert_true(
-            is_session_init,
-            f'{self.subscriber} subscribe succeeded, but null session returned.'
-        )
-        return subscribe_handler
-
-    def _wait_for_discovery(
-        self,
-        sub_aware_session_cb_handler: callback_handler_v2.CallbackHandlerV2,
-        pub_service_specific_info: bytes,
-        is_ranging_enabled: bool,
-    ) -> int:
-        """Waits for discovery of the publisher's service by the subscriber."""
-        event_name = constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED
-        if is_ranging_enabled:
-            event_name = (
-                constants.DiscoverySessionCallbackMethodType.SERVICE_DISCOVERED_WITHIN_RANGE
-            )
-        discover_data = sub_aware_session_cb_handler.waitAndGet(
-            event_name=event_name, timeout=_DEFAULT_TIMEOUT
-        )
-
-        service_info = bytes(
-            discover_data.data[constants.WifiAwareSnippetParams.SERVICE_SPECIFIC_INFO]
-        )
-        asserts.assert_equal(
-            service_info,
-            pub_service_specific_info,
-            f'{self.subscriber} got unexpected service info in discovery'
-            f' callback event "{event_name}".'
-        )
-        match_filters = discover_data.data[
-            constants.WifiAwareSnippetParams.MATCH_FILTER]
-        match_filters = [
-            bytes(filter[constants.WifiAwareSnippetParams.MATCH_FILTER_VALUE])
-            for filter in match_filters
-        ]
-        asserts.assert_equal(
-            match_filters,
-            [constants.WifiAwareTestConstants.MATCH_FILTER_BYTES],
-            f'{self.subscriber} got unexpected match filter data in discovery'
-            f' callback event "{event_name}".'
-        )
-        return discover_data.data[constants.WifiAwareSnippetParams.PEER_ID]
-
-    def _send_msg_through_discovery_session(
-        self,
-        *,
-        sender: android_device.AndroidDevice,
-        sender_aware_session_cb_handler: callback_handler_v2.CallbackHandlerV2,
-        receiver: android_device.AndroidDevice,
-        receiver_aware_session_cb_handler: callback_handler_v2.CallbackHandlerV2,
-        discovery_session: str,
-        peer: int,
-        send_message: str,
-        send_message_id: int,
-    ) -> int:
-        sender.wifi_aware_snippet.wifiAwareSendMessage(
-            discovery_session, peer, send_message_id, send_message
-        )
-        message_send_result = sender_aware_session_cb_handler.waitAndGet(
-            event_name=constants.DiscoverySessionCallbackMethodType.MESSAGE_SEND_RESULT,
-            timeout=_DEFAULT_TIMEOUT,
-        )
-        callback_name = message_send_result.data[
-            constants.DiscoverySessionCallbackParamsType.CALLBACK_NAME
-        ]
-        asserts.assert_equal(
-            callback_name,
-            constants.DiscoverySessionCallbackMethodType.MESSAGE_SEND_SUCCEEDED,
-            f'{sender} failed to send message with an unexpected callback.',
-        )
-        actual_send_message_id = message_send_result.data[
-            constants.DiscoverySessionCallbackParamsType.MESSAGE_ID
-        ]
-        asserts.assert_equal(
-            actual_send_message_id,
-            send_message_id,
-            f'{sender} send message succeeded but message ID mismatched.'
-        )
-        receive_message_event = receiver_aware_session_cb_handler.waitAndGet(
-            event_name=constants.DiscoverySessionCallbackMethodType.MESSAGE_RECEIVED,
-            timeout=_DEFAULT_TIMEOUT,
-        )
-        received_message_raw = receive_message_event.data[
-            constants.WifiAwareSnippetParams.RECEIVED_MESSAGE
-        ]
-        received_message = bytes(received_message_raw).decode('utf-8')
-        asserts.assert_equal(
-            received_message,
-            send_message,
-            f'{receiver} received the message but message content mismatched.'
-        )
-        return receive_message_event.data[constants.WifiAwareSnippetParams.PEER_ID]
-
-    def _request_network(
-        self,
-        ad: android_device.AndroidDevice,
-        discovery_session: str,
-        peer: int,
-        net_work_request_id: str,
-        network_specifier_params: constants.WifiAwareNetworkSpecifier | None = None,
-        is_accept_any_peer: bool = False,
-    ) -> callback_handler_v2.CallbackHandlerV2:
-        """Requests and configures a Wi-Fi Aware network connection."""
-        network_specifier_parcel = (
-            ad.wifi_aware_snippet.wifiAwareCreateNetworkSpecifier(
-                discovery_session,
-                peer,
-                is_accept_any_peer,
-                network_specifier_params.to_dict() if network_specifier_params else None,
-            )
-        )
-        network_request_dict = constants.NetworkRequest(
-            transport_type=_TRANSPORT_TYPE_WIFI_AWARE,
-            network_specifier_parcel=network_specifier_parcel,
-        ).to_dict()
-        ad.log.debug('Requesting Wi-Fi Aware network: %r', network_request_dict)
-        return ad.wifi_aware_snippet.connectivityRequestNetwork(
-            net_work_request_id, network_request_dict, _REQUEST_NETWORK_TIMEOUT_MS
-        )
-
-    def _wait_for_network(
-        self,
-        ad: android_device.AndroidDevice,
-        request_network_cb_handler: callback_handler_v2.CallbackHandlerV2,
-        expected_channel: str | None = None,
-    ):
-        """Waits for and verifies the establishment of a Wi-Fi Aware network."""
-        network_callback_event = request_network_cb_handler.waitAndGet(
-            event_name=constants.NetworkCbEventName.NETWORK_CALLBACK,
-            timeout=_DEFAULT_TIMEOUT,
-        )
-        callback_name = network_callback_event.data[_CALLBACK_NAME]
-        if callback_name == constants.NetworkCbName.ON_UNAVAILABLE:
-            asserts.fail(
-                f'{ad} failed to request the network, got callback'
-                f' {callback_name}.'
-            )
-        elif callback_name == constants.NetworkCbName.ON_CAPABILITIES_CHANGED:
-            # `network` is the network whose capabilities have changed.
-            network = network_callback_event.data[
-                constants.NetworkCbEventKey.NETWORK]
-            network_capabilities = network_callback_event.data[
-                constants.NetworkCbEventKey.NETWORK_CAPABILITIES]
-            asserts.assert_true(
-                network and network_capabilities,
-                f'{ad} received a null Network or NetworkCapabilities!?.'
-            )
-            transport_info_class_name = network_callback_event.data[
-                constants.NetworkCbEventKey.TRANSPORT_INFO_CLASS_NAME]
-            asserts.assert_equal(
-                transport_info_class_name,
-                constants.AWARE_NETWORK_INFO_CLASS_NAME,
-                f'{ad} network capabilities changes but it is not a WiFi Aware'
-                ' network.',
-            )
-            if expected_channel:
-                mhz_list = network_callback_event.data[constants.NetworkCbEventKey.CHANNEL_IN_MHZ]
-                asserts.assert_equal(
-                    mhz_list,
-                    [expected_channel],
-                    f'{ad} Channel freq is not match the request.'
-                )
-        else:
-            asserts.fail(
-                f'{ad} got unknown request network callback {callback_name}.'
-            )
-
-    def teardown_test(self):
-        utils.concurrent_exec(
-            lambda d: d.services.create_output_excerpts_all(self.current_test_info),
-            param_list=[[ad] for ad in self.ads],
-            raise_on_exception=True,
-        )
-        utils.concurrent_exec(
-            self._teardown_on_device,
-            ((self.publisher,), (self.subscriber,)),
-            max_workers=2,
-            raise_on_exception=True,
-        )
-        self.publisher_mac = None
-        self.subscriber_mac = None
-        self.publisher_peer = None
-        self.subscriber_peer = None
-        self.publish_session = None
-        self.subscribe_session = None
-        self.publisher_attach_session = None
-        self.subscriber_attach_session = None
-
-    def _send_socket_msg(
-        self,
-        sender_ad: android_device.AndroidDevice,
-        receiver_ad: android_device.AndroidDevice,
-        msg: str,
-        send_callback_id: str,
-        receiver_callback_id: str,
-    ):
-        """Sends a message from one device to another and verifies receipt."""
-        is_write_socket = sender_ad.wifi_aware_snippet.connectivityWriteSocket(
-            send_callback_id, msg
-        )
-        asserts.assert_true(
-            is_write_socket,
-            f'{sender_ad} Failed to write data to the socket.'
-        )
-        sender_ad.log.info('Wrote data to the socket.')
-        self.publisher.log.info('Server socket accepted the connection.')
-        # Verify received message
-        received_message = receiver_ad.wifi_aware_snippet.connectivityReadSocket(
-            receiver_callback_id, len(msg)
-        )
-        asserts.assert_equal(
-            received_message,
-            msg,
-            f'{receiver_ad} received message mismatched.Failure:Expected {msg} but got '
-            f'{received_message}.'
-        )
-        receiver_ad.log.info('Read data from the socket.')
-
-    def _skip_if_wifi_rtt_is_not_supported(self):
-      """Skips this test case if Wi-Fi RTT is not supported on any device."""
-      asserts.skip_if(
-          not self.publisher.wifi_aware_snippet.wifiAwareIsRttSupported(),
-          f'Publisher {self.publisher} does not support Wi-Fi RTT.'
-      )
-      asserts.skip_if(
-          not self.subscriber.wifi_aware_snippet.wifiAwareIsRttSupported(),
-          f'Subscriber {self.subscriber} does not support Wi-Fi RTT.'
-      )
-
-    def _perform_ranging(
-        self,
-        ad: android_device.AndroidDevice,
-        request: constants.RangingRequest,
-    ):
-        """Performs ranging and checks the ranging result."""
-        ad.log.debug('Starting ranging with request: %s', request)
-        ranging_cb_handler = ad.wifi_aware_snippet.wifiAwareStartRanging(
-            request.to_dict()
-        )
-        event = ranging_cb_handler.waitAndGet(
-            event_name=constants.RangingResultCb.EVENT_NAME_ON_RANGING_RESULT,
-            timeout=_DEFAULT_TIMEOUT,
-        )
-
-        callback_name = event.data.get(
-            constants.RangingResultCb.DATA_KEY_CALLBACK_NAME, None
-        )
-        asserts.assert_equal(
-            callback_name,
-            constants.RangingResultCb.CB_METHOD_ON_RANGING_RESULT,
-            'Ranging failed: got unexpected callback.',
-        )
-
-        results = event.data.get(
-            constants.RangingResultCb.DATA_KEY_RESULTS, None
-        )
-        asserts.assert_true(
-            results is not None and len(results) == 1,
-            'Ranging got invalid results: null, empty, or wrong length.'
-        )
-
-        status_code = results[0].get(
-            constants.RangingResultCb.DATA_KEY_RESULT_STATUS, None
-        )
-        asserts.assert_equal(
-            status_code,
-            constants.RangingResultStatusCode.SUCCESS,
-            'Ranging peer failed: invalid result status code.',
-        )
-
-        distance_mm = results[0].get(
-            constants.RangingResultCb.DATA_KEY_RESULT_DISTANCE_MM, None
-        )
-        asserts.assert_true(
-            (
-                distance_mm is not None
-                and distance_mm <= _LARGE_ENOUGH_DISTANCE_MM
-            ),
-            'Ranging peer failed: invalid distance in ranging result.',
-        )
-        rssi = results[0].get(
-            constants.RangingResultCb.DATA_KEY_RESULT_RSSI, None
-        )
-        asserts.assert_true(
-            rssi is not None and rssi >= _MIN_RSSI,
-            'Ranging peer failed: invalid rssi in ranging result.',
-        )
-
-        peer_id = results[0].get(
-            constants.RangingResultCb.DATA_KEY_PEER_ID, None
-        )
-        if peer_id is not None:
-            msg = 'Ranging peer failed: invalid peer ID in ranging result.'
-            asserts.assert_in(peer_id, request.peer_ids, msg)
-
-        peer_mac = results[0].get(constants.RangingResultCb.DATA_KEY_MAC, None)
-        if peer_mac is not None:
-            msg = (
-                'Ranging peer failed: invalid peer MAC address in ranging '
-                'result.'
-            )
-            asserts.assert_in(peer_mac, request.peer_mac_addresses, msg)
-
-    def _teardown_on_device(self, ad: android_device.AndroidDevice) -> None:
-        """Releases resources and sessions after each test."""
-        ad.wifi_aware_snippet.connectivityReleaseAllSockets()
-        ad.wifi_aware_snippet.wifiAwareCloseAllWifiAwareSession()
-
-    def on_fail(self, record: records.TestResult) -> None:
-        logging.info('Collecting bugreports...')
-        android_device.take_bug_reports(self.ads, destination=self.current_test_info.output_path)
-
-
-if __name__ == '__main__':
-    # Take test args
-    if '--' in sys.argv:
-        index = sys.argv.index('--')
-        sys.argv = sys.argv[:1] + sys.argv[index + 1:]
-
-    test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/aware/wifi_aware_network_test.py b/tests/hostsidetests/multidevices/test/aware/wifi_aware_network_test.py
new file mode 100644
index 0000000000..c0d406603e
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/aware/wifi_aware_network_test.py
@@ -0,0 +1,763 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+"""Wi-Fi Aware network test module."""
+
+import logging
+import sys
+
+from android.platform.test.annotations import ApiTest
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+import wifi_test_utils
+
+from aware import aware_snippet_utils
+from aware import constants
+
+
+_SNIPPET_PACKAGE_NAME = constants.WIFI_SNIPPET_PACKAGE_NAME
+_PUB_SSI = 'Extra bytes in the publisher discovery'.encode('utf-8')
+_SUB_SSI = 'Arbitrary bytes for the subscribe discovery'.encode('utf-8')
+_MATCH_FILTER = ('bytes used for matching'.encode('utf-8'),)
+_PASSWORD = 'Some super secret password'
+_PMK = '01234567890123456789012345678901'
+_MSG_SUB_TO_PUB = "Let's talk [Random Identifier: {random_id}]"
+_MSG_PUB_TO_SUB = 'Ready [Random Identifier: %s]'
+_MSG_CLIENT_TO_SERVER = 'GET SOME BYTES [Random Identifier: {random_id}]'
+_MSG_SERVER_TO_CLIENT = 'PUT SOME OTHER BYTES [Random Identifier: {random_id}]'
+_TRANSPORT_PROTOCOL_TCP = (
+    constants.WifiAwareTestConstants.TRANSPORT_PROTOCOL_TCP
+)
+_TEST_FREQUENCY_5745 = 5745
+
+
+class WifiAwareNetworkTest(base_test.BaseTestClass):
+    """Wi-Fi Aware network test class.
+
+    All tests in this class share the same test steps and expected results.
+    The difference is that each test tests against a different set of Wi-Fi
+    Aware configuration.
+
+    Test Preconditions:
+        * All tests require two Android devices that support Wi-Fi Aware.
+        * Test `test_data_path_force_channel_setup` requires the test devices to
+          support setting a channel requirement in a data-path request.
+
+    Test Steps:
+        1. Attach a Wi-Fi Aware session on each device.
+        2. Publisher publishes an Wi-Fi Aware service, subscriber subscribes to
+           it. Wait for service discovery.
+        3. Send messages through discovery session's API.
+        4. Request a Wi-Fi Aware network on each device.
+        5. Subscriber establishes a socket connection to the publisher.
+        6. Send messages through the new socket connection.
+
+    Expected Results:
+        Publisher and subscriber can send and receive messages through the
+        discovery session's API and the socket connection.
+    """
+
+    ads: list[android_device.AndroidDevice]
+    publisher: android_device.AndroidDevice
+    subscriber: android_device.AndroidDevice
+
+    def setup_class(self):
+        # Register and set up Android devices in parallel.
+        self.ads = self.register_controller(android_device, min_number=2)
+        self.publisher = self.ads[0]
+        self.subscriber = self.ads[1]
+
+        # Device setup
+        utils.concurrent_exec(
+            self._setup_device,
+            ((self.publisher,), (self.subscriber,)),
+            max_workers=2,
+            raise_on_exception=True,
+        )
+
+        # Device capability check
+        for device in [self.publisher, self.subscriber]:
+            asserts.abort_class_if(
+                not device.wifi.wifiAwareIsSupported(),
+                f'{device} does not support Wi-Fi Aware.',
+            )
+            asserts.abort_class_if(
+                not device.wifi.wifiAwareIsAvailable(),
+                f'Wi-Fi Aware is not available on {device}.',
+            )
+
+    def _setup_device(self, device: android_device.AndroidDevice):
+        device.load_snippet('wifi', _SNIPPET_PACKAGE_NAME)
+        device.wifi.wifiEnable()
+        wifi_test_utils.set_screen_on_and_unlock(device)
+        wifi_test_utils.enable_wifi_verbose_logging(device)
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(int)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+    def test_data_path_open_unsolicited_pub_and_passive_sub(self) -> None:
+        """Test Wi-Fi Aware OPEN network with unsolicited publish and passive
+        subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.UNSOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.PASSIVE,
+            ),
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(int)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+    def test_data_path_passphrase_unsolicited_pub_and_passive_sub(self) -> None:
+        """Test Wi-Fi Aware network with passphrase, unsolicited publish, and
+        passive subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.UNSOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.PASSIVE,
+            ),
+            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
+                psk_passphrase=_PASSWORD,
+                transport_protocol=_TRANSPORT_PROTOCOL_TCP,
+            ),
+            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
+                psk_passphrase=_PASSWORD,
+            ),
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(int)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPmk(byte[])',
+        ]
+    )
+    def test_data_path_pmk_unsolicited_pub_and_passive_sub(self) -> None:
+        """Test Wi-Fi Aware network using PMK with unsolicited publish and
+        passive subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.UNSOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.PASSIVE,
+            ),
+            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
+                transport_protocol=_TRANSPORT_PROTOCOL_TCP,
+                pmk=_PMK,
+            ),
+            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
+                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
+                    pmk=_PMK,
+                )
+            ),
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(int)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+        ]
+    )
+    def test_data_path_open_solicited_pub_and_active_sub(self) -> None:
+        """Test OPEN Wi-Fi Aware network with solicited publish and active
+        subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.SOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.ACTIVE,
+            ),
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(int)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+    def test_data_path_passphrase_solicited_pub_and_active_sub(self) -> None:
+        """Test Wi-Fi Aware network with passphrase, solicited publish, and
+        active subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.SOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.ACTIVE,
+            ),
+            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
+                psk_passphrase=_PASSWORD,
+                transport_protocol=_TRANSPORT_PROTOCOL_TCP,
+            ),
+            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
+                psk_passphrase=_PASSWORD,
+            ),
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.PublishConfig.Builder#setPublishType(int)',
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPmk(byte[])',
+        ]
+    )
+    def test_data_path_pmk_solicited_pub_and_active_sub(self) -> None:
+        """Test Wi-Fi Aware network with PMK, solicited publish, and active
+        subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.SOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.ACTIVE,
+            ),
+            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
+                transport_protocol=_TRANSPORT_PROTOCOL_TCP,
+                pmk=_PMK,
+            ),
+            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
+                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
+                    pmk=_PMK,
+                )
+            ),
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#Builder(android.net.wifi.aware.PublishDiscoverySession)',
+        ]
+    )
+    def test_data_path_open_unsolicited_pub_accept_any_and_passive_sub(
+        self,
+    ) -> None:
+        """Test OPEN Wi-Fi Aware with unsolicited publish (accept any peer) and
+        passive subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.UNSOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.PASSIVE,
+            ),
+            is_pub_accept_any_peer=True,
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#Builder(android.net.wifi.aware.PublishDiscoverySession)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+    def test_data_path_passphrase_unsolicited_pub_accept_any_and_passive_sub(
+        self,
+    ) -> None:
+        """Test Wi-Fi Aware with passphrase, unsolicited publish (accept any
+        peer), and passive subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.UNSOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.PASSIVE,
+            ),
+            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
+                psk_passphrase=_PASSWORD,
+                transport_protocol=_TRANSPORT_PROTOCOL_TCP,
+            ),
+            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
+                psk_passphrase=_PASSWORD,
+            ),
+            is_pub_accept_any_peer=True,
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#Builder(android.net.wifi.aware.PublishDiscoverySession)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPmk(byte[])',
+            'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+    def test_data_path_pmk_unsolicited_pub_accept_any_and_passive_sub(
+        self,
+    ) -> None:
+        """Test Wi-Fi Aware with PMK, unsolicited publish (accept any peer), and
+        passive subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.UNSOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.PASSIVE,
+            ),
+            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
+                transport_protocol=_TRANSPORT_PROTOCOL_TCP,
+                pmk=_PMK,
+            ),
+            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
+                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
+                    pmk=_PMK,
+                )
+            ),
+            is_pub_accept_any_peer=True,
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#Builder(android.net.wifi.aware.PublishDiscoverySession)',
+            'android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE',
+        ]
+    )
+    def test_data_path_open_solicited_pub_accept_any_active_sub(self) -> None:
+        """Test Wi-Fi Aware with open network, solicited publish (accept any
+        peer), and active subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.SOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.ACTIVE,
+            ),
+            is_pub_accept_any_peer=True,
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#Builder(android.net.wifi.aware.PublishDiscoverySession)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPskPassphrase(String)',
+        ]
+    )
+    def test_data_path_passphrase_solicited_pub_accept_any_and_active_sub(
+        self,
+    ) -> None:
+        """Test Wi-Fi Aware with passphrase, solicited publish (accept any
+        peer), and active subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.SOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.ACTIVE,
+            ),
+            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
+                psk_passphrase=_PASSWORD,
+                transport_protocol=_TRANSPORT_PROTOCOL_TCP,
+            ),
+            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
+                psk_passphrase=_PASSWORD,
+            ),
+            is_pub_accept_any_peer=True,
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.SubscribeConfig.Builder#setSubscribeType(int)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#build()',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#Builder(android.net.wifi.aware.PublishDiscoverySession)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setPmk(byte[])',
+        ]
+    )
+    def test_data_path_pmk_solicited_pub_accept_any_and_active_sub(
+        self,
+    ) -> None:
+        """Test Wi-Fi Aware with PMK, solicited publish (accept any peer), and
+        active subscribe.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.SOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.ACTIVE,
+            ),
+            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
+                transport_protocol=_TRANSPORT_PROTOCOL_TCP,
+                pmk=_PMK,
+            ),
+            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
+                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
+                    pmk=_PMK,
+                )
+            ),
+            is_pub_accept_any_peer=True,
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#Builder(android.net.wifi.aware.DiscoverySession, android.net.wifi.aware.PeerHandle)',
+            'android.net.wifi.aware.WifiAwareNetworkSpecifier.Builder#setChannelFrequencyMhz(int, boolean)',
+        ]
+    )
+    def test_data_path_force_channel_setup(self):
+        """Test Wi-Fi Aware network, forcing it to use a specific channel.
+
+        This test case requires that both devices support setting a channel
+        requirement in the Wi-Fi Aware data-path request.
+
+        See class docstring for the test steps and expected results.
+        """
+        # The support of this function depends on the chip used.
+        asserts.skip_if(
+            not self.publisher.wifi.wifiAwareIsSetChannelOnDataPathSupported(),
+            'Publish device not support this test feature.',
+        )
+        asserts.skip_if(
+            not self.subscriber.wifi.wifiAwareIsSetChannelOnDataPathSupported(),
+            'Subscriber device not support this test feature.',
+        )
+
+        self._test_wifi_aware_network(
+            pub_config=constants.PublishConfig(
+                service_specific_info=_PUB_SSI,
+                match_filter=_MATCH_FILTER,
+                publish_type=constants.PublishType.UNSOLICITED,
+                ranging_enabled=False,
+            ),
+            sub_config=constants.SubscribeConfig(
+                service_specific_info=_SUB_SSI,
+                match_filter=_MATCH_FILTER,
+                subscribe_type=constants.SubscribeType.PASSIVE,
+            ),
+            network_specifier_on_pub=constants.WifiAwareNetworkSpecifier(
+                transport_protocol=_TRANSPORT_PROTOCOL_TCP,
+                pmk=_PMK,
+                channel_frequency_m_hz=_TEST_FREQUENCY_5745,
+            ),
+            network_specifier_on_sub=constants.WifiAwareNetworkSpecifier(
+                data_path_security_config=constants.WifiAwareDataPathSecurityConfig(
+                    pmk=_PMK,
+                ),
+                channel_frequency_m_hz=_TEST_FREQUENCY_5745,
+            ),
+        )
+
+    def _test_wifi_aware_network(
+        self,
+        pub_config: constants.PublishConfig,
+        sub_config: constants.SubscribeConfig,
+        network_specifier_on_pub: (
+            constants.WifiAwareNetworkSpecifier | None
+        ) = None,
+        network_specifier_on_sub: (
+            constants.WifiAwareNetworkSpecifier | None
+        ) = None,
+        is_pub_accept_any_peer: bool = False,
+    ):
+        """Tests establishing a Wi-Fi Aware network and sending messages."""
+        network_specifier_on_pub = (
+            network_specifier_on_pub or constants.WifiAwareNetworkSpecifier()
+        )
+        network_specifier_on_sub = (
+            network_specifier_on_sub or constants.WifiAwareNetworkSpecifier()
+        )
+
+        # Step 1: Attach Wi-Fi Aware sessions.
+        pub_attach_session, _ = aware_snippet_utils.start_attach(
+            self.publisher, pub_config.ranging_enabled
+        )
+        sub_attach_session, _ = aware_snippet_utils.start_attach(
+            self.subscriber, pub_config.ranging_enabled
+        )
+
+        # Step 2: Publisher publishes an Wi-Fi Aware service, subscriber
+        # subscribes to it. Wait for service discovery.
+        (
+            pub_session,
+            pub_session_handler,
+            sub_session,
+            sub_session_handler,
+            sub_peer,
+        ) = aware_snippet_utils.publish_and_subscribe(
+            publisher=self.publisher,
+            pub_config=pub_config,
+            pub_attach_session=pub_attach_session,
+            subscriber=self.subscriber,
+            sub_config=sub_config,
+            sub_attach_session=sub_attach_session,
+        )
+
+        # Step 3: Send messages through the discovery sessions.
+        msg = _MSG_SUB_TO_PUB.format(random_id=utils.rand_ascii_str(5))
+        pub_peer = aware_snippet_utils.send_msg_through_discovery_session(
+            sender=self.subscriber,
+            sender_discovery_session_handler=sub_session_handler,
+            receiver=self.publisher,
+            receiver_discovery_session_handler=pub_session_handler,
+            discovery_session=sub_session,
+            peer_on_sender=sub_peer,
+            send_message=msg,
+        )
+        self.subscriber.log.info(
+            'Sent a message to peer %d through discovery session.',
+            sub_peer,
+        )
+        msg = _MSG_PUB_TO_SUB.format(random_id=utils.rand_ascii_str(5))
+        aware_snippet_utils.send_msg_through_discovery_session(
+            sender=self.publisher,
+            sender_discovery_session_handler=pub_session_handler,
+            receiver=self.subscriber,
+            receiver_discovery_session_handler=sub_session_handler,
+            discovery_session=pub_session,
+            peer_on_sender=pub_peer,
+            send_message=msg,
+        )
+        self.publisher.log.info(
+            'Sent a message to peer %d through discovery session.',
+            pub_peer,
+        )
+
+        # Step 4: Establish a Wi-Fi Aware network.
+        # Step 4.1: Initialize a server socket on the publisher.
+        pub_accept_handler = (
+            self.publisher.wifi.connectivityServerSocketAccept()
+        )
+        network_id = pub_accept_handler.callback_id
+        pub_local_port = pub_accept_handler.ret_value
+        # `WifiAwareNetworkSpecifier` does not allow setting port for open
+        # networks.
+        if (
+            network_specifier_on_pub.psk_passphrase is not None
+            and network_specifier_on_pub.pmk is not None
+        ):
+            network_specifier_on_pub.port = pub_local_port
+        # Step 4.2: Request a Wi-Fi Aware network on each device.
+        pub_network_handler = aware_snippet_utils.request_aware_network(
+            ad=self.publisher,
+            discovery_session=pub_session,
+            peer=pub_peer,
+            network_id=network_id,
+            network_specifier_params=network_specifier_on_pub,
+            is_accept_any_peer=is_pub_accept_any_peer,
+        )
+        sub_network_handler = aware_snippet_utils.request_aware_network(
+            ad=self.subscriber,
+            discovery_session=sub_session,
+            peer=sub_peer,
+            network_id=network_id,
+            network_specifier_params=network_specifier_on_sub,
+        )
+        # Step 4.3: Wait for network establishment.
+        aware_snippet_utils.wait_for_aware_network(
+            ad=self.publisher,
+            request_network_handler=pub_network_handler,
+        )
+        network_cap_changed_event = aware_snippet_utils.wait_for_aware_network(
+            ad=self.subscriber,
+            request_network_handler=sub_network_handler,
+        )
+        # Check frequency if the config forces a channel.
+        if network_specifier_on_sub.channel_frequency_m_hz:
+            asserts.assert_equal(
+                network_cap_changed_event.data[
+                    constants.NetworkCbEventKey.CHANNEL_IN_MHZ
+                ],
+                [network_specifier_on_pub.channel_frequency_m_hz],
+                f'{self.subscriber} Channel freq does not match the request.',
+            )
+
+        # Step 5: Establish a socket connection and send messages through it.
+        aware_snippet_utils.establish_socket_connection(
+            self.publisher,
+            self.subscriber,
+            pub_accept_handler=pub_accept_handler,
+            network_id=network_id,
+            pub_local_port=pub_local_port,
+        )
+
+        # Step 6: Send messages through the socket connection.
+        msg = _MSG_CLIENT_TO_SERVER.format(random_id=utils.rand_ascii_str(5))
+        aware_snippet_utils.send_socket_msg(
+            sender_ad=self.subscriber,
+            receiver_ad=self.publisher,
+            network_id=network_id,
+            msg=msg,
+        )
+        msg = _MSG_SERVER_TO_CLIENT.format(random_id=utils.rand_ascii_str(5))
+        aware_snippet_utils.send_socket_msg(
+            sender_ad=self.publisher,
+            receiver_ad=self.subscriber,
+            network_id=network_id,
+            msg=msg,
+        )
+        logging.info('Communicated through socket connection successfully.')
+
+        # Test finished, clean up.
+        # Clean up network resources.
+        self.publisher.wifi.connectivityCloseAllSocket(network_id)
+        self.subscriber.wifi.connectivityCloseAllSocket(network_id)
+        self.publisher.wifi.connectivityUnregisterNetwork(network_id)
+        self.subscriber.wifi.connectivityUnregisterNetwork(network_id)
+        # Clean up Wi-Fi Aware resources.
+        self.publisher.wifi.wifiAwareCloseDiscoverSession(pub_session)
+        self.subscriber.wifi.wifiAwareCloseDiscoverSession(sub_session)
+        self.publisher.wifi.wifiAwareDetach(pub_attach_session)
+        self.subscriber.wifi.wifiAwareDetach(sub_attach_session)
+
+    def teardown_test(self):
+        utils.concurrent_exec(
+            self._teardown_on_device,
+            ((self.publisher,), (self.subscriber,)),
+            max_workers=2,
+            raise_on_exception=True,
+        )
+
+    def _teardown_on_device(self, ad: android_device.AndroidDevice) -> None:
+        """Releases resources and sessions after each test."""
+        try:
+            ad.wifi.connectivityReleaseAllSockets()
+            ad.wifi.wifiAwareCloseAllWifiAwareSession()
+        finally:
+            ad.services.create_output_excerpts_all(self.current_test_info)
+
+    def on_fail(self, record: records.TestResult) -> None:
+        logging.info('Collecting bugreports...')
+        android_device.take_bug_reports(
+            self.ads, destination=self.current_test_info.output_path
+        )
+
+
+if __name__ == '__main__':
+    # Take test args
+    if '--' in sys.argv:
+        index = sys.argv.index('--')
+        sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+
+    test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/direct/AndroidTest.xml b/tests/hostsidetests/multidevices/test/direct/AndroidTest.xml
new file mode 100644
index 0000000000..6da3197442
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/AndroidTest.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+          http://www.apache.org/licenses/LICENSE-2.0
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Test config for Wi-Fi Direct multi-device tests">
+  <option name="test-suite-tag" value="cts-v-host" />
+  <option name="config-descriptor:metadata" key="component" value="wifi" />
+  <option name="config-descriptor:metadata" key="parameter" value="not_instant_app" />
+  <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+  <option name="config-descriptor:metadata" key="parameter" value="secondary_user" />
+
+  <device name="AndroidDevice">
+    <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+      <option name="required_feature" value="android.hardware.wifi.direct" />
+    </target_preparer>
+    <target_preparer class="AndroidInstallAppsDecorator" />
+  </device>
+  <device name="AndroidDevice">
+    <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+      <option name="required_feature" value="android.hardware.wifi.direct" />
+    </target_preparer>
+    <target_preparer class="AndroidInstallAppsDecorator" />
+  </device>
+
+  <test class="MoblyAospPackageTest" />
+
+  <option name="mobly_pkg" key="file" value="WifiDirectTests" />
+  <option name="build_apk" key="file" value="wifi_mobly_snippet.apk" />
+</configuration>
\ No newline at end of file
diff --git a/tests/hostsidetests/multidevices/test/direct/constants.py b/tests/hostsidetests/multidevices/test/direct/constants.py
index 55b2eb2ce1..a3bcdf54a8 100644
--- a/tests/hostsidetests/multidevices/test/direct/constants.py
+++ b/tests/hostsidetests/multidevices/test/direct/constants.py
@@ -52,8 +52,12 @@ EVENT_KEY_PEER_LIST = 'peerList'
 EXTRA_WIFI_P2P_GROUP = 'p2pGroupInfo'
 EXTRA_WIFI_STATE = 'wifi_p2p_state'
 
+ON_CONNECTION_INFO_AVAILABLE = 'WifiP2pOnConnectionInfoAvailable'
 ON_DEVICE_INFO_AVAILABLE = 'WifiP2pOnDeviceInfoAvailable'
 ON_PERSISTENT_GROUP_INFO_AVAILABLE = 'onPersistentGroupInfoAvailable'
+ON_UPNP_SERVICE_AVAILABLE = 'onUpnpServiceAvailable'
+ON_DNS_SD_SERVICE_AVAILABLE = 'onDnsSdServiceAvailable'
+ON_DNS_SD_TXT_RECORD_AVAILABLE = 'onDnsSdTxtRecordAvailable'
 WIFI_P2P_CREATING_GROUP = 'CREATING_GROUP'
 WIFI_P2P_CONNECTION_CHANGED_ACTION = (
     'android.net.wifi.p2p.CONNECTION_STATE_CHANGE'
@@ -204,7 +208,7 @@ class WifiP2pDevice:
       cls, devices: list[dict[str, Any]]
   ) -> Sequence[WifiP2pDevice]:
     """Generates WifiP2pDevice objects from a list of dictionary."""
-    return (cls.from_dict(device) for device in devices)
+    return [cls.from_dict(device) for device in devices]
 
 
 @dataclasses.dataclass(frozen=True)
@@ -261,5 +265,97 @@ class WifiP2pGroup:
       cls, groups: list[dict[str, Any]]
   ) -> Sequence[WifiP2pGroup]:
     """Generates WifiP2pGroup objects from a list of dictionary."""
-    return (cls.from_dict(group) for group in groups)
+    return [cls.from_dict(group) for group in groups]
 
+
+@enum.unique
+class ServiceType(enum.IntEnum):
+    """Indicates the type of Wi-Fi p2p services.
+
+    https://developer.android.com/reference/android/net/wifi/p2p/nsd/WifiP2pServiceInfo#summary
+    """
+
+    ALL = 0
+    BONJOUR = 1
+    UPNP = 2
+    WS_DISCOVERY = 3
+
+
+class ServiceData:
+    """Constants for Wi-Fi p2p services."""
+
+    # Service configurations.
+    # Configuration for Bonjour IPP local service.
+    IPP_DNS_SD = (('MyPrinter', '_ipp._tcp.local.'),)
+    AFP_DNS_SD = (('Example', '_afpovertcp._tcp.local.'),)
+    ALL_DNS_SD = (
+        ('MyPrinter', '_ipp._tcp.local.'),
+        ('Example', '_afpovertcp._tcp.local.'),
+    )
+
+    IPP_DNS_TXT = (
+        ('myprinter._ipp._tcp.local.', {
+            'txtvers': '1',
+            'pdl': 'application/postscript'
+        }),
+    )
+    AFP_DNS_TXT = (('example._afpovertcp._tcp.local.', {}),)
+    ALL_DNS_TXT = (('myprinter._ipp._tcp.local.',
+                    {
+                        'txtvers': '1',
+                        'pdl': 'application/postscript'
+                    }
+                    ), ('example._afpovertcp._tcp.local.', {}),)
+
+    # Configuration for IPP local service.
+    DEFAULT_IPP_SERVICE_CONF = {
+        'instance_name': 'MyPrinter',
+        'service_type': '_ipp._tcp',
+        'txt_map': {
+            'txtvers': '1',
+            'pdl': 'application/postscript'
+        },
+    }
+    # Configuration for AFP local service.
+    DEFAULT_AFP_SERVICE_CONF = {
+        'instance_name': 'Example',
+        'service_type': '_afpovertcp._tcp',
+        'txt_map': {},
+    }
+    # Configuration for UPnP MediaRenderer local service.
+    DEFAULT_UPNP_SERVICE_CONF = {
+        'uuid': '6859dede-8574-59ab-9332-123456789011',
+        'device': 'urn:schemas-upnp-org:device:MediaRenderer:1',
+        'services': [
+            'urn:schemas-upnp-org:service:AVTransport:1',
+            'urn:schemas-upnp-org:service:ConnectionManager:1',
+        ],
+    }
+
+    # Expected services to be discovered.
+    ALL_UPNP_SERVICES = (
+        'uuid:6859dede-8574-59ab-9332-123456789011',
+        'uuid:6859dede-8574-59ab-9332-123456789011::upnp:rootdevice',
+        (
+            'uuid:6859dede-8574-59ab-9332-123456789011::urn:schemas-upnp-org:'
+            'device:MediaRenderer:1'
+        ),
+        (
+            'uuid:6859dede-8574-59ab-9332-123456789011::urn:schemas-upnp-org:'
+            'service:AVTransport:1'
+        ),
+        (
+            'uuid:6859dede-8574-59ab-9332-123456789011::urn:schemas-upnp-org:'
+            'service:ConnectionManager:1'
+        ),
+    )
+
+    UPNP_ROOT_DEVICE = ('uuid:6859dede-8574-59ab-9332-123456789011::upnp:rootdevice',)
+
+
+class WifiP2pManagerConstants:
+    """Constants for Wi-Fi p2p manager.
+
+    https://developer.android.com/reference/android/net/wifi/p2p/WifiP2pManager#NO_SERVICE_REQUESTS
+    """
+    NO_SERVICE_REQUESTS = 3
diff --git a/tests/hostsidetests/multidevices/test/direct/group_owner_negotiation_test.py b/tests/hostsidetests/multidevices/test/direct/group_owner_negotiation_test.py
index 6742bdf8d9..d2dabd3367 100644
--- a/tests/hostsidetests/multidevices/test/direct/group_owner_negotiation_test.py
+++ b/tests/hostsidetests/multidevices/test/direct/group_owner_negotiation_test.py
@@ -15,376 +15,19 @@
 # Lint as: python3
 
 from collections.abc import Sequence
-import dataclasses
-import datetime
 import logging
 
+from android.platform.test.annotations import ApiTest
 from mobly import asserts
 from mobly import base_test
 from mobly import records
 from mobly import test_runner
 from mobly import utils
 from mobly.controllers import android_device
-from mobly.controllers.android_device_lib import callback_handler_v2
-from mobly.snippet import errors
 import wifi_test_utils
 
 from direct import constants
-
-_DEFAULT_TIMEOUT = datetime.timedelta(seconds=30)
-
-
-@dataclasses.dataclass(frozen=True)
-class DeviceState:
-    """All objects related to operating p2p snippet RPCs.
-
-    Attributes:
-        ad: The Android device controller object.
-        p2p_device: The object that represents a Wi-Fi p2p device.
-    """
-
-    ad: android_device.AndroidDevice
-    p2p_device: constants.WifiP2pDevice
-    broadcast_receiver: callback_handler_v2.CallbackHandlerV2
-
-
-def _setup_wifi_p2p(ad: android_device.AndroidDevice) -> DeviceState:
-    """Sets up Wi-Fi p2p for automation tests on an Android device."""
-    broadcast_receiver = _init_wifi_p2p(ad)
-    _delete_all_persistent_groups(ad)
-    p2p_device = _get_p2p_device(ad)
-    asserts.assert_not_equal(
-        p2p_device.device_address,
-        constants.ANONYMIZED_MAC_ADDRESS,
-        'Failed to get p2p device MAC address, please check permissions '
-        'required by API WifiP2pManager#requestConnectionInfo',
-    )
-    return DeviceState(
-        ad=ad, p2p_device=p2p_device, broadcast_receiver=broadcast_receiver
-    )
-
-
-def _init_wifi_p2p(
-    ad: android_device.AndroidDevice,
-) -> callback_handler_v2.CallbackHandlerV2:
-    """Registers the snippet app with the Wi-Fi p2p framework.
-
-    This must be the first to be called before any p2p operations are performed.
-
-    Args:
-        ad: The Android device controller object.
-
-    Returns:
-        The broadcast receiver from which you can get snippet events
-        corresponding to Wi-Fi p2p intents received on device.
-    """
-    broadcast_receiver = ad.wifi.wifiP2pInitialize()
-    init_event = broadcast_receiver.waitAndGet(
-        event_name=constants.WIFI_P2P_STATE_CHANGED_ACTION,
-        timeout=_DEFAULT_TIMEOUT.total_seconds(),
-    )
-    state = constants.ExtraWifiState(
-        init_event.data[constants.EXTRA_WIFI_STATE]
-    )
-    asserts.assert_equal(
-        state,
-        constants.ExtraWifiState.WIFI_P2P_STATE_ENABLED,
-        f'Failed to initialize Wi-Fi P2P, state: {state}',
-    )
-    return broadcast_receiver
-
-
-def _capture_p2p_intents(
-    ad: android_device.AndroidDevice,
-) -> callback_handler_v2.CallbackHandlerV2:
-    """Starts capturing Wi-Fi p2p intents and returns the intent receiver."""
-    broadcast_receiver = ad.wifi.wifiP2pCaptureP2pIntents()
-    return broadcast_receiver
-
-
-def _delete_all_persistent_groups(
-    ad: android_device.AndroidDevice,
-) -> None:
-    """Deletes all persistent Wi-Fi p2p groups."""
-    groups = _request_persistent_group_info(ad)
-    ad.log.debug('Wi-Fi p2p persistent groups before delete: %s', groups)
-    for group in groups:
-        result_data = ad.wifi.wifiP2pDeletePersistentGroup(group.network_id)
-        result = result_data[constants.EVENT_KEY_CALLBACK_NAME]
-        if result != constants.ACTION_LISTENER_ON_SUCCESS:
-            reason = constants.ActionListenerOnFailure(
-                result_data[constants.EVENT_KEY_REASON]
-            )
-            raise RuntimeError(
-                'Failed to delete persistent group with network id '
-                f'{group.network_id}. Reason: {reason.name}'
-            )
-    groups = _request_persistent_group_info(ad)
-    ad.log.debug('Wi-Fi p2p persistent groups after delete: %s', groups)
-
-
-def _request_persistent_group_info(
-    ad: android_device.AndroidDevice,
-) -> Sequence[constants.WifiP2pGroup]:
-    """Requests persistent group information."""
-    callback_handler = ad.wifi.wifiP2pRequestPersistentGroupInfo()
-    event = callback_handler.waitAndGet(
-        event_name=constants.ON_PERSISTENT_GROUP_INFO_AVAILABLE,
-        timeout=_DEFAULT_TIMEOUT.total_seconds(),
-    )
-    groups = constants.WifiP2pGroup.from_dict_list(event.data['groupList'])
-    return groups
-
-
-def _get_p2p_device(
-    ad: android_device.AndroidDevice,
-) -> constants.WifiP2pDevice:
-    """Gets the Wi-Fi p2p device information."""
-    callback_handler = ad.wifi.wifiP2pRequestDeviceInfo()
-    event = callback_handler.waitAndGet(
-        event_name=constants.ON_DEVICE_INFO_AVAILABLE,
-        timeout=_DEFAULT_TIMEOUT.total_seconds(),
-    )
-    return constants.WifiP2pDevice.from_dict(
-        event.data[constants.EVENT_KEY_P2P_DEVICE]
-    )
-
-
-def _find_p2p_device(
-    requester: DeviceState,
-    responder: DeviceState,
-) -> constants.WifiP2pDevice:
-    """Initiates Wi-Fi p2p discovery for the requester to find the responder.
-
-    This initiates Wi-Fi p2p discovery on both devices and checks that the
-    requester can discover responder and return peer p2p device.
-    """
-    requester.ad.log.debug('Discovering Wi-Fi P2P peers.')
-    responder.ad.wifi.wifiP2pDiscoverPeers()
-
-    _clear_events(requester, constants.WIFI_P2P_PEERS_CHANGED_ACTION)
-    requester.ad.wifi.wifiP2pDiscoverPeers()
-
-    event = requester.broadcast_receiver.waitAndGet(
-        event_name=constants.WIFI_P2P_PEERS_CHANGED_ACTION,
-        timeout=_DEFAULT_TIMEOUT.total_seconds(),
-    )
-    requester_peers = constants.WifiP2pDevice.from_dict_list(
-        event.data[constants.EVENT_KEY_PEER_LIST]
-    )
-
-    responder_mac = responder.p2p_device.device_address
-    filtered_peers = [
-        peer for peer in requester_peers if peer.device_address == responder_mac
-    ]
-    if len(filtered_peers) == 0:
-        asserts.fail(
-            f'{requester.ad} did not find the responder device. Responder MAC '
-            f'address: {responder_mac}, found peers: {requester_peers}.'
-        )
-    if len(filtered_peers) > 1:
-        asserts.fail(
-            f'{requester.ad} found more than one responder device. Responder '
-            f'MAC address: {responder_mac}, found peers: {requester_peers}.'
-        )
-    return filtered_peers[0]
-
-
-def _p2p_connect_with_push_button(
-    requester: DeviceState,
-    responder: DeviceState,
-) -> constants.WifiP2pDevice:
-    """Establishes Wi-Fi p2p connection with WPS push button configuration.
-
-    This initiates p2p connection on requester, accepts invitation on responder,
-    and checks connection status on both devices.
-
-    Args:
-        requester: The requester device.
-        responder: The respodner device.
-
-    Returns:
-        The peer p2p device found on the requester.
-    """
-    logging.info('Establishing a p2p connection through WPS PBC.')
-
-    # Clear events in broadcast receiver.
-    _clear_events(requester, constants.WIFI_P2P_PEERS_CHANGED_ACTION)
-    _clear_events(requester, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
-    _clear_events(responder, constants.WIFI_P2P_PEERS_CHANGED_ACTION)
-    _clear_events(responder, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
-
-    # Send P2P connect invitation from requester.
-    config = constants.WifiP2pConfig(
-        device_address=responder.p2p_device.device_address,
-        wps_setup=constants.WpsInfo.PBC,
-    )
-    requester.ad.wifi.wifiP2pConnect(config.to_dict())
-    requester.ad.log.info(
-        'Successfully sent P2P connect invitation to responder.'
-    )
-
-    # Click accept button on responder.
-    responder.ad.wifi.wifiP2pAcceptInvitation(requester.p2p_device.device_name)
-    responder.ad.log.info('Accepted connect invitation.')
-
-    # Check p2p status on requester.
-    _wait_connection_notice(requester.broadcast_receiver)
-    _wait_peer_connected(
-        requester.broadcast_receiver,
-        responder.p2p_device.device_address,
-    )
-    requester.ad.log.debug(
-        'Connected with device %s through wifi p2p.',
-        responder.p2p_device.device_address,
-    )
-
-    # Check p2p status on responder.
-    _wait_connection_notice(responder.broadcast_receiver)
-    _wait_peer_connected(
-        responder.broadcast_receiver,
-        requester.p2p_device.device_address,
-    )
-    responder.ad.log.debug(
-        'Connected with device %s through wifi p2p.',
-        requester.p2p_device.device_address,
-    )
-
-    logging.info('Established wifi p2p connection.')
-
-
-def _wait_peer_connected(
-    broadcast_receiver: callback_handler_v2.CallbackHandlerV2, peer_address: str
-):
-    """Waits for event that indicates expected Wi-Fi p2p peer is connected."""
-
-    def _is_peer_connected(event):
-        devices = constants.WifiP2pDevice.from_dict_list(event.data['peerList'])
-        for device in devices:
-            if (
-                device.device_address == peer_address
-                and device.status == constants.WifiP2pDeviceStatus.CONNECTED
-            ):
-                return True
-        return False
-
-    broadcast_receiver.waitForEvent(
-        event_name=constants.WIFI_P2P_PEERS_CHANGED_ACTION,
-        predicate=_is_peer_connected,
-        timeout=_DEFAULT_TIMEOUT.total_seconds(),
-    )
-
-
-def _wait_connection_notice(
-    broadcast_receiver: callback_handler_v2.CallbackHandlerV2,
-):
-    """Waits for event that indicates a p2p connection is established."""
-
-    def _is_group_formed(event):
-        try:
-            p2p_info = constants.WifiP2pInfo.from_dict(
-                event.data[constants.EVENT_KEY_P2P_INFO]
-            )
-            return p2p_info.group_formed
-        except KeyError:
-            return False
-
-    event = broadcast_receiver.waitForEvent(
-        event_name=constants.WIFI_P2P_CONNECTION_CHANGED_ACTION,
-        predicate=_is_group_formed,
-        timeout=_DEFAULT_TIMEOUT.total_seconds(),
-    )
-
-
-def _remove_group_and_verify_disconnected(
-    requester: DeviceState,
-    responder: DeviceState,
-):
-    """Stops p2p connection and verifies disconnection status on devices."""
-    logging.info('Stopping wifi p2p connection.')
-
-    # Clear events in broadcast receiver.
-    _clear_events(requester, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
-    _clear_events(requester, constants.ON_DEVICE_INFO_AVAILABLE)
-    _clear_events(responder, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
-    _clear_events(responder, constants.ON_DEVICE_INFO_AVAILABLE)
-
-    # Requester initiates p2p group removal.
-    requester.ad.wifi.wifiP2pRemoveGroup()
-
-    # Check p2p status on requester.
-    _wait_disconnection_notice(requester.broadcast_receiver)
-    _wait_peer_disconnected(
-        requester.broadcast_receiver, responder.p2p_device.device_address
-    )
-    requester.ad.log.debug(
-        'Disconnected with device %s through wifi p2p.',
-        responder.p2p_device.device_address,
-    )
-
-    # Check p2p status on responder.
-    _wait_disconnection_notice(responder.broadcast_receiver)
-    _wait_peer_disconnected(
-        responder.broadcast_receiver, requester.p2p_device.device_address
-    )
-    responder.ad.log.debug(
-        'Disconnected with device %s through wifi p2p.',
-        requester.p2p_device.device_address,
-    )
-
-    logging.info('Stopped wifi p2p connection.')
-
-
-def _wait_disconnection_notice(broadcast_receiver):
-    """Waits for event that indicates the p2p connection is disconnected."""
-
-    def _is_disconnect_event(event):
-        info = constants.WifiP2pInfo.from_dict(
-            event.data[constants.EVENT_KEY_P2P_INFO]
-        )
-        return not info.group_formed
-
-    broadcast_receiver.waitForEvent(
-        event_name=constants.WIFI_P2P_CONNECTION_CHANGED_ACTION,
-        predicate=_is_disconnect_event,
-        timeout=_DEFAULT_TIMEOUT.total_seconds(),
-    )
-
-
-def _wait_peer_disconnected(broadcast_receiver, target_address):
-    """Waits for event that indicates current Wi-Fi p2p peer is disconnected."""
-
-    def _is_peer_disconnect_event(event):
-        devices = constants.WifiP2pDevice.from_dict_list(
-            event.data[constants.EVENT_KEY_PEER_LIST]
-        )
-        for device in devices:
-            if device.device_address == target_address:
-                return device.status != constants.WifiP2pDeviceStatus.CONNECTED
-        # Target device not found also means it is disconnected.
-        return True
-
-    broadcast_receiver.waitForEvent(
-        event_name=constants.WIFI_P2P_PEERS_CHANGED_ACTION,
-        predicate=_is_peer_disconnect_event,
-        timeout=_DEFAULT_TIMEOUT.total_seconds(),
-    )
-
-
-def _clear_events(device: DeviceState, event_name):
-    """Clears the events with the given name in the broadcast receiver."""
-    all_events = device.broadcast_receiver.getAll(event_name)
-    device.ad.log.debug(
-        'Cleared %d events of event name %s', len(all_events), event_name
-    )
-
-
-def _teardown_wifi_p2p(ad: android_device.AndroidDevice):
-    """Destroys all resources initialized in `_setup_wifi_p2p`."""
-    ad.wifi.wifiP2pStopPeerDiscovery()
-    ad.wifi.wifiP2pCancelConnect()
-    ad.wifi.wifiP2pRemoveGroup()
-    ad.wifi.p2pClose()
+from direct import p2p_utils
 
 
 class GroupOwnerNegotiationTest(base_test.BaseTestClass):
@@ -406,46 +49,109 @@ class GroupOwnerNegotiationTest(base_test.BaseTestClass):
             raise_on_exception=True,
         )
 
-    def _setup_device(self, ad: android_device.AndroidDevice) -> DeviceState:
+    def _setup_device(self, ad: android_device.AndroidDevice) -> None:
         ad.load_snippet('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME)
         wifi_test_utils.set_screen_on_and_unlock(ad)
+        wifi_test_utils.enable_wifi_verbose_logging(ad)
         # Clear all saved Wi-Fi networks.
         ad.wifi.wifiDisable()
         ad.wifi.wifiClearConfiguredNetworks()
         ad.wifi.wifiEnable()
 
+    @ApiTest([
+        'android.net.wifi.p2p.WifiP2pManager#connect(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#discoverPeers(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
     def test_group_owner_negotiation_with_push_button(self) -> None:
         """Test against group owner negotiation and WPS PBC (push button).
 
         Steps:
             1. Initialize Wi-Fi p2p on both responder and requester device.
-            2. Initiate p2p discovery. Requester should be able to find
-               the responder.
+            2. Initiate p2p discovery. Verify that the requester finds the
+               responder.
             3. Establish a p2p connection with WPS PBC (push button
-               configuration). Requester initiates a connection request.
-               Responder clicks accept button to accept the connection.
-            4. Stop the connection.
+               configuration). Verify both devices show connection established
+               status.
+            4. Stop the connection. Verify both devices show connection stopped
+               status.
         """
-        responder = _setup_wifi_p2p(self.responder_ad)
-        requester = _setup_wifi_p2p(self.requester_ad)
+        logging.info('Initializing Wi-Fi p2p.')
+        responder = p2p_utils.setup_wifi_p2p(self.responder_ad)
+        requester = p2p_utils.setup_wifi_p2p(self.requester_ad)
+
+        requester.ad.log.info('Searching for target device.')
+        requester_peer_p2p_device = p2p_utils.discover_p2p_peer(
+            requester, responder
+        )
+        # Make sure that peer is not a group owner (GO) as this is testing
+        # against GO negotiation.
+        asserts.assert_false(
+            requester_peer_p2p_device.is_group_owner,
+            f'{requester.ad} found target responder device with invalid role.'
+            ' It should not be group owner.',
+        )
 
-        requester_peer_p2p_device = _find_p2p_device(requester, responder)
+        requester.ad.log.info('Trying to connect the peer device with WPS PBC.')
+        p2p_config = constants.WifiP2pConfig(
+            device_address=responder.p2p_device.device_address,
+            wps_setup=constants.WpsInfo.PBC,
+        )
+        p2p_utils.p2p_connect(requester, responder, p2p_config)
+
+        requester.ad.log.info('Disconnecting the peer device.')
+        p2p_utils.remove_group_and_verify_disconnected(
+            requester, responder, is_group_negotiation=True
+        )
 
+    @ApiTest([
+        'android.net.wifi.p2p.WifiP2pManager#connect(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#discoverPeers(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
+    def test_group_owner_negotiation_with_pin_button(self) -> None:
+        """Test against group owner negotiation and WPS PIN.
+
+        Steps:
+            1. Initialize Wi-Fi p2p on both responder and requester devices.
+            2. Initiate p2p discovery. Verify that the requester finds the
+               responder.
+            3. Establish a p2p connection using WPS PIN configuration. Verify
+               both devices show connection established status.
+            4. Stop the connection. Verify both devices show connection stopped
+               status.
+        """
+        logging.info('Initializing Wi-Fi p2p.')
+        responder = p2p_utils.setup_wifi_p2p(self.responder_ad)
+        requester = p2p_utils.setup_wifi_p2p(self.requester_ad)
+
+        requester.ad.log.info('Searching for target device.')
+        requester_peer_p2p_device = p2p_utils.discover_p2p_peer(
+            requester, responder
+        )
         # Make sure that peer is not a group owner (GO) as this is testing
         # against GO negotiation.
         asserts.assert_false(
             requester_peer_p2p_device.is_group_owner,
-            f'{requester} found target responder device with invalid role.'
+            f'{requester.ad} found target responder device with invalid role.'
             ' It should not be group owner.',
         )
 
-        _p2p_connect_with_push_button(requester, responder)
+        requester.ad.log.info('Trying to connect the peer device with WPS PIN.')
+        p2p_config = constants.WifiP2pConfig(
+            device_address=responder.p2p_device.device_address,
+            wps_setup=constants.WpsInfo.DISPLAY,
+        )
+        p2p_utils.p2p_connect(requester, responder, p2p_config)
 
-        _remove_group_and_verify_disconnected(requester, responder)
+        requester.ad.log.info('Disconnecting the peer device.')
+        p2p_utils.remove_group_and_verify_disconnected(
+            requester, responder, is_group_negotiation=True
+        )
 
     def _teardown_device(self, ad: android_device.AndroidDevice):
-        _teardown_wifi_p2p(ad)
-        ad.services.create_output_excerpts_all(self.current_test_info)
+        try:
+            p2p_utils.teardown_wifi_p2p(ad)
+        finally:
+            ad.services.create_output_excerpts_all(self.current_test_info)
 
     def teardown_test(self) -> None:
         utils.concurrent_exec(
diff --git a/tests/hostsidetests/multidevices/test/direct/group_owner_test.py b/tests/hostsidetests/multidevices/test/direct/group_owner_test.py
new file mode 100644
index 0000000000..f8221f1aae
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/group_owner_test.py
@@ -0,0 +1,267 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Test cases for p2p service discovery and group connection."""
+
+from collections.abc import Sequence
+import dataclasses
+import datetime
+import logging
+import time
+
+from android.platform.test.annotations import ApiTest
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+
+from direct import constants
+from direct import p2p_utils
+import wifi_test_utils
+
+
+class GroupOwnerTest(base_test.BaseTestClass):
+    """Test cases for p2p service discovery and group connection."""
+
+    ads: Sequence[android_device.AndroidDevice]
+    group_owner_ad: android_device.AndroidDevice
+    client_ad: android_device.AndroidDevice
+
+    def setup_class(self) -> None:
+        super().setup_class()
+        self.ads = self.register_controller(android_device, min_number=2)
+        utils.concurrent_exec(
+            self._setup_device,
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+        self.group_owner_ad, self.client_ad, *_ = self.ads
+        self.group_owner_ad.debug_tag = (
+            f'{self.group_owner_ad.serial}(Group Owner)'
+        )
+        self.client_ad.debug_tag = f'{self.client_ad.serial}(Client)'
+
+    def _setup_device(self, ad: android_device.AndroidDevice) -> None:
+        ad.load_snippet('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME)
+        wifi_test_utils.set_screen_on_and_unlock(ad)
+        wifi_test_utils.enable_wifi_verbose_logging(ad)
+        # Clear all saved Wi-Fi networks.
+        ad.wifi.wifiDisable()
+        ad.wifi.wifiClearConfiguredNetworks()
+        ad.wifi.wifiEnable()
+
+    @ApiTest([
+        'android.net.wifi.p2p.WifiP2pManager#createGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#removeGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
+    def test_connect_with_push_button(self) -> None:
+        """Test p2p client connects to the group owner with WPS PBC.
+
+        Steps:
+          1. Initialize Wi-Fi p2p on both group owner and client.
+          2. Add p2p local services on the group owner.
+          3. Create a p2p group on the group owner.
+          4. Add UPnP service request and initiate p2p service discovery on
+             the client. Verify that the client only discovers UPnP services.
+          5. Initiate p2p device discovery on the client. Verify that the client
+             discovers the group owner.
+          6. The client connects the group owner with WPS PBC (push button
+             configuration). Verify both devices show connection established
+             status.
+          7. Remove the p2p group on the requester. Verify both devices show
+             connection stopped status.
+        """
+        # This is a temporary workaround to avoid p2p service discovery
+        # conflicts previous wifi scan or p2p operations. Without sleeping,
+        # p2p service discovery process has a high failure rate.
+        time.sleep(10)
+
+        # Step 1. Initialize Wi-Fi p2p on both group owner and client.
+        logging.info('Initializing Wi-Fi p2p.')
+        group_owner = p2p_utils.setup_wifi_p2p(self.group_owner_ad)
+        client = p2p_utils.setup_wifi_p2p(self.client_ad)
+
+        # Step 2. Add p2p local services on the group owner.
+        self._add_local_services(group_owner)
+
+        # Step 3. Create a p2p group on the group owner.
+        group_owner.ad.log.debug('Creating a p2p group.')
+        p2p_utils.create_group(group_owner, config=None)
+
+        # Step 4. Add UPnP service request and initiate p2p service discovery on
+        # the client.
+        client.ad.log.info('Searching for target p2p services.')
+        # Only add UPnP service request.
+        client.ad.wifi.wifiP2pAddUpnpServiceRequest()
+        p2p_utils.set_upnp_response_listener(client)
+        p2p_utils.set_dns_sd_response_listeners(client)
+        client.ad.wifi.wifiP2pDiscoverServices()
+
+        # Client should only discover Upnp services, but not Bonjour services.
+        p2p_utils.check_discovered_services(
+            client,
+            expected_src_device_address=group_owner.p2p_device.device_address,
+            expected_dns_sd_sequence=(),
+            expected_dns_txt_sequence=(),
+            expected_upnp_sequence=constants.ServiceData.ALL_UPNP_SERVICES,
+        )
+
+        # Step 5 - 7. Verify that the client can join the group with WPS PBC.
+        self._test_join_group(
+            client,
+            group_owner,
+            constants.WpsInfo.PBC,
+        )
+
+    @ApiTest([
+        'android.net.wifi.p2p.WifiP2pManager#createGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#removeGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
+    def test_connect_with_pin_code(self) -> None:
+        """Test p2p client connects to the group owner with WPS DISPLAY.
+
+        Steps:
+        1. Initialize Wi-Fi p2p on both group owner and client.
+        2. Add p2p local services on the group owner.
+        3. Create a p2p group on the group owner.
+        4. Perform p2p service discovery on the client. Add Bonjour service
+           request to one p2p channel and initiate p2p service discovery on
+           another p2p channel. Verify that the client only discovers Bounjour
+           p2p services.
+        5. Initiate p2p device discovery on the client. Verify that the client
+           discovers the group owner.
+        6. The client connects the group owner with WPS PIN code. Verify both
+           devices show connection established status.
+        7. Remove the p2p group on the requester. Verify both devices show
+           connection stopped status.
+        """
+        # This is a temporary workaround to avoid p2p service discovery
+        # conflicts previous wifi scan or p2p operations. Without sleeping,
+        # p2p service discovery process has a high failure rate.
+        time.sleep(10)
+
+        # Step 1. Initialize Wi-Fi p2p on both group owner and client.
+        logging.info('Initializing Wi-Fi p2p.')
+        group_owner = p2p_utils.setup_wifi_p2p(self.group_owner_ad)
+        client = p2p_utils.setup_wifi_p2p(self.client_ad)
+        main_channel_id = client.channel_ids[0]
+
+        # Step 2. Add p2p local services on the group owner.
+        self._add_local_services(group_owner)
+
+        # Step 3. Create a p2p group on the group owner.
+        group_owner.ad.log.debug('Creating a p2p group.')
+        p2p_utils.create_group(group_owner, config=None)
+
+        # Step 4. Perform p2p service discovery on the client.
+        client.ad.log.info('Searching for target p2p services.')
+        # Initialize an extra p2p channel.
+        sub_channel_id = p2p_utils.init_extra_channel(client)
+        client.ad.wifi.wifiP2pAddBonjourServiceRequest(
+            None,  # serviceType
+            None,  # instanceName
+            sub_channel_id,
+        )
+        p2p_utils.set_upnp_response_listener(client, sub_channel_id)
+        p2p_utils.set_dns_sd_response_listeners(client, sub_channel_id)
+        # Discover services on the main channel.
+        client.ad.wifi.wifiP2pDiscoverServices(main_channel_id)
+
+        # Client should only discover Bonjour services, but not UPnP services.
+        p2p_utils.check_discovered_services(
+            client,
+            expected_src_device_address=group_owner.p2p_device.device_address,
+            expected_dns_sd_sequence=constants.ServiceData.ALL_DNS_SD,
+            expected_dns_txt_sequence=constants.ServiceData.ALL_DNS_TXT,
+            expected_upnp_sequence=(),
+            channel_id=sub_channel_id,
+        )
+
+        # Step 5 - 7. Verify that the client can join the group with WPS PIN.
+        self._test_join_group(
+            client,
+            group_owner,
+            constants.WpsInfo.DISPLAY,
+        )
+
+    def _add_local_services(self, device: p2p_utils.DeviceState) -> None:
+        """Adds local services on the given device."""
+        device.ad.log.debug('Setting up p2p local services.')
+        # Add local services on group owner.
+        p2p_utils.add_upnp_local_service(
+            device, constants.ServiceData.DEFAULT_UPNP_SERVICE_CONF
+        )
+        p2p_utils.add_bonjour_local_service(
+            device, constants.ServiceData.DEFAULT_IPP_SERVICE_CONF
+        )
+        p2p_utils.add_bonjour_local_service(
+            device, constants.ServiceData.DEFAULT_AFP_SERVICE_CONF
+        )
+
+    def _test_join_group(
+        self,
+        client: p2p_utils.DeviceState,
+        group_owner: p2p_utils.DeviceState,
+        wps_config: constants.WpsInfo,
+    ):
+        # Step 5. Initiate p2p device discovery on the client.
+        client.ad.log.info('Searching for the target group owner.')
+        peer_p2p_device = p2p_utils.discover_group_owner(
+            client=client,
+            group_owner_address=group_owner.p2p_device.device_address,
+        )
+        asserts.assert_true(
+            peer_p2p_device.is_group_owner,
+            f'P2p device {peer_p2p_device} should be group owner.',
+        )
+
+        # Step 6. The client connects the group owner.
+        p2p_config = constants.WifiP2pConfig(
+            device_address=group_owner.p2p_device.device_address,
+            wps_setup=wps_config,
+        )
+        client.ad.log.info('Trying to connect the group owner with p2p config: %s', p2p_config)
+        p2p_utils.p2p_connect(client, group_owner, p2p_config)
+
+        # Step 7. Remove the p2p group on the requester.
+        client.ad.log.info('Disconnecting with the group owner.')
+        p2p_utils.remove_group_and_verify_disconnected(
+            client, group_owner, is_group_negotiation=False
+        )
+
+    def _teardown_wifi_p2p(self, ad: android_device.AndroidDevice):
+        try:
+            p2p_utils.teardown_wifi_p2p(ad)
+        finally:
+            ad.services.create_output_excerpts_all(self.current_test_info)
+
+    def teardown_test(self) -> None:
+        utils.concurrent_exec(
+            self._teardown_wifi_p2p,
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+
+    def on_fail(self, record: records.TestResult) -> None:
+        logging.info('Collecting bugreports...')
+        android_device.take_bug_reports(
+            self.ads, destination=self.current_test_info.output_path
+        )
+
+
+if __name__ == '__main__':
+    test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/direct/group_owner_with_config_test.py b/tests/hostsidetests/multidevices/test/direct/group_owner_with_config_test.py
new file mode 100644
index 0000000000..664216fb5e
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/group_owner_with_config_test.py
@@ -0,0 +1,212 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Test cases that create p2p group with group configurations."""
+
+from collections.abc import Sequence
+import dataclasses
+import datetime
+import logging
+
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import signals
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+
+from direct import constants
+from direct import p2p_utils
+import wifi_test_utils
+from android.platform.test.annotations import ApiTest
+
+_FREQ_2G = 2447
+_GROUP_OWNER_DISCOVER_RETRY = 3
+
+
+class GroupOwnerWithConfigTest(base_test.BaseTestClass):
+    """Test cases that create p2p group with group configurations.
+
+    All tests in this class share the same test steps and expected results.
+    The difference is that they are testing against different p2p group
+    configurations.
+
+    Test Preconditions:
+        Two Android phones that support Wi-Fi Direct.
+
+    Test Steps:
+        1. Initialize Wi-Fi p2p on both devices.
+        2. Create a p2p group on one device (group owner device) with specific
+           group configuration. Verify its p2p role is group owner.
+        3. Initiate p2p device discovery on another device (client device).
+           Verify that it discovers the group owner.
+        4. The client connects the group owner with the same group
+           configuration. Verify both devices show connection established
+           status.
+        5. Remove the p2p group on the client. Verify both devices show
+           connection stopped status.
+    """
+
+    ads: Sequence[android_device.AndroidDevice]
+    group_owner_ad: android_device.AndroidDevice
+    client_ad: android_device.AndroidDevice
+
+    def setup_class(self) -> None:
+        self.ads = self.register_controller(android_device, min_number=2)
+        utils.concurrent_exec(
+            self._setup_device,
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+        self.group_owner_ad, self.client_ad, *_ = self.ads
+        self.group_owner_ad.debug_tag = (
+            f'{self.group_owner_ad.serial}(Group Owner)'
+        )
+        self.client_ad.debug_tag = f'{self.client_ad.serial}(Client)'
+
+    def _setup_device(self, ad: android_device.AndroidDevice) -> None:
+        ad.load_snippet('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME)
+        wifi_test_utils.set_screen_on_and_unlock(ad)
+        wifi_test_utils.enable_wifi_verbose_logging(ad)
+        # Clear all saved Wi-Fi networks.
+        ad.wifi.wifiDisable()
+        ad.wifi.wifiClearConfiguredNetworks()
+        ad.wifi.wifiEnable()
+
+    @ApiTest([
+        'android.net.wifi.p2p.WifiP2pManager#createGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#removeGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
+    def test_p2p_group_with_band_auto(self) -> None:
+        """Tests p2p group without specifying band or frequency.
+
+        See class docstring for the test steps and expected results.
+        """
+        self._test_create_and_join_p2p_group(
+            constants.WifiP2pConfig(
+                network_name='DIRECT-XY-HELLO-%s' % utils.rand_ascii_str(5),
+                passphrase='PWD-%s' % utils.rand_ascii_str(5),
+                group_operating_band=None,
+                group_operating_frequency=None,
+            )
+        )
+
+    @ApiTest([
+        'android.net.wifi.p2p.WifiP2pManager#createGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#removeGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
+    def test_p2p_group_with_band_2g(self) -> None:
+        """Tests p2p group by forcing the system to pick the frequency from
+        the 2.4GHz band.
+
+        See class docstring for the test steps and expected results.
+        """
+        network_name = 'DIRECT-XY-HELLO-2.4G-%s' % utils.rand_ascii_str(5)
+        self._test_create_and_join_p2p_group(
+            constants.WifiP2pConfig(
+                network_name=network_name,
+                passphrase='PWD-%s' % utils.rand_ascii_str(5),
+                group_operating_band=constants.Band.GROUP_OWNER_BAND_2GHZ,
+                group_operating_frequency=None,
+            )
+        )
+
+    @ApiTest([
+        'android.net.wifi.p2p.WifiP2pManager#createGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#removeGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
+    def test_p2p_group_with_fixed_frequency(self) -> None:
+        """Tests p2p group by forcing the system to a fixed operating frequency.
+
+        See class docstring for the test steps and expected results.
+        """
+        network_name = (
+            'DIRECT-XY-HELLO-%dMHz-%s' % ( _FREQ_2G, utils.rand_ascii_str(5))
+        )
+        self._test_create_and_join_p2p_group(
+            constants.WifiP2pConfig(
+                network_name=network_name,
+                passphrase='PWD-%s' % utils.rand_ascii_str(5),
+                group_operating_band=None,
+                group_operating_frequency=_FREQ_2G,
+            )
+        )
+
+    def _test_create_and_join_p2p_group(
+        self, p2p_config: constants.WifiP2pConfig
+    ):
+        # Step 1. Initialize Wi-Fi p2p on both devices.
+        group_owner = p2p_utils.setup_wifi_p2p(self.group_owner_ad)
+        client = p2p_utils.setup_wifi_p2p(self.client_ad)
+
+        # Step 2. Create a p2p group on one device (group owner device) with
+        # specific group configuration.
+        p2p_utils.create_group(group_owner, config=p2p_config)
+
+        # Step 3. Initiate p2p device discovery on the client device.
+        # Adding a retry because GC might fail to discover GO in one scan
+        # attempt. GO is operating on channel 149, P2P protocol scans channel
+        # 149 only once as a part of full scan in P2P_FIND.
+        for i in range(_GROUP_OWNER_DISCOVER_RETRY):
+            try:
+                peer_p2p_device = p2p_utils.discover_group_owner(
+                    client=client,
+                    group_owner_address=group_owner.p2p_device.device_address
+                )
+                break
+            except signals.TestFailure:
+                if i == _GROUP_OWNER_DISCOVER_RETRY - 1:
+                    raise
+                client.ad.log.exception(
+                    'Failed to discover group owner %s. Trying again...',
+                    group_owner.p2p_device.device_address
+                )
+        asserts.assert_true(
+            peer_p2p_device.is_group_owner,
+            f'P2p device {peer_p2p_device} should be group owner.',
+        )
+
+        # Step 4. The client connects the group owner with the same p2p group
+        # configuration.
+        p2p_utils.p2p_connect(client, group_owner, p2p_config)
+
+        # Step 5. Remove the p2p group on the client.
+        p2p_utils.remove_group_and_verify_disconnected(
+            client, group_owner, is_group_negotiation=False
+        )
+
+    def _teardown_wifi_p2p(self, ad: android_device.AndroidDevice):
+        try:
+            p2p_utils.teardown_wifi_p2p(ad)
+        finally:
+            ad.services.create_output_excerpts_all(self.current_test_info)
+
+    def teardown_test(self) -> None:
+        utils.concurrent_exec(
+            self._teardown_wifi_p2p,
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+
+    def on_fail(self, record: records.TestResult) -> None:
+        logging.info('Collecting bugreports...')
+        android_device.take_bug_reports(
+            self.ads, destination=self.current_test_info.output_path
+        )
+
+
+if __name__ == '__main__':
+    test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/direct/integration/Android.bp b/tests/hostsidetests/multidevices/test/direct/integration/Android.bp
new file mode 100644
index 0000000000..6ee454d34a
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/integration/Android.bp
@@ -0,0 +1,72 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_fwk_wifi_hal",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+python_library_host {
+    name: "wifi_p2p_lib",
+    srcs: ["wifi_p2p_lib.py"],
+}
+
+python_test_host {
+    name: "WifiP2pGroupTestCases",
+    main: "wifi_p2p_group_test.py",
+    srcs: [
+        "wifi_p2p_group_test.py",
+    ],
+    libs: [
+        "mobly",
+        "wifi_direct_constants",
+        "wifi_direct_test_utils",
+        "wifi_p2p_lib",
+        "wifi_test_utils",
+        "platform-test-py-annotations",
+    ],
+    device_common_data: [":wifi_mobly_snippet"],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+    test_suites: ["general-tests"],
+}
+
+python_test_host {
+    name: "WifiP2pManagerTestCases",
+    main: "wifi_p2p_manager_test.py",
+    srcs: [
+        "wifi_p2p_manager_test.py",
+    ],
+    libs: [
+        "mobly",
+        "wifi_direct_constants",
+        "wifi_direct_test_utils",
+        "wifi_p2p_lib",
+        "wifi_test_utils",
+        "platform-test-py-annotations",
+    ],
+    device_common_data: [":wifi_mobly_snippet"],
+    test_options: {
+        unit_test: false,
+        tags: ["mobly"],
+    },
+    test_suites: ["general-tests"],
+    version: {
+        py3: {
+            embedded_launcher: true,
+        },
+    },
+}
diff --git a/tests/hostsidetests/multidevices/test/direct/integration/wifi_p2p_group_test.py b/tests/hostsidetests/multidevices/test/direct/integration/wifi_p2p_group_test.py
new file mode 100644
index 0000000000..86d5a2b3a9
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/integration/wifi_p2p_group_test.py
@@ -0,0 +1,197 @@
+#  Copyright (C) 2025 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""ACTS Wifi P2p Group Test reimplemented in Mobly."""
+
+from collections.abc import Sequence
+import datetime
+import time
+
+from android.platform.test.annotations import ApiTest
+from direct import constants
+from direct import p2p_utils
+from mobly import base_test
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+import wifi_p2p_lib as wp2putils
+
+
+_DEFAULT_TIMEOUT = datetime.timedelta(seconds=30)
+DEFAULT_SLEEPTIME = 5
+_DEFAULT_FUNCTION_SWITCH_TIME = 10
+_DEFAULT_GROUP_CLIENT_LOST_TIME = 60
+
+P2P_CONNECT_NEGOTIATION = 0
+P2P_CONNECT_JOIN = 1
+P2P_CONNECT_INVITATION = 2
+
+WPS_PBC = wp2putils.WifiP2PEnums.WpsInfo.WIFI_WPS_INFO_PBC
+WPS_DISPLAY = wp2putils.WifiP2PEnums.WpsInfo.WIFI_WPS_INFO_DISPLAY
+WPS_KEYPAD = wp2putils.WifiP2PEnums.WpsInfo.WIFI_WPS_INFO_KEYPAD
+
+
+class WifiP2pGroupTest(base_test.BaseTestClass):
+    """Tests Wi-Fi Direct between 2 Android devices."""
+
+    ads: Sequence[android_device.AndroidDevice]
+    group_owner_ad: android_device.AndroidDevice
+    client_ad: android_device.AndroidDevice
+    network_name = 'DIRECT-xy-Hello'
+    passphrase = 'P2pWorld1234'
+    group_band = '2'
+
+    def setup_class(self) -> None:
+        super().setup_class()
+        self.ads = self.register_controller(android_device, min_number=2)
+        utils.concurrent_exec(
+            self._setup_device,
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+        self.group_owner_ad, self.client_ad, *_ = self.ads
+        self.group_owner_ad.debug_tag = (
+            f'{self.group_owner_ad.serial}(Group Owner)'
+        )
+        self.client_ad.debug_tag = f'{self.client_ad.serial}(Client)'
+
+    def _setup_device(self, ad: android_device.AndroidDevice) -> None:
+        ad.load_snippet('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME)
+        # Clear all saved Wi-Fi networks.
+        ad.wifi.wifiDisable()
+        ad.wifi.wifiClearConfiguredNetworks()
+        ad.wifi.wifiEnable()
+
+    def teardown_test(self) -> None:
+        for ad in self.ads:
+            ad.wifi.p2pClose()
+
+        utils.concurrent_exec(
+            lambda d: d.services.create_output_excerpts_all(
+                self.current_test_info
+            ),
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+
+    def p2p_group_join(self, wps_config: constants.WpsInfo):
+        """General flow for p2p group join.
+
+        Steps:
+        1. GO creates a group.
+        2. GC joins the group.
+        3. connection check via ping from GC to GO
+
+        Args:
+            wps_config: WPS configuration for the group.
+        """
+        go_dut = self.ads[0]
+        gc_dut = self.ads[1]
+
+        go_dut.log.info('Initializing Wi-Fi p2p.')
+        group_owner = p2p_utils.setup_wifi_p2p(go_dut)
+        client = p2p_utils.setup_wifi_p2p(gc_dut)
+        # Create a group.
+        p2p_utils.create_group(group_owner, config=None)
+        time.sleep(_DEFAULT_FUNCTION_SWITCH_TIME)
+
+        # Request the connection.
+        wp2putils.p2p_connect(client, group_owner, False, wps_config,
+                              p2p_connect_type=P2P_CONNECT_JOIN)
+
+        go_ip = wp2putils.p2p_go_ip(gc_dut)
+        wp2putils.p2p_connection_ping_test(gc_dut, go_ip)
+        # Trigger p2p disconnect.
+        p2p_utils.remove_group_and_verify_disconnected(
+            client, group_owner, is_group_negotiation=False
+        )
+        time.sleep(_DEFAULT_FUNCTION_SWITCH_TIME)
+
+    @ApiTest([
+        'android.net.wifi.WpsInfo#PBC',
+        'android.net.wifi.p2p.WifiP2pManager#createGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#connect(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#removeGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
+    def test_p2p_group_join_via_pbc(self):
+        """Verify the p2p creates a group and join this group via WPS PBC method."""
+        self.p2p_group_join(constants.WpsInfo.PBC)
+
+    @ApiTest([
+        'android.net.wifi.WpsInfo#DISPLAY',
+        'android.net.wifi.p2p.WifiP2pManager#createGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#connect(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#removeGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
+    def test_p2p_group_join_via_display(self):
+        """Verify the p2p creates a group and join this group via WPS DISPLAY method."""
+        self.p2p_group_join(WPS_DISPLAY)
+
+    @ApiTest([
+        'android.net.wifi.p2p.WifiP2pConfig.Builder#setPassphrase(String passphrase)',
+        'android.net.wifi.p2p.WifiP2pConfig.Builder#setGroupOperatingBand(int band)',
+        'android.net.wifi.p2p.WifiP2pManager#createGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#connect(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pConfig, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+        'android.net.wifi.p2p.WifiP2pManager#removeGroup(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)',
+    ])
+    def test_p2p_group_with_config(self):
+        """Verify the p2p creates a group and join this group with config.
+
+        Steps:
+        1. GO creates a group with config.
+        2. GC joins the group with config.
+        3. connection check via ping from GC to GO
+        """
+        go_dut = self.ads[0]
+        gc_dut = self.ads[1]
+        # Initialize Wi-Fi p2p on both devices.
+        group_owner = p2p_utils.setup_wifi_p2p(go_dut)
+        client = p2p_utils.setup_wifi_p2p(gc_dut)
+
+        # Create a p2p group on one device (group owner device) with
+        # specific group configuration.
+        p2p_config = constants.WifiP2pConfig(
+            network_name='DIRECT-XY-HELLO-%s' % utils.rand_ascii_str(5),
+            passphrase=self.passphrase,
+            group_operating_band=self.group_band,
+        )
+        p2p_utils.create_group(group_owner, config=p2p_config)
+        time.sleep(_DEFAULT_FUNCTION_SWITCH_TIME)
+        # Request the connection. Since config is known, this is reconnection.
+        p2p_utils.p2p_connect(client, group_owner, p2p_config)
+
+        go_ip = wp2putils.p2p_go_ip(gc_dut)
+        wp2putils.p2p_connection_ping_test(gc_dut, go_ip)
+        # Trigger disconnect.
+        p2p_utils.remove_group_and_verify_disconnected(
+            client, group_owner, is_group_negotiation=False
+        )
+        time.sleep(_DEFAULT_FUNCTION_SWITCH_TIME)
+
+if __name__ == '__main__':
+  test_runner.main()
+
diff --git a/tests/hostsidetests/multidevices/test/direct/integration/wifi_p2p_lib.py b/tests/hostsidetests/multidevices/test/direct/integration/wifi_p2p_lib.py
new file mode 100644
index 0000000000..c6a50e6719
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/integration/wifi_p2p_lib.py
@@ -0,0 +1,753 @@
+"""WiFi P2P library for multi-devices tests."""
+#  Copyright (C) 2025 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+
+from collections.abc import Sequence
+import datetime
+import time
+
+from direct import constants
+from direct import p2p_utils
+from mobly import asserts
+from mobly.controllers import android_device
+from mobly.controllers.android_device_lib import adb
+from mobly.controllers.android_device_lib import callback_handler_v2
+from mobly.snippet import errors
+
+_DEFAULT_TIMEOUT = datetime.timedelta(seconds=30)
+_DEFAULT_SLEEPTIME = 5
+_DEFAULT_FUNCTION_SWITCH_TIME = 10
+_DEFAULT_SERVICE_WAITING_TIME = 20
+_NORMAL_TIMEOUT = datetime.timedelta(seconds=20)
+
+P2P_CONNECT_NEGOTIATION = 0
+P2P_CONNECT_JOIN = 1
+P2P_CONNECT_INVITATION = 2
+
+######################################################
+# Wifi P2p local service type
+####################################################
+P2P_LOCAL_SERVICE_UPNP = 0
+P2P_LOCAL_SERVICE_IPP = 1
+P2P_LOCAL_SERVICE_AFP = 2
+
+######################################################
+# Wifi P2p local service event
+####################################################
+
+DNSSD_EVENT = 'WifiP2pOnDnsSdServiceAvailable'
+DNSSD_TXRECORD_EVENT = 'WifiP2pOnDnsSdTxtRecordAvailable'
+UPNP_EVENT = 'WifiP2pOnUpnpServiceAvailable'
+
+DNSSD_EVENT_INSTANCENAME_KEY = 'InstanceName'
+DNSSD_EVENT_REGISTRATIONTYPE_KEY = 'RegistrationType'
+DNSSD_TXRECORD_EVENT_FULLDOMAINNAME_KEY = 'FullDomainName'
+DNSSD_TXRECORD_EVENT_TXRECORDMAP_KEY = 'TxtRecordMap'
+UPNP_EVENT_SERVICELIST_KEY = 'ServiceList'
+
+
+######################################################
+# Wifi P2p UPnP MediaRenderer local service
+######################################################
+class UpnpTestData():
+    av_transport = 'urn:schemas-upnp-org:service:AVTransport:1'
+    connection_manager = 'urn:schemas-upnp-org:service:ConnectionManager:1'
+    service_type = 'urn:schemas-upnp-org:device:MediaRenderer:1'
+    uuid = '6859dede-8574-59ab-9332-123456789011'
+    rootdevice = 'upnp:rootdevice'
+
+
+######################################################
+# Wifi P2p Bonjour IPP & AFP local service
+######################################################
+class IppTestData():
+    ipp_instance_name = 'MyPrinter'
+    ipp_registration_type = '_ipp._tcp'
+    ipp_domain_name = 'myprinter._ipp._tcp.local.'
+    ipp_txt_record = {'txtvers': '1', 'pdl': 'application/postscript'}
+
+
+class AfpTestData():
+    afp_instance_name = 'Example'
+    afp_registration_type = '_afpovertcp._tcp'
+    afp_domain_name = 'example._afpovertcp._tcp.local.'
+    afp_txt_record = {}
+
+
+# Trigger p2p connect to device_go from device_gc.
+def p2p_connect(
+    device_gc: p2p_utils.DeviceState,
+    device_go: p2p_utils.DeviceState,
+    is_reconnect,
+    wps_setup,
+    p2p_connect_type=P2P_CONNECT_NEGOTIATION,
+    go_ad=None,
+):
+  """Trigger p2p connect to ad2 from ad1.
+
+  Args:
+      device_gc: The android device (Client)
+      device_go: The android device (GO)
+      is_reconnect: boolean, if persist group is exist, is_reconnect is true,
+        otherswise is false.
+      wps_setup: which wps connection would like to use
+      p2p_connect_type: enumeration, which type this p2p connection is
+      go_ad: The group owner android device which is used for the invitation
+        connection
+  """
+  device_gc.ad.log.info(
+      'Create p2p connection from %s to %s via wps: %s type %d',
+      device_gc.ad.serial,
+      device_go.ad.serial,
+      wps_setup,
+      p2p_connect_type,
+  )
+
+  if p2p_connect_type == P2P_CONNECT_INVITATION:
+    if go_ad is None:
+      go_ad = device_gc
+    p2p_utils.discover_p2p_peer(device_gc, device_go)
+    # GO might be another peer, so ad2 needs to find it first.
+    p2p_utils.discover_group_owner(
+        client=device_go, group_owner_address=go_ad.p2p_device.device_address
+    )
+  elif p2p_connect_type == P2P_CONNECT_JOIN:
+    peer_p2p_device = p2p_utils.discover_group_owner(
+        client=device_gc,
+        group_owner_address=device_go.p2p_device.device_address,
+    )
+    asserts.assert_true(
+        peer_p2p_device.is_group_owner,
+        f'P2p device {peer_p2p_device} should be group owner.',
+    )
+  else:
+    p2p_utils.discover_p2p_peer(device_gc, device_go)
+  time.sleep(_DEFAULT_SLEEPTIME)
+  device_gc.ad.log.info(
+      'from device1: %s -> device2: %s',
+      device_gc.p2p_device.device_address,
+      device_go.p2p_device.device_address,
+  )
+  p2p_config = constants.WifiP2pConfig(
+      device_address=device_go.p2p_device.device_address,
+      wps_setup=wps_setup,
+  )
+  if not is_reconnect:
+    p2p_utils.p2p_connect(device_gc, device_go, p2p_config)
+  else:
+    p2p_utils.p2p_reconnect(device_gc, device_go, p2p_config)
+
+
+def is_go(ad):
+  """Check an Android p2p role is Go or not.
+
+  Args:
+      ad: The android device
+
+  Returns:
+      True: An Android device is p2p go
+      False: An Android device is p2p gc
+  """
+  callback_handler = ad.wifi.wifiP2pRequestConnectionInfo()
+  event = callback_handler.waitAndGet(
+      event_name=constants.ON_CONNECTION_INFO_AVAILABLE,
+      timeout=_DEFAULT_TIMEOUT.total_seconds(),
+  )
+  if event.data['isGroupOwner']:
+    return True
+  return False
+
+
+def p2p_go_ip(ad):
+  """Get Group Owner IP address.
+
+  Args:
+      ad: The android device
+
+  Returns:
+      GO IP address
+  """
+  event_handler = ad.wifi.wifiP2pRequestConnectionInfo()
+  result = event_handler.waitAndGet(
+      event_name=constants.ON_CONNECTION_INFO_AVAILABLE,
+      timeout=_DEFAULT_TIMEOUT.total_seconds(),
+  )
+  go_flag = result.data['isGroupOwner']
+  ip = result.data['groupOwnerHostAddress'].replace('/', '')
+  ad.log.info('is_go:%s, p2p ip: %s', go_flag, ip)
+  return ip
+
+
+def p2p_disconnect(ad):
+  """Invoke an Android device removeGroup to trigger p2p disconnect.
+
+  Args:
+      ad: The android device
+  """
+  ad.log.debug('P2p Disconnect')
+  try:
+    ad.wifi.wifiP2pStopPeerDiscovery()
+    ad.wifi.wifiP2pCancelConnect()
+    ad.wifi.wifiP2pRemoveGroup()
+  finally:
+    # Make sure to call `p2pClose`, otherwise `_setup_wifi_p2p` won't be
+    # able to run again.
+    ad.wifi.p2pClose()
+
+
+def p2p_connection_ping_test(dut: android_device.AndroidDevice, peer_ip: str):
+  """Run a ping over the specified device/link.
+
+  Args:
+      dut: Device on which to execute ping6.
+      peer_ip: Scoped IPv4 address of the peer to ping.
+  """
+  cmd = 'ping -c 3 -W 1 %s' % peer_ip
+  try:
+    dut.log.info(cmd)
+    results = dut.adb.shell(cmd)
+  except adb.AdbError:
+    time.sleep(1)
+    dut.log.info('CMD RETRY: %s', cmd)
+    results = dut.adb.shell(cmd)
+
+  dut.log.info(results)
+
+
+def gen_test_data(service_category):
+  """Based on service category to generator Test Data.
+
+  Args:
+      service_category: P2p local service type, Upnp or Bonjour
+
+  Returns:
+      TestData
+  """
+  test_data = []
+  if service_category == P2P_LOCAL_SERVICE_UPNP:
+    test_data.append(UpnpTestData.uuid)
+    test_data.append(UpnpTestData.service_type)
+    test_data.append(
+        [UpnpTestData.av_transport, UpnpTestData.connection_manager]
+    )
+  elif service_category == P2P_LOCAL_SERVICE_IPP:
+    test_data.append(IppTestData.ipp_instance_name)
+    test_data.append(IppTestData.ipp_registration_type)
+    test_data.append(IppTestData.ipp_txt_record)
+  elif service_category == P2P_LOCAL_SERVICE_AFP:
+    test_data.append(AfpTestData.afp_instance_name)
+    test_data.append(AfpTestData.afp_registration_type)
+    test_data.append(AfpTestData.afp_txt_record)
+
+  return test_data
+
+
+def create_p2p_local_service(ad, service_category):
+  """Based on service_category to create p2p local service on an Android device ad.
+
+  Args:
+      ad: The android device
+      service_category: p2p local service type, UPNP / IPP / AFP,
+  """
+  test_data = gen_test_data(service_category)
+  ad.log.info(
+      'LocalService = %s, %s, %s', test_data[0], test_data[1], test_data[2]
+  )
+  if service_category == P2P_LOCAL_SERVICE_UPNP:
+    ad.wifi.wifiP2pAddUpnpLocalService(test_data[0], test_data[1], test_data[2])
+  elif (
+      service_category == P2P_LOCAL_SERVICE_IPP
+      or service_category == P2P_LOCAL_SERVICE_AFP
+  ):
+    ad.wifi.wifiP2pAddBonjourLocalService(
+        test_data[0], test_data[1], test_data[2]
+    )
+
+
+def gen_expect_test_data(service_type, query_string1, query_string2):
+  """Based on serviceCategory to generator expect serviceList.
+
+  Args:
+      service_type: P2p local service type, Upnp or Bonjour
+      query_string1: Query String, NonNull
+      query_string2: Query String, used for Bonjour, Nullable
+
+  Returns:
+      expect_service_list: expect data generated.
+  """
+  expect_service_list = {}
+  if (
+      service_type
+      == WifiP2PEnums.WifiP2pServiceInfo.WIFI_P2P_SERVICE_TYPE_BONJOUR
+  ):
+    ipp_service = WifiP2PEnums.WifiP2pDnsSdServiceResponse()
+    afp_service = WifiP2PEnums.WifiP2pDnsSdServiceResponse()
+    if query_string1 == IppTestData.ipp_registration_type:
+      if query_string2 == IppTestData.ipp_instance_name:
+        ipp_service.instance_name = ''
+        ipp_service.registration_type = ''
+        ipp_service.full_domain_name = IppTestData.ipp_domain_name
+        ipp_service.txt_record_map = IppTestData.ipp_txt_record
+        expect_service_list[ipp_service.to_string()] = 1
+        return expect_service_list
+      ipp_service.instance_name = IppTestData.ipp_instance_name
+      ipp_service.registration_type = (
+          IppTestData.ipp_registration_type + '.local.'
+      )
+      ipp_service.full_domain_name = ''
+      ipp_service.txt_record_map = ''
+      expect_service_list[ipp_service.to_string()] = 1
+      return expect_service_list
+    elif query_string1 == AfpTestData.afp_registration_type:
+      if query_string2 == AfpTestData.afp_instance_name:
+        afp_service.instance_name = ''
+        afp_service.registration_type = ''
+        afp_service.full_domain_name = AfpTestData.afp_domain_name
+        afp_service.txt_record_map = AfpTestData.afp_txt_record
+        expect_service_list[afp_service.to_string()] = 1
+        return expect_service_list
+    ipp_service.instance_name = IppTestData.ipp_instance_name
+    ipp_service.registration_type = (
+        IppTestData.ipp_registration_type + '.local.'
+    )
+    ipp_service.full_domain_name = ''
+    ipp_service.txt_record_map = ''
+    expect_service_list[ipp_service.to_string()] = 1
+
+    ipp_service.instance_name = ''
+    ipp_service.registration_type = ''
+    ipp_service.full_domain_name = IppTestData.ipp_domain_name
+    ipp_service.txt_record_map = IppTestData.ipp_txt_record
+    expect_service_list[ipp_service.to_string()] = 1
+
+    afp_service.instance_name = AfpTestData.afp_instance_name
+    afp_service.registration_type = (
+        AfpTestData.afp_registration_type + '.local.'
+    )
+    afp_service.full_domain_name = ''
+    afp_service.txt_record_map = ''
+    expect_service_list[afp_service.to_string()] = 1
+
+    afp_service.instance_name = ''
+    afp_service.registration_type = ''
+    afp_service.full_domain_name = AfpTestData.afp_domain_name
+    afp_service.txt_record_map = AfpTestData.afp_txt_record
+    expect_service_list[afp_service.to_string()] = 1
+
+    return expect_service_list
+  elif (
+      service_type == WifiP2PEnums.WifiP2pServiceInfo.WIFI_P2P_SERVICE_TYPE_UPNP
+  ):
+    upnp_service = (
+        'uuid:' + UpnpTestData.uuid + '::' + (UpnpTestData.rootdevice)
+    )
+    expect_service_list[upnp_service] = 1
+    if query_string1 != 'upnp:rootdevice':
+      upnp_service = (
+          'uuid:' + UpnpTestData.uuid + ('::' + UpnpTestData.av_transport)
+      )
+      expect_service_list[upnp_service] = 1
+      upnp_service = (
+          'uuid:' + UpnpTestData.uuid + ('::' + UpnpTestData.connection_manager)
+      )
+      expect_service_list[upnp_service] = 1
+      upnp_service = (
+          'uuid:' + UpnpTestData.uuid + ('::' + UpnpTestData.service_type)
+      )
+      expect_service_list[upnp_service] = 1
+      upnp_service = 'uuid:' + UpnpTestData.uuid
+      expect_service_list[upnp_service] = 1
+
+  return expect_service_list
+
+
+def check_service_query_result(service_list, expect_service_list):
+  """Check serviceList same as expectServiceList or not.
+
+  Args:
+      service_list: ServiceList which get from query result
+      expect_service_list: ServiceList which hardcode in genExpectTestData
+
+  Returns:
+      True: serviceList  same as expectServiceList
+      False:Exist discrepancy between serviceList and expectServiceList
+  """
+  temp_service_list = service_list.copy()
+  temp_expect_service_list = expect_service_list.copy()
+  for service in service_list.keys():
+    if service in expect_service_list:
+      del temp_service_list[service]
+      del temp_expect_service_list[service]
+  return not temp_expect_service_list and not temp_service_list
+
+
+def _check_all_expect_data(expect_data: dict[str, int]) -> bool:
+  for _, v in expect_data.items():
+    if v == 1:
+      return False
+  return True
+
+
+def request_service_and_check_result(
+    ad_service_provider: p2p_utils.DeviceState,
+    ad_service_receiver: p2p_utils.DeviceState,
+    service_type: int,
+    query_string1,
+    query_string2,
+):
+  """Based on service type and query info, check service request result.
+
+  Check same as expect or not on an Android device ad_service_receiver.
+  And remove p2p service request after result check.
+
+  Args:
+      ad_service_provider: The android device which provide p2p local service
+      ad_service_receiver: The android device which query p2p local service
+      service_type: P2p local service type, Upnp or Bonjour
+      query_string1: Query String, NonNull
+      query_string2: Query String, used for Bonjour, Nullable
+
+  Returns:
+      0: if service request result is as expected.
+  """
+  expect_data = gen_expect_test_data(service_type, query_string1, query_string2)
+  p2p_utils.discover_p2p_peer(ad_service_receiver, ad_service_provider)
+  ad_service_receiver.ad.wifi.wifiP2pStopPeerDiscovery()
+  ad_service_receiver.ad.wifi.wifiP2pClearServiceRequests()
+  time.sleep(_DEFAULT_FUNCTION_SWITCH_TIME)
+
+  service_id = 0
+  if (
+      service_type
+      == WifiP2PEnums.WifiP2pServiceInfo.WIFI_P2P_SERVICE_TYPE_BONJOUR
+  ):
+    ad_service_receiver.ad.log.info(
+        'Request bonjour service in %s with Query String %s and %s '
+        % (ad_service_receiver.ad.serial, query_string1, query_string2)
+    )
+    ad_service_receiver.ad.log.info('expectData 1st %s' % expect_data)
+    if query_string1:
+      service_id = ad_service_receiver.ad.wifi.wifiP2pAddBonjourServiceRequest(
+          query_string2,  # instanceName
+          query_string1,  # serviceType
+      )
+    else:
+      service_id = ad_service_receiver.ad.wifi.wifiP2pAddServiceRequest(
+          service_type
+      )
+    time.sleep(_DEFAULT_FUNCTION_SWITCH_TIME)
+    ad_service_receiver.ad.log.info('service request id %s' % service_id)
+    p2p_utils.set_dns_sd_response_listeners(ad_service_receiver)
+    ad_service_receiver.ad.wifi.wifiP2pDiscoverServices()
+    ad_service_receiver.ad.log.info('Check Service Listener')
+    time.sleep(_DEFAULT_SERVICE_WAITING_TIME)
+    check_discovered_dns_sd_response(
+        ad_service_receiver,
+        expected_responses=expect_data,
+        expected_src_device_address=(
+            ad_service_provider.p2p_device.device_address
+        ),
+        channel_id=ad_service_receiver.channel_ids[0],
+        timeout=_NORMAL_TIMEOUT,
+    )
+    ad_service_receiver.ad.log.info('expectData 2nd %s' % expect_data)
+    check_discovered_dns_sd_txt_record(
+        ad_service_receiver,
+        expected_records=expect_data,
+        expected_src_device_address=(
+            ad_service_provider.p2p_device.device_address
+        ),
+        channel_id=ad_service_receiver.channel_ids[0],
+        timeout=_NORMAL_TIMEOUT,
+    )
+    got_all_expects = _check_all_expect_data(expect_data)
+    ad_service_receiver.ad.log.info(
+        'Got all the expect data : %s', got_all_expects
+    )
+    asserts.assert_true(
+        got_all_expects,
+        "Don't got all the expect data.",
+    )
+  elif (
+      service_type == WifiP2PEnums.WifiP2pServiceInfo.WIFI_P2P_SERVICE_TYPE_UPNP
+  ):
+    ad_service_receiver.ad.log.info(
+        'Request upnp service in %s with Query String %s '
+        % (ad_service_receiver.ad.serial, query_string1)
+    )
+    ad_service_receiver.ad.log.info('expectData %s' % expect_data)
+    if query_string1:
+      service_id = ad_service_receiver.ad.wifi.wifiP2pAddUpnpServiceRequest(
+          query_string1
+      )
+    else:
+      service_id = ad_service_receiver.ad.wifi.wifiP2pAddServiceRequest(
+          service_type
+      )
+    p2p_utils.set_upnp_response_listener(ad_service_receiver)
+    ad_service_receiver.ad.wifi.wifiP2pDiscoverServices()
+    ad_service_receiver.ad.log.info('Check Service Listener')
+    time.sleep(_DEFAULT_FUNCTION_SWITCH_TIME)
+    p2p_utils.check_discovered_services(
+        ad_service_receiver,
+        ad_service_provider.p2p_device.device_address,
+        expected_dns_sd_sequence=None,
+        expected_dns_txt_sequence=None,
+        expected_upnp_sequence=expect_data,
+    )
+  ad_service_receiver.ad.wifi.wifiP2pRemoveServiceRequest(service_id)
+  return 0
+
+
+def request_service_and_check_result_with_retry(
+    ad_service_provider,
+    ad_service_receiver,
+    service_type,
+    query_string1,
+    query_string2,
+    retry_count=3,
+):
+  """allow failures for requestServiceAndCheckResult.
+
+  Service
+
+      discovery might fail unexpectedly because the request packet might not be
+      received by the service responder due to p2p state switch.
+
+  Args:
+      ad_service_provider: The android device which provide p2p local service
+      ad_service_receiver: The android device which query p2p local service
+      service_type: P2p local service type, Upnp or Bonjour
+      query_string1: Query String, NonNull
+      query_string2: Query String, used for Bonjour, Nullable
+      retry_count: maximum retry count, default is 3
+  """
+  ret = 0
+  while retry_count > 0:
+    ret = request_service_and_check_result(
+        ad_service_provider,
+        ad_service_receiver,
+        service_type,
+        query_string1,
+        query_string2,
+    )
+    if ret == 0:
+      break
+    retry_count -= 1
+
+  asserts.assert_equal(0, ret, 'cannot find any services with retries.')
+
+
+def _check_no_discovered_service(
+    ad: android_device.AndroidDevice,
+    callback_handler: callback_handler_v2.CallbackHandlerV2,
+    event_name: str,
+    expected_src_device_address: str,
+    timeout: datetime.timedelta = _DEFAULT_TIMEOUT,
+):
+    """Checks that no service is received from the specified source device."""
+    def _is_expected_event(event):
+        src_device = constants.WifiP2pDevice.from_dict(
+            event.data['sourceDevice']
+        )
+        return src_device.device_address == expected_src_device_address
+
+    # Set to a small timeout to allow pulling all received events
+    if timeout.total_seconds() <= 1:
+        timeout = datetime.timedelta(seconds=1)
+    try:
+        event = callback_handler.waitForEvent(
+            event_name=event_name,
+            predicate=_is_expected_event,
+            timeout=timeout.total_seconds(),
+        )
+    except errors.CallbackHandlerTimeoutError:
+        # Timeout error is expected as there should not be any qualified service
+        return
+    asserts.assert_is_none(
+        event,
+        f'{ad} should not discover p2p service. Discovered: {event}',
+    )
+
+
+def check_discovered_dns_sd_response(
+    device: p2p_utils.DeviceState,
+    expected_responses: Sequence[Sequence[str, str]],
+    expected_src_device_address: str,
+    channel_id: int | None = None,
+    timeout: datetime.timedelta = _DEFAULT_TIMEOUT,
+):
+    """Check discovered DNS SD responses.
+
+    If no responses are expected, check that no DNS SD response appear within
+    timeout. Otherwise, wait for all expected responses within timeout.
+
+    This assumes that Bonjour service listener is set by
+    `set_dns_sd_response_listeners`.
+
+    Args:
+        device: The device that is discovering DNS SD responses.
+        expected_responses: The expected DNS SD responses.
+        expected_src_device_address: This only checks services that are from the
+            expected source device.
+        channel_id: The channel to check for expected responses.
+        timeout: The wait timeout.
+    """
+    channel_id = channel_id or device.channel_ids[0]
+    callback_handler = device.dns_sd_response_listeners[channel_id]
+
+    def _all_service_received(event):
+        nonlocal expected_responses
+        src_device = constants.WifiP2pDevice.from_dict(
+            event.data['sourceDevice']
+        )
+        if src_device.device_address != expected_src_device_address:
+            return False
+        registration_type = event.data['registrationType']
+        instance_name = event.data['instanceName']
+        service_item = instance_name + registration_type
+        device.ad.log.info('Received DNS SD response: %s', service_item)
+        if service_item in expected_responses:
+            expected_responses[service_item] = 0
+        _check_all_expect_data(expected_responses)
+
+    device.ad.log.info('Waiting for DNS SD services: %s', expected_responses)
+    # Set to a small timeout to allow pulling all received events
+    if timeout.total_seconds() <= 1:
+        timeout = datetime.timedelta(seconds=1)
+    try:
+        callback_handler.waitForEvent(
+            event_name=constants.ON_DNS_SD_SERVICE_AVAILABLE,
+            predicate=_all_service_received,
+            timeout=timeout.total_seconds(),
+        )
+    except errors.CallbackHandlerTimeoutError:
+        device.ad.log.info(f'need to wait for services: {expected_responses}')
+
+
+def check_discovered_dns_sd_txt_record(
+    device: p2p_utils.DeviceState,
+    expected_records: Sequence[Sequence[str, dict[str, str]]],
+    expected_src_device_address: str,
+    channel_id: int | None = None,
+    timeout: datetime.timedelta = _DEFAULT_TIMEOUT,
+):
+    """Check discovered DNS SD TXT records.
+
+    If no records are expected, check that no DNS SD TXT record appear within
+    timeout. Otherwise, wait for all expected records within timeout.
+
+    This assumes that Bonjour service listener is set by
+    `set_dns_sd_response_listeners`.
+
+    Args:
+        device: The device that is discovering DNS SD TXT records.
+        expected_records: The expected DNS SD TXT records.
+        expected_src_device_address: This only checks services that are from the
+            expected source device.
+        channel_id: The channel to check for expected records.
+        timeout: The wait timeout.
+    """
+    channel_id = channel_id or device.channel_ids[0]
+    idx = device.channel_ids.index(channel_id)
+    callback_handler = device.dns_sd_response_listeners[idx]
+
+    device.ad.log.info('Expected DNS SD TXT records: %s', expected_records)
+    def _all_service_received(event):
+        nonlocal expected_records
+        src_device = constants.WifiP2pDevice.from_dict(
+            event.data['sourceDevice']
+        )
+        if src_device.device_address != expected_src_device_address:
+            return False
+        full_domain_name = event.data['fullDomainName']
+        txt_record_map = event.data['txtRecordMap']
+        record_to_remove = full_domain_name + str(txt_record_map)
+        device.ad.log.info('Received DNS SD TXT record: %s', record_to_remove)
+        if record_to_remove in expected_records:
+            expected_records[record_to_remove] = 0
+        _check_all_expect_data(expected_records)
+
+    device.ad.log.info('Waiting for DNS SD TXT records: %s', expected_records)
+    # Set to a small timeout to allow pulling all received events
+    if timeout.total_seconds() <= 1:
+        timeout = datetime.timedelta(seconds=1)
+    try:
+        callback_handler.waitForEvent(
+            event_name=constants.ON_DNS_SD_TXT_RECORD_AVAILABLE,
+            predicate=_all_service_received,
+            timeout=timeout.total_seconds(),
+        )
+    except errors.CallbackHandlerTimeoutError:
+        device.ad.log.info(f'need to wait for services: {expected_records}')
+
+
+class WifiP2PEnums:
+  """Enums for WifiP2p."""
+
+  class WifiP2pConfig:
+    DEVICEADDRESS_KEY = 'deviceAddress'
+    WPSINFO_KEY = 'wpsInfo'
+    GO_INTENT_KEY = 'groupOwnerIntent'
+    NETID_KEY = 'netId'
+    NETWORK_NAME = 'networkName'
+    PASSPHRASE = 'passphrase'
+    GROUP_BAND = 'groupOwnerBand'
+
+  class WpsInfo:
+    WPS_SETUP_KEY = 'setup'
+    BSSID_KEY = 'BSSID'
+    WPS_PIN_KEY = 'pin'
+    WIFI_WPS_INFO_PBC = 0
+    WIFI_WPS_INFO_DISPLAY = 1
+    WIFI_WPS_INFO_KEYPAD = 2
+    WIFI_WPS_INFO_LABEL = 3
+    WIFI_WPS_INFO_INVALID = 4
+
+  class WifiP2pServiceInfo:
+    # Macros for wifi p2p.
+    WIFI_P2P_SERVICE_TYPE_ALL = 0
+    WIFI_P2P_SERVICE_TYPE_BONJOUR = 1
+    WIFI_P2P_SERVICE_TYPE_UPNP = 2
+    WIFI_P2P_SERVICE_TYPE_VENDOR_SPECIFIC = 255
+
+  class WifiP2pDnsSdServiceResponse:
+    instance_name = ''
+    registration_type = ''
+    full_domain_name = ''
+    txt_record_map = {}
+
+    def __init__(self):
+      pass
+
+    def to_string(self):
+      return (
+          self.instance_name
+          + self.registration_type
+          + (self.full_domain_name + str(self.txt_record_map))
+      )
diff --git a/tests/hostsidetests/multidevices/test/direct/integration/wifi_p2p_manager_test.py b/tests/hostsidetests/multidevices/test/direct/integration/wifi_p2p_manager_test.py
new file mode 100644
index 0000000000..d4d6dab7f8
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/integration/wifi_p2p_manager_test.py
@@ -0,0 +1,256 @@
+#  Copyright (C) 2025 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""ACTS Wifi P2pManager Test reimplemented in Mobly."""
+
+from collections.abc import Sequence
+import datetime
+import logging
+import time
+
+from android.platform.test.annotations import ApiTest
+from direct import constants
+from direct import p2p_utils
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+import wifi_p2p_lib as wp2putils
+
+
+_DEFAULT_TIMEOUT = datetime.timedelta(seconds=30)
+DEFAULT_SLEEPTIME = 5
+_DEFAULT_FUNCTION_SWITCH_TIME = 10
+_DEFAULT_GROUP_CLIENT_LOST_TIME = 60
+
+_WIFI_DIRECT_SNIPPET_KEY = 'wifi_direct_mobly_snippet'
+
+P2P_CONNECT_NEGOTIATION = 0
+P2P_CONNECT_JOIN = 1
+P2P_CONNECT_INVITATION = 2
+
+WPS_PBC = wp2putils.WifiP2PEnums.WpsInfo.WIFI_WPS_INFO_PBC
+WPS_DISPLAY = wp2putils.WifiP2PEnums.WpsInfo.WIFI_WPS_INFO_DISPLAY
+WPS_KEYPAD = wp2putils.WifiP2PEnums.WpsInfo.WIFI_WPS_INFO_KEYPAD
+
+
+class WifiP2pManagerTest(base_test.BaseTestClass):
+    """Tests Wi-Fi Direct between 2 Android devices."""
+
+    ads: Sequence[android_device.AndroidDevice]
+    group_owner_ad: android_device.AndroidDevice
+    client_ad: android_device.AndroidDevice
+    network_name = 'DIRECT-xy-Hello'
+    passphrase = 'P2pWorld1234'
+    group_band = '2'
+
+    def setup_class(self) -> None:
+        super().setup_class()
+        self.ads = self.register_controller(android_device, min_number=2)
+        utils.concurrent_exec(
+            self._setup_device,
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+        self.group_owner_ad, self.client_ad, *_ = self.ads
+        self.group_owner_ad.debug_tag = (
+            f'{self.group_owner_ad.serial}(Group Owner)'
+        )
+        self.client_ad.debug_tag = f'{self.client_ad.serial}(Client)'
+
+    def _setup_device(self, ad: android_device.AndroidDevice) -> None:
+        ad.load_snippet('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME)
+        # Clear all saved Wi-Fi networks.
+        ad.wifi.wifiDisable()
+        ad.wifi.wifiClearConfiguredNetworks()
+        ad.wifi.wifiEnable()
+
+    def _teardown_wifi_p2p(self, ad: android_device.AndroidDevice):
+        try:
+            p2p_utils.teardown_wifi_p2p(ad)
+        finally:
+            ad.services.create_output_excerpts_all(self.current_test_info)
+
+    def teardown_test(self) -> None:
+        utils.concurrent_exec(
+            self._teardown_wifi_p2p,
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+
+    def on_fail(self, record: records.TestResult) -> None:
+        logging.info('Collecting bugreports...')
+        android_device.take_bug_reports(
+            self.ads, destination=self.current_test_info.output_path
+        )
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.p2p.WifiP2pManager#discoverPeers(android.net.wifi.p2p.WifiP2pManager.Channel channel, android.net.wifi.p2p.WifiP2pManager.ActionListener listener)',
+        ]
+    )
+    def test_p2p_discovery(self):
+        """Verify the p2p discovery functionality.
+
+        Steps:
+        1. Discover the target device
+        2. Check the target device in peer list
+        """
+        self.ads[0].log.info('Device discovery')
+        responder = p2p_utils.setup_wifi_p2p(self.ads[0])
+        requester = p2p_utils.setup_wifi_p2p(self.ads[1])
+
+        requester.ad.log.info('Searching for target device.')
+        responder_p2p_dev = p2p_utils.discover_p2p_peer(responder, requester)
+        self.ads[0].log.info('name= %s, address=%s, group_owner=%s',
+                             responder_p2p_dev.device_name,
+                             responder_p2p_dev.device_address,
+                             responder_p2p_dev.is_group_owner)
+        requester_p2p_dev = p2p_utils.discover_p2p_peer(requester, responder)
+        self.ads[1].log.info('name= %s, address=%s, group_owner=%s',
+                             requester_p2p_dev.device_name,
+                             requester_p2p_dev.device_address,
+                             requester_p2p_dev.is_group_owner)
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.p2p.WifiP2pManager#requestConnectionInfo(android.net.wifi.p2p.WifiP2pManager.Channel channel, android.net.wifi.p2p.WifiP2pManager.ConnectionInfoListener listener)',
+            'android.net.wifi.p2p.WifiP2pManager#connect(android.net.wifi.p2p.WifiP2pManager.Channel channel, android.net.wifi.p2p.WifiP2pConfig config, android.net.wifi.p2p.WifiP2pManager.ActionListener listener)',
+        ]
+    )
+    def test_p2p_connect_via_pbc_and_ping_and_reconnect(self):
+        """Verify the p2p connect via pbc functionality.
+
+        Steps:
+        1. Request the connection which include discover the target device
+        2. check which dut is GO and which dut is GC
+        3. connection check via ping from GC to GO
+        4. disconnect
+        5. Trigger connect again from GO for reconnect test.
+        6. GO trigger disconnect
+        7. Trigger connect again from GC for reconnect test.
+        8. GC trigger disconnect
+        """
+        self.ads[0].log.info('Device initialize')
+        go_dut = self.ads[0]
+        gc_dut = self.ads[1]
+
+        logging.info('GO: %s, GC: %s', go_dut.serial, gc_dut.serial)
+        device_go = p2p_utils.setup_wifi_p2p(go_dut)
+        device_gc = p2p_utils.setup_wifi_p2p(gc_dut)
+        self.run_p2p_connect_and_ping(device_gc, device_go, WPS_PBC, False)
+        self.run_p2p_connect_and_ping(device_go, device_gc, WPS_PBC, True)
+        self.run_p2p_connect_and_ping(device_gc, device_go, WPS_PBC, True)
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.p2p.WifiP2pManager#requestConnectionInfo(android.net.wifi.p2p.WifiP2pManager.Channel channel, android.net.wifi.p2p.WifiP2pManager.ConnectionInfoListener listener)',
+            'android.net.wifi.p2p.WifiP2pManager#connect(android.net.wifi.p2p.WifiP2pManager.Channel channel, android.net.wifi.p2p.WifiP2pConfig config, android.net.wifi.p2p.WifiP2pManager.ActionListener listener)',
+        ]
+    )
+    def test_p2p_connect_via_display_and_ping_and_reconnect(self):
+        """Verify the p2p connect via display functionality.
+
+        Steps:
+        1. Request the connection which include discover the target device
+        2. check which dut is GO and which dut is GC
+        3. connection check via ping from GC to GO
+        4. disconnect
+        5. Trigger connect again from GO for reconnect test.
+        6. GO trigger disconnect
+        7. Trigger connect again from GC for reconnect test.
+        8. GC trigger disconnect
+        """
+        self.ads[0].log.info('Device initialize')
+        go_dut = self.ads[0]
+        gc_dut = self.ads[1]
+
+        logging.info('GO: %s, GC: %s', go_dut.serial, gc_dut.serial)
+        device_go = p2p_utils.setup_wifi_p2p(go_dut)
+        device_gc = p2p_utils.setup_wifi_p2p(gc_dut)
+        self.run_p2p_connect_and_ping(device_gc, device_go, WPS_DISPLAY, False)
+        self.run_p2p_connect_and_ping(device_go, device_gc, WPS_DISPLAY, True)
+        self.run_p2p_connect_and_ping(device_gc, device_go, WPS_DISPLAY, True)
+
+    @ApiTest(
+        apis=[
+            'android.net.wifi.p2p.WifiP2pManager#requestConnectionInfo(android.net.wifi.p2p.WifiP2pManager.Channel channel, android.net.wifi.p2p.WifiP2pManager.ConnectionInfoListener listener)',
+            'android.net.wifi.p2p.WifiP2pManager#connect(android.net.wifi.p2p.WifiP2pManager.Channel channel, android.net.wifi.p2p.WifiP2pConfig config, android.net.wifi.p2p.WifiP2pManager.ActionListener listener)',
+        ]
+    )
+    def test_p2p_connect_via_keypad_and_ping_and_reconnect(self):
+        """Verify the p2p connect via keypad functionality.
+
+        Steps:
+        1. Request the connection which include discover the target device
+        2. check which dut is GO and which dut is GC
+        3. connection check via ping from GC to GO
+        4. disconnect
+        5. Trigger connect again from GO for reconnect test.
+        6. GO trigger disconnect
+        7. Trigger connect again from GC for reconnect test.
+        8. GC trigger disconnect
+        """
+        self.ads[0].log.info('Device initialize')
+        go_dut = self.ads[0]
+        gc_dut = self.ads[1]
+
+        logging.info('GO: %s, GC: %s', go_dut.serial, gc_dut.serial)
+        device_go = p2p_utils.setup_wifi_p2p(go_dut)
+        device_gc = p2p_utils.setup_wifi_p2p(gc_dut)
+
+        self.run_p2p_connect_and_ping(device_gc, device_go, WPS_KEYPAD, False)
+        self.run_p2p_connect_and_ping(device_go, device_gc, WPS_KEYPAD, True)
+        self.run_p2p_connect_and_ping(device_gc, device_go, WPS_KEYPAD, True)
+
+    def run_p2p_connect_and_ping(
+        self,
+        device1,
+        device2,
+        pws_method,
+        re_connect):
+        # Request the connection
+        wp2putils.p2p_connect(device1, device2, re_connect, pws_method)
+
+        if wp2putils.is_go(device1.ad):
+            client_dut = device2.ad
+        else:
+            client_dut = device1.ad
+        logging.info('Client is : %s', client_dut.serial)
+        go_ip = wp2putils.p2p_go_ip(client_dut)
+        wp2putils.p2p_connection_ping_test(client_dut, go_ip)
+
+        # trigger disconnect
+        p2p_utils.remove_group_and_verify_disconnected(
+            device1, device2, is_group_negotiation=False
+        )
+        time.sleep(_DEFAULT_FUNCTION_SWITCH_TIME)
+
+if __name__ == '__main__':
+  test_runner.main()
+
diff --git a/tests/hostsidetests/multidevices/test/direct/p2p_utils.py b/tests/hostsidetests/multidevices/test/direct/p2p_utils.py
new file mode 100644
index 0000000000..72495cf0be
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/p2p_utils.py
@@ -0,0 +1,906 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# Lint as: python3
+
+from collections.abc import Sequence
+import dataclasses
+import datetime
+import logging
+import time
+
+from mobly import asserts
+from mobly.snippet import errors
+from mobly.controllers.android_device_lib import callback_handler_v2
+from mobly.controllers import android_device
+
+from direct import constants
+
+_DEFAULT_TIMEOUT = datetime.timedelta(seconds=45)
+_GROUP_OWNER_DISCOVERY_TIMEOUT = datetime.timedelta(seconds=60)
+_DEFAULT_UI_RESPONSE_TIME = datetime.timedelta(seconds=2)
+
+
+@dataclasses.dataclass
+class DeviceState:
+    """All objects related to operating p2p snippet RPCs.
+
+    Attributes:
+        ad: The Android device controller object.
+        p2p_device: The object that represents a Wi-Fi p2p device.
+        broadcast_receiver: The object for getting events that represent
+            Wi-Fi p2p broadcast intents on device.
+        channel_ids: The IDs of all p2p channels initialized by Mobly snippets.
+        upnp_response_listeners: Maps channel IDs to UPnP listeners. These
+            listeners correspond to UpnpServiceResponseListener on device.
+        dns_sd_response_listeners: Maps channel IDs to DNS SD listeners. These
+            listeners listen for callback invocation of
+            DnsSdServiceResponseListener and DnsSdTxtRecordListener.
+    """
+
+    ad: android_device.AndroidDevice
+    p2p_device: constants.WifiP2pDevice
+    broadcast_receiver: callback_handler_v2.CallbackHandlerV2
+    channel_ids: Sequence[int] = dataclasses.field(default_factory=list)
+    upnp_response_listeners: dict[int, callback_handler_v2.CallbackHandlerV2] = dataclasses.field(default_factory=dict)
+    dns_sd_response_listeners: dict[int, callback_handler_v2.CallbackHandlerV2] = dataclasses.field(default_factory=dict)
+
+
+def setup_wifi_p2p(ad: android_device.AndroidDevice) -> DeviceState:
+    """Sets up Wi-Fi p2p for automation tests on an Android device."""
+    broadcast_receiver = _init_wifi_p2p(ad)
+    _delete_all_persistent_groups(ad)
+    p2p_device = _get_p2p_device(ad)
+    asserts.assert_not_equal(
+        p2p_device.device_address,
+        constants.ANONYMIZED_MAC_ADDRESS,
+        f'{ad} failed to get p2p device MAC address, please check permissions '
+        'required by API WifiP2pManager#requestConnectionInfo',
+    )
+    return DeviceState(
+        ad=ad,
+        p2p_device=p2p_device,
+        broadcast_receiver=broadcast_receiver,
+        channel_ids=[broadcast_receiver.ret_value],
+    )
+
+
+def _init_wifi_p2p(
+    ad: android_device.AndroidDevice,
+) -> callback_handler_v2.CallbackHandlerV2:
+    """Registers the snippet app with the Wi-Fi p2p framework.
+
+    This must be the first to be called before any p2p operations are performed.
+
+    Args:
+        ad: The Android device controller object.
+
+    Returns:
+        The broadcast receiver from which you can get snippet events
+        corresponding to Wi-Fi p2p intents received on device.
+    """
+    broadcast_receiver = ad.wifi.wifiP2pInitialize()
+
+    def _is_p2p_enabled(event):
+        return (
+            event.data[constants.EXTRA_WIFI_STATE]
+            == constants.ExtraWifiState.WIFI_P2P_STATE_ENABLED
+        )
+
+    # Wait until receiving the "p2p enabled" event. We might receive a
+    # "p2p disabled" event before that.
+    broadcast_receiver.waitForEvent(
+        event_name=constants.WIFI_P2P_STATE_CHANGED_ACTION,
+        predicate=_is_p2p_enabled,
+        timeout=_DEFAULT_TIMEOUT.total_seconds(),
+    )
+    return broadcast_receiver
+
+
+def _capture_p2p_intents(
+    ad: android_device.AndroidDevice,
+) -> callback_handler_v2.CallbackHandlerV2:
+    """Starts capturing Wi-Fi p2p intents and returns the intent receiver."""
+    broadcast_receiver = ad.wifi.wifiP2pCaptureP2pIntents()
+    return broadcast_receiver
+
+
+def _delete_all_persistent_groups(
+    ad: android_device.AndroidDevice,
+) -> None:
+    """Deletes all persistent Wi-Fi p2p groups."""
+    groups = _request_persistent_group_info(ad)
+    ad.log.debug('Wi-Fi p2p persistent groups before delete: %s', groups)
+    for group in groups:
+        result_data = ad.wifi.wifiP2pDeletePersistentGroup(group.network_id)
+        result = result_data[constants.EVENT_KEY_CALLBACK_NAME]
+        if result != constants.ACTION_LISTENER_ON_SUCCESS:
+            reason = constants.ActionListenerOnFailure(
+                result_data[constants.EVENT_KEY_REASON]
+            )
+            raise RuntimeError(
+                'Failed to delete persistent group with network id '
+                f'{group.network_id}. Reason: {reason.name}'
+            )
+    groups = _request_persistent_group_info(ad)
+    ad.log.debug('Wi-Fi p2p persistent groups after delete: %s', groups)
+
+
+def _request_persistent_group_info(
+    ad: android_device.AndroidDevice,
+) -> Sequence[constants.WifiP2pGroup]:
+    """Requests persistent group information."""
+    callback_handler = ad.wifi.wifiP2pRequestPersistentGroupInfo()
+    event = callback_handler.waitAndGet(
+        event_name=constants.ON_PERSISTENT_GROUP_INFO_AVAILABLE,
+        timeout=_DEFAULT_TIMEOUT.total_seconds(),
+    )
+    groups = constants.WifiP2pGroup.from_dict_list(event.data['groupList'])
+    return groups
+
+
+def _get_p2p_device(
+    ad: android_device.AndroidDevice,
+) -> constants.WifiP2pDevice:
+    """Gets the Wi-Fi p2p device information."""
+    callback_handler = ad.wifi.wifiP2pRequestDeviceInfo()
+    event = callback_handler.waitAndGet(
+        event_name=constants.ON_DEVICE_INFO_AVAILABLE,
+        timeout=_DEFAULT_TIMEOUT.total_seconds(),
+    )
+    return constants.WifiP2pDevice.from_dict(
+        event.data[constants.EVENT_KEY_P2P_DEVICE]
+    )
+
+
+def init_extra_channel(device: DeviceState) -> int:
+  """Initializes an extra p2p channel and returns the channel ID."""
+  channel_id = device.ad.wifi.wifiP2pInitExtraChannel()
+  device.channel_ids.append(channel_id)
+  return channel_id
+
+
+def discover_p2p_peer(
+    requester: DeviceState,
+    responder: DeviceState,
+) -> constants.WifiP2pDevice:
+    """Initiates p2p peer discovery for the requester to find the responder.
+
+    This initiates p2p discovery on both devices and checks that the
+    requester can discover responder.
+
+    Returns:
+        The peer p2p device discovered on the client.
+    """
+    requester.ad.log.debug('Discovering Wi-Fi p2p peer %s.', responder.ad)
+    # Clear events in broadcast receiver before initiating peer discovery.
+    _clear_events(requester, constants.WIFI_P2P_PEERS_CHANGED_ACTION)
+
+    # Initiate peer discovery.
+    responder.ad.wifi.wifiP2pDiscoverPeers()
+    requester.ad.wifi.wifiP2pDiscoverPeers()
+
+    # Wait until found the p2p peer device with expected MAC address.
+    expected_address = responder.p2p_device.device_address
+
+    def _filter_target_p2p_device(event) -> Sequence[constants.WifiP2pDevice]:
+        peers = constants.WifiP2pDevice.from_dict_list(
+            event.data[constants.EVENT_KEY_PEER_LIST]
+        )
+        filtered_peers = [
+            peer for peer in peers if peer.device_address == expected_address
+        ]
+        return filtered_peers
+
+    try:
+        event = requester.broadcast_receiver.waitForEvent(
+            event_name=constants.WIFI_P2P_PEERS_CHANGED_ACTION,
+            predicate=lambda event: len(_filter_target_p2p_device(event)) > 0,
+            timeout=_DEFAULT_TIMEOUT.total_seconds(),
+        )
+    except errors.CallbackHandlerTimeoutError as e:
+        asserts.fail(
+            f'{requester.ad} did not find the responder device. Expected '
+            f'responder MAC: {expected_address}.'
+        )
+
+    # There should be only one expected p2p peer.
+    peers = _filter_target_p2p_device(event)
+    if len(peers) == 0:
+        asserts.fail(
+            f'{requester.ad} did not find the responder device. Expected '
+            f'responder MAC: {expected_address}, found event: {event}.'
+        )
+    if len(peers) > 1:
+        asserts.fail(
+            f'{requester.ad} found more than one responder device. Expected '
+            f'responder MAC: {expected_address}, found event: {event}.'
+        )
+    return peers[0]
+
+
+def discover_group_owner(
+    client: DeviceState,
+    group_owner_address: str,
+) -> constants.WifiP2pDevice:
+    """Initiates p2p peer discovery for the client to find expected group owner.
+
+    This requires that p2p group has already been established on the group
+    owner.
+
+    Args:
+        client: The device acts as p2p client.
+        group_owner_address: The expected MAC address of the group owner.
+
+    Returns:
+        The peer p2p device discovered on the client.
+    """
+    client.ad.log.debug(
+        'Discovering Wi-Fi p2p group owner %s.', group_owner_address
+    )
+    client.ad.wifi.wifiP2pDiscoverPeers()
+
+    # Wait until found the p2p peer device with expected MAC address. It must
+    # be a group owner.
+    def _filter_target_group_owner(event) -> Sequence[constants.WifiP2pDevice]:
+        peers = constants.WifiP2pDevice.from_dict_list(
+            event.data[constants.EVENT_KEY_PEER_LIST]
+        )
+        filtered_peers = [
+            peer
+            for peer in peers
+            if peer.device_address == group_owner_address
+            and peer.is_group_owner
+        ]
+        return filtered_peers
+
+    try:
+        event = client.broadcast_receiver.waitForEvent(
+            event_name=constants.WIFI_P2P_PEERS_CHANGED_ACTION,
+            predicate=lambda event: len(_filter_target_group_owner(event)) > 0,
+            timeout=_GROUP_OWNER_DISCOVERY_TIMEOUT.total_seconds(),
+        )
+    except errors.CallbackHandlerTimeoutError as e:
+        asserts.fail(
+            f'{client.ad} did not find the group owner device. Expected group '
+            f'owner MAC: {group_owner_address}.'
+        )
+
+    # There should be only one expected p2p peer.
+    peers = _filter_target_group_owner(event)
+    if len(peers) == 0:
+        asserts.fail(
+            f'{client.ad} did not find the group owner device. Expected group '
+            f'owner MAC: {group_owner_address}, got event: {event}.'
+        )
+    if len(peers) > 1:
+        asserts.fail(
+            f'{client.ad} found more than one group owner devices. Expected '
+            f'group owner MAC: {group_owner_address}, got event: {event}.'
+        )
+    return peers[0]
+
+
+def create_group(
+    device: DeviceState, config: constants.WifiP2pConfig | None = None
+):
+    """Creates a Wi-Fi p2p group on the given device."""
+    _clear_events(device, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
+
+    config = config.to_dict() if config else None
+    device.ad.wifi.wifiP2pCreateGroup(config)
+
+    # Wait until groupFormed=True
+    _wait_connection_notice(device.broadcast_receiver)
+
+
+def p2p_connect(
+    requester: DeviceState,
+    responder: DeviceState,
+    config: constants.WifiP2pConfig,
+) -> None:
+    """Establishes Wi-Fi p2p connection with WPS configuration.
+
+    This method instructs the requester to initiate a connection request and the
+    responder to accept the connection. It then verifies the connection status
+    on both devices.
+
+    Args:
+        requester: The requester device.
+        responder: The responder device.
+        config: The Wi-Fi p2p configuration.
+    """
+    logging.info(
+        'Establishing a p2p connection through p2p configuration %s.', config
+    )
+
+    # Clear events in broadcast receiver.
+    _clear_events(requester, constants.WIFI_P2P_PEERS_CHANGED_ACTION)
+    _clear_events(requester, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
+    _clear_events(responder, constants.WIFI_P2P_PEERS_CHANGED_ACTION)
+    _clear_events(responder, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
+
+    requester.ad.wifi.wifiP2pConnect(config.to_dict())
+    requester.ad.log.info('Sent P2P connect invitation to responder.')
+    # Connect with WPS config requires user inetraction through UI.
+    if config.wps_setup == constants.WpsInfo.PBC:
+        time.sleep(_DEFAULT_UI_RESPONSE_TIME.total_seconds())
+        responder.ad.wifi.wifiP2pAcceptInvitation(
+            requester.p2p_device.device_name
+        )
+        responder.ad.log.info('Accepted connect invitation.')
+    elif config.wps_setup == constants.WpsInfo.DISPLAY:
+        time.sleep(_DEFAULT_UI_RESPONSE_TIME.total_seconds())
+        pin = requester.ad.wifi.wifiP2pGetPinCode(
+            responder.p2p_device.device_name
+        )
+        requester.ad.log.info('p2p connection PIN code: %s', pin)
+        time.sleep(_DEFAULT_UI_RESPONSE_TIME.total_seconds())
+        responder.ad.wifi.wifiP2pEnterPin(pin, requester.p2p_device.device_name)
+        responder.ad.log.info('Enetered PIN code.')
+    elif config.wps_setup == constants.WpsInfo.KEYPAD:
+        time.sleep(_DEFAULT_UI_RESPONSE_TIME.total_seconds())
+        pin = responder.ad.wifi.wifiP2pGetKeypadPinCode(
+            requester.p2p_device.device_name
+        )
+        responder.ad.log.info('p2p connection Keypad PIN code: %s', pin)
+        time.sleep(_DEFAULT_UI_RESPONSE_TIME.total_seconds())
+        requester.ad.wifi.wifiP2pEnterPin(pin, responder.p2p_device.device_name)
+        requester.ad.log.info('Enetered Keypad PIN code.')
+    elif config.wps_setup is not None:
+        asserts.fail(f'Unsupported WPS configuration: {config.wps_setup}')
+
+    # Check p2p status on requester.
+    _wait_connection_notice(requester.broadcast_receiver)
+    _wait_peer_connected(
+        requester.broadcast_receiver,
+        responder.p2p_device.device_address,
+    )
+    requester.ad.log.debug(
+        'Connected with device %s through wifi p2p.',
+        responder.p2p_device.device_address,
+    )
+
+    # Check p2p status on responder.
+    _wait_connection_notice(responder.broadcast_receiver)
+    _wait_peer_connected(
+        responder.broadcast_receiver,
+        requester.p2p_device.device_address,
+    )
+    responder.ad.log.debug(
+        'Connected with device %s through wifi p2p.',
+        requester.p2p_device.device_address,
+    )
+    logging.info('Established wifi p2p connection.')
+
+
+def p2p_reconnect(
+    requester: DeviceState,
+    responder: DeviceState,
+    config: constants.WifiP2pConfig,
+) -> None:
+    """Establishes Wi-Fi p2p connection with WPS configuration.
+
+    This method instructs the requester to initiate a connection request and the
+    responder to accept the connection. It then verifies the connection status
+    on both devices.
+
+    Args:
+        requester: The requester device.
+        responder: The responder device.
+        config: The Wi-Fi p2p configuration.
+    """
+    logging.info(
+        'Establishing a p2p connection through p2p configuration %s.', config
+    )
+
+    # Clear events in broadcast receiver.
+    _clear_events(requester, constants.WIFI_P2P_PEERS_CHANGED_ACTION)
+    _clear_events(requester, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
+    _clear_events(responder, constants.WIFI_P2P_PEERS_CHANGED_ACTION)
+    _clear_events(responder, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
+
+    requester.ad.wifi.wifiP2pConnect(config.to_dict())
+    requester.ad.log.info('Sent P2P connect invitation to responder.')
+
+    # Check p2p status on requester.
+    _wait_connection_notice(requester.broadcast_receiver)
+    _wait_peer_connected(
+        requester.broadcast_receiver,
+        responder.p2p_device.device_address,
+    )
+    requester.ad.log.info(
+        'Connected with device %s through wifi p2p.',
+        responder.p2p_device.device_address,
+    )
+
+    # Check p2p status on responder.
+    _wait_connection_notice(responder.broadcast_receiver)
+    _wait_peer_connected(
+        responder.broadcast_receiver,
+        requester.p2p_device.device_address,
+    )
+    responder.ad.log.info(
+        'Connected with device %s through wifi p2p.',
+        requester.p2p_device.device_address,
+    )
+    logging.info('Established wifi p2p connection.')
+
+
+def _wait_peer_connected(
+    broadcast_receiver: callback_handler_v2.CallbackHandlerV2, peer_address: str
+):
+    """Waits for event that indicates expected Wi-Fi p2p peer is connected."""
+
+    def _is_peer_connected(event):
+        devices = constants.WifiP2pDevice.from_dict_list(event.data['peerList'])
+        for device in devices:
+            if (
+                device.device_address == peer_address
+                and device.status == constants.WifiP2pDeviceStatus.CONNECTED
+            ):
+                return True
+        return False
+
+    broadcast_receiver.waitForEvent(
+        event_name=constants.WIFI_P2P_PEERS_CHANGED_ACTION,
+        predicate=_is_peer_connected,
+        timeout=_DEFAULT_TIMEOUT.total_seconds(),
+    )
+
+
+def _wait_connection_notice(
+    broadcast_receiver: callback_handler_v2.CallbackHandlerV2,
+):
+    """Waits for event that indicates a p2p connection is established."""
+
+    def _is_group_formed(event):
+        try:
+            p2p_info = constants.WifiP2pInfo.from_dict(
+                event.data[constants.EVENT_KEY_P2P_INFO]
+            )
+            return p2p_info.group_formed
+        except KeyError:
+            return False
+
+    event = broadcast_receiver.waitForEvent(
+        event_name=constants.WIFI_P2P_CONNECTION_CHANGED_ACTION,
+        predicate=_is_group_formed,
+        timeout=_DEFAULT_TIMEOUT.total_seconds(),
+    )
+
+
+def remove_group_and_verify_disconnected(
+    requester: DeviceState,
+    responder: DeviceState,
+    is_group_negotiation: bool,
+):
+    """Stops p2p connection and verifies disconnection status on devices."""
+    logging.info('Stopping wifi p2p connection.')
+
+    # Clear events in broadcast receiver.
+    _clear_events(requester, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
+    _clear_events(requester, constants.ON_DEVICE_INFO_AVAILABLE)
+    _clear_events(responder, constants.WIFI_P2P_CONNECTION_CHANGED_ACTION)
+    _clear_events(responder, constants.ON_DEVICE_INFO_AVAILABLE)
+
+    # Requester initiates p2p group removal.
+    requester.ad.wifi.wifiP2pRemoveGroup()
+
+    # Check p2p status on requester.
+    _wait_disconnection_notice(requester.broadcast_receiver)
+    _wait_peer_disconnected(
+        requester.broadcast_receiver, responder.p2p_device.device_address
+    )
+    requester.ad.log.debug(
+        'Disconnected with device %s through wifi p2p.',
+        responder.p2p_device.device_address,
+    )
+
+    # Check p2p status on responder.
+    if is_group_negotiation:
+        _wait_disconnection_notice(responder.broadcast_receiver)
+    _wait_peer_disconnected(
+        responder.broadcast_receiver, requester.p2p_device.device_address
+    )
+    responder.ad.log.debug(
+        'Disconnected with device %s through wifi p2p.',
+        requester.p2p_device.device_address,
+    )
+
+    logging.info('Stopped wifi p2p connection.')
+
+
+def _wait_disconnection_notice(broadcast_receiver):
+    """Waits for event that indicates the p2p connection is disconnected."""
+
+    def _is_disconnect_event(event):
+        info = constants.WifiP2pInfo.from_dict(
+            event.data[constants.EVENT_KEY_P2P_INFO]
+        )
+        return not info.group_formed
+
+    broadcast_receiver.waitForEvent(
+        event_name=constants.WIFI_P2P_CONNECTION_CHANGED_ACTION,
+        predicate=_is_disconnect_event,
+        timeout=_DEFAULT_TIMEOUT.total_seconds(),
+    )
+
+
+def _wait_peer_disconnected(broadcast_receiver, target_address):
+    """Waits for event that indicates current Wi-Fi p2p peer is disconnected."""
+
+    def _is_peer_disconnect_event(event):
+        devices = constants.WifiP2pDevice.from_dict_list(
+            event.data[constants.EVENT_KEY_PEER_LIST]
+        )
+        for device in devices:
+            if device.device_address == target_address:
+                return device.status != constants.WifiP2pDeviceStatus.CONNECTED
+        # Target device not found also means it is disconnected.
+        return True
+
+    broadcast_receiver.waitForEvent(
+        event_name=constants.WIFI_P2P_PEERS_CHANGED_ACTION,
+        predicate=_is_peer_disconnect_event,
+        timeout=_DEFAULT_TIMEOUT.total_seconds(),
+    )
+
+
+def _clear_events(device: DeviceState, event_name):
+    """Clears the events with the given name in the broadcast receiver."""
+    all_events = device.broadcast_receiver.getAll(event_name)
+    device.ad.log.debug(
+        'Cleared %d events of event name %s', len(all_events), event_name
+    )
+
+
+def teardown_wifi_p2p(ad: android_device.AndroidDevice):
+    """Destroys all resources initialized in `_setup_wifi_p2p`."""
+    try:
+        ad.wifi.wifiP2pStopPeerDiscovery()
+        ad.wifi.wifiP2pCancelConnect()
+        ad.wifi.wifiP2pRemoveGroup()
+    finally:
+        # Make sure to call `p2pClose`, otherwise `_setup_wifi_p2p` won't be
+        # able to run again.
+        ad.wifi.p2pClose()
+
+
+def add_upnp_local_service(device: DeviceState, config: dict):
+    """Adds p2p local Upnp service."""
+    device.ad.wifi.wifiP2pAddUpnpLocalService(
+        config['uuid'], config['device'], config['services']
+    )
+
+
+def add_bonjour_local_service(device: DeviceState, config: dict):
+    """Adds p2p local Bonjour service."""
+    device.ad.wifi.wifiP2pAddBonjourLocalService(
+        config['instance_name'], config['service_type'], config['txt_map']
+    )
+
+
+def set_upnp_response_listener(
+    device: DeviceState, channel_id: int | None = None
+):
+    """Set response listener for Upnp service."""
+    channel_id = channel_id or device.channel_ids[0]
+    upnp_response_listener = device.ad.wifi.wifiP2pSetUpnpResponseListener(
+        channel_id
+    )
+    device.upnp_response_listeners[channel_id] = upnp_response_listener
+
+
+def set_dns_sd_response_listeners(
+    device: DeviceState, channel_id: int | None = None
+):
+    """Set response listener for Bonjour service."""
+    channel_id = channel_id or device.channel_ids[0]
+    listener = device.ad.wifi.wifiP2pSetDnsSdResponseListeners(channel_id)
+    device.dns_sd_response_listeners[channel_id] = listener
+
+
+def reset_p2p_service_state(
+    ad: android_device.AndroidDevice, channel_id
+):
+    """Clears all p2p service related states on device."""
+    ad.wifi.wifiP2pClearServiceRequests(channel_id)
+    ad.wifi.wifiP2pUnsetDnsSdResponseListeners(channel_id)
+    ad.wifi.wifiP2pUnsetUpnpResponseListener(channel_id)
+    ad.wifi.wifiP2pClearLocalServices(channel_id)
+
+
+def check_discovered_services(
+    requester: DeviceState,
+    expected_src_device_address: str,
+    expected_dns_sd_sequence: Sequence[Sequence[str, dict[str, str]]],
+    expected_dns_txt_sequence: Sequence[Sequence[str, str]],
+    expected_upnp_sequence: Sequence[str],
+    channel_id: int | None = None,
+):
+    """Checks the discovered service responses are as expected.
+
+    This checks all services discovered within the timeout `_DEFAULT_TIMEOUT`.
+    If any expected service sequence is empty, this checks that no such service
+    are received within timeout.
+
+    Args:
+        device: The device that is discovering services.
+        expected_src_device_address: Only check services advertised from this
+            device address.
+        expected_dns_sd_sequence: Expected DNS SD responses.
+        expected_dns_txt_sequence: Expected DNS SD TXT records.
+        expected_upnp_sequence: Expected UPnP services.
+        channel_id: The channel to check for expected services.
+    """
+    channel_id = channel_id or requester.channel_ids[0]
+    start_time = datetime.datetime.now()
+    timeout = _DEFAULT_TIMEOUT
+    check_discovered_dns_sd_response(
+        requester,
+        expected_responses=expected_dns_sd_sequence,
+        expected_src_device_address=expected_src_device_address,
+        channel_id=channel_id,
+        timeout=timeout,
+    )
+    remaining_timeout = timeout - (datetime.datetime.now() - start_time)
+    check_discovered_dns_sd_txt_record(
+        requester,
+        expected_records=expected_dns_txt_sequence,
+        expected_src_device_address=expected_src_device_address,
+        channel_id=channel_id,
+        timeout=remaining_timeout,
+    )
+    remaining_timeout = timeout - (datetime.datetime.now() - start_time)
+    check_discovered_upnp_services(
+        requester,
+        expected_services=expected_upnp_sequence,
+        expected_src_device_address=expected_src_device_address,
+        channel_id=channel_id,
+        timeout=remaining_timeout,
+    )
+
+
+def check_discovered_upnp_services(
+    device: DeviceState,
+    expected_services: Sequence[str],
+    expected_src_device_address: str,
+    channel_id: int | None = None,
+    timeout: datetime.timedelta = _DEFAULT_TIMEOUT,
+):
+    """Check discovered Upnp services.
+
+    If no services are expected, check that no UPnP service appear within
+    timeout. Otherwise, wait for all expected services within timeout.
+
+    This assumes that Upnp service listener is set by
+    `set_upnp_response_listener`.
+
+    Args:
+        device: The device that is discovering Upnp services.
+        expected_services: The expected Upnp services.
+        expected_src_device_address: This only checks services that are from the
+            expected source device.
+        channel_id: The channel to check for expected services.
+        timeout: The wait timeout.
+    """
+    channel_id = channel_id or device.channel_ids[0]
+    callback_handler = device.upnp_response_listeners[channel_id]
+    if len(expected_services) == 0:
+        _check_no_discovered_service(
+            ad=device.ad,
+            callback_handler=callback_handler,
+            event_name=constants.ON_UPNP_SERVICE_AVAILABLE,
+            expected_src_device_address=expected_src_device_address,
+            timeout=timeout,
+        )
+        return
+
+    expected_services = set(expected_services)
+    def _all_service_received(event):
+        nonlocal expected_services
+        src_device = constants.WifiP2pDevice.from_dict(
+            event.data['sourceDevice']
+        )
+        if src_device.device_address != expected_src_device_address:
+            return False
+        for service in event.data['serviceList']:
+            if service in expected_services:
+                device.ad.log.debug('Received upnp services: %s', service)
+                expected_services.remove(service)
+        return len(expected_services) == 0
+
+    device.ad.log.debug('Waiting for UpnP services: %s', expected_services)
+    # Set to a small timeout to allow pulling all received events
+    if timeout.total_seconds() <= 1:
+        timeout = datetime.timedelta(seconds=1)
+    try:
+        callback_handler.waitForEvent(
+            event_name=constants.ON_UPNP_SERVICE_AVAILABLE,
+            predicate=_all_service_received,
+            timeout=timeout.total_seconds(),
+        )
+    except errors.CallbackHandlerTimeoutError as e:
+        asserts.fail(
+            f'{device.ad} Timed out waiting for services: {expected_services}'
+        )
+
+
+def check_discovered_dns_sd_response(
+    device: DeviceState,
+    expected_responses: Sequence[Sequence[str, str]],
+    expected_src_device_address: str,
+    channel_id: int | None = None,
+    timeout: datetime.timedelta = _DEFAULT_TIMEOUT,
+):
+    """Check discovered DNS SD responses.
+
+    If no responses are expected, check that no DNS SD response appear within
+    timeout. Otherwise, wait for all expected responses within timeout.
+
+    This assumes that Bonjour service listener is set by
+    `set_dns_sd_response_listeners`.
+
+    Args:
+        device: The device that is discovering DNS SD responses.
+        expected_responses: The expected DNS SD responses.
+        expected_src_device_address: This only checks services that are from the
+            expected source device.
+        channel_id: The channel to check for expected responses.
+        timeout: The wait timeout.
+    """
+    channel_id = channel_id or device.channel_ids[0]
+    callback_handler = device.dns_sd_response_listeners[channel_id]
+    if not expected_responses:
+        _check_no_discovered_service(
+            device.ad,
+            callback_handler=callback_handler,
+            event_name=constants.ON_DNS_SD_SERVICE_AVAILABLE,
+            expected_src_device_address=expected_src_device_address,
+            timeout=timeout,
+        )
+        return
+
+    expected_responses = list(expected_responses)
+
+    def _all_service_received(event):
+        nonlocal expected_responses
+        src_device = constants.WifiP2pDevice.from_dict(
+            event.data['sourceDevice']
+        )
+        if src_device.device_address != expected_src_device_address:
+            return False
+        registration_type = event.data['registrationType']
+        instance_name = event.data['instanceName']
+        service_tuple = (instance_name, registration_type)
+        device.ad.log.debug('Received DNS SD response: %s', service_tuple)
+        if service_tuple in expected_responses:
+            expected_responses.remove(service_tuple)
+        return len(expected_responses) == 0
+
+    device.ad.log.debug('Waiting for DNS SD services: %s', expected_responses)
+    # Set to a small timeout to allow pulling all received events
+    if timeout.total_seconds() <= 1:
+        timeout = datetime.timedelta(seconds=1)
+    try:
+        callback_handler.waitForEvent(
+            event_name=constants.ON_DNS_SD_SERVICE_AVAILABLE,
+            predicate=_all_service_received,
+            timeout=timeout.total_seconds(),
+        )
+    except errors.CallbackHandlerTimeoutError as e:
+        asserts.fail(
+            f'{device.ad} Timed out waiting for services: {expected_responses}'
+        )
+
+
+def check_discovered_dns_sd_txt_record(
+    device: DeviceState,
+    expected_records: Sequence[Sequence[str, dict[str, str]]],
+    expected_src_device_address: str,
+    channel_id: int | None = None,
+    timeout: datetime.timedelta = _DEFAULT_TIMEOUT,
+):
+    """Check discovered DNS SD TXT records.
+
+    If no records are expected, check that no DNS SD TXT record appear within
+    timeout. Otherwise, wait for all expected records within timeout.
+
+    This assumes that Bonjour service listener is set by
+    `set_dns_sd_response_listeners`.
+
+    Args:
+        device: The device that is discovering DNS SD TXT records.
+        expected_records: The expected DNS SD TXT records.
+        expected_src_device_address: This only checks services that are from the
+            expected source device.
+        channel_id: The channel to check for expected records.
+        timeout: The wait timeout.
+    """
+    channel_id = channel_id or device.channel_ids[0]
+    idx = device.channel_ids.index(channel_id)
+    callback_handler = device.dns_sd_response_listeners[idx]
+    if not expected_records:
+        _check_no_discovered_service(
+            device.ad,
+            callback_handler=callback_handler,
+            event_name=constants.ON_DNS_SD_TXT_RECORD_AVAILABLE,
+            expected_src_device_address=expected_src_device_address,
+            timeout=timeout,
+        )
+        return
+
+    expected_records = list(expected_records)
+    device.ad.log.debug('Expected DNS SD TXT records: %s', expected_records)
+    def _all_service_received(event):
+        nonlocal expected_records
+        src_device = constants.WifiP2pDevice.from_dict(
+            event.data['sourceDevice']
+        )
+        if src_device.device_address != expected_src_device_address:
+            return False
+        full_domain_name = event.data['fullDomainName']
+        txt_record_map = event.data['txtRecordMap']
+        record_to_remove = (full_domain_name, txt_record_map)
+        device.ad.log.debug('Received DNS SD TXT record: %s', record_to_remove)
+        if record_to_remove in expected_records:
+            expected_records.remove(record_to_remove)
+        return len(expected_records) == 0
+
+    device.ad.log.debug('Waiting for DNS SD TXT records: %s', expected_records)
+    # Set to a small timeout to allow pulling all received events
+    if timeout.total_seconds() <= 1:
+        timeout = datetime.timedelta(seconds=1)
+    try:
+        callback_handler.waitForEvent(
+            event_name=constants.ON_DNS_SD_TXT_RECORD_AVAILABLE,
+            predicate=_all_service_received,
+            timeout=timeout.total_seconds(),
+        )
+    except errors.CallbackHandlerTimeoutError as e:
+        asserts.fail(
+            f'{device.ad} Timed out waiting for services: {expected_records}'
+        )
+
+
+def _check_no_discovered_service(
+    ad: android_device.AndroidDevice,
+    callback_handler: callback_handler_v2.CallbackHandlerV2,
+    event_name: str,
+    expected_src_device_address: str,
+    timeout: datetime.timedelta = _DEFAULT_TIMEOUT,
+):
+    """Checks that no service is received from the specified source device."""
+    def _is_expected_event(event):
+        src_device = constants.WifiP2pDevice.from_dict(
+            event.data['sourceDevice']
+        )
+        return src_device.device_address == expected_src_device_address
+
+    # Set to a small timeout to allow pulling all received events
+    if timeout.total_seconds() <= 1:
+        timeout = datetime.timedelta(seconds=1)
+    try:
+        event = callback_handler.waitForEvent(
+            event_name=event_name,
+            predicate=_is_expected_event,
+            timeout=timeout.total_seconds(),
+        )
+    except errors.CallbackHandlerTimeoutError as e:
+        # Timeout error is expected as there should not be any qualified service
+        return
+    asserts.assert_is_none(
+        event,
+        f'{ad} should not discover p2p service. Discovered: {event}',
+    )
diff --git a/tests/hostsidetests/multidevices/test/direct/service_discovery_test.py b/tests/hostsidetests/multidevices/test/direct/service_discovery_test.py
new file mode 100644
index 0000000000..4f0bbe1f25
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/service_discovery_test.py
@@ -0,0 +1,632 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Test cases for Wi-Fi p2p service discovery."""
+from collections.abc import Sequence
+import logging
+
+from android.platform.test.annotations import ApiTest
+from direct import constants
+from direct import p2p_utils
+from mobly import asserts
+from mobly import base_test
+from mobly import records
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+
+import wifi_test_utils
+
+
+@ApiTest(
+    [
+        "android.net.wifi.p2p.WifiP2pManager#discoverServices(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)",
+        "android.net.wifi.p2p.WifiP2pManager#addServiceRequest(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.WifiP2pServiceRequest, android.net.wifi.p2p.WifiP2pManager.ActionListener)",
+        "android.net.wifi.p2p.WifiP2pManager#setUpnpServiceResponseListener(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.UpnpServiceResponseListener)",
+        "android.net.wifi.p2p.WifiP2pManager#setDnsSdResponseListeners(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.DnsSdServiceResponseListener, android.net.wifi.p2p.WifiP2pManager.DnsSdTxtRecordListener)",
+        "android.net.wifi.p2p.WifiP2pManager#removeServiceRequest(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.WifiP2pServiceRequest, android.net.wifi.p2p.WifiP2pManager.ActionListener)",
+        "android.net.wifi.p2p.WifiP2pManager#clearServiceRequests(android.net.wifi.p2p.WifiP2pManager.Channel, android.net.wifi.p2p.WifiP2pManager.ActionListener)"
+    ]
+)
+class ServiceDiscoveryTest(base_test.BaseTestClass):
+    """Test cases for Wi-Fi p2p service discovery.
+
+    Test Preconditions:
+        Two Android phones that support Wi-Fi Direct.
+
+    Test steps are described in the docstring of each test case.
+    """
+
+    ads: Sequence[android_device.AndroidDevice]
+    responder_ad: android_device.AndroidDevice
+    requester_ad: android_device.AndroidDevice
+
+    def setup_class(self) -> None:
+        super().setup_class()
+        self.ads = self.register_controller(android_device, min_number=2)
+        utils.concurrent_exec(
+            self._setup_device,
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=True,
+        )
+        self.responder_ad, self.requester_ad, *_ = self.ads
+        self.responder_ad.debug_tag = (
+            f'{self.responder_ad.serial}(Responder)'
+        )
+        self.requester_ad.debug_tag = f'{self.requester_ad.serial}(Requester)'
+
+    def _setup_device(self, ad: android_device.AndroidDevice) -> None:
+        ad.load_snippet('wifi', constants.WIFI_SNIPPET_PACKAGE_NAME)
+        wifi_test_utils.set_screen_on_and_unlock(ad)
+        wifi_test_utils.enable_wifi_verbose_logging(ad)
+        # Clear all saved Wi-Fi networks.
+        ad.wifi.wifiDisable()
+        ad.wifi.wifiClearConfiguredNetworks()
+        ad.wifi.wifiEnable()
+
+    def test_search_all_services_01(self) -> None:
+        """Searches all p2p services with API
+        `WifiP2pServiceRequest.newInstance(WifiP2pServiceInfo.SERVICE_TYPE_ALL)`.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Add service request on another device (requester) with API
+               `WifiP2pServiceRequest.newInstance(WifiP2pServiceInfo.SERVICE_TYPE_ALL)`.
+            4. Initiate p2p service discovery on the requester. Verify that the requester
+               discovers all services.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        requester.ad.wifi.wifiP2pAddServiceRequest(
+            constants.ServiceType.ALL
+        )
+        self._search_p2p_services(
+            responder,
+            requester,
+            expected_dns_sd_sequence=constants.ServiceData.ALL_DNS_SD,
+            expected_dns_txt_sequence=constants.ServiceData.ALL_DNS_TXT,
+            expected_upnp_sequence=constants.ServiceData.ALL_UPNP_SERVICES,
+        )
+
+    def test_search_all_services_02(self) -> None:
+        """Searches all p2p services with API
+        `WifiP2pServiceRequest.newInstance(SERVICE_TYPE_BONJOUR/SERVICE_TYPE_UPNP)`
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Add service request on another device (requester) with API
+               `WifiP2pServiceRequest.newInstance(SERVICE_TYPE_BONJOUR)` and
+               `WifiP2pServiceRequest.newInstance(SERVICE_TYPE_UPNP)`.
+            4. Initiate p2p service discovery on the requester. Verify that the requester discovers
+               all services.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        requester.ad.wifi.wifiP2pAddServiceRequest(
+            constants.ServiceType.BONJOUR,
+        )
+        requester.ad.wifi.wifiP2pAddServiceRequest(
+            constants.ServiceType.UPNP,
+        )
+        self._search_p2p_services(
+            responder,
+            requester,
+            expected_dns_sd_sequence=constants.ServiceData.ALL_DNS_SD,
+            expected_dns_txt_sequence=constants.ServiceData.ALL_DNS_TXT,
+            expected_upnp_sequence=constants.ServiceData.ALL_UPNP_SERVICES,
+        )
+
+    def test_search_all_services_03(self) -> None:
+        """Searches all p2p services with API `WifiP2pDnsSdServiceRequest.newInstance()`
+        and `WifiP2pUpnpServiceRequest.newInstance()`.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Add service request on another device (requester) with API
+               `WifiP2pUpnpServiceRequest.newInstance()` and
+               `WifiP2pDnsSdServiceRequest.newInstance()`.
+            4. Initiate p2p service discovery on the requester. Verify that the requester discovers
+               all services.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        requester.ad.wifi.wifiP2pAddBonjourServiceRequest()
+        requester.ad.wifi.wifiP2pAddUpnpServiceRequest()
+        self._search_p2p_services(
+            responder,
+            requester,
+            expected_dns_sd_sequence=constants.ServiceData.ALL_DNS_SD,
+            expected_dns_txt_sequence=constants.ServiceData.ALL_DNS_TXT,
+            expected_upnp_sequence=constants.ServiceData.ALL_UPNP_SERVICES,
+        )
+
+    def test_serv_req_dns_ptr(self) -> None:
+        """Searches Bonjour services with Bonjour domain.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Add Bonjour service request with service type `_ipp._tcp`.
+            4. Initiate p2p service discovery on the requester. Verify that the requester discovers
+               expected services.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        requester.ad.wifi.wifiP2pAddBonjourServiceRequest(
+            None,  # instanceName
+            '_ipp._tcp',
+        )
+        self._search_p2p_services(
+            responder,
+            requester,
+            expected_dns_sd_sequence=constants.ServiceData.IPP_DNS_SD,
+            expected_dns_txt_sequence=(),
+            expected_upnp_sequence=(),
+        )
+
+    def test_serv_req_dns_txt(self) -> None:
+        """Searches Bonjour services with TXT record.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Add Bonjour service request with instance name `MyPrinter` and
+               service type `_ipp._tcp`.
+            4. Initiate p2p service discovery on the requester. Verify that the requester discovers
+               expected services.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        requester.ad.wifi.wifiP2pAddBonjourServiceRequest(
+            'MyPrinter',
+            '_ipp._tcp',
+        )
+        self._search_p2p_services(
+            responder,
+            requester,
+            expected_dns_sd_sequence=(),
+            expected_dns_txt_sequence=constants.ServiceData.IPP_DNS_TXT,
+            expected_upnp_sequence=(),
+        )
+
+    def test_serv_req_upnp_all(self) -> None:
+        """Searches all UPnP services with service type `ssdp:all`.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Add UPnP service request with service type `ssdp:all`.
+            4. Initiate p2p service discovery on the requester. Verify that the requester discovers
+               expected services.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        requester.ad.wifi.wifiP2pAddUpnpServiceRequest('ssdp:all')
+        self._search_p2p_services(
+            responder,
+            requester,
+            expected_dns_sd_sequence=(),
+            expected_dns_txt_sequence=(),
+            expected_upnp_sequence=constants.ServiceData.ALL_UPNP_SERVICES,
+        )
+
+    def test_serv_req_upnp_root_device(self) -> None:
+        """Searches UPnP root devices.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Add UPnP service request with service type `upnp:rootdevice`.
+            4. Initiate p2p service discovery on the requester. Verify that the requester discovers
+               expected services.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        requester.ad.wifi.wifiP2pAddUpnpServiceRequest('upnp:rootdevice')
+        self._search_p2p_services(
+            responder,
+            requester,
+            expected_dns_sd_sequence=(),
+            expected_dns_txt_sequence=(),
+            expected_upnp_sequence=constants.ServiceData.UPNP_ROOT_DEVICE,
+        )
+
+    def test_serv_req_remove_request(self) -> None:
+        """Checks that API `WifiP2pManager#removeServiceRequest` works well.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Add 2 UPnP service requests and 2 Bonjour service requests on the
+               requester.
+            4. Removes 3 of the 4 added requests.
+            5. Initiate p2p service discovery on the requester. Verify that the requester
+               only discovers services corresponds to the remaining request.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+
+        # Add requests
+        requester.ad.log.info('Adding service requests.')
+        upnp_req_1_id = requester.ad.wifi.wifiP2pAddUpnpServiceRequest()
+        requester.ad.wifi.wifiP2pAddUpnpServiceRequest('ssdp:all')
+        bonjour_req_1_id = requester.ad.wifi.wifiP2pAddBonjourServiceRequest()
+        bonjour_req_2_id = requester.ad.wifi.wifiP2pAddBonjourServiceRequest(
+            None,  # instanceName
+            '_ipp._tcp',
+        )
+
+        # Remove 3 of the 4 added requests except for ssdp:all
+        requester.ad.log.info('Removing service requests.')
+        requester.ad.wifi.wifiP2pRemoveServiceRequest(upnp_req_1_id)
+        requester.ad.wifi.wifiP2pRemoveServiceRequest(bonjour_req_1_id)
+        requester.ad.wifi.wifiP2pRemoveServiceRequest(bonjour_req_2_id)
+
+        # Initialize test listener.
+        p2p_utils.set_upnp_response_listener(requester)
+        p2p_utils.set_dns_sd_response_listeners(requester)
+        # Search service
+        requester.ad.wifi.wifiP2pDiscoverServices()
+
+        # Initiates service discovery and check expected services.
+        p2p_utils.check_discovered_services(
+            requester,
+            responder.p2p_device.device_address,
+            expected_dns_sd_sequence=(),
+            expected_dns_txt_sequence=(),
+            expected_upnp_sequence=constants.ServiceData.ALL_UPNP_SERVICES
+        )
+
+    def test_serv_req_clear_request(self) -> None:
+        """Checks that API `WifiP2pManager#clearServiceRequests` works well.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Add 2 UPnP service requests and 2 Bonjour service requests on the
+               requester.
+            4. Clears all added requests.
+            5. Initiate p2p service discovery on the requester. Verify that the service
+               discovery should fail due to no service request.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+
+        # Add requests
+        requester.ad.log.info('Adding service requests.')
+        requester.ad.wifi.wifiP2pAddUpnpServiceRequest()
+        requester.ad.wifi.wifiP2pAddUpnpServiceRequest('ssdp:all')
+        requester.ad.wifi.wifiP2pAddBonjourServiceRequest()
+        requester.ad.wifi.wifiP2pAddBonjourServiceRequest(
+            None,  # instanceName
+            '_ipp._tcp',
+        )
+
+        # Clear requests
+        requester.ad.log.info('Clearing all service requests.')
+        requester.ad.wifi.wifiP2pClearServiceRequests()
+
+        # Search services, but NO_SERVICE_REQUESTS is returned.
+        requester.ad.log.info('Initiating service discovery.')
+        expect_error_code = constants.WifiP2pManagerConstants.NO_SERVICE_REQUESTS
+        with asserts.assert_raises_regex(
+            Exception,
+            f'reason_code={str(expect_error_code)}',
+            extras='Service discovery should fail due to no service request.',
+        ):
+            requester.ad.wifi.wifiP2pDiscoverServices()
+
+    def test_serv_req_multi_channel_01(self) -> None:
+        """Searches all UPnP services on channel1 and all Bonjour services on
+        channel2.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices. This initializes p2p channel
+               channel1.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Initialize an extra p2p channel channel2 on another device (requester).
+            4. Add a UPnP service request to channel1.
+            5. Add a Bonjour request to channel2.
+            6. Initiate p2p service discovery on channel1. Verify that the requester
+               discovers UPnP services on channel1 and Bonjour services on channel2.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        channel1 = requester.channel_ids[0]
+        channel2 = p2p_utils.init_extra_channel(requester)
+
+        requester.ad.log.info('Adding service requests.')
+        # Add UPnP request to the channel 1.
+        requester.ad.wifi.wifiP2pAddUpnpServiceRequest(
+            None,  # serviceType
+            channel1,
+        )
+        # Add UPnP request to channel 2.
+        requester.ad.wifi.wifiP2pAddBonjourServiceRequest(
+            None,  # instanceName
+            None,  # serviceType
+            channel2,
+        )
+
+        # Set service listener.
+        requester.ad.log.info('Setting service listeners.')
+        p2p_utils.set_upnp_response_listener(requester, channel1)
+        p2p_utils.set_dns_sd_response_listeners(requester, channel1)
+        p2p_utils.set_upnp_response_listener(requester, channel2)
+        p2p_utils.set_dns_sd_response_listeners(requester, channel2)
+
+        # Discover services
+        requester.ad.log.info('Initiating service discovery.')
+        requester.ad.wifi.wifiP2pDiscoverServices(channel1)
+        responder_address = responder.p2p_device.device_address
+
+        # Check discovered services
+        # Channel1 receive only UPnP service.
+        requester.ad.log.info('Checking services on channel %d.', channel1)
+        p2p_utils.check_discovered_services(
+            requester,
+            responder.p2p_device.device_address,
+            expected_dns_sd_sequence=(),
+            expected_dns_txt_sequence=(),
+            expected_upnp_sequence=constants.ServiceData.ALL_UPNP_SERVICES,
+            channel_id=channel1,
+        )
+        # Channel2 receive only Bonjour service.
+        requester.ad.log.info('Checking services on channel %d.', channel2)
+        p2p_utils.check_discovered_services(
+            requester,
+            responder.p2p_device.device_address,
+            expected_dns_sd_sequence=constants.ServiceData.ALL_DNS_SD,
+            expected_dns_txt_sequence=constants.ServiceData.ALL_DNS_TXT,
+            expected_upnp_sequence=(),
+            channel_id=channel2,
+        )
+
+        # Clean up.
+        p2p_utils.reset_p2p_service_state(requester.ad, channel1)
+        p2p_utils.reset_p2p_service_state(requester.ad, channel2)
+
+    def test_serv_req_multi_channel_02(self) -> None:
+        """Searches Bonjour IPP PTR service on channel1 and AFP TXT service on channel2.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices. This initializes p2p channel
+               channel1.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Initialize an extra p2p channel channel2 on another device (requester).
+            4. Add a Bonjour IPP PTR request to channel1.
+            5. Add a Bonjour AFP TXT request to channel2.
+            6. Initiate p2p service discovery on channel1. Verify that the requester
+               discovers IPP PTR services on channel1 and AFP TXT services on channel2.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        channel1 = requester.channel_ids[0]
+        channel2 = p2p_utils.init_extra_channel(requester)
+
+        # Add Bonjour IPP PRT request to channel1.
+        requester.ad.log.info('Adding service requests.')
+        requester.ad.wifi.wifiP2pAddBonjourServiceRequest(
+            None,  # instanceName
+            '_ipp._tcp',
+            channel1,
+        )
+
+        # Add Bonjour AFP TXT request to channel2.
+        requester.ad.wifi.wifiP2pAddBonjourServiceRequest(
+            'Example',
+            '_afpovertcp._tcp',
+            channel2,
+        )
+
+        # Initialize listener test objects.
+        requester.ad.log.info('Setting service listeners.')
+        p2p_utils.set_upnp_response_listener(requester, channel1)
+        p2p_utils.set_dns_sd_response_listeners(requester, channel1)
+        p2p_utils.set_upnp_response_listener(requester, channel2)
+        p2p_utils.set_dns_sd_response_listeners(requester, channel2)
+
+        # Discover services
+        requester.ad.log.info('Initiating service discovery.')
+        requester.ad.wifi.wifiP2pDiscoverServices(channel1)
+        responder_address = responder.p2p_device.device_address
+
+        # Check discovered services
+        # Channel1 receive only Bonjour IPP PTR.
+        requester.ad.log.info('Checking services on channel %d.', channel1)
+        p2p_utils.check_discovered_services(
+            requester,
+            responder.p2p_device.device_address,
+            expected_dns_sd_sequence=constants.ServiceData.IPP_DNS_SD,
+            expected_dns_txt_sequence=(),
+            expected_upnp_sequence=(),
+            channel_id=channel1,
+        )
+        # Channel2 receive only Bonjour AFP TXT.
+        requester.ad.log.info('Checking services on channel %d.', channel2)
+        p2p_utils.check_discovered_services(
+            requester,
+            responder.p2p_device.device_address,
+            expected_dns_sd_sequence=(),
+            expected_dns_txt_sequence=constants.ServiceData.AFP_DNS_TXT,
+            expected_upnp_sequence=(),
+            channel_id=channel2,
+        )
+
+        # Clean up.
+        p2p_utils.reset_p2p_service_state(requester.ad, channel1)
+        p2p_utils.reset_p2p_service_state(requester.ad, channel2)
+
+    def test_serv_req_multi_channel_03(self) -> None:
+        """Checks that `removeServiceRequest` and `clearServiceRequests` have no
+        effect against another channel.
+
+        Test Steps:
+            1. Initialize Wi-Fi p2p on both devices. This initializes p2p channel
+               channel1.
+            2. Add local services UPnP and Bonjour and initiate peer discovery on one device
+               (responder).
+            3. Initialize an extra p2p channel channel2 on another device (requester).
+            4. Add a Bonjour request to channel1.
+            5. Try to remove the request of channel1 on channel2. This should
+               not have effect.
+            6. Try to clear service requests on channel2. This should not have
+               effect.
+            4. Add a Bonjour request to channel2.
+            5. Initiate p2p service discovery on channel1. Verify that the requester
+               discovers Bonjour services but not UPnP services on channel1.
+        """
+        requester, responder = self._setup_wifi_p2p()
+        self._add_p2p_services(responder)
+        channel1 = requester.channel_ids[0]
+        channel2 = p2p_utils.init_extra_channel(requester)
+
+        # Add Bonjour request to channel1.
+        requester.ad.log.info('Adding service request to channel %d', channel1)
+        bonjour_req_id = requester.ad.wifi.wifiP2pAddBonjourServiceRequest(
+            None,  # instanceName
+            None,  # serviceType
+            channel1,
+        )
+        requester.ad.log.info('Added request %d', bonjour_req_id)
+
+        # Try to remove the Bonjour request of channel1 on channel2.
+        # However, it should silently succeed but have no effect
+        requester.ad.log.info('Removing the request %d from channel %d', bonjour_req_id, channel1)
+        requester.ad.wifi.wifiP2pRemoveServiceRequest(bonjour_req_id, channel2)
+
+        # Clear the all requests on channel2.
+        # However, it should silently succeed but have no effect
+        requester.ad.log.info('Clearing service requests on channel %d', channel2)
+        requester.ad.wifi.wifiP2pClearServiceRequests(channel2)
+
+        # Initialize service listeners.
+        requester.ad.log.info('Setting service listeners on both channels.')
+        p2p_utils.set_upnp_response_listener(requester, channel1)
+        p2p_utils.set_dns_sd_response_listeners(requester, channel1)
+        p2p_utils.set_upnp_response_listener(requester, channel2)
+        p2p_utils.set_dns_sd_response_listeners(requester, channel2)
+
+        # Discover services
+        requester.ad.log.info('Initiating service discovery.')
+        requester.ad.wifi.wifiP2pDiscoverServices(channel1)
+        responder_address = responder.p2p_device.device_address
+
+        # Check that Bonjour response can be received on channel1
+        requester.ad.log.info('Checking Bonjour services on channel %d.', channel1)
+        p2p_utils.check_discovered_services(
+            requester,
+            responder.p2p_device.device_address,
+            expected_dns_sd_sequence=constants.ServiceData.ALL_DNS_SD,
+            expected_dns_txt_sequence=constants.ServiceData.AFP_DNS_TXT,
+            expected_upnp_sequence=(),
+            channel_id=channel1,
+        )
+
+        # Clean up.
+        p2p_utils.reset_p2p_service_state(requester.ad, channel1)
+        p2p_utils.reset_p2p_service_state(requester.ad, channel2)
+
+    def _search_p2p_services(
+        self,
+        responder: p2p_utils.DeviceState,
+        requester: p2p_utils.DeviceState,
+        expected_dns_sd_sequence: Sequence[Sequence[str, dict[str, str]]],
+        expected_dns_txt_sequence: Sequence[Sequence[str, str]],
+        expected_upnp_sequence: Sequence[str],
+    ) -> None:
+        """Initiate service discovery and assert expected p2p services are discovered.
+
+        Args:
+            responder: The responder device state.
+            requester: The requester device state.
+            expected_dns_sd_sequence: Expected DNS-SD responses.
+            expected_dns_txt_sequence: Expected DNS TXT records.
+            expected_upnp_sequence: Expected UPNP services.
+        """
+        requester.ad.log.info('Initiating service discovery.')
+        p2p_utils.set_upnp_response_listener(requester)
+        p2p_utils.set_dns_sd_response_listeners(requester)
+        requester.ad.wifi.wifiP2pDiscoverServices()
+
+        requester.ad.log.info('Checking discovered services.')
+        p2p_utils.check_discovered_services(
+            requester,
+            responder.p2p_device.device_address,
+            expected_dns_sd_sequence=expected_dns_sd_sequence,
+            expected_dns_txt_sequence=expected_dns_txt_sequence,
+            expected_upnp_sequence=expected_upnp_sequence,
+        )
+
+    def _add_p2p_services(self, responder: p2p_utils.DeviceState):
+        """Sets up P2P services on the responder device.
+
+        This method adds local UPNP and Bonjour services to the responder device and
+        initiates peer discovery.
+        """
+        responder.ad.log.info('Setting up p2p local services UpnP and Bonjour.')
+        p2p_utils.add_upnp_local_service(
+            responder, constants.ServiceData.DEFAULT_UPNP_SERVICE_CONF
+        )
+        p2p_utils.add_bonjour_local_service(
+            responder, constants.ServiceData.DEFAULT_IPP_SERVICE_CONF
+        )
+        p2p_utils.add_bonjour_local_service(
+            responder, constants.ServiceData.DEFAULT_AFP_SERVICE_CONF
+        )
+        responder.ad.wifi.wifiP2pDiscoverPeers()
+
+    def _setup_wifi_p2p(self):
+        logging.info('Initializing Wi-Fi p2p.')
+        responder = p2p_utils.setup_wifi_p2p(self.responder_ad)
+        requester = p2p_utils.setup_wifi_p2p(self.requester_ad)
+        return requester, responder
+
+    def _teardown_wifi_p2p(self, ad: android_device.AndroidDevice):
+        try:
+            p2p_utils.teardown_wifi_p2p(ad)
+        finally:
+            ad.services.create_output_excerpts_all(self.current_test_info)
+
+    def teardown_test(self) -> None:
+        utils.concurrent_exec(
+            self._teardown_wifi_p2p,
+            param_list=[[ad] for ad in self.ads],
+            raise_on_exception=False,
+        )
+
+    def on_fail(self, record: records.TestResult) -> None:
+        logging.info('Collecting bugreports...')
+        android_device.take_bug_reports(
+            self.ads, destination=self.current_test_info.output_path
+        )
+
+
+if __name__ == '__main__':
+    test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/direct/wifi_direct_test_suite.py b/tests/hostsidetests/multidevices/test/direct/wifi_direct_test_suite.py
new file mode 100644
index 0000000000..6598e39648
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/direct/wifi_direct_test_suite.py
@@ -0,0 +1,41 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Wi-Fi Direct test suite."""
+
+from mobly import base_suite
+from mobly import suite_runner
+
+from direct import group_owner_negotiation_test
+from direct import group_owner_test
+from direct import group_owner_with_config_test
+from direct import service_discovery_test
+
+
+class WifiDirectTestSuite(base_suite.BaseSuite):
+    """Wi-Fi Direct test suite."""
+
+    def setup_suite(self, config):
+        del config  # unused
+        self.add_test_class(
+            group_owner_negotiation_test.GroupOwnerNegotiationTest
+        )
+        self.add_test_class(group_owner_test.GroupOwnerTest)
+        self.add_test_class(group_owner_with_config_test.GroupOwnerWithConfigTest)
+        self.add_test_class(service_discovery_test.ServiceDiscoveryTest)
+
+
+if __name__ == '__main__':
+    suite_runner.run_suite_class()
diff --git a/tests/hostsidetests/multidevices/test/requirements.txt b/tests/hostsidetests/multidevices/test/requirements.txt
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/hostsidetests/multidevices/test/softap/AndroidTest.xml b/tests/hostsidetests/multidevices/test/softap/AndroidTest.xml
new file mode 100644
index 0000000000..26ddcdd877
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/softap/AndroidTest.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+          http://www.apache.org/licenses/LICENSE-2.0
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Wifi SoftAp multi-device CTS tests">
+    <option name="test-suite-tag" value="cts-v-host" />
+    <option name="config-descriptor:metadata" key="component" value="wifi" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_instant_app" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+    <option name="config-descriptor:metadata" key="parameter" value="secondary_user" />
+
+    <device name="AndroidDevice">
+        <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+            <option name="required_feature" value="android.hardware.wifi" />
+        </target_preparer>
+        <target_preparer class="AndroidInstallAppsDecorator" />
+    </device>
+    <device name="AndroidDevice">
+        <target_preparer class="AndroidDeviceFeaturesCheckDecorator">
+            <option name="required_feature" value="android.hardware.wifi" />
+        </target_preparer>
+        <target_preparer class="AndroidInstallAppsDecorator" />
+    </device>
+
+    <test class="MoblyAospPackageTest" />
+
+    <option name="mobly_pkg" key="file" value="CtsWifiSoftApTestCases" />
+    <option name="build_apk" key="file" value="wifi_mobly_snippet.apk" />
+</configuration>
\ No newline at end of file
diff --git a/tests/hostsidetests/multidevices/test/softap/constants.py b/tests/hostsidetests/multidevices/test/softap/constants.py
new file mode 100644
index 0000000000..535b30c109
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/softap/constants.py
@@ -0,0 +1,87 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Constants for SoftAp Mobly test."""
+
+import datetime
+import enum
+
+
+# Timeout duration for receiving callbacks
+CALLBACK_TIMEOUT = datetime.timedelta(seconds=10)
+# Wi-Fi scan result interval
+WIFI_SCAN_INTERVAL_SEC = datetime.timedelta(seconds=5)
+
+
+@enum.unique
+class LocalOnlyHotspotCallbackEventName(enum.StrEnum):
+  """Event names for WifiManager#LocalOnlyHotspotCallback."""
+
+  ON_STARTED = 'onStarted'
+  ON_FAILED = 'onFailed'
+
+
+@enum.unique
+class LocalOnlyOnStartedDataKey(enum.StrEnum):
+  """Data keys received from LocalOnlyHotspotCallback#onStarted."""
+
+  SSID = 'ssid'
+  PASSPHRASE = 'passphrase'
+
+
+@enum.unique
+class LocalOnlyOnFailedDataKey(enum.StrEnum):
+  """Data keys received from LocalOnlyHotspotCallback#onFailed."""
+
+  REASON = 'reason'
+
+
+@enum.unique
+class StartTetheringCallbackEventName(enum.StrEnum):
+  """Event names for TetheringManager#StartTetheringCallback."""
+
+  ON_TETHERING_STARTED = 'onTetheringStarted'
+  ON_TETHERING_FAILED = 'onTetheringFailed'
+
+
+@enum.unique
+class TetheringOnTetheringFailedDataKey(enum.StrEnum):
+  """Data keys received from the StartTetheringCallback#onTetheringFailed."""
+
+  ERROR = 'error'
+
+
+@enum.unique
+class SoftApCallbackEventName(enum.StrEnum):
+  """Event names for WifiManager#SoftApCallback."""
+
+  ON_CONNECTED_CLIENTS_CHANGED = 'onConnectedClientsChanged'
+  ON_CLIENTS_DISCONNECTED = 'onClientsDisconnected'
+
+
+@enum.unique
+class SoftApOnConnectedClientsChangedDataKey(enum.StrEnum):
+  """Data keys received from SoftApCallback#onConnectedClientsChanged."""
+
+  CONNECTED_CLIENTS_COUNT = 'connectedClientsCount'
+  CLIENT_MAC_ADDRESS = 'clientMacAddress'
+
+
+@enum.unique
+class SoftApOnClientsDisconnectedDataKey(enum.StrEnum):
+  """Data keys received from SoftApCallback#onClientsDisconnected."""
+
+  DISCONNECTED_CLIENTS_COUNT = 'disconnectedClientsCount'
+  CLIENT_MAC_ADDRESS = 'clientMacAddress'
diff --git a/tests/hostsidetests/multidevices/test/softap/wifi_softap_test.py b/tests/hostsidetests/multidevices/test/softap/wifi_softap_test.py
new file mode 100644
index 0000000000..e96671c9c1
--- /dev/null
+++ b/tests/hostsidetests/multidevices/test/softap/wifi_softap_test.py
@@ -0,0 +1,322 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+import time
+
+from mobly import asserts
+from mobly import base_test
+from mobly import test_runner
+from mobly import utils
+from mobly.controllers import android_device
+from mobly.controllers.android_device_lib import callback_handler_v2
+from mobly.snippet import errors
+from softap import constants
+import wifi_test_utils
+
+_CALLBACK_TIMEOUT = constants.CALLBACK_TIMEOUT.total_seconds()
+_WIFI_SCAN_INTERVAL_SEC = constants.WIFI_SCAN_INTERVAL_SEC.total_seconds()
+
+
+class WifiSoftApTest(base_test.BaseTestClass):
+  """SoftAp test class.
+
+  Attributes:
+    host: Android device providing Wi-Fi hotspot
+    client: Android device connecting to host provided hotspot
+  """
+
+  def setup_class(self) -> None:
+    self.ads = self.register_controller(android_device, min_number=2)
+    self.host = self.ads[0]
+    self.client = self.ads[1]
+    utils.concurrent_exec(
+        self._setup_device,
+        param_list=[[ad] for ad in self.ads],
+        raise_on_exception=True,
+    )
+
+    asserts.abort_class_if(
+        not self.host.wifi.wifiIsPortableHotspotSupported(),
+        'Hotspot is not supported on host, abort remaining tests.',
+    )
+
+  def _setup_device(self, ad: android_device.AndroidDevice) -> None:
+    ad.load_snippet('wifi', 'com.google.snippet.wifi')
+    wifi_test_utils.enable_wifi_verbose_logging(ad)
+
+  def setup_test(self):
+    for ad in self.ads:
+      self._stop_tethering(self.host)
+      ad.wifi.wifiDisableAllSavedNetworks()
+      ad.wifi.wifiEnable()
+
+  def teardown_class(self):
+    for ad in self.ads:
+      ad.wifi.wifiEnableAllSavedNetworks()
+      ad.wifi.wifiEnable()
+
+  def _test_softap_disconnect(self, use_local_only: bool):
+    """Tests SoftApCallback#onClientsDisconnected callback.
+
+    Steps:
+    1. Start host's hotspot and verify it is enabled.
+    2. Register SoftApCallback
+    3. Add client to the hotspot and verify connection.
+    4. Disconnect the client and verify disconnection.
+
+    Args:
+      use_local_only: True to test local-only hotspot, False to test tethering.
+    """
+    asserts.skip_if(
+        not self.host.wifi.wifiCheckSoftApDisconnectReasonFlag(),
+        'Skipping because softap_disconnect_reason flag is not enabled.',
+    )
+
+    # Start host's hotspot and verify that it is enabled
+    # and register SoftApCallback.
+    if use_local_only:
+      callback = self.host.wifi.wifiStartLocalOnlyHotspot()
+      ssid, password = self._wait_for_local_only_on_started(callback)
+      softap_callback = (
+          self.host.wifi.wifiRegisterLocalOnlyHotspotSoftApCallback()
+      )
+    else:
+      callback = self.host.wifi.tetheringStartTethering()
+      ssid, password = self._wait_for_on_tethering_started(callback)
+      softap_callback = self.host.wifi.wifiRegisterSoftApCallback()
+
+    # Add client to the hotspot and verify connection.
+    asserts.assert_true(
+        self._check_wifi_scan_result_for_ssid(self.client, ssid),
+        'Network could not be found in Wi-Fi scan results',
+    )
+    self.client.wifi.wifiConnectSimple(ssid, password)
+    client_mac_address = self._wait_for_on_connected_clients_changed(
+        softap_callback
+    )
+
+    # Disconnect the client and verify disconnection.
+    self.client.wifi.wifiDisable()
+    self._wait_for_on_clients_disconnected(client_mac_address, softap_callback)
+
+    if use_local_only:
+      self.host.wifi.wifiStopLocalOnlyHotspot()
+      self.host.wifi.wifiUnregisterLocalOnlyHotspotSoftApCallback()
+    else:
+      self.host.wifi.tetheringStopTethering()
+      self.host.wifi.wifiUnregisterSoftApCallback()
+
+  def test_local_only_softap_disconnect(self):
+    """Tests local-only SoftAp disconnection."""
+    self._test_softap_disconnect(use_local_only=True)
+
+  def test_tethering_softap_disconnect(self):
+    """Tests tethering SoftAp disconnection."""
+    self._test_softap_disconnect(use_local_only=False)
+
+  def _check_wifi_scan_result_for_ssid(
+      self, ad: android_device.AndroidDevice, ssid: str
+  ) -> bool:
+    """Scan Wi-Fi networks for the network with the given ssid.
+
+    Args:
+      ad: The Android device object.
+      ssid: SSID of the AP.
+
+    Returns:
+      True if SSID is found in Wi-Fi scan results, False otherwise.
+    """
+    # Due to restriction of "scan four times in a 2-minute period" in
+    # https://developer.android.com/guide/topics/connectivity/wifi-scan#wifi-scan-restrictions
+    # this function only scans 4 times looking for the ssid, 5 second
+    # interval between each scan.
+    for _ in range(1, 5):
+      scanned_results = ad.wifi.wifiScanAndGetResults()
+      scanned_ssids = sorted(
+          [scan_result['SSID'] for scan_result in scanned_results]
+      )
+      if ssid in scanned_ssids:
+        return True
+      time.sleep(_WIFI_SCAN_INTERVAL_SEC)
+
+    return False
+
+  def _wait_for_local_only_on_started(
+      self,
+      local_only_cb: callback_handler_v2.CallbackHandlerV2,
+  ) -> tuple[str, str]:
+    """Waits for onStarted callback to be received.
+
+    If local-only hotspot failed to start, the current test is skipped.
+
+    Args:
+      local_only_cb: The LocalOnlyHotspot callback identifier.
+
+    Returns:
+      A tuple containing the credentials of the hotspot session. The
+      tuple is in the form of (ssid of network, passphrase of network).
+    """
+    try:
+      on_started_event = local_only_cb.waitAndGet(
+          event_name=constants.LocalOnlyHotspotCallbackEventName.ON_STARTED,
+          timeout=_CALLBACK_TIMEOUT,
+      )
+    except errors.CallbackHandlerTimeoutError:
+      on_failed_event = local_only_cb.waitAndGet(
+          event_name=constants.LocalOnlyHotspotCallbackEventName.ON_FAILED,
+          timeout=_CALLBACK_TIMEOUT,
+      )
+      failure_reason = on_failed_event.data[
+          constants.LocalOnlyOnFailedDataKey.REASON
+      ]
+      asserts.skip(
+          'Skipping this test because the local-only hotspot '
+          f'could not be started. Reason: {failure_reason}'
+      )
+
+    ssid = on_started_event.data[constants.LocalOnlyOnStartedDataKey.SSID]
+    passphrase = on_started_event.data[
+        constants.LocalOnlyOnStartedDataKey.PASSPHRASE
+    ]
+    return ssid, passphrase
+
+  def _wait_for_on_tethering_started(
+      self,
+      tethering_cb: callback_handler_v2.CallbackHandlerV2,
+  ) -> tuple[str, str]:
+    """Waits for onTetheringStarted callback to be received.
+
+    If tethering failed to start, the current test is skipped.
+
+    Args:
+      tethering_cb: The StartTethering callback identifier.
+
+    Returns:
+      A tuple containing the credentials of the tethering session. The tuple
+      is in the form of (ssid of network, passphrase of network).
+    """
+    try:
+      tethering_cb.waitAndGet(
+          event_name=constants.StartTetheringCallbackEventName.ON_TETHERING_STARTED,
+          timeout=_CALLBACK_TIMEOUT,
+      )
+    except errors.CallbackHandlerTimeoutError:
+      on_tethering_failure_event = tethering_cb.waitAndGet(
+          event_name=constants.StartTetheringCallbackEventName.ON_TETHERING_FAILED,
+          timeout=_CALLBACK_TIMEOUT,
+      )
+      failure_error = on_tethering_failure_event.data[
+          constants.TetheringOnTetheringFailedDataKey.ERROR
+      ]
+      asserts.skip(
+          'Skipping this test because tethering could not be started. Reason:'
+          f' {failure_error}'
+      )
+
+    current_configuration = self.host.wifi.wifiGetSoftApConfiguration()
+    ssid = current_configuration['SSID']
+    passphrase = current_configuration['mPassphrase']
+    return ssid, passphrase
+
+  def _stop_tethering(self, ad: android_device.AndroidDevice) -> bool:
+    """Stops any ongoing tethering sessions on the android device.
+
+    Args:
+      ad: The Android device object.
+
+    Returns:
+      True if tethering is disabled successfully, False otherwise.
+    """
+    if not ad.wifi.wifiIsApEnabled():
+      return True
+
+    ad.wifi.tetheringStopTethering()
+    return ad.wifi.wifiWaitForTetheringDisabled()
+
+  def _wait_for_on_connected_clients_changed(
+      self, softap_callback: callback_handler_v2.CallbackHandlerV2
+  ) -> str:
+    """Wait for SoftApCallback#onConnectedClientsChanged to be received.
+
+    The test fails if the callback is never received. If successful, the
+    mac address of the connected client is returned.
+
+    Args:
+      softap_callback: The SoftApCallback callback identifier.
+
+    Returns:
+      The string mac address of the connected client.
+    """
+    try:
+      on_connected_clients_changed_event = softap_callback.waitAndGet(
+          event_name=(
+              constants.SoftApCallbackEventName.ON_CONNECTED_CLIENTS_CHANGED
+          ),
+          timeout=_CALLBACK_TIMEOUT,
+      )
+    except errors.CallbackHandlerTimeoutError:
+      asserts.fail('Connection could not be established.')
+
+    # In our test cases, there is only one other device involved
+    # so we can confirm that the client has connected.
+    asserts.assert_equal(
+        on_connected_clients_changed_event.data[
+            constants.SoftApOnConnectedClientsChangedDataKey.CONNECTED_CLIENTS_COUNT
+        ],
+        1,
+    )
+
+    return on_connected_clients_changed_event.data[
+        constants.SoftApOnConnectedClientsChangedDataKey.CLIENT_MAC_ADDRESS
+    ]
+
+  def _wait_for_on_clients_disconnected(
+      self,
+      expected_mac_address: str,
+      softap_callback: callback_handler_v2.CallbackHandlerV2,
+  ) -> None:
+    """Wait for SoftApCallback#onClientsDisconnected to be received.
+
+    The test fails if the callback is never received.
+
+    Args:
+      expected_mac_address: Expected mac address of disconnected client
+      softap_callback: The SoftApCallback callback identifier.
+    """
+    try:
+      on_clients_disconnected_event = softap_callback.waitAndGet(
+          event_name='onClientsDisconnected', timeout=_CALLBACK_TIMEOUT
+      )
+    except errors.CallbackHandlerTimeoutError:
+      asserts.fail('No client disconnected.')
+
+    # In our test cases, there is only one other device involved
+    # so we can confirm that the client has disconnected.
+    asserts.assert_equal(
+        on_clients_disconnected_event.data[
+            constants.SoftApOnClientsDisconnectedDataKey.DISCONNECTED_CLIENTS_COUNT
+        ],
+        1,
+    )
+    asserts.assert_equal(
+        on_clients_disconnected_event.data[
+            constants.SoftApOnClientsDisconnectedDataKey.CLIENT_MAC_ADDRESS
+        ],
+        expected_mac_address,
+    )
+
+
+if __name__ == '__main__':
+  test_runner.main()
diff --git a/tests/hostsidetests/multidevices/test/wifi_test_utils.py b/tests/hostsidetests/multidevices/test/wifi_test_utils.py
index 304e52f4de..1dd17c0836 100644
--- a/tests/hostsidetests/multidevices/test/wifi_test_utils.py
+++ b/tests/hostsidetests/multidevices/test/wifi_test_utils.py
@@ -24,3 +24,8 @@ def set_screen_on_and_unlock(ad: android_device.AndroidDevice):
     ad.adb.shell("svc power stayon true")
     ad.adb.shell("input keyevent KEYCODE_WAKEUP")
     ad.adb.shell("wm dismiss-keyguard")
+
+
+def enable_wifi_verbose_logging(ad: android_device.AndroidDevice):
+    """Sets the Wi-Fi verbose logging developer option to Enable."""
+    ad.adb.shell('cmd wifi set-verbose-logging enabled')
```

